{"version":3,"file":"index.umd.js","sources":["../src/CADConstants.js","../src/Hull.js","../src/CADSurfaceLibrary.js","../src/CADTrimSetLibrary.js","../src/CADBodyLibrary.js","../src/CADBody.js","../src/CADAsset.js","../src/CADAssembly.js","../src/CADPart.js","../src/PMIItem.js","../src/PMIView.js","../src/XRef.js","../src/GLSurfaceDrawSet.js","../src/GLCurveDrawSet.js","../src/GLEvaluateCADCurveShader.js","../src/GLCurveLibrary.js","../src/Math/BinReader.js","../src/GLSLBinReader.js","../src/GLSLMath.js","../src/GLSLCADCurves.js","../src/GLSLCADSurfaces.js","../src/GLSLNURBS.js","../src/GLSLNURBSCurves.js","../src/GLSLNURBSSurfaces.js","../src/GLEvaluateCADSurfaceShader.js","../src/GLSurfaceLibrary.js","../src/GLTrimCurveDrawSet.js","../src/GLDrawTrimCurveFansShader.js","../src/GLFlattenTrimSetsShader.js","../src/GLDrawTrimCurveStripsShader.js","../src/GLDebugTrimSetsShader.js","../src/GLTrimSetLibrary.js","../src/GLCADBody.js","../node_modules/rollup-plugin-web-worker-loader/src/WorkerLoaderHelper.js","../src/GLCADAsset.js","../src/GLCADMaterialLibrary.js","../src/GLSLCADConstants.js","../src/GLSLCADSurfaceDrawing.js","../src/GLCADShader.js","../src/GLDrawCADSurfaceNormalsShader.js","../src/GLDrawCADSurfaceShader.js","../src/GLDrawCADSurfaceGeomDataShader.js","../src/GLDrawSelectedCADSurfaceShader.js","../src/GLDrawCADCurveShader.js","../src/GLCADPass.js"],"sourcesContent":["const CADCurveTypes = {\r\n  CURVE_TYPE_LINE: 20,\r\n  CURVE_TYPE_CIRCLE: 21,\r\n  CURVE_TYPE_ELIPSE: 22,\r\n  //  CURVE_TYPE_HYPERBOLA: 23,\r\n  //  CURVE_TYPE_PARABOLA: 24,\r\n  //  CURVE_TYPE_BEZIERCURVE: 25,\r\n  CURVE_TYPE_NURBS_CURVE: 26,\r\n  //  CURVE_TYPE_OFFSET_CURVE: 27,\r\n  //  CURVE_TYPE_TRIMMED_CURVE: 28\r\n}\r\n\r\nconst CADSurfaceTypes = {\r\n  SURFACE_TYPE_PLANE: 0,\r\n  SURFACE_TYPE_CONE: 1,\r\n  SURFACE_TYPE_CYLINDER: 2,\r\n  SURFACE_TYPE_SPHERE: 3,\r\n  SURFACE_TYPE_TORUS: 4,\r\n  SURFACE_TYPE_LINEAR_EXTRUSION: 5,\r\n  SURFACE_TYPE_REVOLUTION: 6,\r\n  //  SURFACE_TYPE_BEZIER_SURFACE: 7,\r\n  SURFACE_TYPE_NURBS_SURFACE: 8,\r\n  SURFACE_TYPE_OFFSET_SURFACE: 9,\r\n  SURFACE_TYPE_TRIMMED_RECT_SURFACE: 10,\r\n  SURFACE_TYPE_POLY_PLANE: 14,\r\n  SURFACE_TYPE_FAN: 15,\r\n  SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN: 16,\r\n}\r\n\r\nconst getCurveTypeName = (id) => {\r\n  switch (id) {\r\n    case CADCurveTypes.CURVE_TYPE_LINE:\r\n      return 'CURVE_TYPE_LINE'\r\n    case CADCurveTypes.CURVE_TYPE_CIRCLE:\r\n      return 'CURVE_TYPE_CIRCLE'\r\n    case CADCurveTypes.CURVE_TYPE_ELIPSE:\r\n      return 'CURVE_TYPE_ELIPSE'\r\n    // case CADCurveTypes.CURVE_TYPE_HYPERBOLA: return 'CURVE_TYPE_HYPERBOLA';\r\n    // case CADCurveTypes.CURVE_TYPE_PARABOLA: return 'CURVE_TYPE_PARABOLA';\r\n    // case CADCurveTypes.CURVE_TYPE_BEZIERCURVE: return 'CURVE_TYPE_BEZIERCURVE';\r\n    case CADCurveTypes.CURVE_TYPE_NURBS_CURVE:\r\n      return 'CURVE_TYPE_NURBS_CURVE'\r\n    // case CADCurveTypes.CURVE_TYPE_OFFSET_CURVE: return 'CURVE_TYPE_OFFSET_CURVE';\r\n    // case CADCurveTypes.CURVE_TYPE_TRIMMED_CURVE: return 'CURVE_TYPE_TRIMMED_CURVE';\r\n  }\r\n}\r\n\r\nconst getSurfaceTypeName = (id) => {\r\n  switch (id) {\r\n    case CADSurfaceTypes.SURFACE_TYPE_PLANE:\r\n      return 'SURFACE_TYPE_PLANE'\r\n    case CADSurfaceTypes.SURFACE_TYPE_CONE:\r\n      return 'SURFACE_TYPE_CONE'\r\n    case CADSurfaceTypes.SURFACE_TYPE_CYLINDER:\r\n      return 'SURFACE_TYPE_CYLINDER'\r\n    case CADSurfaceTypes.SURFACE_TYPE_SPHERE:\r\n      return 'SURFACE_TYPE_SPHERE'\r\n    case CADSurfaceTypes.SURFACE_TYPE_TORUS:\r\n      return 'SURFACE_TYPE_TORUS'\r\n    case CADSurfaceTypes.SURFACE_TYPE_LINEAR_EXTRUSION:\r\n      return 'SURFACE_TYPE_LINEAR_EXTRUSION'\r\n    case CADSurfaceTypes.SURFACE_TYPE_REVOLUTION:\r\n      return 'SURFACE_TYPE_REVOLUTION'\r\n    //    case CADSurfaceTypes.SURFACE_TYPE_BEZIER_SURFACE: return 'SURFACE_TYPE_BEZIER_SURFACE';\r\n    case CADSurfaceTypes.SURFACE_TYPE_NURBS_SURFACE:\r\n      return 'SURFACE_TYPE_NURBS_SURFACE'\r\n    case CADSurfaceTypes.SURFACE_TYPE_OFFSET_SURFACE:\r\n      return 'SURFACE_TYPE_OFFSET_SURFACE'\r\n    case CADSurfaceTypes.SURFACE_TYPE_TRIMMED_RECT_SURFACE:\r\n      return 'SURFACE_TYPE_TRIMMED_RECT_SURFACE'\r\n    case CADSurfaceTypes.SURFACE_TYPE_POLY_PLANE:\r\n      return 'SURFACE_TYPE_POLY_PLANE'\r\n    case CADSurfaceTypes.SURFACE_TYPE_FAN:\r\n      return 'SURFACE_TYPE_FAN'\r\n    case CADSurfaceTypes.SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN:\r\n      return 'SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN'\r\n  }\r\n}\r\n\r\nconst geomLibraryHeaderSize = 8 // 2 FP16 pixels at the start of the GeomLibrary and CurveLibrary\r\n// const pixelsPerDrawItem = 10 // The number of RGBA pixels per draw item.\r\nconst pixelsPerDrawItem = 3 // tr, ori, sc: number of RGBA pixels per draw item.\r\nconst valuesPerCurveTocItem = 8\r\nconst valuesPerSurfaceTocItem = 9\r\nconst valuesPerCurveLibraryLayoutItem = 8\r\nconst valuesPerSurfaceLibraryLayoutItem = 8\r\n//const valuesPerSurfaceRef = 11 // A surfaceRef within a BodyDesc// This is now different based on the version.\r\nconst drawItemShaderAttribsStride = 8\r\nconst floatsPerSceneBody = 2\r\nconst drawShaderAttribsStride = 4 //drawCoords: body ID, Surface index in Body, Surface Id, TrimSet Id // + 2 drawItemTexAddr\r\nconst numValuesPerTrimSetCurveRef = 14 //patchCoords.xyzw, tr.xy, ori.xy, ori.zy, addr.xy, flags, curveId, curveIndexWithinLoop\r\n\r\nconst CURVE_FLAG_PERIODIC = 1 << 0\r\nconst CURVE_FLAG_UNUSED2 = 1 << 2\r\nconst CURVE_FLAG_COST_IS_DETAIL = 1 << 3\r\n\r\nconst SURFACE_FLAG_PERIODIC_U = 1 << 0\r\nconst SURFACE_FLAG_PERIODIC_V = 1 << 1\r\nconst SURFACE_FLAG_UNUSED2 = 1 << 2\r\nconst SURFACE_FLAG_UNUSED3 = 1 << 3\r\nconst SURFACE_FLAG_FLIPPED_NORMAL = 1 << 4\r\nconst SURFACE_FLAG_FLIPPED_UV = 1 << 5\r\nconst SURFACE_FLAG_COST_IS_DETAIL_U = 1 << 6\r\nconst SURFACE_FLAG_COST_IS_DETAIL_V = 1 << 7\r\n\r\nconst BODY_FLAG_CUTAWAY = 1 << 8\r\nconst BODY_FLAG_INVISIBLE = 1 << 9\r\n\r\nexport {\r\n  CADCurveTypes,\r\n  CADSurfaceTypes,\r\n  getCurveTypeName,\r\n  getSurfaceTypeName,\r\n  CURVE_FLAG_COST_IS_DETAIL,\r\n  SURFACE_FLAG_PERIODIC_U,\r\n  SURFACE_FLAG_PERIODIC_V,\r\n  SURFACE_FLAG_COST_IS_DETAIL_U,\r\n  SURFACE_FLAG_COST_IS_DETAIL_V,\r\n  SURFACE_FLAG_FLIPPED_NORMAL,\r\n  SURFACE_FLAG_FLIPPED_UV,\r\n  BODY_FLAG_CUTAWAY,\r\n  BODY_FLAG_INVISIBLE,\r\n  geomLibraryHeaderSize,\r\n  pixelsPerDrawItem,\r\n  valuesPerCurveTocItem,\r\n  valuesPerSurfaceTocItem,\r\n  valuesPerCurveLibraryLayoutItem,\r\n  valuesPerSurfaceLibraryLayoutItem,\r\n  /*valuesPerSurfaceRef,*/\r\n  drawItemShaderAttribsStride,\r\n  drawShaderAttribsStride,\r\n  floatsPerSceneBody,\r\n  numValuesPerTrimSetCurveRef,\r\n}\r\n","import { Lines } from '@zeainc/zea-engine'\r\n\r\n/** Class representing a hull.\r\n * @extends Lines\r\n * @ignore\r\n */\r\nclass Hull extends Lines {\r\n  /**\r\n   * Create a hull.\r\n   * @param {number} numCPsU - The numCPsU value.\r\n   * @param {number} numCPsV - The numCPsV value.\r\n   */\r\n  constructor(numCPsU = 1, numCPsV = 1) {\r\n    super()\r\n    this.__numSpansU = numCPsU - 1\r\n    this.__numSpansV = numCPsV - 1\r\n    this.__rebuild()\r\n  }\r\n\r\n  /**\r\n   * The __rebuild method.\r\n   * @private\r\n   */\r\n  __rebuild() {\r\n    this.setNumVertices((this.__numSpansU + 1) * (this.__numSpansV + 1))\r\n    this.setNumSegments(this.__numSpansU * (this.__numSpansV + 1) + (this.__numSpansU + 1) * this.__numSpansV)\r\n\r\n    let idx = 0\r\n    for (let j = 0; j <= this.__numSpansV; j++) {\r\n      for (let i = 0; i < this.__numSpansU; i++) {\r\n        const v0 = (this.__numSpansU + 1) * j + i\r\n        const v1 = (this.__numSpansU + 1) * j + (i + 1)\r\n        this.setSegmentVertexIndices(idx, v0, v1)\r\n        idx++\r\n      }\r\n    }\r\n    for (let j = 0; j < this.__numSpansV; j++) {\r\n      for (let i = 0; i <= this.__numSpansU; i++) {\r\n        const v0 = (this.__numSpansU + 1) * j + i\r\n        const v1 = (this.__numSpansU + 1) * (j + 1) + i\r\n        this.setSegmentVertexIndices(idx, v0, v1)\r\n        idx++\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport { Hull }\r\n// export default Hull;\r\n","import { Vec2, Vec3, Vec4, Box2, Quat, Color, Plane, Material, BinReader } from '@zeainc/zea-engine'\r\nimport { Hull } from './Hull.js'\r\nimport {\r\n  geomLibraryHeaderSize,\r\n  valuesPerCurveTocItem,\r\n  valuesPerSurfaceTocItem,\r\n  SURFACE_FLAG_PERIODIC_U,\r\n  SURFACE_FLAG_PERIODIC_V,\r\n  CADCurveTypes,\r\n  CADSurfaceTypes,\r\n  getCurveTypeName,\r\n  getSurfaceTypeName,\r\n} from './CADConstants.js'\r\n\r\n/** Class representing a CAD surface library.\r\n * @ignore\r\n */\r\nclass CADSurfaceLibrary {\r\n  /**\r\n   * Create a CAD surface library.\r\n   * @param {any} cadAsset - The cadAsset value.\r\n   * @param {any} trimSetLibrary - The trimSetLibrary value.\r\n   */\r\n  constructor(cadAsset, trimSetLibrary) {\r\n    this.__cadAsset = cadAsset\r\n    this.__trimSetLibrary = trimSetLibrary\r\n    this.__curveLibraryBuffer = undefined\r\n    this.__meshes = []\r\n    this.__hulls = []\r\n    this.__formFactors = {}\r\n\r\n    this.__maxNumKnots = 0\r\n  }\r\n\r\n  /**\r\n   * The setBinaryBuffers method.\r\n   * @param {any} curveLibraryBuffer - The curveLibraryBuffer param.\r\n   * @param {any} surfaceLibraryBuffer - The surfaceLibraryBuffer param.\r\n   * @param {number} version - The version param.\r\n   */\r\n  setBinaryBuffers(curveLibraryBuffer, surfaceLibraryBuffer, cadDataVersion) {\r\n    this.__surfaceLibraryBuffer = surfaceLibraryBuffer\r\n    this.cadDataVersion = cadDataVersion\r\n    this.__surfaceLibraryReader = new BinReader(this.__surfaceLibraryBuffer)\r\n\r\n    this.__surfaceLibrarySize = Math.sqrt(surfaceLibraryBuffer.byteLength / 8) // RGBA16 pixels\r\n    this.__numSurfaces = this.__surfaceLibraryReader.loadUInt32()\r\n    this.__totalSurfaceArea = this.__surfaceLibraryReader.loadFloat32()\r\n\r\n    // this.__totalSurfaceCost = this.__surfaceLibraryReader.loadFloat32();\r\n\r\n    // for (let i = 0; i < this.__numCurves; i++) {\r\n    //   const dims = this.getCurveDims(i);\r\n    //   console.log(this.getCurveTypeLabel(i), \" length:\", dims.length, \" curvature:\", dims.curvature);\r\n    // }\r\n    // for (let i = 0; i < this.__numSurfaces; i++) {\r\n    //   const dims = this.getSurfaceDims(i);\r\n    //   const area = dims.sizeU * dims.sizeV;\r\n\r\n    //   console.log(this.getSurfaceTypeLabel(i), \" sizeU:\", dims.sizeU, \" sizeV:\", dims.sizeV, \" curvatureU:\", dims.curvatureU, \" curvatureV:\", dims.curvatureV);\r\n    // }\r\n\r\n    // if (this.__totalSurfaceArea == 0.0) {\r\n    //   this.__totalSurfaceArea == 0.0;\r\n    //   this.__totalSurfaceCost = 0.0;\r\n    // for (let i = 0; i < this.__numSurfaces; i++) {\r\n    //   const dims = this.getSurfaceDims(i);\r\n    //   const area = dims.sizeU * dims.sizeV;\r\n\r\n    //   console.log(this.getSurfaceTypeLabel(i), \" sizeU:\", dims.sizeU, \" sizeV:\", dims.sizeV, \" curvatureU:\", dims.curvatureU, \" curvatureV:\", dims.curvatureV);\r\n    //   // this.__totalSurfaceArea += area;\r\n    //   // this.__totalSurfaceCost += (1.0 + (dims.sizeU * dims.curvatureU)) * (1.0 + (dims.sizeV * dims.curvatureV));\r\n    // }\r\n    // }\r\n    // console.log(this.__totalSurfaceCost);\r\n\r\n    // this.__triCounts = [\r\n    //   10,\r\n    //   20,\r\n    //   40,\r\n    //   80,\r\n    // ]\r\n\r\n    if (this.__totalSurfaceArea == 0.0) {\r\n      for (let i = 0; i < this.__numSurfaces; i++) {\r\n        const dims = this.getSurfaceDims(i)\r\n        const area = dims.sizeU * dims.sizeV\r\n        this.__totalSurfaceArea += area\r\n      }\r\n    }\r\n\r\n    this.__curveLibraryBuffer = curveLibraryBuffer\r\n    this.__curveLibraryReader = new BinReader(this.__curveLibraryBuffer)\r\n    this.__curveLibrarySize = Math.sqrt(curveLibraryBuffer.byteLength / 8) // RGBA16 pixels\r\n    this.__numCurves = this.__curveLibraryReader.loadUInt32()\r\n\r\n    // for (let i = 0; i < this.__numSurfaces; i++) {\r\n    //   console.log(this.getSurfaceData(i, false));\r\n    // }\r\n    // for (let i = 0; i < this.__numCurves; i++) {\r\n    //   console.log(this.getCurveData(i));\r\n    // }\r\n  }\r\n\r\n  /**\r\n   * The getCurveBuffer method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getCurveBuffer() {\r\n    return this.__curveLibraryBuffer\r\n  }\r\n\r\n  /**\r\n   * The getSurfaceBuffer method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getSurfaceBuffer() {\r\n    return this.__surfaceLibraryBuffer\r\n  }\r\n\r\n  /**\r\n   * The getNumSurfaces method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getNumSurfaces() {\r\n    return this.__numSurfaces\r\n  }\r\n\r\n  /**\r\n   * The getNumCurves method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getNumCurves() {\r\n    return this.__numCurves\r\n  }\r\n\r\n  /**\r\n   * The getDetailFactor method.\r\n   * @param {any} lod - The lod param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getDetailFactor(lod) {\r\n    // Given a target poly count, calculate the detail factor given the total surface cost.\r\n    // const targetQuadCount = this.__triCounts[Math.clamp(0, lod, this.__triCounts.length-1)] * 1000;\r\n    // return targetQuadCount / this.__totalSurfaceCost;\r\n    const mult = Math.pow(2, lod)\r\n    return mult * this.__cadAsset.curvatureToDetail\r\n  }\r\n\r\n  /**\r\n   * The getCurveDataTexelCoords method.\r\n   * @param {any} curveId - The curveId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getCurveDataTexelCoords(curveId) {\r\n    this.__curveLibraryReader.seek(geomLibraryHeaderSize + curveId * (valuesPerCurveTocItem * 2) /* bpc*/)\r\n    const x = this.__curveLibraryReader.loadFloat16()\r\n    const y = this.__curveLibraryReader.loadFloat16()\r\n    return {\r\n      x,\r\n      y,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The __seekCurveData method.\r\n   * @param {any} curveId - The curveId param.\r\n   * @param {number} offsetInBytes - The offsetInBytes param.\r\n   * @private\r\n   */\r\n  __seekCurveData(curveId, offsetInBytes = 0) {\r\n    const addr = this.getCurveDataTexelCoords(curveId)\r\n    // X, Y in pixels.\r\n\r\n    const bytesPerPixel = 8 // RGBA16 pixel\r\n    const byteOffset = addr.x * bytesPerPixel + addr.y * bytesPerPixel * this.__curveLibrarySize\r\n    // console.log(\"__seekSurfaceData:\" + curveId + \" byteOffset:\" + (byteOffset +offset) + \" pixel:\" + ((byteOffset +offset)/8) + \" x:\" + addr.x + \" y:\" + addr.y);\r\n    this.__curveLibraryReader.seek(byteOffset + offsetInBytes)\r\n  }\r\n\r\n  /**\r\n   * The getCurveType method.\r\n   * @param {any} curveId - The curveId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getCurveType(curveId) {\r\n    this.__seekCurveData(curveId)\r\n    const curveType = this.__curveLibraryReader.loadFloat16()\r\n    return curveType\r\n  }\r\n\r\n  /**\r\n   * The getCurveTypeLabel method.\r\n   * @param {any} curveId - The curveId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getCurveTypeLabel(curveId) {\r\n    const curveType = this.getCurveType(curveId)\r\n    return getCurveTypeName(curveType)\r\n  }\r\n\r\n  /**\r\n   * The getCurveTypeLabel method.\r\n   * @param {any} curveId - The curveId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getCurveDims(curveId) {\r\n    this.__curveLibraryReader.seek(geomLibraryHeaderSize + curveId * (valuesPerCurveTocItem * 2) /* bpc*/)\r\n\r\n    return {\r\n      addrX: this.__curveLibraryReader.loadFloat16(),\r\n      addrY: this.__curveLibraryReader.loadFloat16(),\r\n      curvature: this.__curveLibraryReader.loadFloat16(),\r\n      length: this.__curveLibraryReader.loadFloat16(),\r\n      flags: this.__curveLibraryReader.loadFloat16(),\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The getCurveTypeLabel method.\r\n   * @param {any} curveId - The curveId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getCurveData(curveId) {\r\n    const dims = this.getCurveDims(curveId)\r\n    const curveType = this.getCurveType(curveId)\r\n    const domain = new Vec2(this.__curveLibraryReader.loadFloat16(), this.__curveLibraryReader.loadFloat16())\r\n\r\n    switch (curveType) {\r\n      case CADCurveTypes.CURVE_TYPE_LINE: {\r\n        return {\r\n          curveId,\r\n          dims,\r\n          curveType: 'CURVE_TYPE_LINE',\r\n          domain,\r\n        }\r\n        break\r\n      }\r\n      case CADCurveTypes.CURVE_TYPE_CIRCLE: {\r\n        const radius = this.__curveLibraryReader.loadFloat16()\r\n        return {\r\n          curveId,\r\n          dims,\r\n          curveType: 'CURVE_TYPE_CIRCLE',\r\n          domain,\r\n          radius,\r\n        }\r\n        break\r\n      }\r\n      case CADCurveTypes.CURVE_TYPE_ELIPSE: {\r\n        const majorRadius = this.__curveLibraryReader.loadFloat16()\r\n        const minorRadius = this.__curveLibraryReader.loadFloat16()\r\n        return {\r\n          curveId,\r\n          dims,\r\n          curveType: 'SURFACE_TYPE_CYLINDER',\r\n          domain,\r\n          majorRadius,\r\n          minorRadius,\r\n        }\r\n        break\r\n      }\r\n      case CADCurveTypes.CURVE_TYPE_NURBS_CURVE: {\r\n        const degree = this.__curveLibraryReader.loadFloat16()\r\n        const numCPs = this.__curveLibraryReader.loadFloat16()\r\n        const numKnots = this.__curveLibraryReader.loadFloat16()\r\n        this.__curveLibraryReader.advance(4)\r\n\r\n        const controlPoints = []\r\n        for (let j = 0; j < numCPs; j++) {\r\n          const p = new Vec4(\r\n            this.__curveLibraryReader.loadFloat16(),\r\n            this.__curveLibraryReader.loadFloat16(),\r\n            this.__curveLibraryReader.loadFloat16(),\r\n            this.__curveLibraryReader.loadFloat16()\r\n          )\r\n          controlPoints.push(p)\r\n        }\r\n        const knots = []\r\n        for (let j = 0; j < numKnots; j++) {\r\n          knots.push(this.__curveLibraryReader.loadFloat16())\r\n        }\r\n        return {\r\n          curveId,\r\n          dims,\r\n          curveType: 'CURVE_TYPE_NURBS_CURVE',\r\n          domain,\r\n          degree,\r\n          numCPs,\r\n          controlPoints,\r\n          knots,\r\n        }\r\n      }\r\n      default:\r\n        console.warn('Invalid Curve Type:', curveType)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The getSurfaceDataTexelCoords method.\r\n   * @param {any} surfaceId - The surfaceId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getSurfaceDataTexelCoords(surfaceId) {\r\n    this.__surfaceLibraryReader.seek(geomLibraryHeaderSize + surfaceId * (valuesPerSurfaceTocItem * 2) /* bpc*/)\r\n    const x = this.__surfaceLibraryReader.loadUFloat16()\r\n    const y = this.__surfaceLibraryReader.loadUFloat16()\r\n    return {\r\n      x,\r\n      y,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The __seekSurfaceData method.\r\n   * @param {any} surfaceId - The surfaceId param.\r\n   * @param {number} offsetInBytes - The offsetInBytes param.\r\n   * @private\r\n   */\r\n  __seekSurfaceData(surfaceId, offsetInBytes = 0) {\r\n    const addr = this.getSurfaceDataTexelCoords(surfaceId)\r\n    // X, Y in pixels.\r\n\r\n    const bytesPerPixel = 8 // RGBA16 pixel\r\n    const byteOffset = addr.x * bytesPerPixel + addr.y * bytesPerPixel * this.__surfaceLibrarySize\r\n    // console.log(\"__seekSurfaceData:\" + surfaceId + \" byteOffset:\" + (byteOffset +offset) + \" pixel:\" + ((byteOffset +offset)/8) + \" x:\" + addr.x + \" y:\" + addr.y);\r\n    this.__surfaceLibraryReader.seek(byteOffset + offsetInBytes)\r\n  }\r\n\r\n  /**\r\n   * The getSurfaceType method.\r\n   * @param {any} surfaceId - The surfaceId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getSurfaceType(surfaceId) {\r\n    this.__seekSurfaceData(surfaceId)\r\n    const surfaceType = this.__surfaceLibraryReader.loadFloat16()\r\n    return surfaceType\r\n  }\r\n\r\n  /**\r\n   * The getSurfaceTypeLabel method.\r\n   * @param {any} surfaceId - The surfaceId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getSurfaceTypeLabel(surfaceId) {\r\n    const surfaceType = this.getSurfaceType(surfaceId)\r\n    return getSurfaceTypeName(surfaceType)\r\n  }\r\n\r\n  /**\r\n   * The getSurfaceDims method.\r\n   * @param {any} surfaceId - The surfaceId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getSurfaceDims(surfaceId) {\r\n    this.__surfaceLibraryReader.seek(geomLibraryHeaderSize + surfaceId * (valuesPerSurfaceTocItem * 2) /* bpc*/)\r\n\r\n    const loadTrimSetId = () => {\r\n      if (this.cadDataVersion.compare([0, 0, 27]) < 0) {\r\n        // Note: -1 is a valid value for trimset id, so can't use an unsigned float value.\r\n        const partA = this.__surfaceLibraryReader.loadFloat16()\r\n        const partB = this.__surfaceLibraryReader.loadFloat16()\r\n        return partA + (partB << 8)\r\n      } else {\r\n        return this.__surfaceLibraryReader.loadSInt32From2xFloat16()\r\n      }\r\n    }\r\n    return {\r\n      addrX: this.__surfaceLibraryReader.loadUFloat16(),\r\n      addrY: this.__surfaceLibraryReader.loadUFloat16(),\r\n      curvatureU: this.__surfaceLibraryReader.loadFloat16(),\r\n      curvatureV: this.__surfaceLibraryReader.loadFloat16(),\r\n      sizeU: this.__surfaceLibraryReader.loadFloat16(), // size U\r\n      sizeV: this.__surfaceLibraryReader.loadFloat16(), // size V\r\n      flags: this.__surfaceLibraryReader.loadFloat16(),\r\n      trimSetId: loadTrimSetId(), // trimSetId\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The getSurfaceData method.\r\n   * @param {any} surfaceId - The surfaceId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getSurfaceData(surfaceId, includeTrimSet = true) {\r\n    const dims = this.getSurfaceDims(surfaceId)\r\n\r\n    const surfaceType = this.getSurfaceType(surfaceId)\r\n    const readDomain = () => {\r\n      const domain = new Box2()\r\n      domain.p0.x = this.__surfaceLibraryReader.loadFloat16()\r\n      domain.p0.y = this.__surfaceLibraryReader.loadFloat16()\r\n      domain.p1.x = this.__surfaceLibraryReader.loadFloat16()\r\n      domain.p1.y = this.__surfaceLibraryReader.loadFloat16()\r\n      return domain\r\n    }\r\n    if (dims.trimSetId >= 0 && includeTrimSet) dims.trimSet = this.__trimSetLibrary.getTrimSetCurves(dims.trimSetId)\r\n\r\n    switch (surfaceType) {\r\n      case CADSurfaceTypes.SURFACE_TYPE_PLANE: {\r\n        const domain = readDomain()\r\n        return {\r\n          surfaceId,\r\n          dims,\r\n          surfaceType: 'SURFACE_TYPE_PLANE',\r\n          domain,\r\n        }\r\n        break\r\n      }\r\n      case CADSurfaceTypes.SURFACE_TYPE_FAN: {\r\n        const domain = readDomain()\r\n        const points = []\r\n        const numPoints = dims.curvatureU + 1\r\n        for (let j = 0; j < numPoints; j++) {\r\n          const p = new Vec2(this.__surfaceLibraryReader.loadFloat16(), this.__surfaceLibraryReader.loadFloat16())\r\n          points.push(p)\r\n        }\r\n        return {\r\n          surfaceId,\r\n          dims,\r\n          surfaceType: 'SURFACE_TYPE_FAN',\r\n          domain,\r\n          points,\r\n        }\r\n        break\r\n      }\r\n      case CADSurfaceTypes.SURFACE_TYPE_CONE: {\r\n        const domain = readDomain()\r\n        const radius = this.__surfaceLibraryReader.loadFloat16()\r\n        const semiAngle = this.__surfaceLibraryReader.loadFloat16()\r\n        return {\r\n          surfaceId,\r\n          dims,\r\n          surfaceType: 'SURFACE_TYPE_CONE',\r\n          domain,\r\n          radius,\r\n          semiAngle,\r\n        }\r\n        break\r\n      }\r\n      case CADSurfaceTypes.SURFACE_TYPE_CYLINDER: {\r\n        const domain = readDomain()\r\n        const radius = this.__surfaceLibraryReader.loadFloat16()\r\n        return {\r\n          surfaceId,\r\n          dims,\r\n          surfaceType: 'SURFACE_TYPE_CYLINDER',\r\n          domain,\r\n          radius,\r\n        }\r\n        break\r\n      }\r\n      case CADSurfaceTypes.SURFACE_TYPE_SPHERE: {\r\n        const domain = readDomain()\r\n        const radius = this.__surfaceLibraryReader.loadFloat16()\r\n        return {\r\n          surfaceId,\r\n          dims,\r\n          surfaceType: 'SURFACE_TYPE_SPHERE',\r\n          domain,\r\n          radius,\r\n        }\r\n      }\r\n      case CADSurfaceTypes.SURFACE_TYPE_TORUS: {\r\n        const domain = readDomain()\r\n        const majorRadius = this.__surfaceLibraryReader.loadFloat16()\r\n        const minorRadius = this.__surfaceLibraryReader.loadFloat16()\r\n        return {\r\n          surfaceId,\r\n          dims,\r\n          surfaceType: 'SURFACE_TYPE_TORUS',\r\n          domain,\r\n          majorRadius,\r\n          minorRadius,\r\n        }\r\n      }\r\n      case CADSurfaceTypes.SURFACE_TYPE_LINEAR_EXTRUSION: {\r\n        const domain = readDomain()\r\n\r\n        let curveIndex\r\n        // if (this.cadDataVersion.compare([0, 0, 27]) < 0) {\r\n        //   // Note: -1 is a valid value for trimset id, so can't use an unsigned float value.\r\n        //   const partA = this.__surfaceLibraryReader.loadFloat16()\r\n        //   const partB = this.__surfaceLibraryReader.loadFloat16()\r\n        //   curveIndex = partA + (partB << 8)\r\n        // } else {\r\n        // curveIndex = this.__surfaceLibraryReader.loadUInt32From2xUFloat16()\r\n\r\n        const partA = this.__surfaceLibraryReader.loadUFloat16()\r\n        const partB = this.__surfaceLibraryReader.loadUFloat16()\r\n        curveIndex = partA + partB * 2048\r\n        // }\r\n\r\n        const curveData = this.getCurveData(curveIndex)\r\n\r\n        const curve_tr = new Vec3(\r\n          this.__surfaceLibraryReader.loadFloat16(),\r\n          this.__surfaceLibraryReader.loadFloat16(),\r\n          this.__surfaceLibraryReader.loadFloat16()\r\n        )\r\n        const curve_ori = new Quat(\r\n          this.__surfaceLibraryReader.loadFloat16(),\r\n          this.__surfaceLibraryReader.loadFloat16(),\r\n          this.__surfaceLibraryReader.loadFloat16(),\r\n          this.__surfaceLibraryReader.loadFloat16()\r\n        )\r\n\r\n        return {\r\n          surfaceId,\r\n          dims,\r\n          surfaceType: 'SURFACE_TYPE_LINEAR_EXTRUSION',\r\n          domain,\r\n          curve_tr,\r\n          curve_ori,\r\n          curveData,\r\n          partA,\r\n          partB,\r\n        }\r\n      }\r\n      case CADSurfaceTypes.SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN:\r\n      case CADSurfaceTypes.SURFACE_TYPE_REVOLUTION: {\r\n        const domain = readDomain()\r\n\r\n        let curveIndex\r\n        if (this.cadDataVersion.compare([0, 0, 27]) < 0) {\r\n          // Note: -1 is a valid value for trimset id, so can't use an unsigned float value.\r\n          const partA = this.__surfaceLibraryReader.loadFloat16()\r\n          const partB = this.__surfaceLibraryReader.loadFloat16()\r\n          curveIndex = partA + (partB << 8)\r\n        } else {\r\n          curveIndex = this.__surfaceLibraryReader.loadUInt32From2xUFloat16()\r\n        }\r\n\r\n        const curve_tr = new Vec3(\r\n          this.__surfaceLibraryReader.loadFloat16(),\r\n          this.__surfaceLibraryReader.loadFloat16(),\r\n          this.__surfaceLibraryReader.loadFloat16()\r\n        )\r\n        const curve_ori = new Quat(\r\n          this.__surfaceLibraryReader.loadFloat16(),\r\n          this.__surfaceLibraryReader.loadFloat16(),\r\n          this.__surfaceLibraryReader.loadFloat16(),\r\n          this.__surfaceLibraryReader.loadFloat16()\r\n        )\r\n\r\n        const curveData = this.getCurveData(curveIndex)\r\n\r\n        return {\r\n          surfaceId,\r\n          dims,\r\n          surfaceType: 'SURFACE_TYPE_REVOLUTION',\r\n          domain,\r\n          curve_tr,\r\n          curve_ori,\r\n          curveData,\r\n        }\r\n      }\r\n      case CADSurfaceTypes.SURFACE_TYPE_NURBS_SURFACE: {\r\n        const domain = readDomain()\r\n        const degreeU = this.__surfaceLibraryReader.loadFloat16()\r\n        const degreeV = this.__surfaceLibraryReader.loadFloat16()\r\n        const numCPsU = this.__surfaceLibraryReader.loadFloat16()\r\n\r\n        const numCPsV = this.__surfaceLibraryReader.loadFloat16()\r\n        const numKnotsU = this.__surfaceLibraryReader.loadFloat16()\r\n        const numKnotsV = this.__surfaceLibraryReader.loadFloat16()\r\n        const flags = this.__surfaceLibraryReader.loadFloat16()\r\n        const periodicU = (flags & SURFACE_FLAG_PERIODIC_U) != 0\r\n        const periodicV = (flags & SURFACE_FLAG_PERIODIC_V) != 0\r\n        // this.__surfaceLibraryReader.advance(2);\r\n\r\n        const controlPoints = []\r\n        for (let j = 0; j < numCPsU * numCPsV; j++) {\r\n          const p = new Vec4(\r\n            this.__surfaceLibraryReader.loadFloat16(),\r\n            this.__surfaceLibraryReader.loadFloat16(),\r\n            this.__surfaceLibraryReader.loadFloat16(),\r\n            this.__surfaceLibraryReader.loadFloat16()\r\n          )\r\n          controlPoints.push(p)\r\n        }\r\n        const knotsU = []\r\n        for (let j = 0; j < numKnotsU; j++) {\r\n          knotsU.push(this.__surfaceLibraryReader.loadFloat16())\r\n        }\r\n        const knotsV = []\r\n        for (let j = 0; j < numKnotsV; j++) {\r\n          knotsV.push(this.__surfaceLibraryReader.loadFloat16())\r\n        }\r\n        return {\r\n          surfaceId,\r\n          dims,\r\n          surfaceType: 'SURFACE_TYPE_NURBS_SURFACE',\r\n          domain,\r\n          periodicU,\r\n          periodicV,\r\n          degreeU,\r\n          degreeV,\r\n          numCPsU,\r\n          numCPsV,\r\n          controlPoints,\r\n          knotsU,\r\n          knotsV,\r\n        }\r\n      }\r\n      case CADSurfaceTypes.SURFACE_TYPE_POLY_PLANE: {\r\n        const p0 = this.__surfaceLibraryReader.loadFloat16Vec2()\r\n        const p1 = this.__surfaceLibraryReader.loadFloat16Vec2()\r\n        const p2 = this.__surfaceLibraryReader.loadFloat16Vec2()\r\n        const p3 = this.__surfaceLibraryReader.loadFloat16Vec2()\r\n        return {\r\n          surfaceId,\r\n          dims,\r\n          surfaceType: 'SURFACE_TYPE_POLY_PLANE',\r\n          points: [p0, p1, p2, p3],\r\n        }\r\n      }\r\n      default: {\r\n        const surfaceType = this.getSurfaceType(surfaceId)\r\n        console.warn('Invalid Surface Type:', surfaceType, ' surfaceId:', surfaceId)\r\n      }\r\n    }\r\n  }\r\n\r\n  /** ************************************************************\r\n   *  NURBS Utils\r\n   **************************************************************/\r\n\r\n  /**\r\n   * Finds knot vector span.\r\n   * @param {number} u - Parametric value.\r\n   * @param {number} degree - Degree.\r\n   * @param {array} knots - Knot vector.\r\n   * @param {array} knotValues - The knotValues param.\r\n   * @return {number} - Returns the span.\r\n   */\r\n  findSpan(u, degree, knots, knotValues) {\r\n    if (this.cadDataVersion.compare([0, 0, 6]) >= 0) {\r\n      this.cadDataVersion\r\n      // EXPORT_KNOTS_AS_DELTAS\r\n\r\n      let nextKnot = knots[0]\r\n      let knot = nextKnot\r\n\r\n      let span = 1\r\n      const n = knots.length - degree - 1\r\n      // Linear Search...\r\n      for (; span < n; span++) {\r\n        nextKnot += knots[span]\r\n        if (span > degree && u < nextKnot) {\r\n          span--\r\n          break\r\n        }\r\n        knot = nextKnot\r\n      }\r\n      if (span == n) {\r\n        span--\r\n      }\r\n\r\n      // Calculate knot values\r\n      knotValues[degree] = knot\r\n      let left = knot\r\n      let right = knot\r\n      for (let i = 1; i <= degree; i++) {\r\n        left -= knots[span - i + 1]\r\n        right += knots[span + i]\r\n        knotValues[degree - i] = left\r\n        knotValues[degree + i] = right\r\n      }\r\n      return span\r\n    } else {\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate basis functions.\r\n   * See The NURBS Book, page 70, algorithm A2.2\r\n   * span : span in which u lies\r\n   * @param {any} u - Parametric point.\r\n   * @param {any} degree - Degree.\r\n   * @param {any} knots - Knot vector.\r\n   * @param {any} bvD - The bvD param.\r\n   * @return {any} - Returns array[degree+1] with basis functions values.\r\n   */\r\n  calcBasisValues(u, degree, knots, bvD) {\r\n    const left = []\r\n    const right = []\r\n    // Basis[0] is always 1.0\r\n    const basisValues = [1.0]\r\n    bvD[0] = 0.0\r\n\r\n    for (let j = 1; j <= degree; ++j) {\r\n      left[j] = u - knots[degree + 1 - j]\r\n      right[j] = knots[degree + j] - u\r\n\r\n      let saved = 0.0\r\n      for (let r = 0; r < j; ++r) {\r\n        const rv = right[r + 1]\r\n        const lv = left[j - r]\r\n        const temp = basisValues[r] / (rv + lv)\r\n        basisValues[r] = saved + rv * temp\r\n        saved = lv * temp\r\n      }\r\n\r\n      basisValues[j] = saved\r\n\r\n      // Calculate N' if on second to last iteration\r\n      if (j == degree - 1 || degree == 1) {\r\n        saved = 0.0\r\n        // Loop through all basis values\r\n        for (let r = 0; r < degree; r++) {\r\n          // Calculate a temp variable\r\n          const jr_z = r + 1\r\n          // Calculate right side\r\n          const kp_0 = knots[jr_z + degree]\r\n          const kp_1 = knots[jr_z]\r\n          const tmp = (degree * basisValues[r]) / (kp_0 - kp_1)\r\n          // Calculate derivative value\r\n          bvD[r] = saved - tmp\r\n          // Swap right side to left\r\n          saved = tmp\r\n        }\r\n        // Save the last der-basis\r\n        bvD[degree] = saved\r\n      }\r\n    }\r\n\r\n    return basisValues\r\n  }\r\n\r\n  /**\r\n   * Calculate basis function derivativess.\r\n   * See The NURBS Book, page 70, algorithm A2.2\r\n   * span : span in which u lies\r\n   * https://github.com/pradeep-pyro/tinynurbs/blob/master/include/tinynurbs/core/basis.h#L163\r\n   * @param {any} u - Parametric point.\r\n   * @param {any} degree - Degree.\r\n   * @param {any} knots - Knot vector.\r\n   * @return {any} - Returns array[degree+1] with basis function derivative values.\r\n   */\r\n  calcBasisDerivatives(u, degree, knots) {\r\n    const left = []\r\n    const right = []\r\n    let saved = 0.0\r\n    let temp = 0.0\r\n\r\n    const ndu = []\r\n    for (let j = 0; j <= degree; j++) {\r\n      ndu.push([])\r\n    }\r\n    ndu[0][0] = 1.0\r\n\r\n    for (let j = 1; j <= degree; j++) {\r\n      left[j] = u - knots[degree + 1 - j]\r\n      right[j] = knots[degree + j] - u\r\n      saved = 0.0\r\n\r\n      for (let r = 0; r < j; r++) {\r\n        const rv = right[r + 1]\r\n        const lv = left[j - r]\r\n        const rvlv = rv + lv\r\n\r\n        // Lower triangle\r\n        ndu[j][r] = rvlv\r\n        temp = ndu[r][j - 1] / rvlv\r\n        // Upper triangle\r\n        ndu[r][j] = saved + rv * temp\r\n        saved = lv * temp\r\n      }\r\n\r\n      ndu[j][j] = saved\r\n    }\r\n\r\n    const ders = [[], []]\r\n    for (let j = 0; j <= degree; j++) {\r\n      ders[0][j] = ndu[j][degree]\r\n    }\r\n\r\n    const a = [[], []]\r\n    for (let j = 0; j <= degree; j++) {\r\n      a[0].push(0)\r\n      a[1].push(0)\r\n    }\r\n\r\n    for (let r = 0; r <= degree; r++) {\r\n      let s1 = 0\r\n      let s2 = 1\r\n      a[0][0] = 1.0\r\n\r\n      // for (int k = 1; k <= 1; k++)\r\n      {\r\n        const k = 1\r\n        let d = 0.0\r\n        const rk = r - k\r\n        const pk = degree - k\r\n        let j1 = 0\r\n        let j2 = 0\r\n\r\n        if (r >= k) {\r\n          a[s2][0] = a[s1][0] / ndu[pk + 1][rk]\r\n          d = a[s2][0] * ndu[rk][pk]\r\n        }\r\n\r\n        if (rk >= -1) {\r\n          j1 = 1\r\n        } else {\r\n          j1 = -rk\r\n        }\r\n\r\n        if (r - 1 <= pk) {\r\n          j2 = k - 1\r\n        } else {\r\n          j2 = degree - r\r\n        }\r\n\r\n        for (let j = j1; j <= j2; j++) {\r\n          a[s2][j] = (a[s1][j] - a[s1][j - 1]) / ndu[pk + 1][rk + j]\r\n          d += a[s2][j] * ndu[rk + j][pk]\r\n        }\r\n\r\n        if (r <= pk) {\r\n          a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r]\r\n          d += a[s2][k] * ndu[r][pk]\r\n        }\r\n\r\n        ders[k][r] = d\r\n\r\n        const temp = s1\r\n        s1 = s2\r\n        s2 = temp\r\n      }\r\n    }\r\n\r\n    let fac = degree\r\n    // for (int k = 1; k <= 1; k++)\r\n    {\r\n      const k = 1\r\n      for (let j = 0; j <= degree; j++) {\r\n        ders[k][j] = ders[k][j] * fac\r\n      }\r\n      fac *= degree - k\r\n    }\r\n\r\n    return ders\r\n  }\r\n\r\n  // http://www.nar-associates.com/nurbs/programs/dbasisu.c\r\n  /* Subroutine to generate B-spline basis functions and their derivatives for uniform open knot vectors. */\r\n\r\n  /**\r\n   * Calculate rational B-Spline surface point.\r\n   * See The NURBS Book, page 134, algorithm A4.3\r\n   *\r\n   * p1, p2 : degrees of B-Spline surface\r\n   * U1, U2 : knot vectors\r\n   * P      : control points (x, y, z, w)\r\n   * u, v   : parametric values\r\n   *\r\n   * returns point for given (u, v)\r\n   *\r\n   * @param {any} surfaceData - The surfaceData param.\r\n   * @param {any} params - The params param.\r\n   * @return {any} - The return value.\r\n   */\r\n  calcSurfacePoint(surfaceData, params) {\r\n    const d = surfaceData\r\n\r\n    const u = Math.remap(params[0], 0, 1, d.domain.p0.x, d.domain.p1.x)\r\n    const v = Math.remap(params[1], 0, 1, d.domain.p0.y, d.domain.p1.y)\r\n\r\n    const knotValuesU = []\r\n    const spanU = this.findSpan(u, d.degreeU, d.knotsU, knotValuesU)\r\n    const knotValuesV = []\r\n    const spanV = this.findSpan(v, d.degreeV, d.knotsV, knotValuesV)\r\n\r\n    const bvdsU = []\r\n    const basisValuesU = this.calcBasisValues(u, d.degreeU, knotValuesU, bvdsU)\r\n    const bvdsV = []\r\n    const basisValuesV = this.calcBasisValues(v, d.degreeV, knotValuesV, bvdsV)\r\n\r\n    // const dersU = this.calcBasisDerivatives(u, d.degreeU, knotValuesU)\r\n    // const dersV = this.calcBasisDerivatives(v, d.degreeV, knotValuesV)\r\n    // const basisValuesU = dersU[0]\r\n    // const basisValuesV = dersV[0]\r\n\r\n    // console.log(\"knotValuesU:\", knotValuesU)\r\n    // console.log(\"basisValuesU:\", basisValuesU)\r\n    // console.log(\"knotValuesV:\", knotValuesV)\r\n    // console.log(\"basisValuesV:\", basisValuesV)\r\n    // }\r\n    // else {\r\n\r\n    // }\r\n\r\n    const pos = new Vec3(0, 0, 0)\r\n    const tangentU = new Vec3(0, 0, 0)\r\n    const tangentV = new Vec3(0, 0, 0)\r\n    let w = 0.0\r\n    const cvU0 = spanU - d.degreeU\r\n    const cvV0 = spanV - d.degreeV\r\n    for (let y = 0; y <= d.degreeV; ++y) {\r\n      // let vindex = (spanV - d.degreeV + y) % d.numCPsV;\r\n      const vindex = cvV0 + y\r\n      for (let x = 0; x <= d.degreeU; ++x) {\r\n        // const uindex = (spanU - d.degreeU + x) % d.numCPsU;\r\n        const uindex = cvU0 + x\r\n\r\n        const pt = d.controlPoints[uindex + vindex * d.numCPsU]\r\n        const weight = pt.t\r\n\r\n        const bvU = basisValuesU[x]\r\n        const bvV = basisValuesV[y]\r\n        // const bvU = dersU[0][x]\r\n        // const bvV = dersV[0][y]\r\n\r\n        const bvw = weight * bvU * bvV\r\n        pos.addInPlace(pt.scale(bvw))\r\n        w += bvw\r\n\r\n        const bvdU = bvdsU[x]\r\n        const bvdV = bvdsV[y]\r\n        // const bvdU = dersU[1][x]\r\n        // const bvdV = dersV[1][y]\r\n        tangentU.addInPlace(pt.scale(bvdU * bvV))\r\n        tangentV.addInPlace(pt.scale(bvU * bvdV))\r\n      }\r\n    }\r\n    if (w == 0 || isNaN(w) || !isFinite(w)) console.warn('Unable to evaluate surface')\r\n\r\n    // console.log('spanV:', spanV, ' v:', v, ' w:', w)\r\n    pos.scaleInPlace(1 / w)\r\n\r\n    ///////////////////////////////////////////////////////\r\n    // Calculate normal.\r\n    const spanRangeU = knotValuesU[d.degreeU + 1] - knotValuesU[d.degreeU]\r\n    const spanRangeV = knotValuesV[d.degreeV + 1] - knotValuesV[d.degreeV]\r\n    const eqKnotRangeU = (d.domain.p1.x - d.domain.p0.x) / d.knotsU.length\r\n    const eqKnotRangeV = (d.domain.p1.y - d.domain.p0.y) / d.knotsV.length\r\n\r\n    // console.log(v, 'spanRangeV:', spanRangeV, ' eqKnotRangeV:', eqKnotRangeV, spanRangeV / eqKnotRangeV)\r\n\r\n    // Note: for COOLANT_INLET_PORT_01.ipt_faceWithBlackEdge.\r\n    // this tollerance needed to be quite high. (bigger than 0.005)\r\n\r\n    if (spanRangeU / eqKnotRangeU < 0.01) {\r\n      // In some cases (COOLANT_INLET_PORT_01.ipt_faceWithBlackEdge.)\r\n      // we have span segment which has close to zero delta, and\r\n      // so the normals are broken. We want to advace along the\r\n      // e.g. [0, 0, 0, 0.00001, 1, 3, 3, 3]\r\n      // length of the span rather than when we have a pinched corner,\r\n      // where we move along the toher direction.\r\n      // console.log(v, 'spanRangeU:', spanRangeU, ' eqKnotRangeU:', eqKnotRangeU, spanRangeU / eqKnotRangeU)\r\n\r\n      let cvU = cvU0\r\n      if (v > d.domain.p1.y - 0.0001) {\r\n        // If at the end then we grab the end of the pevious row.\r\n        cvU = cvU0 + d.degreeU - 2\r\n      } else {\r\n        // if the broken normal is at the start of the U range, then\r\n        // we will grab the next in the row.\r\n        cvU = cvU0 + 1\r\n      }\r\n\r\n      const spanLerpV = (u - knotValuesV[d.degreeV]) / spanRangeV\r\n      const cvV = cvV0 + Math.floor(spanLerpV * d.degreeV)\r\n\r\n      const pt0 = d.controlPoints[cvU + cvV * d.numCPsU].toVec3()\r\n      const pt1 = d.controlPoints[cvU + 1 + cvV * d.numCPsU].toVec3()\r\n\r\n      tangentU.setFromOther(pt1.subtract(pt0))\r\n    } else if (tangentU.length() < 0.05) {\r\n      // The derivative in the V direction is zero,\r\n      // so we calculate the linear derivative for the next control points along.\r\n\r\n      let cvV\r\n      if (spanV > d.degreeV) {\r\n        // If at the end then we grab the end of the pevious row.\r\n        cvV = cvV0 + d.degreeV - 2\r\n      } else {\r\n        // if the broken normal is at the start of the V range, then\r\n        // we will grab the next in the row.\r\n        cvV = cvV0 + 1\r\n      }\r\n\r\n      const spanLerpU = (u - knotValuesU[d.degreeU]) / spanRangeU\r\n      const cvU = cvU0 + Math.floor(spanLerpU * d.degreeU)\r\n\r\n      const pt0 = d.controlPoints[cvU + cvV * d.numCPsU].toVec3()\r\n      const pt1 = d.controlPoints[cvU + 1 + cvV * d.numCPsU].toVec3()\r\n\r\n      tangentU.setFromOther(pt1.subtract(pt0))\r\n      // tangentU.setFromOther(pt0.subtract(pt1));\r\n    }\r\n\r\n    if (spanRangeV / eqKnotRangeV < 0.01) {\r\n      // In some cases (COOLANT_INLET_PORT_01.ipt_faceWithBlackEdge.)\r\n      // we have span segment which has close to zero delta, and\r\n      // so the normals are broken. We want to advace along the\r\n      // e.g. [0, 0, 0, 0.00001, 1, 3, 3, 3]\r\n      // length of the span rather than when we have a pinched corner,\r\n      // where we move along the toher direction.\r\n      // console.log(v, 'spanRangeV:', spanRangeV, ' eqKnotRangeV:', eqKnotRangeV, spanRangeV / eqKnotRangeV)\r\n\r\n      let cvV = cvV0\r\n      if (v > d.domain.p1.y - 0.0001) {\r\n        // If at the end then we grab the end of the pevious row.\r\n        cvV = cvV0 + d.degreeV - 2\r\n      } else {\r\n        // if the broken normal is at the start of the V range, then\r\n        // we will grab the next in the row.\r\n        cvV = cvV0 + 1\r\n      }\r\n\r\n      const spanLerpU = (u - knotValuesU[d.degreeU]) / spanRangeU\r\n      const cvU = cvU0 + Math.floor(spanLerpU * d.degreeU)\r\n\r\n      const pt0 = d.controlPoints[cvU + cvV * d.numCPsU].toVec3()\r\n      const pt1 = d.controlPoints[cvU + (cvV + 1) * d.numCPsU].toVec3()\r\n\r\n      tangentV.setFromOther(pt1.subtract(pt0))\r\n    } else if (tangentV.length() < 0.05) {\r\n      // The derivative in the V direction is zero,\r\n      // so we calculate the linear derivative for the next control points along.\r\n\r\n      let cvU = cvU0\r\n      if (v > d.domain.p1.y - 0.0001) {\r\n        // If at the end then we grab the end of the pevious row.\r\n        cvU = cvU0 + d.degreeU - 2\r\n      } else {\r\n        // if the broken normal is at the start of the U range, then\r\n        // we will grab the next in the row.\r\n        cvU = cvU0 + 1\r\n      }\r\n\r\n      const spanLerpV = (u - knotValuesV[d.degreeV]) / spanRangeV\r\n      const cvV = cvV0 + Math.floor(spanLerpV * d.degreeV)\r\n\r\n      const pt0 = d.controlPoints[cvU + cvV * d.numCPsU].toVec3()\r\n      const pt1 = d.controlPoints[cvU + (cvV + 1) * d.numCPsU].toVec3()\r\n\r\n      tangentV.setFromOther(pt1.subtract(pt0))\r\n    }\r\n\r\n    const normal = tangentU.cross(tangentV).normalize()\r\n\r\n    return {\r\n      pos,\r\n      normal,\r\n    }\r\n  }\r\n\r\n  // https://github.com/arennuit/libnurbs/blob/3f7daae483a615a13d21e5c674f412ccb8587b6e/nurbs%2B%2B-3.0.11/nurbs/nurbs.cpp\r\n\r\n  /**\r\n   * The generatePolygonSurface method.\r\n   * @param {any} surfaceId - The surfaceId param.\r\n   * @param {number} lod - The lod param.\r\n   * @return {any} - The return value.\r\n   */\r\n  generatePolygonSurface(surfaceId, lod = 0) {\r\n    if (this.__meshes[surfaceId]) {\r\n      // const color = this.__meshes[surfaceId].mat.getParameter('BaseColor').getValue();\r\n      // color.r = color.r + 0.2;\r\n      // console.log(\"surface Instanced:\" + surfaceId + \":\" + color.r);\r\n      return this.__meshes[surfaceId]\r\n    }\r\n\r\n    if (this.getSurfaceType(surfaceId) != CADSurfaceTypes.SURFACE_TYPE_NURBS_SURFACE) {\r\n      return\r\n    }\r\n    const surfaceData = this.getSurfaceData(surfaceId)\r\n    if (!surfaceData) {\r\n      return\r\n    }\r\n    const M = surfaceData.numCPsU * Math.pow(2, lod)\r\n    const N = surfaceData.numCPsV * Math.pow(2, lod)\r\n\r\n    console.log('generatePolygonSurface:' + surfaceId + ' M:' + M + ' N:' + N)\r\n\r\n    const quad = new Plane(1.0, 1.0, M, N)\r\n    const normalsGeom = new Lines()\r\n    normalsGeom.setNumVertices((M + 1) * (N + 1) * 2)\r\n    normalsGeom.setNumSegments((M + 1) * (N + 1))\r\n    const normalsGeom_PosAttr = normalsGeom.getVertexAttribute('positions')\r\n    const normalsLength = 0.2\r\n\r\n    let voff = 0\r\n    const positions = quad.getVertexAttribute('positions')\r\n    const normals = quad.getVertexAttribute('normals')\r\n    for (let j = 0; j <= N; j++) {\r\n      const v = j / N\r\n      for (let i = 0; i <= M; i++) {\r\n        const u = i / M\r\n        const pt = this.calcSurfacePoint(surfaceData, [u, v])\r\n\r\n        positions.getValueRef(voff).set(pt.pos.x, pt.pos.y, pt.pos.z)\r\n        normals.getValueRef(voff).set(pt.normal.x, pt.normal.y, pt.normal.z)\r\n\r\n        normalsGeom.setSegmentVertexIndices(voff, voff * 2, voff * 2 + 1)\r\n        // if (v == 0.0)\r\n        {\r\n          normalsGeom_PosAttr.getValueRef(voff * 2).set(pt.pos.x, pt.pos.y, pt.pos.z)\r\n          normalsGeom_PosAttr\r\n            .getValueRef(voff * 2 + 1)\r\n            .set(\r\n              pt.pos.x + pt.normal.x * normalsLength,\r\n              pt.pos.y + pt.normal.y * normalsLength,\r\n              pt.pos.z + pt.normal.z * normalsLength\r\n            )\r\n        }\r\n\r\n        voff++\r\n      }\r\n    }\r\n\r\n    // quad.computeVertexNormals();\r\n\r\n    const material = new Material('myMat', 'SimpleSurfaceShader')\r\n    material.getParameter('BaseColor').setValue(Color.random(0.15))\r\n    quad.material = material\r\n\r\n    const normalsGeomMaterial = new Material('myMat', 'FlatSurfaceShader')\r\n    normalsGeomMaterial.getParameter('BaseColor').setValue(new Color(1, 0, 0))\r\n    normalsGeom.material = normalsGeomMaterial\r\n\r\n    this.__meshes[surfaceId] = quad\r\n    return { mesh: quad, normals: normalsGeom }\r\n  }\r\n\r\n  /**\r\n   * The generateHullGeometry method.\r\n   * @param {any} surfaceId - The surfaceId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  generateHullGeometry(surfaceId) {\r\n    if (this.__hulls[surfaceId]) {\r\n      // const color = this.__hulls[surfaceId].mat.getParameter('BaseColor').getValue();\r\n      // color.r = color.r + 0.2;\r\n      // console.log(\"surface Instanced:\" + surfaceId + \":\" + color.r);\r\n      return this.__hulls[surfaceId]\r\n    }\r\n\r\n    if (this.getSurfaceType(surfaceId) != CADSurfaceTypes.SURFACE_TYPE_NURBS_SURFACE) {\r\n      return\r\n    }\r\n    const surfaceData = this.getSurfaceData(surfaceId)\r\n    if (!surfaceData) {\r\n      return\r\n    }\r\n    console.log(\r\n      'generateHullGeometry:' + surfaceId + ' numCPsU:' + surfaceData.numCPsU + ' numCPsV:' + surfaceData.numCPsV\r\n    )\r\n    const hull = new Hull(surfaceData.numCPsU, surfaceData.numCPsV)\r\n\r\n    const positions = hull.getVertexAttribute('positions')\r\n    let voff = 0\r\n    for (let j = 0; j < surfaceData.numCPsV; j++) {\r\n      for (let i = 0; i < surfaceData.numCPsU; i++) {\r\n        const index = i + j * surfaceData.numCPsU\r\n        const pt = surfaceData.controlPoints[index]\r\n        positions.getValueRef(voff).set(pt.x, pt.y, pt.z)\r\n        voff++\r\n      }\r\n    }\r\n\r\n    const material = new Material('hullMaterial', 'FlatSurfaceShader')\r\n    material.getParameter('BaseColor').setValue(Color.random(-0.25))\r\n    hull.material = material\r\n\r\n    this.__hulls[surfaceId] = hull\r\n    return hull\r\n  }\r\n\r\n  /**\r\n   * The dumpDebugSurfaces method.\r\n   */\r\n  dumpDebugSurfaces() {\r\n    const surfacesData = []\r\n    for (let i = 0; i < this.__numSurfaces; i++) {\r\n      try {\r\n        surfacesData.push(this.getSurfaceData(i, false))\r\n      } catch (e) {\r\n        console.warn('Error accessing Surface: ', i, e)\r\n        surfacesData.push({})\r\n      }\r\n    }\r\n    return surfacesData\r\n  }\r\n\r\n  /**\r\n   * The dumpDebugCurves method.\r\n   */\r\n  dumpDebugCurves() {\r\n    const curvesData = []\r\n    for (let i = 0; i < this.__numSurfaces; i++) {\r\n      try {\r\n        curvesData.push(this.getCurveData(i))\r\n      } catch (e) {\r\n        console.warn('Error accessing Curve: ', i, e)\r\n        curvesData.push({})\r\n      }\r\n    }\r\n    return curvesData\r\n  }\r\n\r\n  /**\r\n   * The logFormfactors method.\r\n   */\r\n  logFormfactors() {\r\n    for (const ff in this.__formFactors) console.log(ff + ':' + this.__formFactors[ff])\r\n  }\r\n}\r\n\r\nexport { CADSurfaceLibrary }\r\n","import { SystemDesc } from '@zeainc/zea-engine'\r\n\r\nconst sizeOfBBox = 24\r\n\r\n/** Class representing a CAD trim set library.\r\n * @ignore\r\n */\r\nclass CADTrimSetLibrary {\r\n  /**\r\n   * Create a CAD trim set library.\r\n   */\r\n  constructor() {\r\n    this.__reader = undefined\r\n  }\r\n\r\n  /**\r\n   * The setBinaryBuffer method.\r\n   * @param {any} trimSetReader - The trimSetReader param.\r\n   * @param {number} version - The version param.\r\n   */\r\n  setBinaryBuffer(trimSetReader, version) {\r\n    this.__reader = trimSetReader\r\n\r\n    this.__numTrimSets = this.__reader.loadUInt32()\r\n    if (version.compare([0, 0, 0]) > 0) {\r\n      this.__totalTrimSurfaceArea = this.__reader.loadFloat32()\r\n    } else {\r\n      this.__totalTrimSurfaceArea = 0.0\r\n      for (let i = 0; i < this.__numTrimSets; i++) {\r\n        const dims = this.getTrimSetDim(i)\r\n        const area = dims[0] * dims[1]\r\n        this.__totalTrimSurfaceArea += area\r\n      }\r\n    }\r\n\r\n    const sideLength = Math.sqrt(this.__totalTrimSurfaceArea)\r\n\r\n    const maxTexSize = SystemDesc.gpuDesc.maxTextureSize\r\n    // I'm not sure whats going on here.\r\n    // The xlarge size should be at most maxTexSize >> 1 (e.g. 50% wasted space.)\r\n    const xlargeTexSize = maxTexSize >> 1\r\n    const largeTexSize = maxTexSize >> 2\r\n    const medTexSize = maxTexSize >> 3\r\n    const smallTexSize = maxTexSize >> 4\r\n\r\n    // Note: on big scenes like the Spyder, the texels often fail\r\n    // to pack when tex size is too small, causing artifacts in trimming.\r\n    // Therefore the biggest texture size is half the maximum.\r\n    this.__texelSizes = [\r\n      sideLength / smallTexSize,\r\n      sideLength / medTexSize,\r\n      sideLength / largeTexSize,\r\n      sideLength / xlargeTexSize,\r\n    ]\r\n    // console.log(\"sideLength:\", sideLength, this.__texelSizes);\r\n\r\n    ////////////////////////////\r\n    // Debugging.\r\n    // for (let i = 0; i < this.__numTrimSets; i++) {\r\n    //   console.log({\r\n    //     dims: this.getTrimSetDim(i),\r\n    //     curves: this.getTrimSetCurves(i)\r\n    //   })\r\n    // }\r\n  }\r\n\r\n  /**\r\n   * The getBinaryBuffer method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getBinaryBuffer() {\r\n    if (!this.__reader) return null\r\n    return this.__reader.data\r\n  }\r\n\r\n  /**\r\n   * The getNumTrimSets method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getNumTrimSets() {\r\n    return this.__numTrimSets\r\n  }\r\n\r\n  /**\r\n   * The getTrimArea method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getTrimArea() {\r\n    return this.__totalTrimSurfaceArea\r\n  }\r\n\r\n  /**\r\n   * The getTexelSize method.\r\n   * @param {any} lod - The lod param.\r\n   * @param {any} numAssets - The numAssets param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getTexelSize(lod, numAssets) {\r\n    // return 5\r\n    // For scenes with many assets we drop down the texel detail\r\n    // so they load without destroying the GPU.\r\n    let lodId\r\n    if (numAssets < 2) lodId = 3\r\n    else if (numAssets < 6) lodId = 2\r\n    else {\r\n      lodId = 1 // LOD 0 is just a mess.\r\n    }\r\n    // lodId = 1\r\n\r\n    // return 4\r\n    return this.__texelSizes[lodId]\r\n    // return this.__texelSizes[Math.clamp(lod, 0, this.__texelSizes.length-1)];\r\n  }\r\n\r\n  /**\r\n   * The getTrimSetDim method.\r\n   * @param {any} trimSetId - The trimSetId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getTrimSetDim(trimSetId) {\r\n    this.__reader.seek(8 + trimSetId * 4)\r\n    this.__reader.seek(this.__reader.loadUInt32())\r\n\r\n    const size_x = this.__reader.loadFloat32() // size in scene units\r\n    const size_y = this.__reader.loadFloat32() // size in scene units\r\n    return [size_x, size_y]\r\n  }\r\n\r\n  /**\r\n   * The getTrimSetCurves method.\r\n   * @param {any} trimSetId - The trimSetId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getTrimSetCurves(trimSetId) {\r\n    this.__reader.seek(8 + trimSetId * 4)\r\n    this.__reader.seek(this.__reader.loadUInt32())\r\n\r\n    const size_x = this.__reader.loadFloat32() // size in scene units\r\n    const size_y = this.__reader.loadFloat32() // size in scene units\r\n    const numHoles = this.__reader.loadUInt32()\r\n    const numPermiterCurves = this.__reader.loadUInt32()\r\n    const loadCurveRef = () => {\r\n      return {\r\n        id: this.__reader.loadFloat32(),\r\n        xfo_tr: [this.__reader.loadFloat32(), this.__reader.loadFloat32()],\r\n        xfo_rot: [\r\n          this.__reader.loadFloat32(),\r\n          this.__reader.loadFloat32(),\r\n          this.__reader.loadFloat32(),\r\n          this.__reader.loadFloat32(),\r\n        ],\r\n        flags: this.__reader.loadFloat32(),\r\n      }\r\n    }\r\n    const perimeter = []\r\n    for (let i = 0; i < numPermiterCurves; i++) {\r\n      perimeter.push(loadCurveRef())\r\n    }\r\n    const holes = []\r\n    for (let i = 0; i < numHoles; i++) {\r\n      const hole = []\r\n      const numHoleCurves = this.__reader.loadUInt32()\r\n      for (let i = 0; i < numHoleCurves; i++) {\r\n        hole.push(loadCurveRef())\r\n      }\r\n      holes.push(hole)\r\n    }\r\n    return {\r\n      size: [size_x, size_y],\r\n      perimeter,\r\n      holes,\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The dumpDebugTrimSets method.\r\n   */\r\n  dumpDebugTrimSets() {\r\n    const trimSetsData = []\r\n    for (let i = 0; i < this.__numTrimSets; i++) {\r\n      try {\r\n        trimSetsData.push({\r\n          dims: this.getTrimSetDim(i),\r\n          curves: this.getTrimSetCurves(i),\r\n        })\r\n      } catch (e) {\r\n        console.warn('Error accessing TrimSet: ', i, e)\r\n        trimSetsData.push({})\r\n      }\r\n    }\r\n    return trimSetsData\r\n  }\r\n}\r\n\r\nexport { CADTrimSetLibrary }\r\n","import { Box3, Xfo, BinReader } from '@zeainc/zea-engine'\r\nconst bytesPerValue = 4 // 32 bit floats\r\n\r\n/** Class representing a CAD body library.\r\n * @ignore\r\n */\r\nclass CADBodyLibrary {\r\n  /**\r\n   * Create a CAD body library.\r\n   * @param {any} buffer - The buffer value.\r\n   */\r\n  constructor(buffer) {\r\n    if (buffer != undefined) {\r\n      this.setBinaryBuffer(buffer)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The setBinaryBuffers method.\r\n   * @param {any} tocBuffer - The tocBuffer param.\r\n   * @param {any} buffer - The buffer param.\r\n   */\r\n  setBinaryBuffers(tocBuffer, buffer) {\r\n    this.__buffer = buffer\r\n    this.__reader = new BinReader(this.__buffer)\r\n    this.__size = Math.sqrt(buffer.byteLength / (4 * bytesPerValue)) // RGBA32 pixels\r\n\r\n    this.__toc = tocBuffer // new Uint32Array(tocBuffer);\r\n    this.__tocReader = new BinReader(tocBuffer)\r\n    this.__numBodies = this.__tocReader.loadUInt32()\r\n\r\n    // for (let i = 0; i < this.__numBodies; i++) {\r\n    //     // console.log(JSON.stringify(this.getBodyDescData(i)));\r\n    //     console.log(this.getBodyDescData(i));\r\n    // }\r\n  }\r\n\r\n  /**\r\n   * The getToc method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getToc() {\r\n    return this.__toc\r\n  }\r\n\r\n  /**\r\n   * The getBinaryBuffer method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getBinaryBuffer() {\r\n    return this.__buffer\r\n  }\r\n\r\n  /**\r\n   * The getNumBodies method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getNumBodies() {\r\n    return this.__numBodies\r\n  }\r\n\r\n  /**\r\n   * The getBodyDataTexelCoords method.\r\n   * @param {any} bodyDescId - The bodyDescId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getBodyDataTexelCoords(bodyDescId) {\r\n    this.__tocReader.seek(4 + bodyDescId * (3 * 4))\r\n    const x = this.__tocReader.loadUInt32()\r\n    const y = this.__tocReader.loadUInt32()\r\n    return {\r\n      x,\r\n      y,\r\n    }\r\n  }\r\n\r\n  // eslint-disable-next-line require-jsdoc\r\n  __seekBodyData(bodyDescId, offsetInBytes = 0) {\r\n    const addr = this.getBodyDataTexelCoords(bodyDescId)\r\n    // X, Y in pixels.\r\n\r\n    const bytesPerPixel = 16 // RGBA32 pixels == 16 bytes perpixel\r\n    const byteOffset = addr.x * bytesPerPixel + addr.y * bytesPerPixel * this.__size\r\n    // console.log(\"__seekSurfaceData:\" + bodyDescId + \" byteOffset:\" + (byteOffset +offset) + \" pixel:\" + ((byteOffset +offset)/8) + \" x:\" + addr.x + \" y:\" + addr.y);\r\n    this.__reader.seek(byteOffset + offsetInBytes)\r\n  }\r\n\r\n  /**\r\n   * The getNumSurfacesForBody method.\r\n   * @param {any} bodyDescId - The bodyDescId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getNumSurfacesForBody(bodyDescId) {\r\n    this.__seekBodyData(bodyDescId, 6 /* bbox*/ * bytesPerValue)\r\n    const numBodySurfaces = this.__reader.loadFloat32()\r\n    return numBodySurfaces\r\n  }\r\n\r\n  /**\r\n   * The getBodyBBox method.\r\n   * @param {any} bodyDescId - The bodyDescId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getBodyBBox(bodyDescId) {\r\n    this.__seekBodyData(bodyDescId)\r\n    const bbox = new Box3()\r\n    bbox.p0 = this.__reader.loadFloat32Vec3()\r\n    bbox.p1 = this.__reader.loadFloat32Vec3()\r\n    return bbox\r\n  }\r\n\r\n  /**\r\n   * The getBodyDescData method.\r\n   * @param {any} bodyDescId - The bodyDescId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getBodyDescData(bodyDescId, includeXfosAndColors = true) {\r\n    this.__seekBodyData(bodyDescId)\r\n    // console.log(this.__reader.pos() / 8);\r\n\r\n    const bbox = new Box3()\r\n    bbox.p0 = this.__reader.loadFloat32Vec3()\r\n    bbox.p1 = this.__reader.loadFloat32Vec3()\r\n    // console.log(this.__reader.pos() / 8);\r\n    const numBodySurfaces = this.__reader.loadFloat32()\r\n    const numBodyCurves = this.__reader.loadFloat32()\r\n    const surfaceRefs = []\r\n    for (let j = 0; j < numBodySurfaces; j++) {\r\n      if (includeXfosAndColors) {\r\n        const surfaceRef = {\r\n          surfaceId: this.__reader.loadFloat32(),\r\n        }\r\n        surfaceRef.xfo = new Xfo(\r\n          this.__reader.loadFloat32Vec3(),\r\n          this.__reader.loadFloat32Quat(),\r\n          this.__reader.loadFloat32Vec3()\r\n        )\r\n        surfaceRef.color = this.__reader.loadRGBAFloat32Color()\r\n        surfaceRefs.push(surfaceRef)\r\n      } else {\r\n        surfaceRefs.push(this.__reader.loadFloat32())\r\n        this.__reader.advance(14 * 4)\r\n      }\r\n    }\r\n\r\n    const curveRefs = []\r\n    for (let j = 0; j < numBodyCurves; j++) {\r\n      if (includeXfosAndColors) {\r\n        const curveRef = {\r\n          curveId: this.__reader.loadFloat32(),\r\n        }\r\n        curveRef.xfo = new Xfo(\r\n          this.__reader.loadFloat32Vec3(),\r\n          this.__reader.loadFloat32Quat(),\r\n          this.__reader.loadFloat32Vec3()\r\n        )\r\n        curveRef.color = this.__reader.loadRGBAFloat32Color()\r\n        curveRefs.push(curveRef)\r\n      } else {\r\n        curveRefs.push(this.__reader.loadFloat32())\r\n        this.__reader.advance(14 * 4)\r\n      }\r\n    }\r\n\r\n    const bodyDescData = {\r\n      bbox,\r\n      surfaceRefs,\r\n      curveRefs,\r\n    }\r\n\r\n    return bodyDescData\r\n  }\r\n}\r\n\r\nexport { CADBodyLibrary }\r\n","import {\r\n  Color,\r\n  Box3,\r\n  MaterialParameter,\r\n  ColorParameter,\r\n  BaseGeomItem,\r\n  Material,\r\n  GeomItem,\r\n  TreeItem,\r\n  Registry,\r\n} from '@zeainc/zea-engine'\r\n\r\n/**\r\n * Represents a Body within a CAD Part. A Body is made up of either a single mesh or a collection of meshes, one for each surface.\r\n * When a zcad file is produced, the tool can  optimize bodies to contain only one mesh to speed up loading of large models, and support bigger models being loaded.\r\n *\r\n * **Parameters**\r\n * * **Material(`MaterialParameter`):** Specifies the material of the geometry item.\r\n * * **Color(`ColorParameter`):** Specifies the color of the geometry item.\r\n *\r\n * @extends BaseGeomItem\r\n */\r\nclass CADBody extends BaseGeomItem {\r\n  /**\r\n   * Creates an instance of CADBody setting up the initial configuration for Material and Color parameters.\r\n   *\r\n   * @param {string} name - The name value.\r\n   * @param {CADAsset} cadAsset - The cadAsset value.\r\n   */\r\n  constructor(name, cadAsset) {\r\n    super(name)\r\n    this.__bodyDescId = -1\r\n    this.__id = -1\r\n    this.__bodyBBox = new Box3()\r\n    this.__cadAsset = cadAsset // Note: used in testing scenes.\r\n    if (this.__cadAsset) this.__cadAsset.incCADBodyCount()\r\n\r\n    this.__materialParam = this.addParameter(new MaterialParameter('Material'))\r\n    this.__colorParam = this.addParameter(new ColorParameter('Color', new Color(1, 0, 0, 0)))\r\n  }\r\n\r\n  /**\r\n   * Returns the `CADAsset` object in current `CADBody`\r\n   *\r\n   * @return {CADAsset} - The return value.\r\n   */\r\n  getCADAsset() {\r\n    return this.__cadAsset\r\n  }\r\n\r\n  /**\r\n   * The clone method constructs a new CADBody, copies its values\r\n   * from this item and returns it.\r\n   *\r\n   * @param {number} flags - The flags param.\r\n   * @return {CADBody} - The return value.\r\n   */\r\n  clone(flags) {\r\n    const cloned = new CADBody()\r\n    cloned.copyFrom(this, flags)\r\n    return cloned\r\n  }\r\n\r\n  /**\r\n   * The copyFrom method.\r\n   * @param {CADBody} src - The src param.\r\n   * @param {number} flags - The flags param.\r\n   * @private\r\n   */\r\n  copyFrom(src, flags) {\r\n    super.copyFrom(src, flags)\r\n    this.__cadAsset = src.getCADAsset()\r\n    this.__cadAsset.incCADBodyCount()\r\n\r\n    this.setBodyDescId(src.getBodyDescId())\r\n    this.setMaterial(src.getMaterial()) // clone?\r\n  }\r\n\r\n  // ////////////////////////////////////////\r\n  // Geometry\r\n\r\n  /**\r\n   * The getBodyDataTexelCoords method.\r\n   * @param {any} bodyDescId - The bodyDescId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getBodyDataTexelCoords() {\r\n    return this.__cadAsset.getBodyLibrary().getBodyDataTexelCoords(this.__bodyDescId)\r\n  }\r\n\r\n  /**\r\n   * Returns an object that contains the bBox and all the SurfaceRefs of current object using the bodyDescId.\r\n   * @private\r\n   * @return {object} - The return value.\r\n   */\r\n  getBodyDescData() {\r\n    const bodyDescData = this.__cadAsset.getBodyLibrary().getBodyDescData(this.__bodyDescId)\r\n    for (const surfaceRef of bodyDescData.surfaceRefs) {\r\n      surfaceRef.surfaceType = this.__cadAsset.getSurfaceLibrary().getSurfaceTypeLabel(surfaceRef.surfaceId)\r\n      surfaceRef.dims = this.__cadAsset.getSurfaceLibrary().getSurfaceDims(surfaceRef.surfaceId)\r\n    }\r\n    return bodyDescData\r\n  }\r\n\r\n  /**\r\n   * Returns a list of all SurfaceRefs of current `CADBody`.\r\n   * <br>\r\n   * Which contain the surfaceId, xfo object and the color.\r\n   *\r\n   * @return {array} - The return value.\r\n   */\r\n  getSurfaceRefs() {\r\n    const bodyData = this.getBodyDescData()\r\n    return bodyData.surfaceRefs\r\n  }\r\n\r\n  /**\r\n   * Returns the bodyDescId of current `CADBody`\r\n   *\r\n   * @return {number} - The return value.\r\n   */\r\n  getBodyDescId() {\r\n    return this.__bodyDescId\r\n  }\r\n\r\n  /**\r\n   * Sets bodyDescId to current `CADBody`, but also calculates a new bBox.\r\n   * @private\r\n   * @param {number} bodyId - The bodyId param.\r\n   */\r\n  setBodyDescId(bodyId) {\r\n    this.__bodyDescId = bodyId\r\n    if (bodyId >= 0) {\r\n      this.__bodyBBox = this.__cadAsset.getBodyLibrary().getBodyBBox(this.__bodyDescId)\r\n      this._setBoundingBoxDirty()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns current Material parameter value.\r\n   * @deprecated\r\n   * @return {MaterialParameter} - The return value.\r\n   */\r\n  getMaterial() {\r\n    return this.__materialParam.getValue()\r\n  }\r\n\r\n  /**\r\n   * Sets Material parameter value.\r\n   * <br>\r\n   * For `mode` possible values check `Parameter` Class documentation.\r\n   * @see [Zea Engine]()\r\n   *\r\n   * @deprecated\r\n   * @param {MaterialParameter} material - The material param.\r\n   * @param {number} mode - The mode param.\r\n   */\r\n  setMaterial(material, mode) {\r\n    this.__materialParam.setValue(material, mode)\r\n  }\r\n\r\n  /**\r\n   * The _cleanBoundingBox method.\r\n   * @param {any} bbox - The bbox param.\r\n   * @return {any} - The return value.\r\n   * @private\r\n   */\r\n  _cleanBoundingBox(bbox) {\r\n    bbox = super._cleanBoundingBox(bbox)\r\n    if (this.__bodyDescId != -1) {\r\n      bbox.addBox3(this.__bodyBBox, this.getParameter('GlobalXfo').getValue())\r\n    }\r\n    return bbox\r\n  }\r\n\r\n  // ///////////////////////////\r\n  // Persistence\r\n\r\n  /**\r\n   * Initializes CADBody's asset, material, version and layers; adding current `CADBody` Geometry Item toall the layers in reader\r\n   *\r\n   * @param {BinReader} reader - The reader param.\r\n   * @param {object} context - The context param.\r\n   */\r\n  readBinary(reader, context) {\r\n    super.readBinary(reader, context)\r\n\r\n    // Cache only in debug mode.\r\n    this.__cadAsset = context.assetItem\r\n    this.__cadAsset.incCADBodyCount()\r\n\r\n    const bodyDescId = reader.loadSInt32()\r\n    if (bodyDescId >= 0) {\r\n      this.setBodyDescId(bodyDescId)\r\n    }\r\n\r\n    if (context.versions['zea-cad'].compare([0, 0, 4]) < 0) {\r\n      const materialName = reader.loadStr()\r\n      // const materialName = 'Mat' + this.__bodyDescId;\r\n\r\n      const materialLibrary = context.assetItem.getMaterialLibrary()\r\n      let material = materialLibrary.getMaterial(materialName, false)\r\n      if (!material) {\r\n        // console.warn(\"Body :'\" + this.name + \"' Material not found:\" + materialName);\r\n        // material = materialLibrary.getMaterial('DefaultMaterial');\r\n\r\n        material = new Material(materialName, 'SimpleSurfaceShader')\r\n        material.getParameter('BaseColor').setValue(Color.random(0.25))\r\n        context.assetItem.getMaterialLibrary().addMaterial(material)\r\n      }\r\n      this.getParameter('Material').setValue(material)\r\n    }\r\n\r\n    if (context.versions['zea-cad'].compare([0, 0, 2]) >= 0 && context.versions['zea-cad'].compare([0, 0, 4]) < 0) {\r\n      this.__layers = reader.loadStrArray()\r\n      // console.log(\"Layers:\", this.__layers)\r\n      for (const layer of this.__layers) context.addGeomToLayer(this, layer)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The generatePolygonMeshSurfaces method.\r\n   * @param {number} lod - The lod param.\r\n   * @return {any} - The return value.\r\n   * @private\r\n   */\r\n  generatePolygonMeshSurfaces(lod = 0) {\r\n    const treeItem = new TreeItem(this.getName())\r\n\r\n    // const standardMaterial = new Material('surfaces', 'SimpleSurfaceShader');\r\n    // standardMaterial.getParameter('BaseColor').setValue(Color.random(0.4));\r\n\r\n    const bodyData = this.getBodyDescData()\r\n    bodyData.surfaceRefs.forEach((surfaceRef, surfaceIndex) => {\r\n      const mesh = this.__cadAsset.getSurfaceLibrary().generatePolygonSurface(surfaceRef.surfaceId, lod)\r\n      if (mesh) {\r\n        const geomItem = new GeomItem('Surface' + surfaceIndex + ':' + surfaceRef.surfaceId, mesh, mesh.material) // this.__material);// mesh.mat);\r\n        geomItem.getParameter('LocalXfo').setValue(surfaceRef.xfo)\r\n        treeItem.addChild(geomItem)\r\n      }\r\n    })\r\n    return treeItem\r\n  }\r\n\r\n  /**\r\n   * The generateHullGeometry method.\r\n   * @return {any} - The return value.\r\n   * @private\r\n   */\r\n  generateHullGeometry() {\r\n    const treeItem = new TreeItem(this.getName())\r\n    const bodyData = this.getBodyDescData()\r\n    bodyData.surfaceRefs.forEach((surfaceRef, surfaceIndex) => {\r\n      const hull = this.__cadAsset.getSurfaceLibrary().generateHullGeometry(surfaceRef.surfaceId)\r\n      if (hull) {\r\n        const geomItem = new GeomItem('Hull' + surfaceIndex + ':' + surfaceRef.surfaceId, hull, hull.material)\r\n        geomItem.getParameter('LocalXfo').setValue(surfaceRef.xfo)\r\n        treeItem.addChild(geomItem)\r\n        return false\r\n      }\r\n    })\r\n    return treeItem\r\n  }\r\n\r\n  // ////////////////////////////////////////\r\n  // Persistence\r\n\r\n  /**\r\n   * The toJSON method encodes this type as a json object for persistences.\r\n   *\r\n   * @param {number} flags - The flags param.\r\n   * @return {object} - The return value.\r\n   */\r\n  toJSON(flags = 0) {\r\n    const j = super.toJSON(flags)\r\n    return j\r\n  }\r\n\r\n  /**\r\n   * The fromJSON method decodes a json object for this type.\r\n   *\r\n   * @param {object} j - The j param.\r\n   * @param {number} flags - The flags param.\r\n   */\r\n  fromJSON(j, flags = 0) {\r\n    super.fromJSON(j, flags)\r\n  }\r\n}\r\n\r\nRegistry.register('CADBody', CADBody)\r\n\r\nexport { CADBody }\r\n","/* eslint-disable no-unused-vars */\r\nimport {\r\n  Vec2,\r\n  Vec3,\r\n  Color,\r\n  FilePathParameter,\r\n  BooleanParameter,\r\n  NumberParameter,\r\n  ColorParameter,\r\n  Vec3Parameter,\r\n  Version,\r\n  BinReader,\r\n  SystemDesc,\r\n  AssetItem,\r\n  AssetLoadContext,\r\n  TreeItem,\r\n  Registry,\r\n  resourceLoader,\r\n} from '@zeainc/zea-engine'\r\nimport { CADSurfaceLibrary } from './CADSurfaceLibrary.js'\r\nimport { CADTrimSetLibrary } from './CADTrimSetLibrary.js'\r\nimport { CADBodyLibrary } from './CADBodyLibrary.js'\r\nimport { CADBody } from './CADBody.js'\r\n\r\nconst cadFileExts = new RegExp('\\\\.(stp|step|jt|3dm|ifc|vlcad|zcad)$', 'i')\r\n\r\n// eslint-disable-next-line require-jsdoc\r\nfunction getLOD() {\r\n  const urlParams = new URLSearchParams(window.location.search)\r\n  if (urlParams.has('lod')) {\r\n    return Number.parseInt(urlParams.get('lod'))\r\n  }\r\n  switch (SystemDesc.deviceCategory) {\r\n    case 'Low':\r\n      return 1\r\n    case 'Medium':\r\n      return 2\r\n    case 'High':\r\n      return 3\r\n  }\r\n  return 1\r\n}\r\n\r\n/**\r\n * Class representing a CAD asset.\r\n *\r\n * **Parameters**\r\n * * **DataFilePath(`FilePathParameter`):** Hosts file information used to load the asset(Like the URL).\r\n * * **DisplayEdges(`BooleanParameter`):** Hides/Shows edges of the asset(Like a border).\r\n * * **EdgeColor(`ColorParameter`):** Specifies the color of the edge(border-color).\r\n *\r\n * **Events**\r\n * * **loaded:** Triggered when the  asset is loaded\r\n * @extends AssetItem\r\n */\r\nclass CADAsset extends AssetItem {\r\n  /**\r\n   * Create a CAD asset.\r\n   * @param {string} name - The name value.\r\n   */\r\n  constructor(name) {\r\n    super(name)\r\n\r\n    this.__trimSetLibrary = new CADTrimSetLibrary()\r\n    this.__surfaceLibrary = new CADSurfaceLibrary(this, this.__trimSetLibrary)\r\n    this.__bodyLibrary = new CADBodyLibrary()\r\n    this.__atlasSize = new Vec2()\r\n    this.__numCADBodyItems = 0\r\n    this.__loaded = false\r\n\r\n    this.__datafileParam = this.addParameter(new FilePathParameter('FilePath'))\r\n    this.addParameterDeprecationMapping('DataFilePath', 'FilePath')\r\n    this.__datafileParam.on('valueChanged', () => {\r\n      let url\r\n      const file = this.__datafileParam.getFileDesc()\r\n      if (file.metadata && file.metadata.ConvertFile) {\r\n        let zcadFile\r\n        const zcadfileext = new RegExp('\\\\.(vlcad|zcad)$', 'i')\r\n        file.metadata.ConvertFile.map((metadataFile) => {\r\n          if (zcadfileext.test(metadataFile.filename)) zcadFile = metadataFile\r\n        })\r\n        if (zcadFile) {\r\n          url = zcadFile.url\r\n        } else {\r\n          console.warn('ConvertFile metadata contains no vla file.')\r\n        }\r\n      } else if (file.url) {\r\n        url = file.url\r\n      } else {\r\n        console.warn('CADAsset unable to load file:', file)\r\n      }\r\n\r\n      this.load(url)\r\n    })\r\n\r\n    this.addParameter(new BooleanParameter('DisplayEdges', true))\r\n    this.addParameter(new ColorParameter('EdgeColor', new Color(0.1, 0.1, 0.1, 0.75)))\r\n\r\n    this.lod = getLOD()\r\n    this.curvatureToDetail = 0.5\r\n  }\r\n\r\n  /**\r\n   * Returns the loaded status of the AssetItem.\r\n   *\r\n   * @return {boolean} - Returns true if the asset has already loaded its data.\r\n   */\r\n  isLoaded() {\r\n    return this.__loaded\r\n  }\r\n\r\n  /**\r\n   * Returns `LOD` parameter value.\r\n   *\r\n   * @return {number} - The return value.\r\n   */\r\n  getLOD() {\r\n    return Math.max(0, this.lod)\r\n  }\r\n\r\n  /**\r\n   * The incCADBodyCount method.\r\n   * @private\r\n   */\r\n  incCADBodyCount() {\r\n    this.__numCADBodyItems++\r\n  }\r\n\r\n  /**\r\n   * Returns the value of number CADBody items in the asset.\r\n   *\r\n   * @return {number} - The return value.\r\n   */\r\n  getNumBodyItems() {\r\n    return this.__numCADBodyItems\r\n  }\r\n\r\n  /**\r\n   * Returns the instantiated `CADSurfaceLibrary` object on current Asset\r\n   *\r\n   * @return {CADSurfaceLibrary} - The return value.\r\n   */\r\n  getSurfaceLibrary() {\r\n    return this.__surfaceLibrary\r\n  }\r\n\r\n  /**\r\n   * Returns the instantiated `CADTrimSetLibrary` object of current Asset\r\n   *\r\n   * @return {CADTrimSetLibrary} - The return value.\r\n   */\r\n  getTrimSetLibrary() {\r\n    return this.__trimSetLibrary\r\n  }\r\n\r\n  /**\r\n   * Returns the instantiated `CADBodyLibrary` object of current Asset\r\n   *\r\n   * @return {CADBodyLibrary} - The return value.\r\n   */\r\n  getBodyLibrary() {\r\n    return this.__bodyLibrary\r\n  }\r\n\r\n  /**\r\n   * Returns the instantiated `MaterialLibrary` object of current Asset\r\n   *\r\n   * @return {MaterialLibrary} - The return value.\r\n   */\r\n  getMaterialLibrary() {\r\n    return this.__materials\r\n  }\r\n\r\n  // ////////////////////////////////////////\r\n  // Persistence\r\n\r\n  /**\r\n   * Returns the versioon of the data loaded by thie CADAsset.\r\n   *\r\n   * @return {string} - The return value.\r\n   */\r\n  getVersion() {\r\n    return this.cadfileversion\r\n  }\r\n\r\n  /**\r\n   * Initializes CADAsset's asset, material, version and layers; adding current `CADAsset` Geometry Item toall the layers in reader\r\n   *\r\n   * @param {BinReader} reader - The reader param.\r\n   * @param {AssetLoadContext} context - The load context object that provides additional data such as the units of the scene we are loading into.\r\n   */\r\n  readRootLevelBinary(reader, context) {\r\n    this.__numCADBodyItems = 0\r\n\r\n    context.versions['zea-cad'] = new Version(reader.loadStr())\r\n    context.sdk = reader.loadStr()\r\n    this.cadfileversion = context.versions['zea-cad']\r\n    // console.log('Loading CAD File version:', this.cadfileversion, ' exported using SDK:', context.cadSDK)\r\n\r\n    super.readBinary(reader, context)\r\n  }\r\n\r\n  /**\r\n   * Loads all the geometries and metadata from the asset file.\r\n   * @param {string} url - The URL of the asset to load\r\n   * @param {AssetLoadContext} context - The load context object that provides additional data such as paths to external references.\r\n   * @return {Promise} - Returns a promise that resolves once the load of the tree is complete. Geometries, textures and other resources might still be loading.\r\n   */\r\n  load(url, context = new AssetLoadContext()) {\r\n    if (this.__loadPromise) return this.__loadPromise\r\n    this.__loadPromise = new Promise((resolve, reject) => {\r\n      const folder = url.lastIndexOf('/') > -1 ? url.substring(0, url.lastIndexOf('/')) + '/' : ''\r\n      const filename = url.lastIndexOf('/') > -1 ? url.substring(url.lastIndexOf('/') + 1) : ''\r\n      const stem = filename.substring(0, filename.lastIndexOf('.'))\r\n\r\n      this.url = url\r\n\r\n      // These values are used by XRef to generate URLS.\r\n      context.assetItem = this\r\n      context.url = url\r\n      context.folder = folder\r\n      if (!context.resources) context.resources = {}\r\n      context.xrefs = {}\r\n\r\n      context.on('done', () => {\r\n        this.__loaded = true\r\n        resolve()\r\n        this.emit('loaded')\r\n      })\r\n\r\n      context.incrementAsync()\r\n\r\n      // Increment the resource loader counter to provided an update to the progress bar.\r\n      // preload in case we don't have embedded geoms.\r\n      // completed by geomLibrary.on('loaded' ..\r\n      resourceLoader.incrementWorkload(1)\r\n      this.__geomLibrary.once('loaded', () => {\r\n        // A chunk of geoms are now parsed, so update the resource loader.\r\n        resourceLoader.incrementWorkDone(1)\r\n      })\r\n\r\n      resourceLoader.loadFile('archive', url).then(\r\n        (entries) => {\r\n          // const desc = entries['desc.json']\r\n          //   ? JSON.parse(new TextDecoder('utf-8').decode(entries['desc.json']))\r\n          //   : { numGeomFiles: 0 }\r\n\r\n          const treeReader = new BinReader((entries.tree2 || entries.tree).buffer, 0, SystemDesc.isMobileDevice)\r\n\r\n          if (entries.bodies) {\r\n            this.__bodyLibrary.setBinaryBuffers(entries.bodiestoc.buffer, entries.bodies.buffer)\r\n          }\r\n\r\n          const name = this.getName()\r\n          this.readRootLevelBinary(treeReader, context)\r\n\r\n          // Maintain the name provided by the user before loading.\r\n          if (name != '') this.setName(name)\r\n\r\n          context.versions['zea-cad'] = this.getVersion()\r\n          context.versions['zea-engine'] = this.getEngineDataVersion()\r\n\r\n          if (entries.geoms) {\r\n            this.__geomLibrary.readBinaryBuffer(filename, entries.geoms.buffer, context)\r\n          } else if (entries['geomLibrary.json']) {\r\n            entries['desc.json']\r\n            const geomLibraryJSON = JSON.parse(new TextDecoder('utf-8').decode(entries['geomLibrary.json']))\r\n            const basePath = folder + stem\r\n            this.__geomLibrary.loadGeomFilesStream(geomLibraryJSON, basePath, context)\r\n          } else {\r\n            // No geoms in this file, so we won't wait for the 'done' event in the GeomLibrary.\r\n            resourceLoader.incrementWorkDone(1)\r\n          }\r\n\r\n          if (entries.trimSets) {\r\n            const trimSets = entries.trimSets || entries.trimsets || entries.trimSets2\r\n            const trimSetReader = new BinReader(trimSets.buffer, 0, SystemDesc.isMobileDevice)\r\n\r\n            this.__trimSetLibrary.setBinaryBuffer(trimSetReader, this.getVersion())\r\n          }\r\n\r\n          if (entries.curves) {\r\n            this.__surfaceLibrary.setBinaryBuffers(entries.curves.buffer, entries.surfaces.buffer, this.getVersion())\r\n          }\r\n\r\n          // console.log(this.__name, \" NumBaseItems:\", this.getNumBaseItems(), \" NumCADBodyItems:\", this.__numCADBodyItems)\r\n          context.decrementAsync()\r\n        },\r\n        (error) => {\r\n          resourceLoader.incrementWorkDone(1)\r\n          this.emit('error', error)\r\n          reject(error)\r\n        }\r\n      )\r\n    })\r\n\r\n    return this.__loadPromise\r\n  }\r\n\r\n  // ////////////////////////////////////////\r\n  // Persistence\r\n\r\n  /**\r\n   * The toJSON method encodes this type as a json object for persistences.\r\n   *\r\n   * @param {object} context - The context param.\r\n   * @param {number} flags - The flags param.\r\n   * @return {object} - The return value.\r\n   */\r\n  toJSON(context, flags) {\r\n    const j = super.toJSON(context, flags)\r\n    return j\r\n  }\r\n\r\n  /**\r\n   * The fromJSON method decodes a json object for this type.\r\n   *\r\n   * @param {object} j - The json object this item must decode.\r\n   * @param {object} context - The context param.\r\n   * @param {callback} onDone - The onDone param.\r\n   */\r\n  fromJSON(j, context, onDone) {\r\n    const loadAssetJSON = () => {\r\n      const flags = TreeItem.LoadFlags.LOAD_FLAG_LOADING_BIN_TREE_VALUES\r\n      super.fromJSON(j, context, flags, onDone)\r\n      context.decAsyncCount()\r\n\r\n      // If the asset is nested within a bigger asset, then\r\n      // this subtree can noow be flagged as loded(and added to the renderer);\r\n      if (!this.__loaded) {\r\n        this.emit('loaded')\r\n        this.__loaded = true\r\n      }\r\n    }\r\n\r\n    if (j.params && j.params.DataFilePath) {\r\n      this.__datafileLoaded = loadAssetJSON\r\n      context.incAsyncCount()\r\n      const filePathJSON = j.params.DataFilePath\r\n      delete j.params.DataFilePath\r\n      this.__datafileParam.fromJSON(filePathJSON, context)\r\n    } else {\r\n      loadAssetJSON()\r\n    }\r\n  }\r\n\r\n  // ////////////////////////////////////////////////////\r\n  // Debugging\r\n\r\n  /**\r\n   * The generatePolygonMeshSurfaces method.\r\n   * @param {number} lod - The lod param.\r\n   * @return {any} - The return value.\r\n   * @private\r\n   */\r\n  generatePolygonMeshSurfaces(lod = 0) {\r\n    // Traverse the tree adding items till we hit the leaves(which are usually GeomItems.)\r\n    // let count = 0\r\n    const surfacesTreeItem = new TreeItem('surfaces')\r\n    const traverse = (treeItem) => {\r\n      treeItem.getChildren().forEach((childItem) => {\r\n        if (childItem instanceof CADBody) {\r\n          const cadBodySurfaces = childItem.generatePolygonMeshSurfaces(lod)\r\n          const globalXfo = childItem.getParameter('GlobalXfo').getValue()\r\n          cadBodySurfaces.getParameter('GlobalXfo').setValue(globalXfo)\r\n          surfacesTreeItem.addChild(cadBodySurfaces)\r\n        } else traverse(childItem)\r\n      })\r\n    }\r\n    traverse(this)\r\n\r\n    surfaceLibrary.logFormfactors()\r\n    return surfacesTreeItem\r\n  }\r\n\r\n  /**\r\n   * The generateHullGeometry method.\r\n   * @return {any} - The return value.\r\n   * @private\r\n   */\r\n  generateHullGeometry() {\r\n    // Traverse the tree adding items till we hit the leaves(which are usually GeomItems.)\r\n    // let count = 0\r\n    const hullTreeItem = new TreeItem('hull')\r\n    const traverse = (treeItem) => {\r\n      treeItem.getChildren().forEach((childItem) => {\r\n        if (childItem instanceof CADBody) {\r\n          const cadBodyHulls = childItem.generateHullGeometry()\r\n          const globalXfo = childItem.getParameter('GlobalXfo').getValue()\r\n          hullTreeItem.getParameter('GlobalXfo').setValue(globalXfo)\r\n          hullTreeItem.addChild(cadBodyHulls)\r\n        } else traverse(childItem)\r\n      })\r\n    }\r\n    traverse(this)\r\n\r\n    surfaceLibrary.logFormfactors()\r\n    return hullTreeItem\r\n  }\r\n\r\n  // ////////////////////////////////////////\r\n  // Static Methods\r\n\r\n  /**\r\n   * Getter for LOADSTATE.\r\n   * @return {any} - The return value.\r\n   * @private\r\n   */\r\n  static get LOADSTATE() {\r\n    return LOADSTATE\r\n  }\r\n\r\n  /**\r\n   * The supportsExt method.\r\n   * @param {any} filename - The filename param.\r\n   * @return {any} - The return value.\r\n   * @private\r\n   */\r\n  static supportsExt(filename) {\r\n    return cadFileExts.test(filename)\r\n  }\r\n}\r\n\r\nRegistry.register('CADAsset', CADAsset)\r\n\r\nexport { CADAsset }\r\n","import { TreeItem, Registry } from '@zeainc/zea-engine'\r\n\r\n/**\r\n * Represents a Tree Item of an Assembly modeling. Brings together components to define a larger product.\r\n *\r\n * @extends TreeItem\r\n */\r\nclass CADAssembly extends TreeItem {\r\n  /**\r\n   * Create a CAD assembly.\r\n   *\r\n   * @param {string} name - The name of the tree item.\r\n   */\r\n  constructor(name) {\r\n    super(name)\r\n  }\r\n\r\n  /**\r\n   * The clone method constructs a new CADAssembly item, copies its values\r\n   * from this item and returns it.\r\n   *\r\n   * @param {number} flags - The flags param.\r\n   * @return {CADAssembly} - The return value.\r\n   */\r\n  clone(flags) {\r\n    const cloned = new CADAssembly()\r\n    cloned.copyFrom(this, flags)\r\n    return cloned\r\n  }\r\n\r\n  // ////////////////////////////////////////\r\n  // Persistence\r\n\r\n  /**\r\n   * The toJSON method encodes this type as a json object for persistences.\r\n   *\r\n   * @param {object} context - The context param.\r\n   * @param {number} flags - The flags param.\r\n   * @return {object} - Returns the json object.\r\n   */\r\n  toJSON(context, flags = 0) {\r\n    const j = super.toJSON(context, flags)\r\n    return j\r\n  }\r\n\r\n  /**\r\n   * The fromJSON method decodes a json object for this type.\r\n   *\r\n   * @param {object} j - The json object this item must decode.\r\n   * @param {object} context - The context param.\r\n   * @param {number} flags - The flags param.\r\n   */\r\n  fromJSON(j, context, flags = 0) {\r\n    super.fromJSON(j, context, flags)\r\n  }\r\n}\r\n\r\nRegistry.register('CADAssembly', CADAssembly)\r\n\r\nexport { CADAssembly }\r\n","import { TreeItem, Registry } from '@zeainc/zea-engine'\n\n/**\n * Represents a Part within a CAD assembly.\n *\n * @extends TreeItem\n */\nclass CADPart extends TreeItem {\n  /**\n   * Creates an instance of CADPart setting up the initial configuration for Material and Color parameters.\n   *\n   * @param {string} name - The name value.\n   */\n  constructor(name) {\n    super(name)\n  }\n\n  /**\n   * The clone method constructs a new CADPart, copies its values\n   * from this item and returns it.\n   *\n   * @param {number} flags - The flags param.\n   * @return {CADPart} - The return value.\n   */\n  clone(flags) {\n    const cloned = new CADPart()\n    cloned.copyFrom(this, flags)\n    return cloned\n  }\n\n  /**\n   * The copyFrom method.\n   * @param {CADPart} src - The src param.\n   * @param {number} flags - The flags param.\n   * @private\n   */\n  copyFrom(src, flags) {\n    super.copyFrom(src, flags)\n  }\n\n  // ///////////////////////////\n  // Persistence\n\n  /**\n   * Initializes CADPart's asset, material, version and layers; adding current `CADPart` Geometry Item toall the layers in reader\n   *\n   * @param {BinReader} reader - The reader param.\n   * @param {object} context - The context param.\n   */\n  readBinary(reader, context) {\n    super.readBinary(reader, context)\n  }\n\n  /**\n   * The toJSON method encodes this type as a json object for persistences.\n   *\n   * @param {number} flags - The flags param.\n   * @return {object} - The return value.\n   */\n  toJSON(flags = 0) {\n    const j = super.toJSON(flags)\n    return j\n  }\n\n  /**\n   * The fromJSON method decodes a json object for this type.\n   *\n   * @param {object} j - The j param.\n   * @param {number} flags - The flags param.\n   */\n  fromJSON(j, flags = 0) {\n    super.fromJSON(j, flags)\n  }\n}\n\nRegistry.register('CADPart', CADPart)\n\nexport { CADPart }\n","import { TreeItem, Registry, Color } from '@zeainc/zea-engine'\r\nimport { CADAsset } from './CADAsset.js'\r\nimport { CADPart } from './CADPart.js'\r\n\r\nconst findCADAsset = (treeItem) => {\r\n  while (!(treeItem instanceof CADAsset)) treeItem = treeItem.getOwner()\r\n  return treeItem\r\n}\r\nconst traverse = (treeItem, callback) => {\r\n  const __c = (treeItem, depth) => {\r\n    const children = treeItem.getChildren()\r\n    for (const childItem of children) {\r\n      if (childItem) __t(childItem, depth + 1)\r\n    }\r\n  }\r\n\r\n  const __t = (treeItem, depth) => {\r\n    if (callback(treeItem, depth) != false) {\r\n      __c(treeItem, depth)\r\n    }\r\n  }\r\n  __t(treeItem, 1)\r\n}\r\n\r\nconst highlightColor = new Color('#F9CE03')\r\nhighlightColor.a = 0.1\r\n\r\n/**\r\n * Represents a view of PMI data. within a CAD assembly.\r\n *\r\n * @extends TreeItem\r\n */\r\nclass PMIItem extends TreeItem {\r\n  /**\r\n   * Creates an instance of PMIItem setting up the initial configuration for Material and Color parameters.\r\n   *\r\n   * @param {string} name - The name value.\r\n   */\r\n  constructor(name) {\r\n    super(name)\r\n  }\r\n\r\n  /**\r\n   * The clone method constructs a new PMIItem, copies its values\r\n   * from this item and returns it.\r\n   *\r\n   * @param {number} flags - The flags param.\r\n   * @return {PMIItem} - The return value.\r\n   */\r\n  clone(flags) {\r\n    const cloned = new PMIItem()\r\n    cloned.copyFrom(this, flags)\r\n    return cloned\r\n  }\r\n\r\n  /**\r\n   * Changes the current state of the selection of this item.\r\n   *\r\n   * @emits `selectedChanged` with selected state\r\n   * @param {boolean} sel - Boolean indicating the new selection state.\r\n   */\r\n  setSelected(sel) {\r\n    super.setSelected(sel)\r\n    if (sel) this.activate()\r\n    else this.deactivate()\r\n  }\r\n\r\n  /**\r\n   * Activates the PMIItem, adjusting visibility of the PMI items and the camera Xfo\r\n   *\r\n   * @param {Camera} camera - Boolean indicating the new selection state.\r\n   */\r\n  activate() {\r\n    console.log('activate')\r\n    this.getParameters().forEach((param) => {\r\n      const name = param.getName()\r\n      if (name != 'Visible' && name != 'GlobalXfo' && name != 'LocalXfo' && name != 'BoundingBox') console.log(name)\r\n    })\r\n    const cadAsset = findCADAsset(this)\r\n    // const cadPart = findCADPart(this)\r\n    const pmiContainer = this.getOwner().getOwner()\r\n    const pmiOwner = pmiContainer.getOwner()\r\n    if (pmiOwner) {\r\n      const linkedEntitiesParam = this.getParameter('LinkedEntities')\r\n      if (linkedEntitiesParam) {\r\n        const linkedEntityPaths = linkedEntitiesParam.getValue()\r\n        console.log(linkedEntityPaths)\r\n\r\n        linkedEntityPaths.forEach((pathStr) => {\r\n          const path = pathStr.split(', ')\r\n          try {\r\n            const linkedEntity = cadAsset.resolvePath(path)\r\n            if (linkedEntity) {\r\n              linkedEntity.addHighlight('pmi', highlightColor, true)\r\n            }\r\n          } catch (e) {\r\n            console.log(e.message)\r\n            // traverse(pmiOwner, (treeItem) => {\r\n            //   if (treeItem.getName() == 'PMI') return false\r\n            //   console.log(treeItem.getName())\r\n            //   if (treeItem.getName() == pathStr) {\r\n            //     linkedEntity.addHighlight('pmi', highlightColor, true)\r\n            //     return false\r\n            //   }\r\n            // })\r\n          }\r\n        })\r\n      }\r\n    }\r\n  }\r\n  deactivate() {\r\n    console.log('deactivate')\r\n    const cadAsset = findCADAsset(this)\r\n    // const cadPart = findCADPart(this)\r\n    const pmiOwner = this.getOwner().getOwner()\r\n    if (pmiOwner) {\r\n      const linkedEntitiesParam = this.getParameter('LinkedEntities')\r\n      if (linkedEntitiesParam) {\r\n        const linkedEntityPaths = linkedEntitiesParam.getValue()\r\n        console.log(linkedEntityPaths)\r\n\r\n        linkedEntityPaths.forEach((pathStr) => {\r\n          const path = pathStr.split(', ')\r\n          try {\r\n            const linkedEntity = cadAsset.resolvePath(path)\r\n            if (linkedEntity) {\r\n              linkedEntity.removeHighlight('pmi', true)\r\n            }\r\n          } catch (e) {}\r\n        })\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nRegistry.register('PMIItem', PMIItem)\r\n\r\nexport { PMIItem }\r\n","import { TreeItem, Registry } from '@zeainc/zea-engine'\r\n\r\n/**\r\n * Represents a view of PMI data. within a CAD assembly.\r\n *\r\n * @extends TreeItem\r\n */\r\nclass PMIView extends TreeItem {\r\n  /**\r\n   * Creates an instance of PMIView setting up the initial configuration for Material and Color parameters.\r\n   *\r\n   * @param {string} name - The name value.\r\n   */\r\n  constructor(name) {\r\n    super(name)\r\n  }\r\n\r\n  /**\r\n   * The clone method constructs a new PMIView, copies its values\r\n   * from this item and returns it.\r\n   *\r\n   * @param {number} flags - The flags param.\r\n   * @return {PMIView} - The return value.\r\n   */\r\n  clone(flags) {\r\n    const cloned = new PMIView()\r\n    cloned.copyFrom(this, flags)\r\n    return cloned\r\n  }\r\n\r\n  /**\r\n   * Activates the PMIView, adjusting visibility of the PMI items and the camera Xfo\r\n   *\r\n   * @param {Camera} camera - Boolean indicating the new selection state.\r\n   */\r\n  activate(camera) {\r\n    super.activate()\r\n    // const pmiItems = this.getOwner().getOwner().getChildByName('PMI')\r\n    // const graphicalItems = this.getParameter('GraphicalElements').getValue()\r\n    // pmiItems.getChildren().forEach((pmiItem) => {\r\n    //   const visible = graphicalItems.includes(pmiItem.getName())\r\n    //   pmiItem.setVisible(visible)\r\n    // })\r\n\r\n    if (camera) {\r\n      const cameraXfo = this.getParameter('GlobalXfo').getValue().clone()\r\n      const TargetPoint = this.getParameter('TargetPoint').getValue()\r\n      // const UpDirection = this.getParameter('UpDirection').getValue()\r\n      TargetPoint.scaleInPlace(cameraXfo.sc.z)\r\n      const dist = cameraXfo.tr.distanceTo(TargetPoint) // * cameraXfo.sc.z\r\n      cameraXfo.sc.set(1.0, 1.0, 1.0)\r\n\r\n      camera.getParameter('GlobalXfo').setValue(cameraXfo)\r\n      camera.setFocalDistance(dist)\r\n    }\r\n  }\r\n}\r\n\r\nRegistry.register('PMIView', PMIView)\r\n\r\nexport { PMIView }\r\n","import { Registry, AssetLoadContext, Xfo } from '@zeainc/zea-engine'\r\nimport { CADAsset } from './CADAsset'\r\n\r\n/**\r\n * Represents a view of PMI data. within a CAD assembly.\r\n *\r\n * @extends TreeItem\r\n */\r\nclass XRef extends CADAsset {\r\n  /**\r\n   * Creates an instance of XRef setting up the initial configuration for Material and Color parameters.\r\n   *\r\n   * @param {string} name - The name value.\r\n   */\r\n  constructor(name) {\r\n    super(name)\r\n  }\r\n\r\n  /**\r\n   * The clone method constructs a new XRef, copies its values\r\n   * from this item and returns it.\r\n   *\r\n   * @param {number} flags - The flags param.\r\n   * @return {XRef} - The return value.\r\n   */\r\n  clone(flags) {\r\n    const cloned = new XRef()\r\n    cloned.copyFrom(this, flags)\r\n    return cloned\r\n  }\r\n\r\n  // ///////////////////////////\r\n  // Persistence\r\n\r\n  /**\r\n   * Initializes XRef's asset, material, version and layers; adding current `XRef` Geometry Item toall the layers in reader\r\n   *\r\n   * @param {BinReader} reader - The reader param.\r\n   * @param {object} context - The context param.\r\n   */\r\n  readBinary(reader, context) {\r\n    reader.loadStr() // read type\r\n    const name = reader.loadStr() // read name\r\n    this.setName(name)\r\n    let relativePath = reader.loadStr()\r\n\r\n    if (context.versions['zea-cad'].compare([3, 6, 2]) > 0) {\r\n      const xfo = new Xfo()\r\n      xfo.tr = reader.loadFloat32Vec3()\r\n      xfo.ori = reader.loadFloat32Quat()\r\n      this.__localXfoParam.loadValue(xfo)\r\n    } else {\r\n      // Note: the SpatialBridge now encodes the 'ReferenceName' into the\r\n      // XRef, while CADEx didn't provide one. Use the name if it is provided.\r\n      if (name == '') this.setName(relativePath)\r\n    }\r\n\r\n    if (context.assets[relativePath]) {\r\n      const srcAsset = context.assets[relativePath]\r\n      if (srcAsset.isLoaded()) {\r\n        this.copyFrom(srcAsset, 0)\r\n      } else {\r\n        srcAsset.on('loaded', () => {\r\n          this.copyFrom(srcAsset, 0)\r\n        })\r\n      }\r\n    } else {\r\n      context.assets[relativePath] = this\r\n\r\n      if (!context.resources[relativePath]) {\r\n        // Generate a path based on the path of the parent CADAsset.\r\n        // const stem = relativePath.substring(0, relativePath.lastIndexOf('.'))\r\n        // context.resources[relativePath] = context.folder + stem + '.zcad'\r\n        if (relativePath.includes('/')) {\r\n          relativePath = relativePath.slice(relativePath.lastIndexOf('/') + 1)\r\n        } else if (relativePath.includes('\\\\')) {\r\n          relativePath = relativePath.slice(relativePath.lastIndexOf('\\\\') + 1)\r\n        }\r\n        if (!context.resources[relativePath]) {\r\n          context.resources[relativePath] = context.folder + relativePath + '.zcad'\r\n        }\r\n      }\r\n\r\n      if (context.resources[relativePath]) {\r\n        console.log('resolving XRef:', relativePath, ' > ', context.resources[relativePath])\r\n        const url = context.resources[relativePath]\r\n        context.incrementAsync()\r\n\r\n        if (context.xrefs[relativePath]) {\r\n          const xref = context.xrefs[relativePath]\r\n          if (!xref.isLoaded()) {\r\n            xref.on('loaded', () => {\r\n              this.copyFrom(xref)\r\n            })\r\n          } else {\r\n            this.copyFrom(xref)\r\n          }\r\n        } else {\r\n          context.xrefs[relativePath] = this\r\n          this.load(url, new AssetLoadContext(context)).then(\r\n            () => {\r\n              context.decrementAsync()\r\n            },\r\n            (error) => {\r\n              console.log(`While Loading ${this.getPath()} unable to resolve ${relativePath}`)\r\n              context.decrementAsync()\r\n            }\r\n          )\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nRegistry.register('XRef', XRef)\r\n\r\nexport { XRef }\r\n","import { Lines, Mesh, GLMesh, GLLines, Plane } from '@zeainc/zea-engine'\r\n\r\nimport { drawShaderAttribsStride } from './CADConstants.js'\r\n\r\n/** This class abstracts the rendering of a collection of geometries to screen.\r\n * @extends Lines\r\n * @ignore\r\n */\r\nclass SurfaceNormals extends Lines {\r\n  /**\r\n   * Create surface normals.\r\n   * @param {number} u - The u value.\r\n   * @param {number} v - The v value.\r\n   */\r\n  constructor(u, v) {\r\n    super()\r\n    this.setNumSegments(u * v)\r\n    this.setNumVertices(u * v * 2)\r\n    const positions = this.getVertexAttribute('positions')\r\n    for (let i = 0; i < v; i++) {\r\n      const y = i / (v - 1) - 0.5\r\n      for (let j = 0; j < u; j++) {\r\n        const x = j / (u - 1) - 0.5\r\n        const id = i * u + j\r\n        positions.getValueRef(id * 2).set(x, y, 0.0)\r\n        positions.getValueRef(id * 2 + 1).set(x, y, 1.0)\r\n        this.setSegmentVertexIndices(id, id * 2, id * 2 + 1)\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/** Class representing a fan.\r\n * @extends Mesh\r\n * @ignore\r\n */\r\nclass Fan extends Mesh {\r\n  /**\r\n   * Create a fan.\r\n   * @param {any} vertexCount - The vertexCount value.\r\n   */\r\n  constructor(vertexCount) {\r\n    super()\r\n    this.setNumVertices(vertexCount)\r\n    const faceCount = vertexCount - 2\r\n    this.setFaceCounts([faceCount])\r\n\r\n    // ////////////////////////////\r\n    // build the topology\r\n    for (let j = 0; j < faceCount; j++) {\r\n      this.setFaceVertexIndices(j, [0, j + 1, j + 2])\r\n    }\r\n    const positions = this.getVertexAttribute('positions')\r\n    for (let i = 0; i < vertexCount; i++) {\r\n      // Note: the 'x,y' values are used as uv coords\r\n      // to look up the actual vertex values in the texture.\r\n      // (with a 0.5, 0.5 offset)\r\n      positions.getValueRef(i).set(i / vertexCount - 0.5, -0.5, 0.0)\r\n    }\r\n  }\r\n}\r\n\r\n/** Class representing a sub set.\r\n * @ignore\r\n */\r\nclass SubSet {\r\n  /**\r\n   * Create a sub set.\r\n   * @param {any} gl - The gl value.\r\n   */\r\n  constructor(gl) {\r\n    this.__gl = gl\r\n    this.__drawCoordsArray = null\r\n    this.__drawCoordsBuffer = null\r\n    this.__drawCount = 0 // The number of visible drawn geoms.\r\n\r\n    this.__bindAttr = (location, channels, type, stride, offset, instanced = true) => {\r\n      gl.enableVertexAttribArray(location)\r\n      gl.vertexAttribPointer(location, channels, type, false, stride, offset)\r\n      if (instanced) gl.vertexAttribDivisor(location, 1) // This makes it instanced\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The setDrawItems method.\r\n   * @param {any} itemsArray - The itemsArray param.\r\n   */\r\n  setDrawItems(itemsArray) {\r\n    if (this.__drawCoordsBuffer) {\r\n      this.__gl.deleteBuffer(this.__drawCoordsBuffer)\r\n      this.__drawCoordsBuffer = null\r\n    }\r\n    const gl = this.__gl\r\n    this.__drawCoordsBuffer = gl.createBuffer()\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.__drawCoordsBuffer)\r\n    gl.bufferData(gl.ARRAY_BUFFER, itemsArray, gl.STATIC_DRAW)\r\n    this.__drawCount = itemsArray.length / drawShaderAttribsStride\r\n    return this.__drawCount\r\n  }\r\n\r\n  /**\r\n   * The addDrawItems method.\r\n   * @param {any} itemsArray - The itemsArray param.\r\n   */\r\n  addDrawItems(itemsArray) {\r\n    // console.log(\"addDrawItems:\" + itemsArray);\r\n    if (!this.__drawCoordsArray) {\r\n      this.__drawCoordsArray = itemsArray\r\n    } else {\r\n      const new_Array = new Float32Array(this.__drawCoordsArray.length + itemsArray.length)\r\n      new_Array.set(this.__drawCoordsArray)\r\n      new_Array.set(itemsArray, this.__drawCoordsArray.length)\r\n      this.__drawCoordsArray = new_Array\r\n    }\r\n\r\n    if (this.__drawCoordsBuffer) {\r\n      this.__gl.deleteBuffer(this.__drawCoordsBuffer)\r\n      this.__drawCoordsBuffer = null\r\n    }\r\n\r\n    const gl = this.__gl\r\n    this.__drawCoordsBuffer = gl.createBuffer()\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.__drawCoordsBuffer)\r\n    gl.bufferData(gl.ARRAY_BUFFER, this.__drawCoordsArray, gl.STATIC_DRAW)\r\n\r\n    this.__drawCount += itemsArray.length / drawShaderAttribsStride\r\n    return this.__drawCount\r\n  }\r\n\r\n  /**\r\n   * The getDrawCount method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getDrawCount() {\r\n    return this.__drawCount\r\n  }\r\n\r\n  // ////////////////////////////////////\r\n  // Drawing\r\n\r\n  /**\r\n   * The bind method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @return {any} - The return value.\r\n   */\r\n  bind(renderstate) {\r\n    if (this.__drawCount == 0) {\r\n      return 0\r\n    }\r\n\r\n    const gl = this.__gl\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.__drawCoordsBuffer)\r\n\r\n    const attrs = renderstate.attrs\r\n    this.__bindAttr(attrs.drawCoords.location, 4, gl.FLOAT, drawShaderAttribsStride * 4, 0)\r\n    // this.__bindAttr(attrs.drawItemTexAddr.location, 2, gl.FLOAT, drawShaderAttribsStride * 4, 4 * 4)\r\n\r\n    return this.__drawCount\r\n  }\r\n\r\n  destroy() {\r\n    const gl = this.__gl\r\n    gl.deleteBuffer(this.__drawCoordsBuffer)\r\n    this.__drawCoordsBuffer = null\r\n  }\r\n}\r\n\r\nconst __cache = {}\r\n\r\n/** Class representing a GL surface draw set.\r\n * @ignore\r\n */\r\nclass GLSurfaceDrawSet {\r\n  /**\r\n   * Create a GL surface draw set.\r\n   * @param {any} gl - The gl value.\r\n   * @param {number} x - The x value.\r\n   * @param {number} y - The y value.\r\n   */\r\n  constructor(gl, x, y) {\r\n    // console.log(\"GLSurfaceDrawSet:\" + x + \",\" + y)\r\n    this.__gl = gl\r\n\r\n    if (x == 0 || y == 0) console.error('invalid GLSurfaceDrawSet:' + x + ',' + y)\r\n\r\n    if (y == 1) {\r\n      const key = x\r\n      if (!__cache[key]) {\r\n        __cache[key] = new GLMesh(gl, new Fan(x))\r\n      }\r\n      this.__glgeom = __cache[key]\r\n      this.__numTris = x - 2\r\n      this.__glnormalsgeom = new GLLines(gl, new SurfaceNormals(x, y))\r\n\r\n      this.key = key\r\n    } else {\r\n      const key = x + 'x' + y\r\n      if (!__cache[key]) {\r\n        __cache[key] = new GLMesh(gl, new Plane(1.0, 1.0, x - 1, y - 1))\r\n      }\r\n      this.__glgeom = __cache[key]\r\n      this.__numTris = (x - 1) * (y - 1) * 2\r\n      this.__glnormalsgeom = new GLLines(gl, new SurfaceNormals(x, y))\r\n\r\n      this.key = key\r\n    }\r\n    this.__quadDetail = [x - 1, y - 1]\r\n    this.__freeIndices = []\r\n    this.__subSets = {}\r\n  }\r\n\r\n  /**\r\n   * The setDrawItems method.\r\n   * @param {any} itemsArray - The itemsArray param.\r\n   * @param {any} key - The key param.\r\n   * @return {any} - The return value.\r\n   */\r\n  setDrawItems(itemsArray, key) {\r\n    if (!this.__subSets[key]) {\r\n      this.__subSets[key] = new SubSet(this.__gl)\r\n    }\r\n    const drawCount = this.__subSets[key].setDrawItems(itemsArray)\r\n    return this.__numTris * drawCount\r\n  }\r\n\r\n  /**\r\n   * The addDrawItems method.\r\n   * @param {any} itemsArray - The itemsArray param.\r\n   * @param {any} key - The key param.\r\n   * @return {any} - The return value.\r\n   */\r\n  addDrawItems(itemsArray, key) {\r\n    if (!this.__subSets[key]) {\r\n      this.__subSets[key] = new SubSet(this.__gl)\r\n    }\r\n    const drawCount = this.__subSets[key].addDrawItems(itemsArray)\r\n    // console.log(this.key, \"key:\", key, drawCount)\r\n\r\n    return this.__numTris * drawCount\r\n  }\r\n\r\n  /**\r\n   * The getDrawCount method.\r\n   * @param {any} key - The key param.\r\n   * @return {number} - The return value.\r\n   */\r\n  getDrawCount(key) {\r\n    if (this.__subSets[key]) return this.__subSets[key].getDrawCount()\r\n    return 0\r\n  }\r\n\r\n  // ////////////////////////////////////\r\n  // Drawing\r\n\r\n  /**\r\n   * The draw method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @param {any} key - The key param.\r\n   */\r\n  draw(renderstate, key) {\r\n    const subSet = this.__subSets[key]\r\n    if (!subSet) return\r\n\r\n    const gl = this.__gl\r\n    const unifs = renderstate.unifs\r\n\r\n    if (unifs.quadDetail) {\r\n      gl.uniform2i(unifs.quadDetail.location, this.__quadDetail[0], this.__quadDetail[1])\r\n    }\r\n\r\n    this.__glgeom.bind(renderstate)\r\n\r\n    const drawCount = subSet.bind(renderstate)\r\n\r\n    renderstate.bindViewports(renderstate.unifs, () => {\r\n      this.__glgeom.drawInstanced(drawCount)\r\n\r\n      // To debug the mesh topology we can render as lines instead.\r\n      // gl.drawElementsInstanced(\r\n      //   this.__glgeom.__gl.LINES,\r\n      //   this.__glgeom.__numTriIndices,\r\n      //   this.__glgeom.__indexDataType,\r\n      //   0,\r\n      //   drawCount\r\n      // )\r\n    })\r\n  }\r\n\r\n  /**\r\n   * The drawNormals method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @param {any} key - The key param.\r\n   */\r\n  drawNormals(renderstate, key) {\r\n    if (!this.__glnormalsgeom) return\r\n\r\n    const subSet = this.__subSets[key]\r\n    if (!subSet) return\r\n    const gl = this.__gl\r\n    const unifs = renderstate.unifs\r\n\r\n    if (unifs.quadDetail) {\r\n      gl.uniform2i(unifs.quadDetail.location, this.__quadDetail[0], this.__quadDetail[1])\r\n    }\r\n\r\n    this.__glnormalsgeom.bind(renderstate)\r\n\r\n    const drawCount = subSet.bind(renderstate)\r\n\r\n    renderstate.bindViewports(renderstate.unifs, () => {\r\n      this.__glnormalsgeom.drawInstanced(drawCount)\r\n    })\r\n  }\r\n\r\n  destroy() {\r\n    // Note:  this.__glgeom is shared between all GLCADAssets using a global cache. See above\r\n    // this.__glgeom.destroy()\r\n\r\n    if (this.__glnormalsgeom) this.__glnormalsgeom.destroy()\r\n\r\n    for (const key in this.__subSets) {\r\n      let subSet = this.__subSets[key]\r\n      subSet.destroy()\r\n    }\r\n  }\r\n}\r\n\r\nexport { GLSurfaceDrawSet }\r\n","import { Lines, GLLines } from '@zeainc/zea-engine'\r\nimport { drawShaderAttribsStride } from './CADConstants.js'\r\n\r\n/** Class representing an Edge\r\n * @private\r\n */\r\nclass Edge extends Lines {\r\n  /**\r\n   * Create a strip.\r\n   * @param {number} detail - The detail value.\r\n   */\r\n  constructor(detail = 1) {\r\n    super()\r\n    this.setNumVertices(detail + 1)\r\n    this.setNumSegments(detail)\r\n    const positions = this.getVertexAttribute('positions')\r\n    for (let i = 0; i <= detail; i++) {\r\n      if (i < detail) this.setSegmentVertexIndices(i, i, i + 1)\r\n      // Note: the 'x,y' values are used as uv coords\r\n      // to look up the actual vertex values in the texture.\r\n      // (with a 0.5, 0.5 offset)\r\n      positions.getValueRef(i).set(i / detail, 0.0, 0.0)\r\n    }\r\n    this.emit('geomDataTopologyChanged')\r\n  }\r\n}\r\n\r\n/** Class representing a sub set.\r\n * @private\r\n */\r\nclass SubSet {\r\n  /**\r\n   * Create a sub set.\r\n   * @param {any} gl - The gl value.\r\n   */\r\n  constructor(gl) {\r\n    this.__gl = gl\r\n    this.__drawCoordsArray = null\r\n    this.__drawCoordsBuffer = null\r\n    this.__drawCount = 0 // The number of visible drawn geoms.\r\n\r\n    this.__bindAttr = (location, channels, type, stride, offset, instanced = true) => {\r\n      gl.enableVertexAttribArray(location)\r\n      gl.vertexAttribPointer(location, channels, type, false, stride, offset)\r\n      if (instanced) gl.vertexAttribDivisor(location, 1) // This makes it instanced\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The setDrawItems method.\r\n   * @param {any} itemsArray - The itemsArray param.\r\n   */\r\n  setDrawItems(itemsArray) {\r\n    if (this.__drawCoordsBuffer) {\r\n      this.__gl.deleteBuffer(this.__drawCoordsBuffer)\r\n      this.__drawCoordsBuffer = null\r\n    }\r\n    const gl = this.__gl\r\n    this.__drawCoordsBuffer = gl.createBuffer()\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.__drawCoordsBuffer)\r\n    gl.bufferData(gl.ARRAY_BUFFER, itemsArray, gl.STATIC_DRAW)\r\n    this.__drawCount = itemsArray.length / drawShaderAttribsStride\r\n    return this.__drawCount\r\n  }\r\n\r\n  /**\r\n   * The addDrawItems method.\r\n   * @param {any} itemsArray - The itemsArray param.\r\n   */\r\n  addDrawItems(itemsArray) {\r\n    // console.log(\"addDrawItems:\" + itemsArray);\r\n    if (!this.__drawCoordsArray) {\r\n      this.__drawCoordsArray = itemsArray\r\n    } else {\r\n      const new_Array = new Float32Array(this.__drawCoordsArray.length + itemsArray.length)\r\n      new_Array.set(this.__drawCoordsArray)\r\n      new_Array.set(itemsArray, this.__drawCoordsArray.length)\r\n      this.__drawCoordsArray = new_Array\r\n    }\r\n\r\n    if (this.__drawCoordsBuffer) {\r\n      this.__gl.deleteBuffer(this.__drawCoordsBuffer)\r\n      this.__drawCoordsBuffer = null\r\n    }\r\n\r\n    const gl = this.__gl\r\n    this.__drawCoordsBuffer = gl.createBuffer()\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.__drawCoordsBuffer)\r\n    gl.bufferData(gl.ARRAY_BUFFER, this.__drawCoordsArray, gl.STATIC_DRAW)\r\n\r\n    this.__drawCount += itemsArray.length / drawShaderAttribsStride\r\n    return this.__drawCount\r\n  }\r\n\r\n  /**\r\n   * The getDrawCount method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getDrawCount() {\r\n    return this.__drawCount\r\n  }\r\n\r\n  // ////////////////////////////////////\r\n  // Drawing\r\n\r\n  /**\r\n   * The bind method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @return {any} - The return value.\r\n   */\r\n  bind(renderstate) {\r\n    if (this.__drawCount == 0) {\r\n      return 0\r\n    }\r\n    const gl = this.__gl\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.__drawCoordsBuffer)\r\n\r\n    const attrs = renderstate.attrs\r\n    this.__bindAttr(attrs.drawCoords.location, 4, gl.FLOAT, drawShaderAttribsStride * 4, 0)\r\n    // this.__bindAttr(attrs.drawItemTexAddr.location, 2, gl.FLOAT, drawShaderAttribsStride * 4, 4 * 4)\r\n\r\n    return this.__drawCount\r\n  }\r\n\r\n  destroy() {\r\n    const gl = this.__gl\r\n    gl.deleteBuffer(this.__drawCoordsBuffer)\r\n    this.__drawCoordsBuffer = null\r\n  }\r\n}\r\n\r\nconst __cache = {}\r\n\r\n/** Class representing a GL surface draw set.\r\n * @private\r\n */\r\nclass GLCurveDrawSet {\r\n  /**\r\n   * Create a GL surface draw set.\r\n   * @param {any} gl - The gl value.\r\n   * @param {number} x - The x value.\r\n   * @param {number} y - The y value.\r\n   */\r\n  constructor(gl, detail) {\r\n    // console.log(\"GLCurveDrawSet:\" + x + \",\" + y)\r\n    this.__gl = gl\r\n\r\n    if (detail == 0) console.error('invalid GLCurveDrawSet:' + detail)\r\n\r\n    if (!__cache[detail]) {\r\n      __cache[detail] = new GLLines(gl, new Edge(detail))\r\n    }\r\n    this.key = detail\r\n    this.__glgeom = __cache[detail]\r\n    this.__edgeDetail = detail\r\n    this.__freeIndices = []\r\n    this.__subSets = {}\r\n    this.__numDrawItems = 0\r\n  }\r\n\r\n  /**\r\n   * The setDrawItems method.\r\n   * @param {any} itemsArray - The itemsArray param.\r\n   * @param {any} key - The key param.\r\n   * @return {any} - The return value.\r\n   */\r\n  setDrawItems(itemsArray, key) {\r\n    if (!this.__subSets[key]) {\r\n      this.__subSets[key] = new SubSet(this.__gl)\r\n    }\r\n    this.__subSets[key].setDrawItems(itemsArray)\r\n\r\n    this.__numDrawItems += itemsArray.length / 2\r\n    return this.__numDrawItems\r\n  }\r\n\r\n  /**\r\n   * The addDrawItems method.\r\n   * @param {any} itemsArray - The itemsArray param.\r\n   * @param {any} key - The key param.\r\n   * @return {any} - The return value.\r\n   */\r\n  addDrawItems(itemsArray, key) {\r\n    if (!this.__subSets[key]) {\r\n      this.__subSets[key] = new SubSet(this.__gl)\r\n    }\r\n    this.__numDrawItems += this.__subSets[key].addDrawItems(itemsArray)\r\n    // console.log(this.key, \"key:\", key, this.__numDrawItems)\r\n  }\r\n\r\n  /**\r\n   * The getDrawCount method.\r\n   * @param {any} key - The key param.\r\n   * @return {number} - The return value.\r\n   */\r\n  getDrawCount(key) {\r\n    if (this.__subSets[key]) return this.__subSets[key].getDrawCount()\r\n    return 0\r\n  }\r\n\r\n  // ////////////////////////////////////\r\n  // Drawing\r\n\r\n  /**\r\n   * The draw method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @param {any} key - The key param.\r\n   */\r\n  draw(renderstate, key) {\r\n    const subSet = this.__subSets[key]\r\n    if (!subSet) return\r\n\r\n    const gl = this.__gl\r\n    const unifs = renderstate.unifs\r\n\r\n    if (unifs.edgeDetail) {\r\n      gl.uniform1i(unifs.edgeDetail.location, this.__edgeDetail)\r\n    }\r\n\r\n    this.__glgeom.bind(renderstate)\r\n\r\n    const drawCount = subSet.bind(renderstate)\r\n    renderstate.bindViewports(renderstate.unifs, () => {\r\n      this.__glgeom.drawInstanced(drawCount)\r\n    })\r\n  }\r\n\r\n  destroy() {\r\n    // Note:  this.__glgeom is shared between all GLCADAssets using a global cache. See above\r\n    // this.__glgeom.destroy()\r\n\r\n    if (this.__glnormalsgeom) this.__glnormalsgeom.destroy()\r\n\r\n    for (const key in this.__subSets) {\r\n      let subSet = this.__subSets[key]\r\n      subSet.destroy()\r\n    }\r\n  }\r\n}\r\n\r\nexport { GLCurveDrawSet }\r\n","/* eslint-disable camelcase */\r\nimport { GLShader, shaderLibrary, Registry } from '@zeainc/zea-engine'\r\n\r\n/** Class representing a GL evaluate CAD curve shader.\r\n * @extends GLShader\r\n * @ignore\r\n */\r\nclass GLEvaluateCADCurveShader extends GLShader {\r\n  /**\r\n   * Create a GL evaluate CAD curve shader.\r\n   * @param {any} gl - The gl value.\r\n   * @ignore\r\n   */\r\n  constructor(gl) {\r\n    super(gl)\r\n\r\n    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(\r\n      'GLEvaluateCADCurveShader.vertexShader',\r\n      `\r\nprecision highp float;\r\n\r\nattribute vec3 positions;\r\ninstancedattribute vec4 patchCoords;         // where the values will be written to in the target texture.\r\ninstancedattribute vec2 curveDataCoords;     // where the data will come from in the source texture\r\n\r\nuniform ivec2 curvesAtlasTextureSize;\r\n\r\n/* VS Outputs */\r\nvarying vec2 v_geomDataCoords;\r\nvarying vec2 v_patchSize;\r\nvarying vec2 v_vertexCoord;\r\n\r\n\r\n\r\nvoid main(void) {\r\n\r\n  vec2 patchPos = patchCoords.xy;\r\n  v_patchSize = patchCoords.zw;\r\n\r\n  v_geomDataCoords = curveDataCoords;\r\n  v_vertexCoord = (positions.xy + 0.5) * v_patchSize;\r\n\r\n  vec2 pos = (patchPos + v_vertexCoord) / vec2(curvesAtlasTextureSize);\r\n  gl_Position =  vec4((pos - 0.5) * 2.0, 0.0, 1.0);\r\n}\r\n`\r\n    )\r\n\r\n    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(\r\n      'GLEvaluateCADCurveShader.fragmentShader',\r\n      `\r\n// #extension GL_EXT_draw_buffers : require\r\nprecision highp float;\r\n\r\n/* VS Outputs */\r\nvarying vec2 v_geomDataCoords;\r\nvarying vec2 v_patchSize;\r\nvarying vec2 v_vertexCoord;\r\n\r\n\r\nstruct PosNorm {\r\n  vec3 pos;\r\n  vec3 normal;\r\n  int geomType;\r\n};\r\n\r\n\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n<%include file=\"GLSLMath.glsl\"/>\r\n<%include file=\"GLSLBinReader.glsl\"/>\r\n\r\n<%include file=\"GLSLCADConstants.glsl\"/>\r\n<%include file=\"GLSLCADCurves.glsl\"/>\r\n<%include file=\"GLSLNURBS.glsl\"/>\r\n<%include file=\"GLSLNURBSCurves.glsl\"/>\r\n\r\nuniform sampler2D curveDataTexture;\r\nuniform ivec2 curveDataTextureSize;\r\nuniform int writeTangents;\r\n\r\nPosNorm evalCADCurves(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\r\n  int geomType = GLSLBinReader_readInt(reader, texture);\r\n\r\n  // PosNorm result;\r\n  // result.pos = vec3(float(geomType));\r\n  // // fragColor = reader.buffer;\r\n  // // fragColor = vec4(float(reader.textureSize.x), float(reader.textureSize.y), float(geomType), 1.0);\r\n  // return result;\r\n\r\n\r\n  if(geomType == CURVE_TYPE_LINE) {\r\n      return calcLinePoint(params.x, reader, texture);\r\n  } \r\n  if(geomType == CURVE_TYPE_CIRCLE) {\r\n      return calcCirclePoint(params.x, reader, texture);\r\n  } \r\n  if(geomType == CURVE_TYPE_ELIPSE) {\r\n      return calcElipsePoint(params.x, reader, texture);\r\n  }\r\n  if(geomType == CURVE_TYPE_NURBS_CURVE) {\r\n      return calcNURBSCurve3dPoint(params.x, reader, texture);\r\n  } \r\n  \r\n  PosNorm detault;\r\n  return detault;\r\n}\r\n\r\n#ifdef ENABLE_ES3\r\nout vec4 fragColor;\r\n#endif\r\n\r\nvoid main(void) {\r\n\r\n#ifndef ENABLE_ES3\r\n  vec4 fragColor;\r\n#endif\r\n\r\n\r\n  // Evaluate the curve per vertex\r\n\r\n  // compute exact xy coords per pixel by rounding the vertex coord to the nearest integer and then dividing my patch size.\r\n  // The interpollated xy coords from the quad are not exact because the quad must cover the pixels with some margin.\r\n\r\n  // The quad overlaps the pixels by half a pixel, so \r\n  vec2 params = vec2(floor(v_vertexCoord.x), floor(v_vertexCoord.y));\r\n  if(v_patchSize.x > 1.0)\r\n      params.x /= v_patchSize.x - 1.0;\r\n  // if(v_patchSize.y > 1.0)\r\n  //     params.y /= v_patchSize.y - 1.0;\r\n\r\n  ivec4 region = ivec4(0, 0, curveDataTextureSize.x, curveDataTextureSize.y);\r\n  ivec2 start = ivec2(int(v_geomDataCoords.x), int(v_geomDataCoords.y));\r\n\r\n  GLSLBinReader reader;\r\n  GLSLBinReader_init(reader, curveDataTextureSize, region, start, 32);\r\n  PosNorm posNorm = evalCADCurves(params, reader, curveDataTexture);\r\n\r\n  if(writeTangents == 1) {\r\n      fragColor = vec4(posNorm.normal, 1.0);\r\n  }\r\n  else {\r\n      fragColor = vec4(posNorm.pos, 1.0);\r\n  }\r\n  // fragColor = vec4(params.x, params.y, 0.0, 1.0);\r\n  // gl_FragData[0] = vec4(posNorm.pos, 1.0);\r\n  // gl_FragData[1] = vec4(posNorm.normal, 1.0);\r\n\r\n  // fragColor.r = v_geomDataCoords.x;\r\n  // fragColor.g = v_geomDataCoords.y;\r\n  // fragColor.b = float(curveDataTextureSize.x);\r\n  // fragColor.a = float(curveDataTextureSize.y);\r\n\r\n#ifndef ENABLE_ES3\r\n  gl_FragColor = fragColor;\r\n#endif\r\n}\r\n`\r\n    )\r\n  }\r\n}\r\n\r\nRegistry.register('GLEvaluateCADCurveShader', GLEvaluateCADCurveShader)\r\n\r\nexport { GLEvaluateCADCurveShader }\r\n","import { GLTexture2D, GLRenderTarget } from '@zeainc/zea-engine'\r\nimport { valuesPerCurveLibraryLayoutItem } from './CADConstants.js'\r\nimport { GLEvaluateCADCurveShader } from './GLEvaluateCADCurveShader.js'\r\n\r\n/** Class representing a GL curve library.\r\n * @ignore\r\n */\r\nclass GLCurveLibrary {\r\n  /**\r\n   * Create a GL curve library.\r\n   * @param {any} gl - The gl value.\r\n   * @param {any} cadpassdata - The cadpassdata value.\r\n   * @param {any} surfacesLibrary - The surfacesLibrary value.\r\n   * @param {any} version - The version object.\r\n   */\r\n  constructor(gl, cadpassdata, surfacesLibrary, version) {\r\n    this.__gl = gl\r\n    this.__cadpassdata = cadpassdata\r\n    this.__surfacesLibrary = surfacesLibrary\r\n    this.cadDataVersion = version\r\n\r\n    const curvesDataBuffer = this.__surfacesLibrary.getCurveBuffer()\r\n    const curveTexSize = Math.sqrt(curvesDataBuffer.byteLength / 8)\r\n\r\n    this.__curveDataTexture = new GLTexture2D(gl, {\r\n      format: 'RGBA',\r\n      type: 'HALF_FLOAT',\r\n      width: curveTexSize,\r\n      height: curveTexSize,\r\n      filter: 'NEAREST',\r\n      wrap: 'CLAMP_TO_EDGE',\r\n      mipMapped: false,\r\n      data: new Uint16Array(curvesDataBuffer),\r\n    })\r\n\r\n    this.__bindAttr = (location, channels, type, stride, offset, instanced = true) => {\r\n      gl.enableVertexAttribArray(location)\r\n      gl.vertexAttribPointer(location, channels, gl.FLOAT, false, stride, offset)\r\n      if (instanced) gl.vertexAttribDivisor(location, 1) // This makes it instanced\r\n    }\r\n  }\r\n\r\n  // /////////////////////////////////////////////////////////////\r\n  // Curves\r\n\r\n  /**\r\n   * The evaluateCurves method.\r\n   * @param {any} curvesAtlasLayout - The curvesAtlasLayout param.\r\n   * @param {any} numCurves - The numCurves param.\r\n   * @param {any} curvesAtlasLayoutTextureSize - The curvesAtlasLayoutTextureSize param.\r\n   * @param {any} curvesAtlasTextureDim - The curvesAtlasTextureDim param.\r\n   */\r\n  evaluateCurves(curvesAtlasLayout, numCurves, curvesAtlasLayoutTextureSize, curvesAtlasTextureDim) {\r\n    // console.log(\"evaluateCurves:\" + assetId + \":\" + curvesAtlasTextureDim);\r\n\r\n    const count = numCurves\r\n    if (count == 0) return\r\n\r\n    const gl = this.__gl\r\n    {\r\n      this.__curveAtlasLayoutTexture = new GLTexture2D(this.__gl, {\r\n        format: 'RGBA',\r\n        type: 'FLOAT',\r\n        width: curvesAtlasLayoutTextureSize[0],\r\n        height: curvesAtlasLayoutTextureSize[1],\r\n        filter: 'NEAREST',\r\n        wrap: 'CLAMP_TO_EDGE',\r\n        mipMapped: false,\r\n        data: curvesAtlasLayout,\r\n      })\r\n    }\r\n\r\n    if (!this.__curvesAtlasRenderTarget) {\r\n      this.__curvesAtlasRenderTarget = new GLRenderTarget(gl, {\r\n        format: 'RGBA',\r\n        type: 'FLOAT',\r\n        width: curvesAtlasTextureDim[0],\r\n        height: curvesAtlasTextureDim[1],\r\n        filter: 'NEAREST',\r\n        wrap: 'CLAMP_TO_EDGE',\r\n        mipMapped: false,\r\n      })\r\n      this.__curvesTangentAtlasRenderTarget = new GLRenderTarget(gl, {\r\n        format: 'RGBA',\r\n        type: 'FLOAT',\r\n        width: curvesAtlasTextureDim[0],\r\n        height: curvesAtlasTextureDim[1],\r\n        filter: 'NEAREST',\r\n        wrap: 'CLAMP_TO_EDGE',\r\n        mipMapped: false,\r\n      })\r\n    } else if (\r\n      this.__curvesAtlasRenderTarget.width != curvesAtlasTextureDim[0] ||\r\n      this.__curvesAtlasRenderTarget.height != curvesAtlasTextureDim[1]\r\n    ) {\r\n      // Copy the previous image into a new one, and then destroy the prvious.\r\n      this.__curvesAtlasRenderTarget.resize(curvesAtlasTextureDim[0], curvesAtlasTextureDim[1], true)\r\n    }\r\n\r\n    const renderstate = {\r\n      shaderopts: {\r\n        directives: [...gl.shaderopts.directives],\r\n      },\r\n    }\r\n    this.__curvesAtlasRenderTarget.bindForWriting(renderstate, true)\r\n\r\n    if (this.cadDataVersion.compare([0, 0, 0]) > 0) {\r\n      renderstate.shaderopts.directives.push('#define EXPORT_KNOTS_AS_DELTAS 1')\r\n    }\r\n    if (this.cadDataVersion.compare([0, 0, 26]) > 0) {\r\n      renderstate.shaderopts.directives.push('#define INTS_PACKED_AS_2FLOAT16 1')\r\n    }\r\n\r\n    if (!this.evaluateCurveShader) {\r\n      this.evaluateCurveShader = new GLEvaluateCADCurveShader(gl)\r\n    }\r\n\r\n    this.evaluateCurveShader.bind(renderstate)\r\n    this.__cadpassdata.glplanegeom.bind(renderstate)\r\n\r\n    const unifs = renderstate.unifs\r\n    const attrs = renderstate.attrs\r\n\r\n    gl.uniform2i(\r\n      unifs.curvesAtlasTextureSize.location,\r\n      this.__curvesAtlasRenderTarget.width,\r\n      this.__curvesAtlasRenderTarget.height\r\n    )\r\n\r\n    this.__curveDataTexture.bindToUniform(renderstate, unifs.curveDataTexture)\r\n    gl.uniform2i(unifs.curveDataTextureSize.location, this.__curveDataTexture.width, this.__curveDataTexture.height)\r\n\r\n    const buffer = gl.createBuffer()\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer)\r\n    gl.bufferData(gl.ARRAY_BUFFER, curvesAtlasLayout, gl.STATIC_DRAW)\r\n\r\n    this.__bindAttr(attrs.patchCoords.location, 4, gl.FLOAT, valuesPerCurveLibraryLayoutItem * 4, 0)\r\n    this.__bindAttr(attrs.curveDataCoords.location, 2, gl.FLOAT, valuesPerCurveLibraryLayoutItem * 4, 4 * 4)\r\n\r\n    // //////////////////////////////////////////////\r\n    // Bind each Fbo and render separately.\r\n    // Bizzarly, this has turned out to be much faster\r\n    // than using mutiple render targets...\r\n    gl.uniform1i(unifs.writeTangents.location, 0)\r\n\r\n    this.__cadpassdata.glplanegeom.drawInstanced(count)\r\n\r\n    this.__curvesTangentAtlasRenderTarget.bindForWriting(renderstate, true)\r\n\r\n    gl.uniform1i(unifs.writeTangents.location, 1)\r\n    this.__cadpassdata.glplanegeom.drawInstanced(count)\r\n    // //////////////////////////////////////////////\r\n\r\n    gl.deleteBuffer(buffer)\r\n\r\n    const logCurveData = (curveId) => {\r\n      this.__curvesAtlasRenderTarget.bindForReading()\r\n      const layout = [\r\n        curvesAtlasLayout[curveId * valuesPerCurveLibraryLayoutItem + 0],\r\n        curvesAtlasLayout[curveId * valuesPerCurveLibraryLayoutItem + 1],\r\n        curvesAtlasLayout[curveId * valuesPerCurveLibraryLayoutItem + 2],\r\n        curvesAtlasLayout[curveId * valuesPerCurveLibraryLayoutItem + 3],\r\n      ]\r\n      console.log('----------------------------------')\r\n      console.log('logCurveData ' + curveId + ':[' + layout[0] + ',' + layout[1] + ']:' + layout[2] + 'x' + layout[3])\r\n      const pixels = new Float32Array(layout[2] * 4)\r\n      for (let i = 0; i < layout[3]; i++) {\r\n        gl.readPixels(layout[0], layout[1] + i, layout[2], 1, gl.RGBA, gl.FLOAT, pixels)\r\n        for (let j = 0; j < layout[2]; j++) {\r\n          console.log(j, ':', pixels[j * 4 + 0], pixels[j * 4 + 1], pixels[j * 4 + 2], pixels[j * 4 + 3])\r\n        }\r\n        // console.log(i+\":\" + pixels);\r\n      }\r\n    }\r\n    // console.log(\"----------------------------------\");\r\n    // logCurveData(35799)\r\n    // logCurveData(1)\r\n    // console.log(\"----------------------------------\");\r\n\r\n    this.__curvesTangentAtlasRenderTarget.unbind()\r\n    gl.finish()\r\n  }\r\n\r\n  /**\r\n   * The bindCurvesAtlas method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   */\r\n  bindCurvesAtlasLayout(renderstate) {\r\n    const gl = this.__gl\r\n    const unifs = renderstate.unifs\r\n    if (this.__curvesAtlasRenderTarget) {\r\n      if (unifs.curvesAtlasLayoutTexture) {\r\n        this.__curveAtlasLayoutTexture.bindToUniform(renderstate, unifs.curvesAtlasLayoutTexture)\r\n        gl.uniform2i(\r\n          unifs.curvesAtlasLayoutTextureSize.location,\r\n          this.__curveAtlasLayoutTexture.width,\r\n          this.__curveAtlasLayoutTexture.height\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The bindCurvesAtlas method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   */\r\n  bindCurvesAtlas(renderstate) {\r\n    const gl = this.__gl\r\n    const unifs = renderstate.unifs\r\n    if (this.__curvesAtlasRenderTarget) {\r\n      this.__curvesAtlasRenderTarget.bindColorTexture(renderstate, unifs.curvesAtlasTexture)\r\n\r\n      if (unifs.curveTangentsTexture) {\r\n        this.__curvesTangentAtlasRenderTarget.bindColorTexture(renderstate, unifs.curveTangentsTexture)\r\n      }\r\n      if (unifs.curvesAtlasTextureSize) {\r\n        gl.uniform2i(\r\n          unifs.curvesAtlasTextureSize.location,\r\n          this.__curvesAtlasRenderTarget.width,\r\n          this.__curvesAtlasRenderTarget.height\r\n        )\r\n      }\r\n\r\n      if (unifs.curvesAtlasLayoutTexture) {\r\n        this.__curveAtlasLayoutTexture.bindToUniform(renderstate, unifs.curvesAtlasLayoutTexture)\r\n        gl.uniform2i(\r\n          unifs.curvesAtlasLayoutTextureSize.location,\r\n          this.__curveAtlasLayoutTexture.width,\r\n          this.__curveAtlasLayoutTexture.height\r\n        )\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The destroy method.\r\n   */\r\n  destroy() {\r\n    this.__curveDataTexture.destroy()\r\n    if (this.__curveAtlasLayoutTexture) {\r\n      this.__curveAtlasLayoutTexture.destroy()\r\n      this.__curvesAtlasRenderTarget.destroy()\r\n      this.__curvesTangentAtlasRenderTarget.destroy()\r\n    }\r\n  }\r\n}\r\n\r\nexport { GLCurveLibrary }\r\n","// import {\r\n//     Vec2,\r\n//     Vec3,\r\n//     Quat,\r\n//     Color,\r\n//     Box2,\r\n//     Box3\r\n// } from '../Math';\r\n\r\nconst decode16BitFloat = (h) => {\r\n  const s = (h & 0x8000) >> 15\r\n  const e = (h & 0x7c00) >> 10\r\n  const f = h & 0x03ff\r\n\r\n  if (e == 0) {\r\n    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10))\r\n  } else if (e == 0x1f) {\r\n    return f ? NaN : (s ? -1 : 1) * Infinity\r\n  }\r\n\r\n  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10))\r\n}\r\n\r\n/** Class representing a bin reader.\r\n * @ignore\r\n */\r\nclass BinReader {\r\n  /**\r\n   * Create a bin reader.\r\n   * @param {Buffer} data - The data buffer.\r\n   * @param {number} byteOffset - The byte offset value to start reading the buffer.\r\n   * @param {boolean} isMobileDevice - The isMobileDevice value.\r\n   */\r\n  constructor(data, byteOffset = 0, isMobileDevice = true) {\r\n    this.__data = data\r\n    this.__byteOffset = byteOffset\r\n    this.__dataView = new DataView(this.__data)\r\n    this.__isMobileDevice = isMobileDevice\r\n    this.utf8decoder = new TextDecoder()\r\n  }\r\n\r\n  /**\r\n   * Getter for isMobileDevice.\r\n   * @return {Boolean} - Returns true is a mobile device is detected.\r\n   */\r\n  get isMobileDevice() {\r\n    return this.__isMobileDevice\r\n  }\r\n\r\n  /**\r\n   * Getter for data.\r\n   * @return {Buffer} - The data buffer we are reading from,\r\n   */\r\n  get data() {\r\n    return this.__data\r\n  }\r\n\r\n  /**\r\n   * Getter for byteLength.\r\n   * @return {number} - The total length of the buffer\r\n   */\r\n  get byteLength() {\r\n    return this.__dataView.byteLength\r\n  }\r\n\r\n  /**\r\n   * Getter for remainingByteLength.\r\n   * @return {number} - The reemaining length of the buffer to read.\r\n   */\r\n  get remainingByteLength() {\r\n    return this.__dataView.byteLength - this.__byteOffset\r\n  }\r\n\r\n  /**\r\n   * The pos method.\r\n   * @return {number} - The current offset in the binary buffer\r\n   */\r\n  pos() {\r\n    return this.__byteOffset\r\n  }\r\n\r\n  /**\r\n   * The seek method.\r\n   * @param {number} byteOffset - The byteOffset param.\r\n   */\r\n  seek(byteOffset) {\r\n    this.__byteOffset = byteOffset\r\n  }\r\n\r\n  /**\r\n   * The advance method.\r\n   * @param {number} byteOffset - The byte Offset amount.\r\n   */\r\n  advance(byteOffset) {\r\n    this.__byteOffset += byteOffset\r\n  }\r\n\r\n  /**\r\n   * The loadUInt8 method.\r\n   * @return {number} - The return value.\r\n   */\r\n  loadUInt8() {\r\n    const result = this.__dataView.getUint8(this.__byteOffset)\r\n    this.__byteOffset += 1\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * The loadUInt16 method.\r\n   * @return {number} - The return value.\r\n   */\r\n  loadUInt16() {\r\n    const result = this.__dataView.getUint16(this.__byteOffset, true)\r\n    this.__byteOffset += 2\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * The loadUInt32 method.\r\n   * @return {number} - The return value.\r\n   */\r\n  loadUInt32() {\r\n    const result = this.__dataView.getUint32(this.__byteOffset, true)\r\n    this.__byteOffset += 4\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * The loadSInt32 method.\r\n   * @return {number} - The return value.\r\n   */\r\n  loadSInt32() {\r\n    const result = this.__dataView.getInt32(this.__byteOffset, true)\r\n    this.__byteOffset += 4\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * The loadFloat16 method.\r\n   * @return {number} - The return value.\r\n   */\r\n  loadFloat16() {\r\n    const uint16 = this.loadUInt16()\r\n    return decode16BitFloat(uint16)\r\n  }\r\n\r\n  /**\r\n   * The loadUFloat16 returns a float where the sign big indicates it is > 201.\r\n   * @return {number} - The return value.\r\n   */\r\n  loadUFloat16() {\r\n    const result = this.loadFloat16()\r\n    if (result < 0.0) {\r\n      return 2048.0 - result // Note: subtract a negative number to add it.\r\n    } else {\r\n      return result\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The loadFloat16From2xUInt8 method.\r\n   * @return {number} - The return value.\r\n   */\r\n  loadFloat16From2xUInt8() {\r\n    const result = this.__dataView.getFloat16(this.__byteOffset, true)\r\n    // const uint8s = this.loadUInt8Array(2);\r\n    // return decode16BitFloat(uint8s);\r\n    this.__byteOffset += 2\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * The loadUInt32From2xUFloat16 loads a single Signed integer value from 2 Unsigned Float16 values.\r\n   * @return {number} - The return value.\r\n   */\r\n  loadUInt32From2xUFloat16() {\r\n    const partA = this.loadUFloat16()\r\n    const partB = this.loadUFloat16()\r\n    return partA + partB * 4096\r\n  }\r\n\r\n  /**\r\n   * The loadSInt32From2xFloat16 loads a single Signed integer value from 2 signed Float16 values.\r\n   * @return {number} - The return value.\r\n   */\r\n  loadSInt32From2xFloat16() {\r\n    const partA = this.loadFloat16()\r\n    const partB = this.loadFloat16()\r\n    return partA + partB * 2048\r\n  }\r\n\r\n  /**\r\n   * The loadFloat32 method.\r\n   * @return {any} - The return value.\r\n   */\r\n  loadFloat32() {\r\n    const result = this.__dataView.getFloat32(this.__byteOffset, true)\r\n    this.__byteOffset += 4\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * The loadFloat32 method.\r\n   * @param {any} size - The size param.\r\n   * @param {boolean} clone - The clone param.\r\n   * @return {any} - The return value.\r\n   */\r\n  loadUInt8Array(size = undefined, clone = false) {\r\n    if (size == undefined) size = this.loadUInt32()\r\n    const result = new Uint8Array(this.__data, this.__byteOffset, size)\r\n    this.__byteOffset += size\r\n    const padd = this.__byteOffset % 4\r\n    // this.readPadd();\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * The loadUInt16Array method.\r\n   * @param {any} size - The size param.\r\n   * @param {boolean} clone - The clone param.\r\n   * @return {any} - The return value.\r\n   */\r\n  loadUInt16Array(size = undefined, clone = false) {\r\n    if (size == undefined) size = this.loadUInt32()\r\n    if (size == 0) return new Uint16Array()\r\n    this.readPadd(2)\r\n    let result\r\n    if (this.__isMobileDevice) {\r\n      result = new Uint16Array(size)\r\n      for (let i = 0; i < size; i++) {\r\n        result[i] = this.__dataView.getUint16(this.__byteOffset, true)\r\n        this.__byteOffset += 2\r\n      }\r\n    } else {\r\n      result = new Uint16Array(this.__data, this.__byteOffset, size)\r\n      this.__byteOffset += size * 2\r\n    }\r\n    // this.readPadd();\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * The loadUInt32Array method.\r\n   * @param {any} size - The size param.\r\n   * @param {boolean} clone - The clone param.\r\n   * @return {any} - The return value.\r\n   */\r\n  loadUInt32Array(size = undefined, clone = false) {\r\n    if (size == undefined) size = this.loadUInt32()\r\n    if (size == 0) return new Uint32Array()\r\n    this.readPadd(4)\r\n    let result\r\n    if (this.__isMobileDevice) {\r\n      result = new Uint32Array(size)\r\n      for (let i = 0; i < size; i++) {\r\n        result[i] = this.__dataView.getUint32(this.__byteOffset, true)\r\n        this.__byteOffset += 4\r\n      }\r\n    } else {\r\n      result = new Uint32Array(this.__data, this.__byteOffset, size)\r\n      this.__byteOffset += size * 4\r\n    }\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * The loadFloat32Array method.\r\n   * @param {any} size - The size param.\r\n   * @param {boolean} clone - The clone param.\r\n   * @return {any} - The return value.\r\n   */\r\n  loadFloat32Array(size = undefined, clone = false) {\r\n    if (size == undefined) size = this.loadUInt32()\r\n    if (size == 0) return new Float32Array()\r\n    this.readPadd(4)\r\n    let result\r\n    if (this.__isMobileDevice) {\r\n      result = new Float32Array(size)\r\n      for (let i = 0; i < size; i++) {\r\n        result[i] = this.__dataView.getFloat32(this.__byteOffset, true)\r\n        this.__byteOffset += 4\r\n      }\r\n    } else {\r\n      result = new Float32Array(this.__data, this.__byteOffset, size)\r\n      this.__byteOffset += size * 4\r\n    }\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * The loadStr method.\r\n   * @return {string} - The return value.\r\n   */\r\n  loadStr() {\r\n    const numChars = this.loadUInt32()\r\n    const chars = new Uint8Array(this.__data, this.__byteOffset, numChars)\r\n    this.__byteOffset += numChars\r\n    let result = ''\r\n    for (let i = 0; i < numChars; i++) result = result + String.fromCharCode(chars[i])\r\n    return result\r\n  }\r\n\r\n  /**\r\n   * The loadStrArray method.\r\n   * @return {array} - The return value.\r\n   */\r\n  loadStrArray() {\r\n    const size = this.loadUInt32()\r\n    const result = []\r\n    for (let i = 0; i < size; i++) {\r\n      result[i] = this.loadStr()\r\n    }\r\n    return result\r\n  }\r\n\r\n  // loadSInt32Vec2() {\r\n  //     const x = this.loadSInt32();\r\n  //     const y = this.loadSInt32();\r\n  //     return new Vec2(x, y);\r\n  // }\r\n\r\n  // loadUInt32Vec2() {\r\n  //     const x = this.loadUInt32();\r\n  //     const y = this.loadUInt32();\r\n  //     return new Vec2(x, y);\r\n  // }\r\n\r\n  // loadFloat16Vec2() {\r\n  //     const x = this.loadFloat16();\r\n  //     const y = this.loadFloat16();\r\n  //     return new Vec2(x, y);\r\n  // }\r\n\r\n  // loadFloat32Vec2() {\r\n  //     const x = this.loadFloat32();\r\n  //     const y = this.loadFloat32();\r\n  //     return new Vec2(x, y);\r\n  // }\r\n\r\n  // loadFloat16Vec3() {\r\n  //     const x = this.loadFloat16();\r\n  //     const y = this.loadFloat16();\r\n  //     const z = this.loadFloat16();\r\n  //     return new Vec3(x, y, z);\r\n  // }\r\n\r\n  // loadFloat32Vec3() {\r\n  //     const x = this.loadFloat32();\r\n  //     const y = this.loadFloat32();\r\n  //     const z = this.loadFloat32();\r\n  //     return new Vec3(x, y, z);\r\n  // }\r\n\r\n  // loadFloat16Quat() {\r\n  //     const x = this.loadFloat16();\r\n  //     const y = this.loadFloat16();\r\n  //     const z = this.loadFloat16();\r\n  //     const w = this.loadFloat16();\r\n  //     return new Quat(x, y, z, w);\r\n  // }\r\n\r\n  // loadFloat32Quat() {\r\n  //     const x = this.loadFloat32();\r\n  //     const y = this.loadFloat32();\r\n  //     const z = this.loadFloat32();\r\n  //     const w = this.loadFloat32();\r\n  //     return new Quat(x, y, z, w);\r\n  // }\r\n\r\n  // loadRGBFloat32Color() {\r\n  //     const r = this.loadFloat32();\r\n  //     const g = this.loadFloat32();\r\n  //     const b = this.loadFloat32();\r\n  //     return new Color(r, g, b);\r\n  // }\r\n\r\n  // loadRGBAFloat32Color() {\r\n  //     const r = this.loadFloat32();\r\n  //     const g = this.loadFloat32();\r\n  //     const b = this.loadFloat32();\r\n  //     const a = this.loadFloat32();\r\n  //     return new Color(r, g, b, a);\r\n  // }\r\n\r\n  // loadRGBUInt8Color() {\r\n  //     const r = this.loadUInt8();\r\n  //     const g = this.loadUInt8();\r\n  //     const b = this.loadUInt8();\r\n  //     return new Color(r / 255, g / 255, b / 255);\r\n  // }\r\n\r\n  // loadRGBAUInt8Color() {\r\n  //     const r = this.loadUInt8();\r\n  //     const g = this.loadUInt8();\r\n  //     const b = this.loadUInt8();\r\n  //     const a = this.loadUInt8();\r\n  //     return new Color(r / 255, g / 255, b / 255, a / 255);\r\n  // }\r\n\r\n  // loadBox2() {\r\n  //     return new Box2(this.loadFloat32Vec2(), this.loadFloat32Vec2());\r\n  // }\r\n\r\n  // loadBox3() {\r\n  //     return new Box3(this.loadFloat32Vec3(), this.loadFloat32Vec3());\r\n  // }\r\n\r\n  /**\r\n   * The loadStr method.\r\n   * @param {any} stride - The stride param.\r\n   */\r\n  readPadd(stride) {\r\n    const padd = this.__byteOffset % stride\r\n    if (padd != 0) this.__byteOffset += stride - padd\r\n  }\r\n}\r\n\r\nexport { BinReader }\r\n","import { shaderLibrary } from '@zeainc/zea-engine'\r\nshaderLibrary.setShaderModule(\r\n  'GLSLBinReader.glsl',\r\n  `\r\n\r\n#ifdef DECODE_16BIT_FLOAT_FROM_8BIT_INT\r\n\r\n/////////////////////////////////////////////////////////////////\r\n// http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js\r\n// Note: modulo on some GPUS. (e.g. iPhone)\r\n// often incur errors in modulo, leaving a result\r\n// that appears to boe the y param. in this use case\r\n// we are only interested in integer moduos anyway\r\n// so we just trim off erronious values. .Seems to work. \r\nfloat fixed_mod(float x, float y) {\r\n  float res = mod(x, y);\r\n  return (abs(y - res) < 0.5) ? 0.0 : res;\r\n}\r\n\r\nfloat shift_right(float v, float amt) {\r\n  v = floor(v) + 0.5;\r\n  return floor(v / exp2(amt));\r\n}\r\n\r\nfloat shift_left(float v, float amt) {\r\n  return floor(v * exp2(amt) + 0.5);\r\n}\r\n\r\nfloat mask_last(float v, float bits) {\r\n  return fixed_mod(v, shift_left(1.0, bits));\r\n}\r\n\r\nfloat extract_bits(float num, float from, float to) {\r\n  from = floor(from + 0.5);\r\n  to = floor(to + 0.5);\r\n  return mask_last(shift_right(num, from), to - from);\r\n}\r\n\r\n\r\n/////////////////////////////////////////////////////////////////\r\n\r\nfloat decode16BitFloatFrom2xUInt8_IEEE(vec2 c){\r\n  float v = 0.;\r\n\r\n  // int h = c.x + c.y * 256;\r\n  // const s = (h & 0x8000) >> 15;\r\n  // const e = (h & 0x7C00) >> 10;\r\n  // const f = h & 0x03FF;\r\n\r\n\r\n  // float h = c.x + c.y * 256.0;\r\n  // float s = extract_bits(h, 15.0, 16.0);\r\n  // float e = extract_bits(h, 10.0, 15.0);\r\n  // float f = extract_bits(h, 0.0, 10.0);\r\n\r\n  // float s = extract_bits(c.y, 7.0, 8.0);\r\n  // float e = extract_bits(c.y, 2.0, 7.0);\r\n\r\n  int s = (c.y >= 127.5) ? 1 : 0;\r\n  float e = shift_right(c.y - ((s == 1) ? 128.0 : 0.0), 2.0);\r\n  float f = c.x + mask_last(c.y, 2.0) * 256.0;\r\n  // return float(s);\r\n\r\n  if(e < 0.5) {\r\n    return ((s!=0)?-1.0:1.0) * exp2(-14.0) * (f/exp2(10.0));\r\n  } else if (int(e) == 0x1F) {\r\n    float NaN = 0.0;\r\n    float Inf = 0.0;\r\n    return (f==0.0)?(NaN):(((s!=0)?-1.0:1.0)*Inf);\r\n  }\r\n\r\n  return ((s!=0)?-1.0:1.0) * exp2(e-15.0) * (1.0+(f/exp2(10.0)));\r\n}\r\n\r\n#endif\r\n\r\n// RGBA16 textures\r\nvec4 GLSLBinReader_texelFetch2D(sampler2D texture, ivec2 textureSize, ivec2 address) {\r\n  return fetchTexel(texture, textureSize, address);\r\n}\r\n\r\nstruct GLSLBinReader {\r\n  ivec2 textureSize; \r\n  ivec4 region;\r\n  ivec2 start; /* the base address from which we base the offsets */\r\n  int offset; /* how far we have read into the buffer . Note: value is in channels. so 4 == 1 pixel.*/\r\n  vec4 buffer; \r\n  ivec2 bufferaddress;\r\n  int bpc; // bits per channel. (e.g. 8, 16, 32)\r\n};\r\n\r\nvoid GLSLBinReader_init(inout GLSLBinReader reader, ivec2 textureSize, ivec4 region, ivec2 start, int bpc) {\r\n  reader.textureSize = textureSize;\r\n  reader.region = region;\r\n  reader.start = start;\r\n#ifdef DECODE_16BIT_FLOAT_FROM_8BIT_INT\r\n  reader.start = ivec2(start.x * 2, start.y);\r\n#else\r\n  reader.start = start;\r\n#endif\r\n  reader.bpc = bpc;\r\n  reader.bufferaddress = ivec2(-1, -1);\r\n}\r\n\r\nvoid GLSLBinReader_init(inout GLSLBinReader reader, ivec2 textureSize, int bpc) {\r\n  reader.textureSize = textureSize;\r\n  reader.region = ivec4(0, 0, textureSize.x, textureSize.y);\r\n  reader.start = ivec2(0,0);\r\n  reader.bpc = bpc;\r\n  reader.bufferaddress = ivec2(-1, -1);\r\n}\r\n\r\n\r\nivec2 GLSLBinReader_getAddress(in GLSLBinReader reader, int offset) {\r\n#ifdef DECODE_16BIT_FLOAT_FROM_8BIT_INT\r\n  ivec2 address = ivec2(reader.start.x + (offset/2), reader.start.y);\r\n#else\r\n  ivec2 address = ivec2(reader.start.x + (offset/4), reader.start.y);\r\n#endif\r\n  address.y += address.x / reader.region.z;\r\n  address.x = imod(address.x, reader.region.z);\r\n  return address;\r\n}\r\n\r\n\r\nfloat GLSLBinReader_readFloat(inout GLSLBinReader reader, sampler2D texture, int offset) {\r\n\r\n  ivec2 address = GLSLBinReader_getAddress(reader, offset);\r\n\r\n  if(address != reader.bufferaddress){\r\n    reader.buffer = GLSLBinReader_texelFetch2D(texture, reader.textureSize, reader.region.xy + address);\r\n    reader.bufferaddress = address;\r\n  }\r\n\r\n#ifdef DECODE_16BIT_FLOAT_FROM_8BIT_INT\r\n\r\n  int swizelIndex = imod(offset, 2);\r\n  if(swizelIndex == 0)\r\n    return decode16BitFloatFrom2xUInt8_IEEE(reader.buffer.xy * 255.0);\r\n  return decode16BitFloatFrom2xUInt8_IEEE(reader.buffer.zw * 255.0);\r\n\r\n#else\r\n\r\n  int swizelIndex = imod(offset, 4);\r\n  if(swizelIndex == 0)\r\n    return reader.buffer.x;\r\n  if(swizelIndex == 1)\r\n    return reader.buffer.y;\r\n  if(swizelIndex == 2)\r\n    return reader.buffer.z;\r\n  return reader.buffer.w;\r\n  \r\n#endif\r\n}\r\n\r\n\r\nint GLSLBinReader_readInt(inout GLSLBinReader reader, sampler2D texture, int offset) {\r\n  if(reader.bpc == 8)\r\n    return int(GLSLBinReader_readFloat(reader, texture, offset) * 255.0);\r\n  else {\r\n    float flt = GLSLBinReader_readFloat(reader, texture, offset);\r\n    return int(flt);\r\n  }\r\n}\r\n\r\nint GLSLBinReader_readUInt(inout GLSLBinReader reader, sampler2D texture, int offset) {\r\n  if(reader.bpc == 8)\r\n    return int(GLSLBinReader_readFloat(reader, texture, offset) * 255.0);\r\n  else {\r\n    float flt = GLSLBinReader_readFloat(reader, texture, offset);\r\n    if (flt < 0.0) {\r\n      return int(2048.0 - flt);\r\n    }\r\n    else {\r\n      return int(flt);\r\n    }\r\n  }\r\n}\r\n\r\nvec4 GLSLBinReader_readVec4(inout GLSLBinReader reader, sampler2D texture, int offset) {\r\n  ivec2 address = GLSLBinReader_getAddress(reader, offset);\r\n  return GLSLBinReader_texelFetch2D(texture, reader.textureSize, reader.region.xy + address);\r\n}\r\n\r\n\r\nvec3 GLSLBinReader_readVec3(inout GLSLBinReader reader, sampler2D texture, int offset) {\r\n  return GLSLBinReader_readVec4(reader, texture, offset).rgb;\r\n}\r\n\r\nvec2 GLSLBinReader_readVec2(inout GLSLBinReader reader, sampler2D texture, int offset) {\r\n  return vec2(\r\n    GLSLBinReader_readFloat(reader, texture, offset),\r\n    GLSLBinReader_readFloat(reader, texture, offset+1)\r\n  );\r\n}\r\n\r\n\r\n\r\nfloat GLSLBinReader_readFloat(inout GLSLBinReader reader, sampler2D texture) {\r\n  float result = GLSLBinReader_readFloat( reader,  texture, reader.offset);\r\n  reader.offset++;\r\n  return result;\r\n}\r\n\r\nint GLSLBinReader_readInt(inout GLSLBinReader reader, sampler2D texture) {\r\n  if(reader.bpc == 8)\r\n    return int(GLSLBinReader_readFloat(reader, texture) * 255.0);\r\n  else\r\n    return int(GLSLBinReader_readFloat(reader, texture));\r\n}\r\n\r\nint GLSLBinReader_readUInt(inout GLSLBinReader reader, sampler2D texture) {\r\n  if(reader.bpc == 8)\r\n    return int(GLSLBinReader_readFloat(reader, texture) * 255.0);\r\n  else {\r\n    float flt = GLSLBinReader_readFloat(reader, texture);\r\n    if (flt < 0.0) {\r\n      return int(2048.0 - flt);\r\n    }\r\n    else {\r\n      return int(flt);\r\n    }\r\n  }\r\n}\r\n\r\nint GLSLBinReader_readUIntFrom2xUFloat16(inout GLSLBinReader reader, sampler2D texture) {\r\n  int partA = GLSLBinReader_readUInt(reader, texture);\r\n  int partB = GLSLBinReader_readUInt(reader, texture);\r\n  \r\n#ifdef INTS_PACKED_AS_2FLOAT16\r\n  // Changed on version 0.0.28\r\n  return partA + (partB * 4096);\r\n#else\r\n  return partA + (partB * 256);\r\n#endif\r\n}\r\n\r\nvec4 GLSLBinReader_readVec4(inout GLSLBinReader reader, sampler2D texture) {\r\n  vec4 result = GLSLBinReader_readVec4( reader, texture, reader.offset);\r\n  reader.offset += 4;\r\n  return result;\r\n}\r\n\r\n\r\nvec3 GLSLBinReader_readVec3(inout GLSLBinReader reader, sampler2D texture) {\r\n  return GLSLBinReader_readVec4(reader, texture).rgb;\r\n}\r\n\r\nvec2 GLSLBinReader_readVec2(inout GLSLBinReader reader, sampler2D texture) {\r\n  return vec2(\r\n    GLSLBinReader_readFloat(reader, texture),\r\n    GLSLBinReader_readFloat(reader, texture)\r\n  );\r\n}\r\n\r\n\r\n\r\n`\r\n)\r\n","import { shaderLibrary } from '@zeainc/zea-engine'\r\nshaderLibrary.setShaderModule(\r\n  'GLSLMath.glsl',\r\n  `\r\n\r\n<%include file=\"stack-gl/transpose.glsl\"/>\r\n\r\n  ////////////////////////////////////////\r\n  \r\n  struct Xfo2d {\r\n    vec2 tr;\r\n    float rot;\r\n    vec2 sc;\r\n  };\r\n\r\n  vec2 rotateVec2(float rot, vec2 vec){\r\n    float cosa = cos(rot);\r\n    float sina = sin(rot);\r\n    return vec2(vec.x * cosa - vec.y * sina, vec.x * sina + vec.y * cosa);\r\n  }\r\n\r\n  vec2 Xfo2D_transformVec2(Xfo2d xfo2d, vec2 pos){\r\n    return xfo2d.tr + rotateVec2(xfo2d.rot, pos * xfo2d.sc);\r\n  }\r\n\r\n  ////////////////////////////////////////\r\n\r\n\r\n  vec4 quat_fromAxisAndAngle(vec3 axis, float angle) {\r\n    float halfAngle = angle / 2.0;\r\n    vec3 vec = axis* sin(halfAngle);\r\n    return vec4(vec.x, vec.y, vec.z, cos(halfAngle));\r\n  }\r\n\r\n  vec4 quat_conjugate(vec4 quat) {\r\n    return vec4(-quat.x, -quat.y, -quat.z, quat.w);\r\n  }\r\n\r\n  vec4 quat_multiply(vec4 lhs, vec4 rhs) {\r\n    float ax = lhs.x;\r\n    float ay = lhs.y;\r\n    float az = lhs.z;\r\n    float aw = lhs.w;\r\n    float bx = rhs.x;\r\n    float by = rhs.y;\r\n    float bz = rhs.z;\r\n    float bw = rhs.w;\r\n    return vec4(\r\n      ax * bw + aw * bx + ay * bz - az * by,\r\n      ay * bw + aw * by + az * bx - ax * bz,\r\n      az * bw + aw * bz + ax * by - ay * bx,\r\n      aw * bw - ax * bx - ay * by - az * bz\r\n    );\r\n  }\r\n\r\n  vec3 quat_rotateVec3(vec4 quat, vec3 rhs) {\r\n    vec4 vq = vec4(rhs.x, rhs.y, rhs.z, 0.0);\r\n    vec4 pq = quat_multiply(quat_multiply(quat, vq), quat_conjugate(quat));\r\n    return vec3(pq.x, pq.y, pq.z);\r\n  }\r\n\r\n\r\n  mat4 tr_toMat4(vec3 tr) {\r\n    // Note: GLSL matrices are transposed compared to the matrices in ZeaEngine\r\n    vec4 col0 = vec4(1.0, 0.0, 0.0, 0.0);\r\n    vec4 col1 = vec4(0.0, 1.0, 0.0, 0.0);\r\n    vec4 col2 = vec4(0.0, 0.0, 1.0, 0.0);\r\n    vec4 col3 = vec4(tr, 1.0);\r\n    return mat4(col0, col1, col2, col3);\r\n  }\r\n\r\n  mat4 quat_toMat4(vec4 quat) {\r\n\r\n    float x2 = quat.x + quat.x;\r\n    float y2 = quat.y + quat.y;\r\n    float z2 = quat.z + quat.z;\r\n\r\n    float xx = quat.x * x2;\r\n    float yx = quat.y * x2;\r\n    float yy = quat.y * y2;\r\n    float zx = quat.z * x2;\r\n    float zy = quat.z * y2;\r\n    float zz = quat.z * z2;\r\n    float wx = quat.w * x2;\r\n    float wy = quat.w * y2;\r\n    float wz = quat.w * z2;\r\n\r\n\r\n    // Note: GLSL matrices are transposed compared to the matrices in ZeaEngine\r\n    vec4 col0 = vec4(\r\n      1.0 - yy - zz,\r\n      yx - wz,\r\n      zx + wy,\r\n      0.0);\r\n\r\n    vec4 col1 = vec4(\r\n      yx + wz,\r\n      1.0 - xx - zz,\r\n      zy - wx,\r\n      0.0);\r\n\r\n    vec4 col2 = vec4(\r\n      zx - wy,\r\n      zy + wx,\r\n      1.0 - xx - yy,\r\n      0.0);\r\n\r\n    vec4 col3 = vec4(\r\n      0.0,\r\n      0.0,\r\n      0.0,\r\n      1.0);\r\n\r\n    // return mat4(col0, col1, col2, col3);\r\n    return transpose(mat4(col0, col1, col2, col3));\r\n  }\r\n\r\n  mat4 sc_toMat4(vec3 sc) {\r\n    // Note: GLSL matrices are transposed compared to the matrices in ZeaEngine\r\n    return mat4(\r\n      sc.x, 0.0,  0.0,  0.0,\r\n      0.0,  sc.y, 0.0,  0.0,\r\n      0.0,  0.0,  sc.z, 0.0,\r\n      0.0,  0.0,  0.0,  1.0);\r\n  }\r\n\r\n  struct Xfo {\r\n    vec3 tr;\r\n    vec4 ori;\r\n    vec3 sc;\r\n  };\r\n\r\n  Xfo xfo_multiply(Xfo xfo, Xfo other){\r\n    return Xfo(\r\n      xfo.tr + quat_rotateVec3(xfo.ori, xfo.sc * other.tr),\r\n      quat_multiply(xfo.ori, other.ori),\r\n      xfo.sc * other.sc\r\n    );\r\n  }\r\n\r\n  mat4 xfo_toMat4(Xfo xfo){\r\n    mat4 sc_mat4 = sc_toMat4(xfo.sc);\r\n    mat4 ori_mat4  = quat_toMat4(xfo.ori);\r\n    mat4 tr_mat4  = tr_toMat4(xfo.tr);\r\n    mat4 result = tr_mat4 * ori_mat4 * sc_mat4;\r\n    return result;\r\n  }\r\n\r\n`\r\n)\r\n","import { shaderLibrary } from '@zeainc/zea-engine'\r\n\r\nshaderLibrary.setShaderModule(\r\n  'GLSLCADCurves.glsl',\r\n  `\r\n\r\n  // http://cadexchanger.com/download/sdk/doc/dev/html/sdk_data_model_geometry_topology.html#sdk_data_model_geometry_curves\r\n\r\n\r\n\r\n// http://cadexchanger.com/download/sdk/doc/dev/html/sdk_data_model_geometry_topology.html#sdk_data_model_geometry_surfaces\r\n\r\n\r\nvec2 loadVec2(inout GLSLBinReader reader, sampler2D texture) {\r\n  return vec2(GLSLBinReader_readFloat(reader, texture),  GLSLBinReader_readFloat(reader, texture));\r\n}\r\n\r\nfloat mapDomain1d(vec2 domain, float param) {\r\n  float u = domain.x + param * ( domain.y - domain.x );\r\n  return u;\r\n}\r\n\r\n/////////////////////////////////////////\r\n// Line\r\n\r\nPosNorm calcLinePoint(float param, inout GLSLBinReader reader, sampler2D texture) {\r\n  vec2 domain = loadVec2(reader, texture);\r\n  float u = mapDomain1d( domain, param );\r\n  vec3 pos = vec3(u, 0.0, 0.0);\r\n  vec3 norm = vec3(1.0, 0.0, 0.0);\r\n  return PosNorm(pos, norm, CURVE_TYPE_LINE);\r\n}\r\n\r\n\r\n/////////////////////////////////////////\r\n// Circle\r\n\r\nPosNorm calcCirclePoint(float param, inout GLSLBinReader reader, sampler2D texture) {\r\n  vec2 domain = loadVec2(reader, texture);\r\n  float radius = GLSLBinReader_readFloat(reader, texture);\r\n\r\n  float u = mapDomain1d( domain, param );\r\n  vec3 pos = vec3(cos(u) * radius, sin(u) * radius, 0.0);\r\n  vec3 norm = vec3(-sin(u), cos(u), 0.0);\r\n  return PosNorm(pos, norm, CURVE_TYPE_CIRCLE);\r\n}\r\n\r\n\r\n\r\n/////////////////////////////////////////\r\n// Elipse3d\r\n// An ellipse is a periodic curve parametrized as follows: C(t) = P + X * R_major * cos(t) + Y * R_minor * sin(t), where\r\n\r\n// P is an origin point,\r\n// X and Y are directions,\r\n// R_major and R_minor are major and minor radii,\r\n// t belongs to [0, 2 * PI].\r\n// Note that major radius is always along the X-axis and minor radius - along the Y-axis, and that with t=0 the point corresponds to a major radius.\r\n\r\n\r\nPosNorm calcElipsePoint(float param, inout GLSLBinReader reader, sampler2D texture) {\r\n  vec2 domain = loadVec2(reader, texture);\r\n  float u = mapDomain1d( domain, param );\r\n  float minorRadius = GLSLBinReader_readFloat(reader, texture);\r\n  float majorRadius = GLSLBinReader_readFloat(reader, texture);\r\n  vec3 pos = vec3(cos(u) * majorRadius, sin(u) * minorRadius, 0.0);\r\n  vec3 norm = normalize(vec3(-sin(u) * majorRadius, cos(u) * minorRadius, 0.0)); // TODO: fix this broken line.\r\n\r\n  // pos = vec3(float(minorRadius));\r\n\r\n  return PosNorm(pos, norm, CURVE_TYPE_ELIPSE);\r\n}\r\n\r\n`\r\n)\r\n","import { shaderLibrary } from '@zeainc/zea-engine'\r\n\r\nshaderLibrary.setShaderModule(\r\n  'GLSLCADSimpleSurfaces.glsl',\r\n  `\r\n\r\n  // http://cadexchanger.com/download/sdk/doc/dev/html/sdk_data_model_geometry_topology.html#sdk_data_model_geometry_surfaces\r\n\r\n\r\n/////////////////////////////////////////\r\n// Plane\r\n// A plane is parametrized as follows: S(u,v) = P + u * dX + v * dY, where\r\n\r\n// P is an origin point,\r\n// dX and dY are directions (unit vectors) of X and Y axes respectively,\r\n// u, v belongs to (-Infinity, +Infinity).\r\n\r\nPosNorm calcPlaneSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\r\n  box2 domain = loadBox2(reader, texture);\r\n  vec2 uv = mapDomain(domain, params);\r\n\r\n  vec3 pos = vec3(uv.x, uv.y, 0.0);\r\n  vec3 normal = vec3(0.0, 0.0, 1.0);\r\n\r\n  return PosNorm(pos, normal, SURFACE_TYPE_PLANE);\r\n}\r\n\r\n/////////////////////////////////////////\r\n// Poly Plane\r\n// A plane is parametrized as follows: S(u,v) = P + u * dX + v * dY, where\r\n\r\n// P is an origin point,\r\n// dX and dY are directions (unit vectors) of X and Y axes respectively,\r\n// u, v belongs to (-Infinity, +Infinity).\r\n\r\nPosNorm calcPolyPlaneSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\r\n  // Domain does not need to be mapped in this case.\r\n  vec2 uv = params;\r\n  vec2 p0 = GLSLBinReader_readVec2(reader, texture);\r\n  vec2 p1 = GLSLBinReader_readVec2(reader, texture);\r\n  vec2 p2 = GLSLBinReader_readVec2(reader, texture);\r\n  vec2 p3 = GLSLBinReader_readVec2(reader, texture);\r\n\r\n  vec2 pos = mix(mix(p0, p1, uv.x), mix(p3, p2, uv.x), uv.y);\r\n  vec3 normal = vec3(0.0, 0.0, 1.0);\r\n\r\n  return PosNorm(vec3(pos, 0.0), normal, SURFACE_TYPE_POLY_PLANE);\r\n}\r\n\r\n\r\n/////////////////////////////////////////\r\n// Fan\r\n// A plane is parametrized as follows: S(u,v) = P + u * dX + v * dY, where\r\n\r\n// P is an origin point,\r\n// dX and dY are directions (unit vectors) of X and Y axes respectively,\r\n// u, v belongs to (-Infinity, +Infinity).\r\n\r\nPosNorm calcFanSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\r\n  // Domain does not need to be mapped in this case.\r\n  vec2 uv = params;\r\n  // Skip forward 2 values for each vertex.\r\n  reader.offset += int(2.0 * floor(v_vertexCoord.x));\r\n  vec2 pos = GLSLBinReader_readVec2(reader, texture);\r\n  vec3 normal = vec3(0.0, 0.0, 1.0);\r\n\r\n  return PosNorm(vec3(pos, 0.0), normal, SURFACE_TYPE_FAN);\r\n}\r\n\r\n\r\n\r\n/////////////////////////////////////////\r\n// Cone\r\n// A conical surface is parametrized as follows: S(u,v) = P + r * cos(u) * Dx + r * sin(u) * Dy + v * cos(φ) * Dz, where\r\n\r\n// P is an origin point,\r\n// Dx, Dy and Dz are directions (unit vectors) of X, Y and Z axes respectively,\r\n// φ - semi-angle, i.e. an angle between Dz and any generatrix,\r\n// r = R + v * sin(φ), i.e. a radius of a circle at respective parameter v,\r\n// u belongs to [0, 2 * PI],\r\n// v belongs to (-infinity, +infinity).\r\n// U-parameter is an angle along the circle at a given parameter V and V-parameter is a length along the cone. Thus, U-isolines are lines and V-isoline are circles.\r\n\r\n// V-isoline at V=0 is a circle of radius R in the plane defined by an axis placement.\r\n\r\n// Conical surface contains both halfs of mathematical cone.\r\n\r\n// Conical surface is U-periodical with period 2 * PI. At a cone apex, r equals 0, hence V-parameter of an apex equals -R / sin(φ)\r\n\r\n\r\nPosNorm calcConeSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\r\n  box2 domain = loadBox2(reader, texture);\r\n  float r = GLSLBinReader_readFloat(reader, texture);\r\n  float semiAngle = GLSLBinReader_readFloat(reader, texture);\r\n  vec2 uv = mapDomain(domain, params);\r\n\r\n  float u = uv.x;\r\n  float v = uv.y;\r\n  float r_at_v = r + v * sin(semiAngle);\r\n  vec3 pos = vec3(r_at_v * cos(u), r_at_v * sin(u), v * cos(semiAngle));\r\n  vec3 normal = normalize(vec3(cos(u)*cos(semiAngle), sin(u)*cos(semiAngle), -sin(semiAngle)));\r\n  return PosNorm(pos, normal, SURFACE_TYPE_CONE);\r\n}\r\n\r\n\r\n/////////////////////////////////////////\r\n// Cylinder\r\n// A cylindrical surface is parametrized as follows: S(u,v) = P + R * cos(u) * dX + R * sin(u) * dY + v * dZ, where\r\n\r\n// P is an origin point,\r\n// dX, dY and dZ are directions (unit vectors) of X, Y and Z axes respectively,\r\n// R is a radius,\r\n// u belongs to [0, 2 * PI],\r\n// v belongs to (-infinity, +infinity).\r\n\r\n\r\nPosNorm calcCylinderSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\r\n  box2 domain = loadBox2(reader, texture);\r\n  float r = GLSLBinReader_readFloat(reader, texture);\r\n  vec2 uv = mapDomain(domain, params);\r\n\r\n  vec3 normal = vec3(cos(uv.x), sin(uv.x), 0.0);\r\n  vec3 pos = r * normal + vec3(0.0, 0.0, uv.y);\r\n\r\n  return PosNorm(pos, normal, SURFACE_TYPE_CYLINDER);\r\n}\r\n\r\n\r\n/////////////////////////////////////////\r\n// Sphere\r\n// A spherical surface is parametrized as follows: S(u,v) = P + R * cos(v) * (cos(u) * Dx + sin(u) * Dy) + R * sin(v) * Dz, where\r\n\r\n// P is an origin point,\r\n// Dx, Dy and Dz are directions (unit vectors) of X, Y and Z axes respectively,\r\n// R is a radius,\r\n// u belongs to [0, 2 * PI],\r\n// v belongs to [-PI/2, +PI/2].\r\n// U-parameter is an angle of rotation around the Dz axis counterclockwise (i.e. similar to longitude on the Earth), and V-parameter is an angle between plane defined by an axis placement and line from P to a point on a sphere (i.e. latitude). Thus, U-isolines are semi-circles and V-isoline are circles.\r\n\r\n// V-isoline at V=0 is a circle of radius R in the plane defined by an axis placement. U-isoline at U=0 corresponds to a semi-circle from south to north pole.\r\n\r\n// Spherical surface is U-periodical with period 2 * PI.\r\n\r\n// If a face lies on a full spherical surface its boundary wire will contain two a degenerated edges corresponding to the south and north poles (V equals -PI/2 and PI/2 respectively), and a seam-edge.\r\n\r\n\r\nPosNorm calcSphereSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\r\n  box2 domain = loadBox2(reader, texture);\r\n  vec2 uv = mapDomain(domain, params);\r\n\r\n  float r = GLSLBinReader_readFloat(reader, texture);\r\n\r\n  float u = uv.x;\r\n  float v = uv.y;\r\n  vec3 normal = vec3(cos(v) * cos(u), cos(v) * sin(u), sin(v));\r\n  vec3 pos = r * normal;\r\n\r\n  return PosNorm(pos, normal, SURFACE_TYPE_SPHERE);\r\n}\r\n\r\n/////////////////////////////////////////\r\n// Torus\r\n\r\n// A toroidal surface is parametrized as follows: S(u,v) = (R1 + R2 * cos(v)) * (cos(u) * Dx + sin(u) * Dy) + R2 * sin(v) * Dz, where\r\n\r\n// R1 is a major radius,\r\n// R2 is a minor radius,\r\n// u belongs to [0, 2 * PI],\r\n// v belongs to [0, 2 * PI],\r\n// U-parameter is an angle when rotating around the Dz axis counterclockwise, and V-parameter is an angle in circular section at a given parameter U. Thus, U-isolines circles lying in the plane containing Z axis and V-isolines are circles in the planes perpendicular to Z axis.\r\n\r\n// V-isoline at V=0 is a circle of radius (R1 + R2) in the plane defined by an axis placement. U-isoline at U=0 is a circle of radius R2 in the plane containing Z and X axes.\r\n\r\n// Radii R1 and R2 must be positive. If R2 > R1 then toroidal surface will be self-intersecting.\r\n\r\n// Toroidal surface is both U- and V-periodical with periods 2 * PI.\r\n\r\n// If a face lies on a full toroidal surface its boundary wire will contain two seam-edges, corresponding to U=0 and U=2*PI, and V=0 and V=2*PI respectively.\r\n\r\n\r\nPosNorm calcTorusSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\r\n  box2 domain = loadBox2(reader, texture);\r\n  vec2 uv = mapDomain(domain, params);\r\n\r\n  float majorRadius = GLSLBinReader_readFloat(reader, texture);\r\n  float minorRadius = GLSLBinReader_readFloat(reader, texture);\r\n  float u = uv.x;\r\n  float v = uv.y;\r\n  vec3 pos = (majorRadius + minorRadius * cos(v)) * vec3(cos(u), sin(u), 0.0) + vec3(0.0, 0.0, minorRadius * sin(v));\r\n\r\n  vec3 normal = vec3(cos(v) * cos(u), cos(v) * sin(u), sin(v));\r\n  // vec3 pos = majorRadius * normal;\r\n\r\n  return PosNorm(pos, normal, SURFACE_TYPE_TORUS);\r\n}\r\n\r\n`\r\n)\r\n\r\nshaderLibrary.setShaderModule(\r\n  'GLSLCADCompoundSurfaces.glsl',\r\n  `\r\n\r\n/////////////////////////////////////////\r\n// LinearExtrusion\r\n\r\nPosNorm calcLinearExtrusionSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\r\n  box2 domain = loadBox2(reader, texture);\r\n  \r\n  int curve_index = GLSLBinReader_readUIntFrom2xUFloat16(reader, texture);\r\n\r\n  vec3 curve_tr = vec3(\r\n    GLSLBinReader_readFloat(reader, texture),\r\n    GLSLBinReader_readFloat(reader, texture),\r\n    GLSLBinReader_readFloat(reader, texture)\r\n  );\r\n  vec4 curve_ori = vec4(\r\n    GLSLBinReader_readFloat(reader, texture),\r\n    GLSLBinReader_readFloat(reader, texture),\r\n    GLSLBinReader_readFloat(reader, texture),\r\n    GLSLBinReader_readFloat(reader, texture)\r\n    );\r\n  vec3 curve_sc = vec3(\r\n    GLSLBinReader_readFloat(reader, texture),\r\n    GLSLBinReader_readFloat(reader, texture),\r\n    GLSLBinReader_readFloat(reader, texture)\r\n  );\r\n  vec2 uv = mapDomain(domain, params);\r\n\r\n  PosNorm curveResult = evalCADCurve3d(curve_index, uv.x);\r\n  \r\n  vec3 pos = quat_rotateVec3(curve_ori, curveResult.pos * curve_sc) + curve_tr;\r\n  pos.z += uv.y;\r\n\r\n  vec3 normal = normalize(cross(vec3(0.0, 0.0, 1.0), quat_rotateVec3(curve_ori, curveResult.normal)));\r\n\r\n  return PosNorm(pos, normal, SURFACE_TYPE_LINEAR_EXTRUSION);\r\n}\r\n\r\n\r\n/////////////////////////////////////////\r\n// Revolution\r\nPosNorm calcRevolutionSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture, bool flipDomain) {\r\n  box2 domain = loadBox2(reader, texture);\r\n\r\n  int curve_index = GLSLBinReader_readUIntFrom2xUFloat16(reader, texture);\r\n\r\n  vec3 curve_tr = vec3(\r\n    GLSLBinReader_readFloat(reader, texture),\r\n    GLSLBinReader_readFloat(reader, texture),\r\n    GLSLBinReader_readFloat(reader, texture)\r\n  );\r\n  vec4 curve_ori = vec4(\r\n    GLSLBinReader_readFloat(reader, texture),\r\n    GLSLBinReader_readFloat(reader, texture),\r\n    GLSLBinReader_readFloat(reader, texture),\r\n    GLSLBinReader_readFloat(reader, texture)\r\n    );\r\n  vec3 curve_sc = vec3(\r\n    GLSLBinReader_readFloat(reader, texture),\r\n    GLSLBinReader_readFloat(reader, texture),\r\n    GLSLBinReader_readFloat(reader, texture)\r\n  );\r\n  vec2 uv = mapDomain(domain, params);\r\n\r\n  vec3 axis = vec3(0.0, 0.0, 1.0);\r\n  PosNorm curveResult;\r\n  vec4 rev;\r\n  if (flipDomain) {\r\n    curveResult = evalCADCurve3d(curve_index, uv.x);\r\n    rev = quat_fromAxisAndAngle(axis, uv.y);\r\n  } else {\r\n    curveResult = evalCADCurve3d(curve_index, uv.y);\r\n    rev = quat_fromAxisAndAngle(axis, uv.x);\r\n  }\r\n\r\n  vec3 p_t = quat_rotateVec3(curve_ori, curveResult.pos * curve_sc) + curve_tr;\r\n  vec3 pos = quat_rotateVec3(rev, p_t);\r\n\r\n  vec3 p_n = quat_rotateVec3(rev, quat_rotateVec3(curve_ori, curveResult.normal));\r\n  \r\n  vec3 tangent;\r\n  if (abs(1.0 - dot(p_n, axis)) > 0.001) {\r\n    tangent = cross(p_n, axis);\r\n  } else {\r\n    tangent = cross(pos, axis);\r\n  }\r\n  // TODO: Find a conclusive test file that demonstrates this as correct.\r\n  // I think it is the master cylinder sample.\r\n  // vec3 normal = normalize(cross(p_n, tangent));\r\n  vec3 normal = normalize(cross(tangent, p_n));\r\n\r\n  // vec3 pos;\r\n  // vec3 normal;\r\n  // pos.x = float(partA);\r\n  // pos.y = float(partB);\r\n  // pos.z = float(curve_index);\r\n  return PosNorm(pos, normal, SURFACE_TYPE_REVOLUTION);\r\n}\r\n\r\n\r\n/////////////////////////////////////////\r\n// OffsetSurface\r\n\r\nPosNorm calcOffsetSurfaceSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\r\n  box2 domain = loadBox2(reader, texture);\r\n  int surfaceId = GLSLBinReader_readUInt(reader, texture);\r\n  float offset = GLSLBinReader_readFloat(reader, texture);\r\n  vec2 uv = mapDomain(domain, params);\r\n\r\n/*\r\n  GLSLBinReader subSurfaceReader = reader;\r\n  subSurfaceReader.start = \r\n  GLSLBinReader_init(reader, surfaceDataTextureSize, region, start, 32);\r\n\r\n  vec3 p = calcCurvePoint(uv.x);\r\n  vec3 pos = p + dir * (dist * uv.y);\r\n  \r\n*/\r\n  vec3 pos;\r\n  vec3 normal;\r\n  return PosNorm(pos, normal, SURFACE_TYPE_OFFSET_SURFACE);\r\n}\r\n\r\n\r\n\r\n`\r\n)\r\n","import { shaderLibrary } from '@zeainc/zea-engine'\r\n\r\nshaderLibrary.setShaderModule(\r\n  'GLSLNURBS.glsl',\r\n  `\r\n\r\n#define MAX_KNOTS 256\r\n// Note: The BRP motorcycle features many surfaces of degree 15.\r\n#define MAX_DEGREE 16\r\n\r\nfloat kp(int index, inout GLSLBinReader r, sampler2D t, int offset) {\r\n  return GLSLBinReader_readFloat(r, t, offset+index);\r\n}\r\n\r\n#ifdef EXPORT_KNOTS_AS_DELTAS\r\n\r\nint findSpan(float u, in int degree, in int numKnots, int kpOff, inout GLSLBinReader r, sampler2D t, out highp float knots[MAX_DEGREE*2+1]) {\r\n  \r\n  float nextKnot = kp(0, r, t, kpOff);\r\n  float knot = nextKnot;\r\n\r\n  int span = 1;\r\n  int n = numKnots - degree - 1;\r\n  // Linear Search...\r\n  for (; span<n; span++){\r\n    nextKnot += kp(span, r, t, kpOff);\r\n    if (span > degree && u < nextKnot){\r\n      span--;\r\n      break;\r\n    }\r\n    knot = nextKnot;\r\n  }\r\n  if (span == n) {\r\n    span--;\r\n  }\r\n\r\n\r\n  //Calculate knot values\r\n  knots[degree] = knot;\r\n  float left = knot;\r\n  float right = knot; \r\n  for (int i=1; i<=degree; i++) {\r\n    left -= kp(span-i+1, r, t, kpOff);\r\n    right += kp(span+i, r, t, kpOff);\r\n    knots[degree-i] = left;\r\n    knots[degree+i] = right;\r\n  }\r\n\r\n  return span;\r\n}\r\n\r\nvoid calcBasisValues(in float u, in int degree, in highp float knots[MAX_DEGREE*2+1], out highp float basisValues[MAX_DEGREE+1], out highp float bvD[MAX_DEGREE+1]) {\r\n  \r\n  highp vec2 savedTemp;\r\n  highp float left[MAX_DEGREE+1];\r\n  highp float right[MAX_DEGREE+1];\r\n\r\n  //Basis[0] is always 1.0\r\n  basisValues[0] = 1.0;\r\n  // Calculate basis values\r\n  for (int i=1; i<=degree; i++) {\r\n    left[i] = u - knots[degree+1-i];\r\n    right[i] = knots[degree+i] - u;\r\n\r\n    savedTemp.x = 0.0;\r\n    for (int j=0; j<i; j++) {\r\n      float rv = right[j+1];\r\n      float lv = left[i-j];\r\n      savedTemp.y = basisValues[j] / (rv + lv);\r\n      basisValues[j] = savedTemp.x + rv * savedTemp.y;\r\n      savedTemp.x = lv * savedTemp.y;\r\n    }\r\n    basisValues[i] = savedTemp.x;\r\n\r\n    // Calculate N' if on second to last iteration\r\n    if (i == degree-1 || degree == 1) {\r\n      savedTemp.x = 0.0;\r\n      //Loop through all basis values\r\n      for (int j=0; j<degree; j++) {\r\n        // Calculate a temp variable\r\n        int jr_z = j + 1;\r\n        //Calculate right side\r\n        float kp_0 = knots[jr_z + degree];\r\n        float kp_1 = knots[jr_z];\r\n        savedTemp.y = (float(degree) * basisValues[j]) / (kp_0 - kp_1);\r\n        // Calculate derivative value\r\n        bvD[j] = savedTemp.x - savedTemp.y;\r\n        // Swap right side to left\r\n        savedTemp.x = savedTemp.y;\r\n      }\r\n      //Save the last der-basis\r\n      bvD[degree] = savedTemp.x;\r\n    }\r\n  }\r\n}\r\n\r\n#else\r\n\r\n// http://read.pudn.com/downloads134/sourcecode/math/569665/nurbsR2006b/findspan.c__.htm\r\n// Note: I have found the 'early outs' in the Three code to be more correct\r\n// https://github.com/mrdoob/three.js/blob/b8d8a8625465bd634aa68e5846354d69f34d2ff5/examples/js/curves/NURBSUtils.js\r\nint findSpan(float u, in int degree, in int numKnots, int kpOff, inout GLSLBinReader r, sampler2D t, bool periodic) {\r\n  \r\n  // early outs\r\n  int n = numKnots - degree - 1;\r\n  if(u >= kp(n, r, t, kpOff))\r\n    return n-1;\r\n  if(u <= kp(degree, r, t, kpOff)) {\r\n    return degree;\r\n  }\r\n\r\n  // Linear Search...\r\n#ifdef ENABLE_ES3\r\n  int i = degree; \r\n  for (; i<n; i++){\r\n#else\r\n  // Note: loop values must be constant.\r\n  // Loops start at 1 because that is the minimum degree for a curve.\r\n  for (int i = 1; i<MAX_KNOTS; i++){\r\n    if(i >= degree && i < numKnots-1){\r\n#endif\r\n    if (u < kp(i+1, r, t, kpOff)){\r\n      return i;\r\n    }\r\n#ifndef ENABLE_ES3\r\n  }\r\n#endif\r\n  }\r\n\r\n  return i;\r\n}\r\n\r\n\r\nvoid calcBasisValues(in float u, in int span, int degree, int kpOff, int numKnots, inout GLSLBinReader r, sampler2D t, out highp float basisValues[MAX_DEGREE+1], out highp float bvD[MAX_DEGREE+1]) {\r\n  \r\n  highp vec2 savedTemp;\r\n  highp float left[MAX_DEGREE+1];\r\n  highp float right[MAX_DEGREE+1];\r\n\r\n  // Basis[0] is always 1.0\r\n  basisValues[0] = 1.0;\r\n  // Calculate basis values\r\n#ifdef ENABLE_ES3\r\n  for (int i=1; i<=degree; i++) {\r\n#else\r\n  for (int i=1; i<MAX_DEGREE; i++) {\r\n    if(i > degree) // i<=degree\r\n      break;\r\n#endif\r\n    left[i] = u - kp(span+1-i, r, t, kpOff);\r\n    right[i] = kp(span+i, r, t, kpOff) - u;\r\n\r\n    savedTemp.x = 0.0;\r\n#ifdef ENABLE_ES3\r\n    for (int j=0; j<i; j++) {\r\n#else\r\n    for (int j=0; j<MAX_DEGREE; j++) {\r\n      if(j >= i) // j < i\r\n        break;\r\n#endif\r\n      float rv = right[j+1];\r\n      float lv = left[i-j];\r\n      savedTemp.y = basisValues[j] / (rv + lv);\r\n      basisValues[j] = savedTemp.x + rv * savedTemp.y;\r\n      savedTemp.x = lv * savedTemp.y;\r\n    }\r\n    basisValues[i] = savedTemp.x;\r\n    \r\n    // Calculate N' if on second to last iteration\r\n    if (i == degree-1 || degree == 1) {\r\n      savedTemp.x = 0.0;\r\n      // Loop through all basis values\r\n#ifdef ENABLE_ES3\r\n      for (int j=0; j<degree; j++) {\r\n#else\r\n      for (int j=0; j<MAX_DEGREE; j++) {\r\n        if(j >= degree) // j < degree\r\n          break;\r\n#endif\r\n        // Calculate a temp variable\r\n        int jr_z = span - degree + j + 1;\r\n        // Calculate right side\r\n        float kp_0 = kp(jr_z + degree, r, t, kpOff);\r\n        float kp_1 = kp(jr_z, r, t, kpOff);\r\n        savedTemp.y = (float(degree) * basisValues[j]) / (kp_0 - kp_1);\r\n        // Calculate derivative value\r\n        bvD[j] = savedTemp.x - savedTemp.y;\r\n        // Swap right side to left\r\n        savedTemp.x = savedTemp.y;\r\n      }\r\n      // Save the last der-basis\r\n#ifdef ENABLE_ES3\r\n      bvD[degree] = savedTemp.x;\r\n#else\r\n      if(degree == 1)\r\n        bvD[1] = savedTemp.x;\r\n      else if(degree == 2)\r\n        bvD[2] = savedTemp.x;\r\n      else if(degree == 3)\r\n        bvD[3] = savedTemp.x;\r\n      else if(degree == 4)\r\n        bvD[4] = savedTemp.x;\r\n      else if(degree == 5)\r\n        bvD[5] = savedTemp.x;\r\n      else if(degree == 6)\r\n        bvD[6] = savedTemp.x;\r\n      else if(degree == 7)\r\n        bvD[7] = savedTemp.x;\r\n      else if(degree == 8)\r\n        bvD[8] = savedTemp.x;\r\n      else if(degree == 9)\r\n        bvD[9] = savedTemp.x;\r\n      else if(degree == 10)\r\n        bvD[10] = savedTemp.x;\r\n      else if(degree == 11)\r\n        bvD[11] = savedTemp.x;\r\n      else if(degree == 12)\r\n        bvD[12] = savedTemp.x;\r\n      else if(degree == 13)\r\n        bvD[13] = savedTemp.x;\r\n      else if(degree == 14)\r\n        bvD[14] = savedTemp.x;\r\n      else if(degree == 15)\r\n        bvD[15] = savedTemp.x;\r\n#endif\r\n    }\r\n  }\r\n}\r\n\r\n\r\n#endif\r\n\r\n`\r\n)\r\n","import { shaderLibrary } from '@zeainc/zea-engine'\r\n\r\nshaderLibrary.setShaderModule(\r\n  'GLSLNURBSCurves.glsl',\r\n  `\r\n\r\nstruct NURBSCurveData {\r\n  vec2 domain;\r\n  bool periodic;\r\n  int degree;\r\n  int numCPs;\r\n  int numKnots;\r\n\r\n  int cpStart;\r\n  int kpStart;\r\n};\r\n\r\nvoid loadNURBSCurve3dData(inout GLSLBinReader reader, sampler2D texture, out NURBSCurveData result) {\r\n\r\n  result.domain.x = GLSLBinReader_readFloat(reader, texture);\r\n  result.domain.y = GLSLBinReader_readFloat(reader, texture);\r\n  result.degree = GLSLBinReader_readUInt(reader, texture);\r\n\r\n  result.numCPs = GLSLBinReader_readUInt(reader, texture);\r\n  result.numKnots = GLSLBinReader_readUInt(reader, texture);\r\n  int flags = GLSLBinReader_readUInt(reader, texture);\r\n  result.periodic = testFlag(flags, CURVE_FLAG_PERIODIC);\r\n\r\n  result.cpStart = 2*4; // 2 RGBA pixels of data before the knot values start.\r\n  result.kpStart = result.cpStart + (result.numCPs*4);\r\n}\r\n\r\nvec4 curve_cp3d(int u, inout GLSLBinReader r, NURBSCurveData d, sampler2D t) {\r\n  int index = u * 4;\r\n  return GLSLBinReader_readVec4(r, t, d.cpStart + index);\r\n}\r\n\r\n// https://github.com/akshatamohanty/wildcat-cad/blob/650e18d665ccde3dbc4c78029e35c38951581c92/Source/Geometry/Shaders/ns23_default_plM.fsh\r\n// https://github.com/mrdoob/three.js/blob/6c7f000734f8579da37fb39e5c2e9e5e2dfb14f8/examples/js/curves/NURBSUtils.js\r\n\r\n/*\r\n  Calculate rational B-Spline curve point. See The NURBS Book, page 134, algorithm A4.3.\r\n*/\r\nPosNorm calcNURBSCurve3dPoint(float param, inout GLSLBinReader r, sampler2D t) {\r\n\r\n  NURBSCurveData d;\r\n  loadNURBSCurve3dData(r, t, d);\r\n\r\n  float u = d.domain.x + param * ( d.domain.y - d.domain.x ); // linear mapping param->u\r\n  //if(d.periodic)\r\n  //    u = wrap(u, kp(0, r, t, d.kpStart), kp(d.numKnots-1, r, t, d.kpStart));\r\n \r\n  float bv[MAX_DEGREE+1];\r\n  float bvds[MAX_DEGREE+1];\r\n\r\n#ifdef EXPORT_KNOTS_AS_DELTAS\r\n  highp float knots[MAX_DEGREE*2+1];\r\n  int span = findSpan(u, d.degree, d.numKnots, d.kpStart, r, t, knots);\r\n  //return PosNorm(vec3(span, knots[d.degree], knots[d.degree+1]), vec3(1.0), CURVE_TYPE_NURBS_CURVE);\r\n  //return PosNorm(vec3(knots[d.degree-1], knots[d.degree], knots[d.degree+1]), vec3(1.0), CURVE_TYPE_NURBS_CURVE);\r\n  //return PosNorm(vec3(knots[d.degree+1], knots[d.degree+2], knots[d.degree+3]), vec3(1.0), CURVE_TYPE_NURBS_CURVE);\r\n\r\n  calcBasisValues(u, d.degree, knots, bv, bvds);\r\n  // return PosNorm(vec3(bv[0], bv[1], bv[2]), vec3(bv[3], bv[4], bv[5]), CURVE_TYPE_NURBS_CURVE);\r\n#else\r\n  int span = findSpan(u, d.degree, d.numKnots, d.kpStart, r, t, d.periodic);\r\n  // return PosNorm(vec3(float(span)), vec3(1.0), CURVE_TYPE_NURBS_CURVE);\r\n  // return PosNorm(vec3(kp(span-1, r, t, d.kpStart), kp(span-0, r, t, d.kpStart), kp(span+1, r, t, d.kpStart)), vec3(0.0), CURVE_TYPE_NURBS_CURVE);\r\n\r\n  // Invalid knot vectors exist where all the values are identical.\r\n  if (kp(span, r, t, d.kpStart) == kp(span+1, r, t, d.kpStart)) {\r\n    for(int x=0; x <= d.degree; x++)\r\n      bv[x] = 0.0;\r\n    bv[d.degree] = 1.0;\r\n  }\r\n  else {\r\n    calcBasisValues(u, span, d.degree, d.kpStart, d.numKnots, r, t, bv, bvds);\r\n  }\r\n  // return PosNorm(vec3(bv[0], bv[1], bv[2]), vec3(bv[3], bv[4], bv[5]), CURVE_TYPE_NURBS_CURVE);\r\n#endif\r\n\r\n\r\n  float w = 0.0;\r\n  vec3 pos = vec3(0.0);\r\n  vec3 tangent = vec3(0.0);\r\n\r\n  int cv0 = (span - d.degree);\r\n#ifdef ENABLE_ES3\r\n  for(int x=0; x <= d.degree; x++) {\r\n#else\r\n  for(int x=0; x < MAX_DEGREE; x++) {\r\n    if(x > d.degree) // x<=degree\r\n      break;\r\n#endif\r\n    int index = cv0 + x;\r\n    vec4 pt = curve_cp3d(index, r, d, t);\r\n\r\n    if(d.degree < 3) {\r\n      // Rhino style evaluation....\r\n      highp float bvw = bv[x];\r\n      pos += pt.xyz * bvw;\r\n      w += pt.w * bvw;\r\n    }\r\n    else {\r\n      // Tiny NURBS/CADEx style evaluation....\r\n      highp float bvw = pt.w * bv[x];\r\n      pos += pt.xyz * bvw;\r\n      w += bvw;\r\n    }\r\n\r\n    tangent += pt.xyz * bvds[x];\r\n  }\r\n\r\n  pos /= w;\r\n\r\n\r\n  // Calc tangent\r\n  if(d.degree == 1){\r\n    vec3 pt0 = curve_cp3d(cv0, r, d, t).xyz;\r\n    vec3 pt1 = curve_cp3d(cv0+1, r, d, t).xyz;\r\n    tangent = pt1 - pt0;\r\n  }\r\n  else {\r\n    if (length(tangent) < 0.05) {\r\n\r\n      float spanLerp = u - knots[span];\r\n      float spanRange = knots[span+1] - knots[span];\r\n      int cv = int(floor((spanLerp / spanRange) * float(d.degree-1)));\r\n\r\n      vec3 pt0 = curve_cp3d(cv, r, d, t).xyz;\r\n      vec3 pt1 = curve_cp3d(cv+1, r, d, t).xyz;\r\n      tangent = pt1 - pt0;\r\n    }\r\n  }\r\n\r\n  return PosNorm(pos, normalize(tangent), CURVE_TYPE_NURBS_CURVE);\r\n}\r\n\r\n\r\n\r\n`\r\n)\r\n","import { shaderLibrary } from '@zeainc/zea-engine'\r\nshaderLibrary.setShaderModule(\r\n  'GLSLNURBSSurfaces.glsl',\r\n  `\r\n\r\nstruct NURBSSurfaceData {\r\n  box2 domain;\r\n  bool periodicU;\r\n  bool periodicV;\r\n  int degreeU;\r\n  int degreeV;\r\n  int numCPsU;\r\n  int numCPsV;\r\n  int numKnotsU;\r\n  int numKnotsV;\r\n\r\n  int cpStart;\r\n  int kpUStart;\r\n  int kpVStart;\r\n};\r\n\r\nvoid loadNURBSSurfaceData(inout GLSLBinReader reader, sampler2D texture, out NURBSSurfaceData result) {\r\n\r\n  result.domain.p0.x = GLSLBinReader_readFloat(reader, texture);\r\n  result.domain.p0.y = GLSLBinReader_readFloat(reader, texture);\r\n  result.domain.p1.x = GLSLBinReader_readFloat(reader, texture);\r\n\r\n  result.domain.p1.y = GLSLBinReader_readFloat(reader, texture);\r\n  result.degreeU = GLSLBinReader_readInt(reader, texture);\r\n  if(result.degreeU > MAX_DEGREE)\r\n    result.degreeU = MAX_DEGREE;\r\n  result.degreeV = GLSLBinReader_readInt(reader, texture);\r\n  if(result.degreeV > MAX_DEGREE)\r\n    result.degreeV = MAX_DEGREE;\r\n  result.numCPsU = GLSLBinReader_readInt(reader, texture);\r\n\r\n  result.numCPsV = GLSLBinReader_readInt(reader, texture);\r\n  result.numKnotsU = GLSLBinReader_readInt(reader, texture);\r\n  result.numKnotsV = GLSLBinReader_readInt(reader, texture);\r\n  int flags = GLSLBinReader_readInt(reader, texture);\r\n  result.periodicU = testFlag(flags, SURFACE_FLAG_PERIODIC_U);\r\n  result.periodicV = testFlag(flags, SURFACE_FLAG_PERIODIC_V);\r\n\r\n  result.cpStart  = 3*4; // 3 RGBA pixels of data before the knot values start.\r\n  result.kpUStart = result.cpStart + (result.numCPsU*result.numCPsV*4);\r\n  result.kpVStart = result.kpUStart + result.numKnotsU;\r\n}\r\n\r\nvec4 surface_cp(int u, int v, inout GLSLBinReader r, NURBSSurfaceData d, sampler2D t) {\r\n  int index = (u + (v * d.numCPsU)) * 4;\r\n  return GLSLBinReader_readVec4(r, t, d.cpStart + index);\r\n}\r\n\r\n/*\r\n  Calculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\r\n*/\r\nPosNorm calcNURBSSurfacePoint(vec2 params, inout GLSLBinReader r, sampler2D t) {\r\n\r\n  vec3 tmp;\r\n  NURBSSurfaceData d;\r\n  loadNURBSSurfaceData(r, t, d);\r\n\r\n  // ///////////////////////////////////////\r\n  // // vec3 cp_pos = vec3(params.x + float(d.degreeU), params.y + float(d.degreeV), 0.0 );\r\n  // vec3 cp_pos = vec3(params.x + float(d.numCPsU), params.y + float(d.numCPsV), 0.0 );\r\n  // return PosNorm(cp_pos, tmp);\r\n  // ///////////////////////////////////////\r\n\r\n  // ///////////////////////////////////////\r\n  // int knot_x = int(params.x * float(d.numCPsU-1));\r\n  // int knot_y = int(params.y * float(d.numCPsV-1));\r\n  // vec4 cp_pos = surface_cp(knot_x, knot_y, r, d, t);\r\n  // return PosNorm(cp_pos.xyz, tmp);\r\n  // ///////////////////////////////////////\r\n\r\n  vec2 uv = mapDomain(d.domain, params); // linear mapping params -> uv\r\n  float u = uv.x;\r\n  float v = uv.y;\r\n\r\n  highp float basisValuesU[MAX_DEGREE+1];\r\n  highp float basisValuesV[MAX_DEGREE+1];\r\n  highp float bvdsU[MAX_DEGREE+1];\r\n  highp float bvdsV[MAX_DEGREE+1];\r\n  \r\n#ifdef EXPORT_KNOTS_AS_DELTAS\r\n  highp float knotsU[MAX_DEGREE*2+1];\r\n  highp float knotsV[MAX_DEGREE*2+1];\r\n  int spanU = findSpan(u, d.degreeU, d.numKnotsU, d.kpUStart, r, t, knotsU);\r\n  int spanV = findSpan(v, d.degreeV, d.numKnotsV, d.kpVStart, r, t, knotsV);\r\n  calcBasisValues(u, d.degreeU, knotsU, basisValuesU, bvdsU);\r\n  calcBasisValues(v, d.degreeV, knotsV, basisValuesV, bvdsV);\r\n\r\n#else\r\n  int spanU = findSpan(u, d.degreeU, d.numKnotsU, d.kpUStart, r, t, d.periodicU);\r\n  int spanV = findSpan(v, d.degreeV, d.numKnotsV, d.kpVStart, r, t, d.periodicV);\r\n\r\n  calcBasisValues(u, spanU, d.degreeU, d.kpUStart, d.numKnotsU, r, t, basisValuesU, bvdsU);\r\n  calcBasisValues(v, spanV, d.degreeV, d.kpVStart, d.numKnotsV, r, t, basisValuesV, bvdsV);\r\n#endif\r\n\r\n  // ///////////////////////////////////////\r\n  // return PosNorm(vec3(knotsV[11], knotsV[12], knotsV[13]), tmp, SURFACE_TYPE_NURBS_SURFACE);\r\n  // return PosNorm(vec3(knotsV[14], knotsV[15], knotsV[16]), tmp, SURFACE_TYPE_NURBS_SURFACE);\r\n  // return PosNorm(vec3(knotsV[17], knotsV[18], knotsV[19]), tmp, SURFACE_TYPE_NURBS_SURFACE);\r\n  // return PosNorm(vec3(basisValuesU[0], basisValuesU[1], basisValuesU[2]), tmp, SURFACE_TYPE_NURBS_SURFACE);\r\n  // ///////////////////////////////////////\r\n\r\n  ivec2 indices;\r\n  highp float w = 0.0;\r\n  highp vec3 pos = vec3(0.0);\r\n  highp vec3 tangentU = vec3(0.0);\r\n  highp vec3 tangentV = vec3(0.0);\r\n  int cvU0 = (spanU - d.degreeU);\r\n  int cvV0 = (spanV - d.degreeV);\r\n#ifdef ENABLE_ES3\r\n  for(int y=0; y <= d.degreeV; y++) {\r\n#else\r\n  for(int y=0; y < MAX_DEGREE; y++) {\r\n     if(y > d.degreeV) // y<=degree\r\n         break;\r\n#endif\r\n    indices.y = cvV0 + y;\r\n\r\n#ifdef ENABLE_ES3\r\n    for(int x=0; x <= d.degreeU; x++) {\r\n#else\r\n    for(int x=0; x < MAX_DEGREE; x++) {\r\n      if(x > d.degreeU) // x<=degree\r\n        break;\r\n#endif\r\n      indices.x = cvU0 + x;\r\n      \r\n      vec4 cv = surface_cp(indices.x, indices.y, r, d, t);\r\n      vec3 pt = cv.xyz;\r\n      float weight = cv.w;\r\n\r\n      float bvU = basisValuesU[x];\r\n      float bvV = basisValuesV[y];\r\n\r\n// #define USE_RHNIO_EVALUATION_MATH 1\r\n#ifdef USE_RHNIO_EVALUATION_MATH\r\n      // Rhino style evaluation....\r\n      float bvw = bvU * bvV;\r\n      pos += pt * bvw;\r\n      w += weight * bvw;\r\n#else\r\n      // Tiny NURBS/CADEx style evaluation....\r\n      highp float bvw = weight * bvU * bvV;\r\n      pos += pt * bvw;\r\n      w += bvw;\r\n#endif\r\n        \r\n      float bvdU = bvdsU[x];\r\n      float bvdV = bvdsV[y];\r\n\r\n      tangentU += pt * bvdU * bvV;\r\n      tangentV += pt * bvU * bvdV;\r\n    }\r\n  }\r\n\r\n  pos /= w;\r\n\r\n  ///////////////////////////////////////////////////////\r\n  // Calculate normal.\r\n  float spanRangeU = knotsU[d.degreeU + 1] - knotsU[d.degreeU];\r\n  float spanRangeV = knotsV[d.degreeV + 1] - knotsV[d.degreeV];\r\n  float eqKnotRangeU = ( d.domain.p1.x - d.domain.p0.x ) / float(d.numKnotsU);\r\n  float eqKnotRangeV = ( d.domain.p1.y - d.domain.p0.y ) / float(d.numKnotsV);\r\n  \r\n  \r\n  if (spanRangeU / eqKnotRangeU < 0.01) { \r\n    // In some cases (COOLANT_INLET_PORT_01.ipt_faceWithBlackEdge.)\r\n    // we have span segment which has close to zero delta, and \r\n    // so the normals are broken. We want to advace along the \r\n    // e.g. [0, 0, 0, 0.00001, 1, 3, 3, 3]\r\n    // length of the span rather than when we have a pinched corner, \r\n    // where we move along the toher direction.\r\n    // console.log(v, 'spanRangeU:', spanRangeU, ' eqKnotRangeU:', eqKnotRangeU, spanRangeU / eqKnotRangeU)\r\n\r\n    int cvU = cvU0;\r\n    if (v > d.domain.p1.y - 0.0001) {\r\n      // If at the end then we grab the end of the pevious row.\r\n      cvU = cvU0 + d.degreeU - 2;\r\n    } else {\r\n      // if the broken normal is at the start of the U range, then \r\n      // we will grab the next in the row. \r\n      cvU = cvU0 + 1;\r\n    }\r\n\r\n    float spanLerpV = (u - knotsV[d.degreeV]) / spanRangeV;\r\n    int cvV = cvV0 + int(floor(spanLerpV * float(d.degreeV)));\r\n\r\n    vec3 pt0 = surface_cp(cvU, cvV, r, d, t).xyz;\r\n    vec3 pt1 = surface_cp(cvU+1, cvV, r, d, t).xyz;\r\n\r\n    tangentU = pt1 - pt0;\r\n  } else if (length(tangentU) < 0.001) {\r\n    // Note: on values to big, we get false positives.\r\n    // See: 2_SR00404681_1_RI510090.CATPart.zcad\r\n    // long narrow nurbs surface above the tail light.\r\n    // Reduced from 0.05 to 0.001 fixed it.\r\n\r\n    // The derivative in the V direction is zero, \r\n    // so we calculate the linear derivative for the next control points along.\r\n    \r\n    int cvV;\r\n    if (spanV > d.degreeV) {\r\n      // If at the end then we grab the end of the pevious row.\r\n      cvV = cvV0 + d.degreeV - 2;\r\n    } else {\r\n      // if the broken normal is at the start of the V range, then \r\n      // we will grab the next in the row. \r\n      cvV = cvV0 + 1;\r\n    }\r\n    \r\n    float spanLerpU = (u - knotsU[d.degreeU]) / spanRangeU;\r\n    int cvU = cvU0 + int(floor(spanLerpU * float(d.degreeU)));\r\n    \r\n    vec3 pt0 = surface_cp(cvU, cvV, r, d, t).xyz;\r\n    vec3 pt1 = surface_cp(cvU+1, cvV, r, d, t).xyz;\r\n\r\n    tangentU = pt1 - pt0;\r\n  }\r\n\r\n  if (spanRangeV / eqKnotRangeV < 0.01) {\r\n    // In some cases (COOLANT_INLET_PORT_01.ipt_faceWithBlackEdge.)\r\n    // we have span segment which has close to zero delta, and \r\n    // so the normals are broken. We want to advace along the \r\n    // e.g. [0, 0, 0, 0.00001, 1, 3, 3, 3]\r\n    // length of the span rather than when we have a pinched corner, \r\n    // where we move along the toher direction.\r\n    // console.log(v, 'spanRangeV:', spanRangeV, ' eqKnotRangeV:', eqKnotRangeV, spanRangeV / eqKnotRangeV)\r\n\r\n    int cvV = cvV0;\r\n    if (v > d.domain.p1.y - 0.0001) {\r\n      // If at the end then we grab the end of the pevious row.\r\n      cvV = cvV0 + d.degreeV - 2;\r\n    } else {\r\n      // if the broken normal is at the start of the V range, then \r\n      // we will grab the next in the row. \r\n      cvV = cvV0 + 1;\r\n    }\r\n\r\n    float spanLerpU = (u - knotsU[d.degreeU]) / spanRangeU;\r\n    int cvU = cvU0 + int(floor(spanLerpU * float(d.degreeU)));\r\n\r\n    vec3 pt0 = surface_cp(cvU, cvV, r, d, t).xyz;\r\n    vec3 pt1 = surface_cp(cvU, cvV+1, r, d, t).xyz;\r\n\r\n    tangentV = pt1 - pt0;\r\n    \r\n  } else if (length(tangentV) < 0.001) { \r\n    // Note: on values to big, we get false positives.\r\n    // See: 2_SR00404681_1_RI510090.CATPart.zcad\r\n    // long narrow nurbs surface above the tail light.\r\n    // Reduced from 0.05 to 0.001 fixed it.\r\n\r\n    // The derivative in the V direction is close to zero, \r\n    // so we calculate the linear derivative for the next control points along.\r\n\r\n    int cvU = cvU0;\r\n    if (v > d.domain.p1.y - 0.0001) {\r\n      // If at the end then we grab the end of the pevious row.\r\n      cvU = cvU0 + d.degreeU - 2;\r\n    } else {\r\n      // if the broken normal is at the start of the U range, then\r\n      // we will grab the next in the row.\r\n      cvU = cvU0 + 1;\r\n    }\r\n\r\n    float spanLerpV = (u - knotsV[d.degreeV]) / spanRangeV;\r\n    int cvV = cvV0 + int(floor(spanLerpV * float(d.degreeV)));\r\n\r\n    vec3 pt0 = surface_cp(cvU, cvV, r, d, t).xyz;\r\n    vec3 pt1 = surface_cp(cvU, cvV+1, r, d, t).xyz;\r\n\r\n    tangentV = pt1 - pt0;\r\n  }\r\n\r\n  // vec3 normal = tangentV;\r\n  // Note: in the gear_box_final_asm.zcad. the nurbs surfaces were all flipped\r\n  // This is only apparent in cut-away scenes, which the gearbox demo is.\r\n  // vec3 normal = normalize(cross(tangentV, tangentU));\r\n  vec3 normal = normalize(cross(tangentU, tangentV));\r\n\r\n  return PosNorm(pos, normal, SURFACE_TYPE_NURBS_SURFACE);\r\n}\r\n\r\n`\r\n)\r\n","/* eslint-disable camelcase */\r\nimport { GLShader, shaderLibrary } from '@zeainc/zea-engine'\r\n\r\nimport './GLSLBinReader.js'\r\nimport './GLSLMath.js'\r\nimport './GLSLCADCurves.js'\r\nimport './GLSLCADSurfaces.js'\r\nimport './GLSLNURBS.js'\r\nimport './GLSLNURBSCurves.js'\r\nimport './GLSLNURBSSurfaces.js'\r\n\r\nconst GLEvaluateCADSurfaceShader_VERTEX_SHADER = shaderLibrary.parseShader(\r\n  'GLEvaluateCADSurfaceShader.vertexShader',\r\n  `\r\nprecision highp float;\r\n\r\nattribute vec3 positions;\r\ninstancedattribute float surfaceId;\r\n\r\nuniform sampler2D surfaceAtlasLayoutTexture;\r\nuniform ivec2 surfaceAtlasLayoutTextureSize;\r\n\r\nuniform ivec2 surfacesAtlasTextureSize;\r\n\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n<%include file=\"GLSLBinReader.glsl\"/>\r\n\r\n/* VS Outputs */\r\nvarying float v_surfaceId;      // flat\r\nvarying vec3 v_geomDataCoords;  // flat\r\nvarying vec2 v_patchSize;       // flat\r\nvarying vec2 v_vertexCoord;\r\n\r\n\r\n\r\nvoid main(void) {\r\n\r\n  GLSLBinReader reader;\r\n  GLSLBinReader_init(reader, surfaceAtlasLayoutTextureSize, 32);\r\n  vec4 patchCoords = GLSLBinReader_readVec4(reader, surfaceAtlasLayoutTexture, int(surfaceId)*8);\r\n  vec4 surfaceDataCoords = GLSLBinReader_readVec4(reader, surfaceAtlasLayoutTexture, (int(surfaceId)*8)+4);\r\n\r\n  vec2 patchPos = patchCoords.xy;\r\n  v_patchSize = patchCoords.zw;\r\n\r\n  v_surfaceId = surfaceId;\r\n  v_geomDataCoords = surfaceDataCoords.xyz;\r\n  v_vertexCoord = (positions.xy + 0.5) * v_patchSize;\r\n\r\n  vec2 pos = (patchPos + v_vertexCoord) / vec2(surfacesAtlasTextureSize);\r\n  gl_Position = vec4((pos - 0.5) * 2.0, 0.0, 1.0);\r\n}\r\n`\r\n)\r\n\r\nshaderLibrary.setShaderModule(\r\n  'GLSLCADSurfaceFragmentShader.glsl',\r\n  `\r\n\r\nstruct PosNorm {\r\n  vec3 pos;\r\n  vec3 normal;\r\n  int geomType;\r\n};\r\n\r\n/* VS Outputs */\r\nvarying float v_surfaceId;      // flat\r\nvarying vec3 v_geomDataCoords;  // flat\r\nvarying vec2 v_patchSize;       // flat\r\nvarying vec2 v_vertexCoord;\r\n\r\nuniform sampler2D surfaceDataTexture;\r\nuniform ivec2 surfaceDataTextureSize;\r\nuniform int writeNormals;\r\n\r\nvec2 initReader(inout GLSLBinReader reader) {\r\n\r\n  // compute exact xy coords per pixel by rounding the vertex coord to the nearest integer and then dividing my patch size.\r\n  // The interpollated xy coords from the quad are not exact because the quad must cover the pixels with some margin.\r\n\r\n  vec2 params = vec2(floor(v_vertexCoord.x), floor(v_vertexCoord.y));\r\n  if(v_patchSize.x > 1.0)\r\n    params.x /= v_patchSize.x - 1.0;\r\n  if(v_patchSize.y > 1.0)\r\n    params.y /= v_patchSize.y - 1.0;\r\n\r\n  ivec4 region = ivec4(0, 0, surfaceDataTextureSize.x, surfaceDataTextureSize.y);\r\n  ivec2 start = ivec2(v_geomDataCoords.xy);\r\n  int flags = int(v_geomDataCoords.z);\r\n  if(testFlag(flags, SURFACE_FLAG_FLIPPED_UV))  {\r\n    float tmp = params.x;\r\n    params.x = params.y;\r\n    params.y = tmp;\r\n  }\r\n\r\n  GLSLBinReader_init(reader, surfaceDataTextureSize, region, start, 32);\r\n\r\n  return params;\r\n}\r\n\r\n\r\nstruct box2 {\r\n  vec2 p0;\r\n  vec2 p1;\r\n};\r\n\r\nbox2 loadBox2(inout GLSLBinReader reader, sampler2D texture) {\r\n  box2 domain;\r\n  domain.p0.x = GLSLBinReader_readFloat(reader, texture);\r\n  domain.p0.y = GLSLBinReader_readFloat(reader, texture);\r\n  domain.p1.x = GLSLBinReader_readFloat(reader, texture);\r\n  domain.p1.y = GLSLBinReader_readFloat(reader, texture);\r\n  return domain;\r\n}\r\n\r\nvec2 mapDomain(box2 domain, vec2 params) {\r\n  return domain.p0 + params * ( domain.p1 - domain.p0 );\r\n}\r\n\r\n\r\n`\r\n)\r\n\r\n/** Class representing a GL evaluate simple CAD surface shader.\r\n * @extends GLShader\r\n * @ignore\r\n */\r\nclass GLEvaluateSimpleCADSurfaceShader extends GLShader {\r\n  /**\r\n   * Create a GL evaluate simple CAD surface shader.\r\n   * @param {any} gl - The gl value.\r\n   */\r\n  constructor(gl) {\r\n    super(gl)\r\n\r\n    this.__shaderStages['VERTEX_SHADER'] = GLEvaluateCADSurfaceShader_VERTEX_SHADER\r\n\r\n    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(\r\n      'GLEvaluateSimpleCADSurfaceShader.fragmentShader',\r\n      `\r\n// #extension GL_EXT_draw_buffers : require\r\nprecision highp float;\r\n\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n<%include file=\"GLSLBinReader.glsl\"/>\r\n<%include file=\"GLSLCADConstants.glsl\"/>\r\n<%include file=\"GLSLCADSurfaceFragmentShader.glsl\"/>\r\n\r\n<%include file=\"GLSLCADSimpleSurfaces.glsl\"/>\r\n\r\nPosNorm evalCADSurfaces(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\r\n  // Evaluate the surface per vertex\r\n  int geomType = GLSLBinReader_readInt(reader, texture);\r\n\r\n  PosNorm posNorm;\r\n  if(geomType == SURFACE_TYPE_PLANE) {\r\n    posNorm = calcPlaneSurfacePoint(params, reader, texture);\r\n  } else if(geomType == SURFACE_TYPE_POLY_PLANE) {\r\n    posNorm = calcPolyPlaneSurfacePoint(params, reader, texture);\r\n  } else if(geomType == SURFACE_TYPE_FAN) {\r\n    posNorm = calcFanSurfacePoint(params, reader, texture);\r\n  } else if(geomType == SURFACE_TYPE_CONE) {\r\n    posNorm = calcConeSurfacePoint(params, reader, texture);\r\n  } else if(geomType == SURFACE_TYPE_CYLINDER) {\r\n    posNorm = calcCylinderSurfacePoint(params, reader, texture);\r\n  } else if(geomType == SURFACE_TYPE_SPHERE) {\r\n    posNorm = calcSphereSurfacePoint(params, reader, texture);\r\n  } else if(geomType == SURFACE_TYPE_TORUS) {\r\n    posNorm = calcTorusSurfacePoint(params, reader, texture);\r\n  }\r\n  return posNorm;\r\n}\r\n\r\n#ifdef ENABLE_ES3\r\nout vec4 fragColor;\r\n#endif\r\n\r\nvoid main(void) {\r\n\r\n#ifndef ENABLE_ES3\r\n  vec4 fragColor;\r\n#endif\r\n  \r\n  GLSLBinReader reader;\r\n  vec2 xy = initReader(reader);\r\n  PosNorm posNorm = evalCADSurfaces(xy, reader, surfaceDataTexture);\r\n\r\n  if(writeNormals == 1) {\r\n    fragColor = vec4(posNorm.normal, float(posNorm.geomType));\r\n  }\r\n  else {\r\n    fragColor = vec4(posNorm.pos, float(posNorm.geomType));\r\n  }\r\n  // gl_FragData[0] = vec4(posNorm.pos, 1.0);\r\n  // gl_FragData[1] = vec4(posNorm.normal, 1.0);\r\n\r\n  // fragColor.r = v_geomDataCoords.x;\r\n  // fragColor.g = v_geomDataCoords.y;\r\n  // fragColor.r = floor(v_vertexCoord.x);\r\n  // fragColor.g = floor(v_vertexCoord.y);\r\n  // fragColor.b = v_patchSize.x;\r\n  // fragColor.a = v_patchSize.y;\r\n\r\n#ifndef ENABLE_ES3\r\n  gl_FragColor = fragColor;\r\n#endif\r\n}\r\n`\r\n    )\r\n  }\r\n}\r\n\r\n/** Class representing a GL evaluate compound CAD surface shader.\r\n * @extends GLShader\r\n * @ignore\r\n */\r\nclass GLEvaluateCompoundCADSurfaceShader extends GLShader {\r\n  /**\r\n   * Create a GL evaluate compound CAD surface shader.\r\n   * @param {any} gl - The gl value.\r\n   */\r\n  constructor(gl) {\r\n    super(gl)\r\n\r\n    this.__shaderStages['VERTEX_SHADER'] = GLEvaluateCADSurfaceShader_VERTEX_SHADER\r\n\r\n    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(\r\n      'GLEvaluateCompoundCADSurfaceShader.fragmentShader',\r\n      `\r\n// #extension GL_EXT_draw_buffers : require\r\nprecision highp float;\r\n\r\n<%include file=\"GLSLCADConstants.glsl\"/>\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n<%include file=\"GLSLBinReader.glsl\"/>\r\n<%include file=\"GLSLCADSurfaceFragmentShader.glsl\"/>\r\n\r\n<%include file=\"GLSLMath.glsl\"/>\r\n\r\nuniform sampler2D curvesAtlasTexture;\r\nuniform ivec2 curvesAtlasTextureSize;\r\nuniform sampler2D curveTangentsTexture;\r\nuniform sampler2D curvesAtlasLayoutTexture;\r\nuniform ivec2 curvesAtlasLayoutTextureSize;\r\n\r\nvec3 getCurveVertex(ivec2 curvePatchCoords, int vertexCoord) {\r\n  return fetchTexel(curvesAtlasTexture, curvesAtlasTextureSize, ivec2(curvePatchCoords.x + vertexCoord, curvePatchCoords.y)).rgb;\r\n}\r\n\r\nvec3 getCurveTangent(ivec2 curvePatchCoords, int vertexCoord) {\r\n  return fetchTexel(curveTangentsTexture, curvesAtlasTextureSize, ivec2(curvePatchCoords.x + vertexCoord, curvePatchCoords.y)).rgb;\r\n}\r\n\r\nPosNorm evalCADCurve3d(int curveId, float u) {\r\n\r\n  GLSLBinReader curveLayoutDataReader;\r\n  GLSLBinReader_init(curveLayoutDataReader, curvesAtlasLayoutTextureSize, 32);\r\n  ivec4 curvePatch = ivec4(GLSLBinReader_readVec4(curveLayoutDataReader, curvesAtlasLayoutTexture, curveId * 8));\r\n\r\n  float t = float(curvePatch.z - 1) * u;\r\n  int vertexId0 = min(int(floor(t + 0.5)), curvePatch.z - 1);\r\n  // int vertexId1 = floor(t) + 1.0;\r\n  // float lerp = t - floor(t);\r\n\r\n  vec3 p0 = getCurveVertex(curvePatch.xy, vertexId0);\r\n  // vec3 p1 = getCurveVertex(curvePatch.xy, vertexId1);\r\n  vec3 t0 = getCurveTangent(curvePatch.xy, vertexId0);\r\n  // vec3 t1 = getCurveTangent(curvePatch.xy, vertexId1);\r\n\r\n  PosNorm res;\r\n  res.pos = p0;//mix(p0, p1, lerp);\r\n  res.normal = normalize(t0);//mix(t0, t1, lerp));\r\n  res.geomType = 0;\r\n\r\n  // res.pos.x = u;\r\n  // res.pos.y = float(curveId);\r\n  // res.pos.x = float(curvePatch.x);\r\n  // res.pos.y = float(curvePatch.y);\r\n  // res.pos.z = float(curvePatch.z);\r\n  return res;\r\n}\r\n\r\n\r\n<%include file=\"GLSLCADCompoundSurfaces.glsl\"/>\r\n\r\nPosNorm evalCADSurfaces(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\r\n  // Evaluate the surface per vertex\r\n  int geomType = GLSLBinReader_readInt(reader, texture);\r\n\r\n  PosNorm posNorm;\r\n  if(geomType == SURFACE_TYPE_LINEAR_EXTRUSION) {\r\n    posNorm = calcLinearExtrusionSurfacePoint(params, reader, texture);\r\n  } else if(geomType == SURFACE_TYPE_REVOLUTION) {\r\n    posNorm = calcRevolutionSurfacePoint(params, reader, texture, false);\r\n  } else if(geomType == SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN) {\r\n    posNorm = calcRevolutionSurfacePoint(params, reader, texture, true);\r\n  } \r\n  \r\n  return posNorm;\r\n}\r\n\r\n#ifdef ENABLE_ES3\r\nout vec4 fragColor;\r\n#endif\r\n\r\nvoid main(void) {\r\n\r\n#ifndef ENABLE_ES3\r\n  vec4 fragColor;\r\n#endif\r\n  \r\n  GLSLBinReader reader;\r\n  vec2 xy = initReader(reader);\r\n  PosNorm posNorm = evalCADSurfaces(xy, reader, surfaceDataTexture);\r\n\r\n  if(writeNormals == 1) {\r\n    fragColor = vec4(posNorm.normal, float(posNorm.geomType));\r\n  }\r\n  else {\r\n    fragColor = vec4(posNorm.pos, float(posNorm.geomType));\r\n  }\r\n\r\n#ifndef ENABLE_ES3\r\n  gl_FragColor = fragColor;\r\n#endif\r\n}\r\n`\r\n    )\r\n  }\r\n}\r\n\r\n/** Class representing a GL evaluate NURBS CAD surface shader.\r\n * @extends GLShader\r\n * @ignore\r\n */\r\nclass GLEvaluateNURBSCADSurfaceShader extends GLShader {\r\n  /**\r\n   * Create a GL evaluate NURBS CAD surface shader.\r\n   * @param {any} gl - The gl value.\r\n   */\r\n  constructor(gl) {\r\n    super(gl)\r\n\r\n    this.__shaderStages['VERTEX_SHADER'] = GLEvaluateCADSurfaceShader_VERTEX_SHADER\r\n\r\n    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(\r\n      'GLEvaluateNURBSCADSurfaceShader.fragmentShader',\r\n      `\r\n// #extension GL_EXT_draw_buffers : require\r\nprecision highp float;\r\n\r\n<%include file=\"GLSLCADConstants.glsl\"/>\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n<%include file=\"GLSLBinReader.glsl\"/>\r\n<%include file=\"GLSLCADSurfaceFragmentShader.glsl\"/>\r\n\r\n<%include file=\"GLSLNURBS.glsl\"/>\r\n<%include file=\"GLSLNURBSSurfaces.glsl\"/>\r\n\r\nPosNorm evalCADSurfaces(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\r\n  // Evaluate the surface per vertex\r\n  int geomType = GLSLBinReader_readInt(reader, texture);\r\n\r\n  PosNorm posNorm;\r\n  if(geomType == SURFACE_TYPE_NURBS_SURFACE) {\r\n    posNorm = calcNURBSSurfacePoint(params, reader, texture);\r\n  }\r\n  \r\n  return posNorm;\r\n}\r\n\r\n#ifdef ENABLE_ES3\r\nout vec4 fragColor;\r\n#endif\r\n\r\nvoid main(void) {\r\n\r\n#ifndef ENABLE_ES3\r\n  vec4 fragColor;\r\n#endif\r\n  \r\n  GLSLBinReader reader;\r\n  vec2 xy = initReader(reader);\r\n  PosNorm posNorm = evalCADSurfaces(xy, reader, surfaceDataTexture);\r\n\r\n  if(writeNormals == 1) {\r\n    fragColor = vec4(posNorm.normal, float(posNorm.geomType));\r\n  }\r\n  else {\r\n    fragColor = vec4(posNorm.pos, float(posNorm.geomType));\r\n  }\r\n\r\n#ifndef ENABLE_ES3\r\n  gl_FragColor = fragColor;\r\n#endif\r\n}\r\n`\r\n    )\r\n  }\r\n}\r\n\r\nexport { GLEvaluateSimpleCADSurfaceShader, GLEvaluateCompoundCADSurfaceShader, GLEvaluateNURBSCADSurfaceShader }\r\n","import { EventEmitter, GLFbo, GLTexture2D } from '@zeainc/zea-engine'\r\nimport { valuesPerSurfaceLibraryLayoutItem } from './CADConstants.js'\r\nimport { BinReader } from './Math/BinReader.js'\r\n\r\nimport {\r\n  GLEvaluateSimpleCADSurfaceShader,\r\n  GLEvaluateCompoundCADSurfaceShader,\r\n  GLEvaluateNURBSCADSurfaceShader,\r\n} from './GLEvaluateCADSurfaceShader.js'\r\n\r\n/** Class representing a GL surface library.\r\n * @ignore\r\n */\r\nclass GLSurfaceLibrary extends EventEmitter {\r\n  /**\r\n   * Create a GL surface library.\r\n   * @param {any} gl - The gl value.\r\n   * @param {any} cadpassdata - The cadpassdata value.\r\n   * @param {any} surfacesLibrary - The surfacesLibrary value.\r\n   * @param {any} glCurveLibrary - The glCurveLibrary value.\r\n   */\r\n  constructor(gl, cadpassdata, surfacesLibrary, glCurveLibrary, version) {\r\n    super()\r\n    this.__gl = gl\r\n    this.__cadpassdata = cadpassdata\r\n    this.__surfacesLibrary = surfacesLibrary\r\n    this.__glCurveLibrary = glCurveLibrary\r\n    this.cadDataVersion = version\r\n\r\n    const surfacesDataBuffer = this.__surfacesLibrary.getSurfaceBuffer()\r\n    const surfaceTexSize = Math.sqrt(surfacesDataBuffer.byteLength / 8)\r\n\r\n    this.__surfaceDataTexture = new GLTexture2D(gl, {\r\n      format: 'RGBA',\r\n      type: 'HALF_FLOAT',\r\n      width: surfaceTexSize,\r\n      height: surfaceTexSize,\r\n      filter: 'NEAREST',\r\n      wrap: 'CLAMP_TO_EDGE',\r\n      mipMapped: false,\r\n      data: new Uint16Array(surfacesDataBuffer),\r\n    })\r\n\r\n    this.__bindAttr = (location, channels, type, stride, offset, instanced = true) => {\r\n      gl.enableVertexAttribArray(location)\r\n      gl.vertexAttribPointer(location, channels, gl.FLOAT, false, stride, offset)\r\n      if (instanced) gl.vertexAttribDivisor(location, 1) // This makes it instanced\r\n    }\r\n\r\n    this.evaluateSurfaceShaders = []\r\n    this.__surfaceDrawSets = {}\r\n  }\r\n\r\n  // /////////////////////////////////////////////////////////////\r\n  // Surfaces\r\n\r\n  /**\r\n   * The drawSurfaceData method.\r\n   * @return {boolean} - The return value.\r\n   */\r\n  drawSurfaceData() {\r\n    const renderstate = {}\r\n    if (!this.__surfaceDataTexture || !this.__cadpassdata.debugTrimSetsShader.bind(renderstate)) return false\r\n    // this.bindTrimSetAtlas(renderstate);\r\n\r\n    this.__surfaceDataTexture.bindToUniform(renderstate, renderstate.unifs.trimSetAtlasTexture)\r\n    this.__cadpassdata.glplanegeom.bind(renderstate)\r\n    this.__cadpassdata.glplanegeom.draw()\r\n  }\r\n\r\n  /**\r\n   * The evaluateSurfaces method.\r\n   * @param {any} surfacesEvalAttrs - The surfacesEvalAttrs param.\r\n   * @param {any} surfacesAtlasLayout - The surfacesAtlasLayout param.\r\n   * @param {any} surfaceAtlasLayoutTextureSize - The surfaceAtlasLayoutTextureSize param.\r\n   * @param {any} surfacesAtlasTextureDim - The surfacesAtlasTextureDim param.\r\n   * @return {any} - The return value.\r\n   */\r\n  evaluateSurfaces(surfacesEvalAttrs, surfacesAtlasLayout, surfaceAtlasLayoutTextureSize, surfacesAtlasTextureDim) {\r\n    // console.log(\"evaluateSurfaces\");\r\n    const t0 = performance.now()\r\n\r\n    const totalSurfaceCount = surfacesAtlasLayout.length / valuesPerSurfaceLibraryLayoutItem\r\n    if (totalSurfaceCount == 0) return\r\n    const gl = this.__gl\r\n\r\n    {\r\n      this.__surfaceAtlasLayoutTexture = new GLTexture2D(gl, {\r\n        format: 'RGBA',\r\n        type: 'FLOAT',\r\n        width: surfaceAtlasLayoutTextureSize[0],\r\n        height: surfaceAtlasLayoutTextureSize[1],\r\n        filter: 'NEAREST',\r\n        wrap: 'CLAMP_TO_EDGE',\r\n        mipMapped: false,\r\n        data: surfacesAtlasLayout,\r\n      })\r\n    }\r\n\r\n    if (!this.__surfacesAtlasTexture) {\r\n      this.__surfacesAtlasTexture = new GLTexture2D(gl, {\r\n        format: 'RGBA',\r\n        type: 'FLOAT',\r\n        width: surfacesAtlasTextureDim[0],\r\n        height: surfacesAtlasTextureDim[1],\r\n        filter: 'NEAREST',\r\n        wrap: 'CLAMP_TO_EDGE',\r\n        mipMapped: false,\r\n      })\r\n      this.__surfacesFbo = new GLFbo(gl, this.__surfacesAtlasTexture)\r\n      this.__surfacesFbo.setClearColor([0, 0, 0, 0])\r\n      this.__surfacesFbo.bindAndClear()\r\n\r\n      this.__normalsTexture = new GLTexture2D(gl, {\r\n        format: 'RGBA',\r\n        type: 'FLOAT',\r\n        width: surfacesAtlasTextureDim[0],\r\n        height: surfacesAtlasTextureDim[1],\r\n        filter: 'NEAREST',\r\n        wrap: 'CLAMP_TO_EDGE',\r\n        mipMapped: false,\r\n      })\r\n      this.__normalsFbo = new GLFbo(gl, this.__normalsTexture)\r\n      this.__normalsFbo.setClearColor([0, 0, 0, 0])\r\n      this.__normalsFbo.bindAndClear()\r\n    } else if (\r\n      this.__surfacesAtlasTexture.width != surfacesAtlasTextureDim[0] ||\r\n      this.__surfacesAtlasTexture.height != surfacesAtlasTextureDim[1]\r\n    ) {\r\n      // Copy the previous image into a new one, and then destroy the prvious.\r\n      this.__surfacesAtlasTexture.resize(surfacesAtlasTextureDim[0], surfacesAtlasTextureDim[1], true)\r\n      this.__surfacesFbo.resize() // hack to rebind the texture. Refactor the way textures are resized.\r\n    }\r\n\r\n    const renderstate = {}\r\n\r\n    // /////////////////////////////////////////////\r\n    // Precompile shaders.\r\n    const shaderopts = { directives: [...gl.shaderopts.directives] }\r\n\r\n    if (this.cadDataVersion.compare([0, 0, 6]) >= 0) {\r\n      shaderopts.directives.push('#define EXPORT_KNOTS_AS_DELTAS 1')\r\n    }\r\n    if (this.cadDataVersion.compare([0, 0, 26]) > 0) {\r\n      shaderopts.directives.push('#define INTS_PACKED_AS_2FLOAT16 1')\r\n    }\r\n\r\n    surfacesEvalAttrs.forEach((attr, category) => {\r\n      if (!this.evaluateSurfaceShaders[category]) {\r\n        let shader\r\n        switch (category) {\r\n          case 0:\r\n            shader = new GLEvaluateSimpleCADSurfaceShader(gl)\r\n            break\r\n          case 1:\r\n            shader = new GLEvaluateCompoundCADSurfaceShader(gl)\r\n            break\r\n          case 2:\r\n            shader = new GLEvaluateNURBSCADSurfaceShader(gl)\r\n            break\r\n        }\r\n        shader.compileForTarget(undefined, shaderopts)\r\n        this.evaluateSurfaceShaders[category] = shader\r\n      }\r\n      this.evaluateSurfaceShaders[category].bind(renderstate)\r\n      this.__cadpassdata.glplanegeom.bind(renderstate)\r\n\r\n      const unifs = renderstate.unifs\r\n      const attrs = renderstate.attrs\r\n\r\n      this.__surfaceAtlasLayoutTexture.bindToUniform(renderstate, unifs.surfaceAtlasLayoutTexture)\r\n      gl.uniform2i(\r\n        unifs.surfaceAtlasLayoutTextureSize.location,\r\n        this.__surfaceAtlasLayoutTexture.width,\r\n        this.__surfaceAtlasLayoutTexture.height\r\n      )\r\n\r\n      gl.uniform2i(\r\n        unifs.surfacesAtlasTextureSize.location,\r\n        this.__surfacesAtlasTexture.width,\r\n        this.__surfacesAtlasTexture.height\r\n      )\r\n\r\n      this.__surfaceDataTexture.bindToUniform(renderstate, unifs.surfaceDataTexture)\r\n      gl.uniform2i(\r\n        unifs.surfaceDataTextureSize.location,\r\n        this.__surfaceDataTexture.width,\r\n        this.__surfaceDataTexture.height\r\n      )\r\n\r\n      // For the linear and radial loft.\r\n      if (unifs.curveTangentsTexture) this.__glCurveLibrary.bindCurvesAtlas(renderstate)\r\n\r\n      const buffer = gl.createBuffer()\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buffer)\r\n      gl.bufferData(gl.ARRAY_BUFFER, attr, gl.STATIC_DRAW)\r\n\r\n      this.__bindAttr(attrs.surfaceId.location, 1, gl.FLOAT, 4, 0)\r\n\r\n      // //////////////////////////////////////////////\r\n      // Bind each Fbo and render separately.\r\n      // Bizzarly, this has turned out to be much faster\r\n      // than using mutiple render targets...\r\n      this.__surfacesFbo.bind()\r\n      gl.uniform1i(unifs.writeNormals.location, 0)\r\n      this.__cadpassdata.glplanegeom.drawInstanced(attr.length)\r\n\r\n      this.__normalsFbo.bind()\r\n      gl.uniform1i(unifs.writeNormals.location, 1)\r\n      this.__cadpassdata.glplanegeom.drawInstanced(attr.length)\r\n      // //////////////////////////////////////////////\r\n\r\n      gl.deleteBuffer(buffer)\r\n    })\r\n    this.__surfacesFbo.unbind()\r\n\r\n    this.__surfacesAtlasLayout = surfacesAtlasLayout\r\n    // console.log(\"----------------------------------\");\r\n    // // console.log(surfacesAtlasLayout);\r\n    const logSurfaceData = (surfaceId) => {\r\n      this.__surfacesFbo.bindForReading()\r\n      const layout = [\r\n        surfacesAtlasLayout[surfaceId * valuesPerSurfaceLibraryLayoutItem + 0],\r\n        surfacesAtlasLayout[surfaceId * valuesPerSurfaceLibraryLayoutItem + 1],\r\n        surfacesAtlasLayout[surfaceId * valuesPerSurfaceLibraryLayoutItem + 2],\r\n        surfacesAtlasLayout[surfaceId * valuesPerSurfaceLibraryLayoutItem + 3],\r\n      ]\r\n      console.log('----------------------------------')\r\n      console.log(\r\n        'logSurfaceData ' + surfaceId + ':[' + layout[0] + ',' + layout[1] + ']:' + layout[2] + 'x' + layout[3]\r\n      )\r\n      const pixels = new Float32Array(layout[2] * 4)\r\n      for (let i = 0; i < layout[3]; i++) {\r\n        gl.readPixels(layout[0], layout[1] + i, layout[2], 1, gl.RGBA, gl.FLOAT, pixels)\r\n        for (let j = 0; j < layout[2]; j++) {\r\n          console.log(i, j, ':', pixels[j * 4 + 0], pixels[j * 4 + 1], pixels[j * 4 + 2], pixels[j * 4 + 3])\r\n          break\r\n        }\r\n        // console.log(i+\":\" + pixels);\r\n      }\r\n    }\r\n    // logSurfaceData(9628)\r\n    // console.log(\"----------------------------------\");\r\n\r\n    const t = performance.now() - t0\r\n    // console.log(\"evaluateSurfaces - Done:\", t);\r\n\r\n    return t\r\n  }\r\n\r\n  /**\r\n   * The logSurfaceData method.\r\n   * @param {any} surfaceId - The surfaceId param.\r\n   */\r\n  logSurfaceData(surfaceId) {\r\n    // const layout = [\r\n    //   this.__surfacesAtlasLayout[(surfaceId * valuesPerSurfaceLibraryLayoutItem) + 0],\r\n    //   this.__surfacesAtlasLayout[(surfaceId * valuesPerSurfaceLibraryLayoutItem) + 1],\r\n    //   this.__surfacesAtlasLayout[(surfaceId * valuesPerSurfaceLibraryLayoutItem) + 2],\r\n    //   this.__surfacesAtlasLayout[(surfaceId * valuesPerSurfaceLibraryLayoutItem) + 3]];\r\n\r\n    // console.log(\"logGeomData \" + surfaceId + \":[\" + layout[0] +\",\"+ layout[1] + \"] detail :\" + layout[2] +\"x\"+ layout[3]);\r\n\r\n    const surfacesDataBuffer = this.__surfacesLibrary.getSurfaceBuffer()\r\n    const surfacesDataReader = new BinReader(surfacesDataBuffer)\r\n    surfacesDataReader.seek(8 + surfaceId * (8 /* num values per item*/ * 2) /* bpc*/ + 2 /* addr*/ * 2 /* bpc*/)\r\n\r\n    const detailU = surfacesDataReader.loadFloat16()\r\n    const detailV = surfacesDataReader.loadFloat16()\r\n    const sizeU = surfacesDataReader.loadFloat16()\r\n    const sizeV = surfacesDataReader.loadFloat16()\r\n    const trimSetIndex = surfacesDataReader.loadFloat16()\r\n    console.log(\r\n      'logGeomData ' +\r\n        surfaceId +\r\n        ' detailU:[' +\r\n        detailU +\r\n        ',' +\r\n        detailV +\r\n        '] sizeU [' +\r\n        sizeU +\r\n        ',' +\r\n        sizeV +\r\n        '] trimSetIndex:' +\r\n        trimSetIndex\r\n    )\r\n  }\r\n\r\n  /**\r\n   * The drawSurfaceAtlas method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @return {boolean} - The return value.\r\n   */\r\n  drawSurfaceAtlas(renderstate) {\r\n    if (!this.__normalsTexture || !this.__cadpassdata.debugTrimSetsShader.bind(renderstate)) return false\r\n    // this.bindTrimSetAtlas(renderstate);\r\n\r\n    this.__normalsTexture.bindToUniform(renderstate, renderstate.unifs.trimSetAtlasTexture)\r\n    this.__cadpassdata.glplanegeom.bind(renderstate)\r\n    this.__cadpassdata.glplanegeom.draw()\r\n  }\r\n\r\n  /**\r\n   * The bindSurfacesData method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   */\r\n  bindSurfacesData(renderstate) {\r\n    const gl = this.__gl\r\n    const unifs = renderstate.unifs\r\n    this.__surfaceDataTexture.bindToUniform(renderstate, unifs.surfaceDataTexture)\r\n    gl.uniform2i(\r\n      unifs.surfaceDataTextureSize.location,\r\n      this.__surfaceDataTexture.width,\r\n      this.__surfaceDataTexture.height\r\n    )\r\n  }\r\n\r\n  /**\r\n   * The bindSurfacesAtlas method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @return {boolean} - returns true if the atlass was bound.\r\n   */\r\n  bindSurfacesAtlas(renderstate) {\r\n    if (!this.__surfacesAtlasTexture) return false\r\n    const unifs = renderstate.unifs\r\n    this.__surfacesAtlasTexture.bindToUniform(renderstate, unifs.surfacesAtlasTexture)\r\n    const gl = this.__gl\r\n    if (unifs.normalsTexture) this.__normalsTexture.bindToUniform(renderstate, unifs.normalsTexture)\r\n    if (unifs.surfacesAtlasTextureSize)\r\n      gl.uniform2i(\r\n        unifs.surfacesAtlasTextureSize.location,\r\n        this.__surfacesAtlasTexture.width,\r\n        this.__surfacesAtlasTexture.height\r\n      )\r\n\r\n    if (unifs.numSurfacesInLibrary) {\r\n      gl.uniform1i(unifs.numSurfacesInLibrary.location, this.__surfacesLibrary.getNumSurfaces())\r\n    }\r\n\r\n    if (unifs.surfaceAtlasLayoutTexture) {\r\n      this.__surfaceAtlasLayoutTexture.bindToUniform(renderstate, unifs.surfaceAtlasLayoutTexture)\r\n      gl.uniform2i(\r\n        unifs.surfaceAtlasLayoutTextureSize.location,\r\n        this.__surfaceAtlasLayoutTexture.width,\r\n        this.__surfaceAtlasLayoutTexture.height\r\n      )\r\n    }\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * The getSurfaceData method.\r\n   * @param {any} surfaceId - The surfaceId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getSurfaceData(surfaceId) {\r\n    return this.__surfacesLibrary.getSurfaceData(surfaceId)\r\n  }\r\n\r\n  /**\r\n   * The destroy method.\r\n   */\r\n  destroy() {\r\n    this.__surfaceDataTexture.destroy()\r\n    if (this.__surfacesAtlasTexture) {\r\n      this.__surfacesAtlasTexture.destroy()\r\n      this.__normalsTexture.destroy()\r\n      this.__surfacesFbo.destroy()\r\n      this.__normalsFbo.destroy()\r\n    }\r\n  }\r\n}\r\n\r\nexport { GLSurfaceLibrary }\r\n","import { Float32, Plane, Mesh, GLMesh } from '@zeainc/zea-engine'\r\n\r\nimport { numValuesPerTrimSetCurveRef } from './CADConstants.js'\r\n\r\n/** This class abstracts the rendering of a collection of geometries to screen.\r\n * @extends Mesh\r\n * @ignore\r\n */\r\nclass Fan extends Mesh {\r\n  /**\r\n   * Create a fan.\r\n   * @param {number} detail - The detail value.\r\n   */\r\n  constructor(detail = 1) {\r\n    super()\r\n    this.__detail = detail\r\n    this.addVertexAttribute('vertexIds', Float32)\r\n    this.__rebuild()\r\n  }\r\n\r\n  /**\r\n   * The __rebuild method.\r\n   * @private\r\n   */\r\n  __rebuild() {\r\n    this.setNumVertices(this.__detail + 2)\r\n    this.setFaceCounts([this.__detail])\r\n\r\n    for (let i = 0; i < this.__detail; i++) {\r\n      this.setFaceVertexIndices(i, [0, i + 1, i + 2])\r\n    }\r\n    const vertexIds = this.getVertexAttribute('vertexIds')\r\n    for (let i = 0; i <= vertexIds.length; i++) {\r\n      vertexIds.setFloat32Value(i, i)\r\n    }\r\n  }\r\n}\r\n\r\n/** Class representing a strip.\r\n * @extends Plane\r\n * @ignore\r\n */\r\nclass Strip extends Plane {\r\n  /**\r\n   * Create a strip.\r\n   * @param {number} detail - The detail value.\r\n   */\r\n  constructor(detail = 1) {\r\n    super(1, 2, detail, 1, false, false)\r\n  }\r\n\r\n  /**\r\n   * The __resize method.\r\n   * @private\r\n   */\r\n  __resize() {\r\n    const sizeX = this.__sizeXParam.getValue()\r\n    const sizeY = this.__sizeYParam.getValue()\r\n    const detailX = this.__detailXParam.getValue()\r\n    const detailY = this.__detailYParam.getValue()\r\n    const positions = this.getVertexAttribute('positions')\r\n    let voff = 0\r\n    for (let i = 0; i <= detailY; i++) {\r\n      const y = (i / detailY - 0.5) * sizeY\r\n      for (let j = 0; j <= detailX; j++) {\r\n        const x = j\r\n        positions.getValueRef(voff).set(x, y, 0.0)\r\n        voff++\r\n      }\r\n    }\r\n    this.setBoundingBoxDirty()\r\n  }\r\n}\r\n\r\nconst __cache = {}\r\n\r\n/** Class representing a GL trim curve draw set.\r\n * @ignore\r\n */\r\nclass GLTrimCurveDrawSet {\r\n  /**\r\n   * Create a GL trim curve draw set.\r\n   * @param {any} gl - The gl value.\r\n   * @param {any} detail - The detail value.\r\n   * @param {any} trimCurvesDataArray - The trimCurvesDataArray value.\r\n   */\r\n  constructor(gl, detail, trimCurvesDataArray) {\r\n    this.__gl = gl\r\n    this.__detail = detail\r\n\r\n    if (!__cache[detail]) {\r\n      __cache[detail] = {\r\n        glfangeom: new GLMesh(gl, new Fan(detail)),\r\n        glstripgeom: new GLMesh(gl, new Strip(detail)),\r\n      }\r\n    }\r\n    this.__glfangeom = __cache[detail].glfangeom\r\n    this.__glstripgeom = __cache[detail].glstripgeom\r\n\r\n    this.__buffer = gl.createBuffer()\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.__buffer)\r\n    gl.bufferData(gl.ARRAY_BUFFER, trimCurvesDataArray, gl.STATIC_DRAW)\r\n\r\n    this.__drawCount = trimCurvesDataArray.length / numValuesPerTrimSetCurveRef\r\n  }\r\n\r\n  /**\r\n   * The bindAttr method.\r\n   * @param {any} location - The location param.\r\n   * @param {any} channels - The channels param.\r\n   * @param {any} type - The type param.\r\n   * @param {any} stride - The stride param.\r\n   * @param {any} offset - The offset param.\r\n   */\r\n  bindAttr(location, channels, type, stride, offset) {\r\n    if (location < 0) return\r\n    const gl = this.__gl\r\n    gl.enableVertexAttribArray(location)\r\n    gl.vertexAttribPointer(location, channels, gl.FLOAT, false, stride, offset)\r\n    gl.vertexAttribDivisor(location, 1) // This makes it instanced\r\n  }\r\n\r\n  // ////////////////////////////////////\r\n  // Drawing\r\n\r\n  /**\r\n   * The setBuffer method.\r\n   */\r\n  setBuffer() {}\r\n\r\n  /**\r\n   * The drawFans method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   */\r\n  drawFans(renderstate) {\r\n    const gl = this.__gl\r\n\r\n    this.__glfangeom.bind(renderstate)\r\n\r\n    const unifs = renderstate.unifs\r\n    const attrs = renderstate.attrs\r\n\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.__buffer)\r\n    this.bindAttr(attrs.patchCoords.location, 4, gl.FLOAT, numValuesPerTrimSetCurveRef * 4, 0)\r\n    this.bindAttr(attrs.data0.location, 4, gl.FLOAT, numValuesPerTrimSetCurveRef * 4, 4 * 4)\r\n    this.bindAttr(attrs.data1.location, 4, gl.FLOAT, numValuesPerTrimSetCurveRef * 4, 4 * 8)\r\n    this.bindAttr(attrs.data2.location, 2, gl.FLOAT, numValuesPerTrimSetCurveRef * 4, 4 * 12)\r\n\r\n    gl.uniform1i(unifs.numCurveVertices.location, this.__detail + 1)\r\n\r\n    this.__glfangeom.drawInstanced(this.__drawCount)\r\n  }\r\n\r\n  /**\r\n   * The drawStrips method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   */\r\n  drawStrips(renderstate) {\r\n    const gl = this.__gl\r\n\r\n    this.__glstripgeom.bind(renderstate)\r\n\r\n    const unifs = renderstate.unifs\r\n    const attrs = renderstate.attrs\r\n\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.__buffer)\r\n    this.bindAttr(attrs.patchCoords.location, 4, gl.FLOAT, numValuesPerTrimSetCurveRef * 4, 0)\r\n    this.bindAttr(attrs.data0.location, 4, gl.FLOAT, numValuesPerTrimSetCurveRef * 4, 4 * 4)\r\n    this.bindAttr(attrs.data1.location, 4, gl.FLOAT, numValuesPerTrimSetCurveRef * 4, 4 * 8)\r\n    this.bindAttr(attrs.data2.location, 2, gl.FLOAT, numValuesPerTrimSetCurveRef * 4, 4 * 12)\r\n\r\n    gl.uniform1i(unifs.numCurveVertices.location, this.__detail + 1)\r\n\r\n    this.__glstripgeom.drawInstanced(this.__drawCount)\r\n  }\r\n\r\n  /**\r\n   * The cleanup method.\r\n   */\r\n  cleanup() {\r\n    // this.__gl.deleteBuffer(this.__buffer);\r\n  }\r\n}\r\n\r\nexport { GLTrimCurveDrawSet }\r\n","/* eslint-disable camelcase */\r\nimport { GLShader, shaderLibrary, Registry } from '@zeainc/zea-engine'\r\n\r\n/** Class representing a GL draw trim curve fans shader.\r\n * @extends GLShader\r\n * @ignore\r\n */\r\nclass GLDrawTrimCurveFansShader extends GLShader {\r\n  /**\r\n   * Create a GL draw trim curve fans shader.\r\n   * @param {any} gl - The gl value.\r\n   */\r\n  constructor(gl) {\r\n    super(gl)\r\n\r\n    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(\r\n      'GLDrawTrimCurveFansShader.vertexShader',\r\n      `\r\nprecision highp float;\r\n\r\nattribute float vertexIds;\r\ninstancedattribute vec4 patchCoords;         // instanced attribute..\r\ninstancedattribute vec4 data0;     // instanced attribute..\r\ninstancedattribute vec4 data1;     // instanced attribute..\r\ninstancedattribute vec2 data2;     // instanced attribute..\r\n\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n<%include file=\"GLSLMath.glsl\"/>\r\n\r\nuniform sampler2D curvesAtlasTexture;\r\nuniform ivec2 curvesAtlasTextureSize;\r\n\r\nuniform ivec2 trimSetAtlasTextureSize;\r\n\r\nuniform int numCurveVertices;\r\n\r\nstruct CurveRef {\r\n  int curveId;\r\n  vec2 tr;\r\n  mat2 mat;\r\n  int flags;\r\n\r\n  ivec2 addr;\r\n  int numCurveVertices;\r\n\r\n};\r\n\r\nvec2 getCurveVertex(in CurveRef curveRef, int vertexId) {\r\n    if(curveRef.flags != 0)\r\n      vertexId = curveRef.numCurveVertices - vertexId - 1;\r\n    return curveRef.tr + curveRef.mat * fetchTexel(curvesAtlasTexture, curvesAtlasTextureSize, ivec2(curveRef.addr.x + vertexId, curveRef.addr.y)).rg;\r\n}\r\n\r\n\r\nuniform sampler2D curvesAtlasLayoutTexture;\r\nuniform ivec2 curvesAtlasLayoutTextureSize;\r\n\r\nuniform sampler2D trimSetTexture;\r\nuniform ivec2 trimSetTextureSize;\r\n\r\n\r\n<%include file=\"GLSLBinReader.glsl\"/>\r\n\r\nCurveRef getCurveRef(inout GLSLBinReader trimsetDataReader, in int curveRefStart, inout GLSLBinReader curvesAtlasLayoutDataReader) {\r\n\r\n  CurveRef curveRef;\r\n\r\n  // Get the Curve Id from the trimSet Atlas\r\n  curveRef.curveId = GLSLBinReader_readInt(trimsetDataReader, trimSetTexture, curveRefStart + 0);\r\n\r\n  // Get the Xfo for the curve\r\n  curveRef.tr = vec2(\r\n    GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 1), \r\n    GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 2)\r\n    );\r\n  curveRef.mat = mat2(\r\n    vec2(\r\n      GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 3), \r\n      GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 4)\r\n    ),\r\n    vec2(\r\n      GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 5), \r\n      GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 6)\r\n    ));\r\n\r\n  // Get the flags for the curve\r\n  curveRef.flags = GLSLBinReader_readInt(trimsetDataReader, trimSetTexture, curveRefStart + 7);\r\n\r\n\r\n  curveRef.addr = ivec2(\r\n    GLSLBinReader_readInt(curvesAtlasLayoutDataReader, curvesAtlasLayoutTexture, (curveRef.curveId * 8) + 0), \r\n    GLSLBinReader_readInt(curvesAtlasLayoutDataReader, curvesAtlasLayoutTexture, (curveRef.curveId * 8) + 1)\r\n    );\r\n  curveRef.numCurveVertices = GLSLBinReader_readInt(curvesAtlasLayoutDataReader, curvesAtlasLayoutTexture, (curveRef.curveId * 8) + 2);\r\n\r\n  return curveRef;\r\n}\r\n\r\n\r\n\r\nvoid main(void) {\r\n\r\n  vec2 pos;\r\n  int vertexId = ftoi(vertexIds);\r\n  if(vertexId == 0) {\r\n    pos = (patchCoords.xy + patchCoords.zw * 0.5) / vec2(trimSetAtlasTextureSize);\r\n  }\r\n  else {\r\n    vertexId--;\r\n\r\n    CurveRef curveRef;\r\n    curveRef.tr = data0.xy;\r\n    curveRef.mat = mat2(data0.zw, data1.xy);\r\n    curveRef.flags = ftoi(data2.x);\r\n\r\n    curveRef.addr = ivec2(ftoi(data1.z), ftoi(data1.w));\r\n    curveRef.numCurveVertices = numCurveVertices;\r\n\r\n    //////////////////////////////////////////////\r\n    pos = getCurveVertex(curveRef, vertexId);\r\n\r\n    /*\r\n    //////////////////////////////////////////////\r\n    \r\n    int loopStartPos = ftoi(data0.x);\r\n    int curveIndexWithLoop = ftoi(data0.y);\r\n\r\n    GLSLBinReader trimsetDataReader;\r\n    GLSLBinReader_init(trimsetDataReader, trimSetTextureSize, 16);\r\n    int numCurves = GLSLBinReader_readInt(trimsetDataReader, trimSetTexture, loopStartPos);\r\n\r\n    GLSLBinReader curvesAtlasLayoutDataReader;\r\n    GLSLBinReader_init(curvesAtlasLayoutDataReader, curvesAtlasLayoutTextureSize, 32);\r\n\r\n    CurveRef curveRef = getCurveRef(trimsetDataReader, loopStartPos + 1 + (curveIndexWithLoop * 8), curvesAtlasLayoutDataReader);\r\n    pos = getCurveVertex( curveRef, vertexId );\r\n\r\n\r\n    // Tranform the curve points by the xfo2d to put it into the coords of the trim set.\r\n    Xfo2d xfo2d = Xfo2d(data0.xy, data1.x, data0.zw);\r\n    pos = Xfo2D_transformVec2(xfo2d, pos);\r\n\r\n\r\n    //////////////////////////////////\r\n    // Due to the reduced precision we use to store our data\r\n    // we get cracks in the trim textures. To fix this we weld\r\n    // the end points of the trim curves here.\r\n    // For each end point of a curve, we find the joining end point \r\n    // and average their positions.\r\n\r\n    if(vertexId == 0) {\r\n      // Lookup the vertex of the previous curve.\r\n      int prevCurveIndexWithinLoop = curveIndexWithLoop - 1;\r\n      if(prevCurveIndexWithinLoop < 0)\r\n        prevCurveIndexWithinLoop += numCurves;\r\n      CurveRef prevCurveRef = getCurveRef(trimsetDataReader, loopStartPos + 1 + (prevCurveIndexWithinLoop * 8), curvesAtlasLayoutDataReader);\r\n\r\n      // Get the end of the previous curve.\r\n      vec2 prevCurveEndPos = getCurveVertex( prevCurveRef, prevCurveRef.numCurveVertices-1 );\r\n\r\n      pos = (pos + prevCurveEndPos) * 0.5;\r\n    }\r\n    else if(vertexId == numCurveVertices-1) {\r\n      // Lookup the vertex of the next curve.\r\n      int nextCurveIndexWithinLoop = curveIndexWithLoop + 1;\r\n      if(nextCurveIndexWithinLoop >= numCurves)\r\n        nextCurveIndexWithinLoop = 0;\r\n      CurveRef nextCurveRef = getCurveRef(trimsetDataReader, loopStartPos + 1 + (nextCurveIndexWithinLoop * 8), curvesAtlasLayoutDataReader);\r\n\r\n      // Get the start of the next curve.\r\n      vec2 nextCurveEndPos = getCurveVertex( nextCurveRef, 0 );\r\n      pos = (pos + nextCurveEndPos) * 0.5;\r\n    }\r\n\r\n    */\r\n    //////////////////////////////////////////////\r\n\r\n\r\n    // Now transform the trim set into the coords of the full texture.\r\n    pos = (patchCoords.xy + (pos * patchCoords.zw));\r\n    pos /= vec2(trimSetAtlasTextureSize);\r\n  }\r\n\r\n  // transform the position into clip space.\r\n  gl_Position = vec4(vec2(-1.0, -1.0) + (pos * 2.0), 0.0, 1.0);\r\n}\r\n`\r\n    )\r\n\r\n    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(\r\n      'GLDrawTrimCurveFansShader.fragmentShader',\r\n      `\r\nprecision highp float;\r\n\r\n#ifdef ENABLE_ES3\r\nout vec4 fragColor;\r\n#endif\r\n\r\nvoid main(void) {\r\n\r\n#ifndef ENABLE_ES3\r\n    vec4 fragColor;\r\n#endif\r\n\r\n    fragColor = vec4(1.0/255.0,0.0,0.0,1.0);\r\n    \r\n#ifndef ENABLE_ES3\r\n    gl_FragColor = fragColor;\r\n#endif\r\n}\r\n`\r\n    )\r\n  }\r\n}\r\n\r\nRegistry.register('GLDrawTrimCurveFansShader', GLDrawTrimCurveFansShader)\r\n\r\nexport { GLDrawTrimCurveFansShader }\r\n","/* eslint-disable camelcase */\r\nimport { GLShader, shaderLibrary, Registry } from '@zeainc/zea-engine'\r\n\r\n/** Class representing a GL flatten trim sets shader.\r\n * @extends GLShader\r\n * @ignore\r\n */\r\nclass GLFlattenTrimSetsShader extends GLShader {\r\n  /**\r\n   * Create a GL flatten trim sets shader.\r\n   * @param {any} gl - The gl value.\r\n   */\r\n  constructor(gl) {\r\n    super(gl)\r\n\r\n    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(\r\n      'GLFlattenTrimSetsShader.vertexShader',\r\n      `\r\nprecision highp float;\r\n\r\nattribute vec4 positions;\r\n\r\n/* VS Outputs */\r\nvarying vec2 v_texCoord;\r\n \r\nvoid main()\r\n{\r\n    v_texCoord = (positions.xy + 0.5);\r\n    gl_Position =  vec4(positions.xy * 2.0, 0.0, 1.0);\r\n}\r\n`\r\n    )\r\n\r\n    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(\r\n      'GLFlattenTrimSetsShader.fragmentShader',\r\n      `\r\nprecision highp float;\r\n\r\nuniform sampler2D trimSetAtlasTexture;\r\nuniform ivec2 trimSetAtlasTextureSize;\r\n\r\n\r\n/* VS Outputs */\r\nvarying vec2 v_texCoord;\r\n\r\n// returns true if the texel will be kept\r\n// When the fans are rendered, the pixels are acumulated. \r\n// An even number means that the pixel should be discarded\r\n// and an odd number mean the pixel should be kept.\r\nbool sampleAtlas(vec2 offset){\r\n    return mod(texture2D(trimSetAtlasTexture, v_texCoord + (offset / vec2(trimSetAtlasTextureSize))).r * 255.0, 2.0) > 0.5;\r\n}\r\n\r\nint scoreAtlas(vec2 offset){\r\n  if(sampleAtlas(offset))\r\n    return 1;\r\n  else\r\n    return 0;\r\n}\r\n\r\n#ifdef ENABLE_ES3\r\nout vec4 fragColor;\r\n#endif\r\n\r\nvoid main(void) {\r\n\r\n#ifndef ENABLE_ES3\r\n    vec4 fragColor;\r\n#endif\r\n\r\n  // if(sampleAtlas(vec2(0.0, 0.0))){\r\n  //   fragColor = vec4(1.0, 0.5, 0.5, 1.0);\r\n  // }\r\n  // else{\r\n  //   fragColor = vec4(0.0, 0.5, 0.5, 1.0);\r\n  // }\r\n  \r\n  // Smoothing. Look at neighboring pixels to see\r\n  // if we should fill in the gaps. Due to floating\r\n  // point issues, we see random pixels floating\r\n  // in the air that shold have been trimmed by the\r\n  // fan. If a point \r\n  int score = scoreAtlas(vec2(-1.0, 0.0)) + \r\n              scoreAtlas(vec2(-1.0,-1.0)) + \r\n              scoreAtlas(vec2( 0.0,-1.0)) + \r\n              scoreAtlas(vec2( 1.0,-1.0)) + \r\n              scoreAtlas(vec2( 1.0, 0.0)) + \r\n              scoreAtlas(vec2( 1.0, 1.0)) + \r\n              scoreAtlas(vec2( 0.0, 1.0)) + \r\n              scoreAtlas(vec2(-1.0, 1.0));\r\n\r\n  float r = 0.0;\r\n  if(sampleAtlas(vec2(0.0, 0.0))){\r\n    if(score >= 4) // corner verts have a score of 3\r\n      r = 1.0;\r\n    else\r\n      r = 0.0;\r\n  }\r\n  else{\r\n    if(score < 4) \r\n      r = 0.0;\r\n    else\r\n      r = 1.0;\r\n  }\r\n  fragColor = vec4(r, r, 0.0, 0.0);\r\n  \r\n#ifndef ENABLE_ES3\r\n    gl_FragColor = fragColor;\r\n#endif\r\n}\r\n`\r\n    )\r\n  }\r\n}\r\n\r\nRegistry.register('GLFlattenTrimSetsShader', GLFlattenTrimSetsShader)\r\n\r\nexport { GLFlattenTrimSetsShader }\r\n","/* eslint-disable camelcase */\r\nimport { GLShader, shaderLibrary, Registry } from '@zeainc/zea-engine'\r\n\r\n/** Class representing a GL draw trim curve strips shader.\r\n * @extends GLShader\r\n * @ignore\r\n */\r\nclass GLDrawTrimCurveStripsShader extends GLShader {\r\n  /**\r\n   * Create a GL draw trim curve strips shader.\r\n   * @param {any} gl - The gl value.\r\n   */\r\n  constructor(gl) {\r\n    super(gl)\r\n\r\n    this.__shaderStages['VERTEX_SHADER'] = shaderLibrary.parseShader(\r\n      'GLDrawTrimCurveStripsShader.vertexShader',\r\n      `\r\nprecision highp float;\r\n\r\nattribute vec4 positions;\r\ninstancedattribute vec4 patchCoords;         // instanced attribute..\r\ninstancedattribute vec4 data0;     // instanced attribute..\r\ninstancedattribute vec4 data1;     // instanced attribute..\r\ninstancedattribute vec3 data2;     // instanced attribute..\r\n\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n<%include file=\"GLSLMath.glsl\"/>\r\n\r\nuniform sampler2D curvesAtlasTexture;\r\nuniform ivec2 trimSetAtlasTextureSize;\r\n\r\nuniform int numCurveVertices;\r\nuniform float stripWidth;\r\n\r\nvec2 getCurveVertex(int vertexId, int flags) {\r\n  if(flags != 0)\r\n    vertexId = numCurveVertices - vertexId - 1;\r\n  return fetchTexel(curvesAtlasTexture, trimSetAtlasTextureSize, ivec2(int(data1.z) + vertexId, int(data1.w))).rg;\r\n}\r\n\r\n#define M_PI 3.1415926535897932384626433832795\r\n\r\n/* VS Outputs */\r\nvarying float v_curveIndexWithinLoop;\r\nvarying float v_gradient;\r\n\r\nvoid main(void) {\r\n\r\n  int vertexId = ftoi(positions.x);\r\n  float side = positions.y < 0.0 ? -1.0 : 1.0;\r\n  mat2 rot = mat2(data0.zw, data1.xy);\r\n  int curveRefFlags = ftoi(data2.x);\r\n  int curveIndexWithinLoop = ftoi(data2.y);\r\n  v_curveIndexWithinLoop = float(curveIndexWithinLoop);\r\n\r\n  // Tranform the curve points by the mat2 to put it into the coords of the trim set.\r\n  vec2 pos = data0.xy + (rot * getCurveVertex(vertexId, curveRefFlags));\r\n\r\n  //////////////////////////////////////////////\r\n  vec2 curveTangent;\r\n  if(vertexId > 0) {\r\n    vec2 posPrev = data0.xy + (rot * getCurveVertex(vertexId-1, curveRefFlags));\r\n    curveTangent += pos - posPrev;\r\n  }\r\n  if(vertexId < numCurveVertices-1) {\r\n    vec2 posNext = data0.xy + (rot * getCurveVertex(vertexId+1, curveRefFlags));\r\n    curveTangent += posNext - pos;\r\n  }\r\n  curveTangent = normalize(curveTangent);\r\n  vec2 curveNormal = vec2(-curveTangent.y, curveTangent.x);\r\n\r\n  // Fatten the strip\r\n  pos += (curveNormal * side * stripWidth) / patchCoords.zw;\r\n\r\n  //////////////////////////////////////////////\r\n  // Extend the strip by one pixel at each end.\r\n  if(vertexId == 0) {\r\n    pos -= curveTangent * (stripWidth / patchCoords.zw) * 0.5;\r\n  }\r\n  else if(vertexId == numCurveVertices-1) {\r\n    pos += curveTangent * (stripWidth / patchCoords.zw) * 0.5;\r\n  }\r\n  //////////////////////////////////////////////\r\n\r\n  // Now transform the trim set into the coords of the full texture.\r\n  pos = (patchCoords.xy + (pos * patchCoords.zw));\r\n  pos /= vec2(trimSetAtlasTextureSize);\r\n\r\n  // transform the position into clip space.\r\n  gl_Position = vec4((pos * 2.0) - 1.0, 0.0, 1.0);\r\n  \r\n\r\n  // The gradient should run 0.0 ... 1.0 from one side of the strip to the other.\r\n  // The side value ranges from -1.0 to +1.0\r\n\r\n  v_gradient = (side + 1.0) / 2.0;\r\n  // v_gradient = 1.0;\r\n\r\n  // Note: this causes the trim edge to move slightly to grow.\r\n  // This fills in slight gaps betwen trimmed surfaces.\r\n  // This causes lots of atrifacts on some thin surfaces\r\n  // On Mordacious, this causese many artifacts at the border of surfaces.\r\n  // v_gradient = (v_gradient * 1.1) + 0.05;\r\n  // v_gradient = (v_gradient * 1.2) + 0.1;\r\n  // v_gradient = (v_gradient * 1.5) + 0.25;\r\n  // v_gradient = (v_gradient * 2.0) + 0.5;\r\n  // v_gradient = (v_gradient * 2.0) + 1.0;\r\n}\r\n`\r\n    )\r\n\r\n    this.__shaderStages['FRAGMENT_SHADER'] = shaderLibrary.parseShader(\r\n      'GLDrawTrimCurveStripsShader.fragmentShader',\r\n      `\r\nprecision highp float;\r\n\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n\r\nuniform int flatten;\r\n\r\n/* VS Outputs */\r\nvarying float v_curveIndexWithinLoop;\r\nvarying float v_gradient;\r\n\r\n#ifdef ENABLE_ES3\r\nout vec4 fragColor;\r\n#endif\r\n\r\nvoid main(void) {\r\n\r\n#ifndef ENABLE_ES3\r\n  vec4 fragColor;\r\n#endif\r\n\r\n  // Initially a build up the data around the edges by rasterizing a full color pixel,\r\n  // followed by a subtractive pass that cuts down the borders\r\n  //\r\n  // Initially, after the fans are rasterized \r\n  //     ----\r\n  //  .  |  .\r\n  //  .  |  .\r\n  //     ----\r\n  //\r\n  // Becomes \r\n  //  -------\r\n  //  .     .\r\n  //  .     .\r\n  //  -------\r\n  //\r\n  // Becomes \r\n  //    . ---\r\n  //    ./     \r\n  //   /. \r\n  //  -------\r\n  // After the subtraction pass\r\n\r\n\r\n  \r\n  if (flatten > 0) {\r\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\r\n  } else {\r\n    int curveIndexWithinLoop = ftoi(v_curveIndexWithinLoop);\r\n    if (curveIndexWithinLoop % 2 == 0) {\r\n      fragColor = vec4(v_gradient, 1.0, 1.0, 1.0);\r\n    }\r\n    else {\r\n      fragColor = vec4(1.0, v_gradient, 1.0, 1.0);\r\n    }\r\n  }\r\n    \r\n#ifndef ENABLE_ES3\r\n  gl_FragColor = fragColor;\r\n#endif\r\n}\r\n`\r\n    )\r\n  }\r\n}\r\n\r\nRegistry.register('GLDrawTrimCurveStripsShader', GLDrawTrimCurveStripsShader)\r\n\r\nexport { GLDrawTrimCurveStripsShader }\r\n","/* eslint-disable camelcase */\r\nimport { GLShader } from '@zeainc/zea-engine'\r\n\r\n/** Class representing a GL debug trim sets shader.\r\n * @extends GLShader\r\n * @ignore\r\n */\r\nclass GLDebugTrimSetsShader extends GLShader {\r\n  /**\r\n   * Create a GL debug trim sets shader.\r\n   * @param {any} gl - The gl value.\r\n   */\r\n  constructor(gl) {\r\n    super(gl)\r\n\r\n    this.setShaderStage(\r\n      'VERTEX_SHADER',\r\n      `\r\nprecision highp float;\r\n\r\nattribute vec4 positions;\r\n\r\n/* VS Outputs */\r\nvarying vec2 v_texCoord;\r\n \r\nvoid main()\r\n{\r\n    v_texCoord = (positions.xy + 0.5);\r\n    gl_Position =  vec4(positions.xy * 2.0, 0.0, 1.0);\r\n    // gl_Position =  vec4(positions.xy + vec2(-0.5, 0.5), 0.0, 1.0);\r\n}\r\n`\r\n    )\r\n    this.setShaderStage(\r\n      'FRAGMENT_SHADER',\r\n      `\r\nprecision highp float;\r\n\r\nuniform sampler2D trimSetAtlasTexture;\r\n\r\n/* VS Outputs */\r\nvarying vec2 v_texCoord;\r\n \r\n#ifdef ENABLE_ES3\r\nout vec4 fragColor;\r\n#endif\r\n\r\nvoid main(void) {\r\n\r\n#ifndef ENABLE_ES3\r\n  vec4 fragColor;\r\n#endif\r\n\r\n  vec4 col = texture2D(trimSetAtlasTexture, v_texCoord);\r\n  vec3 rgb = col.rgb / col.a;\r\n  fragColor = vec4(rgb,1.0);\r\n  \r\n#ifndef ENABLE_ES3\r\n  gl_FragColor = fragColor;\r\n#endif\r\n}\r\n`\r\n    )\r\n  }\r\n}\r\n\r\nexport { GLDebugTrimSetsShader }\r\n","import { GLFbo, GLTexture2D } from '@zeainc/zea-engine'\r\nimport { GLTrimCurveDrawSet } from './GLTrimCurveDrawSet.js'\r\n\r\nimport { GLDrawTrimCurveFansShader } from './GLDrawTrimCurveFansShader.js'\r\nimport { GLFlattenTrimSetsShader } from './GLFlattenTrimSetsShader.js'\r\nimport { GLDrawTrimCurveStripsShader } from './GLDrawTrimCurveStripsShader.js'\r\nimport { GLDebugTrimSetsShader } from './GLDebugTrimSetsShader.js'\r\n\r\n/** Class representing a GL trim set library.\r\n * @ignore\r\n */\r\nclass GLTrimSetLibrary {\r\n  /**\r\n   * Create a GL trim set library.\r\n   * @param {any} gl - The gl value.\r\n   * @param {any} cadpassdata - The cadpassdata value.\r\n   * @param {any} trimSetLibrary - The trimSetLibrary value.\r\n   * @param {any} glCurvesLibrary - The glCurvesLibrary value.\r\n   */\r\n  constructor(gl, cadpassdata, trimSetLibrary, glCurvesLibrary) {\r\n    this.__gl = gl\r\n    this.__cadpassdata = cadpassdata\r\n    this.__trimSetLibrary = trimSetLibrary\r\n    this.__glCurvesLibrary = glCurvesLibrary\r\n\r\n    const trimSetsBuffer = this.__trimSetLibrary.getBinaryBuffer()\r\n    const trimSetsTexSize = Math.sqrt(trimSetsBuffer.byteLength / 8)\r\n    this.__trimSetsTexture = new GLTexture2D(gl, {\r\n      format: 'RGBA',\r\n      type: 'HALF_FLOAT',\r\n      width: trimSetsTexSize,\r\n      height: trimSetsTexSize,\r\n      filter: 'NEAREST',\r\n      wrap: 'CLAMP_TO_EDGE',\r\n      mipMapped: false,\r\n      data: new Uint16Array(trimSetsBuffer)\r\n    })\r\n\r\n    this.__bindAttr = (location, channels, type, stride, offset, instanced = true) => {\r\n      gl.enableVertexAttribArray(location)\r\n      gl.vertexAttribPointer(location, channels, gl.FLOAT, false, stride, offset)\r\n      if (instanced) gl.vertexAttribDivisor(location, 1) // This makes it instanced\r\n    }\r\n\r\n    this.__trimCurveDrawSets = {}\r\n  }\r\n\r\n  // /////////////////////////////////////////////////////////////\r\n  // Trim Sets\r\n\r\n  /**\r\n   * The evaluateTrimSets method.\r\n   * @param {any} trimCurveDrawSets - The trimCurveDrawSets param.\r\n   * @param {any} trimSetAtlasTextureSize - The trimSetAtlasTextureSize param.\r\n   * @param {any} trimSetsAtlasLayoutData - The trimSetsAtlasLayoutData param.\r\n   * @param {any} trimSetsAtlasLayoutTextureSize - The trimSetsAtlasLayoutTextureSize param.\r\n   */\r\n  evaluateTrimSets(\r\n    trimCurveDrawSets,\r\n    trimSetAtlasTextureSize,\r\n    trimSetsAtlasLayoutData,\r\n    trimSetsAtlasLayoutTextureSize\r\n  ) {\r\n    // console.log(\"evaluateTrimSets:\" + trimSetAtlasTextureSize);\r\n    const gl = this.__gl\r\n\r\n    {\r\n      this.__trimSetsAtlasLayoutTexture = new GLTexture2D(this.__gl, {\r\n        format: 'RGBA',\r\n        type: 'FLOAT',\r\n        width: trimSetsAtlasLayoutTextureSize[0],\r\n        height: trimSetsAtlasLayoutTextureSize[1],\r\n        filter: 'NEAREST',\r\n        wrap: 'CLAMP_TO_EDGE',\r\n        mipMapped: false,\r\n        data: trimSetsAtlasLayoutData\r\n      })\r\n    }\r\n\r\n    if (!this.__trimSetAtlasTexture) {\r\n      this.__trimSetAtlasTextureSize = trimSetAtlasTextureSize\r\n\r\n      if (\r\n        this.__trimSetAtlasTextureSize[0] > this.__cadpassdata.maxTexSize ||\r\n        this.__trimSetAtlasTextureSize[1] > this.__cadpassdata.maxTexSize\r\n      ) {\r\n        console.warn(\r\n          'trimSetAtlas  is too big to fit in a texture. The image will be downsized:' +\r\n            this.__trimSetAtlasTextureSize +\r\n            ' maxTexSize:' +\r\n            this.__cadpassdata.maxTexSize\r\n        )\r\n      }\r\n\r\n      this.__trimSetAtlasMaskTexture = new GLTexture2D(gl, {\r\n        format: gl.name == 'webgl2' ? 'RG' : 'RGBA',\r\n        type: 'UNSIGNED_BYTE',\r\n        width: Math.min(this.__trimSetAtlasTextureSize[0], this.__cadpassdata.maxTexSize),\r\n        height: Math.min(this.__trimSetAtlasTextureSize[1], this.__cadpassdata.maxTexSize),\r\n        filter: 'NEAREST'\r\n      })\r\n      this.__trimSetAtlasMaskFbo = new GLFbo(gl, this.__trimSetAtlasMaskTexture)\r\n      this.__trimSetAtlasMaskFbo.setClearColor([0, 0, 0, 0])\r\n\r\n      // Multi-channel signed distance field\r\n      // https://steamcdn-a.akamaihd.net/apps/valve/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf\r\n      // See: 4.3\r\n      const format = gl.name == 'webgl2' ? 'RG' : 'RGBA'\r\n      const filter = 'LINEAR'\r\n\r\n      this.__trimSetAtlasTexture = new GLTexture2D(gl, {\r\n        format,\r\n        type: 'UNSIGNED_BYTE',\r\n        width: Math.min(this.__cadpassdata.maxTexSize, this.__trimSetAtlasTextureSize[0]),\r\n        height: Math.min(this.__cadpassdata.maxTexSize, this.__trimSetAtlasTextureSize[1]),\r\n        magFilter: filter,\r\n        minFilter: filter\r\n      })\r\n\r\n      this.__trimSetAtlasFbo = new GLFbo(gl, this.__trimSetAtlasTexture)\r\n      this.__trimSetAtlasFbo.setClearColor([0, 0, 0, 0])\r\n    } else if (\r\n      this.__trimSetAtlasTexture.width != trimSetAtlasTextureSize[0] ||\r\n      this.__trimSetAtlasTexture.height != trimSetAtlasTextureSize[1]\r\n    ) {\r\n      this.__trimSetAtlasTextureSize = trimSetAtlasTextureSize\r\n\r\n      // Copy the previous image into a new one, and then destroy the prvious.\r\n      this.__trimSetAtlasTexture.resize(trimSetAtlasTextureSize[0], trimSetAtlasTextureSize[1], true)\r\n      this.__trimSetAtlasFbo.resize() // hack to rebind the texture. Refactor the way textures are resized.\r\n\r\n      // this.__trimSetAtlasFbo.bind();\r\n    }\r\n\r\n    const renderstate = {}\r\n\r\n    // ////////////////////////////////////////////////\r\n    // Render the mask aread using fans\r\n\r\n    if (!this.trimCurveFansShader) {\r\n      this.trimCurveFansShader = new GLDrawTrimCurveFansShader(gl)\r\n      this.flattenTrimSetsShader = new GLFlattenTrimSetsShader(gl)\r\n      this.trimCurveStripsShader = new GLDrawTrimCurveStripsShader(gl)\r\n      this.debugTrimSetsShader = new GLDebugTrimSetsShader(gl)\r\n    }\r\n\r\n    this.__trimSetAtlasMaskFbo.bindAndClear()\r\n\r\n    {\r\n      // / Setup additive blending so that all rendering passes accumulate into the same Fbo.\r\n      gl.enable(gl.BLEND)\r\n      gl.blendEquation(gl.FUNC_ADD)\r\n      gl.blendFunc(gl.ONE, gl.ONE)\r\n\r\n      this.trimCurveFansShader.bind(renderstate)\r\n      const unifs = renderstate.unifs\r\n\r\n      this.__glCurvesLibrary.bindCurvesAtlas(renderstate)\r\n\r\n      gl.uniform2i(\r\n        unifs.trimSetAtlasTextureSize.location,\r\n        this.__trimSetAtlasTextureSize[0],\r\n        this.__trimSetAtlasTextureSize[1]\r\n      )\r\n\r\n      // For vertex welding (Not yet implemented)\r\n      if (unifs.trimSetTexture) {\r\n        this.__trimSetsTexture.bindToUniform(renderstate, unifs.trimSetTexture)\r\n        if (unifs.trimSetTextureSize)\r\n          gl.uniform2i(unifs.trimSetTextureSize.location, this.__trimSetsTexture.width, this.__trimSetsTexture.height)\r\n\r\n        this.__trimSetsAtlasLayoutTexture.bindToUniform(renderstate, unifs.curvesAtlasLayoutTexture)\r\n        if (unifs.curvesAtlasLayoutTextureSize)\r\n          gl.uniform2i(\r\n            unifs.curvesAtlasLayoutTextureSize.location,\r\n            this.__trimSetsAtlasLayoutTexture.width,\r\n            this.__trimSetsAtlasLayoutTexture.height\r\n          )\r\n      }\r\n\r\n      for (const key in trimCurveDrawSets) {\r\n        const detail = parseInt(key)\r\n        if (detail < 0) continue\r\n        let trimCurveDrawSet = this.__trimCurveDrawSets[key]\r\n        if (!trimCurveDrawSet) {\r\n          trimCurveDrawSet = new GLTrimCurveDrawSet(this.__gl, detail, trimCurveDrawSets[key])\r\n          this.__trimCurveDrawSets[key] = trimCurveDrawSet\r\n        }\r\n        trimCurveDrawSet.drawFans(renderstate)\r\n      }\r\n\r\n      gl.disable(gl.BLEND)\r\n    }\r\n\r\n    // ////////////////////////////////////////////////////\r\n    // Render the float texture as a signed distance field\r\n\r\n    this.__trimSetAtlasFbo.bindAndClear()\r\n\r\n    // if(false)\r\n    {\r\n      // /////////////////////////\r\n      // Flatten the fans texture\r\n      this.flattenTrimSetsShader.bind(renderstate)\r\n      const unifs = renderstate.unifs\r\n      this.__trimSetAtlasMaskTexture.bindToUniform(renderstate, unifs.trimSetAtlasTexture)\r\n      if (unifs.trimSetAtlasTextureSize)\r\n        this.__gl.uniform2i(\r\n          unifs.trimSetAtlasTextureSize.location,\r\n          this.__trimSetAtlasTextureSize[0],\r\n          this.__trimSetAtlasTextureSize[1]\r\n        )\r\n      this.__cadpassdata.glplanegeom.bind(renderstate)\r\n      this.__cadpassdata.glplanegeom.draw()\r\n    }\r\n\r\n    // //////////////////////////////////////\r\n    // Draw the Strips to clean up the edges\r\n    // if(false)\r\n    {\r\n      this.trimCurveStripsShader.bind(renderstate)\r\n      const unifs = renderstate.unifs\r\n\r\n      this.__glCurvesLibrary.bindCurvesAtlas(renderstate)\r\n\r\n      gl.uniform2i(\r\n        unifs.trimSetAtlasTextureSize.location,\r\n        this.__trimSetAtlasTextureSize[0],\r\n        this.__trimSetAtlasTextureSize[1]\r\n      )\r\n      gl.uniform1f(unifs.stripWidth.location, 1.25)\r\n\r\n      // Initially a build up the data around the edges by rasterizing a full color pixel,\r\n      // followed by a subtractive pass that cuts down the borders\r\n      //\r\n      // Initially, after the fans are rasterized.\r\n      //     ----\r\n      //  .  |  .\r\n      //  .  |  .\r\n      //     ----\r\n      //\r\n      // Becomes\r\n      //  -------\r\n      //  .     .\r\n      //  .     .\r\n      //  -------\r\n      //\r\n      // Becomes\r\n      //    . ---\r\n      //    ./\r\n      //   /.\r\n      //  -------\r\n      // After the subtraction pass\r\n      gl.uniform1i(unifs.flatten.location, 1)\r\n      gl.disable(gl.BLEND)\r\n\r\n      for (const key in trimCurveDrawSets) {\r\n        const detail = parseInt(key)\r\n        if (detail < 0) continue\r\n        let trimCurveDrawSet = this.__trimCurveDrawSets[key]\r\n        if (!trimCurveDrawSet) {\r\n          trimCurveDrawSet = new GLTrimCurveDrawSet(this.__gl, detail, trimCurveDrawSets[key])\r\n          this.__trimCurveDrawSets[key] = trimCurveDrawSet\r\n        }\r\n        trimCurveDrawSet.drawStrips(renderstate)\r\n      }\r\n\r\n      // Now subtract the gradient.\r\n      gl.uniform1i(unifs.flatten.location, 0)\r\n      gl.enable(gl.BLEND)\r\n      gl.blendEquation(gl.MIN)\r\n      gl.blendFunc(gl.ONE, gl.ONE)\r\n\r\n      for (const key in trimCurveDrawSets) {\r\n        const detail = parseInt(key)\r\n        if (detail < 0) continue\r\n        let trimCurveDrawSet = this.__trimCurveDrawSets[key]\r\n        if (!trimCurveDrawSet) {\r\n          trimCurveDrawSet = new GLTrimCurveDrawSet(this.__gl, detail, trimCurveDrawSets[key])\r\n          this.__trimCurveDrawSets[key] = trimCurveDrawSet\r\n        }\r\n        trimCurveDrawSet.drawStrips(renderstate)\r\n      }\r\n\r\n      gl.disable(gl.BLEND)\r\n    }\r\n\r\n    for (const key in trimCurveDrawSets) {\r\n      const trimCurveDrawSet = this.__trimCurveDrawSets[key]\r\n      if (trimCurveDrawSet) trimCurveDrawSet.cleanup()\r\n    }\r\n\r\n    this.__trimSetsAtlasLayoutData = trimSetsAtlasLayoutData\r\n    // console.log(\"----------------------------------\");\r\n    // const st_x = Math.round(trimSetAtlasTextureSize[0] / 2)\r\n    // const st_y = trimSetAtlasTextureSize[0] - 4;; //Math.round(trimSetAtlasTextureSize[1] / 2)\r\n    // gl.finish();\r\n    // this.logTrimSet(0);\r\n\r\n    gl.finish()\r\n  }\r\n\r\n  /**\r\n   * The logTrimSetMask method.\r\n   * @param {any} trimSetId - The trimSetId param.\r\n   */\r\n  logTrimSetMask(trimSetId) {\r\n    const gl = this.__gl\r\n    this.__trimSetAtlasMaskFbo.bind()\r\n    const layout = [\r\n      this.__trimSetsAtlasLayoutData[trimSetId * 4 + 0],\r\n      this.__trimSetsAtlasLayoutData[trimSetId * 4 + 1],\r\n      this.__trimSetsAtlasLayoutData[trimSetId * 4 + 2],\r\n      this.__trimSetsAtlasLayoutData[trimSetId * 4 + 3]\r\n    ]\r\n    console.log('logTrimSetMask ' + trimSetId + ':[' + layout[0] + ',' + layout[1] + ']:' + layout[2] + 'x' + layout[3])\r\n    const pixels = new Uint8Array(layout[2] * 4)\r\n    for (let i = 0; i < layout[3]; i++) {\r\n      gl.readPixels(\r\n        layout[0],\r\n        layout[1] + i,\r\n        layout[2],\r\n        1,\r\n        gl.name == 'webgl2' ? gl.RED : gl.RGBA,\r\n        gl.UNSIGNED_BYTE,\r\n        pixels\r\n      )\r\n      let line = i + ' '\r\n      for (let j = 0; j < layout[2]; j++) {\r\n        // line += (pixels[j * 4] % 2 == 0 ? '-' : '*');\r\n        line += pixels[j * 4]\r\n      }\r\n      console.log(line)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The logTrimSet method.\r\n   * @param {any} trimSetId - The trimSetId param.\r\n   */\r\n  logTrimSet(trimSetId) {\r\n    const gl = this.__gl\r\n    this.__trimSetAtlasFbo.bind()\r\n    const layout = [\r\n      this.__trimSetsAtlasLayoutData[trimSetId * 4 + 0],\r\n      this.__trimSetsAtlasLayoutData[trimSetId * 4 + 1],\r\n      this.__trimSetsAtlasLayoutData[trimSetId * 4 + 2],\r\n      this.__trimSetsAtlasLayoutData[trimSetId * 4 + 3]\r\n    ]\r\n    console.log('logTrimSet ' + trimSetId + ':[' + layout[0] + ',' + layout[1] + ']:' + layout[2] + 'x' + layout[3])\r\n    const pixels = new Uint16Array(layout[2] * 4)\r\n    for (let i = 0; i < layout[3]; i++) {\r\n      gl.readPixels(layout[0], layout[1] + i, layout[2], 1, gl.RGBA, gl.HALF_FLOAT, pixels)\r\n      let line = i + ' '\r\n      for (let j = 0; j < layout[2]; j++) {\r\n        // line += (pixels[j * 4] % 2 == 0 ? '-' : '*');\r\n        line += pixels[j * 4]\r\n      }\r\n      console.log(line)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The bindTrimSetAtlas method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   */\r\n  bindTrimSetAtlas(renderstate) {\r\n    const gl = this.__gl\r\n    const unifs = renderstate.unifs\r\n    const { trimSetAtlasTexture, trimSetAtlasTextureSize } = unifs\r\n    if (this.__trimSetAtlasTexture && trimSetAtlasTexture) {\r\n      this.__trimSetAtlasTexture.bindToUniform(renderstate, trimSetAtlasTexture)\r\n      if (trimSetAtlasTextureSize) {\r\n        gl.uniform2i(\r\n          trimSetAtlasTextureSize.location,\r\n          this.__trimSetAtlasTextureSize[0],\r\n          this.__trimSetAtlasTextureSize[1]\r\n        )\r\n      }\r\n\r\n      if (this.ext_filter_anisotropic) {\r\n        // Disable anisotropic filtering on this texture.\r\n        gl.texParameterf(gl.TEXTURE_2D, this.ext_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT, 1.0)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The bindTrimSetAtlasLayout method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   */\r\n  bindTrimSetAtlasLayout(renderstate) {\r\n    // During debugging, we disable trim sets.\r\n    if (!this.__trimSetsAtlasLayoutTexture) return\r\n    const gl = this.__gl\r\n    const unifs = renderstate.unifs\r\n    this.__trimSetsAtlasLayoutTexture.bindToUniform(renderstate, unifs.trimSetsAtlasLayoutTexture)\r\n    gl.uniform2i(\r\n      unifs.trimSetsAtlasLayoutTextureSize.location,\r\n      this.__trimSetsAtlasLayoutTexture.width,\r\n      this.__trimSetsAtlasLayoutTexture.height\r\n    )\r\n  }\r\n\r\n  /**\r\n   * The drawTrimSets method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @return {boolean} - The return value.\r\n   */\r\n  drawTrimSets(renderstate) {\r\n    if (!this.__trimSetAtlasTexture || !this.debugTrimSetsShader.bind(renderstate)) return false\r\n    // this.bindTrimSetAtlas(renderstate);\r\n\r\n    this.__trimSetAtlasTexture.bindToUniform(renderstate, renderstate.unifs.trimSetAtlasTexture)\r\n    this.__cadpassdata.glplanegeom.bind(renderstate)\r\n    this.__cadpassdata.glplanegeom.draw()\r\n  }\r\n\r\n  /**\r\n   * The destroy method.\r\n   */\r\n  destroy() {\r\n    this.__trimSetsTexture.destroy()\r\n    if (this.__trimSetsAtlasLayoutTexture) {\r\n      this.__trimSetsAtlasLayoutTexture.destroy()\r\n      this.__trimSetAtlasMaskTexture.destroy()\r\n      this.__trimSetAtlasMaskFbo.destroy()\r\n      this.__trimSetAtlasTexture.destroy()\r\n      this.__trimSetAtlasFbo.destroy()\r\n    }\r\n  }\r\n}\r\n\r\nexport { GLTrimSetLibrary }\r\n","/* eslint-disable require-jsdoc */\r\nimport { EventEmitter } from '@zeainc/zea-engine'\r\nimport './CADBody.js'\r\n\r\nimport { floatsPerSceneBody, BODY_FLAG_CUTAWAY, BODY_FLAG_INVISIBLE } from './CADConstants.js'\r\n\r\n/** Class representing a GLCADBody.\r\n * @ignore\r\n */\r\nexport class GLCADBody extends EventEmitter {\r\n  constructor(cadBody, bodyId) {\r\n    super()\r\n    this.cadBody = cadBody\r\n    this.bodyId = bodyId\r\n    this.flags = 0\r\n\r\n    this.dirtyValues = new Set()\r\n  }\r\n\r\n  bind(\r\n    cadpassdata,\r\n    sceneBodyItemData,\r\n    cadBodyTextureData,\r\n    bodyItemDataChanged,\r\n    highlightedBodies,\r\n    highlightChangeBatch,\r\n    pushhighlightChangeBatchToWorker\r\n  ) {\r\n    this.cadBodyTextureData = cadBodyTextureData\r\n\r\n    const cadBodyDescAddr = this.cadBody.getBodyDataTexelCoords()\r\n\r\n    // const offset = bodyId * floatsPerSceneBody\r\n    if (!this.cadBody.isVisible()) this.flags |= BODY_FLAG_INVISIBLE\r\n\r\n    if (this.cadBody.isCutawayEnabled && this.cadBody.isCutawayEnabled()) {\r\n      this.flags |= BODY_FLAG_CUTAWAY\r\n    }\r\n\r\n    const material = this.cadBody.getMaterial()\r\n\r\n    const shaderId = cadpassdata.genShaderID(material.getShaderName())\r\n    // console.log('Shader:' + material.getShaderName() + ':' + shaderId);\r\n    let glmaterialcoords = material.getMetadata('glmaterialcoords')\r\n    if (!glmaterialcoords) {\r\n      glmaterialcoords = cadpassdata.materialLibrary.addMaterial(material)\r\n    }\r\n\r\n    sceneBodyItemData[0] = this.cadBody.getBodyDescId()\r\n    sceneBodyItemData[1] = shaderId\r\n\r\n    cadBodyTextureData[0] = this.cadBody.getBodyDescId()\r\n    cadBodyTextureData[1] = this.flags\r\n    cadBodyTextureData[2] = cadBodyDescAddr.x\r\n    cadBodyTextureData[3] = cadBodyDescAddr.y\r\n\r\n    cadBodyTextureData[4] = glmaterialcoords.x\r\n    cadBodyTextureData[5] = glmaterialcoords.y\r\n\r\n    this.visibilityChanged = () => {\r\n      // TODO: Actually modify the draw sets for each visibility chage.\r\n      // It should be similar to hilight changes.\r\n      const visibile = this.cadBody.isVisible()\r\n      if (!visibile) {\r\n        if ((this.flags & BODY_FLAG_INVISIBLE) == 0) {\r\n          this.flags |= BODY_FLAG_INVISIBLE\r\n          this.cadBodyTextureData[1] = this.flags\r\n          bodyItemDataChanged(this.bodyId)\r\n        }\r\n      } else {\r\n        if ((this.flags & BODY_FLAG_INVISIBLE) != 0) {\r\n          this.flags &= ~BODY_FLAG_INVISIBLE\r\n          this.cadBodyTextureData[1] = this.flags\r\n          bodyItemDataChanged(this.bodyId)\r\n        }\r\n      }\r\n    }\r\n    this.cadBody.on('visibilityChanged', this.visibilityChanged)\r\n\r\n    this.materialChanged = () => {\r\n      const material = this.cadBody.getMaterial()\r\n      let glmaterialcoords = material.getMetadata('glmaterialcoords')\r\n      if (!glmaterialcoords) {\r\n        glmaterialcoords = cadpassdata.materialLibrary.addMaterial(material)\r\n      }\r\n      cadBodyTextureData[4] = glmaterialcoords.x\r\n      cadBodyTextureData[5] = glmaterialcoords.y\r\n      bodyItemDataChanged(this.bodyId)\r\n    }\r\n    this.cadBody.getParameter('Material').on('valueChanged', this.materialChanged)\r\n\r\n    // /////////////////////////////////\r\n    // Body Xfo\r\n    this.globalXfoParam = this.cadBody.getParameter('GlobalXfo')\r\n    this.updateXfo()\r\n    this.globalXfoChanged = () => {\r\n      bodyItemDataChanged(this.bodyId)\r\n      this.dirtyValues.add('Xfo')\r\n    }\r\n    this.globalXfoParam.on('valueChanged', this.globalXfoChanged)\r\n\r\n    // /////////////////////////////////\r\n    // Highlight\r\n    if (this.cadBody.isHighlighted()) {\r\n      this.updateHighlightColor()\r\n      highlightedBodies.push(this.bodyId)\r\n    }\r\n\r\n    this.highlightChanged = () => {\r\n      if (!highlightChangeBatch.dirty) {\r\n        setTimeout(pushhighlightChangeBatchToWorker, 1)\r\n        highlightChangeBatch.dirty = true\r\n      }\r\n      const highlighted = this.cadBody.isHighlighted()\r\n      if (highlighted) {\r\n        this.dirtyValues.add('Highlight')\r\n        bodyItemDataChanged(this.bodyId)\r\n        if (highlightedBodies.indexOf(this.bodyId) == -1) {\r\n          highlightedBodies.push(this.bodyId)\r\n\r\n          // Note: filter out highlight/unhighlight in a single update.\r\n          const indexInSelChangeSet = highlightChangeBatch.unhighlightedBodyIds.indexOf(this.bodyId)\r\n          if (indexInSelChangeSet != -1) {\r\n            highlightChangeBatch.unhighlightedBodyIds.splice(indexInSelChangeSet, 1)\r\n          } else {\r\n            highlightChangeBatch.highlightedBodyIds.push(this.bodyId)\r\n          }\r\n        }\r\n      } else {\r\n        const index = highlightedBodies.indexOf(this.bodyId)\r\n        if (index != -1) {\r\n          highlightedBodies.splice(index, 1)\r\n\r\n          // Note: filter out highlight/unhighlight in a single update.\r\n          const indexInSelChangeSet = highlightChangeBatch.highlightedBodyIds.indexOf(this.bodyId)\r\n          if (indexInSelChangeSet != -1) {\r\n            highlightChangeBatch.highlightedBodyIds.splice(indexInSelChangeSet, 1)\r\n          } else {\r\n            highlightChangeBatch.unhighlightedBodyIds.push(this.bodyId)\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this.cadBody.on('highlightChanged', this.highlightChanged)\r\n\r\n    // /////////////////////////////////\r\n    // Body Cut Plane\r\n    this.updateCutaway()\r\n    this.cutAwayChangedId = this.cadBody.on('cutAwayChanged', () => {\r\n      bodyItemDataChanged(this.bodyId)\r\n      this.dirtyValues.add('Cutaway')\r\n    })\r\n  }\r\n\r\n  updateCutaway() {\r\n    const cpoff = 24\r\n    if (this.cadBody.isCutawayEnabled()) {\r\n      if (!(this.flags & BODY_FLAG_CUTAWAY)) {\r\n        this.flags |= BODY_FLAG_CUTAWAY\r\n        this.cadBodyTextureData[1] = this.flags\r\n      }\r\n\r\n      const cutPlane = this.cadBody.getCutVector()\r\n      const cutPlaneDist = this.cadBody.getCutDist()\r\n      this.cadBodyTextureData[cpoff + 0] = cutPlane.x\r\n      this.cadBodyTextureData[cpoff + 1] = cutPlane.y\r\n      this.cadBodyTextureData[cpoff + 2] = cutPlane.z\r\n      this.cadBodyTextureData[cpoff + 3] = cutPlaneDist\r\n    } else {\r\n      if (this.flags & BODY_FLAG_CUTAWAY) {\r\n        this.flags &= ~BODY_FLAG_CUTAWAY\r\n        this.cadBodyTextureData[1] = this.flags\r\n      }\r\n    }\r\n  }\r\n\r\n  updateHighlightColor() {\r\n    const highlight = this.cadBody.getHighlight()\r\n    if (highlight) {\r\n      const hoff = 20\r\n      this.cadBodyTextureData[hoff + 0] = highlight.r\r\n      this.cadBodyTextureData[hoff + 1] = highlight.g\r\n      this.cadBodyTextureData[hoff + 2] = highlight.b\r\n      this.cadBodyTextureData[hoff + 3] = highlight.a\r\n    }\r\n  }\r\n\r\n  updateXfo() {\r\n    const bodyXfo = this.globalXfoParam.getValue()\r\n\r\n    const off = 8\r\n    this.cadBodyTextureData[off + 0] = bodyXfo.tr.x\r\n    this.cadBodyTextureData[off + 1] = bodyXfo.tr.y\r\n    this.cadBodyTextureData[off + 2] = bodyXfo.tr.z\r\n    // this.cadBodyTextureData[off + 3]\r\n    this.cadBodyTextureData[off + 4] = bodyXfo.ori.x\r\n    this.cadBodyTextureData[off + 5] = bodyXfo.ori.y\r\n    this.cadBodyTextureData[off + 6] = bodyXfo.ori.z\r\n    this.cadBodyTextureData[off + 7] = bodyXfo.ori.w\r\n    this.cadBodyTextureData[off + 8] = bodyXfo.sc.x\r\n    this.cadBodyTextureData[off + 9] = bodyXfo.sc.y\r\n    this.cadBodyTextureData[off + 10] = bodyXfo.sc.z\r\n  }\r\n\r\n  updateCadBodyTex() {\r\n    this.dirtyValues.forEach((key) => {\r\n      if (key == 'Xfo') this.updateXfo()\r\n      else if (key == 'Highlight') this.updateHighlightColor()\r\n      else if (key == 'Cutaway') this.updateCutaway()\r\n    })\r\n    this.dirtyValues.clear()\r\n  }\r\n\r\n  destroy() {\r\n    this.cadBody.off('visibilityChanged', this.visibilityChanged)\r\n    if (this.cadBody.cutAwayChanged) {\r\n      this.cadBody.off('cutAwayChanged', this.cutAwayChangedId)\r\n    } else {\r\n      const cutParam = this.cadBody.getParameter('CutawayEnabled')\r\n      if (cutParam) {\r\n        cutParam.off('valueChanged', this.cutAwayEnabledId)\r\n      }\r\n    }\r\n    this.cadBody.getParameter('Material').off('valueChanged', this.materialChanged)\r\n    this.cadBody.getParameter('GlobalXfo').off('valueChanged', this.globalXfoChanged)\r\n    this.cadBody.off('highlightChanged', this.highlightChanged)\r\n  }\r\n}\r\n","const kIsNodeJS = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';\nconst kRequire = kIsNodeJS && typeof module.require === 'function' ? module.require : null; // eslint-disable-line\n\nexport function createInlineWorkerFactory(fn, sourcemap = null) {\n    const source = fn.toString();\n    const start = source.indexOf('\\n', 10) + 1;\n    const end = source.indexOf('}', source.length - 1);\n    const body = source.substring(start, end) + (sourcemap ? `\\/\\/# sourceMappingURL=${sourcemap}` : '');\n    const blankPrefixLength = body.search(/\\S/);\n    const lines = body.split('\\n').map(line => line.substring(blankPrefixLength) + '\\n');\n\n    if (kRequire) {\n        /* node.js */\n        const Worker = kRequire('worker_threads').Worker; // eslint-disable-line\n        const concat = lines.join('\\n');\n        return function WorkerFactory(options) {\n            return new Worker(concat, Object.assign({}, options, { eval: true }));\n        };\n    }\n\n    /* browser */\n    const blob = new Blob(lines, { type: 'application/javascript' });\n    const url = URL.createObjectURL(blob);\n    return function WorkerFactory(options) {\n        return new Worker(url, options);\n    };\n}\n\nexport function createURLWorkerFactory(url) {\n    if (kRequire) {\n        /* node.js */\n        const Worker = kRequire('worker_threads').Worker; // eslint-disable-line\n        return function WorkerFactory(options) {\n            return new Worker(url, options);\n        };\n    }\n    /* browser */\n    return function WorkerFactory(options) {\n        return new Worker(url, options);\n    };\n}\n\nexport function browserDecodeBase64(base64, enableUnicode) {\n    const binaryString = atob(base64);\n    if (enableUnicode) {\n        const binaryView = new Uint8Array(binaryString.length);\n        Array.prototype.forEach.call(binaryView, (el, idx, arr) => {\n            arr[idx] = binaryString.charCodeAt(idx);\n        });\n        return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));\n    }\n    return binaryString;\n}\n\nexport function nodeDecodeBase64(base64, enableUnicode) {\n    return Buffer.from(base64, 'base64').toString(enableUnicode ? 'utf16' : 'utf8');\n}\n\nexport function createBase64WorkerFactory(base64, sourcemap = null, enableUnicode = false) {\n    const source = kIsNodeJS ? nodeDecodeBase64(base64, enableUnicode) : browserDecodeBase64(base64, enableUnicode);\n    const start = source.indexOf('\\n', 10) + 1;\n    const body = source.substring(start) + (sourcemap ? `\\/\\/# sourceMappingURL=${sourcemap}` : '');\n\n    if (kRequire) {\n        /* node.js */\n        const Worker = kRequire('worker_threads').Worker; // eslint-disable-line\n        return function WorkerFactory(options) {\n            return new Worker(body, Object.assign({}, options, { eval: true }));\n        };\n    }\n\n    /* browser */\n    const blob = new Blob([body], { type: 'application/javascript' });\n    const url = URL.createObjectURL(blob);\n    return function WorkerFactory(options) {\n        return new Worker(url, options);\n    };\n}\n","import { EventEmitter, Vec3, GLTexture2D, MathFunctions } from '@zeainc/zea-engine'\r\nimport { CADBody } from './CADBody.js'\r\nimport { GLSurfaceDrawSet } from './GLSurfaceDrawSet.js'\r\nimport { GLCurveDrawSet } from './GLCurveDrawSet.js'\r\nimport { GLCurveLibrary } from './GLCurveLibrary.js'\r\nimport { GLSurfaceLibrary } from './GLSurfaceLibrary.js'\r\nimport { GLTrimSetLibrary } from './GLTrimSetLibrary.js'\r\nimport { GLCADBody } from './GLCADBody.js'\r\n\r\nimport {\r\n  pixelsPerDrawItem, // The number of RGBA pixels per draw item.\r\n  drawItemShaderAttribsStride,\r\n  floatsPerSceneBody,\r\n} from './CADConstants.js'\r\n\r\n// [bodyDescId, surfaceId, cadBodyDesc.xy], [glmaterialcoords.xy][tr-xyz], [ori], [sc], [highlight], [cutPlane]\r\nconst pixelsPerCADBody = 7\r\n\r\nimport GLCADAssetWorker from 'web-worker:./GLCADAssetWorker.js'\r\n// import {\r\n//   GLCADAssetWorker_onmessage\r\n// } from './GLCADAssetWorker.js';\r\n\r\n/**  Class representing a GL CAD asset.\r\n * @ignore\r\n */\r\nclass GLCADAsset extends EventEmitter {\r\n  /**\r\n   * Create a GL CAD asset.\r\n   * @param {any} gl - The gl value.\r\n   * @param {any} assetId - The assetId value.\r\n   * @param {any} cadAsset - The cadAsset value.\r\n   * @param {any} cadpassdata - The cadpassdata value.\r\n   */\r\n  constructor(gl, assetId, cadAsset, cadpassdata) {\r\n    super()\r\n    this.__gl = gl\r\n    this.__assetId = assetId\r\n    this.__cadAsset = cadAsset\r\n    this.__numSurfaces = cadAsset.getSurfaceLibrary().getNumSurfaces()\r\n    this.__numBodies = cadAsset.getBodyLibrary().getNumBodies()\r\n    this.__numMaterials = cadAsset.getMaterialLibrary().getNumMaterials()\r\n    this.__numHighlightedGeoms = 0\r\n    this.__ready = false\r\n\r\n    this.__visible = this.__cadAsset.isVisible()\r\n    this.__assetVisibilityChanged = this.__assetVisibilityChanged.bind(this)\r\n    this.__cadAsset.on('visibilityChanged', this.__assetVisibilityChanged)\r\n\r\n    const updateDisplayEdges = () => {\r\n      this.displayEdges = this.__cadAsset.getParameter('DisplayEdges').getValue()\r\n      if (this.displayEdges) cadpassdata.incDisplayEdges()\r\n      else cadpassdata.decDisplayEdges()\r\n    }\r\n    updateDisplayEdges()\r\n    this.displayEdgesChangedId = this.__cadAsset.getParameter('DisplayEdges').on('valueChanged', updateDisplayEdges)\r\n\r\n    const updateEdgeColor = () => {\r\n      this.edgeColor = this.__cadAsset.getParameter('EdgeColor').getValue().asArray()\r\n      this.emit('updated')\r\n    }\r\n    updateEdgeColor()\r\n    this.edgesColorChangedId = this.__cadAsset.getParameter('EdgeColor').on('valueChanged', updateEdgeColor)\r\n\r\n    this.__cadpassdata = cadpassdata\r\n\r\n    this.__curveLibrary = new GLCurveLibrary(\r\n      gl,\r\n      cadpassdata,\r\n      this.__cadAsset.getSurfaceLibrary(),\r\n      cadAsset.getVersion()\r\n    )\r\n    this.__surfaceLibrary = new GLSurfaceLibrary(\r\n      gl,\r\n      cadpassdata,\r\n      this.__cadAsset.getSurfaceLibrary(),\r\n      this.__curveLibrary,\r\n      cadAsset.getVersion()\r\n    )\r\n    const trimSetsBuffer = this.__cadAsset.getTrimSetLibrary().getBinaryBuffer()\r\n    if (trimSetsBuffer && trimSetsBuffer.byteLength > 8) {\r\n      this.__trimSetLibrary = new GLTrimSetLibrary(\r\n        gl,\r\n        cadpassdata,\r\n        this.__cadAsset.getTrimSetLibrary(),\r\n        this.__curveLibrary\r\n      )\r\n    }\r\n\r\n    {\r\n      const bodyLibraryBuffer = this.__cadAsset.getBodyLibrary().getBinaryBuffer()\r\n      if (bodyLibraryBuffer) {\r\n        const bodyTexSize = Math.sqrt(bodyLibraryBuffer.byteLength / 16) // RGBA32 pixels\r\n        this.__bodyDescTexture = new GLTexture2D(gl, {\r\n          format: 'RGBA',\r\n          type: 'FLOAT',\r\n          width: bodyTexSize,\r\n          height: bodyTexSize,\r\n          filter: 'NEAREST',\r\n          wrap: 'CLAMP_TO_EDGE',\r\n          mipMapped: false,\r\n          data: new Float32Array(bodyLibraryBuffer),\r\n        })\r\n      }\r\n    }\r\n\r\n    this.__bindAttr = (location, channels, type, stride, offset, instanced = true) => {\r\n      gl.enableVertexAttribArray(location)\r\n      gl.vertexAttribPointer(location, channels, gl.FLOAT, false, stride, offset)\r\n      if (instanced) gl.vertexAttribDivisor(location, 1) // This makes it instanced\r\n    }\r\n\r\n    this.__trimCurveDrawSets = {}\r\n    this.__surfaceDrawSets = {}\r\n    this.__curveDrawSets = {}\r\n\r\n    // ////////////////////////////////////////////////\r\n\r\n    this.loadWorker()\r\n  }\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  __assetVisibilityChanged() {\r\n    this.__visible = this.__cadAsset.isVisible()\r\n    this.emit('updated')\r\n  }\r\n\r\n  /**\r\n   * The getCADAsset method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getCADAsset() {\r\n    return this.__cadAsset\r\n  }\r\n\r\n  /**\r\n   * The getNumSurfaces method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getNumSurfaces() {\r\n    return this.__numSurfaces\r\n  }\r\n\r\n  /**\r\n   * The getNumBodies method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getNumBodies() {\r\n    return this.__numBodies\r\n  }\r\n\r\n  /**\r\n   * The getNumMaterials method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getNumMaterials() {\r\n    return this.__numMaterials\r\n  }\r\n\r\n  /**\r\n   * The incHighlightedCount method.\r\n   * @param {any} count - The count param.\r\n   */\r\n  incHighlightedCount(count) {\r\n    this.__numHighlightedGeoms += count\r\n    this.__cadpassdata.incHighlightedCount(count)\r\n  }\r\n\r\n  /**\r\n   * The decHighlightedCount method.\r\n   * @param {any} count - The count param.\r\n   */\r\n  decHighlightedCount(count) {\r\n    this.__numHighlightedGeoms -= count\r\n    this.__cadpassdata.decHighlightedCount(count)\r\n  }\r\n\r\n  /**\r\n   * The loadWorker method.\r\n   */\r\n  loadWorker() {\r\n    const numBodyItems = this.__cadAsset.getNumBodyItems()\r\n    if (numBodyItems == 0) return\r\n\r\n    // let tmp = 0;\r\n    // this.__cadAsset.traverse((treeItem) => {\r\n    //     if (treeItem instanceof CADBody) {\r\n    //       console.log(treeItem.getPath())\r\n    //       tmp++;\r\n    //       return false;\r\n    //     } else\r\n    //       return true;\r\n    // });\r\n    // if(numBodyItems != tmp){\r\n    //   console.log(\"numBodyItems\", numBodyItems, tmp)\r\n    //   numBodyItems = tmp;\r\n    // }\r\n\r\n    // Only support power 2 textures. Else we get strange corruption on some GPUs\r\n    // in some scenes.\r\n    let cadBodiesTextureSize = MathFunctions.nextPow2(Math.round(Math.sqrt(numBodyItems * pixelsPerCADBody) + 0.5))\r\n    // Size should be a multiple of pixelsPerCADBody, so each geom item is always contiguous\r\n    // in memory. (makes updating a lot easier. See __updateItemInstanceData below)\r\n    if (cadBodiesTextureSize % pixelsPerCADBody != 0)\r\n      cadBodiesTextureSize += pixelsPerCADBody - (cadBodiesTextureSize % pixelsPerCADBody)\r\n\r\n    this.cadBodiesTextureData = new Float32Array(cadBodiesTextureSize * cadBodiesTextureSize * 4) // 4==RGBA pixels.\r\n\r\n    // Calculate the entroid to offset all the Xfo values.\r\n    // This is to work around an issue on Mobile GPUs where\r\n    // the fragment shader stage only supports Flaot16 operations.\r\n    // The Matrix calculated in the DrawItems shader contains artifacts\r\n    // because of the low precision.\r\n    // If the asset is invisible when loaded, then the bbox is\r\n    // not valid and the centroid becomes NaN\r\n    const assetBBox = this.__cadAsset.getParameter('BoundingBox').getValue()\r\n    // this.__assetCentroid = assetBBox.center()\r\n    // if (\r\n    //   Number.isNaN(this.__assetCentroid.x) ||\r\n    //   Number.isNaN(this.__assetCentroid.y) ||\r\n    //   Number.isNaN(this.__assetCentroid.z)\r\n    // ) {\r\n    this.__assetCentroid = new Vec3()\r\n    // }\r\n\r\n    const sceneBodyItemsData = new Float32Array(numBodyItems * floatsPerSceneBody)\r\n\r\n    let index = 0\r\n    this.__cadBodies = []\r\n    const highlightedBodies = []\r\n\r\n    const highlightChangeBatch = {\r\n      highlightedBodyIds: [],\r\n      unhighlightedBodyIds: [],\r\n      dirty: false,\r\n    }\r\n    const pushhighlightChangeBatchToWorker = () => {\r\n      this.__postMessageToWorker({\r\n        eventType: 'bodyHighlightChanged',\r\n        highlightedBodyIds: highlightChangeBatch.highlightedBodyIds,\r\n        unhighlightedBodyIds: highlightChangeBatch.unhighlightedBodyIds,\r\n      })\r\n      highlightChangeBatch.highlightedBodyIds = []\r\n      highlightChangeBatch.unhighlightedBodyIds = []\r\n      highlightChangeBatch.dirty = false\r\n    }\r\n\r\n    this.__dirtyBodyIndices = []\r\n    const bodyItemDataChanged = (bodyId) => {\r\n      if (this.__dirtyBodyIndices.indexOf(bodyId) == -1) {\r\n        this.__dirtyBodyIndices.push(bodyId)\r\n        this.emit('updated')\r\n      }\r\n    }\r\n\r\n    const bindCADBody = (cadBody) => {\r\n      const bodyId = index\r\n      if (bodyId >= numBodyItems) return\r\n\r\n      // Data passed to the web worker to help setup layout.\r\n      const sceneBodyItemDataByteOffset = bodyId * floatsPerSceneBody * 4 /*bytes/channel*/\r\n      const sceneBodyItemData = new Float32Array(\r\n        sceneBodyItemsData.buffer,\r\n        sceneBodyItemDataByteOffset,\r\n        floatsPerSceneBody\r\n      )\r\n\r\n      const cadBodyTextureDataByteOffset = bodyId * pixelsPerCADBody * 4 /*channels/pixel*/ * 4 /*bytes/channel*/\r\n      const cadBodyTextureData = new Float32Array(\r\n        this.cadBodiesTextureData.buffer,\r\n        cadBodyTextureDataByteOffset,\r\n        pixelsPerCADBody * 4 /*channels/pixel*/\r\n      )\r\n\r\n      const glCADBody = new GLCADBody(cadBody, bodyId)\r\n      glCADBody.bind(\r\n        this.__cadpassdata,\r\n        sceneBodyItemData,\r\n        cadBodyTextureData,\r\n        bodyItemDataChanged,\r\n        highlightedBodies,\r\n        highlightChangeBatch,\r\n        pushhighlightChangeBatchToWorker\r\n      )\r\n\r\n      this.__cadBodies.push(glCADBody)\r\n      index++\r\n    }\r\n\r\n    this.__cadAsset.traverse((treeItem) => {\r\n      if (treeItem instanceof CADBody) {\r\n        bindCADBody(treeItem)\r\n        return false\r\n      } else {\r\n        return true\r\n      }\r\n    })\r\n\r\n    ////////////////////////////////////////\r\n    // Greate the GLTexture.\r\n    const gl = this.__gl\r\n    this.__cadBodiesTexture = new GLTexture2D(gl, {\r\n      format: 'RGBA',\r\n      type: 'FLOAT',\r\n      width: cadBodiesTextureSize,\r\n      height: cadBodiesTextureSize,\r\n      filter: 'NEAREST',\r\n      wrap: 'CLAMP_TO_EDGE',\r\n      mipMapped: false,\r\n      data: this.cadBodiesTextureData,\r\n    })\r\n\r\n    ////////////////////////////////////////\r\n    // Detail Factor\r\n    // The detail factor is used to convert surface 'cost'\r\n    // to a given tesselation level.\r\n    // Here we start with a given tesselation desired for a\r\n    // circle the size of the asset bounding box.\r\n    // We calculate the cost of the circle (curvature * length^2)\r\n    const unitsScale = this.__cadAsset.getUnitsConversion()\r\n    const assetBBoxRadius = (assetBBox.size() * 0.5) / unitsScale\r\n\r\n    //////////////////////\r\n    // Calculate a detail value for a circle enclosing our bbox.\r\n    const lod = this.__cadAsset.lod\r\n    const detail = 128 * Math.pow(2, lod)\r\n    // Calculate the arc angle for a cricle subdivided to the detail level\r\n    const arcAngle = (Math.PI * 2.0) / detail\r\n    // Calculate the deviation to the circle at the middle of the arc.\r\n    const errorTolerance = assetBBoxRadius - assetBBoxRadius * Math.cos(arcAngle / 2)\r\n\r\n    // The smallest area of a drawn item.\r\n    // The renderer will skip any surfaces smaller than this item.\r\n    const surfaceAreaThreshold = 0 //Math.PI * (assetBBoxRadius * assetBBoxRadius * 0.000000005 * Math.pow(2, lod))\r\n    // Note: on the hospital sprinker system we get the following values on the GTX laptop.\r\n    // assetBBoxRadius: 67447  surfaceAreaThreshold: 285\r\n    // Skipping about 30 surfaces.\r\n\r\n    console.log(\r\n      'assetBBoxRadius:',\r\n      assetBBoxRadius,\r\n      ' errorTolerance:',\r\n      errorTolerance,\r\n      ' surfaceAreaThreshold:',\r\n      surfaceAreaThreshold\r\n    )\r\n\r\n    ////////////////////////////////////////\r\n    const curvesDataBuffer = this.__cadAsset.getSurfaceLibrary().getCurveBuffer()\r\n    const surfacesDataBuffer = this.__cadAsset.getSurfaceLibrary().getSurfaceBuffer()\r\n    const cadDataVersion = this.__cadAsset.getVersion()\r\n\r\n    const trimSetsBuffer = this.__cadAsset.getTrimSetLibrary().getBinaryBuffer()\r\n    let trimTexelSize = -1\r\n    if (trimSetsBuffer) {\r\n      const numAssets = this.__cadpassdata.assetCount\r\n      trimTexelSize = this.__cadAsset.getTrimSetLibrary().getTexelSize(lod, numAssets)\r\n      // const mult = Math.pow(2, this.__cadAsset.getLOD());\r\n      // trimTexelSize = this.__cadAsset.getTrimTexelSize() * mult;\r\n    }\r\n\r\n    const bodyLibraryBufferToc = this.__cadAsset.getBodyLibrary().getToc()\r\n    const bodyLibraryBuffer = this.__cadAsset.getBodyLibrary().getBinaryBuffer()\r\n\r\n    const transferables = [surfacesDataBuffer, bodyLibraryBufferToc, bodyLibraryBuffer]\r\n    if (trimSetsBuffer) transferables.push(trimSetsBuffer)\r\n\r\n    const assemblyData = {\r\n      eventType: 'loadAssembly',\r\n      assetId: this.__assetId,\r\n      curvesDataBuffer,\r\n      surfacesDataBuffer,\r\n      cadDataVersion,\r\n      trimSetsBuffer,\r\n      lod: this.__cadAsset.getLOD(),\r\n      maxTexSize: this.__cadpassdata.maxTexSize / 2,\r\n      errorTolerance,\r\n      surfaceAreaThreshold,\r\n      trimTexelSize,\r\n      sceneBodyItemsData,\r\n      bodyLibraryBufferToc,\r\n      bodyLibraryBuffer,\r\n      highlightedBodies,\r\n    }\r\n    this.__postMessageToWorker(assemblyData, transferables)\r\n  }\r\n\r\n  updateBodyTexture(renderstate) {\r\n    const gl = this.__gl\r\n\r\n    const texId = this.__gl.TEXTURE0 + renderstate.boundTextures + 1\r\n    gl.activeTexture(texId)\r\n    gl.bindTexture(gl.TEXTURE_2D, this.__cadBodiesTexture.glTex)\r\n    const size = this.__cadBodiesTexture.width\r\n    for (let i = 0; i < this.__dirtyBodyIndices.length; i++) {\r\n      const bodyId = this.__dirtyBodyIndices[i]\r\n      const yoffset = Math.floor((bodyId * pixelsPerCADBody) / size)\r\n      const xoffset = (bodyId * pixelsPerCADBody) % size\r\n\r\n      const glCADBody = this.__cadBodies[bodyId]\r\n      glCADBody.updateCadBodyTex()\r\n\r\n      const width = pixelsPerCADBody\r\n      const height = 1\r\n\r\n      const cadBodyTextureDataByteOffset = bodyId * pixelsPerCADBody * 4 /*channels/pixel*/ * 4 /*bytes/channel*/\r\n      const cadBodyTextureData = new Float32Array(\r\n        this.cadBodiesTextureData.buffer,\r\n        cadBodyTextureDataByteOffset,\r\n        pixelsPerCADBody * 4 /*channels/pixel*/\r\n      )\r\n      this.__cadBodiesTexture.populate(cadBodyTextureData, width, height, xoffset, yoffset, false)\r\n    }\r\n    gl.bindTexture(gl.TEXTURE_2D, null)\r\n\r\n    this.__dirtyBodyIndices = []\r\n  }\r\n\r\n  /**\r\n   * The __postMessageToWorker method.\r\n   * @param {any} data - The data param.\r\n   * @param {any} transferables - The transferables param.\r\n   * @private\r\n   */\r\n  __postMessageToWorker(data, transferables) {\r\n    // if(this.__cadpassdata.debugMode) {\r\n    //   setTimeout(()=>{\r\n    //     GLCADAssetWorker_onmessage(data, this.__onWorkerMessage.bind(this));\r\n    //   },100);\r\n    // }\r\n    // else\r\n    {\r\n      if (!this.__worker) this.__worker = new GLCADAssetWorker()\r\n      this.__worker.onmessage = (event) => {\r\n        this.__onWorkerMessage(event.data) // loading done...\r\n      }\r\n      this.__worker.postMessage(data, this.__cadpassdata.debugMode ? [] : transferables)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The __onWorkerMessage method.\r\n   * @param {any} data - The data param.\r\n   * @private\r\n   */\r\n  __onWorkerMessage(data) {\r\n    switch (data.eventType) {\r\n      case 'loadAssetDone':\r\n        console.log('Layout Asset:', this.getCADAsset().getName(), data.profiling)\r\n\r\n        // ///////////////////////////////\r\n        // Curves, Surfaces and Trim Sets\r\n\r\n        // this.__gl.finish();\r\n\r\n        if (data.curvesAtlasLayout) {\r\n          this.__curveLibrary.evaluateCurves(\r\n            data.curvesAtlasLayout,\r\n            data.numCurves,\r\n            data.curvesAtlasLayoutTextureSize,\r\n            data.curvesAtlasTextureDim\r\n          )\r\n        }\r\n\r\n        // Note: rollup is generating radom problems in production builds\r\n        // values are getting assigned classes. The profiling values here\r\n        // become assigned class definitions, which then cause crashes or\r\n        // garbage logging\r\n        // Here, if we bundle the values into an object, then its ok.\r\n        // This is probably due to the use to WebWorkers this this file.\r\n        // We should try updating rollup and see if these hacks can be\r\n        // removed.\r\n        const values = {}\r\n\r\n        if (data.surfacesEvalAttrs) {\r\n          values.surfaceEvalTime = this.__surfaceLibrary.evaluateSurfaces(\r\n            data.surfacesEvalAttrs,\r\n            data.surfacesAtlasLayout,\r\n            data.surfacesAtlasLayoutTextureSize,\r\n            data.surfacesAtlasTextureDim\r\n          )\r\n        }\r\n\r\n        if (data.trimCurveDrawSets && data.trimSetAtlasTextureSize[0] > 0 && data.trimSetAtlasTextureSize[1] > 0) {\r\n          this.__trimSetLibrary.evaluateTrimSets(\r\n            data.trimCurveDrawSets,\r\n            data.trimSetAtlasTextureSize,\r\n            data.trimSetsAtlasLayoutData,\r\n            data.trimSetsAtlasLayoutTextureSize\r\n          )\r\n        }\r\n\r\n        // ///////////////////////////////\r\n        // Draw Items\r\n\r\n        this.__bodyAtlasDim = data.bodyAtlasDim\r\n        // this.updateDrawItems(data.evalDrawItemShaderAttribs)\r\n        this.updateDrawSets(values, data.surfaceDrawSets, data.curveDrawSets)\r\n        this.__ready = true\r\n\r\n        this.emit('loaded', {\r\n          numSurfaces: data.profiling.numSurfaces,\r\n          numSurfaceInstances: data.profiling.numSurfaceInstances,\r\n          surfaceEvalTime: values.surfaceEvalTime,\r\n          numBodies: data.profiling.numBodies,\r\n          numMaterials: this.__numMaterials,\r\n          numTriangles: values.numTriangles,\r\n          numDrawSets: values.numDrawSets,\r\n        })\r\n        this.emit('updated')\r\n        break\r\n      case 'highlightedSurfaceDrawSetsChanged':\r\n        for (const drawSetKey in data.highlightedSurfaceDrawSets) {\r\n          const drawSet = this.__surfaceDrawSets[drawSetKey]\r\n          if (!drawSet) {\r\n            console.warn('Selecting invalid items:', drawSetKey)\r\n            continue\r\n          }\r\n          drawSet.setDrawItems(data.highlightedSurfaceDrawSets[drawSetKey], 1)\r\n        }\r\n        this.incHighlightedCount(data.numHighlighted)\r\n        this.decHighlightedCount(data.numUnhighlighted)\r\n        this.emit('updated')\r\n        break\r\n    }\r\n\r\n    // if (data.lodChanges.length != 0){\r\n    //     const eachLODChange = (change)=>{\r\n    //         const glsurfacedrawItem = this.__glbodyItems[change.bodyIndex].glsurfacedrawItems[change.surfaceIndex];\r\n    //         glsurfacedrawItem.setLod(change.lod - 1);\r\n    //     }\r\n    //     // console.log(\"lodChanges:\" + data.lodChanges.length)\r\n    //     data.lodChanges.forEach(eachLODChange);\r\n    // }\r\n    // if (data.becomingInvisible.length != 0 || data.becomingVisible.length != 0){\r\n    //     const eachBecomingInvisibleChange = (change)=>{\r\n    //         // console.log(\"BecomingInvisible:\" + change.bodyIndex + \":\" + change.surfaceIndex);\r\n    //         const glsurfacedrawItem = this.__glbodyItems[change.bodyIndex].glsurfacedrawItems[change.surfaceIndex];\r\n    //         glsurfacedrawItem.setInvisible();\r\n    //     }\r\n    //     // console.log(\"becomingInvisible:\" + data.becomingInvisible.length)\r\n    //     data.becomingInvisible.forEach(eachBecomingInvisibleChange);\r\n\r\n    //     const eachBecomingVisibleChange = (change)=>{\r\n    //         // console.log(\"BecomingVisible:\" + change.bodyIndex + \":\" + change.surfaceIndex);\r\n    //         const glsurfacedrawItem = this.__glbodyItems[change.bodyIndex].glsurfacedrawItems[change.surfaceIndex];\r\n    //         glsurfacedrawItem.setVisible();\r\n    //     }\r\n    //     // console.log(\"becomingVisible:\" + data.becomingVisible.length)\r\n    //     data.becomingVisible.forEach(eachBecomingVisibleChange);\r\n    // }\r\n  }\r\n\r\n  /**\r\n   * The updateDrawItems method.\r\n   * @param {any} evalDrawItemShaderAttribs - The evalDrawItemShaderAttribs param.\r\n   */\r\n  updateDrawSets(values, surfaceDrawSets, curveDrawSets) {\r\n    values.numTriangles = 0\r\n    values.numDrawSets = 0\r\n\r\n    if (surfaceDrawSets) {\r\n      // eslint-disable-next-line guard-for-in\r\n      for (const drawSetKey in surfaceDrawSets) {\r\n        let drawSet = this.__surfaceDrawSets[drawSetKey]\r\n        // Note: on initialization, there are no draw sets, so\r\n        // we always construct the draw set here.\r\n        if (!drawSet) {\r\n          const parts = drawSetKey.split('x')\r\n          const detailX = parseInt(parts[0])\r\n          const detailY = parseInt(parts[1])\r\n          drawSet = new GLSurfaceDrawSet(this.__gl, detailX, detailY)\r\n          this.__surfaceDrawSets[drawSetKey] = drawSet\r\n        }\r\n\r\n        const drawSetData = surfaceDrawSets[drawSetKey]\r\n        // eslint-disable-next-line guard-for-in\r\n        for (const subSetKey in drawSetData) {\r\n          const drawItemsData = drawSetData[subSetKey]\r\n          values.numTriangles += drawSet.addDrawItems(drawItemsData, subSetKey)\r\n        }\r\n\r\n        values.numDrawSets++\r\n      }\r\n    }\r\n    if (curveDrawSets) {\r\n      // eslint-disable-next-line guard-for-in\r\n      for (const drawSetKey in curveDrawSets) {\r\n        let drawSet = this.__curveDrawSets[drawSetKey]\r\n        // Note: on initialization, there are no draw sets, so\r\n        // we always construct the draw set here.\r\n        if (!drawSet) {\r\n          const detail = parseInt(drawSetKey)\r\n          drawSet = new GLCurveDrawSet(this.__gl, detail)\r\n          this.__curveDrawSets[drawSetKey] = drawSet\r\n        }\r\n\r\n        const drawSetData = curveDrawSets[drawSetKey]\r\n        // eslint-disable-next-line guard-for-in\r\n        for (const subSetKey in drawSetData) {\r\n          const drawItemsData = drawSetData[subSetKey]\r\n          drawSet.addDrawItems(drawItemsData, subSetKey)\r\n        }\r\n\r\n        values.numDrawSets++\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The bindDrawItemsAtlas method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   */\r\n\r\n  bindDrawItemsAtlas(renderstate) {\r\n    this.__drawItemsTarget.bindColorTexture(renderstate, renderstate.unifs.drawItemsTexture)\r\n    // this.__drawItemsTexture.bindToUniform(renderstate, renderstate.unifs.drawItemsTexture);\r\n    if (renderstate.unifs.vert_drawItemsTextureSize) {\r\n      this.__gl.uniform2i(\r\n        renderstate.unifs.vert_drawItemsTextureSize.location,\r\n        this.__bodyAtlasDim[0],\r\n        this.__bodyAtlasDim[1]\r\n      )\r\n    }\r\n    if (renderstate.unifs.frag_drawItemsTextureSize) {\r\n      this.__gl.uniform2i(\r\n        renderstate.unifs.frag_drawItemsTextureSize.location,\r\n        this.__bodyAtlasDim[0],\r\n        this.__bodyAtlasDim[1]\r\n      )\r\n    }\r\n  }\r\n\r\n  bind(renderstate) {\r\n    const gl = this.__gl\r\n    const unifs = renderstate.unifs\r\n\r\n    // console.log(\"bind:\", Object.keys(unifs))\r\n\r\n    // this.bindDrawItemsAtlas(renderstate)\r\n    // if (unifs.drawItemsTexture) {\r\n    //   this.__drawItemsTarget.bindColorTexture(\r\n    //     renderstate,\r\n    //     unifs.drawItemsTexture\r\n    //   )\r\n    // }\r\n\r\n    if (unifs.vert_drawItemsTextureSize) {\r\n      this.__gl.uniform2i(unifs.vert_drawItemsTextureSize.location, this.__bodyAtlasDim[0], this.__bodyAtlasDim[1])\r\n    }\r\n    if (unifs.frag_drawItemsTextureSize) {\r\n      this.__gl.uniform2i(unifs.frag_drawItemsTextureSize.location, this.__bodyAtlasDim[0], this.__bodyAtlasDim[1])\r\n    }\r\n\r\n    if (unifs.bodyDescTexture) {\r\n      this.__bodyDescTexture.bindToUniform(renderstate, unifs.bodyDescTexture)\r\n      gl.uniform2i(unifs.bodyDescTextureSize.location, this.__bodyDescTexture.width, this.__bodyDescTexture.height)\r\n      if (unifs.bodyDescTextureSize_frag) {\r\n        gl.uniform2i(\r\n          unifs.bodyDescTextureSize_frag.location,\r\n          this.__bodyDescTexture.width,\r\n          this.__bodyDescTexture.height\r\n        )\r\n      }\r\n    }\r\n\r\n    if (unifs.cadBodiesTexture) {\r\n      this.__cadBodiesTexture.bindToUniform(renderstate, unifs.cadBodiesTexture)\r\n      if (unifs.cadBodiesTextureSize_vert)\r\n        gl.uniform1i(unifs.cadBodiesTextureSize_vert.location, this.__cadBodiesTexture.width)\r\n      if (unifs.cadBodiesTextureSize_frag)\r\n        gl.uniform1i(unifs.cadBodiesTextureSize_frag.location, this.__cadBodiesTexture.width)\r\n    }\r\n\r\n    // if (unifs.cutNormal) {\r\n    //   gl.uniform3fv(unifs.cutNormal.location, this.__cutNormal.asArray())\r\n    //   gl.uniform1f(unifs.planeDist.location, this.__cutDist)\r\n    //   if (unifs.cutColor) {\r\n    //     gl.uniform4fv(unifs.cutColor.location, this.__cutColor.asArray())\r\n    //   }\r\n    // }\r\n\r\n    if (unifs.assetCentroid) {\r\n      gl.uniform3fv(unifs.assetCentroid.location, this.__assetCentroid.asArray())\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The draw method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @return {any} - The return value.\r\n   */\r\n  draw(renderstate) {\r\n    if (!this.__visible || !this.__ready) return false\r\n\r\n    const boundTextures = renderstate.boundTextures\r\n\r\n    if (this.__dirtyBodyIndices.length > 0) {\r\n      this.updateBodyTexture(renderstate)\r\n    }\r\n\r\n    this.bind(renderstate)\r\n\r\n    if (!this.__surfaceLibrary.bindSurfacesAtlas(renderstate)) {\r\n      renderstate.boundTextures = boundTextures\r\n      return\r\n    }\r\n\r\n    if (this.__trimSetLibrary) {\r\n      this.__trimSetLibrary.bindTrimSetAtlasLayout(renderstate)\r\n      this.__trimSetLibrary.bindTrimSetAtlas(renderstate)\r\n    }\r\n\r\n    for (const key in this.__surfaceDrawSets) {\r\n      // console.log(\"draw:\" + key)\r\n      const drawSet = this.__surfaceDrawSets[key]\r\n      drawSet.draw(renderstate, renderstate.shaderId)\r\n    }\r\n\r\n    renderstate.boundTextures = boundTextures\r\n  }\r\n\r\n  /**\r\n   * The drawHighlightedGeoms method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @return {any} - The return value.\r\n   */\r\n  drawHighlightedGeoms(renderstate) {\r\n    if (!this.__visible || this.__numHighlightedGeoms == 0) return false\r\n\r\n    const boundTextures = renderstate.boundTextures\r\n\r\n    this.bind(renderstate)\r\n\r\n    this.__surfaceLibrary.bindSurfacesAtlas(renderstate)\r\n    if (this.__trimSetLibrary) {\r\n      this.__trimSetLibrary.bindTrimSetAtlasLayout(renderstate)\r\n      this.__trimSetLibrary.bindTrimSetAtlas(renderstate)\r\n    }\r\n\r\n    // Now draw the highlight outline.\r\n    const highlightOutlineID = 1\r\n    for (const key in this.__surfaceDrawSets) {\r\n      // console.log(\"draw:\" + key)\r\n      const drawSet = this.__surfaceDrawSets[key]\r\n      drawSet.draw(renderstate, highlightOutlineID)\r\n    }\r\n\r\n    renderstate.boundTextures = boundTextures\r\n  }\r\n\r\n  /**\r\n   * The drawNormals method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @param {any} shaderKey - The shaderKey param.\r\n   * @return {any} - The return value.\r\n   */\r\n  drawNormals(renderstate, shaderKey) {\r\n    if (!this.__visible || !this.__ready) return false\r\n\r\n    const boundTextures = renderstate.boundTextures\r\n    this.bind(renderstate)\r\n\r\n    this.__surfaceLibrary.bindSurfacesAtlas(renderstate)\r\n    if (this.__trimSetLibrary) {\r\n      this.__trimSetLibrary.bindTrimSetAtlasLayout(renderstate)\r\n      this.__trimSetLibrary.bindTrimSetAtlas(renderstate)\r\n    }\r\n\r\n    for (const key in this.__surfaceDrawSets) {\r\n      const drawSet = this.__surfaceDrawSets[key]\r\n      drawSet.drawNormals(renderstate, shaderKey)\r\n    }\r\n\r\n    renderstate.boundTextures = boundTextures\r\n  }\r\n\r\n  /**\r\n   * The drawEdges method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @param {any} shaderKey - The shaderKey param.\r\n   * @return {any} - The return value.\r\n   */\r\n  drawEdges(renderstate, shaderKey) {\r\n    if (!this.__visible || !this.__ready || !this.displayEdges) return false\r\n\r\n    const boundTextures = renderstate.boundTextures\r\n    if (this.__dirtyBodyIndices.length > 0) {\r\n      this.updateBodyTexture(renderstate)\r\n    }\r\n\r\n    this.bind(renderstate)\r\n    this.__curveLibrary.bindCurvesAtlas(renderstate)\r\n\r\n    const gl = this.__gl\r\n    gl.uniform4fv(renderstate.unifs.edgeColor.location, this.edgeColor)\r\n\r\n    for (const key in this.__curveDrawSets) {\r\n      const drawSet = this.__curveDrawSets[key]\r\n      drawSet.draw(renderstate, shaderKey)\r\n    }\r\n\r\n    renderstate.boundTextures = boundTextures\r\n  }\r\n\r\n  /**\r\n   * The drawGeomData method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @return {any} - The return value.\r\n   */\r\n  drawGeomData(renderstate) {\r\n    if (!this.__visible || !this.__ready) return false\r\n\r\n    const boundTextures = renderstate.boundTextures\r\n\r\n    this.bind(renderstate)\r\n\r\n    this.__surfaceLibrary.bindSurfacesAtlas(renderstate)\r\n    if (this.__trimSetLibrary) {\r\n      this.__trimSetLibrary.bindTrimSetAtlasLayout(renderstate)\r\n      this.__trimSetLibrary.bindTrimSetAtlas(renderstate)\r\n    }\r\n\r\n    const gl = this.__gl\r\n    const assetIndexUnif = renderstate.unifs.assetIndex\r\n    if (assetIndexUnif) {\r\n      gl.uniform1i(assetIndexUnif.location, this.__assetId)\r\n    }\r\n\r\n    for (const key in this.__surfaceDrawSets) {\r\n      // console.log(\"draw:\" + key)\r\n      const drawSet = this.__surfaceDrawSets[key]\r\n      drawSet.draw(renderstate, renderstate.shaderId)\r\n    }\r\n\r\n    renderstate.boundTextures = boundTextures\r\n  }\r\n\r\n  /**\r\n   * The getGeomItem method.\r\n   * @param {any} bodyId - The bodyId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getGeomItem(bodyId) {\r\n    return this.__cadBodies[bodyId].cadBody\r\n  }\r\n\r\n  /**\r\n   * The getSurfaceData method.\r\n   * @param {any} surfaceId - The surfaceId param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getSurfaceData(surfaceId) {\r\n    return this.__cadAsset.getSurfaceLibrary().getSurfaceData(surfaceId)\r\n  }\r\n\r\n  /**\r\n   * The getSurfaceData method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   */\r\n  drawSurfaceAtlas(renderstate) {\r\n    if (this.__surfaceLibrary) this.__surfaceLibrary.drawSurfaceAtlas(renderstate)\r\n  }\r\n\r\n  /**\r\n   * The drawTrimSets method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   */\r\n  drawTrimSets(renderstate) {\r\n    if (this.__trimSetLibrary) this.__trimSetLibrary.drawTrimSets(renderstate)\r\n  }\r\n\r\n  /**\r\n   * The destroy method.\r\n   */\r\n  destroy() {\r\n    this.__cadAsset.off('visibilityChanged', this.__assetVisibilityChanged)\r\n\r\n    this.__cadBodiesTexture.destroy()\r\n\r\n    this.__cadBodies.forEach((glCADBody) => glCADBody.destroy())\r\n    this.__cadBodies = []\r\n    this.__curveLibrary.destroy()\r\n    this.__surfaceLibrary.destroy()\r\n\r\n    if (this.__trimSetLibrary) {\r\n      this.__trimSetLibrary.destroy()\r\n    }\r\n\r\n    for (const drawSetKey in this.__surfaceDrawSets) {\r\n      let drawSet = this.__surfaceDrawSets[drawSetKey]\r\n      drawSet.destroy()\r\n    }\r\n  }\r\n}\r\n\r\nexport { GLCADAsset }\r\n","﻿import { EventEmitter, GrowingPacker, GLTexture2D, Registry } from '@zeainc/zea-engine'\r\n\r\n/** Class representing a GL CAD material library.\r\n * @ignore\r\n */\r\nclass GLCADMaterialLibrary extends EventEmitter {\r\n  /**\r\n   * Create a GL CAD material library.\r\n   * @param {any} gl - The gl value.\r\n   */\r\n  constructor(gl) {\r\n    super()\r\n    this.__gl = gl\r\n    this.__materialDatas = []\r\n    this.__dirtyIndices = []\r\n    this.__numItems = 0\r\n    this.__materialPacker = new GrowingPacker(256, 256)\r\n\r\n    this.__needsUpload = false\r\n  }\r\n\r\n  /**\r\n   * The addMaterial method.\r\n   * @param {any} material - The material param.\r\n   * @return {any} - The return value.\r\n   */\r\n  addMaterial(material) {\r\n    if (material.getMetadata('glmaterialcoords')) {\r\n      return\r\n    }\r\n\r\n    this.__numItems++\r\n\r\n    const coords = this.__materialPacker.addBlock({ w: 2, h: 1 })\r\n    const materialId = this.__materialDatas.length\r\n    this.__materialDatas.push({\r\n      material,\r\n      coords,\r\n    })\r\n\r\n    material.on('parameterValueChanged', () => {\r\n      // this.__renderer.requestRedraw();\r\n      this.__dirtyIndices.push(materialId)\r\n      this.emit('updated')\r\n    })\r\n\r\n    material.setMetadata('glmaterialcoords', coords)\r\n\r\n    this.__dirtyIndices.push(materialId)\r\n\r\n    return coords\r\n  }\r\n\r\n  /**\r\n   * The needsUpload method.\r\n   * @return {any} - The return value.\r\n   */\r\n  needsUpload() {\r\n    return this.__dirtyIndices.length > 0\r\n  }\r\n\r\n  /**\r\n   * The uploadMaterials method.\r\n   */\r\n  uploadMaterials() {\r\n    const gl = this.__gl\r\n    const width = this.__materialPacker.root.w\r\n    const height = this.__materialPacker.root.h\r\n    // console.log('Num Used Materials:' + this.__numItems, width, height)\r\n    if (!this.__materialsTexture) {\r\n      this.__materialsTexture = new GLTexture2D(gl, {\r\n        format: 'RGBA',\r\n        type: 'FLOAT',\r\n        width,\r\n        height,\r\n        filter: 'NEAREST',\r\n        wrap: 'CLAMP_TO_EDGE',\r\n        mipMapped: false,\r\n      })\r\n      this.__materialsTexture.clear()\r\n    } else if (this.__materialsTexture.width != width || this.__materialsTexture.height != height) {\r\n      throw new Error('Cannot resize here. Need a resize the preserves the data.')\r\n      this.__materialsTexture.resize(width, height)\r\n      this.__dirtyIndices = Array(this.__bodyDrawItems.length)\r\n        .fill()\r\n        .map((v, i) => i)\r\n    }\r\n\r\n    gl.bindTexture(gl.TEXTURE_2D, this.__materialsTexture.glTex)\r\n    const typeId = this.__materialsTexture.getTypeID()\r\n    const formatId = this.__materialsTexture.getFormatID()\r\n\r\n    const eachMaterial = (value) => {\r\n      const materialData = this.__materialDatas[value]\r\n      const material = materialData.material\r\n\r\n      let shaderClass = Registry.getBlueprint(material.getShaderName())\r\n      if (!shaderClass || !shaderClass.getPackedMaterialData) {\r\n        shaderClass = Registry.getBlueprint('GLDrawCADSurfaceShader')\r\n      }\r\n\r\n      const matData = shaderClass.getPackedMaterialData(material)\r\n\r\n      const width = matData.length / 4 // 4==RGBA pixels.\r\n      const height = 1\r\n\r\n      const coords = materialData.coords\r\n      if (typeId == gl.FLOAT) {\r\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, coords.x, coords.y, width, height, formatId, typeId, matData)\r\n      } else {\r\n        const unit16s = Math.convertFloat32ArrayToUInt16Array(matData)\r\n        gl.texSubImage2D(gl.TEXTURE_2D, 0, coords.x, coords.y, width, height, formatId, typeId, unit16s)\r\n      }\r\n    }\r\n    this.__dirtyIndices.forEach(eachMaterial)\r\n    this.__dirtyIndices = []\r\n    gl.bindTexture(gl.TEXTURE_2D, null)\r\n  }\r\n\r\n  /**\r\n   * The bind method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @return {any} - The return value.\r\n   */\r\n  bind(renderstate) {\r\n    if (!this.__materialsTexture) return false\r\n\r\n    const gl = this.__gl\r\n    const unifs = renderstate.unifs\r\n    if (unifs.materialsTexture) this.__materialsTexture.bindToUniform(renderstate, unifs.materialsTexture)\r\n    if (unifs.materialsTextureSize)\r\n      gl.uniform2i(unifs.materialsTextureSize.location, this.__materialsTexture.width, this.__materialsTexture.height)\r\n    return true\r\n  }\r\n}\r\nexport { GLCADMaterialLibrary }\r\n","import { shaderLibrary } from '@zeainc/zea-engine'\r\n\r\nshaderLibrary.setShaderModule(\r\n  'GLSLCADConstants.glsl',\r\n  `\r\n  const int SURFACE_FLAG_PERIODIC_U = 1; // 1<<0;\r\n  const int SURFACE_FLAG_PERIODIC_V = 2; // 1<<1;\r\n  const int SURFACE_FLAG_UNUSED2 = 4; // 1<<2;\r\n  const int SURFACE_FLAG_UNUSED3 = 8; // 1<<3;\r\n  const int SURFACE_FLAG_FLIPPED_NORMAL = 16; // 1<<4\r\n  const int SURFACE_FLAG_FLIPPED_UV = 32; // 1<<5\r\n  const int SURFACE_FLAG_COST_IS_DETAIL_U = 64; // 1<<6;\r\n  const int SURFACE_FLAG_COST_IS_DETAIL_V = 128; // 1<<7;\r\n\r\n  const int BODY_FLAG_CUTAWAY = 256; // 1<<8\r\n  const int BODY_FLAG_INVISIBLE = 512; // 1<<9\r\n\r\n  const int CURVE_FLAG_PERIODIC = 1; // 1<<0;\r\n  const int CURVE_FLAG_UNUSED2 = 4; // 1<<2;\r\n  const int CURVE_FLAG_COST_IS_DETAIL = 8;//1<<3;\r\n\r\n\r\n  const int SURFACE_TYPE_PLANE = 0;\r\n  const int SURFACE_TYPE_CONE = 1;\r\n  const int SURFACE_TYPE_CYLINDER = 2;\r\n  const int SURFACE_TYPE_SPHERE = 3;\r\n  const int SURFACE_TYPE_TORUS = 4;\r\n  const int SURFACE_TYPE_LINEAR_EXTRUSION = 5;\r\n  const int SURFACE_TYPE_REVOLUTION = 6;\r\n  const int SURFACE_TYPE_BEZIER_SURFACE = 7;\r\n  const int SURFACE_TYPE_NURBS_SURFACE = 8;\r\n  const int SURFACE_TYPE_OFFSET_SURFACE = 9;\r\n  const int SURFACE_TYPE_TRIMMED_RECT_SURFACE = 10;\r\n\r\n  const int SURFACE_TYPE_POLY_PLANE = 14;\r\n  const int SURFACE_TYPE_FAN = 15;\r\n  const int SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN = 16;\r\n\r\n\r\n  const int CURVE_TYPE_LINE = 20;\r\n  const int CURVE_TYPE_CIRCLE = 21;\r\n  const int CURVE_TYPE_ELIPSE = 22;\r\n  // const int CURVE_TYPE_HYPERBOLA = 23;\r\n  // const int CURVE_TYPE_PARABOLA = 24;\r\n  // const int CURVE_TYPE_BEZIERCURVE = 25;\r\n  const int CURVE_TYPE_NURBS_CURVE = 26;\r\n  // const int CURVE_TYPE_OFFSET_CURVE = 27;\r\n  // const int CURVE_TYPE_TRIMMED_CURVE = 28;\r\n\r\n\r\n  const int geomLibraryHeaderSize = 4; // 2 pixels at the start of the GeomLibrary and CurveLibrary\r\n\r\n  // [bodyDescId, surfaceId, cadBodyDesc.xy], [glmaterialcoords.xy][tr-xyz], [ori], [sc], [highlight], [cutPlane]\r\n  const int pixelsPerCADBody = 7;\r\n`\r\n)\r\n","import { shaderLibrary } from '@zeainc/zea-engine'\r\n\r\nshaderLibrary.setShaderModule(\r\n  'GLSLCADGeomDrawing.vertexShader.glsl',\r\n  `\r\n\r\n\r\nuniform sampler2D cadBodiesTexture;\r\nuniform int cadBodiesTextureSize_vert;\r\n  \r\nvec4 getCADBodyPixel(int cadBodyId, int pixelOffset) {\r\n  int offset = cadBodyId * pixelsPerCADBody;\r\n  ivec2 start;\r\n  start.y += offset / cadBodiesTextureSize_vert;\r\n  start.x = imod(offset, cadBodiesTextureSize_vert);\r\n  return fetchTexel(cadBodiesTexture, ivec2(cadBodiesTextureSize_vert), ivec2(start.x + pixelOffset, start.y));\r\n}\r\n\r\n<%include file=\"GLSLMath.glsl\"/>\r\n<%include file=\"GLSLBinReader.glsl\"/>\r\n\r\n\r\nconst int pixelsPerDrawItem = 10; // The number of RGBA pixels per draw item.\r\nconst int valuesPerSurfaceTocItem = 9;\r\nconst int bytesPerValue = 4; // 32 bit floats\r\n\r\n// Before enabling this, enable the 2nd vertex attribute (drawItemTexAddr)\r\n// in the Draw shader and in the GLDrawSet, and in the GLCADAssetWorker\r\n#define CALC_GLOBAL_XFO_DURING_DRAW\r\n#ifdef CALC_GLOBAL_XFO_DURING_DRAW\r\n\r\nmat4 getCADBodyMatrix(int cadBodyId) {\r\n  vec3 body_tr = getCADBodyPixel(cadBodyId, 2).rgb;\r\n  vec4 body_ori = normalize(getCADBodyPixel(cadBodyId, 3));\r\n  vec3 body_sc = getCADBodyPixel(cadBodyId, 4).rgb;\r\n  Xfo bodyXfo = Xfo(body_tr, body_ori, body_sc);\r\n  return xfo_toMat4(bodyXfo);\r\n  // return mat4(1.0);\r\n}\r\n\r\nuniform sampler2D bodyDescTexture;\r\nuniform ivec2 bodyDescTextureSize;\r\n\r\nGLSLBinReader setupBodyDescReader(ivec2 bodyDescAddr) {\r\n  GLSLBinReader bodyDescReader;\r\n  ivec4 region = ivec4(0, 0, bodyDescTextureSize.x, bodyDescTextureSize.y);\r\n  ivec2 start = ivec2(bodyDescAddr.x, bodyDescAddr.y);\r\n  GLSLBinReader_init(bodyDescReader, bodyDescTextureSize, region, start, 32);\r\n  return bodyDescReader;\r\n}\r\n\r\nXfo getDrawItemXfo(ivec2 bodyDescAddr, int drawItemIndexInBody) {\r\n  GLSLBinReader bodyDescReader = setupBodyDescReader(bodyDescAddr);\r\n  \r\n  // Skip over the bbox, numSurfaces and then to the current surface data.  \r\n  #ifdef ENABLE_BODY_EDGES\r\n  int offsetOfItemRef = (6/*bbox*/) + (1/*numSurfaces*/) + (1/*numCurves*/) + (drawItemIndexInBody * (1/*id*/ + 10/*xfo*/));\r\n  #else\r\n  int offsetOfItemRef = (6/*bbox*/) + (1/*numSurfaces*/) + (drawItemIndexInBody * (1/*id*/ + 10/*xfo*/));\r\n  #endif\r\n  #ifdef ENABLE_PER_FACE_COLORS\r\n  offsetOfItemRef += drawItemIndexInBody * 4/*color*/; // Skip over the color.\r\n  #endif\r\n  \r\n  vec3 surface_tr = vec3(\r\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+1),\r\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+2),\r\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+3)\r\n    );\r\n\r\n  vec4 surface_ori = normalize(vec4(\r\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+4),\r\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+5),\r\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+6),\r\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+7)\r\n    ));\r\n\r\n  vec3 surface_sc = vec3(\r\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+8),\r\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+9),\r\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+10)\r\n  );\r\n\r\n  Xfo surfaceXfo = Xfo(surface_tr, surface_ori, surface_sc);\r\n  return surfaceXfo;\r\n\r\n}\r\nmat4 getDrawItemMatrix(ivec2 bodyDescAddr, int drawItemIndexInBody) {\r\n  return xfo_toMat4(getDrawItemXfo(bodyDescAddr, drawItemIndexInBody));\r\n  // return mat4(1.0);\r\n}\r\n\r\n#else // CALC_GLOBAL_XFO_DURING_DRAW\r\n\r\nuniform sampler2D drawItemsTexture;\r\nuniform ivec2 vert_drawItemsTextureSize;\r\n\r\n// The Draw Items texture is laid out with 8 pixels per draw item.\r\nvec4 getDrawItemData(int offset) {\r\n  return fetchTexel(drawItemsTexture, vert_drawItemsTextureSize, ivec2(ftoi(drawItemTexAddr.x) + offset, ftoi(drawItemTexAddr.y)));\r\n}\r\n\r\nmat4 getModelMatrix() {\r\n  // Unpack 3 x 4 matix columns into a 4 x 4 matrix.\r\n  vec4 col0 = getDrawItemData(0);\r\n  vec4 col1 = getDrawItemData(1);\r\n  vec4 col2 = getDrawItemData(2);\r\n  mat4 result = mat4(col0, col1, col2, vec4(0.0, 0.0, 0.0, 1.0));\r\n  return transpose(result);\r\n}\r\n\r\n#endif // CALC_GLOBAL_XFO_DURING_DRAW\r\n\r\n  `\r\n)\r\nshaderLibrary.setShaderModule(\r\n  'GLSLCADSurfaceDrawing.vertexShader.glsl',\r\n  `\r\n  \r\n<%include file=\"GLSLCADGeomDrawing.vertexShader.glsl\"/>\r\n\r\n\r\n// GEOM\r\nuniform sampler2D surfaceAtlasLayoutTexture;\r\nuniform ivec2 surfaceAtlasLayoutTextureSize;\r\n\r\nuniform sampler2D surfacesAtlasTexture;\r\nuniform ivec2 surfacesAtlasTextureSize;\r\nuniform sampler2D normalsTexture;\r\n\r\nvec4 getSurfaceVertex(vec2 surfacePatchCoords, vec2 vertexCoord) {\r\n  return fetchTexel(surfacesAtlasTexture, surfacesAtlasTextureSize, ivec2(ftoi(surfacePatchCoords.x + vertexCoord.x), ftoi(surfacePatchCoords.y + vertexCoord.y)));\r\n}\r\n\r\nvec3 getSurfaceNormal(vec2 surfacePatchCoords, vec2 vertexCoord) {\r\n  return fetchTexel(normalsTexture, surfacesAtlasTextureSize, ivec2(ftoi(surfacePatchCoords.x + vertexCoord.x), ftoi(surfacePatchCoords.y + vertexCoord.y))).rgb;\r\n}\r\n\r\n`\r\n)\r\n\r\nshaderLibrary.setShaderModule(\r\n  'GLSLCADGeomDrawing.fragmentShader.glsl',\r\n  `\r\n  uniform sampler2D cadBodiesTexture;\r\n  uniform int cadBodiesTextureSize_frag;\r\n  \r\n  vec4 getCADBodyPixel(int cadBodyId, int pixelOffset) {\r\n    \r\n    int offset = cadBodyId * pixelsPerCADBody;\r\n    ivec2 start;\r\n    start.y += offset / cadBodiesTextureSize_frag;\r\n    start.x = imod(offset, cadBodiesTextureSize_frag);\r\n  \r\n    return fetchTexel(cadBodiesTexture, ivec2(cadBodiesTextureSize_frag), ivec2(start.x + pixelOffset, start.y));\r\n  }\r\n  \r\n  // Is this still used?\r\n  uniform sampler2D drawItemsTexture;\r\n  uniform ivec2 frag_drawItemsTextureSize;\r\n  // The Draw Items texture is laid out with 8 pixels per draw item.\r\n  vec4 getDrawItemData(int offset) {\r\n    return fetchTexel(drawItemsTexture, frag_drawItemsTextureSize, ivec2(ftoi(v_drawCoords.x) + offset, ftoi(v_drawCoords.y)));\r\n  }\r\n  \r\n  \r\n\r\n//////////////////////////////////////////////\r\n// Cutaways\r\n\r\n<%include file=\"cutaways.glsl\"/>\r\n\r\n// bool applyCutaway(int cadBodyId, int flags) {\r\n//   if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\r\n//     vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\r\n//     vec3 cutNormal = cadBodyPixel6.xyz;\r\n//     float cutPlaneDist = cadBodyPixel6.w;\r\n//     if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\r\n//         discard;\r\n//     }\r\n//     return true;\r\n//   }\r\n//   return false;\r\n// }\r\n\r\n// int applyCutaway(int flags, bool backFacing, vec3 cutColor, inout vec4 fragColor) {\r\n//   bool cut = testFlag(flags, BODY_FLAG_CUTAWAY);\r\n//   if(cut){\r\n//     if(cutaway(v_worldPos, cutNormal, planeDist)) {\r\n//       return 1;\r\n//     }\r\n//     if(backFacing){\r\n//       fragColor = vec4(cutColor, 1.0);\r\n//       return 2;\r\n//     }\r\n//   }\r\n//   return 0;\r\n// }\r\n  `\r\n)\r\nshaderLibrary.setShaderModule(\r\n  'GLSLCADSurfaceDrawing.fragmentShader.glsl',\r\n  `\r\n  \r\n<%include file=\"GLSLCADGeomDrawing.fragmentShader.glsl\"/>\r\n\r\n\r\nuniform sampler2D materialsTexture;\r\nuniform ivec2 materialsTextureSize;\r\n\r\nvec4 getMaterialValue(vec2 materialCoords, int valueIndex) {\r\n  return fetchTexel(materialsTexture, materialsTextureSize, ivec2(ftoi(materialCoords.x) + valueIndex, ftoi(materialCoords.y)));\r\n}\r\n\r\n\r\n//////////////////////////////////////////////\r\n// Surface Colors\r\n\r\nuniform sampler2D bodyDescTexture;\r\nuniform ivec2 bodyDescTextureSize_frag;\r\n\r\nGLSLBinReader setupBodyDescReader(ivec2 bodyDescAddr) {\r\n  GLSLBinReader bodyDescReader;\r\n  ivec4 region = ivec4(0, 0, bodyDescTextureSize_frag.x, bodyDescTextureSize_frag.y);\r\n  ivec2 start = ivec2(bodyDescAddr.x, bodyDescAddr.y);\r\n  GLSLBinReader_init(bodyDescReader, bodyDescTextureSize_frag, region, start, 32);\r\n  return bodyDescReader;\r\n}\r\n\r\nvec4 getDrawItemColor(ivec2 bodyDescAddr, int drawItemIndexInBody) {\r\n  GLSLBinReader bodyDescReader = setupBodyDescReader(bodyDescAddr);\r\n  \r\n  #ifdef ENABLE_BODY_EDGES\r\n  int offsetOfItemRef = (6/*bbox*/) + (1/*numSurfaces*/) + (1/*numCurves*/) + (drawItemIndexInBody * (1/*id*/ + 10/*xfo*/ + 4/*color*/));\r\n  #else\r\n  int offsetOfItemRef = (6/*bbox*/) + (1/*numSurfaces*/) + (drawItemIndexInBody * (1/*id*/ + 10/*xfo*/ + 4/*color*/));\r\n  #endif\r\n\r\n  vec4 color = vec4(\r\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+11),\r\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+12),\r\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+13),\r\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+14)\r\n  );\r\n\r\n  return color;\r\n}\r\n\r\n//////////////////////////////////////////////\r\n// Trimming\r\nuniform sampler2D trimSetsAtlasLayoutTexture;\r\nuniform ivec2 trimSetsAtlasLayoutTextureSize;\r\n\r\nuniform sampler2D trimSetAtlasTexture;\r\nuniform ivec2 trimSetAtlasTextureSize;\r\n\r\nbool applyTrim(vec4 trimPatchQuad, inout vec3 trimCoords, int flags) {\r\n  if(trimPatchQuad.z > 0.0 && trimPatchQuad.w > 0.0){\r\n    // Remove cobwebs along borders.\r\n    // Tis appears to eliminate cobwebs along borders of trim sets. \r\n    // It does indicate that a math eror exists somewhere else\r\n    // that we would get cobwebs here.\r\n    // To repro, load Dead Eye Bearing and zoom out.\r\n    if (v_textureCoord.x < 0.0 || v_textureCoord.x >= 1.0 || v_textureCoord.y < 0.0 || v_textureCoord.y >= 1.0)\r\n      return true;\r\n\r\n    trimCoords.xy = trimPatchQuad.xy + (trimPatchQuad.zw * v_textureCoord);\r\n\r\n    vec2 trimUv = (trimCoords.xy) / vec2(trimSetAtlasTextureSize);\r\n    vec4 trimTexel = texture2D(trimSetAtlasTexture, trimUv);\r\n\r\n    trimCoords.z = max(trimTexel.r, trimTexel.g);\r\n    \r\n    if (trimTexel.r < 0.5 || trimTexel.g < 0.5) {\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  else {\r\n    // This is a non-trimmed surface, so return false.\r\n    trimCoords = vec3(-1.0);\r\n    return false;\r\n  }\r\n}\r\n\r\n\r\n`\r\n)\r\n","import { GLShader } from '@zeainc/zea-engine'\n/** Class representing a GL CAD shader.\n * @extends GLShader\n * @ignore\n */\nclass GLCADShader extends GLShader {\n  /**\n   * Create a GL CAD shader.\n   * @param {any} gl - The gl value.\n   */\n  constructor(gl) {\n    super(gl)\n    this.stack = [{}]\n  }\n\n  /**\n   * The setPreprocessorValue method.\n   * @param {any} name - The name param.\n   */\n  setPreprocessorValue(name) {\n    this.getState()[name] = name\n  }\n\n  /**\n   * The clearPreprocessorValue method.\n   * @param {any} name - The name param.\n   */\n  clearPreprocessorValue(name) {\n    delete this.getState()[name]\n  }\n\n  /**\n   * The getState method.\n   * @return {any} - The return value.\n   */\n  getState() {\n    return this.stack[this.stack.length - 1]\n  }\n\n  /**\n   * The pushState method.\n   */\n  pushState() {\n    this.stack.push(Object.assign({}, this.getState()))\n  }\n\n  /**\n   * The popState method.\n   */\n  popState() {\n    this.stack.pop()\n    this.applyOptions()\n  }\n\n  /**\n   * The applyOptions method.\n   */\n  applyOptions() {\n    const directives = [...this.__gl.shaderopts.directives]\n    const state = this.getState()\n    for (const key in state) {\n      directives.push(state[key])\n    }\n    const defines = directives.join('\\n') + '\\n'\n    this.__key = defines\n    this.compileForTarget(this.__key, {\n      directives,\n    })\n  }\n\n  /**\n   * The bind method.\n   * @param {any} renderstate - The renderstate param.\n   * @return {any} - The return value.\n   */\n  bind(renderstate) {\n    return super.bind(renderstate, this.__key)\n  }\n}\n\nexport { GLCADShader }\n","import { shaderLibrary, GLShader, Registry } from '@zeainc/zea-engine'\r\nimport './GLSLCADConstants.js'\r\nimport './GLSLMath.js'\r\nimport './GLSLCADSurfaceDrawing.js'\r\n\r\nconst GLDrawCADSurfaceNormalsShader_VERTEX_SHADER = `\r\nprecision highp float;\r\n\r\nattribute vec3 positions;\r\ninstancedattribute vec4 drawCoords;  // (DrawItemData Coords (x, y) \r\n// instancedattribute vec2 drawItemTexAddr;  // Address of the data in the draw item texture. (mat4)\r\n\r\nuniform mat4 viewMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform ivec2 quadDetail;\r\nuniform vec3 assetCentroid;\r\nuniform float normalLength;\r\n\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n<%include file=\"GLSLCADConstants.glsl\"/>\r\n<%include file=\"stack-gl/transpose.glsl\"/>\r\n<%include file=\"stack-gl/inverse.glsl\"/>\r\n\r\n<%include file=\"GLSLCADSurfaceDrawing.vertexShader.glsl\"/>\r\n\r\nvarying vec4 v_drawCoords;\r\nvarying vec3 v_viewPos;\r\nvarying vec3 v_worldPos;\r\nvarying vec3 v_viewNormal;\r\nvarying vec2 v_textureCoord;\r\n\r\nvoid main(void) {\r\n    int cadBodyId = ftoi(drawCoords.r);\r\n    int drawItemIndexInBody = ftoi(drawCoords.g);\r\n    int surfaceId = ftoi(drawCoords.b);\r\n    int trimSetId = ftoi(drawCoords.a);\r\n\r\n    vec2 texCoords = positions.xy + 0.5;\r\n    \r\n    v_drawCoords = drawCoords;\r\n\r\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\r\n    vec4 cadBodyPixel1 = getCADBodyPixel(cadBodyId, 1);\r\n\r\n    // int bodyDescId = ftoi(cadBodyPixel0.r);\r\n    int cadBodyFlags = ftoi(cadBodyPixel0.g);\r\n    \r\n    //////////////////////////////////////////////\r\n    // Visibility\r\n    if(testFlag(cadBodyFlags, BODY_FLAG_INVISIBLE)) {\r\n        gl_Position = vec4(-3.0, -3.0, -3.0, 1.0);;\r\n        return;\r\n    }\r\n\r\n    //////////////////////////////////////////////\r\n    // Transforms\r\n#ifdef DEBUG_SURFACES\r\n    mat4 modelMatrix = mat4(1.0);\r\n    // if(v_surfaceType == SURFACE_TYPE_NURBS_SURFACE) {\r\n    //     // int drawItemIndexInBody = int(metadata.b+0.5);\r\n    //     int sideLen = int(ceil(sqrt(float(numSurfacesInLibrary))));\r\n    //     int x = drawItemIndexInBody % sideLen;\r\n    //     int y = drawItemIndexInBody / sideLen;\r\n    //     modelMatrix = mat4(1.0, 0.0, 0.0, 0.0, \r\n    //                     0.0, 1.0, 0.0, 0.0, \r\n    //                     0.0, 0.0, 1.0, 0.0,  \r\n    //                     float(x), float(y), 0.0, 1.0);\r\n    // }\r\n#else\r\n\r\n#ifdef CALC_GLOBAL_XFO_DURING_DRAW\r\n    mat4 bodyMat = getCADBodyMatrix(cadBodyId);\r\n    ivec2 bodyDescAddr = ftoi(cadBodyPixel0.ba);\r\n    mat4 surfaceMat = getDrawItemMatrix(bodyDescAddr, drawItemIndexInBody);\r\n    mat4 modelMatrix = bodyMat * surfaceMat;\r\n#else\r\n    mat4 modelMatrix = getModelMatrix();\r\n    // Note: on mobile GPUs, we get only FP16 math in the\r\n    // fragment shader, causing inaccuracies in modelMatrix\r\n    // calculation. By offsetting the data to the origin\r\n    // we calculate a modelMatrix in the asset space, and\r\n    //  then add it back on during final drawing.\r\n    // modelMatrix[3][0] += assetCentroid.x;\r\n    // modelMatrix[3][1] += assetCentroid.y;\r\n    // modelMatrix[3][2] += assetCentroid.z;\r\n#endif\r\n#endif\r\n    // modelMatrix = mat4(1.0);\r\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\r\n    mat4 viewProjectionMatrix = projectionMatrix * viewMatrix;\r\n\r\n    //////////////////////////////////////////////\r\n    // Vertex Attributes\r\n    \r\n    GLSLBinReader surfaceLayoutDataReader;\r\n    GLSLBinReader_init(surfaceLayoutDataReader, surfaceAtlasLayoutTextureSize, 16);\r\n    vec4 surfaceDataAddr = GLSLBinReader_readVec4(surfaceLayoutDataReader, surfaceAtlasLayoutTexture, surfaceId * 8);\r\n    int surfaceFlags = GLSLBinReader_readInt(surfaceLayoutDataReader, surfaceAtlasLayoutTexture, surfaceId * 8 + 6);\r\n\r\n    bool isFan = int(quadDetail.y) == 0;\r\n    vec2 vertexCoords = texCoords * (isFan ? vec2(quadDetail) + vec2(1.0, 1.0) : vec2(quadDetail));\r\n\r\n    vec3 normal = getSurfaceNormal(surfaceDataAddr.xy, vertexCoords);\r\n    vec4 pos = vec4(getSurfaceVertex(surfaceDataAddr.xy, vertexCoords).rgb, 1.0);\r\n\r\n    bool flippedNormal = testFlag(surfaceFlags, SURFACE_FLAG_FLIPPED_NORMAL);\r\n    if(flippedNormal){\r\n        normal = -normal;\r\n    }\r\n  \r\n    vec4 worldPos = modelMatrix * pos;\r\n    vec3 worldNormal = normalize(mat3(modelMatrix) * normal);\r\n\r\n    // if (positions.z > 0.5)\r\n    //   worldPos = vec4(vec3(0.0), 1.0);\r\n    worldPos += vec4(worldNormal * positions.z * normalLength, 0.0);\r\n    \r\n    gl_Position = viewProjectionMatrix * worldPos;\r\n\r\n    \r\n    v_textureCoord = texCoords;\r\n    if(testFlag(surfaceFlags, SURFACE_FLAG_FLIPPED_UV))\r\n        v_textureCoord = vec2(v_textureCoord.y, v_textureCoord.x);\r\n\r\n    // v_textureCoord.y = 1.0 - v_textureCoord.y; // Flip y\r\n}`\r\n\r\nconst FRAGMENT_SHADER = `\r\nprecision highp float;\r\n\r\n<%include file=\"GLSLCADConstants.glsl\"/>\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n<%include file=\"stack-gl/gamma.glsl\"/>\r\n<%include file=\"materialparams.glsl\"/>\r\n<%include file=\"GLSLBinReader.glsl\"/>\r\n\r\nuniform color BaseColor;\r\n\r\nuniform mat4 cameraMatrix;\r\n\r\nvarying vec4 v_drawCoords;\r\nvarying vec3 v_viewPos;\r\nvarying vec3 v_worldPos;\r\nvarying vec3 v_viewNormal;\r\nvarying vec2 v_textureCoord;\r\n\r\n<%include file=\"GLSLCADSurfaceDrawing.fragmentShader.glsl\"/>\r\n\r\n#ifdef ENABLE_ES3\r\nout vec4 fragColor;\r\n#endif\r\n\r\nvoid main(void) {\r\n\r\n#ifndef ENABLE_ES3\r\n    vec4 fragColor;\r\n#endif\r\n\r\n    int cadBodyId = int(floor(v_drawCoords.r + 0.5));\r\n    int drawItemIndexInBody = int(floor(v_drawCoords.g + 0.5));\r\n    int surfaceId = int(floor(v_drawCoords.b + 0.5));\r\n    int trimSetId = int(floor(v_drawCoords.a + 0.5));\r\n\r\n    // TODO: pass as varying from pixel shader.\r\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\r\n    int flags = int(floor(cadBodyPixel0.g + 0.5));\r\n            \r\n\r\n    //////////////////////////////////////////////\r\n    // Cutaways\r\n    if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\r\n        vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\r\n        vec3 cutNormal = cadBodyPixel6.xyz;\r\n        float cutPlaneDist = cadBodyPixel6.w;\r\n        if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\r\n            discard;\r\n        }\r\n    }\r\n\r\n    //////////////////////////////////////////////\r\n    // Trimming\r\n    vec4 trimPatchQuad;\r\n    vec3 trimCoords;\r\n    if(trimSetId >= 0) {\r\n        GLSLBinReader trimsetLayoutDataReader;\r\n        GLSLBinReader_init(trimsetLayoutDataReader, trimSetsAtlasLayoutTextureSize, 16);\r\n        trimPatchQuad = GLSLBinReader_readVec4(trimsetLayoutDataReader, trimSetsAtlasLayoutTexture, trimSetId*4);\r\n\r\n        if(applyTrim(trimPatchQuad, trimCoords, flags)){\r\n            discard;\r\n            return;\r\n        }\r\n    }\r\n\r\n    vec4 baseColor      = vec4(1.0,0.0,0.0,1.0);\r\n\r\n//#ifdef ENABLE_INLINE_GAMMACORRECTION\r\n    fragColor.rgb = toGamma(baseColor.rgb);\r\n//#endif\r\n\r\n}\r\n`\r\n\r\nimport { GLCADShader } from './GLCADShader.js'\r\n\r\n/** Class representing a GL draw CAD surface normals shader.\r\n * @extends GLCADShader\r\n * @ignore\r\n */\r\nclass GLDrawCADSurfaceNormalsShader extends GLCADShader {\r\n  /**\r\n   * Create a GL draw CAD surface normals shader.\r\n   * @param {any} gl - The gl value.\r\n   */\r\n  constructor(gl) {\r\n    super(gl)\r\n\r\n    this.setShaderStage('VERTEX_SHADER', GLDrawCADSurfaceNormalsShader_VERTEX_SHADER)\r\n    this.setShaderStage('FRAGMENT_SHADER', FRAGMENT_SHADER)\r\n    this.nonSelectable = true\r\n  }\r\n\r\n  /**\r\n   * The getParamDeclarations method.\r\n   * @return {any} - The return value.\r\n   */\r\n  static getParamDeclarations() {\r\n    const paramDescs = super.getParamDeclarations()\r\n    paramDescs.push({\r\n      name: 'BaseColor',\r\n      defaultValue: new Color(1.0, 1.0, 0.5),\r\n    })\r\n    return paramDescs\r\n  }\r\n}\r\n\r\nRegistry.register('GLDrawCADSurfaceNormalsShader', GLDrawCADSurfaceNormalsShader)\r\n\r\nexport { GLDrawCADSurfaceNormalsShader_VERTEX_SHADER, GLDrawCADSurfaceNormalsShader }\r\n","/* eslint-disable camelcase */\r\nimport { Color, Registry } from '@zeainc/zea-engine'\r\nimport './GLSLCADConstants.js'\r\nimport './GLSLMath.js'\r\nimport './GLSLCADSurfaceDrawing.js'\r\n\r\nconst GLDrawCADSurfaceShader_VERTEX_SHADER = `\r\nprecision highp float;\r\n\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n<%include file=\"GLSLCADConstants.glsl\"/>\r\n<%include file=\"stack-gl/transpose.glsl\"/>\r\n<%include file=\"stack-gl/inverse.glsl\"/>\r\n\r\nattribute vec3 positions;\r\ninstancedattribute vec4 drawCoords;  // body ID, Surface index in Body, Surface Id, TrimSet Id\r\n// instancedattribute vec2 drawItemTexAddr;  // Address of the data in the draw item texture. (mat4)\r\n\r\nuniform mat4 viewMatrix;\r\nuniform mat4 cameraMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform ivec2 quadDetail;\r\nuniform vec3 assetCentroid;\r\n\r\n// #define DEBUG_SURFACES\r\nuniform int numSurfacesInLibrary;\r\n\r\n\r\n<%include file=\"GLSLCADSurfaceDrawing.vertexShader.glsl\"/>\r\n\r\nvarying vec4 v_drawCoords;\r\nvarying vec3 v_viewPos;\r\nvarying vec3 v_worldPos;\r\nvarying vec3 v_viewNormal;\r\nvarying vec2 v_textureCoord;\r\nvarying vec3 v_bodyDescAddr;\r\nvarying float v_surfaceType;\r\nvarying vec2 v_quadDetail;\r\n\r\nvoid main(void) {\r\n    int cadBodyId = ftoi(drawCoords.r);\r\n    int drawItemIndexInBody = ftoi(drawCoords.g);\r\n    int surfaceId = ftoi(drawCoords.b);\r\n    int trimSetId = ftoi(drawCoords.a);\r\n\r\n    vec2 texCoords = positions.xy + 0.5;\r\n    \r\n    v_drawCoords = drawCoords;\r\n\r\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\r\n    vec4 cadBodyPixel1 = getCADBodyPixel(cadBodyId, 1);\r\n\r\n    // int bodyDescId = ftoi(cadBodyPixel0.r);\r\n    int cadBodyFlags = ftoi(cadBodyPixel0.g);\r\n    \r\n    //////////////////////////////////////////////\r\n    // Visibility\r\n    if(testFlag(cadBodyFlags, BODY_FLAG_INVISIBLE)) {\r\n        gl_Position = vec4(-3.0, -3.0, -3.0, 1.0);;\r\n        return;\r\n    }\r\n\r\n    //////////////////////////////////////////////\r\n    // Transforms\r\n#ifdef DEBUG_SURFACES\r\n    mat4 modelMatrix = mat4(1.0);\r\n    // if(v_surfaceType == SURFACE_TYPE_NURBS_SURFACE) {\r\n    //     // int drawItemIndexInBody = int(metadata.b+0.5);\r\n    //     int sideLen = int(ceil(sqrt(float(numSurfacesInLibrary))));\r\n    //     int x = drawItemIndexInBody % sideLen;\r\n    //     int y = drawItemIndexInBody / sideLen;\r\n    //     modelMatrix = mat4(1.0, 0.0, 0.0, 0.0, \r\n    //                     0.0, 1.0, 0.0, 0.0, \r\n    //                     0.0, 0.0, 1.0, 0.0,  \r\n    //                     float(x), float(y), 0.0, 1.0);\r\n    // }\r\n#else\r\n\r\n#ifdef CALC_GLOBAL_XFO_DURING_DRAW\r\n    mat4 bodyMat = getCADBodyMatrix(cadBodyId);\r\n    ivec2 bodyDescAddr = ftoi(cadBodyPixel0.ba);\r\n    v_bodyDescAddr.xy = vec2(float(bodyDescAddr.x), float(bodyDescAddr.y));\r\n    v_bodyDescAddr.z = float(drawItemIndexInBody);\r\n    mat4 surfaceMat = getDrawItemMatrix(bodyDescAddr, drawItemIndexInBody);\r\n    mat4 modelMatrix = bodyMat * surfaceMat;\r\n#else\r\n    mat4 modelMatrix = getModelMatrix();\r\n    // Note: on mobile GPUs, we get only FP16 math in the\r\n    // fragment shader, causing inaccuracies in modelMatrix\r\n    // calculation. By offsetting the data to the origin\r\n    // we calculate a modelMatrix in the asset space, and\r\n    //  then add it back on during final drawing.\r\n    // modelMatrix[3][0] += assetCentroid.x;\r\n    // modelMatrix[3][1] += assetCentroid.y;\r\n    // modelMatrix[3][2] += assetCentroid.z;\r\n#endif\r\n#endif\r\n    // modelMatrix = mat4(1.0);\r\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\r\n    mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));\r\n\r\n    //////////////////////////////////////////////\r\n    // Vertex Attributes\r\n    \r\n    GLSLBinReader surfaceLayoutDataReader;\r\n    GLSLBinReader_init(surfaceLayoutDataReader, surfaceAtlasLayoutTextureSize, 16);\r\n    vec4 surfaceDataAddr = GLSLBinReader_readVec4(surfaceLayoutDataReader, surfaceAtlasLayoutTexture, surfaceId * 8);\r\n    int surfaceFlags = GLSLBinReader_readInt(surfaceLayoutDataReader, surfaceAtlasLayoutTexture, surfaceId * 8 + 6);\r\n\r\n    bool isFan = int(quadDetail.y) == 0;\r\n    vec2 vertexCoords = texCoords * (isFan ? vec2(quadDetail) + vec2(1.0, 1.0) : vec2(quadDetail));\r\n    vec4 surfaceVertex = getSurfaceVertex(surfaceDataAddr.xy, vertexCoords);\r\n    v_surfaceType = surfaceVertex.a;\r\n    vec3 normal  = getSurfaceNormal(surfaceDataAddr.xy, vertexCoords);\r\n    vec4 pos     = vec4(surfaceVertex.rgb, 1.0);\r\n    \r\n    bool flippedNormal = testFlag(surfaceFlags, SURFACE_FLAG_FLIPPED_NORMAL);\r\n    if(flippedNormal)\r\n        normal = -normal;\r\n\r\n    vec4 viewPos = modelViewMatrix * pos;\r\n    v_viewPos    = viewPos.xyz;\r\n    v_worldPos   = (modelMatrix * pos).xyz;\r\n    gl_Position  = projectionMatrix * viewPos;\r\n    v_viewNormal = normalMatrix * normal;\r\n\r\n    v_quadDetail = vec2(quadDetail);\r\n\r\n    {\r\n        // Pull back facing vertices towards us ever so slightly...\r\n        // This is to avoid z-fighting that occurs wehn we see the inside\r\n        // of a surface that is resting on another surface.\r\n        vec3 worldNormal = normalize(mat3(cameraMatrix) * v_viewNormal);\r\n\r\n        vec3 viewVector = normalize(mat3(cameraMatrix) * normalize(-v_viewPos));\r\n        float ndotv = dot(worldNormal, viewVector);\r\n        bool backFacing = ndotv <= 0.0;\r\n        if (backFacing) {\r\n            // Pull backfacing vertices towards us ever so slightly...\r\n            gl_Position.z *= 0.99999;\r\n        }\r\n    }\r\n\r\n    if(isFan) {\r\n        // We are drawing a Fan surface, so the uv coords\r\n        // simply come from the vertex positions.\r\n        v_textureCoord = positions.xy;\r\n    }\r\n    else {\r\n        v_textureCoord = texCoords;\r\n        if(testFlag(surfaceFlags, SURFACE_FLAG_FLIPPED_UV)) {\r\n            v_textureCoord = vec2(v_textureCoord.y, v_textureCoord.x);\r\n            v_quadDetail = vec2(v_quadDetail.y, v_quadDetail.x);\r\n        }\r\n\r\n        // v_textureCoord.y = 1.0 - v_textureCoord.y; // Flip y\r\n    }\r\n}`\r\n\r\nconst GLDrawCADSurfaceShader_FRAGMENT_SHADER = `\r\nprecision highp float;\r\n\r\n<%include file=\"math/constants.glsl\"/>\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n<%include file=\"stack-gl/gamma.glsl\"/>\r\n<%include file=\"materialparams.glsl\"/>\r\n<%include file=\"GGX_Specular.glsl\"/>\r\n<%include file=\"PBRSurfaceRadiance.glsl\"/>\r\n\r\n<%include file=\"GLSLCADConstants.glsl\"/>\r\n<%include file=\"GLSLBinReader.glsl\"/>\r\n\r\nuniform mat4 cameraMatrix;\r\n\r\nuniform bool headLighting;\r\nuniform bool displayWireframes;\r\nuniform bool displayEdges;\r\n\r\n\r\n#ifdef ENABLE_INLINE_GAMMACORRECTION\r\nuniform float exposure;\r\n#endif\r\n\r\nvarying vec4 v_drawCoords;\r\nvarying vec3 v_viewPos;\r\nvarying vec3 v_worldPos;\r\nvarying vec3 v_viewNormal;\r\nvarying vec2 v_textureCoord;\r\nvarying vec3 v_bodyDescAddr;\r\nvarying float v_surfaceType;\r\nvarying vec2 v_quadDetail;\r\n\r\nvec3 getDebugColor(int id){\r\n    \r\n    int sel = int(round(mod(float(id), 14.0)));\r\n    \r\n    if(sel==0)\r\n        return vec3(0.0, 1.0, 1.0);\r\n    else if (sel==1)\r\n        return vec3(0.0, 1.0, 0.0);\r\n    else if (sel==2)\r\n        return vec3(1.0, 0.0, 1.0);\r\n    else if (sel==3)\r\n        return vec3(0.75, 0.75, 0.0);\r\n    else if (sel==4)\r\n        return vec3(0.0, 0.75, 0.75);\r\n    else if (sel==5)\r\n        return vec3(0.75, 0.0, 0.75);\r\n    else if (sel==6)\r\n        return vec3(0.45, 0.95, 0.0);\r\n    else if (sel==7)\r\n        return vec3(0.0, 0.45, 0.95);\r\n    else if (sel==8)\r\n        return vec3(0.95, 0.0, 0.45);\r\n    else if (sel==9)\r\n        return vec3(0.95, 0.45, 0.0);\r\n    else if (sel==10)\r\n        return vec3(0.0, 0.95, 0.45);\r\n    else if (sel==11)\r\n        return vec3(0.45, 0.0, 0.95);\r\n    else if (sel==12)\r\n        return vec3(0.45, 0.45, 0.95);\r\n    else if (sel==13)\r\n        return vec3(0.0, 0.0, 0.45);\r\n    else if (sel==14)\r\n        return vec3(0.0, 0.45, 0.45);\r\n    else if (sel==15)\r\n        return vec3(0.45, 0.0, 0.45);\r\n    else return vec3(0.2, 0.2, 0.2);\r\n}\r\n\r\n<%include file=\"GLSLCADSurfaceDrawing.fragmentShader.glsl\"/>\r\n\r\n// const float gridSize = 0.02;\r\nconst float gridSize = 0.2;\r\n\r\n#ifdef ENABLE_ES3\r\nout vec4 fragColor;\r\n#endif\r\n\r\nvoid main(void) {\r\n    \r\n    int cadBodyId = int(floor(v_drawCoords.r + 0.5));\r\n    int drawItemIndexInBody = int(floor(v_drawCoords.g + 0.5));\r\n    int surfaceId = int(floor(v_drawCoords.b + 0.5));\r\n    int trimSetId = int(floor(v_drawCoords.a + 0.5));\r\n\r\n\r\n    // TODO: pass as varying from pixel shader.\r\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\r\n    vec4 cadBodyPixel1 = getCADBodyPixel(cadBodyId, 1);\r\n\r\n    int flags = int(floor(cadBodyPixel0.g + 0.5));\r\n    vec2 materialCoords = cadBodyPixel1.xy;\r\n    //////////////////////////////////////////////\r\n    // Trimming\r\n    vec4 trimPatchQuad;\r\n    vec3 trimCoords;\r\n    if(trimSetId >= 0) {\r\n        GLSLBinReader trimsetLayoutDataReader;\r\n        GLSLBinReader_init(trimsetLayoutDataReader, trimSetsAtlasLayoutTextureSize, 16);\r\n        trimPatchQuad = GLSLBinReader_readVec4(trimsetLayoutDataReader, trimSetsAtlasLayoutTexture, trimSetId*4);\r\n\r\n        if(applyTrim(trimPatchQuad, trimCoords, flags)){\r\n            discard;\r\n            return;\r\n        }\r\n    }\r\n\r\n    ///////////////////////////////////////////\r\n    // Normal\r\n\r\n    vec3 normal = normalize(mat3(cameraMatrix) * v_viewNormal);\r\n    vec3 viewNormal = normalize(v_viewNormal);\r\n\r\n    vec3 viewVector = normalize(mat3(cameraMatrix) * normalize(-v_viewPos));\r\n    bool backFacing = dot(normal, viewVector) <= 0.0;\r\n    if(backFacing){\r\n        normal = -normal;\r\n        viewNormal = -viewNormal;\r\n    }\r\n\r\n    //////////////////////////////////////////////\r\n    // Material\r\n\r\n    vec4 matValue0 = getMaterialValue(materialCoords, 0);\r\n\r\n    MaterialParams material;\r\n\r\n    /////////////////\r\n    bool clayRendering = false;\r\n    \r\n    material.baseColor             = matValue0.rgb;\r\n    material.opacity               = matValue0.a;\r\n    \r\n    /////////////////\r\n    // Face color\r\n#ifdef ENABLE_PER_FACE_COLORS\r\n    vec4 faceColor = getDrawItemColor(ftoi(v_bodyDescAddr.xy), ftoi(v_bodyDescAddr.z));\r\n    material.baseColor = mix(material.baseColor, faceColor.rgb, faceColor.a);\r\n#endif\r\n\r\n    if(clayRendering) {\r\n        material.baseColor          = vec3(0.45, 0.26, 0.13);\r\n        material.opacity            = 1.0;\r\n    } \r\n\r\n    //////////////////////////////////////////////\r\n    // Cutaways\r\n    // if (applyCutaway(cadBodyId, flags)) {\r\n    //     discard;\r\n    //     return;\r\n    // }\r\n    if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\r\n        vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\r\n        vec3 cutNormal = normalize(cadBodyPixel6.xyz);\r\n        float cutPlaneDist = cadBodyPixel6.w;\r\n        if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\r\n            discard;\r\n            return;\r\n        }\r\n        // If we are not cutaway, but we can see a back facing face\r\n        // then set the normal to the cut plane do the lighting is flat.\r\n        if (backFacing){\r\n            normal = cutNormal;\r\n        }\r\n    }\r\n\r\n    /////////////////\r\n    // Debug backFacing\r\n    // if(backFacing) {\r\n    //     material.baseColor = mix(material.baseColor, vec3(1.0, 0.0, 0.0), 0.5);\r\n    // }\r\n\r\n    /////////////////\r\n    // Debug materialId\r\n#ifdef DEBUG_MATERIALID\r\n    {\r\n        material.baseColor = vec3(float(int(materialCoords.x) % 5)/5.0, float(int(materialCoords.y) % 5)/5.0, 0.0);\r\n    }\r\n#endif\r\n\r\n    /////////////////\r\n    // Debug bodyId\r\n#ifdef DEBUG_BODYID\r\n    {\r\n        material.baseColor       = getDebugColor(cadBodyId);\r\n    }\r\n#endif\r\n\r\n    /////////////////\r\n    // Debug drawItemIndexInBody\r\n#ifdef DEBUG_SURFACEID\r\n    {\r\n        material.baseColor       = getDebugColor(drawItemIndexInBody);\r\n    }\r\n#endif\r\n\r\n    /////////////////\r\n    // Debug surface Type\r\n#ifdef DEBUG_SURFACETYPE\r\n    {\r\n        material.baseColor       = getDebugColor(v_surfaceType);\r\n    }\r\n#endif\r\n\r\n    /////////////////\r\n    // bool flippedNormal = testFlag(flags, SURFACE_FLAG_FLIPPED_NORMAL);\r\n    // if(flippedNormal) {\r\n    //    material.baseColor = mix(material.baseColor, vec3(1,0,0), 0.75);\r\n    // }\r\n\r\n    // if (backFacing) {\r\n    //     material.baseColor = mix(material.baseColor, vec3(1,0,0), 0.75);\r\n    // }\r\n\r\n    /////////////////\r\n    // Debug UV layout.\r\n    // {\r\n    //     material.baseColor = vec3(v_textureCoord.x);\r\n    //     // material.baseColor.r = mix(0.0, 1.0, v_textureCoord.x);\r\n    //     // material.baseColor.g = mix(0.0, 1.0, v_textureCoord.y);\r\n    // }\r\n\r\n    /////////////////\r\n    // if(testFlag(flags, SURFACE_FLAG_FLIPPED_UV)){\r\n    //     material.baseColor = mix(material.baseColor, vec3(1,1,1), 0.5);\r\n    // }\r\n\r\n    /////////////////\r\n    // if(v_quadDetail.x > 512.0 || v_quadDetail.y > 512.0){\r\n    //     material.baseColor = mix(material.baseColor, vec3(1,0,0), 0.75);\r\n    // } else {\r\n    //     // discard;\r\n    // }\r\n    \r\n    /////////////////\r\n    // Debug trim texture.\r\n#ifdef DEBUG_TRIMTEXELS\r\n    if(trimCoords.x >= 0.0) {\r\n        // trimCoords = (trimPatchQuad.xy + 0.5) + ((trimPatchQuad.zw - 0.5) * v_textureCoord);\r\n        trimCoords.xy = trimPatchQuad.xy + (trimPatchQuad.zw * v_textureCoord);\r\n        vec2 trimUv = (trimCoords.xy) / vec2(trimSetAtlasTextureSize);\r\n        vec4 trimTexel = texture2D(trimSetAtlasTexture, trimUv);\r\n\r\n        vec2 texelOffset = trimCoords.xy - (floor(trimCoords.xy) + 0.5);\r\n        float texelDist = length(texelOffset);\r\n        \r\n        material.baseColor = trimTexel.rgb * texelDist;\r\n\r\n        // if (trimTexel.r > 0.5 && trimTexel.g > 0.5) {\r\n        //     material.baseColor = vec3(0,0,0);\r\n        // }\r\n\r\n        // material.baseColor = mix(material.baseColor, vec3(0,0,0), texelDist);\r\n        // material.baseColor = mix(material.baseColor, vec3(0,0,0), trimCoords.z);\r\n        // material.baseColor = mix(material.baseColor, vec3(0,0,0), (trimCoords.z < 0.5) ? 1.0 : 0.0);\r\n\r\n        // if(trimCoords.z < 0.5) {\r\n        //     material.baseColor = mix(material.baseColor, vec3(0,0,0), 0.1);\r\n        // }\r\n        // else{\r\n        //     float total = floor(trimCoords.x) +\r\n        //                   floor(trimCoords.y);\r\n        //     if(mod(total,2.0)==0.0)\r\n        //         material.baseColor = mix(material.baseColor, vec3(0,0,0), 0.25);\r\n        //     else\r\n        //         material.baseColor = mix(material.baseColor, vec3(1,1,1), 0.25);\r\n        // }\r\n    }\r\n#endif\r\n\r\n\r\n    \r\n    //////////////////////////////////////////////\r\n    // Transparency\r\n    // Simple screen door transparency.\r\n    // float threshold = gridSize * opacity * (1.0 - (v_viewPos.z / 300.0));\r\n    // // if(mod(v_viewPos.x / v_viewPos.z, gridSize) > threshold || mod(v_viewPos.y/v_viewPos.z, gridSize) > threshold)// || mod(v_viewPos.z, gridSize) > threshold)\r\n    // if(mod(abs(v_worldPos.x), gridSize) > threshold || mod(abs(v_worldPos.y), gridSize) > threshold || mod(abs(v_worldPos.z), gridSize) > threshold)\r\n    //     discard;\r\n\r\n\r\n    ///////////////////////////////////////////\r\n    // Lighting\r\n    vec3 radiance;\r\n\r\n    vec4 matValue1;\r\n    if(clayRendering)\r\n        matValue1          = vec4(0.0, 0.9, 0.1, 0.0);\r\n    else\r\n        matValue1          = getMaterialValue(materialCoords, 1);\r\n\r\n    material.metallic       = matValue1.r;\r\n    material.roughness      = matValue1.g;\r\n    material.reflectance    = matValue1.b;\r\n    material.emission       = matValue1.a;\r\n\r\n#ifndef ENABLE_ES3\r\n    vec4 fragColor;\r\n#endif\r\n    fragColor = pbrSurfaceRadiance(material, normal, viewVector);\r\n\r\n    /////////////////////////////\r\n    // fragColor = vec4(material.baseColor, 1.0);\r\n    // fragColor = vec4( normalize(viewNormal), 1.0);\r\n    // fragColor = vec4( normalize(normal), 1.0);\r\n\r\n    // fragColor = vec4(sampleEnvMap(viewNormal, material.roughness), 1.0);;\r\n    \r\n    ////////////////////\r\n    {\r\n        // vec4 wireColor = vec4(0.1, 0.1, 0.1, 1.0);\r\n        //vec4 wireColor = vec4(0.6, 0.6, 0.6, 1.0);\r\n        vec4 wireColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n        \r\n        vec2 vertexCoords = v_textureCoord * v_quadDetail;\r\n        vec2 vcD = fwidth(vertexCoords);\r\n        vec2 vcW = fract(vertexCoords);\r\n\r\n        bool isFan = v_quadDetail.y < 0.5;\r\n        if(displayWireframes) {\r\n            if (isFan) {\r\n\r\n            } else {\r\n        \r\n                float lerpVal = smoothstep(0.0, vcD.x, vcW.x) * smoothstep(1.0, 1.0 - vcD.x, vcW.x) * smoothstep(0.0, vcD.y, vcW.y) * smoothstep(1.0, 1.0 - vcD.y, vcW.y);\r\n                \r\n                // Display a thin line at 50% opacity.\r\n                fragColor = mix(fragColor, wireColor, (1.0-smoothstep(0.0, 0.5, lerpVal)) * 0.5 );\r\n        \r\n                //fragColor = mix(fragColor, wireColor, (mod(vertexCoords.x, 2.0) < 1.0) ? 0.5 : 0.0 );\r\n            }\r\n        }\r\n    }\r\n\r\n#ifdef ENABLE_INLINE_GAMMACORRECTION\r\n    fragColor.rgb = toGamma(fragColor.rgb * exposure);\r\n#endif\r\n\r\n#ifndef ENABLE_ES3\r\n    gl_FragColor = fragColor;\r\n#endif\r\n}\r\n`\r\n\r\nimport { GLCADShader } from './GLCADShader.js'\r\n\r\n/** Class representing a GL draw CAD surface shader.\r\n * @extends GLCADShader\r\n * @ignore\r\n */\r\nclass GLDrawCADSurfaceShader extends GLCADShader {\r\n  /*\r\n   * Create a GL draw CAD surface shader.\r\n   * @param {any} gl - The gl value.\r\n   */\r\n  constructor(gl) {\r\n    super(gl)\r\n    this.setShaderStage('VERTEX_SHADER', GLDrawCADSurfaceShader_VERTEX_SHADER)\r\n    this.setShaderStage('FRAGMENT_SHADER', GLDrawCADSurfaceShader_FRAGMENT_SHADER)\r\n  }\r\n\r\n  /**\r\n   * The bind method.\r\n   * @param {object} renderstate - The object tracking the current state of the renderer\r\n   * @param {string} key - The key value.\r\n   * @return {any} - The return value.\r\n   */\r\n  bind(renderstate, key) {\r\n    super.bind(renderstate, key)\r\n\r\n    const gl = this.__gl\r\n    if (renderstate.envMap) {\r\n      renderstate.envMap.bind(renderstate)\r\n    }\r\n\r\n    const { exposure } = renderstate.unifs\r\n    if (exposure) {\r\n      gl.uniform1f(exposure.location, renderstate.exposure)\r\n    }\r\n    return true\r\n  }\r\n\r\n  /**\r\n   * The getParamDeclarations method.\r\n   * @return {any} - The return value.\r\n   */\r\n  static getParamDeclarations() {\r\n    const paramDescs = super.getParamDeclarations()\r\n    paramDescs.push({\r\n      name: 'BaseColor',\r\n      defaultValue: new Color(1.0, 1.0, 0.5),\r\n    })\r\n    paramDescs.push({\r\n      name: 'EmissiveStrength',\r\n      defaultValue: 0.0,\r\n    })\r\n    paramDescs.push({\r\n      name: 'Metallic',\r\n      defaultValue: 0.0,\r\n    })\r\n    paramDescs.push({\r\n      name: 'Roughness',\r\n      defaultValue: 0.25,\r\n    })\r\n    paramDescs.push({\r\n      name: 'Normal',\r\n      defaultValue: new Color(0.0, 0.0, 0.0),\r\n    })\r\n    paramDescs.push({\r\n      name: 'TexCoordScale',\r\n      defaultValue: 1.0,\r\n      texturable: false,\r\n    })\r\n    // F0 = reflectance and is a physical property of materials\r\n    // It also has direct relation to IOR so we need to dial one or the other\r\n    // For simplicity sake, we don't need to touch this value as metalic can dictate it\r\n    // such that non metallic is mostly around (0.01-0.025) and metallic around (0.7-0.85)\r\n    paramDescs.push({\r\n      name: 'Reflectance',\r\n      defaultValue: 0.025,\r\n    })\r\n    return paramDescs\r\n  }\r\n\r\n  /**\r\n   * The getPackedMaterialData method.\r\n   * @param {any} material - The material param.\r\n   * @return {any} - The return value.\r\n   */\r\n  static getPackedMaterialData(material) {\r\n    const matData = new Float32Array(8)\r\n    const baseColor = material.getParameter('BaseColor').getValue()\r\n    matData[0] = baseColor.r\r\n    matData[1] = baseColor.g\r\n    matData[2] = baseColor.b\r\n    matData[3] = baseColor.a\r\n    if (material.getParameter('EmissiveStrength')) {\r\n      matData[4] = material.getParameter('Metallic').getValue()\r\n      matData[5] = material.getParameter('Roughness').getValue()\r\n      matData[6] = material.getParameter('Reflectance').getValue()\r\n      matData[7] = material.getParameter('EmissiveStrength').getValue()\r\n    } else {\r\n      matData[5] = 1.0\r\n    }\r\n    return matData\r\n  }\r\n}\r\n\r\nRegistry.register('GLDrawCADSurfaceShader', GLDrawCADSurfaceShader)\r\n\r\nexport { GLDrawCADSurfaceShader_VERTEX_SHADER, GLDrawCADSurfaceShader_FRAGMENT_SHADER, GLDrawCADSurfaceShader }\r\n","/* eslint-disable camelcase */\r\nimport { GLDrawCADSurfaceShader_VERTEX_SHADER } from './GLDrawCADSurfaceShader.js'\r\n\r\nconst FRAGMENT_SHADER = `\r\nprecision highp float;\r\n\r\n<%include file=\"stack-gl/gamma.glsl\"/>\r\n<%include file=\"GLSLCADConstants.glsl\"/>\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n<%include file=\"GLSLBinReader.glsl\"/>\r\n\r\nuniform int passIndex;\r\nuniform int assetIndex;\r\n\r\nvarying vec4 v_drawCoords;\r\nvarying vec3 v_viewPos;\r\nvarying vec3 v_worldPos;\r\nvarying vec3 v_viewNormal;\r\nvarying vec2 v_textureCoord;\r\nvarying float v_surfaceType;\r\nvarying vec2 v_quadDetail;\r\n\r\n<%include file=\"GLSLCADSurfaceDrawing.fragmentShader.glsl\"/>\r\n\r\n#ifdef ENABLE_ES3\r\nout vec4 fragColor;\r\n#endif\r\n\r\nvoid main(void) {\r\n\r\n#ifndef ENABLE_ES3\r\n    vec4 fragColor;\r\n#endif\r\n\r\n    int cadBodyId = int(floor(v_drawCoords.r + 0.5));\r\n    int surfaceIndexInBody = int(floor(v_drawCoords.g + 0.5));\r\n    int surfaceId = int(floor(v_drawCoords.b + 0.5));\r\n    int trimSetId = int(floor(v_drawCoords.a + 0.5));\r\n\r\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\r\n    int flags = int(floor(cadBodyPixel0.g + 0.5));\r\n\r\n    //////////////////////////////////////////////\r\n    // Cutaways\r\n    if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\r\n        vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\r\n        vec3 cutNormal = cadBodyPixel6.xyz;\r\n        float cutPlaneDist = cadBodyPixel6.w;\r\n        if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\r\n            discard;\r\n        }\r\n    }\r\n\r\n    //////////////////////////////////////////////\r\n    // Trimming\r\n    vec4 trimPatchQuad;\r\n    vec3 trimCoords;\r\n    if(trimSetId >= 0) {\r\n        GLSLBinReader trimsetLayoutDataReader;\r\n        GLSLBinReader_init(trimsetLayoutDataReader, trimSetsAtlasLayoutTextureSize, 16);\r\n        trimPatchQuad = GLSLBinReader_readVec4(trimsetLayoutDataReader, trimSetsAtlasLayoutTexture, trimSetId*4);\r\n\r\n        if(applyTrim(trimPatchQuad, trimCoords, flags)){\r\n            discard;\r\n            return;\r\n        }\r\n    }\r\n\r\n    float dist = length(v_viewPos);\r\n\r\n    int passAndAssetIndex = passIndex + (assetIndex * 64);\r\n\r\n    fragColor.r = float(passAndAssetIndex);\r\n    fragColor.g = float(cadBodyId);\r\n    fragColor.b = float(surfaceIndexInBody);\r\n    fragColor.a = dist;\r\n    \r\n    // fragColor.b = float(v_surfaceType);\r\n\r\n#ifndef ENABLE_ES3\r\n    gl_FragColor = fragColor;\r\n#endif\r\n}\r\n`\r\n\r\nimport { GLCADShader } from './GLCADShader.js'\r\n\r\n/** Class representing a GL draw CAD surface geom data shader.\r\n * @extends GLCADShader\r\n * @ignore\r\n */\r\nclass GLDrawCADSurfaceGeomDataShader extends GLCADShader {\r\n  /**\r\n   * Create a GL draw CAD surface geom data shader.\r\n   * @param {any} gl - The gl value.\r\n   */\r\n  constructor(gl) {\r\n    super(gl)\r\n\r\n    this.setShaderStage('VERTEX_SHADER', GLDrawCADSurfaceShader_VERTEX_SHADER)\r\n    this.setShaderStage('FRAGMENT_SHADER', FRAGMENT_SHADER)\r\n\r\n    this.nonSelectable = true\r\n  }\r\n}\r\n\r\nexport { GLDrawCADSurfaceGeomDataShader }\r\n","import { shaderLibrary, Registry } from '@zeainc/zea-engine'\r\nimport { GLDrawCADSurfaceShader_VERTEX_SHADER } from './GLDrawCADSurfaceShader.js'\r\n\r\nconst FRAGMENT_SHADER = `\r\nprecision highp float;\r\n\r\n<%include file=\"stack-gl/gamma.glsl\"/>\r\n<%include file=\"GLSLCADConstants.glsl\"/>\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n<%include file=\"GLSLBinReader.glsl\"/>\r\n\r\nvarying vec4 v_drawCoords;\r\nvarying vec3 v_viewPos;\r\nvarying vec3 v_worldPos;\r\nvarying vec3 v_viewNormal;\r\nvarying vec2 v_textureCoord;\r\nvarying float v_surfaceType;\r\nvarying vec2 v_quadDetail;\r\n\r\n<%include file=\"GLSLCADSurfaceDrawing.fragmentShader.glsl\"/>\r\n\r\n#ifdef ENABLE_ES3\r\nout vec4 fragColor;\r\n#endif\r\n\r\nvoid main(void) {\r\n\r\n#ifndef ENABLE_ES3\r\n    vec4 fragColor;\r\n#endif\r\n    \r\n    int cadBodyId = int(floor(v_drawCoords.r + 0.5));\r\n    int surfaceIndexInBody = int(floor(v_drawCoords.g + 0.5));\r\n    int surfaceId = int(floor(v_drawCoords.b + 0.5));\r\n    int trimSetId = int(floor(v_drawCoords.a + 0.5));\r\n\r\n    // TODO: pass as varying from pixel shader.\r\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\r\n    int flags = int(floor(cadBodyPixel0.g + 0.5));\r\n            \r\n\r\n    //////////////////////////////////////////////\r\n    // Cutaways\r\n    if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\r\n        vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\r\n        vec3 cutNormal = cadBodyPixel6.xyz;\r\n        float cutPlaneDist = cadBodyPixel6.w;\r\n        if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\r\n            discard;\r\n        }\r\n    }\r\n\r\n    //////////////////////////////////////////////\r\n    // Trimming\r\n    vec4 trimPatchQuad;\r\n    vec3 trimCoords;\r\n    if(trimSetId >= 0) {\r\n        GLSLBinReader trimsetLayoutDataReader;\r\n        GLSLBinReader_init(trimsetLayoutDataReader, trimSetsAtlasLayoutTextureSize, 16);\r\n        trimPatchQuad = GLSLBinReader_readVec4(trimsetLayoutDataReader, trimSetsAtlasLayoutTexture, trimSetId*4);\r\n\r\n        if(applyTrim(trimPatchQuad, trimCoords, flags)){\r\n            discard;\r\n            return;\r\n        }\r\n    }\r\n    \r\n    vec4 highlightColor = getCADBodyPixel(cadBodyId, 5);\r\n    fragColor = highlightColor;\r\n\r\n#ifndef ENABLE_ES3\r\n    gl_FragColor = fragColor;\r\n#endif\r\n}\r\n`\r\n\r\nimport { GLCADShader } from './GLCADShader.js'\r\n\r\n/** Class representing a GL draw selected CAD surface shader.\r\n * @extends GLCADShader\r\n * @ignore\r\n */\r\nclass GLDrawSelectedCADSurfaceShader extends GLCADShader {\r\n  /**\r\n   * Create a GL draw selected CAD surface shader.\r\n   * @param {any} gl - The gl value.\r\n   */\r\n  constructor(gl) {\r\n    super(gl)\r\n\r\n    this.setShaderStage('VERTEX_SHADER', GLDrawCADSurfaceShader_VERTEX_SHADER)\r\n    this.setShaderStage('FRAGMENT_SHADER', FRAGMENT_SHADER)\r\n    this.nonSelectable = true\r\n  }\r\n}\r\n\r\nRegistry.register('GLDrawSelectedCADSurfaceShader', GLDrawSelectedCADSurfaceShader)\r\n\r\nexport { GLDrawSelectedCADSurfaceShader }\r\n","/* eslint-disable camelcase */\r\nimport { Color } from '@zeainc/zea-engine'\r\nimport './GLSLCADConstants.js'\r\nimport './GLSLMath.js'\r\nimport './GLSLCADSurfaceDrawing.js'\r\n\r\nconst GLDrawCADCurveShader_VERTEX_SHADER = `\r\nprecision highp float;\r\n\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n<%include file=\"GLSLCADConstants.glsl\"/>\r\n<%include file=\"stack-gl/transpose.glsl\"/>\r\n<%include file=\"stack-gl/inverse.glsl\"/>\r\n\r\nattribute vec3 positions;\r\ninstancedattribute vec4 drawCoords;  // body ID, Surface index in Body, Surface Id, TrimSet Id\r\n// instancedattribute vec2 drawItemTexAddr;  // Address of the data in the draw item texture. (mat4)\r\n\r\nuniform mat4 viewMatrix;\r\nuniform mat4 cameraMatrix;\r\nuniform mat4 projectionMatrix;\r\nuniform int edgeDetail;\r\nuniform vec3 assetCentroid;\r\n\r\n\r\n// #define DEBUG_SURFACES\r\nuniform int numCurvesInLibrary;\r\n\r\n\r\n<%include file=\"GLSLCADGeomDrawing.vertexShader.glsl\"/>\r\n\r\n// GEOM\r\nuniform sampler2D curvesAtlasLayoutTexture;\r\nuniform ivec2 curvesAtlasLayoutTextureSize;\r\n\r\n\r\nuniform sampler2D curvesAtlasTexture;\r\nuniform ivec2 curvesAtlasTextureSize;\r\n// uniform sampler2D normalsTexture;\r\n\r\nvec3 getCurveVertex(ivec2 addr, int vertexId) {\r\n  return fetchTexel(curvesAtlasTexture, curvesAtlasTextureSize, ivec2(addr.x + vertexId, addr.y)).rgb;\r\n}\r\n\r\n// vec3 getCurveTangent(vec2 surfacePatchCoords, vec2 vertexCoord) {\r\n//   return fetchTexel(normalsTexture, curvesAtlasTextureSize, ivec2(ftoi(surfacePatchCoords.x + vertexCoord.x), ftoi(surfacePatchCoords.y + vertexCoord.y))).rgb;\r\n// }\r\n\r\nvarying vec4 v_drawCoords;\r\nvarying vec3 v_viewPos;\r\nvarying vec3 v_worldPos;\r\n\r\nvoid main(void) {\r\n    int cadBodyId = ftoi(drawCoords.r);\r\n    int drawItemIndexInBody = ftoi(drawCoords.g);\r\n    int curveId = ftoi(drawCoords.b);\r\n    int trimSetId = ftoi(drawCoords.a);\r\n    v_drawCoords = drawCoords;\r\n\r\n    vec2 texCoords = positions.xy;\r\n\r\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\r\n    vec4 cadBodyPixel1 = getCADBodyPixel(cadBodyId, 1);\r\n\r\n    // int bodyDescId = ftoi(cadBodyPixel0.r);\r\n    int flags = ftoi(cadBodyPixel0.g);\r\n\r\n    // vec4 metadata = getDrawItemData(0);\r\n    // ivec4 curveAtlasCoords = ftoi(getDrawItemData(2));\r\n    // int flags = int(floor(metadata.a + 0.5));\r\n\r\n    //////////////////////////////////////////////\r\n    // Visibility\r\n    if(testFlag(flags, BODY_FLAG_INVISIBLE)) {\r\n        gl_Position = vec4(-3.0, -3.0, -3.0, 1.0);;\r\n        return;\r\n    }\r\n\r\n    //////////////////////////////////////////////\r\n    // Transforms\r\n#ifdef DEBUG_SURFACES\r\n    mat4 modelMatrix = mat4(1.0);\r\n    int numCurvesInLibrary = 15;\r\n    // int sideLen = int(ceil(sqrt(float(numCurvesInLibrary))));\r\n    // int x = curveId % sideLen;\r\n    // int y = curveId / sideLen;\r\n    modelMatrix = mat4(1.0, 0.0, 0.0, 0.0, \r\n                    0.0, 1.0, 0.0, 0.0, \r\n                    0.0, 0.0, 1.0, 0.0,  \r\n                    float(curveId), float(0), 0.0, 1.0);\r\n#else\r\n\r\n#ifdef CALC_GLOBAL_XFO_DURING_DRAW\r\n    mat4 bodyMat = getCADBodyMatrix(cadBodyId);\r\n    ivec2 bodyDescAddr = ftoi(cadBodyPixel0.ba);\r\n    mat4 curveMat = getDrawItemMatrix(bodyDescAddr, drawItemIndexInBody);\r\n    mat4 modelMatrix = bodyMat * curveMat;\r\n\r\n    // v_sc = surfaceXfo.sc;\r\n    //if (v_sc.z > 0.0) {\r\n    //  gl_Position = vec4(-3.0, -3.0, -3.0, 1.0);;\r\n    //  return;\r\n    //}\r\n#else\r\n    mat4 modelMatrix = getModelMatrix();\r\n    // Note: on mobile GPUs, we get only FP16 math in the\r\n    // fragment shader, causing inaccuracies in modelMatrix\r\n    // calculation. By offsetting the data to the origin\r\n    // we calculate a modelMatrix in the asset space, and\r\n    //  then add it back on during final drawing.\r\n    // modelMatrix[3][0] += assetCentroid.x;\r\n    // modelMatrix[3][1] += assetCentroid.y;\r\n    // modelMatrix[3][2] += assetCentroid.z;\r\n#endif\r\n#endif\r\n    // modelMatrix = mat4(0.001, 0.0, 0.0, 0.0, \r\n    //   0.0, 0.001, 0.0, 0.0, \r\n    //   0.0, 0.0, 0.001, 0.0,  \r\n    //   0.0, 0.0, 0.0, 1.0);\r\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\r\n\r\n    //////////////////////////////////////////////\r\n    // Vertex Attributes\r\n    \r\n    GLSLBinReader curvesLayoutDataReader;\r\n    GLSLBinReader_init(curvesLayoutDataReader, curvesAtlasLayoutTextureSize, 16);\r\n    vec4 curveDataAddr = GLSLBinReader_readVec4(curvesLayoutDataReader, curvesAtlasLayoutTexture, curveId * 8);\r\n\r\n    int vertexId = int(positions.x * float(edgeDetail));\r\n    vec4 pos     = vec4(getCurveVertex(ftoi(curveDataAddr.xy), vertexId), 1.0);\r\n    // vec4 pos     = vec4(positions * float(edgeDetail), 1.0);\r\n\r\n    // if (vertexId == 0)\r\n    //   pos = vec4(vec3(0.0), 1.0);\r\n\r\n    vec4 viewPos = modelViewMatrix * pos;\r\n    v_viewPos    = viewPos.xyz;\r\n    v_worldPos   = (modelMatrix * pos).xyz;\r\n    gl_Position  = projectionMatrix * viewPos;\r\n\r\n    {\r\n        // Pull edge vertices towards us ever so slightly...\r\n        gl_Position.z *= 0.99999;\r\n    }\r\n}`\r\n\r\nconst GLDrawCADCurveShader_FRAGMENT_SHADER = `\r\nprecision highp float;\r\n\r\n<%include file=\"math/constants.glsl\"/>\r\n<%include file=\"GLSLUtils.glsl\"/>\r\n<%include file=\"stack-gl/gamma.glsl\"/>\r\n<%include file=\"materialparams.glsl\"/>\r\n<%include file=\"GGX_Specular.glsl\"/>\r\n<%include file=\"PBRSurfaceRadiance.glsl\"/>\r\n\r\n<%include file=\"GLSLCADConstants.glsl\"/>\r\n\r\nuniform mat4 cameraMatrix;\r\n\r\nuniform bool headLighting;\r\nuniform bool displayWireframes;\r\nuniform bool displayEdges;\r\nuniform vec4 edgeColor;\r\n\r\n#ifdef ENABLE_INLINE_GAMMACORRECTION\r\nuniform float exposure;\r\nuniform float gamma;\r\n#endif\r\n\r\nvarying vec4 v_drawCoords;\r\nvarying vec3 v_viewPos;\r\nvarying vec3 v_worldPos;\r\n\r\n<%include file=\"GLSLCADGeomDrawing.fragmentShader.glsl\"/>\r\n\r\nvec3 getDebugColor(int id){\r\n    \r\n  int sel = int(round(mod(float(id), 14.0)));\r\n  \r\n  if(sel==0)\r\n      return vec3(0.0, 1.0, 1.0);\r\n  else if (sel==1)\r\n      return vec3(0.0, 1.0, 0.0);\r\n  else if (sel==2)\r\n      return vec3(1.0, 0.0, 1.0);\r\n  else if (sel==3)\r\n      return vec3(0.75, 0.75, 0.0);\r\n  else if (sel==4)\r\n      return vec3(0.0, 0.75, 0.75);\r\n  else if (sel==5)\r\n      return vec3(0.75, 0.0, 0.75);\r\n  else if (sel==6)\r\n      return vec3(0.45, 0.95, 0.0);\r\n  else if (sel==7)\r\n      return vec3(0.0, 0.45, 0.95);\r\n  else if (sel==8)\r\n      return vec3(0.95, 0.0, 0.45);\r\n  else if (sel==9)\r\n      return vec3(0.95, 0.45, 0.0);\r\n  else if (sel==10)\r\n      return vec3(0.0, 0.95, 0.45);\r\n  else if (sel==11)\r\n      return vec3(0.45, 0.0, 0.95);\r\n  else if (sel==12)\r\n      return vec3(0.45, 0.45, 0.95);\r\n  else if (sel==13)\r\n      return vec3(0.0, 0.0, 0.45);\r\n  else if (sel==14)\r\n      return vec3(0.0, 0.45, 0.45);\r\n  else if (sel==15)\r\n      return vec3(0.45, 0.0, 0.45);\r\n  else return vec3(0.2, 0.2, 0.2);\r\n}\r\n\r\n#ifdef ENABLE_ES3\r\nout vec4 fragColor;\r\n#endif\r\n\r\nvoid main(void) {\r\n\r\n#ifndef ENABLE_ES3\r\n    vec4 fragColor;\r\n#endif\r\n\r\n    int cadBodyId = int(floor(v_drawCoords.r + 0.5));\r\n    int drawItemIndexInBody = int(floor(v_drawCoords.g + 0.5));\r\n    int curveId = int(floor(v_drawCoords.b + 0.5));\r\n\r\n    // TODO: pass as varying from pixel shader.\r\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\r\n    int flags = int(floor(cadBodyPixel0.g + 0.5));\r\n            \r\n\r\n    //////////////////////////////////////////////\r\n    // Cutaways\r\n    if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\r\n        vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\r\n        vec3 cutNormal = cadBodyPixel6.xyz;\r\n        float cutPlaneDist = cadBodyPixel6.w;\r\n        if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\r\n            discard;\r\n            return;\r\n        }\r\n    }\r\n\r\n    fragColor = edgeColor;\r\n\r\n    // fragColor = vec4(0.0, 0.0, 0.0, 1.0);\r\n    // if (v_sc.x < 0.0) {\r\n    //   fragColor.r = 1.0;\r\n    // }\r\n    // if (v_sc.y < 0.0) {\r\n    //   fragColor.g = 1.0;\r\n    // }\r\n    // if (v_sc.z < 0.0) {\r\n    //   fragColor.b = 1.0;\r\n    // }\r\n\r\n    /////////////////\r\n    // Debug drawItemIndexInBody\r\n    // {\r\n    //   fragColor.rgb = mix(vec3(1.,1.,1.), getDebugColor(drawItemIndexInBody), float(drawItemIndexInBody)/5.0);\r\n    // }\r\n\r\n#ifdef ENABLE_INLINE_GAMMACORRECTION\r\n    fragColor.rgb = toGamma(fragColor.rgb * exposure, gamma);\r\n#endif\r\n\r\n#ifndef ENABLE_ES3\r\n    gl_FragColor = fragColor;\r\n#endif\r\n}\r\n`\r\n\r\nimport { GLCADShader } from './GLCADShader.js'\r\n\r\n/** Class representing a GL draw CAD surface shader.\r\n * @extends GLCADShader\r\n * @ignore\r\n */\r\nclass GLDrawCADCurveShader extends GLCADShader {\r\n  /*\r\n   * Create a GL draw CAD surface shader.\r\n   * @param {any} gl - The gl value.\r\n   */\r\n  constructor(gl) {\r\n    super(gl)\r\n\r\n    this.setShaderStage('VERTEX_SHADER', GLDrawCADCurveShader_VERTEX_SHADER)\r\n    this.setShaderStage('FRAGMENT_SHADER', GLDrawCADCurveShader_FRAGMENT_SHADER)\r\n  }\r\n\r\n  /**\r\n   * The getParamDeclarations method.\r\n   * @return {any} - The return value.\r\n   */\r\n  static getParamDeclarations() {\r\n    const paramDescs = super.getParamDeclarations()\r\n    paramDescs.push({\r\n      name: 'BaseColor',\r\n      defaultValue: new Color(1.0, 1.0, 0.5),\r\n    })\r\n    paramDescs.push({\r\n      name: 'EmissiveStrength',\r\n      defaultValue: 0.0,\r\n    })\r\n    paramDescs.push({\r\n      name: 'Metallic',\r\n      defaultValue: 0.0,\r\n    })\r\n    paramDescs.push({\r\n      name: 'Roughness',\r\n      defaultValue: 0.25,\r\n    })\r\n    paramDescs.push({\r\n      name: 'Normal',\r\n      defaultValue: new Color(0.0, 0.0, 0.0),\r\n    })\r\n    paramDescs.push({\r\n      name: 'TexCoordScale',\r\n      defaultValue: 1.0,\r\n      texturable: false,\r\n    })\r\n    // F0 = reflectance and is a physical property of materials\r\n    // It also has direct relation to IOR so we need to dial one or the other\r\n    // For simplicity sake, we don't need to touch this value as metalic can dictate it\r\n    // such that non metallic is mostly around (0.01-0.025) and metallic around (0.7-0.85)\r\n    paramDescs.push({\r\n      name: 'Reflectance',\r\n      defaultValue: 0.025,\r\n    })\r\n    return paramDescs\r\n  }\r\n\r\n  /**\r\n   * The getPackedMaterialData method.\r\n   * @param {any} material - The material param.\r\n   * @return {any} - The return value.\r\n   */\r\n  static getPackedMaterialData(material) {\r\n    const matData = new Float32Array(8)\r\n    const baseColor = material.getParameter('BaseColor').getValue()\r\n    matData[0] = baseColor.r\r\n    matData[1] = baseColor.g\r\n    matData[2] = baseColor.b\r\n    matData[3] = baseColor.a\r\n    if (material.getParameter('EmissiveStrength')) {\r\n      matData[4] = material.getParameter('Metallic').getValue()\r\n      matData[5] = material.getParameter('Roughness').getValue()\r\n      matData[6] = material.getParameter('Reflectance').getValue()\r\n      matData[7] = material.getParameter('EmissiveStrength').getValue()\r\n    } else {\r\n      matData[5] = 1.0\r\n    }\r\n    return matData\r\n  }\r\n}\r\n\r\nexport { GLDrawCADCurveShader }\r\n","﻿import { SystemDesc, GLMesh, Plane, GLPass, Registry } from '@zeainc/zea-engine'\r\nimport { CADAsset } from './CADAsset.js'\r\nimport { GLCADAsset } from './GLCADAsset.js'\r\nimport { GLCADMaterialLibrary } from './GLCADMaterialLibrary.js'\r\n\r\nimport { GLDrawCADSurfaceNormalsShader } from './GLDrawCADSurfaceNormalsShader.js'\r\nimport { GLDrawCADSurfaceGeomDataShader } from './GLDrawCADSurfaceGeomDataShader.js'\r\nimport { GLDrawSelectedCADSurfaceShader } from './GLDrawSelectedCADSurfaceShader.js'\r\nimport { GLDrawCADCurveShader } from './GLDrawCADCurveShader.js'\r\n\r\n/**\r\n * Class representing a GL CAD pass.\r\n *\r\n * **Events**\r\n * * **updated**\r\n * @extends GLPass\r\n */\r\nclass GLCADPass extends GLPass {\r\n  /**\r\n   * Create a GL CAD pass.\r\n   * @param {boolean} debugMode - If true, then puts the GLCADPass rendering into debug mode.\r\n   */\r\n  constructor(debugMode = false) {\r\n    super()\r\n    this.debugMode = debugMode\r\n    this.headLighting = false\r\n    this.displayWireframes = false\r\n    this.displaySurfaces = true\r\n    this.__displayEdges = 0\r\n    this.displayNormals = false\r\n    this.normalLength = 0.002 // 2cm\r\n    this.debugTrimTex = false\r\n    this.debugSurfaceAtlas = false\r\n    this.debugAssetId = 0\r\n    this.pbrEnabled = false\r\n    this.__assets = []\r\n    this.__loadQueue = 0\r\n\r\n    this.__numHighlightedGeoms = 0\r\n\r\n    // Note: fist id reserved for selectionOutlineID = 1\r\n    // See 'draw()' below.\r\n    this.__shaderCount = 2\r\n    this.__shaderKeys = {}\r\n    this.__shaderOptsStack = [{}]\r\n\r\n    this.__profiling = {\r\n      numSurfaces: 0,\r\n      numSurfaceInstances: 0,\r\n      surfaceEvalTime: 0,\r\n      numBodies: 0,\r\n      numMaterials: 0,\r\n      numTriangles: 0,\r\n      numDrawSets: 0,\r\n    }\r\n  }\r\n\r\n  // eslint-disable-next-line require-jsdoc\r\n  get displayEdges() {\r\n    return this.__displayEdges > 0\r\n  }\r\n\r\n  // eslint-disable-next-line require-jsdoc\r\n  set displayEdges(val) {\r\n    if (val == true) this.__displayEdges++\r\n    else this.__displayEdges--\r\n    this.emit('updated')\r\n  }\r\n\r\n  /**\r\n   * The init method.\r\n   * @param {any} renderer - The renderer param.\r\n   * @param {any} passIndex - The passIndex param.\r\n   */\r\n  init(renderer, passIndex) {\r\n    super.init(renderer, passIndex)\r\n\r\n    this.__dataLoadStartTime = performance.now()\r\n\r\n    const gl = renderer.gl\r\n\r\n    const materialLibrary = new GLCADMaterialLibrary(gl)\r\n    materialLibrary.on('updated', () => this.emit('updated'))\r\n\r\n    // Note: The crappy browsers don't support GLSL binary caching, so\r\n    // load times get quite long as we wait for the big shaders to compile.\r\n\r\n    if (gl.name != 'webgl2') {\r\n      this.setShaderPreprocessorValue('#extension GL_OES_standard_derivatives : enable')\r\n    }\r\n\r\n    if (this.debugMode) {\r\n      this.setShaderPreprocessorValue('#define DEBUG_MODE')\r\n    }\r\n\r\n    this.setShaderPreprocessorValue('#define ENABLE_TRIMMING')\r\n    this.setShaderPreprocessorValue('#define ENABLE_INLINE_GAMMACORRECTION')\r\n\r\n    this.__cadpassdata = {\r\n      debugMode: this.debugMode,\r\n      assetCount: 0,\r\n      materialLibrary,\r\n\r\n      glplanegeom: new GLMesh(gl, new Plane(1.0, 1.0, 1, 1)),\r\n      maxTexSize: SystemDesc.gpuDesc.maxTextureSize,\r\n\r\n      incHighlightedCount: this.incHighlightedCount.bind(this),\r\n      decHighlightedCount: this.decHighlightedCount.bind(this),\r\n\r\n      incDisplayEdges: () => {\r\n        this.__displayEdges++\r\n        this.emit('updated')\r\n      },\r\n      decDisplayEdges: () => {\r\n        this.__displayEdges--\r\n        this.emit('updated')\r\n      },\r\n      genShaderID: (shaderName) => {\r\n        if (shaderName == 'SimpleSurfaceShader' || shaderName == 'StandardSurfaceShader') {\r\n          shaderName = 'GLDrawCADSurfaceShader'\r\n        }\r\n        if (!(shaderName in this.__shaderKeys)) {\r\n          const shaderClass = Registry.getBlueprint(shaderName)\r\n          if (!shaderClass || !shaderClass.getPackedMaterialData) {\r\n            return this.__cadpassdata.genShaderID('GLDrawCADSurfaceShader')\r\n          }\r\n          const shader = this.applyOptsToShader(Registry.constructClass(shaderName, gl))\r\n\r\n          const id = this.__shaderCount\r\n          this.__shaderKeys[shaderName] = {\r\n            id,\r\n            shader,\r\n          }\r\n          this.__shaderCount++\r\n          return id\r\n        }\r\n        return this.__shaderKeys[shaderName].id\r\n      },\r\n    }\r\n\r\n    this.__decrementLoadQueue = () => {\r\n      this.__loadQueue--\r\n      if (this.__loadQueue == 0) {\r\n        // console.log('===All Assets Loaded===')\r\n        // console.log('Total Load Time:' + (performance.now() - this.__gpuLoadStartTime) / 1000)\r\n        this.__profiling.numTriangles = this.__profiling.numTriangles / 1000000\r\n        // console.log(this.__profiling)\r\n\r\n        this.emit('updated')\r\n      }\r\n    }\r\n\r\n    // collector.registerSceneItemFilter((treeItem, rargs) => {\r\n    //   if (treeItem instanceof CADAsset) {\r\n    //     this.__loadQueue++;\r\n    //     const cadAsset = treeItem;\r\n    //     cadAsset.on('loaded', () => {\r\n    //       this.addCADAsset(treeItem);\r\n    //     });\r\n    //     rargs.continueInSubTree = true;\r\n    //     return true;\r\n    //   }\r\n    // });\r\n  }\r\n\r\n  /**\r\n   * The itemAddedToScene method is called on each pass when a new item\r\n   * is added to the scene, and the renderer must decide how to render it.\r\n   * It allows Passes to select geometries to handle the drawing of.\r\n   * @param {TreeItem} treeItem - The treeItem value.\r\n   * @param {object} rargs - Extra return values are passed back in this object.\r\n   * The object contains a parameter 'continueInSubTree', which can be set to false,\r\n   * so the subtree of this node will not be traversed after this node is handled.\r\n   * @return {Boolean} - The return value.\r\n   */\r\n  itemAddedToScene(treeItem, rargs) {\r\n    if (treeItem instanceof CADAsset) {\r\n      const cadAsset = treeItem\r\n      this.__loadQueue++\r\n      this.__cadpassdata.assetCount++\r\n\r\n      if (cadAsset.isLoaded()) {\r\n        if (cadAsset.getSurfaceLibrary().getNumSurfaces() > 0) {\r\n          this.addCADAsset(cadAsset)\r\n        } else {\r\n          this.__decrementLoadQueue()\r\n        }\r\n      } else {\r\n        cadAsset.once('loaded', () => {\r\n          if (cadAsset.getSurfaceLibrary().getNumSurfaces() > 0) this.addCADAsset(cadAsset)\r\n          else {\r\n            this.__decrementLoadQueue()\r\n          }\r\n        })\r\n      }\r\n      rargs.continueInSubTree = true\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * The itemRemovedFromScene method is called on each pass when aa item\r\n   * is removed to the scene, and the pass must handle cleaning up any resources.\r\n   * @param {TreeItem} treeItem - The treeItem value.\r\n   * @param {object} rargs - Extra return values are passed back in this object.\r\n   * @return {Boolean} - The return value.\r\n   */\r\n  itemRemovedFromScene(treeItem, rargs) {\r\n    if (treeItem instanceof CADAsset) {\r\n      this.removeCADAsset(treeItem)\r\n      return true\r\n    }\r\n    return false\r\n  }\r\n\r\n  /**\r\n   * The getShaderPreprocessorValue method.\r\n   * @param {any} name - The name param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getShaderPreprocessorValue(name) {\r\n    return this.getShaderState()[name]\r\n  }\r\n\r\n  /**\r\n   * The setShaderPreprocessorValue method.\r\n   * @param {any} name - The name param.\r\n   * @param {boolean} apply - The apply param.\r\n   */\r\n  setShaderPreprocessorValue(name, apply = true) {\r\n    if (!name.startsWith('#')) name = '#define ' + name\r\n\r\n    this.getShaderState()[name] = name\r\n\r\n    // Now update any shaders already consturcted.\r\n    // eslint-disable-next-line guard-for-in\r\n    for (const shaderKey in this.__shaderKeys) {\r\n      const shaderReg = this.__shaderKeys[shaderKey]\r\n      if (shaderReg.shader.setPreprocessorValue) {\r\n        shaderReg.shader.setPreprocessorValue(name)\r\n        if (apply) shaderReg.shader.applyOptions()\r\n      }\r\n    }\r\n\r\n    if (this.__drawSelectedCADSurfaceShader) {\r\n      this.__drawSelectedCADSurfaceShader.setPreprocessorValue(name)\r\n      if (apply) this.__drawSelectedCADSurfaceShader.applyOptions()\r\n    }\r\n    if (this.__drawCADSurfaceGeomDataShader) {\r\n      this.__drawCADSurfaceGeomDataShader.setPreprocessorValue(name)\r\n      if (apply) this.__drawCADSurfaceGeomDataShader.applyOptions()\r\n    }\r\n    if (this.__renderer) this.__renderer.requestRedraw()\r\n  }\r\n\r\n  /**\r\n   * The clearShaderPreprocessorValue method.\r\n   * @param {any} name - The name param.\r\n   * @param {boolean} apply - The apply param.\r\n   */\r\n  clearShaderPreprocessorValue(name, apply = true) {\r\n    delete this.getShaderState()[name]\r\n\r\n    // Now update any shaders already consturcted.\r\n    // eslint-disable-next-line guard-for-in\r\n    for (const shaderKey in this.__shaderKeys) {\r\n      const shaderReg = this.__shaderKeys[shaderKey]\r\n      if (shaderReg.shader.clearPreprocessorValue) {\r\n        shaderReg.shader.clearPreprocessorValue(name)\r\n        if (apply) shaderReg.shader.applyOptions()\r\n      }\r\n    }\r\n    if (this.__renderer) this.__renderer.requestRedraw()\r\n  }\r\n\r\n  /**\r\n   * Applies shader options to the compiled shaders, recompiling if necessary.\r\n   * @param {Shader} shader - The shader.\r\n   * @return {Shader} - The updated shader\r\n   */\r\n  applyOptsToShader(shader) {\r\n    if (shader.setPreprocessorValue) {\r\n      // Initialise the shaders.\r\n      const opts = this.getShaderState()\r\n      // eslint-disable-next-line guard-for-in\r\n      for (const key in opts) shader.setPreprocessorValue(key)\r\n      shader.applyOptions()\r\n    }\r\n    return shader\r\n  }\r\n\r\n  /**\r\n   * The getShaderState method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getShaderState() {\r\n    return this.__shaderOptsStack[this.__shaderOptsStack.length - 1]\r\n  }\r\n\r\n  /**\r\n   * The pushShaderState method.\r\n   */\r\n  pushShaderState() {\r\n    this.__shaderOptsStack.push(Object.assign({}, this.getShaderState()))\r\n    // eslint-disable-next-line guard-for-in\r\n    for (const shaderKey in this.__shaderKeys) {\r\n      const shaderReg = this.__shaderKeys[shaderKey]\r\n      if (shaderReg.shader.pushState) {\r\n        shaderReg.shader.pushState()\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The popShaderState method.\r\n   */\r\n  popShaderState() {\r\n    this.__shaderOptsStack.pop()\r\n    // eslint-disable-next-line guard-for-in\r\n    for (const shaderKey in this.__shaderKeys) {\r\n      const shaderReg = this.__shaderKeys[shaderKey]\r\n      if (shaderReg.shader.popState) shaderReg.shader.popState()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The startPresenting method.\r\n   */\r\n  startPresenting() {\r\n    if (SystemDesc.deviceCategory != 'High') {\r\n      this.pushShaderState()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The stopPresenting method.\r\n   */\r\n  stopPresenting() {\r\n    if (SystemDesc.deviceCategory != 'High') {\r\n      this.popShaderState()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The getCutPlaneNormalParam method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getCutPlaneNormalParam() {\r\n    return this.__cutPlaneNormalParam\r\n  }\r\n\r\n  /**\r\n   * The getCutPlaneDistParam method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getCutPlaneDistParam() {\r\n    return this.__cutDistParam\r\n  }\r\n\r\n  /**\r\n   * The getCutPlaneColorParam method.\r\n   * @return {any} - The return value.\r\n   */\r\n  getCutPlaneColorParam() {\r\n    return this.__cutPlaneColorParam\r\n  }\r\n\r\n  /**\r\n   * The incHighlightedCount method.\r\n   * @param {any} count - The count param.\r\n   */\r\n  incHighlightedCount(count) {\r\n    this.__numHighlightedGeoms += count\r\n  }\r\n\r\n  /**\r\n   * The decHighlightedCount method.\r\n   * @param {any} count - The count param.\r\n   */\r\n  decHighlightedCount(count) {\r\n    this.__numHighlightedGeoms -= count\r\n  }\r\n\r\n  /**\r\n   * The addCADAsset method is an internal method called when new CADAsset\r\n   * items are discovered in the tree.\r\n   * @param {CADAsset} cadAsset - The cadAsset tree item.\r\n   */\r\n  addCADAsset(cadAsset) {\r\n    this.__gl.finish()\r\n    const assetId = this.__assets.length\r\n\r\n    if (assetId == 0) {\r\n      this.__gpuLoadStartTime = performance.now()\r\n    }\r\n\r\n    if (cadAsset.getVersion().compare([0, 0, 26]) > 0) {\r\n      this.setShaderPreprocessorValue('#define INTS_PACKED_AS_2FLOAT16')\r\n    }\r\n    if (cadAsset.getVersion().compare([0, 0, 29]) >= 0) {\r\n      this.setShaderPreprocessorValue('#define ENABLE_PER_FACE_COLORS')\r\n    }\r\n    if (cadAsset.getVersion().compare([1, 0, 5]) >= 0) {\r\n      this.setShaderPreprocessorValue('#define ENABLE_BODY_EDGES')\r\n    }\r\n\r\n    const glcadAsset = new GLCADAsset(this.__gl, assetId, cadAsset, this.__cadpassdata)\r\n\r\n    glcadAsset.once('loaded', (assetStats) => {\r\n      this.__profiling.numSurfaces += assetStats.numSurfaces\r\n      this.__profiling.numSurfaceInstances += assetStats.numSurfaceInstances\r\n      this.__profiling.surfaceEvalTime += assetStats.surfaceEvalTime\r\n      this.__profiling.numBodies += assetStats.numBodies\r\n      this.__profiling.numMaterials += assetStats.numMaterials\r\n      this.__profiling.numTriangles += assetStats.numTriangles\r\n      this.__profiling.numDrawSets += assetStats.numDrawSets\r\n\r\n      this.__decrementLoadQueue()\r\n    })\r\n\r\n    glcadAsset.on('updated', () => this.emit('updated'))\r\n\r\n    this.__assets.push(glcadAsset)\r\n  }\r\n\r\n  /**\r\n   * The removeCADAsset method.\r\n   * @param {CADAsset} asset - The cadAsset to remove.\r\n   */\r\n  removeCADAsset(asset) {\r\n    this.__assets = this.__assets.filter((glcadAsset) => {\r\n      if (glcadAsset.getCADAsset() == asset) {\r\n        glcadAsset.destroy()\r\n        return false\r\n      }\r\n      return true\r\n    })\r\n    this.emit('updated')\r\n  }\r\n\r\n  /**\r\n   * The getGLCADAsset method.\r\n   * @param {number} index - The index of the cadAsset to retrieve.\r\n   * @return {CADAsset} - The return value.\r\n   */\r\n  getGLCADAsset(index) {\r\n    return this.__assets[index]\r\n  }\r\n\r\n  /**\r\n   * The draw method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @return {any} - The return value.\r\n   */\r\n  draw(renderstate) {\r\n    const gl = this.__gl\r\n\r\n    if (this.__profiling.numBodies == 0) return\r\n    if (SystemDesc.isIOSDevice) {\r\n      throw new Error('The ZeaCAD cannot be supported on iOS due to no ability to render to a FLOAT framebuffer.')\r\n    }\r\n\r\n    if (this.debugTrimTex) {\r\n      if (this.__assets.length > this.debugAssetId) this.__assets[this.debugAssetId].drawTrimSets(renderstate)\r\n    }\r\n    if (this.debugSurfaceAtlas) {\r\n      if (this.__assets.length > this.debugAssetId) this.__assets[this.debugAssetId].drawSurfaceAtlas(renderstate)\r\n      return\r\n    }\r\n\r\n    if (this.displaySurfaces) {\r\n      if (!this.pbrEnabled && renderstate.envMap) {\r\n        // If an env map is detected, automatically enable PBR rendering.\r\n        this.setShaderPreprocessorValue('#define ENABLE_PBR')\r\n        this.pbrEnabled = true\r\n      }\r\n\r\n      if (this.__cadpassdata.materialLibrary.needsUpload()) this.__cadpassdata.materialLibrary.uploadMaterials()\r\n\r\n      // eslint-disable-next-line guard-for-in\r\n      for (const shaderKey in this.__shaderKeys) {\r\n        const shaderReg = this.__shaderKeys[shaderKey]\r\n        shaderReg.shader.bind(renderstate)\r\n        renderstate.shaderId = shaderReg.id\r\n\r\n        if (!this.__cadpassdata.materialLibrary.bind(renderstate)) {\r\n          return false\r\n        }\r\n\r\n        if (renderstate.unifs.headLighting) {\r\n          gl.uniform1i(renderstate.unifs.headLighting.location, this.headLighting)\r\n        }\r\n        if (renderstate.unifs.displayWireframes) {\r\n          gl.uniform1i(renderstate.unifs.displayWireframes.location, this.displayWireframes)\r\n        }\r\n\r\n        const boundTextures = renderstate.boundTextures\r\n        for (const asset of this.__assets) {\r\n          asset.draw(renderstate)\r\n          renderstate.boundTextures = boundTextures\r\n        }\r\n\r\n        shaderReg.shader.unbind(renderstate)\r\n      }\r\n    }\r\n\r\n    if (this.displayNormals) {\r\n      if (!this.__drawCADSurfaceNormalsShader) {\r\n        this.__drawCADSurfaceNormalsShader = this.applyOptsToShader(new GLDrawCADSurfaceNormalsShader(gl))\r\n      }\r\n      if (!this.__drawCADSurfaceNormalsShader.bind(renderstate)) return false\r\n\r\n      gl.uniform1f(renderstate.unifs.normalLength.location, this.normalLength)\r\n      const id = this.__shaderKeys.GLDrawCADSurfaceShader.id\r\n      const boundTextures = renderstate.boundTextures\r\n      for (const asset of this.__assets) {\r\n        asset.drawNormals(renderstate, id)\r\n        renderstate.boundTextures = boundTextures\r\n      }\r\n    }\r\n\r\n    if (this.__displayEdges > 0) {\r\n      if (!this.__drawCADCurvesShader) {\r\n        this.__drawCADCurvesShader = this.applyOptsToShader(new GLDrawCADCurveShader(gl))\r\n      }\r\n      if (!this.__drawCADCurvesShader.bind(renderstate)) return false\r\n\r\n      gl.uniform4f(renderstate.unifs.edgeColor.location, 0.1, 0.1, 0.1, 1)\r\n\r\n      gl.enable(gl.BLEND)\r\n      gl.blendEquation(gl.FUNC_ADD)\r\n      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA) // For add\r\n\r\n      const boundTextures = renderstate.boundTextures\r\n      for (const asset of this.__assets) {\r\n        asset.drawEdges(renderstate, 0)\r\n        renderstate.boundTextures = boundTextures\r\n      }\r\n\r\n      gl.disable(gl.BLEND)\r\n    }\r\n\r\n    // To debug the highlight buffer, enable this line.\r\n    // It will draw the highlight buffer directly to the screen.\r\n    // this.drawHighlightedGeoms(renderstate)\r\n  }\r\n\r\n  /**\r\n   * The drawHighlightedGeoms method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @return {any} - The return value.\r\n   */\r\n  drawHighlightedGeoms(renderstate) {\r\n    if (this.__numHighlightedGeoms == 0) return false\r\n    const gl = this.__gl\r\n    if (!this.__drawSelectedCADSurfaceShader) {\r\n      this.__drawSelectedCADSurfaceShader = this.applyOptsToShader(new GLDrawSelectedCADSurfaceShader(gl))\r\n    }\r\n    if (!this.__drawSelectedCADSurfaceShader.bind(renderstate)) {\r\n      return false\r\n    }\r\n    for (const asset of this.__assets) {\r\n      asset.drawHighlightedGeoms(renderstate)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The drawGeomData method.\r\n   * @param {any} renderstate - The renderstate param.\r\n   * @return {any} - The return value.\r\n   */\r\n  drawGeomData(renderstate) {\r\n    if (this.__profiling.numBodies == 0) return\r\n    if (SystemDesc.isIOSDevice) {\r\n      throw new Error('The ZeaCAD cannot be supported on iOS due to no ability to render to a FLOAT framebuffer.')\r\n    }\r\n\r\n    const gl = this.__gl\r\n    if (!this.__drawCADSurfaceGeomDataShader) {\r\n      this.__drawCADSurfaceGeomDataShader = this.applyOptsToShader(new GLDrawCADSurfaceGeomDataShader(gl))\r\n    }\r\n    if (!this.__drawCADSurfaceGeomDataShader.bind(renderstate)) {\r\n      return false\r\n    }\r\n\r\n    gl.disable(gl.BLEND)\r\n    gl.disable(gl.CULL_FACE)\r\n    gl.enable(gl.DEPTH_TEST)\r\n    gl.depthFunc(gl.LESS)\r\n    gl.depthMask(true)\r\n\r\n    const passIndexUnif = renderstate.unifs.passIndex\r\n    if (passIndexUnif) {\r\n      gl.uniform1i(passIndexUnif.location, this.passIndex)\r\n    }\r\n\r\n    // eslint-disable-next-line guard-for-in\r\n    for (const shaderKey in this.__shaderKeys) {\r\n      const shaderReg = this.__shaderKeys[shaderKey]\r\n      if (shaderReg.shader.nonSelectable) continue\r\n\r\n      renderstate.shaderId = shaderReg.id\r\n      for (const asset of this.__assets) {\r\n        asset.drawGeomData(renderstate)\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The getGeomItemAndDist method.\r\n   * @param {any} geomData - The geomData param.\r\n   * @return {any} - The return value.\r\n   */\r\n  getGeomItemAndDist(geomData) {\r\n    const assetId = Math.round(geomData[0] / 64)\r\n    const geomId = Math.round(geomData[1])\r\n    const dist = geomData[3]\r\n    const geomItem = this.__assets[assetId].getGeomItem(geomId)\r\n\r\n    // console.log(this.__assets[assetId].getSurfaceData(geomId))\r\n\r\n    return {\r\n      geomItem,\r\n      dist,\r\n    }\r\n  }\r\n}\r\n\r\nexport { GLCADPass }\r\n"],"names":["CADCurveTypes","CURVE_TYPE_LINE","CURVE_TYPE_CIRCLE","CURVE_TYPE_ELIPSE","CURVE_TYPE_NURBS_CURVE","CADSurfaceTypes","SURFACE_TYPE_PLANE","SURFACE_TYPE_CONE","SURFACE_TYPE_CYLINDER","SURFACE_TYPE_SPHERE","SURFACE_TYPE_TORUS","SURFACE_TYPE_LINEAR_EXTRUSION","SURFACE_TYPE_REVOLUTION","SURFACE_TYPE_NURBS_SURFACE","SURFACE_TYPE_OFFSET_SURFACE","SURFACE_TYPE_TRIMMED_RECT_SURFACE","SURFACE_TYPE_POLY_PLANE","SURFACE_TYPE_FAN","SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN","getCurveTypeName","id","getSurfaceTypeName","Hull","Lines","[object Object]","numCPsU","numCPsV","super","this","__numSpansU","__numSpansV","__rebuild","setNumVertices","setNumSegments","idx","j","i","v0","v1","setSegmentVertexIndices","CADSurfaceLibrary","cadAsset","trimSetLibrary","__cadAsset","__trimSetLibrary","__curveLibraryBuffer","undefined","__meshes","__hulls","__formFactors","__maxNumKnots","curveLibraryBuffer","surfaceLibraryBuffer","cadDataVersion","__surfaceLibraryBuffer","__surfaceLibraryReader","BinReader","__surfaceLibrarySize","Math","sqrt","byteLength","__numSurfaces","loadUInt32","__totalSurfaceArea","loadFloat32","dims","getSurfaceDims","area","sizeU","sizeV","__curveLibraryReader","__curveLibrarySize","__numCurves","lod","pow","curvatureToDetail","curveId","seek","x","loadFloat16","y","offsetInBytes","addr","getCurveDataTexelCoords","byteOffset","__seekCurveData","curveType","getCurveType","addrX","addrY","curvature","length","flags","getCurveDims","domain","Vec2","radius","majorRadius","minorRadius","degree","numCPs","numKnots","advance","controlPoints","p","Vec4","push","knots","console","warn","surfaceId","loadUFloat16","getSurfaceDataTexelCoords","__seekSurfaceData","surfaceType","getSurfaceType","curvatureU","curvatureV","trimSetId","compare","loadSInt32From2xFloat16","loadTrimSetId","includeTrimSet","readDomain","Box2","p0","p1","trimSet","getTrimSetCurves","points","numPoints","semiAngle","curveIndex","partA","partB","curveData","getCurveData","curve_tr","Vec3","curve_ori","Quat","loadUInt32From2xUFloat16","degreeU","degreeV","numKnotsU","numKnotsV","periodicU","periodicV","knotsU","knotsV","loadFloat16Vec2","u","knotValues","nextKnot","knot","span","n","left","right","bvD","basisValues","saved","r","rv","lv","temp","jr_z","kp_0","kp_1","tmp","ndu","rvlv","ders","a","s1","s2","k","d","rk","pk","j1","j2","fac","surfaceData","params","remap","v","knotValuesU","spanU","findSpan","knotValuesV","spanV","bvdsU","basisValuesU","calcBasisValues","bvdsV","basisValuesV","pos","tangentU","tangentV","w","cvU0","cvV0","vindex","uindex","pt","weight","t","bvU","bvV","bvw","addInPlace","scale","bvdU","bvdV","isNaN","isFinite","scaleInPlace","spanRangeU","spanRangeV","eqKnotRangeU","eqKnotRangeV","cvU","spanLerpV","cvV","floor","pt0","toVec3","pt1","setFromOther","subtract","spanLerpU","normal","cross","normalize","getSurfaceData","M","N","log","quad","Plane","normalsGeom","normalsGeom_PosAttr","getVertexAttribute","voff","positions","normals","calcSurfacePoint","getValueRef","set","z","material","Material","getParameter","setValue","Color","random","normalsGeomMaterial","mesh","hull","index","surfacesData","e","curvesData","ff","CADTrimSetLibrary","__reader","trimSetReader","version","__numTrimSets","__totalTrimSurfaceArea","getTrimSetDim","sideLength","maxTexSize","SystemDesc","gpuDesc","maxTextureSize","xlargeTexSize","largeTexSize","medTexSize","smallTexSize","__texelSizes","data","numAssets","lodId","size_x","size_y","numHoles","numPermiterCurves","loadCurveRef","xfo_tr","xfo_rot","perimeter","holes","hole","numHoleCurves","size","trimSetsData","curves","CADBodyLibrary","buffer","setBinaryBuffer","tocBuffer","__buffer","__size","__toc","__tocReader","__numBodies","bodyDescId","getBodyDataTexelCoords","__seekBodyData","bbox","Box3","loadFloat32Vec3","includeXfosAndColors","numBodySurfaces","numBodyCurves","surfaceRefs","surfaceRef","xfo","Xfo","loadFloat32Quat","color","loadRGBAFloat32Color","curveRefs","curveRef","CADBody","BaseGeomItem","name","__bodyDescId","__id","__bodyBBox","incCADBodyCount","__materialParam","addParameter","MaterialParameter","__colorParam","ColorParameter","cloned","copyFrom","src","getCADAsset","setBodyDescId","getBodyDescId","setMaterial","getMaterial","getBodyLibrary","bodyDescData","getBodyDescData","getSurfaceLibrary","getSurfaceTypeLabel","bodyId","getBodyBBox","_setBoundingBoxDirty","getValue","mode","_cleanBoundingBox","addBox3","reader","context","readBinary","assetItem","loadSInt32","versions","materialName","loadStr","getMaterialLibrary","addMaterial","__layers","loadStrArray","layer","addGeomToLayer","treeItem","TreeItem","getName","forEach","surfaceIndex","generatePolygonSurface","geomItem","GeomItem","addChild","generateHullGeometry","toJSON","fromJSON","register","cadFileExts","RegExp","CADAsset","AssetItem","__surfaceLibrary","__bodyLibrary","__atlasSize","__numCADBodyItems","__loaded","__datafileParam","FilePathParameter","addParameterDeprecationMapping","on","url","file","getFileDesc","metadata","ConvertFile","zcadFile","zcadfileext","map","metadataFile","test","filename","load","BooleanParameter","urlParams","URLSearchParams","window","location","search","has","Number","parseInt","get","deviceCategory","getLOD","max","__materials","cadfileversion","Version","sdk","AssetLoadContext","__loadPromise","Promise","resolve","reject","folder","lastIndexOf","substring","stem","resources","xrefs","emit","incrementAsync","resourceLoader","incrementWorkload","__geomLibrary","once","incrementWorkDone","loadFile","then","entries","treeReader","tree2","tree","isMobileDevice","bodies","setBinaryBuffers","bodiestoc","readRootLevelBinary","setName","getVersion","getEngineDataVersion","geoms","readBinaryBuffer","geomLibraryJSON","JSON","parse","TextDecoder","decode","basePath","loadGeomFilesStream","trimSets","trimsets","trimSets2","surfaces","decrementAsync","error","onDone","loadAssetJSON","LoadFlags","LOAD_FLAG_LOADING_BIN_TREE_VALUES","decAsyncCount","DataFilePath","__datafileLoaded","incAsyncCount","filePathJSON","surfacesTreeItem","traverse","getChildren","childItem","cadBodySurfaces","generatePolygonMeshSurfaces","globalXfo","surfaceLibrary","logFormfactors","hullTreeItem","cadBodyHulls","LOADSTATE","CADAssembly","CADPart","findCADAsset","getOwner","highlightColor","PMIItem","sel","setSelected","activate","deactivate","getParameters","param","linkedEntitiesParam","linkedEntityPaths","pathStr","path","split","linkedEntity","resolvePath","addHighlight","message","removeHighlight","PMIView","camera","cameraXfo","clone","TargetPoint","sc","dist","tr","distanceTo","setFocalDistance","XRef","relativePath","ori","__localXfoParam","loadValue","assets","srcAsset","isLoaded","includes","slice","xref","getPath","SurfaceNormals","Fan","Mesh","vertexCount","faceCount","setFaceCounts","setFaceVertexIndices","SubSet","gl","__gl","__drawCoordsArray","__drawCoordsBuffer","__drawCount","__bindAttr","channels","type","stride","offset","instanced","enableVertexAttribArray","vertexAttribPointer","vertexAttribDivisor","itemsArray","deleteBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","new_Array","Float32Array","renderstate","attrs","drawCoords","FLOAT","drawShaderAttribsStride","__cache","GLSurfaceDrawSet","key","GLMesh","__glgeom","__numTris","__glnormalsgeom","GLLines","__quadDetail","__freeIndices","__subSets","drawCount","setDrawItems","addDrawItems","getDrawCount","subSet","unifs","quadDetail","uniform2i","bind","bindViewports","drawInstanced","destroy","Edge","detail","GLCurveDrawSet","__edgeDetail","__numDrawItems","edgeDetail","uniform1i","GLEvaluateCADCurveShader","GLShader","__shaderStages","shaderLibrary","parseShader","GLCurveLibrary","cadpassdata","surfacesLibrary","__cadpassdata","__surfacesLibrary","curvesDataBuffer","getCurveBuffer","curveTexSize","__curveDataTexture","GLTexture2D","format","width","height","filter","wrap","mipMapped","Uint16Array","curvesAtlasLayout","numCurves","curvesAtlasLayoutTextureSize","curvesAtlasTextureDim","count","__curveAtlasLayoutTexture","__curvesAtlasRenderTarget","resize","GLRenderTarget","__curvesTangentAtlasRenderTarget","shaderopts","directives","bindForWriting","evaluateCurveShader","glplanegeom","curvesAtlasTextureSize","bindToUniform","curveDataTexture","curveDataTextureSize","patchCoords","valuesPerCurveLibraryLayoutItem","curveDataCoords","writeTangents","unbind","finish","curvesAtlasLayoutTexture","bindColorTexture","curvesAtlasTexture","curveTangentsTexture","__data","__byteOffset","__dataView","DataView","__isMobileDevice","utf8decoder","remainingByteLength","result","getUint8","getUint16","getUint32","getInt32","h","s","f","NaN","Infinity","decode16BitFloat","loadUInt16","getFloat16","getFloat32","Uint8Array","readPadd","Uint32Array","numChars","chars","String","fromCharCode","padd","setShaderModule","GLEvaluateCADSurfaceShader_VERTEX_SHADER","GLEvaluateSimpleCADSurfaceShader","GLEvaluateCompoundCADSurfaceShader","GLEvaluateNURBSCADSurfaceShader","GLSurfaceLibrary","EventEmitter","glCurveLibrary","__glCurveLibrary","surfacesDataBuffer","getSurfaceBuffer","surfaceTexSize","__surfaceDataTexture","evaluateSurfaceShaders","__surfaceDrawSets","debugTrimSetsShader","trimSetAtlasTexture","draw","surfacesEvalAttrs","surfacesAtlasLayout","surfaceAtlasLayoutTextureSize","surfacesAtlasTextureDim","t0","performance","now","__surfaceAtlasLayoutTexture","__surfacesAtlasTexture","__surfacesFbo","GLFbo","setClearColor","bindAndClear","__normalsTexture","__normalsFbo","attr","category","shader","compileForTarget","surfaceAtlasLayoutTexture","surfacesAtlasTextureSize","surfaceDataTexture","surfaceDataTextureSize","bindCurvesAtlas","writeNormals","__surfacesAtlasLayout","surfacesDataReader","detailU","detailV","trimSetIndex","surfacesAtlasTexture","normalsTexture","numSurfacesInLibrary","getNumSurfaces","__detail","addVertexAttribute","Float32","vertexIds","setFloat32Value","Strip","__sizeXParam","sizeY","__sizeYParam","detailX","__detailXParam","detailY","__detailYParam","setBoundingBoxDirty","GLTrimCurveDrawSet","trimCurvesDataArray","glfangeom","glstripgeom","__glfangeom","__glstripgeom","bindAttr","numValuesPerTrimSetCurveRef","data0","data1","data2","numCurveVertices","GLDrawTrimCurveFansShader","GLFlattenTrimSetsShader","GLDrawTrimCurveStripsShader","GLDebugTrimSetsShader","setShaderStage","GLTrimSetLibrary","glCurvesLibrary","__glCurvesLibrary","trimSetsBuffer","getBinaryBuffer","trimSetsTexSize","__trimSetsTexture","__trimCurveDrawSets","trimCurveDrawSets","trimSetAtlasTextureSize","trimSetsAtlasLayoutData","trimSetsAtlasLayoutTextureSize","__trimSetsAtlasLayoutTexture","__trimSetAtlasTexture","__trimSetAtlasTextureSize","__trimSetAtlasFbo","__trimSetAtlasMaskTexture","min","__trimSetAtlasMaskFbo","magFilter","minFilter","trimCurveFansShader","flattenTrimSetsShader","trimCurveStripsShader","enable","BLEND","blendEquation","FUNC_ADD","blendFunc","ONE","trimSetTexture","trimSetTextureSize","trimCurveDrawSet","drawFans","disable","uniform1f","stripWidth","flatten","drawStrips","MIN","cleanup","__trimSetsAtlasLayoutData","layout","pixels","readPixels","RED","RGBA","UNSIGNED_BYTE","line","HALF_FLOAT","ext_filter_anisotropic","texParameterf","TEXTURE_2D","TEXTURE_MAX_ANISOTROPY_EXT","trimSetsAtlasLayoutTexture","GLCADBody","cadBody","dirtyValues","Set","sceneBodyItemData","cadBodyTextureData","bodyItemDataChanged","highlightedBodies","highlightChangeBatch","pushhighlightChangeBatchToWorker","cadBodyDescAddr","isVisible","isCutawayEnabled","shaderId","genShaderID","getShaderName","glmaterialcoords","getMetadata","materialLibrary","visibilityChanged","materialChanged","globalXfoParam","updateXfo","globalXfoChanged","add","isHighlighted","updateHighlightColor","highlightChanged","dirty","setTimeout","indexOf","indexInSelChangeSet","unhighlightedBodyIds","splice","highlightedBodyIds","updateCutaway","cutAwayChangedId","cutPlane","getCutVector","cutPlaneDist","getCutDist","cpoff","highlight","getHighlight","hoff","g","b","bodyXfo","off","clear","cutAwayChanged","cutParam","cutAwayEnabledId","kIsNodeJS","Object","prototype","toString","call","process","kRequire","module","require","base64","sourcemap","enableUnicode","source","Buffer","from","nodeDecodeBase64","binaryString","atob","binaryView","Array","el","arr","charCodeAt","apply","browserDecodeBase64","start","body","Worker","options","assign","eval","blob","Blob","URL","createObjectURL","GLCADAsset","assetId","__assetId","getNumBodies","__numMaterials","getNumMaterials","__numHighlightedGeoms","__ready","__visible","__assetVisibilityChanged","updateDisplayEdges","displayEdges","incDisplayEdges","decDisplayEdges","displayEdgesChangedId","updateEdgeColor","edgeColor","asArray","edgesColorChangedId","__curveLibrary","getTrimSetLibrary","bodyLibraryBuffer","bodyTexSize","__bodyDescTexture","__curveDrawSets","loadWorker","incHighlightedCount","decHighlightedCount","numBodyItems","getNumBodyItems","cadBodiesTextureSize","MathFunctions","nextPow2","round","cadBodiesTextureData","assetBBox","__assetCentroid","sceneBodyItemsData","__cadBodies","__postMessageToWorker","eventType","__dirtyBodyIndices","bindCADBody","sceneBodyItemDataByteOffset","cadBodyTextureDataByteOffset","pixelsPerCADBody","glCADBody","__cadBodiesTexture","unitsScale","getUnitsConversion","assetBBoxRadius","arcAngle","PI","errorTolerance","cos","trimTexelSize","assetCount","getTexelSize","bodyLibraryBufferToc","getToc","transferables","assemblyData","surfaceAreaThreshold","texId","TEXTURE0","boundTextures","activeTexture","bindTexture","glTex","yoffset","xoffset","updateCadBodyTex","populate","__worker","GLCADAssetWorker","onmessage","event","__onWorkerMessage","postMessage","debugMode","profiling","evaluateCurves","values","surfaceEvalTime","evaluateSurfaces","surfacesAtlasLayoutTextureSize","evaluateTrimSets","__bodyAtlasDim","bodyAtlasDim","updateDrawSets","surfaceDrawSets","curveDrawSets","numSurfaces","numSurfaceInstances","numBodies","numMaterials","numTriangles","numDrawSets","drawSetKey","highlightedSurfaceDrawSets","drawSet","numHighlighted","numUnhighlighted","parts","drawSetData","subSetKey","drawItemsData","__drawItemsTarget","drawItemsTexture","vert_drawItemsTextureSize","frag_drawItemsTextureSize","bodyDescTexture","bodyDescTextureSize","bodyDescTextureSize_frag","cadBodiesTexture","cadBodiesTextureSize_vert","cadBodiesTextureSize_frag","assetCentroid","uniform3fv","updateBodyTexture","bindSurfacesAtlas","bindTrimSetAtlasLayout","bindTrimSetAtlas","shaderKey","drawNormals","uniform4fv","assetIndexUnif","assetIndex","drawSurfaceAtlas","drawTrimSets","GLCADMaterialLibrary","__materialDatas","__dirtyIndices","__numItems","__materialPacker","GrowingPacker","__needsUpload","coords","addBlock","materialId","setMetadata","root","__materialsTexture","Error","typeId","getTypeID","formatId","getFormatID","value","materialData","shaderClass","Registry","getBlueprint","getPackedMaterialData","matData","texSubImage2D","unit16s","convertFloat32ArrayToUInt16Array","materialsTexture","materialsTextureSize","GLCADShader","stack","getState","pop","applyOptions","state","defines","join","__key","GLDrawCADSurfaceNormalsShader","nonSelectable","paramDescs","getParamDeclarations","defaultValue","GLDrawCADSurfaceShader_VERTEX_SHADER","envMap","exposure","texturable","baseColor","GLDrawCADSurfaceGeomDataShader","GLDrawSelectedCADSurfaceShader","GLDrawCADCurveShader","GLCADPass","GLPass","headLighting","displayWireframes","displaySurfaces","__displayEdges","displayNormals","normalLength","debugTrimTex","debugSurfaceAtlas","debugAssetId","pbrEnabled","__assets","__loadQueue","__shaderCount","__shaderKeys","__shaderOptsStack","__profiling","val","renderer","passIndex","init","__dataLoadStartTime","setShaderPreprocessorValue","shaderName","applyOptsToShader","constructClass","__decrementLoadQueue","rargs","addCADAsset","continueInSubTree","removeCADAsset","getShaderState","startsWith","shaderReg","setPreprocessorValue","__drawSelectedCADSurfaceShader","__drawCADSurfaceGeomDataShader","__renderer","requestRedraw","clearPreprocessorValue","opts","pushState","popState","pushShaderState","popShaderState","__cutPlaneNormalParam","__cutDistParam","__cutPlaneColorParam","__gpuLoadStartTime","glcadAsset","assetStats","asset","isIOSDevice","needsUpload","uploadMaterials","__drawCADSurfaceNormalsShader","GLDrawCADSurfaceShader","__drawCADCurvesShader","uniform4f","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","drawEdges","drawHighlightedGeoms","CULL_FACE","DEPTH_TEST","depthFunc","LESS","depthMask","passIndexUnif","drawGeomData","geomData","geomId","getGeomItem"],"mappings":"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"}