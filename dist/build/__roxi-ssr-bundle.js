(() => {
  var __defProp = Object.defineProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
  var __commonJS = (callback, module) => () => {
    if (!module) {
      module = {exports: {}};
      callback(module.exports, module);
    }
    return module.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, {get: all[name2], enumerable: true});
  };

  // dist/build/_fallback-7aee0e06.js
  var require_fallback_7aee0e06 = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => h3
    });
    function v3(s3) {
      let a3, t3, d3, f3, v4, g4, h4, m3;
      return {c() {
        a3 = N2("div"), t3 = N2("div"), t3.textContent = "404", d3 = A2(), f3 = N2("div"), v4 = T2("Page not found.\r\n    \r\n    "), g4 = N2("a"), h4 = T2("Go back"), D2(t3, "class", "huge svelte-s04wto"), D2(g4, "href", m3 = s3[0]("../")), D2(f3, "class", "big"), D2(a3, "class", "e404 svelte-s04wto");
      }, m(s4, e3) {
        I2(s4, a3, e3), E2(a3, t3), E2(a3, d3), E2(a3, f3), E2(f3, v4), E2(f3, g4), E2(g4, h4);
      }, p(s4, [a4]) {
        1 & a4 && m3 !== (m3 = s4[0]("../")) && D2(g4, "href", m3);
      }, i: t2, o: t2, d(s4) {
        s4 && S2(a3);
      }};
    }
    function g3(s3, a3, t3) {
      let e3;
      return p2(s3, Ee2, (s4) => t3(0, e3 = s4)), [e3];
    }
    var h3 = class extends Kt {
      constructor(s3) {
        super(), Ht(this, s3, g3, v3, a2, {});
      }
    };
  });

  // dist/build/examples-0cc77ff1.js
  var require_examples_0cc77ff1 = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => r3
    });
    function u3(a3) {
      let s3;
      return {c() {
        s3 = N2("div"), s3.innerHTML = '<h1 class="mb-3 text-2xl">Examples</h1> \n\n  <ul class="underline text-blue-500"><li><a class="hover:text-blue-400" href="/login?zcad=/data/gear_box_final_asm-visu.zcad">gear_box_final_asm-visu.zcad</a></li> \n    <li><a class="hover:text-blue-400" href="/login?zcad=/data/Hospital/Autodesk_Hospital_HVAC.zcad">Autodesk_Hospital_HVAC.zcad</a></li> \n    <li><a class="hover:text-blue-400" href="/login?zcad=/data/Hospital/Autodesk_Hospital_Structural.zcad">Autodesk_Hospital_Structural.zcad</a></li></ul>', D2(s3, "class", "m-3");
      }, m(a4, l3) {
        I2(a4, s3, l3);
      }, p: t2, i: t2, o: t2, d(a4) {
        a4 && S2(s3);
      }};
    }
    var r3 = class extends Kt {
      constructor(a3) {
        super(), Ht(this, a3, null, u3, a2, {});
      }
    };
  });

  // dist/build/index-6246489a.js
  var require_index_6246489a = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => Nl
    });
    var He3 = et(It);
    var je3 = it(function(e3, t3) {
      !function(e4, t4) {
        var n3 = {name: "@zeainc/zea-ux", version: "4.1.0", description: "Zea UX", main: "dist/index.cjs.js", module: "dist/index.esm.js", browser: "dist/index.umd.js", types: "dist/zea-ux.d.ts", files: ["dist/", "css/"], keywords: ["Zea", "UX"], scripts: {"build:tsc": "npx tsc", "build:tsc:watch": "npx tsc --watch", "clean:build": "rm -Rf dist/ buildcache", "build:rollup": "rollup -c", "build:rollup:watch": "rollup -w -c", build: "npm-run-all clean:build build:rollup", dev: "npm-run-all --parallel build:rollup:watch start:watch", start: "es-dev-server --app-index testing-e2e/index.html --open", "start:watch": "es-dev-server --app-index testing-e2e/index.html --open --watch", release: "standard-version", dist: "yarn publish --access=public", docs: "adg --config adg.config.json", "docs-w": "adg -w --config=adg.config.json", "docs:serve": "docsify serve docs/", lint: "eslint src/", prepare: "yarn run build", test: "jest", generate: "plop", "test:coverage": "jest --coverage", "test:debug": "node --inspect ./node_modules/jest/bin/jest.js --runInBand --watch", "test:watch": "jest --watch", "test:e2e": "percy exec cypress run --browser chrome --headless", "test:e2e:watch": "percy exec cypress open", "to-cleanup": "rm -Rf dist/ node_modules/ yarn.lock", "to-link-packages": "yarn link @zeainc/zea-engine"}, repository: {type: "git", url: "git+ssh://git@github.com/ZeaInc/zea-ux.git"}, bugs: {url: "https://github.com/ZeaInc/zea-ux/issues"}, homepage: "https://github.com/ZeaInc/zea-ux#readme", author: "Zea Inc.", license: "MIT", devDependencies: {"@babel/preset-env": "^7.12.7", "@percy/cypress": "^2.3.1", "@rollup/plugin-commonjs": "^21.0.1", "@rollup/plugin-json": "^4.1.0", "@rollup/plugin-node-resolve": "^13.0.6", "@zeainc/jsdocs2md": "^0.0.7", "@zeainc/zea-collab": "^6.0.1", "@zeainc/zea-engine": "^4", canvas: "^2.6.1", copyfiles: "^2.4.1", cypress: "^5.6.0", "docsify-cli": "^4.4.2", documentation: "^13.1.0", "es-dev-server": "^1.60.1", eslint: "^7.14.0", "eslint-config-google": "^0.14.0", "eslint-config-prettier": "^6.15.0", "eslint-plugin-prettier": "^3.2.0", husky: "^4.3.0", "husky-run": "^0.0.0", jest: "^26.6.3", "npm-run-all": "^4.1.5", plop: "^2.7.4", prettier: "^2.2.1", rollup: "^2.34.1", "rollup-plugin-commonjs": "^10.1.0", "rollup-plugin-dts": "^4.1.0", "rollup-plugin-node-resolve": "^5.2.0", "rollup-plugin-terser": "^7.0.2", "rollup-plugin-typescript": "^1.0.1", "standard-version": "^9.0.0", "ts-node": "^10.4.0", tslib: "^2.3.1", typescript: "^4.4.4"}, dependencies: {"dom-to-image": "^2.6.0"}, husky: {hooks: {"disabled=pre-commit": "npm test", "disabled=pre-push": "npm test"}}};
        function i3(e5) {
          if (e5 !== void 0) {
            if (e5 instanceof t4.ZeaMouseEvent)
              return e5.pointerRay;
            if (e5 instanceof t4.ZeaTouchEvent)
              return e5.touches[0].touchRay;
            if (e5 instanceof t4.XRControllerEvent) {
              const n4 = e5.controller.getTipXfo(), i4 = n4.ori.getZaxis().negate();
              return new t4.Ray(n4.tr, i4);
            }
            return console.warn("unhandled pointer event"), new t4.Ray();
          }
          console.warn("undefined event");
        }
        class s3 extends t4.TreeItem {
          constructor(e5) {
            super(e5), this.captured = false, this.colorParam = new t4.ColorParameter("Color", new t4.Color()), this.highlightColorParam = new t4.ColorParameter("HighlightColor", new t4.Color(1, 1, 1)), this.addParameter(this.colorParam), this.addParameter(this.highlightColorParam);
          }
          highlight() {
            this.emit("highlight");
          }
          unhighlight() {
            this.emit("unhighlight");
          }
          getManipulationPlane() {
            const e5 = this.globalXfoParam.value;
            return new t4.Ray(e5.tr, e5.ori.getZaxis());
          }
          onPointerEnter(e5) {
            this.highlight();
          }
          onPointerLeave(e5) {
            this.unhighlight();
          }
          onPointerDown(e5) {
            e5.setCapture(this), e5.stopPropagation(), this.captured = true, this.changedTouches && this.highlight(), e5.pointerType == "mouse" || e5.pointerType == "touch" ? this.handlePointerDown(e5) : e5.pointerType == "xr" && this.onVRControllerButtonDown(e5);
          }
          onPointerMove(e5) {
            this.captured && (e5.stopPropagation(), e5.pointerType == "mouse" || e5.pointerType == "touch" ? this.handlePointerMove(e5) : e5.pointerType == "xr" && this.onVRPoseChanged(e5)), e5.preventDefault();
          }
          onPointerUp(e5) {
            this.captured && (e5.releaseCapture(), e5.stopPropagation(), this.captured = false, this.changedTouches && this.unhighlight(), e5.pointerType == "mouse" || e5.pointerType == "touch" ? this.handlePointerUp(e5) : e5.pointerType == "xr" && this.onVRControllerButtonUp(e5));
          }
          onWheel(e5) {
          }
          handlePointerDown(e5) {
            this.gizmoRay = this.getManipulationPlane();
            const t5 = i3(e5), n4 = t5.intersectRayPlane(this.gizmoRay);
            this.grabPos = t5.pointAtDist(n4), this.onDragStart(e5);
          }
          handlePointerMove(e5) {
            const t5 = i3(e5), n4 = t5.intersectRayPlane(this.gizmoRay);
            this.holdPos = t5.pointAtDist(n4), this.onDrag(e5);
          }
          handlePointerUp(e5) {
            const t5 = i3(e5);
            if (t5) {
              const e6 = t5.intersectRayPlane(this.gizmoRay);
              this.releasePos = t5.pointAtDist(e6);
            }
            this.onDragEnd(e5);
          }
          onVRControllerButtonDown(e5) {
            this.activeController = e5.controller;
            const t5 = this.activeController.getTipXfo().clone(), n4 = this.getManipulationPlane(), i4 = t5.tr.subtract(n4.start), s4 = t5.tr.subtract(n4.dir.scale(i4.dot(n4.dir)));
            this.grabPos = s4, this.onDragStart(e5);
          }
          onVRPoseChanged(e5) {
            if (this.activeController) {
              const t5 = this.activeController.getTipXfo(), n4 = this.getManipulationPlane(), i4 = t5.tr.subtract(n4.start), s4 = t5.tr.subtract(n4.dir.scale(i4.dot(n4.dir)));
              this.holdPos = s4, this.onDrag(e5);
            }
          }
          onVRControllerButtonUp(e5) {
            this.activeController == e5.controller && (this.activeController.getTipXfo(), this.onDragEnd(e5), this.activeController = void 0);
          }
          onDragStart(e5) {
            console.warn("@Handle#onDragStart - Implement me!", e5);
          }
          onDrag(e5) {
            console.warn("@Handle#onDrag - Implement me!", e5);
          }
          onDragEnd(e5) {
            console.warn("@Handle#onDragEnd - Implement me!", e5);
          }
          setTargetParam(e5, t5) {
            console.warn("setTargetParam not implemented");
          }
        }
        class r3 extends s3 {
          constructor(e5) {
            super(e5);
          }
          handlePointerDown(e5) {
            this.gizmoRay = this.getManipulationPlane();
            const t5 = i3(e5);
            this.grabDist = t5.intersectRayVector(this.gizmoRay)[1];
            const n4 = this.gizmoRay.pointAtDist(this.grabDist);
            this.grabPos = n4, this.onDragStart(e5);
          }
          handlePointerMove(e5) {
            const t5 = i3(e5).intersectRayVector(this.gizmoRay)[1];
            this.holdPos = this.gizmoRay.pointAtDist(t5), this.holdDist = t5, this.value = t5, this.delta = t5 - this.grabDist, this.onDrag(e5);
          }
          handlePointerUp(e5) {
            const t5 = i3(e5);
            if (t5) {
              const e6 = t5.intersectRayVector(this.gizmoRay)[1], n4 = this.gizmoRay.pointAtDist(e6);
              this.releasePos = n4;
            }
            this.onDragEnd(e5);
          }
          onVRControllerButtonDown(e5) {
            this.gizmoRay = this.getManipulationPlane(), this.activeController = e5.controller;
            const t5 = this.activeController.getTipXfo();
            this.grabDist = t5.tr.subtract(this.gizmoRay.start).dot(this.gizmoRay.dir), this.grabPos = this.gizmoRay.start.add(this.gizmoRay.dir.scale(this.grabDist)), this.onDragStart(e5);
          }
          onVRPoseChanged(e5) {
            const t5 = this.activeController.getTipXfo().tr.subtract(this.gizmoRay.start).dot(this.gizmoRay.dir);
            this.holdPos = this.gizmoRay.start.add(this.gizmoRay.dir.scale(t5)), this.value = t5, this.delta = t5 - this.grabDist, this.onDrag(e5);
          }
          onVRControllerButtonUp(e5) {
            this.activeController == e5.controller && (this.onDragEnd(), this.activeController = void 0);
          }
        }
        class a3 extends t4.EventEmitter {
          constructor() {
            super(), this.__undoStack = [], this.__redoStack = [], this.__currChange = null, this.__currChangeUpdated = this.__currChangeUpdated.bind(this);
          }
          flush() {
            for (const e5 of this.__undoStack)
              e5.destroy();
            this.__undoStack = [];
            for (const e5 of this.__redoStack)
              e5.destroy();
            this.__redoStack = [], this.__currChange && (this.__currChange.off("updated", this.__currChangeUpdated), this.__currChange = null);
          }
          addChange(e5) {
            this.__currChange && this.__currChange.off && this.__currChange.off("updated", this.__currChangeUpdated), this.__undoStack.push(e5), this.__currChange = e5, this.__currChange.on && this.__currChange.on("updated", this.__currChangeUpdated);
            for (const e6 of this.__redoStack)
              e6.destroy();
            this.__redoStack = [], this.emit("changeAdded", {change: e5});
          }
          getCurrentChange() {
            return this.__currChange;
          }
          __currChangeUpdated(e5) {
            this.emit("changeUpdated", e5);
          }
          undo(e5 = true) {
            if (this.__undoStack.length > 0) {
              this.__currChange && (this.__currChange.off("updated", this.__currChangeUpdated), this.__currChange = null);
              const t5 = this.__undoStack.pop();
              t5.undo(), e5 && (this.__redoStack.push(t5), this.emit("changeUndone"));
            }
          }
          cancel() {
            this.__undoStack.length > 0 && (this.__currChange && (this.__currChange.off("updated", this.__currChangeUpdated), this.__currChange = null), this.__undoStack.pop().undo());
          }
          redo() {
            if (this.__redoStack.length > 0) {
              const e5 = this.__redoStack.pop();
              e5.redo(), this.__undoStack.push(e5), this.emit("changeRedone");
            }
          }
          constructChange(e5) {
            return t4.Registry.constructClass(e5);
          }
          static isChangeClassRegistered(e5) {
            try {
              return t4.Registry.getClassName(Object.getPrototypeOf(e5).constructor), true;
            } catch (e6) {
              return false;
            }
          }
          static getChangeClassName(e5) {
            return t4.Registry.getClassName(Object.getPrototypeOf(e5).constructor);
          }
          static registerChange(e5, n4) {
            t4.Registry.register(e5, n4);
          }
          static getInstance() {
            return o3 || (o3 = new a3()), o3;
          }
        }
        let o3;
        class l3 extends t4.EventEmitter {
          constructor(e5) {
            super(), this.secondaryChanges = [], this.suppressPrimaryChange = false, this.name = e5 || a3.getChangeClassName(this);
          }
          addSecondaryChange(e5) {
            const t5 = this.secondaryChanges.length;
            return this.secondaryChanges.push(e5), t5;
          }
          undo() {
            this.secondaryChanges.forEach((e5) => e5.undo());
          }
          redo() {
            this.secondaryChanges.forEach((e5) => e5.redo());
          }
          update(e5) {
            throw new Error("Implement me");
          }
          toJSON(e5) {
            return {};
          }
          fromJSON(e5, t5) {
          }
          updateFromJSON(e5) {
            this.update(e5);
          }
          destroy() {
          }
        }
        class h3 extends l3 {
          constructor(e5, t5) {
            e5 ? (super(e5 ? e5.getName() + " Changed" : "ParameterValueChange"), this.prevValue = e5.getValue(), this.param = e5, t5 != null && (this.nextValue = t5, this.param.value = this.nextValue)) : super();
          }
          undo() {
            this.param && !this.suppressPrimaryChange && (this.param.value = this.prevValue), super.undo();
          }
          redo() {
            this.param && !this.suppressPrimaryChange && (this.param.value = this.nextValue), super.redo();
          }
          update(e5) {
            this.param && (this.nextValue = e5.value, this.param.value = this.nextValue, this.emit("updated", e5));
          }
          toJSON(e5) {
            const t5 = {name: this.name, paramPath: this.param.getPath()};
            return this.nextValue != null && (this.nextValue.toJSON ? t5.value = this.nextValue.toJSON() : t5.value = this.nextValue), t5;
          }
          fromJSON(e5, n4) {
            const i4 = n4.appData.scene.getRoot().resolvePath(e5.paramPath, 1);
            i4 && i4 instanceof t4.Parameter ? (this.param = i4, this.prevValue = this.param.getValue(), this.prevValue.clone ? this.nextValue = this.prevValue.clone() : this.nextValue = this.prevValue, this.name = e5.name, e5.value != null && this.updateFromJSON(e5)) : console.warn("resolvePath is unable to resolve", e5.paramPath);
          }
          updateFromJSON(e5) {
            this.param && (this.nextValue.fromJSON ? this.nextValue.fromJSON(e5.value) : this.nextValue = e5.value, this.param.value = this.nextValue);
          }
        }
        a3.registerChange("ParameterValueChange", h3);
        class c3 extends t4.Material {
          constructor(e5) {
            super(e5), this.baseColorParam = new t4.MaterialColorParam("BaseColor", new t4.Color(1, 1, 0.5)), this.maintainScreenSizeParam = new t4.NumberParameter("MaintainScreenSize", 0), this.overlayParam = new t4.NumberParameter("Overlay", 0, [0, 1]), this.__shaderName = "HandleShader", this.addParameter(this.baseColorParam), this.addParameter(this.maintainScreenSizeParam), this.addParameter(this.overlayParam);
          }
        }
        t4.Registry.register("HandleMaterial", c3);
        class d3 extends t4.GLShader {
          constructor(e5) {
            super(e5), this.__shaderStages.VERTEX_SHADER = t4.shaderLibrary.parseShader("HandleShader.vertexShader", '\nprecision highp float;\n\nattribute vec3 positions;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="drawItemId.glsl"/>\n<%include file="drawItemTexture.glsl"/>\n<%include file="modelMatrix.glsl"/>\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\n#ifdef ENABLE_MULTI_DRAW\n<%include file="materialparams.glsl"/>\n#else\nuniform int MaintainScreenSize;\nuniform float Overlay;\n#endif\n\n/* VS Outputs */\nvarying float v_drawItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n\nvoid main(void) {\n  int drawItemId = getDrawItemId();\n  v_drawItemId = float(drawItemId);\n  v_geomItemData  = getInstanceData(drawItemId);\n\n  //////////////////////////////////////////////\n  // Material\n\n#ifdef ENABLE_MULTI_DRAW\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 materialValue1 = getMaterialValue(materialCoords, 1);\n  int maintainScreenSize = int(materialValue1.x + 0.5);\n  float overlay = materialValue1.y;\n#else\n  int maintainScreenSize = MaintainScreenSize;\n  float overlay = Overlay;\n#endif\n\n  //////////////////////////////////////////////\n  // Matrix\n  \n  mat4 modelMatrix = getModelMatrix(drawItemId);\n  if (maintainScreenSize != 0) {\n    // Remove the scale from the model matrix.\n    vec3 row0 = normalize(vec3(modelMatrix[0][0], modelMatrix[0][1], modelMatrix[0][2]));\n    vec3 row1 = normalize(vec3(modelMatrix[1][0], modelMatrix[1][1], modelMatrix[1][2]));\n    vec3 row2 = normalize(vec3(modelMatrix[2][0], modelMatrix[2][1], modelMatrix[2][2]));\n    modelMatrix = mat4(\n      row0.x, row0.y, row0.z, 0.0,\n      row1.x, row1.y, row1.z, 0.0,\n      row2.x, row2.y, row2.z, 0.0,\n      modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2], 1.0\n    );\n  }\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  if (maintainScreenSize != 0) {\n    float dist = modelViewMatrix[3][2];\n    float sc = abs(dist); // Note: items in front of the camera will have a negative value here.\n    mat4 scmat = mat4(\n      sc, 0.0, 0.0, 0.0,\n      0.0, sc, 0.0, 0.0,\n      0.0, 0.0, sc, 0.0,\n      0.0, 0.0, 0.0, 1.0\n    );\n    modelViewMatrix = modelViewMatrix * scmat;\n  }\n\n  vec4 viewPos = modelViewMatrix * vec4(positions, 1.0);\n  gl_Position = projectionMatrix * viewPos;\n\n  if(overlay > 0.0){\n    gl_Position.z = mix(gl_Position.z, -gl_Position.w, overlay);\n  }\n\n  v_viewPos = viewPos.xyz;\n  v_textureCoord = texCoords;\n  v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y\n}\n'), this.__shaderStages.FRAGMENT_SHADER = t4.shaderLibrary.parseShader("HandleShader.fragmentShader", `
precision highp float;

<%include file="GLSLUtils.glsl"/>
<%include file="math/constants.glsl"/>
<%include file="drawItemTexture.glsl"/>
<%include file="stack-gl/gamma.glsl"/>
<%include file="materialparams.glsl"/>


#if defined(DRAW_COLOR)

uniform color BaseColor;

#ifdef ENABLE_TEXTURES
uniform sampler2D BaseColorTex;
uniform int BaseColorTexType;
#endif

#elif defined(DRAW_GEOMDATA)

uniform int isOrthographic;
import 'surfaceGeomData.glsl'

#elif defined(DRAW_HIGHLIGHT)

#ifdef ENABLE_FLOAT_TEXTURES
vec4 getHighlightColor(int id) {
  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 4);
}
#else // ENABLE_FLOAT_TEXTURES

uniform vec4 highlightColor;

vec4 getHighlightColor() {
    return highlightColor;
}

#endif // ENABLE_FLOAT_TEXTURES

#endif // DRAW_HIGHLIGHT

/* VS Outputs */
varying float v_drawItemId;
varying vec4 v_geomItemData;
varying vec3 v_viewPos;
#ifdef ENABLE_TEXTURES
varying vec2 v_textureCoord;
#endif


#ifdef ENABLE_ES3
  out vec4 fragColor;
#endif
void main(void) {
#ifndef ENABLE_ES3
  vec4 fragColor;
#endif

  int drawItemId = int(v_drawItemId + 0.5);

  //////////////////////////////////////////////
  // Color
#if defined(DRAW_COLOR)


#ifdef ENABLE_MULTI_DRAW

  vec2 materialCoords = v_geomItemData.zw;
  vec4 baseColor = toLinear(getMaterialValue(materialCoords, 0));

#else // ENABLE_MULTI_DRAW

#ifndef ENABLE_TEXTURES
  vec4 baseColor = toLinear(BaseColor);
#else
  vec4 baseColor = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, v_textureCoord);
#endif // ENABLE_TEXTURES

#endif // ENABLE_MULTI_DRAW

  fragColor = baseColor;

#ifdef ENABLE_INLINE_GAMMACORRECTION
  fragColor.rgb = toGamma(fragColor.rgb);
#endif

  //////////////////////////////////////////////
  // GeomData
#elif defined(DRAW_GEOMDATA)

  fragColor = setFragColor_geomData(v_viewPos, floatGeomBuffer, passId, v_drawItemId, isOrthographic);
  //////////////////////////////////////////////
  // Highlight
#elif defined(DRAW_HIGHLIGHT)
  
  fragColor = getHighlightColor(drawItemId);

#endif // DRAW_HIGHLIGHT


#ifndef ENABLE_ES3
  gl_FragColor = fragColor;
#endif
}
`);
          }
          static getPackedMaterialData(e5) {
            const t5 = new Float32Array(8), n4 = e5.getParameter("BaseColor").getValue();
            return t5[0] = n4.r, t5[1] = n4.g, t5[2] = n4.b, t5[3] = n4.a, t5[4] = e5.getParameter("MaintainScreenSize").getValue(), t5[5] = e5.getParameter("Overlay").getValue(), t5;
          }
          static isOverlay() {
            return true;
          }
          static getMaterialTemplate() {
            return u3;
          }
        }
        const u3 = new c3("HandleShader_template");
        t4.Registry.register("HandleShader", d3);
        const f3 = (e5, t5) => {
          e5.update();
          const n4 = e5.getVertexAttribute("positions");
          for (let e6 = 0; e6 < n4.getCount(); e6++) {
            const i4 = n4.getValueRef(e6), s4 = t5.transformVec3(i4);
            i4.set(s4.x, s4.y, s4.z);
          }
        };
        class m3 extends l3 {
          constructor(e5, t5) {
            super("SelectionXfoChange"), this.treeItems = [], this.localXfos = [], this.prevValues = [], this.newValues = [], this.treeItems = e5, this.baseXfo = t5;
            const n4 = t5.inverse();
            this.treeItems.forEach((e6) => {
              this.localXfos.push(n4.multiply(e6.globalXfoParam.value)), this.prevValues.push(e6.globalXfoParam.value), this.newValues.push(e6.globalXfoParam.value);
            });
          }
          setDeltaXfo(e5) {
            const t5 = this.baseXfo.clone();
            t5.tr = e5.tr.add(t5.tr), t5.ori = e5.ori.multiply(t5.ori), t5.sc = e5.sc.multiply(t5.sc), this.prevValues.forEach((e6, n4) => {
              const i4 = t5.multiply(this.localXfos[n4]);
              this.newValues[n4] = i4, this.treeItems[n4].globalXfoParam.value = this.newValues[n4].clone();
            }), this.emit("updated");
          }
          setDone() {
            this.emit("done");
          }
          undo() {
            this.treeItems.forEach((e5, t5) => {
              e5.globalXfoParam.value = this.prevValues[t5];
            }), super.undo();
          }
          redo() {
            this.treeItems.forEach((e5, t5) => {
              e5.globalXfoParam.value = this.newValues[t5];
            }), super.redo();
          }
          update(e5) {
            this.newValues = e5.newValues, this.treeItems.forEach((e6, t5) => {
              e6.globalXfoParam.value = this.newValues[t5];
            }), this.emit("updated", e5);
          }
          toJSON(e5) {
            const t5 = {name: this.name, treeItems: [], prevValues: [], newValues: []};
            return this.treeItems.forEach((e6, n4) => {
              t5.treeItems[n4] = this.treeItems[n4].getPath(), t5.prevValues[n4] = this.prevValues[n4].toJSON(), t5.newValues[n4] = this.newValues[n4].toJSON();
            }), t5;
          }
          fromJSON(e5, n4) {
            const i4 = n4.appData.scene.getRoot().resolvePath(e5.paramPath, 1);
            i4 && i4 instanceof t4.Parameter ? e5.treeItems.forEach((i5, s4) => {
              this.treeItems[s4] = n4.appData.scene.getRoot().resolvePath(i5, 1), this.prevValues[s4] || (this.prevValues[s4] = new t4.Xfo()), this.prevValues[s4].fromJSON(e5.prevValues[s4]), this.newValues[s4] || (this.newValues[s4] = new t4.Xfo()), this.newValues[s4].fromJSON(e5.newValues[s4]);
            }) : console.warn("resolvePath is unable to resolve", e5.paramPath);
          }
          updateFromJSON(e5) {
            e5.treeItems.forEach((t5, n4) => {
              this.prevValues[n4].fromJSON(e5.prevValues[n4]), this.newValues[n4].fromJSON(e5.newValues[n4]);
            });
          }
        }
        a3.registerChange("SelectionXfoChange", m3);
        class g3 extends r3 {
          constructor(e5, n4 = 0.1, i4 = 3e-3, s4 = new t4.Color()) {
            super(e5), this.colorParam.value = s4, this.handleMat = new t4.Material("handle", "HandleShader"), this.handleMat.getParameter("BaseColor").value = s4, this.handleMat.getParameter("MaintainScreenSize").value = 1, this.handleMat.getParameter("Overlay").value = 0.9;
            const r4 = new t4.Cylinder(i4, n4, 64);
            r4.baseZAtZeroParam.value = true;
            const a4 = new t4.Cone(4 * i4, 10 * i4, 64, true), o4 = new t4.GeomItem("handle", r4, this.handleMat), l4 = new t4.GeomItem("tip", a4, this.handleMat), h4 = new t4.Xfo();
            h4.tr.set(0, 0, n4), f3(a4, h4), this.colorParam.on("valueChanged", () => {
              this.handleMat.getParameter("BaseColor").value = this.colorParam.getValue();
            }), this.addChild(o4), this.addChild(l4);
          }
          highlight() {
            super.highlight(), this.handleMat.getParameter("BaseColor").value = this.highlightColorParam.getValue();
          }
          unhighlight() {
            super.unhighlight(), this.handleMat.getParameter("BaseColor").value = this.colorParam.getValue();
          }
          setSelectionGroup(e5) {
            this.selectionGroup = e5;
          }
          setTargetParam(e5, t5 = true) {
            if (this.param = e5, t5) {
              const t6 = () => {
                this.globalXfoParam.value = e5.getValue();
              };
              t6(), e5.on("valueChanged", t6);
            }
          }
          getTargetParam() {
            return this.param ? this.param : this.globalXfoParam;
          }
          onDragStart(e5) {
            const t5 = this.getTargetParam();
            if (this.baseXfo = t5.getValue(), this.selectionGroup) {
              const e6 = this.selectionGroup.getItems();
              this.change = new m3(Array.from(e6), this.globalXfoParam.value), a3.getInstance().addChange(this.change);
            } else
              this.change = new h3(t5), a3.getInstance().addChange(this.change);
          }
          onDrag(e5) {
            const n4 = this.holdPos.subtract(this.grabPos);
            if (this.selectionGroup) {
              const e6 = this.change, i4 = new t4.Xfo(n4);
              e6.setDeltaXfo(i4);
            } else {
              const e6 = this.baseXfo.clone();
              e6.tr.addInPlace(n4), this.change.update({value: e6});
            }
          }
          onDragEnd(e5) {
            this.selectionGroup && this.change.setDone(), this.change = null;
          }
        }
        class p3 extends s3 {
          constructor(e5) {
            super(e5);
          }
          setSelectionGroup(e5) {
            this.selectionGroup = e5;
          }
          setTargetParam(e5, t5 = true) {
            if (this.param = e5, t5) {
              const t6 = () => {
                this.globalXfoParam.value = e5.getValue();
              };
              t6(), e5.on("valueChanged", t6);
            }
          }
          getTargetParam() {
            return this.param ? this.param : this.globalXfoParam;
          }
          onDragStart(e5) {
            if (this.baseXfo = this.globalXfoParam.value.clone(), this.vec0 = this.grabPos.subtract(this.baseXfo.tr), this.grabCircleRadius = this.vec0.length(), this.vec0.normalizeInPlace(), this.selectionGroup) {
              const e6 = this.selectionGroup.getItems();
              this.change = new m3(Array.from(e6), this.baseXfo), a3.getInstance().addChange(this.change);
            } else {
              const e6 = this.getTargetParam();
              this.change = new h3(e6), a3.getInstance().addChange(this.change);
            }
          }
          onDrag(e5) {
            const n4 = this.holdPos.subtract(this.baseXfo.tr);
            n4.normalizeInPlace();
            let i4 = 1 * this.vec0.angleTo(n4);
            if (this.vec0.cross(n4).dot(this.baseXfo.ori.getZaxis()) < 0 && (i4 = -i4), this.range && (i4 = t4.MathFunctions.clamp(i4, this.range[0], this.range[1])), (e5 instanceof t4.ZeaMouseEvent || e5 instanceof t4.ZeaTouchEvent) && e5.shiftKey) {
              const e6 = Math.PI / 180 * 22.5;
              i4 = Math.floor(i4 / e6) * e6;
            }
            const s4 = new t4.Xfo();
            if (s4.ori.setFromAxisAndAngle(this.baseXfo.ori.getZaxis(), i4), this.selectionGroup)
              this.change.setDeltaXfo(s4);
            else {
              const e6 = this.baseXfo.clone();
              e6.ori = s4.ori.multiply(e6.ori), this.change.update({value: e6});
            }
          }
          onDragEnd(e5) {
            this.selectionGroup && this.change.setDone(), this.change = null;
          }
        }
        class v3 extends p3 {
          constructor(e5, n4, i4, s4 = new t4.Color(1, 1, 0)) {
            super(e5), this.radiusParam = new t4.NumberParameter("Radius", n4), this.colorParam.value = s4, this.addParameter(this.radiusParam), this.handleMat = new t4.Material("handle", "HandleShader"), this.handleMat.getParameter("BaseColor").value = s4, this.handleMat.getParameter("MaintainScreenSize").value = 1, this.handleMat.getParameter("Overlay").value = 0.9;
            const r4 = new t4.Torus(i4, n4, 64, 0.5 * Math.PI);
            this.handle = new t4.GeomItem("handle", r4, this.handleMat), this.handleXfo = new t4.Xfo(), this.radiusParam.on("valueChanged", () => {
              n4 = this.radiusParam.getValue(), r4.outerRadiusParam.value = n4, r4.innerRadiusParam.value = 0.02 * n4;
            }), this.colorParam.on("valueChanged", () => {
              this.handleMat.getParameter("BaseColor").value = this.colorParam.getValue();
            }), this.addChild(this.handle);
          }
          highlight() {
            super.highlight(), this.handleMat.getParameter("BaseColor").value = this.highlightColorParam.getValue();
          }
          unhighlight() {
            super.unhighlight(), this.handleMat.getParameter("BaseColor").value = this.colorParam.getValue();
          }
          getBaseXfo() {
            return this.globalXfoParam.value;
          }
          onDragStart(e5) {
            super.onDragStart(e5);
          }
          onDrag(e5) {
            super.onDrag(e5);
          }
          onDragEnd(e5) {
            super.onDragEnd(e5);
          }
        }
        class w3 extends s3 {
          constructor(e5) {
            super(e5), this.fullXfoManipulationInVR = true;
          }
          setSelectionGroup(e5) {
            this.selectionGroup = e5;
          }
          setTargetParam(e5, t5 = true) {
            if (this.param = e5, t5) {
              const t6 = () => {
                this.globalXfoParam.value = e5.getValue();
              };
              t6(), e5.on("valueChanged", t6);
            }
          }
          getTargetParam() {
            return this.param ? this.param : this.globalXfoParam;
          }
          onDragStart(e5) {
            this.grabPos = this.grabPos;
            const t5 = this.getTargetParam();
            if (this.baseXfo = t5.value, this.selectionGroup) {
              const e6 = this.selectionGroup.getItems();
              this.change = new m3(Array.from(e6), this.globalXfoParam.value), a3.getInstance().addChange(this.change);
            } else
              this.change = new h3(t5), a3.getInstance().addChange(this.change);
          }
          onDrag(e5) {
            const n4 = this.holdPos.subtract(this.grabPos);
            if (this.selectionGroup) {
              const e6 = this.change, i4 = new t4.Xfo(n4);
              e6.setDeltaXfo(i4);
            } else {
              const e6 = this.baseXfo.clone();
              e6.tr.addInPlace(n4), this.change.update({value: e6});
            }
          }
          onDragEnd(e5) {
            this.selectionGroup && this.change.setDone(), this.change = null;
          }
          onVRControllerButtonDown(e5) {
            if (this.fullXfoManipulationInVR) {
              this.activeController = e5.controller;
              const t5 = this.activeController.getTipXfo(), n4 = this.globalXfoParam.value;
              this.grabOffset = t5.inverse().multiply(n4);
            } else
              super.onVRControllerButtonDown(e5);
          }
          onVRPoseChanged(e5) {
            if (this.fullXfoManipulationInVR) {
              const e6 = this.activeController.getTipXfo().multiply(this.grabOffset);
              this.change ? this.change.update({value: e6}) : this.getTargetParam().value = e6;
            } else
              super.onVRPoseChanged(e5);
          }
          onVRControllerButtonUp(e5) {
            this.fullXfoManipulationInVR ? this.change = null : super.onVRControllerButtonUp(e5);
          }
        }
        class b3 extends w3 {
          constructor(e5, n4, i4, s4 = new t4.Color()) {
            super(e5), this.sizeParam = new t4.NumberParameter("Size", n4), this.addParameter(this.sizeParam), this.colorParam.value = s4, this.handleMat = new t4.Material("handle", "HandleShader"), this.handleMat.getParameter("BaseColor").value = s4, this.handleMat.getParameter("MaintainScreenSize").value = 1, this.handleMat.getParameter("Overlay").value = 0.9;
            const r4 = new t4.Cuboid(n4, n4, 0.02 * n4), a4 = new t4.Xfo();
            a4.tr = i4, f3(r4, a4), this.handle = new t4.GeomItem("handle", r4, this.handleMat), this.sizeParam.on("valueChanged", () => {
              n4 = this.sizeParam.getValue(), r4.sizeXParam.value = n4, r4.sizeYParam.value = n4, r4.sizeZParam.value = 0.02 * n4;
            }), this.colorParam.on("valueChanged", () => {
              this.handleMat.getParameter("BaseColor").value = this.colorParam.getValue();
            }), this.addChild(this.handle);
          }
          highlight() {
            super.highlight(), this.handleMat.getParameter("BaseColor").value = this.highlightColorParam.getValue();
          }
          unhighlight() {
            super.unhighlight(), this.handleMat.getParameter("BaseColor").value = this.colorParam.getValue();
          }
        }
        class _3 extends t4.TreeItem {
          constructor(e5 = 0.1, n4 = 3e-3) {
            super("XfoHandle"), this.highlightColorParam = new t4.ColorParameter("HighlightColor", new t4.Color(1, 1, 1)), this.highlightColorParam.on("valueChanged", () => {
              const e6 = this.highlightColorParam.getValue();
              this.traverse((t5) => {
                t5 instanceof s3 && (t5.highlightColorParam.value = e6);
              });
            }), this.addParameter(this.highlightColorParam);
            const i4 = new t4.TreeItem("Translate");
            this.addChild(i4);
            const r4 = new t4.Color(1, 0.1, 0.1), a4 = new t4.Color("#32CD32"), o4 = new t4.Color("#1E90FF");
            r4.a = 1, a4.a = 1, o4.a = 1;
            {
              const s4 = new g3("linearX", e5, n4, r4), a5 = new t4.Xfo();
              a5.ori.setFromAxisAndAngle(new t4.Vec3(0, 1, 0), 0.5 * Math.PI), s4.localXfoParam.value = a5, i4.addChild(s4);
            }
            {
              const s4 = new g3("linearY", e5, n4, a4), r5 = new t4.Xfo();
              r5.ori.setFromAxisAndAngle(new t4.Vec3(1, 0, 0), -0.5 * Math.PI), s4.localXfoParam.value = r5, i4.addChild(s4);
            }
            {
              const t5 = new g3("linearZ", e5, n4, o4);
              i4.addChild(t5);
            }
            const l4 = 0.35 * e5;
            {
              const e6 = new b3("planarXY", l4, new t4.Vec3(0.5 * l4, 0.5 * l4, 0), o4), n5 = new t4.Xfo();
              e6.localXfoParam.value = n5, i4.addChild(e6);
            }
            {
              const e6 = new b3("planarYZ", l4, new t4.Vec3(-0.5 * l4, 0.5 * l4, 0), r4), n5 = new t4.Xfo();
              n5.ori.setFromAxisAndAngle(new t4.Vec3(0, 1, 0), 0.5 * Math.PI), e6.localXfoParam.value = n5, i4.addChild(e6);
            }
            {
              const e6 = new b3("planarXZ", l4, new t4.Vec3(0.5 * l4, 0.5 * l4, 0), a4), n5 = new t4.Xfo();
              n5.ori.setFromAxisAndAngle(new t4.Vec3(1, 0, 0), 0.5 * Math.PI), e6.localXfoParam.value = n5, i4.addChild(e6);
            }
            const h4 = new t4.TreeItem("Rotate");
            this.addChild(h4);
            {
              const i5 = new v3("rotationX", 0.75 * e5, n4, r4), s4 = new t4.Xfo();
              s4.ori.setFromEulerAngles(new t4.EulerAngles(-0.5 * Math.PI, -0.5 * Math.PI, 0)), i5.localXfoParam.value = s4, h4.addChild(i5);
            }
            {
              const i5 = new v3("rotationY", 0.75 * e5, n4, a4), s4 = new t4.Xfo();
              s4.ori.setFromAxisAndAngle(new t4.Vec3(1, 0, 0), -0.5 * Math.PI), i5.localXfoParam.value = s4, h4.addChild(i5);
            }
            {
              const i5 = new v3("rotationZ", 0.75 * e5, n4, o4), s4 = new t4.Xfo();
              s4.ori.setFromAxisAndAngle(new t4.Vec3(0, 0, 1), 0.5 * Math.PI), i5.localXfoParam.value = s4, h4.addChild(i5);
            }
          }
          showHandles(e5) {
            e5 ? this.setVisible(true) : this.setVisible(false);
          }
          setTargetParam(e5, t5 = true) {
            this.param = e5, this.traverse((t6) => {
              t6 instanceof s3 && t6.setTargetParam(e5, false);
            });
          }
          setSelectionGroup(e5) {
            this.traverse((t5) => {
              (t5 instanceof g3 || t5 instanceof b3 || t5 instanceof v3) && t5.setSelectionGroup(e5);
            });
          }
        }
        class y3 extends t4.Operator {
          constructor(e5, n4) {
            super(), this.xfoModeInput = new t4.NumberOperatorInput("InitialXfoMode"), this.xfoOutput = new t4.XfoOperatorOutput("GroupGlobalXfo"), this.addInput(this.xfoModeInput).setParam(e5), this.addOutput(this.xfoOutput).setParam(n4), this.currGroupXfo = new t4.Xfo();
          }
          addItem(e5) {
            const n4 = new t4.XfoOperatorInput("MemberGlobalXfo" + this.getNumInputs());
            n4.setParam(e5.globalXfoParam), this.addInput(n4), this.setDirty();
          }
          removeItem(e5) {
            const t5 = e5.globalXfoParam;
            for (let e6 = 1; e6 < this.getNumInputs(); e6++) {
              const n4 = this.getInputByIndex(e6);
              if (n4.getParam() == t5)
                return this.removeInput(n4), void this.setDirty();
            }
            throw new Error("Item not found in SelectionGroupXfoOperator");
          }
          backPropagateValue(e5) {
            const t5 = this.currGroupXfo.inverse(), n4 = e5.multiply(t5);
            n4.ori.normalizeInPlace(), this.currGroupXfo = n4.multiply(this.currGroupXfo);
            for (let e6 = 1; e6 < this.getNumInputs(); e6++) {
              const t6 = this.getInputByIndex(e6), i4 = t6.getValue(), s4 = n4.multiply(i4);
              t6.setValue(s4);
            }
          }
          evaluate() {
            if (this.currGroupXfo = new t4.Xfo(), this.getNumInputs() == 1)
              return void this.xfoOutput.setClean(this.currGroupXfo);
            const e5 = this.xfoModeInput.getValue();
            if (e5 != t4.KinematicGroup.INITIAL_XFO_MODES.manual) {
              if (e5 == t4.KinematicGroup.INITIAL_XFO_MODES.first) {
                const e6 = this.getInputByIndex(1).getValue();
                this.currGroupXfo.tr = e6.tr.clone(), this.currGroupXfo.ori = e6.ori.clone();
              } else if (e5 == t4.KinematicGroup.INITIAL_XFO_MODES.average) {
                this.currGroupXfo.ori.set(0, 0, 0, 0);
                let e6 = 0;
                for (let t5 = 1; t5 < this.getNumInputs(); t5++) {
                  const n4 = this.getInputByIndex(t5).getValue();
                  this.currGroupXfo.tr.addInPlace(n4.tr), e6 == 0 && this.currGroupXfo.ori.addInPlace(n4.ori), e6++;
                }
                this.currGroupXfo.tr.scaleInPlace(1 / e6);
              } else {
                if (e5 != t4.KinematicGroup.INITIAL_XFO_MODES.globalOri)
                  throw new Error("Invalid KinematicGroup.INITIAL_XFO_MODES.");
                {
                  let e6 = 0;
                  for (let t5 = 1; t5 < this.getNumInputs(); t5++) {
                    const n4 = this.getInputByIndex(t5).getValue();
                    this.currGroupXfo.tr.addInPlace(n4.tr), e6++;
                  }
                  this.currGroupXfo.tr.scaleInPlace(1 / e6);
                }
              }
              this.currGroupXfo.ori.normalizeInPlace(), this.xfoOutput.setClean(this.currGroupXfo);
            } else
              this.currGroupXfo = this.xfoOutput.getValue().clone();
          }
        }
        const I3 = {disabled: 0, manual: 1, first: 2, average: 3, globalOri: 4};
        class x3 extends t4.SelectionSet {
          constructor(e5) {
            super(), this.initialXfoModeParam = new t4.MultiChoiceParameter("InitialXfoMode", I3.average, ["manual", "first", "average", "global"]);
            const n4 = e5.selectionOutlineColor ? e5.selectionOutlineColor : new t4.Color(3 / 255, 227 / 255, 172 / 255, 0.1);
            this.highlightColorParam.value = n4, this.itemsParam.setFilterFn((e6) => e6 instanceof t4.BaseItem), this.addParameter(this.initialXfoModeParam), this.selectionGroupXfoOp = new y3(this.initialXfoModeParam, this.globalXfoParam);
          }
          static get INITIAL_XFO_MODES() {
            return I3;
          }
          clone() {
            const e5 = new x3();
            return e5.copyFrom(this), e5;
          }
          bindItem(e5, n4) {
            if (e5 instanceof t4.TreeItem) {
              const t5 = this.highlightColorParam.value;
              t5.a = this.highlightFillParam.value, e5.addHighlight("selected" + this.getId(), t5, true), this.selectionGroupXfoOp.addItem(e5);
            }
          }
          unbindItem(e5, n4) {
            e5 instanceof t4.TreeItem && (e5.removeHighlight("selected" + this.getId(), true), this.selectionGroupXfoOp.removeItem(e5));
          }
        }
        class P3 extends l3 {
          constructor(e5, t5, n4) {
            super("SelectionChange"), this.__selectionManager = e5, this.__prevSelection = t5, this.__newSelection = n4;
          }
          undo() {
            this.__selectionManager.setSelection(this.__prevSelection, false);
          }
          redo() {
            this.__selectionManager.setSelection(this.__newSelection, false);
          }
          toJSON(e5) {
            const t5 = super.toJSON(e5), n4 = [];
            for (const e6 of this.__newSelection)
              n4.push(e6.getPath());
            return t5.itemPaths = n4, t5;
          }
          fromJSON(e5, t5) {
            super.fromJSON(e5, t5), this.__selectionManager = t5.appData.selectionManager, this.__prevSelection = new Set(this.__selectionManager.getSelection());
            const n4 = t5.appData.scene.getRoot(), i4 = new Set();
            for (const t6 of e5.itemPaths)
              i4.add(n4.resolvePath(t6, 1));
            this.__newSelection = i4, this.__selectionManager.setSelection(this.__newSelection, false);
          }
        }
        a3.registerChange("SelectionChange", P3);
        class C3 extends l3 {
          constructor(e5, t5) {
            super("Selection Visibility Change"), this.selection = e5, this.state = t5, this._changeItemsVisibility(this.state);
          }
          undo() {
            this._changeItemsVisibility(!this.state);
          }
          redo() {
            this._changeItemsVisibility(this.state);
          }
          _changeItemsVisibility(e5) {
            for (const t5 of this.selection)
              t5.getParameter("Visible").value = e5;
          }
        }
        a3.registerChange("ToggleSelectionVisibility", C3);
        class k3 extends t4.EventEmitter {
          constructor(e5, n4 = {}) {
            if (super(), this.leadSelection = void 0, this.appData = e5, this.selectionGroup = new x3(n4), n4.enableXfoHandles === true) {
              const e6 = 0.1, n5 = 0.02 * e6;
              this.xfoHandle = new _3(e6, n5), this.xfoHandle.setSelectionGroup(this.selectionGroup), this.xfoHandle.setVisible(false), this.xfoHandle.highlightColorParam.value = new t4.Color(1, 1, 0), this.xfoHandleVisible = true, this.selectionGroup.addChild(this.xfoHandle);
            }
            this.appData.renderer && this.setRenderer(this.appData.renderer);
          }
          setRenderer(e5) {
            this.__renderer != e5 ? (this.__renderer = e5, this.__renderer.addTreeItem(this.selectionGroup)) : console.warn("Renderer already set on SelectionManager");
          }
          setXfoMode(e5) {
            this.xfoHandle && (this.selectionGroup.initialXfoModeParam.value = e5);
          }
          showHandles(e5) {
            this.xfoHandleVisible = e5;
          }
          updateHandleVisibility() {
            if (!this.xfoHandle)
              return;
            const e5 = this.selectionGroup.getItems(), t5 = Array.from(e5).length > 0;
            this.xfoHandle.setVisible(t5 && this.xfoHandleVisible), this.__renderer.requestRedraw();
          }
          getSelection() {
            return this.selectionGroup.getItems();
          }
          setSelection(e5, t5 = true) {
            const n4 = new Set(this.selectionGroup.getItems()), i4 = new Set(n4);
            for (const t6 of e5)
              n4.has(t6) || (t6.setSelected(true), n4.add(t6));
            for (const t6 of n4)
              e5.has(t6) || (t6.setSelected(false), n4.delete(t6));
            if (this.selectionGroup.setItems(n4), n4.size > 0 ? this.__setLeadSelection(n4.values().next().value) : this.__setLeadSelection(), this.updateHandleVisibility(), t5) {
              const e6 = new P3(this, i4, n4);
              a3.getInstance().addChange(e6);
            }
            this.emit("selectionChanged", {prevSelection: i4, selection: n4});
          }
          __setLeadSelection(e5) {
            this.leadSelection != e5 && (this.leadSelection = e5, this.emit("leadSelectionChanged", {treeItem: e5}));
          }
          toggleItemSelection(e5, t5 = true) {
            const n4 = new Set(this.selectionGroup.getItems()), i4 = new Set(n4);
            if (t5 && (n4.size != 1 || !n4.has(e5))) {
              let t6 = true;
              if (n4.has(e5)) {
                let i5 = 1;
                e5.traverse((e6) => {
                  n4.has(e6) && i5++;
                }), t6 = i5 != n4.size;
              }
              t6 && (Array.from(n4).forEach((e6) => {
                e6.setSelected(false);
              }), n4.clear());
            }
            let s4;
            n4.has(e5) ? (e5.setSelected(false), n4.delete(e5), s4 = false) : (e5.setSelected(true), n4.add(e5), s4 = true), this.selectionGroup.setItems(n4), s4 && n4.size === 1 ? this.__setLeadSelection(e5) : s4 || (n4.size === 1 ? this.__setLeadSelection(n4.values().next().value) : n4.size === 0 && this.__setLeadSelection());
            const r4 = new P3(this, i4, n4);
            a3.getInstance().addChange(r4), this.updateHandleVisibility(), this.emit("selectionChanged", {prevSelection: i4, selection: n4});
          }
          clearSelection(e5 = true) {
            const t5 = new Set(this.selectionGroup.getItems());
            if (t5.size == 0)
              return false;
            let n4;
            e5 && (n4 = new Set(t5));
            for (const e6 of t5)
              e6.setSelected(false);
            if (t5.clear(), this.selectionGroup.setItems(t5), this.__setLeadSelection(), this.updateHandleVisibility(), e5) {
              const e6 = new P3(this, n4, t5);
              a3.getInstance().addChange(e6), this.emit("selectionChanged", {selection: t5, prevSelection: n4});
            }
            return true;
          }
          selectItems(e5, t5 = true) {
            const n4 = new Set(this.selectionGroup.getItems()), i4 = new Set(n4);
            t5 && n4.clear();
            for (const t6 of e5)
              n4.has(t6) || (t6.setSelected(true), n4.add(t6));
            const s4 = new P3(this, i4, n4);
            a3.getInstance().addChange(s4), this.selectionGroup.setItems(n4), n4.size === 1 ? this.__setLeadSelection(n4.values().next().value) : n4.size === 0 && this.__setLeadSelection(), this.updateHandleVisibility(), this.emit("selectionChanged", {prevSelection: i4, selection: n4});
          }
          deselectItems(e5) {
            const t5 = new Set(this.selectionGroup.getItems()), n4 = new Set(t5);
            for (const n5 of e5)
              t5.has(n5) && (n5.setSelected(false), t5.delete(n5));
            this.selectionGroup.setItems(t5);
            const i4 = new P3(this, n4, t5);
            a3.getInstance().addChange(i4), t5.size === 1 ? this.__setLeadSelection(t5.values().next().value) : t5.size === 0 && this.__setLeadSelection(), this.updateHandleVisibility(), this.emit("selectionChanged", {prevSelection: n4, selection: t5});
          }
          toggleSelectionVisibility() {
            if (this.leadSelection) {
              const e5 = this.selectionGroup.getItems(), t5 = !this.leadSelection.getVisible(), n4 = new C3(e5, t5);
              a3.getInstance().addChange(n4);
            }
          }
          startPickingMode(e5, t5, n4, i4) {
            console.log(e5), this.__pickCB = t5, this.__pickFilter = n4, this.__pickCount = i4, this.__picked = [];
          }
          pickingFilter(e5) {
            return this.__pickFilter(e5);
          }
          pickingModeActive() {
            return this.__pickCB != null;
          }
          cancelPickingMode() {
            this.__pickCB = void 0;
          }
          pick(e5) {
            if (this.__pickCB) {
              if (Array.isArray(e5))
                this.__pickFilter ? this.__picked = this.__picked.concat(e5.filter(this.__pickFilter)) : this.__picked = this.__picked.concat(e5);
              else {
                if (this.__pickFilter && !this.__pickFilter(e5))
                  return;
                this.__picked.push(e5);
              }
              this.__picked.length == this.__pickCount && (this.__pickCB(this.__picked), this.__pickCB = void 0);
            }
          }
        }
        class T3 extends l3 {
          constructor(e5, t5, n4) {
            e5 ? (super(e5.getName() + " Added"), this.treeItem = e5, this.owner = t5, this.selectionManager = n4, this.prevSelection = new Set(this.selectionManager.getSelection()), this.treeItemIndex = this.owner.getChildIndex(this.owner.addChild(this.treeItem)), this.selectionManager.setSelection(new Set([this.treeItem]), false)) : super();
          }
          undo() {
            this.treeItem instanceof t4.Operator ? this.treeItem.detach() : this.treeItem instanceof t4.TreeItem && this.treeItem.traverse((e5) => {
              e5 instanceof t4.Operator && e5.detach();
            }, false), this.owner.removeChild(this.treeItemIndex), this.selectionManager && this.selectionManager.setSelection(this.prevSelection, false);
          }
          redo() {
            this.treeItem instanceof t4.Operator ? this.treeItem.reattach() : this.treeItem instanceof t4.TreeItem && this.treeItem.traverse((e5) => {
              e5 instanceof t4.Operator && e5.reattach();
            }, false), this.owner.addChild(this.treeItem), this.selectionManager && this.selectionManager.setSelection(new Set([this.treeItem]), false);
          }
          toJSON(e5) {
            return {name: this.name, treeItem: this.treeItem.toJSON(e5), treeItemPath: this.treeItem.getPath(), treeItemIndex: this.treeItemIndex};
          }
          fromJSON(e5, n4) {
            const i4 = t4.Registry.constructClass(e5.treeItem.type);
            i4 ? (this.name = e5.name, this.treeItem = i4, this.treeItem.fromJSON(e5.treeItem, n4), this.treeItemIndex = this.owner.getChildIndex(this.owner.addChild(this.treeItem))) : console.warn("resolvePath is unable to construct", e5.treeItem);
          }
          destroy() {
          }
        }
        a3.registerChange("TreeItemAddChange", T3);
        class A3 extends l3 {
          constructor(e5, t5) {
            e5 ? (super(e5.getName() + " Moved"), this.treeItem = e5, this.oldOwner = this.treeItem.getOwner(), this.oldOwnerIndex = this.oldOwner.getChildIndex(this.treeItem), this.newOwner = t5, this.newOwner.addChild(this.treeItem, true)) : super();
          }
          undo() {
            this.oldOwner.insertChild(this.treeItem, this.oldOwnerIndex, true);
          }
          redo() {
            this.newOwner.addChild(this.treeItem, true);
          }
          toJSON(e5) {
            return {name: this.name, treeItemPath: this.treeItem.getPath(), newOwnerPath: this.newOwner.getPath()};
          }
          fromJSON(e5, t5) {
            if (!t5 || !t5.scene)
              return;
            const n4 = t5.scene.getRoot().resolvePath(e5.treeItemPath, 1);
            if (!n4)
              return void console.warn("resolvePath is unable to resolve", e5.treeItemPath);
            const i4 = t5.scene.getRoot().resolvePath(e5.newOwnerPath, 1);
            i4 ? (this.name = e5.name, this.treeItem = n4, this.newOwner = i4, this.oldOwner = this.treeItem.getOwner(), this.oldOwnerIndex = this.oldOwner.getChildIndex(this.treeItem), this.newOwner.addChild(this.treeItem, true)) : console.warn("resolvePath is unable to resolve", e5.newOwnerPath);
          }
        }
        a3.registerChange("TreeItemMoveChange", A3);
        class $3 extends l3 {
          constructor(e5, n4) {
            if (super(), this.items = [], this.itemOwners = [], this.itemPaths = [], this.itemIndices = [], e5) {
              this.selectionManager = n4.selectionManager, this.prevSelection = new Set(this.selectionManager.getSelection()), this.items = e5, this.newSelection = new Set(this.prevSelection);
              const i4 = [];
              this.items.forEach((e6) => {
                const n5 = e6.getOwner(), s4 = n5.getChildIndex(e6);
                i4.push(e6.getName()), this.itemOwners.push(n5), this.itemPaths.push(e6.getPath()), this.itemIndices.push(s4), this.selectionManager && this.newSelection.has(e6) && this.newSelection.delete(e6), e6 instanceof t4.Operator ? e6.detach() : e6 instanceof t4.TreeItem && e6.traverse((e7) => {
                  e7 instanceof t4.Operator && e7.detach(), this.selectionManager && this.newSelection.has(e7) && this.newSelection.delete(e7);
                }, false), n5.removeChild(s4);
              }), this.selectionManager.setSelection(this.newSelection, false), this.name = i4 + " Deleted";
            }
          }
          undo() {
            this.items.forEach((e5, n4) => {
              this.itemOwners[n4].insertChild(e5, this.itemIndices[n4], false, false), e5 instanceof t4.Operator ? e5.reattach() : e5 instanceof t4.TreeItem && e5.traverse((e6) => {
                e6 instanceof t4.Operator && e6.reattach();
              }, false);
            }), this.selectionManager && this.selectionManager.setSelection(this.prevSelection, false);
          }
          redo() {
            this.selectionManager && this.selectionManager.setSelection(this.newSelection, false), this.items.forEach((e5, n4) => {
              this.itemOwners[n4].removeChild(this.itemIndices[n4]), e5 instanceof t4.Operator ? e5.detach() : e5 instanceof t4.TreeItem && e5.traverse((e6) => {
                e6 instanceof t4.Operator && e6.detach();
              }, false);
            });
          }
          toJSON(e5) {
            const t5 = {name: this.name, items: [], itemPaths: this.itemPaths, itemIndices: this.itemIndices};
            return this.items.forEach((e6) => {
              t5.items.push(e6.toJSON());
            }), t5;
          }
          fromJSON(e5, t5) {
            this.name = e5.name, e5.itemPaths.forEach((e6) => {
              const n4 = t5.scene.getRoot().resolvePath(e6, 1);
              if (!n4)
                return void console.warn("resolvePath is unable to resolve", e6);
              const i4 = n4.getOwner();
              this.itemOwners.push(i4), this.itemPaths.push(n4.getPath()), this.itemIndices.push(i4.getChildIndex(n4));
            });
          }
          destroy() {
          }
        }
        a3.registerChange("TreeItemsRemoveChange", $3);
        class E3 extends t4.BaseTool {
          constructor(e5) {
            super(), e5 || console.error("App data not provided to tool"), this.appData = e5, this.dragging = false, e5.selectionManager || console.error("`SelectionTool` requires `SelectionManager` to be provided in the `appData` object"), this.selectionManager = e5.selectionManager, this.selectionRect = new t4.Rect(1, 1), this.selectionRectMat = new t4.Material("marker", "ScreenSpaceShader"), this.selectionRectMat.getParameter("BaseColor").value = new t4.Color("#03E3AC"), this.selectionRectXfo = new t4.Xfo(), this.selectionRectXfo.tr.set(0.5, 0.5, 0), this.selectionRectXfo.sc.set(0, 0, 0), this.rectItem = new t4.GeomItem("selectionRect", this.selectionRect, this.selectionRectMat), this.rectItem.getParameter("Visible").value = false, this.appData.renderer.addTreeItem(this.rectItem);
          }
          activateTool() {
            super.activateTool();
          }
          deactivateTool() {
            super.deactivateTool(), this.selectionRectXfo.sc.set(0, 0, 0), this.rectItem.globalXfoParam.value = this.selectionRectXfo, this.rectItem.getParameter("Visible").value = false;
          }
          setSelectionManager(e5) {
            this.selectionManager = e5;
          }
          setSelectionFilter(e5) {
            this.__selectionFilterFn = e5;
          }
          __resizeRect(e5, n4) {
            const i4 = new t4.Vec2(1 / e5.getWidth() * 2, 1 / e5.getHeight() * 2), s4 = n4.multiply(i4);
            this.selectionRectXfo.sc.set(Math.abs(s4.x), Math.abs(s4.y), 1);
            const r4 = this.pointerDownPos.subtract(n4.scale(0.5)).multiply(i4).subtract(new t4.Vec2(1, 1));
            this.selectionRectXfo.tr.x = r4.x, this.selectionRectXfo.tr.y = -r4.y, this.rectItem.globalXfoParam.value = this.selectionRectXfo;
          }
          onPointerDoublePress(e5) {
          }
          onPointerDown(e5) {
            (e5 instanceof t4.ZeaTouchEvent || e5 instanceof t4.ZeaMouseEvent && e5.button == 0) && (this.pointerDownPos = e5.pointerPos, this.dragging = false, e5.stopPropagation());
          }
          onPointerMove(e5) {
            if (e5 instanceof t4.ZeaMouseEvent || e5 instanceof t4.ZeaTouchEvent) {
              if (this.pointerDownPos) {
                const t5 = this.pointerDownPos.subtract(e5.pointerPos);
                t5.length() > 4 && (this.dragging = true, this.rectItem.getParameter("Visible").value = true, this.__resizeRect(e5.viewport, t5)), e5.stopPropagation();
              }
            } else
              console.warn("not handling VR");
          }
          onPointerUp(e5) {
            if ((e5 instanceof t4.ZeaMouseEvent || e5 instanceof t4.ZeaTouchEvent) && this.pointerDownPos) {
              if (this.dragging) {
                this.rectItem.getParameter("Visible").value = false;
                const n4 = e5.pointerPos, i4 = new t4.Vec2(Math.min(this.pointerDownPos.x, n4.x), Math.min(this.pointerDownPos.y, n4.y)), r4 = new t4.Vec2(Math.max(this.pointerDownPos.x, n4.x), Math.max(this.pointerDownPos.y, n4.y)), a4 = e5.viewport;
                let o4 = Array.from(a4.getGeomItemsInRect(i4, r4));
                if (this.__selectionFilterFn) {
                  const e6 = [];
                  for (let t5 = 0; t5 < o4.length; t5++) {
                    const n5 = this.__selectionFilterFn(o4[t5]);
                    e6.includes(n5) || e6.push(n5);
                  }
                  o4 = e6;
                }
                if (!this.selectionManager)
                  throw "Please set the Selection Manager on the Selection Tool before using it.";
                if (this.selectionManager.pickingModeActive())
                  this.selectionManager.pick(o4);
                else {
                  const t5 = new Set([...o4].filter((e6) => !(e6.getOwner() instanceof s3)));
                  e5.shiftKey ? this.selectionManager.deselectItems(t5) : this.selectionManager.selectItems(t5, !e5.ctrlKey), this.selectionRectXfo.sc.set(0, 0, 0), this.rectItem.globalXfoParam.value = this.selectionRectXfo;
                }
              } else {
                const t5 = e5.viewport.getGeomDataAtPos(e5.pointerPos, void 0);
                if (t5 == null || t5.geomItem.getOwner() instanceof s3)
                  this.selectionManager.clearSelection();
                else {
                  let n4 = t5.geomItem;
                  if (this.__selectionFilterFn && (n4 = this.__selectionFilterFn(n4)), this.selectionManager.pickingModeActive())
                    this.selectionManager.pick(n4);
                  else if (e5.shiftKey) {
                    const e6 = new Set();
                    e6.add(n4), this.selectionManager.deselectItems(e6);
                  } else
                    this.selectionManager.toggleItemSelection(n4, !e5.ctrlKey);
                }
              }
              this.pointerDownPos = void 0, e5.stopPropagation();
            }
          }
          onVRControllerButtonDown(e5) {
            if (e5.button == 1) {
              if (!this.selectionManager)
                throw "Please set the Selection Manager on the Selection Tool before using it.";
              const t5 = e5.controller.getGeomItemAtTip();
              t5 == null || t5.geomItem.getOwner() instanceof s3 || (this.selectionManager.toggleItemSelection(t5.geomItem), e5.stopPropagation());
            }
          }
        }
        const S3 = function() {
          return {escape: function(e6) {
            return e6.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
          }, parseExtension: e5, mimeType: function(t6) {
            const n4 = e5(t6).toLowerCase();
            return function() {
              const e6 = "application/font-woff", t7 = "image/jpeg";
              return {woff: e6, woff2: e6, ttf: "application/font-truetype", eot: "application/vnd.ms-fontobject", png: "image/png", jpg: t7, jpeg: t7, gif: "image/gif", tiff: "image/tiff", svg: "image/svg+xml"};
            }()[n4] || "";
          }, dataAsUrl: function(e6, t6) {
            return "data:" + t6 + ";base64," + e6;
          }, isDataUrl: function(e6) {
            return e6.search(/^(data:)/) !== -1;
          }, canvasToBlob: function(e6) {
            return e6.toBlob ? new Promise(function(t6) {
              e6.toBlob(t6);
            }) : function(e7) {
              return new Promise(function(t6) {
                const n4 = window.atob(e7.toDataURL().split(",")[1]), i4 = n4.length, s4 = new Uint8Array(i4);
                for (let e8 = 0; e8 < i4; e8++)
                  s4[e8] = n4.charCodeAt(e8);
                t6(new Blob([s4], {type: "image/png"}));
              });
            }(e6);
          }, resolveUrl: function(e6, t6) {
            const n4 = document.implementation.createHTMLDocument(), i4 = n4.createElement("base");
            n4.head.appendChild(i4);
            const s4 = n4.createElement("a");
            return n4.body.appendChild(s4), i4.href = t6, s4.href = e6, s4.href;
          }, getAndEncode: function(e6) {
            const t6 = 3e4;
            return N3.impl.options.cacheBust && (e6 += (/\?/.test(e6) ? "&" : "?") + new Date().getTime()), new Promise(function(n4) {
              const i4 = new XMLHttpRequest();
              let s4;
              if (i4.onreadystatechange = r4, i4.ontimeout = a4, i4.responseType = "blob", i4.timeout = t6, i4.open("GET", e6, true), i4.send(), N3.impl.options.imagePlaceholder) {
                const e7 = N3.impl.options.imagePlaceholder.split(/,/);
                e7 && e7[1] && (s4 = e7[1]);
              }
              function r4() {
                if (i4.readyState !== 4)
                  return;
                if (i4.status !== 200)
                  return void (s4 ? n4(s4) : o4("cannot fetch resource: " + e6 + ", status: " + i4.status));
                const t7 = new FileReader();
                t7.onloadend = function() {
                  if (typeof t7.result == "string") {
                    const e7 = t7.result.split(/,/)[1];
                    n4(e7);
                  } else
                    console.warn("encoder.result is not of string type");
                }, t7.readAsDataURL(i4.response);
              }
              function a4() {
                s4 ? n4(s4) : o4("timeout of " + t6 + "ms occured while fetching resource: " + e6);
              }
              function o4(e7) {
                console.error(e7), n4("");
              }
            });
          }, uid: function() {
            let e6 = 0;
            return function() {
              return "u" + t6() + e6++;
              function t6() {
                return ("0000" + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);
              }
            };
          }(), delay: function(e6) {
            return function(t6) {
              return new Promise(function(n4) {
                setTimeout(function() {
                  n4(t6);
                }, e6);
              });
            };
          }, asArray: function(e6) {
            const t6 = [], n4 = e6.length;
            for (let i4 = 0; i4 < n4; i4++)
              t6.push(e6[i4]);
            return t6;
          }, escapeXhtml: function(e6) {
            return e6.replace(/#/g, "%23").replace(/\n/g, "%0A");
          }, makeImage: function(e6) {
            return new Promise(function(t6, n4) {
              const i4 = new Image();
              i4.onload = function() {
                t6(i4);
              }, i4.onerror = n4, i4.src = e6;
            });
          }, width: function(e6) {
            const n4 = t5(e6, "border-left-width"), i4 = t5(e6, "border-right-width");
            return e6.scrollWidth + n4 + i4;
          }, height: function(e6) {
            const n4 = t5(e6, "border-top-width"), i4 = t5(e6, "border-bottom-width");
            return e6.scrollHeight + n4 + i4;
          }};
          function e5(e6) {
            const t6 = /\.([^\.\/]*?)$/g.exec(e6);
            return t6 ? t6[1] : "";
          }
          function t5(e6, t6) {
            const n4 = window.getComputedStyle(e6).getPropertyValue(t6);
            return parseFloat(n4.replace("px", ""));
          }
        }(), M3 = function() {
          const e5 = /url\(['"]?([^'"]+?)['"]?\)/g;
          return {inlineAll: function(e6, s4, r4) {
            return a4() ? Promise.resolve(e6) : Promise.resolve(e6).then(n4).then(function(t6) {
              let n5 = Promise.resolve(e6);
              return t6.forEach(function(e7) {
                n5 = n5.then(function(t7) {
                  return i4(t7, e7, s4, r4);
                });
              }), n5;
            });
            function a4() {
              return !t5(e6);
            }
          }, shouldProcess: t5, impl: {readUrls: n4, inline: i4}};
          function t5(t6) {
            return t6.search(e5) !== -1;
          }
          function n4(t6) {
            const n5 = [];
            let i5;
            for (; (i5 = e5.exec(t6)) !== null; )
              n5.push(i5[1]);
            return n5.filter(function(e6) {
              return !S3.isDataUrl(e6);
            });
          }
          function i4(e6, t6, n5, i5) {
            return Promise.resolve(t6).then(function(e7) {
              return n5 ? S3.resolveUrl(e7, n5) : e7;
            }).then(i5 || S3.getAndEncode).then(function(e7) {
              return S3.dataAsUrl(e7, S3.mimeType(t6));
            }).then(function(n6) {
              return e6.replace(function(e7) {
                return new RegExp(`(url\\(['"]?)(` + S3.escape(e7) + `)(['"]?\\))`, "g");
              }(t6), "$1" + n6 + "$3");
            });
          }
        }(), R3 = function() {
          return {resolveAll: function() {
            return e5(document).then(function(e6) {
              return Promise.all(e6.map(function(e7) {
                return e7.resolve();
              }));
            }).then(function(e6) {
              return e6.join("\n");
            });
          }, impl: {readAll: e5}};
          function e5(e6) {
            return Promise.resolve(S3.asArray(e6.styleSheets)).then(function(e7) {
              const t6 = [];
              return e7.forEach(function(e8) {
                try {
                  S3.asArray(e8.cssRules || []).forEach(t6.push.bind(t6));
                } catch (t7) {
                  console.log("Error while reading CSS rules from " + e8.href, t7.toString());
                }
              }), t6;
            }).then(function(e7) {
              return e7.filter(function(e8) {
                return e8.type === CSSRule.FONT_FACE_RULE;
              }).filter(function(e8) {
                return M3.shouldProcess(e8.style.getPropertyValue("src"));
              });
            }).then(function(e7) {
              return e7.map(t5);
            });
            function t5(e7) {
              return {resolve: function() {
                const t6 = (e7.parentStyleSheet || {}).href;
                return M3.inlineAll(e7.cssText, t6);
              }, src: function() {
                return e7.style.getPropertyValue("src");
              }};
            }
          }
        }(), D3 = function() {
          return {inlineAll: function t5(n4) {
            return n4 instanceof Element ? i4(n4).then(function() {
              return n4 instanceof HTMLImageElement ? e5(n4).inline() : Promise.all(S3.asArray(n4.childNodes).map(function(e6) {
                return t5(e6);
              }));
            }) : Promise.resolve(n4);
            function i4(e6) {
              const t6 = e6.style.getPropertyValue("background");
              return t6 ? M3.inlineAll(t6).then(function(t7) {
                e6.style.setProperty("background", t7, e6.style.getPropertyPriority("background"));
              }).then(function() {
                return e6;
              }) : Promise.resolve(e6);
            }
          }, impl: {newImage: e5}};
          function e5(e6) {
            return {inline: function(t5) {
              return S3.isDataUrl(e6.src) ? Promise.resolve() : Promise.resolve(e6.src).then(t5 || S3.getAndEncode).then(function(t6) {
                return S3.dataAsUrl(t6, S3.mimeType(e6.src));
              }).then(function(t6) {
                return new Promise(function(n4, i4) {
                  e6.onload = n4, e6.onerror = i4, e6.src = t6;
                });
              });
            }};
          }
        }(), O3 = {imagePlaceholder: void 0, cacheBust: false}, N3 = {toSvg: z3, toPng: function(e5, t5) {
          return L3(e5, t5 || {}).then(function(e6) {
            return e6.toDataURL();
          });
        }, toJpeg: function(e5, t5) {
          return L3(e5, t5 = t5 || {}).then(function(e6) {
            return e6.toDataURL("image/jpeg", t5.quality || 1);
          });
        }, toBlob: function(e5, t5) {
          return L3(e5, t5 || {}).then(S3.canvasToBlob);
        }, toPixelData: function(e5, t5) {
          return L3(e5, t5 || {}).then(function(t6) {
            return t6.getContext("2d").getImageData(0, 0, S3.width(e5), S3.height(e5)).data;
          });
        }, toCanvas: function(e5, t5) {
          return L3(e5, t5 || {}).then(function(e6) {
            return e6;
          });
        }, impl: {fontFaces: R3, images: D3, util: S3, inliner: M3, options: {cacheBust: void 0, imagePlaceholder: void 0}}};
        function z3(e5, t5) {
          return function(e6) {
            e6.imagePlaceholder === void 0 ? N3.impl.options.imagePlaceholder = O3.imagePlaceholder : N3.impl.options.imagePlaceholder = e6.imagePlaceholder, e6.cacheBust === void 0 ? N3.impl.options.cacheBust = O3.cacheBust : N3.impl.options.cacheBust = e6.cacheBust;
          }(t5 = t5 || {}), Promise.resolve(e5).then(function(e6) {
            return V3(e6, t5.filter, true);
          }).then(B3).then(U3).then(function(e6) {
            return t5.bgcolor && (e6.style.backgroundColor = t5.bgcolor), t5.width && (e6.style.width = t5.width + "px"), t5.height && (e6.style.height = t5.height + "px"), t5.style && Object.keys(t5.style).forEach(function(n4) {
              e6.style[n4] = t5.style[n4];
            }), e6;
          }).then(function(n4) {
            return function(e6, t6, n5) {
              return Promise.resolve(e6).then(function(e7) {
                return e7.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), new XMLSerializer().serializeToString(e7);
              }).then(S3.escapeXhtml).then(function(e7) {
                return '<foreignObject x="0" y="0" width="100%" height="100%">' + e7 + "</foreignObject>";
              }).then(function(e7) {
                return '<svg xmlns="http://www.w3.org/2000/svg" width="' + t6 + '" height="' + n5 + '">' + e7 + "</svg>";
              }).then(function(e7) {
                return "data:image/svg+xml;charset=utf-8," + e7;
              });
            }(n4, t5.width || S3.width(e5), t5.height || S3.height(e5));
          });
        }
        function L3(e5, t5) {
          return z3(e5, t5).then(S3.makeImage).then(S3.delay(100)).then(function(n4) {
            const i4 = function(e6) {
              const n5 = document.createElement("canvas");
              if (n5.width = t5.width || S3.width(e6), n5.height = t5.height || S3.height(e6), t5.bgcolor) {
                const e7 = n5.getContext("2d");
                e7.fillStyle = t5.bgcolor, e7.fillRect(0, 0, n5.width, n5.height);
              }
              return n5;
            }(e5);
            return i4.getContext("2d").drawImage(n4, 0, 0), i4;
          });
        }
        function V3(e5, t5, n4) {
          return n4 || !t5 || t5(e5) ? Promise.resolve(e5).then(function(e6) {
            return e6 instanceof HTMLCanvasElement ? S3.makeImage(e6.toDataURL()) : e6.cloneNode(false);
          }).then(function(n5) {
            return function(e6, t6, n6) {
              const i4 = e6.childNodes;
              return i4.length === 0 ? Promise.resolve(t6) : s4(t6, S3.asArray(i4), n6).then(function() {
                return t6;
              });
              function s4(e7, t7, n7) {
                let i5 = Promise.resolve();
                return t7.forEach(function(t8) {
                  i5 = i5.then(function() {
                    return V3(t8, n7);
                  }).then(function(t9) {
                    t9 && e7.appendChild(t9);
                  });
                }), i5;
              }
            }(e5, n5, t5);
          }).then(function(t6) {
            return function(e6, t7) {
              return t7 instanceof Element ? Promise.resolve().then(n5).then(i4).then(s4).then(r4).then(function() {
                return t7;
              }) : t7;
              function n5() {
                function n6(e7, t8) {
                  function n7(e8, t9) {
                    S3.asArray(e8).forEach(function(n8) {
                      t9.setProperty(n8, e8.getPropertyValue(n8), e8.getPropertyPriority(n8));
                    });
                  }
                  e7.cssText ? t8.cssText = e7.cssText : n7(e7, t8);
                }
                n6(window.getComputedStyle(e6), t7.style);
              }
              function i4() {
                function n6(n7) {
                  const i5 = window.getComputedStyle(e6, n7), s5 = i5.getPropertyValue("content");
                  if (s5 === "" || s5 === "none")
                    return;
                  const r5 = S3.uid();
                  t7.className = t7.className + " " + r5;
                  const a4 = document.createElement("style");
                  function o4(e7, t8, n8) {
                    const i6 = "." + e7 + ":" + t8, s6 = n8.cssText ? r6(n8) : a5(n8);
                    return document.createTextNode(i6 + "{" + s6 + "}");
                    function r6(e8) {
                      const t9 = e8.getPropertyValue("content");
                      return e8.cssText + " content: " + t9 + ";";
                    }
                    function a5(e8) {
                      return S3.asArray(e8).map(t9).join("; ") + ";";
                      function t9(t10) {
                        return t10 + ": " + e8.getPropertyValue(t10) + (e8.getPropertyPriority(t10) ? " !important" : "");
                      }
                    }
                  }
                  a4.appendChild(o4(r5, n7, i5)), t7.appendChild(a4);
                }
                [":before", ":after"].forEach(function(e7) {
                  n6(e7);
                });
              }
              function s4() {
                e6 instanceof HTMLTextAreaElement && (t7.innerHTML = e6.value), e6 instanceof HTMLInputElement && t7.setAttribute("value", e6.value);
              }
              function r4() {
                t7 instanceof SVGElement && (t7.setAttribute("xmlns", "http://www.w3.org/2000/svg"), t7 instanceof SVGRectElement && ["width", "height"].forEach(function(e7) {
                  const n6 = t7.getAttribute(e7);
                  n6 && t7.style.setProperty(e7, n6);
                }));
              }
            }(e5, t6);
          }) : Promise.resolve();
        }
        function B3(e5) {
          return R3.resolveAll().then(function(t5) {
            const n4 = document.createElement("style");
            return e5.appendChild(n4), n4.appendChild(document.createTextNode(t5)), e5;
          });
        }
        function U3(e5) {
          return D3.inlineAll(e5).then(function() {
            return e5;
          });
        }
        function X3(e5, t5, n4) {
          if (n4(e5, t5))
            for (e5 = e5.firstChild; e5; )
              X3(e5, t5 + 1, n4), e5 = e5.nextSibling;
        }
        const F3 = 'data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg"'.length, G3 = (e5, t5, n4, i4) => {
          N3.toSvg(e5).then((e6) => {
            const s4 = e6.substring(0, F3) + ` viewBox="0 0 ${t5.width} ${t5.height}"` + e6.substring(F3), r4 = new Image();
            r4.onload = function() {
              i4(r4, n4);
            }, r4.src = s4;
          });
        }, H3 = new t4.Plane(1, 1);
        class j3 extends t4.TreeItem {
          constructor(e5, n4) {
            super("VRControllerUI"), this.setSelectable(false), this.appData = e5, this.__vrUIDOMElement = n4, this.__vrUIDOMElement.style.display = "none";
            const i4 = new t4.TreeItem("Offset");
            this.addChild(i4, false), this.ready = false;
            const s4 = new ResizeObserver((e6) => {
              s4.disconnect();
              const r4 = new t4.Xfo(), a4 = 5e-4;
              r4.sc.set(a4, a4, a4), r4.ori.setFromEulerAngles(new t4.EulerAngles(Math.PI, Math.PI, 0)), i4.localXfoParam.value = r4, this.size = new t4.Vec3(n4.clientWidth * a4, n4.clientHeight * a4, 1), X3(n4, 0, (e7, s5) => {
                if (e7.className == "button") {
                  const r5 = function(e8) {
                    const t5 = e8.computedStyleMap();
                    return {width: t5.get("width").value + (t5.get("margin-left").value + t5.get("margin-right").value), height: t5.get("height").value + (t5.get("margin-top").value + t5.get("margin-bottom").value)};
                  }(e7), a5 = new t4.Xfo();
                  a5.sc.set(r5.width, -r5.height, 1), a5.tr.set(e7.offsetLeft + 0.5 * r5.width - 0.5 * n4.clientWidth, e7.offsetTop + 0.5 * r5.height - 0.5 * n4.clientHeight, -s5);
                  const o4 = new t4.Material("element-vr-ui-mat", "FlatSurfaceShader");
                  o4.getParameter("BaseColor").value = new t4.Color(0.3, 0.3, 0.3);
                  const l4 = new t4.DataImage();
                  o4.getParameter("BaseColor").value = l4;
                  const h4 = new t4.GeomItem("element-vr-ui", H3, o4, a5);
                  h4.setSelectable(false), i4.addChild(h4, false);
                  const c4 = {};
                  return r5.width > 0 && r5.height > 0 && G3(e7, r5, e7.id + e7.className, (e8, t5) => {
                    c4[t5] = e8, l4.setData(r5.width, r5.height, e8);
                  }), new MutationObserver((t5) => {
                    if (r5.width == 0 || r5.height == 0)
                      return;
                    const n5 = e7.id + e7.className;
                    c4[n5] ? l4.setData(r5.width, r5.height, c4[n5]) : G3(e7, r5, n5, (e8, t6) => {
                      c4[t6] = e8, l4.setData(r5.width, r5.height, e8);
                    });
                  }).observe(e7, {attributes: true, characterData: false, childList: false, subtree: false}), false;
                }
                return true;
              }), this.ready = true, this.emit("ready");
            });
            s4.observe(n4);
          }
          activate() {
            this.__vrUIDOMElement.style.display = "block";
          }
          deactivate() {
            this.__vrUIDOMElement.style.display = "none";
          }
          sendMouseEvent(e5, t5, n4) {
            const i4 = new MouseEvent(e5, Object.assign({target: n4, view: window, bubbles: true, cancelable: true}, t5));
            return n4.dispatchEvent(i4), i4;
          }
        }
        class Z3 extends t4.BaseTool {
          constructor(e5, n4) {
            super(), this.appData = e5, this.__vrUIDOMElement = n4, this.controllerUI = new j3(e5, this.__vrUIDOMElement);
            const i4 = new t4.Material("pointermat", "LinesShader");
            i4.setSelectable(false), i4.getParameter("BaseColor").value = new t4.Color(1.2, 0, 0);
            const s4 = new t4.Lines();
            s4.setNumVertices(2), s4.setNumSegments(1), s4.setSegmentVertexIndices(0, 0, 1);
            const r4 = s4.getVertexAttribute("positions");
            r4.getValueRef(0).set(0, 0, 0), r4.getValueRef(1).set(0, 0, -1), s4.setBoundingBoxDirty(), this.__pointerLocalXfo = new t4.Xfo(), this.__pointerLocalXfo.sc.set(1, 1, 0.1), this.__pointerLocalXfo.ori.setFromAxisAndAngle(new t4.Vec3(1, 0, 0), -0.2 * Math.PI), this.__uiPointerItem = new t4.GeomItem("VRControllerPointer", s4, i4), this.__uiPointerItem.setSelectable(false), this.__triggerHeld = false, this.uiOpen = false, this.appData.renderer.getXRViewport().then((e6) => {
              e6.on("presentingChanged", (e7) => {
                this.uiOpen && !e7.state && this.closeUI();
              });
            });
          }
          getName() {
            return "VRUITool";
          }
          activateTool() {
            super.activateTool();
          }
          deactivateTool() {
            this.uiOpen && this.closeUI(), super.deactivateTool();
          }
          displayUI(e5, n4, i4) {
            this.controllerUI.activate(), this.uiController = e5, this.pointerController = n4;
            const s4 = this.controllerUI.localXfoParam.getValue();
            if (s4.ori.setFromAxisAndAngle(new t4.Vec3(1, 0, 0), -0.6 * Math.PI), this.pointerController) {
              const e6 = this.uiController.getTreeItem().globalXfoParam.value, t5 = this.pointerController.getTreeItem().globalXfoParam.value, n5 = e6.tr.subtract(i4.tr), r4 = t5.tr.subtract(i4.tr);
              n5.cross(r4).dot(i4.ori.getYaxis()) > 0 ? s4.tr.set(0.05, -0.05, 0.08) : s4.tr.set(-0.05, -0.05, 0.08);
            } else
              s4.tr.set(0, -0.05, 0.08);
            if (this.controllerUI.localXfoParam.value = s4, this.uiController && (this.uiController.getTipItem().addChild(this.controllerUI, false), this.pointerController && this.pointerController.getTipItem().addChild(this.__uiPointerItem, false), this.appData.session)) {
              const e6 = () => {
                this.appData.session.pub("pose-message", {interfaceType: "VR", showUIPanel: {controllerId: this.uiController.getId(), localXfo: s4.toJSON(), size: this.controllerUI.size.toJSON()}});
              };
              this.controllerUI.ready ? e6() : this.controllerUI.on("ready", e6);
            }
            this.uiOpen = true;
          }
          closeUI() {
            this.controllerUI.deactivate(), this.uiController && (this.uiController.getTipItem().removeChildByHandle(this.controllerUI), this.pointerController && this.pointerController.getTipItem().removeChildByHandle(this.__uiPointerItem), this.appData.session && this.appData.session.pub("pose-message", {interfaceType: "VR", closehideUIPanel: {controllerId: this.uiController.getId()}})), this.uiOpen = false;
          }
          setPointerLength(e5) {
            this.__pointerLocalXfo.sc.set(1, 1, e5), this.__uiPointerItem.localXfoParam.value = this.__pointerLocalXfo;
          }
          calcUIIntersection() {
            const e5 = this.__uiPointerItem.globalXfoParam.value, n4 = e5.ori.getZaxis().negate(), i4 = new t4.Ray(e5.tr, n4), s4 = this.controllerUI.globalXfoParam.value, r4 = this.controllerUI.size.multiply(s4.sc), a4 = new t4.Ray(s4.tr, s4.ori.getZaxis().negate()), o4 = i4.intersectRayPlane(a4);
            if (o4 <= 0)
              return void this.setPointerLength(0.5);
            const l4 = e5.tr.add(n4.scale(o4)).subtract(a4.start), h4 = l4.dot(s4.ori.getXaxis()) / r4.x, c4 = l4.dot(s4.ori.getYaxis()) / r4.y;
            if (Math.abs(h4) > 0.5 || Math.abs(c4) > 0.5)
              return void this.setPointerLength(0.5);
            this.setPointerLength(o4 / s4.sc.z);
            const d4 = this.__vrUIDOMElement.getBoundingClientRect();
            return {clientX: Math.round(h4 * -d4.width + d4.width / 2), clientY: Math.round(c4 * -d4.height + d4.height / 2)};
          }
          sendEventToUI(e5, t5) {
            const n4 = this.calcUIIntersection();
            if (n4) {
              n4.offsetX = n4.pageX = n4.pageX = n4.screenX = n4.clientX, n4.offsetY = n4.pageY = n4.pageY = n4.screenY = n4.clientY;
              let i4 = document.elementFromPoint(n4.clientX, n4.clientY);
              return i4 ? (i4.shadowRoot && (i4 = i4.shadowRoot.elementFromPoint(n4.clientX, n4.clientY)), i4 != this._element && (this._element && this.controllerUI.sendMouseEvent("mouseleave", Object.assign(t5, n4), this._element), this._element = i4, this.controllerUI.sendMouseEvent("mouseenter", Object.assign(t5, n4), this._element)), this.controllerUI.sendMouseEvent(e5, Object.assign(t5, n4), this._element)) : this._element = null, this._element;
            }
            this._element && (this.controllerUI.sendMouseEvent("mouseleave", Object.assign(t5, n4), this._element), this._element = null);
          }
          onPointerDown(e5) {
            if (e5.pointerType === t4.POINTER_TYPES.xr && e5.controller == this.pointerController && this.uiOpen) {
              this.__triggerHeld = true;
              const t5 = this.sendEventToUI("mousedown", {button: e5.button - 1});
              this.__triggerDownElem = t5 || null, e5.stopPropagation();
            }
          }
          onPointerUp(e5) {
            if (e5.pointerType === t4.POINTER_TYPES.xr && e5.controller == this.pointerController && this.uiOpen) {
              this.__triggerHeld = false;
              const t5 = this.sendEventToUI("mouseup", {button: e5.button - 1});
              t5 && this.__triggerDownElem == t5 && this.sendEventToUI("mouseup", {button: e5.button - 1}), this.__triggerDownElem = null, e5.stopPropagation();
            }
          }
          onPointerMove(e5) {
            if (e5.pointerType === t4.POINTER_TYPES.xr)
              if (this.uiOpen) {
                const t5 = e5.viewXfo;
                (() => {
                  const n4 = this.uiController.getTreeItem().globalXfoParam.value, i4 = n4.tr.subtract(t5.tr);
                  return i4.normalizeInPlace(), !(i4.angleTo(n4.ori.getYaxis()) > 0.5 * Math.PI && (this.closeUI(), e5.getCapture() == this && e5.releaseCapture(), 1));
                })() && this.sendEventToUI("mousemove", {}), e5.stopPropagation();
              } else {
                if (!e5.controllers[0] || e5.controllers[0].buttonPressed || !e5.controllers[1] || e5.controllers[1].buttonPressed)
                  return;
                const t5 = e5.viewXfo, n4 = (n5, i4) => {
                  const s4 = n5.getTreeItem().globalXfoParam.value, r4 = s4.tr.subtract(t5.tr);
                  return r4.normalizeInPlace(), r4.angleTo(s4.ori.getYaxis()) < 0.25 * Math.PI && (this.displayUI(n5, i4, t5), e5.setCapture(this), e5.stopPropagation(), true);
                };
                if (n4(e5.controllers[0], e5.controllers[1]))
                  return;
                if (n4(e5.controllers[1], e5.controllers[0]))
                  return;
              }
          }
        }
        class J3 extends l3 {
          constructor(e5) {
            super("HoldObjectsChange"), this.__selection = [], this.__prevXfos = [], this.__newXfos = [], e5 && this.update(e5);
          }
          undo() {
            for (let e5 = 0; e5 < this.__selection.length; e5++)
              this.__selection[e5] && this.__prevXfos[e5] && (this.__selection[e5].globalXfoParam.value = this.__prevXfos[e5]);
          }
          redo() {
            for (let e5 = 0; e5 < this.__selection.length; e5++)
              this.__selection[e5] && this.__newXfos[e5] && (this.__selection[e5].globalXfoParam.value = this.__newXfos[e5]);
          }
          update(e5) {
            if (e5.newItem)
              this.__selection[e5.newItemId] = e5.newItem, this.__prevXfos[e5.newItemId] = e5.newItem.globalXfoParam.value;
            else if (e5.changeXfos)
              for (let t5 = 0; t5 < e5.changeXfoIds.length; t5++) {
                const n4 = e5.changeXfoIds[t5];
                this.__selection[n4] && (this.__selection[n4].globalXfoParam.value = e5.changeXfos[t5], this.__newXfos[n4] = e5.changeXfos[t5]);
              }
            this.emit("updated", e5);
          }
          toJSON(e5) {
            const t5 = super.toJSON(e5), n4 = [];
            for (let e6 = 0; e6 < this.__selection.length; e6++)
              this.__selection[e6] ? n4[e6] = this.__selection[e6].getPath() : n4.push(null);
            return t5.itemPaths = n4, t5;
          }
          fromJSON(e5, t5) {
            super.fromJSON(e5, t5);
            const n4 = t5.appData.scene.getRoot();
            this.__selection = [];
            for (let t6 = 0; t6 < e5.itemPaths.length; t6++) {
              const i4 = e5.itemPaths[t6];
              if (i4 && i4 != "") {
                const e6 = n4.resolvePath(i4, 1);
                e6 != n4 && (this.__selection[t6] = e6, this.__prevXfos[t6] = e6.globalXfoParam.value);
              }
            }
          }
          updateFromJSON(e5) {
            this.update(e5);
          }
        }
        a3.registerChange("HoldObjectsChange", J3);
        class K3 extends t4.BaseTool {
          constructor(e5) {
            super(), this.__pressedButtonCount = 0, this.__freeIndices = [], this.__vrControllers = [], this.__heldObjectCount = 0, this.__heldGeomItems = [], this.__highlightedGeomItemIds = [], this.__heldGeomItemIds = [], this.__heldGeomItemRefs = [], this.__heldGeomItemOffsets = [], this.appData = e5;
          }
          activateTool() {
            super.activateTool(), this.appData.renderer.getGLCanvas().style.cursor = "crosshair";
            const e5 = (e6) => {
              this.__activated;
            };
            this.appData.renderer.getXRViewport().then((t5) => {
              for (const n4 of t5.getControllers())
                e5();
              this.addIconToControllerId = t5.on("controllerAdded", (t6) => e5(t6.controller));
            });
          }
          deactivateTool() {
            super.deactivateTool(), this.appData.renderer.getXRViewport().then((e5) => {
              e5.removeListenerById("controllerAdded", this.addIconToControllerId);
            });
          }
          computeGrabXfo(e5) {
            let n4;
            if (e5.length == 1)
              n4 = this.__vrControllers[e5[0]].getTipXfo();
            else if (e5.length == 2) {
              const i4 = this.__vrControllers[e5[0]].getTipXfo(), s4 = this.__vrControllers[e5[1]].getTipXfo();
              i4.ori.alignWith(s4.ori), n4 = new t4.Xfo(), n4.tr = i4.tr.lerp(s4.tr, 0.5), n4.ori = i4.ori.lerp(s4.ori, 0.5);
              let r4 = s4.tr.subtract(i4.tr);
              r4.normalizeInPlace();
              const a4 = n4.ori.getXaxis();
              r4.dot(a4) < 0 && (r4 = r4.negate());
              const o4 = r4.angleTo(a4);
              if (o4 > 0) {
                const e6 = a4.cross(r4);
                e6.normalizeInPlace();
                const i5 = new t4.Quat();
                i5.setFromAxisAndAngle(e6, o4), n4.ori = i5.multiply(n4.ori);
              }
            }
            return n4;
          }
          initAction() {
            for (let e5 = 0; e5 < this.__heldGeomItems.length; e5++) {
              const t5 = this.__heldGeomItems[e5];
              if (!t5)
                continue;
              const n4 = this.computeGrabXfo(this.__heldGeomItemRefs[e5]);
              this.__heldGeomItemOffsets[e5] = n4.inverse().multiply(t5.globalXfoParam.value);
            }
          }
          onPointerDown(e5) {
            if (e5.pointerType === t4.POINTER_TYPES.xr) {
              const t5 = e5.controller.getId();
              this.__vrControllers[t5] = e5.controller;
              const n4 = this.__highlightedGeomItemIds[t5];
              if (n4) {
                let i4 = this.__heldGeomItems.indexOf(n4);
                if (i4 == -1) {
                  i4 = this.__heldGeomItems.length, this.__heldObjectCount++, this.__heldGeomItems.push(n4), this.__heldGeomItemRefs[i4] = [t5], this.__heldGeomItemIds[t5] = i4;
                  const e6 = {newItem: n4, newItemId: i4};
                  this.change ? this.change.update(e6) : (this.change = new J3(e6), a3.getInstance().addChange(this.change));
                } else
                  this.__heldGeomItemIds[t5] = i4, this.__heldGeomItemRefs[i4].push(t5);
                this.initAction(), e5.stopPropagation();
              }
            }
          }
          onPointerUp(e5) {
            if (e5.pointerType === t4.POINTER_TYPES.xr) {
              const t5 = e5.controller.getId();
              if (this.__pressedButtonCount--, this.__heldGeomItemIds[t5] !== void 0) {
                const n4 = this.__heldGeomItemIds[t5], i4 = this.__heldGeomItemRefs[n4];
                i4.splice(i4.indexOf(t5), 1), i4.length == 0 && (this.__heldObjectCount--, this.__heldGeomItems[n4] = void 0, this.change = void 0), this.__heldGeomItemIds[t5] = void 0, this.initAction(), e5.stopPropagation();
              }
            }
          }
          onPointerMove(e5) {
            if (e5.pointerType === t4.POINTER_TYPES.xr) {
              if (!this.change)
                return void e5.controllers.forEach((e6) => {
                  const n5 = e6.getId(), i5 = e6.getGeomItemAtTip();
                  if (i5) {
                    const e7 = i5.geomItem;
                    this.__highlightedGeomItemIds[n5] != e7 && (this.__highlightedGeomItemIds[n5] && this.__highlightedGeomItemIds[n5].removeHighlight("vrHoldObject"), e7.addHighlight("vrHoldObject", new t4.Color(1, 0, 0, 0.2)), this.__highlightedGeomItemIds[n5] = e7);
                  } else
                    this.__highlightedGeomItemIds[n5] && (this.__highlightedGeomItemIds[n5].removeHighlight("vrHoldObject"), this.__highlightedGeomItemIds[n5] = null);
                });
              const n4 = [], i4 = [];
              for (let e6 = 0; e6 < this.__heldGeomItems.length; e6++) {
                if (!this.__heldGeomItems[e6])
                  continue;
                const t5 = this.computeGrabXfo(this.__heldGeomItemRefs[e6]);
                n4.push(t5.multiply(this.__heldGeomItemOffsets[e6])), i4.push(e6);
              }
              this.change.update({changeXfos: n4, changeXfoIds: i4}), e5.stopPropagation();
            }
          }
          onPointerDoublePress(e5) {
            e5.pointerType, t4.POINTER_TYPES.xr;
          }
        }
        class W3 extends t4.BaseTool {
          constructor(e5) {
            super(), this.appData = e5;
          }
        }
        class Y3 extends W3 {
          constructor(e5) {
            super(e5), this.colorParam = new t4.ColorParameter("Color", new t4.Color(0.7, 0.2, 0.2)), e5 || console.error("App data not provided to tool"), this.appData = e5, this.stage = 0, this.removeToolOnRightClick = true, this.parentItem = "parentItem" in e5 ? e5.parentItem : e5.scene.getRoot(), this.addParameter(this.colorParam), this.controllerAddedHandler = this.controllerAddedHandler.bind(this);
          }
          addIconToVRController(e5) {
            this.vrControllerToolTip || (this.vrControllerToolTip = new t4.Cross(0.05), this.vrControllerToolTipMat = new t4.Material("VRController Cross", "LinesShader"), this.vrControllerToolTipMat.getParameter("BaseColor").value = this.colorParam.getValue(), this.vrControllerToolTipMat.setSelectable(false));
            const n4 = new t4.GeomItem("CreateGeomToolTip", this.vrControllerToolTip, this.vrControllerToolTipMat);
            n4.setSelectable(false), e5.getTipItem().addChild(n4, false);
          }
          controllerAddedHandler(e5) {
            this.addIconToVRController(e5.controller);
          }
          activateTool() {
            super.activateTool(), this.prevCursor = this.appData.renderer.getGLCanvas().style.cursor, this.appData.renderer.getGLCanvas().style.cursor = "crosshair", this.appData.renderer.getXRViewport().then((e5) => {
              for (const t5 of e5.getControllers())
                this.addIconToVRController(t5);
              e5.on("controllerAdded", this.controllerAddedHandler);
            });
          }
          deactivateTool() {
            super.deactivateTool(), this.appData.renderer.getGLCanvas().style.cursor = this.prevCursor, this.appData.renderer.getXRViewport().then((e5) => {
              e5.off("controllerAdded", this.controllerAddedHandler);
            });
          }
          screenPosToXfo(e5) {
            if (!(e5 instanceof t4.ZeaMouseEvent || e5 instanceof t4.ZeaTouchEvent))
              return void console.warn("not handling VR");
            if (e5.intersectionData) {
              const t5 = i3(e5), n5 = this.constructionPlane.clone();
              return n5.tr = t5.pointAtDist(e5.intersectionData.dist), n5;
            }
            const n4 = i3(e5), s4 = new t4.Ray(this.constructionPlane.tr, this.constructionPlane.ori.getZaxis()), r4 = n4.intersectRayPlane(s4);
            if (r4 > 0) {
              const e6 = this.constructionPlane.clone();
              return e6.tr = n4.pointAtDist(r4), e6;
            }
            const a4 = e5.viewport.getCamera(), o4 = a4.globalXfoParam.value.clone();
            return o4.tr = n4.pointAtDist(a4.getFocalDistance()), o4;
          }
          createStart(e5, t5) {
            this.stage = 1;
          }
          createPoint(e5) {
          }
          createMove(e5) {
          }
          createRelease(e5) {
          }
          onPointerDown(e5) {
            if (e5 instanceof t4.XRControllerEvent)
              this.onVRControllerButtonDown(e5);
            else if (e5 instanceof t4.ZeaMouseEvent) {
              if (e5.altKey)
                return;
              if (this.stage == 0)
                if (e5.button == 0 || e5.pointerType !== "mouse") {
                  this.constructionPlane = new t4.Xfo();
                  const n4 = this.screenPosToXfo(e5);
                  this.createStart(n4), e5.stopPropagation();
                } else
                  e5.button;
              else
                e5.button == 2 && (a3.getInstance().cancel(), this.stage = 0);
              e5.stopPropagation(), e5.preventDefault();
            } else
              console.warn("Touch event not handled");
          }
          onPointerMove(e5) {
            if (e5.pointerType === "xr")
              this.onVRPoseChanged(e5);
            else if (this.stage > 0) {
              const t5 = this.screenPosToXfo(e5);
              this.createMove(t5.tr), e5.stopPropagation(), e5.preventDefault();
            }
          }
          onPointerUp(e5) {
            if (e5 instanceof t4.XRControllerEvent)
              this.onVRControllerButtonUp(e5);
            else if (this.stage > 0) {
              const t5 = this.screenPosToXfo(e5);
              this.createRelease(t5.tr), e5.stopPropagation();
            }
          }
          onWheel(e5) {
          }
          onKeyPressed(e5) {
          }
          onKeyDown(e5) {
          }
          onKeyUp(e5) {
          }
          onTouchCancel(e5) {
          }
          onVRControllerButtonDown(e5) {
            if (!this.__activeController) {
              this.__activeController = e5.controller, this.constructionPlane = new t4.Xfo();
              const n4 = this.constructionPlane.clone();
              n4.tr = this.__activeController.getTipXfo().tr, this.createStart(n4, this.appData.scene.getRoot());
            }
            e5.stopPropagation();
          }
          onVRPoseChanged(e5) {
            if (this.__activeController && this.stage > 0) {
              const t5 = this.__activeController.getTipXfo();
              this.createMove(t5.tr), e5.stopPropagation();
            }
          }
          onVRControllerButtonUp(e5) {
            if (this.stage > 0 && this.__activeController == e5.controller) {
              const t5 = this.__activeController.getTipXfo();
              this.createRelease(t5.tr), this.stage == 0 && (this.__activeController = void 0), e5.stopPropagation();
            }
          }
        }
        class q3 extends l3 {
          constructor(e5, t5) {
            super(e5), this.parentItem = t5 || null;
          }
          setParentAndXfo(e5, t5) {
            this.parentItem = e5;
            const n4 = this.parentItem.generateUniqueName(this.geomItem.getName());
            this.geomItem.setName(n4), this.geomItem.globalXfoParam.value = t5, this.parentItem.addChild(this.geomItem);
          }
          undo() {
            this.parentItem.removeChild(this.parentItem.getChildIndex(this.geomItem));
          }
          redo() {
            this.parentItem.addChild(this.geomItem, false, false);
          }
          toJSON(e5) {
            const t5 = super.toJSON(e5);
            t5.parentItemPath = this.parentItem.getPath(), t5.geomItemName = this.geomItem.getName(), t5.geomItemXfo = this.geomItem.localXfoParam.getValue();
            const n4 = this.geomItem.getParameter("Material").getValue();
            return t5.color = n4.getParameter("BaseColor").getValue(), t5;
          }
          fromJSON(e5, n4) {
            const i4 = n4.appData.scene.getRoot();
            this.parentItem = i4.resolvePath(e5.parentItemPath, 1), this.geomItem.setName(this.parentItem.generateUniqueName(e5.geomItemName));
            const s4 = new t4.Xfo();
            if (s4.fromJSON(e5.geomItemXfo), this.geomItem.localXfoParam.value = s4, this.childIndex = this.parentItem.getChildIndex(this.parentItem.addChild(this.geomItem, false)), e5.color) {
              const n5 = new t4.Color(0.7, 0.2, 0.2);
              n5.fromJSON(e5.color), this.geomItem.getParameter("Material").getValue().getParameter("BaseColor").value = n5;
            }
          }
          destroy() {
          }
        }
        class Q3 extends q3 {
          constructor(e5, n4, i4, s4 = 1e-3) {
            super("Create Line"), this.line = new t4.Lines(), this.line.setNumVertices(2), this.line.setNumSegments(1), this.line.getVertexAttribute("positions").setValue(0, new t4.Vec3()), this.line.setSegmentVertexIndices(0, 0, 1);
            const r4 = new t4.FatLinesMaterial("Line");
            i4 && (r4.baseColorParam.value = i4), r4.lineThicknessParam && (r4.lineThicknessParam.value = s4), this.geomItem = new t4.GeomItem("Line", this.line, r4), e5 && n4 && this.setParentAndXfo(e5, n4);
          }
          update(e5) {
            e5.p1 && (this.line.positions.getValueRef(1).setFromOther(e5.p1), this.line.setBoundingBoxDirty(), this.line.emit("geomDataChanged")), this.emit("updated", e5);
          }
          fromJSON(e5, n4) {
            if (super.fromJSON(e5, n4), e5.color) {
              const n5 = new t4.Color();
              n5.fromJSON(e5.color), this.geomItem.materialParam.value.getParameter("BaseColor").value = n5;
            }
          }
        }
        a3.registerChange("CreateLineChange", Q3);
        class ee3 extends Y3 {
          constructor(e5) {
            super(e5), this.lineThickness = new t4.NumberParameter("LineThickness", 0.01, [0, 0.1]), this.addParameter(this.lineThickness);
          }
          createStart(e5) {
            const t5 = this.colorParam.getValue(), n4 = this.lineThickness.getValue();
            this.change = new Q3(this.parentItem, e5, t5, n4), a3.getInstance().addChange(this.change), this.xfo = e5.inverse(), this.stage = 1, this.length = 0;
          }
          createMove(e5) {
            const t5 = this.xfo.transformVec3(e5);
            this.length = t5.length(), this.change.update({p1: t5});
          }
          createRelease(e5) {
            this.length == 0 && a3.getInstance().cancel(), this.stage = 0, this.emit("actionFinished");
          }
          onVRControllerButtonDown(e5) {
            if (this.stage == 0) {
              const t5 = e5.viewport.__stageScale;
              this.lineThickness.value = 3e-3 * t5;
            }
            super.onVRControllerButtonDown(e5);
          }
        }
        class te3 extends q3 {
          constructor(e5, n4, i4) {
            super("Create Cone");
            const s4 = new t4.Cone(0, 0);
            s4.heightParam.value = 0;
            const r4 = new t4.Material("Cone", "SimpleSurfaceShader");
            this.geomItem = new t4.GeomItem("Cone", s4, r4), e5 && n4 && (r4.getParameter("BaseColor").value = i4, this.setParentAndXfo(e5, n4));
          }
          update(e5) {
            e5.radius && (this.geomItem.getParameter("Geometry").getValue().radiusParam.value = e5.radius), e5.height && (this.geomItem.getParameter("Geometry").getValue().getParameter("Height").value = e5.height), this.emit("updated", e5);
          }
        }
        a3.registerChange("CreateConeChange", te3);
        class ne3 extends q3 {
          constructor(e5, n4) {
            super("CreateCircle"), this.circle = new t4.Circle(0, 64);
            const i4 = new t4.Material("circle", "FatLinesShader");
            i4.getParameter("BaseColor").value = new t4.Color(0.7, 0.2, 0.2), this.geomItem = new t4.GeomItem("Circle", this.circle, i4), e5 && n4 && this.setParentAndXfo(e5, n4);
          }
          update(e5) {
            this.circle.radiusParam.value = e5.radius, this.emit("updated", e5);
          }
          toJSON() {
            const e5 = super.toJSON();
            return e5.radius = this.circle.radiusParam.value, e5;
          }
          updateFromJSON(e5) {
            console.log("CreateCircleChange:", e5), e5.radius && (this.circle.radiusParam.value = e5.radius);
          }
        }
        a3.registerChange("CreateCircleChange", ne3);
        class ie3 extends q3 {
          constructor(e5, n4) {
            super("CreateRect"), this.rect = new t4.Rect(0, 0);
            const i4 = new t4.Material("circle", "FatLinesShader");
            i4.getParameter("BaseColor").value = new t4.Color(0.7, 0.2, 0.2), this.geomItem = new t4.GeomItem("Rect", this.rect, i4), e5 && n4 && this.setParentAndXfo(e5, n4);
          }
          update(e5) {
            if (e5.baseSize && (this.rect.sizeXParam.value = e5.baseSize[0], this.rect.sizeYParam.value = e5.baseSize[1]), e5.tr) {
              const t5 = this.geomItem.localXfoParam.getValue();
              t5.tr.fromJSON(e5.tr), this.geomItem.localXfoParam.value = t5;
            }
            this.emit("updated", e5);
          }
        }
        a3.registerChange("CreateRectChange", ie3);
        class se3 extends q3 {
          constructor(e5, n4, i4, s4 = 1e-3) {
            super("CreateFreehandLine"), this.vertexCount = 100, this.used = 0, this.line = new t4.Lines(), this.line.setNumVertices(this.vertexCount), this.line.setNumSegments(this.vertexCount - 1), this.line.getVertexAttribute("positions").setValue(0, new t4.Vec3());
            const r4 = new t4.FatLinesMaterial("freeHandLine");
            i4 && (r4.baseColorParam.value = i4), r4.lineThicknessParam && (r4.lineThicknessParam.value = s4), this.geomItem = new t4.GeomItem("freeHandLine", this.line, r4), e5 && n4 && this.setParentAndXfo(e5, n4);
          }
          update(e5) {
            this.used++;
            let t5 = false;
            this.used >= this.line.getNumSegments() && (this.vertexCount = this.vertexCount + 100, this.line.setNumVertices(this.vertexCount), this.line.setNumSegments(this.vertexCount - 1), t5 = true), this.line.getVertexAttribute("positions").setValue(this.used, e5.point), this.line.setSegmentVertexIndices(this.used - 1, this.used - 1, this.used), this.line.setBoundingBoxDirty(), t5 ? this.line.emit("geomDataTopologyChanged", {topologyChanged: true}) : this.line.emit("geomDataChanged", {topologyChanged: true}), this.emit("updated", e5);
          }
          toJSON(e5) {
            const t5 = super.toJSON(e5), n4 = this.geomItem.materialParam.value;
            return t5.lineThickness = n4.lineThicknessParam.value, t5.color = n4.baseColorParam.value, t5;
          }
          fromJSON(e5, n4) {
            if (e5.lineThickness && (this.geomItem.materialParam.value.lineThicknessParam.value = e5.lineThickness), e5.color) {
              const n5 = new t4.Color(0.7, 0.2, 0.2);
              n5.fromJSON(e5.color), this.geomItem.materialParam.value.baseColorParam.value = n5;
            }
            super.fromJSON(e5, n4);
          }
        }
        a3.registerChange("CreateFreehandLineChange", se3);
        class re3 extends q3 {
          constructor(e5, n4, i4) {
            super("CreateSphere", e5), this.sphere = new t4.Sphere(0, 24, 12);
            const s4 = new t4.Material("Sphere", "SimpleSurfaceShader");
            this.geomItem = new t4.GeomItem("Sphere", this.sphere, s4), this.geomItem.setSelectable(false), e5 && n4 && i4 && (s4.getParameter("BaseColor").value = i4, this.setParentAndXfo(e5, n4));
          }
          update(e5) {
            this.sphere.radiusParam.value = e5.radius, this.emit("updated", e5);
          }
          toJSON() {
            const e5 = super.toJSON();
            return e5.radius = this.sphere.radiusParam.getValue(), e5;
          }
          updateFromJSON(e5) {
            e5.radius && (this.sphere.radiusParam.value = e5.radius);
          }
        }
        a3.registerChange("CreateSphereChange", re3);
        class ae3 extends q3 {
          constructor(e5, n4, i4) {
            super("CreateCuboid"), this.cuboid = new t4.Cuboid(0, 0, 0, true);
            const s4 = new t4.Material("Cuboid", "SimpleSurfaceShader");
            this.geomItem = new t4.GeomItem("Cuboid", this.cuboid, s4), e5 && n4 && (s4.getParameter("BaseColor").value = i4, this.setParentAndXfo(e5, n4));
          }
          update(e5) {
            if (e5.baseSize && (this.cuboid.sizeXParam.value = e5.baseSize[0], this.cuboid.sizeYParam.value = e5.baseSize[1]), e5.tr) {
              const t5 = this.geomItem.localXfoParam.getValue();
              t5.tr.fromJSON(e5.tr), this.geomItem.localXfoParam.value = t5;
            }
            e5.height && (this.cuboid.sizeZParam.value = e5.height), this.emit("updated", e5);
          }
        }
        a3.registerChange("CreateCuboidChange", ae3);
        class oe3 extends t4.BaseTool {
          constructor() {
            super(), this.tools = {}, this.toolStack = [];
          }
          registerTool(e5, t5) {
            this.tools[e5] = t5;
          }
          pushTool(e5) {
            const t5 = this.tools[e5];
            if (!t5)
              throw Error("Tool not found" + e5);
            t5.activateTool && t5.activateTool(), this.toolStack.push(this.tools[e5]);
          }
          popTool() {
            if (this.toolStack.length == 0)
              throw Error("Tool stack is empty");
            const e5 = this.toolStack[this.toolStack.length - 1];
            e5.deactivateTool && e5.deactivateTool(), this.toolStack.pop();
          }
          activeTool() {
            if (this.toolStack.length > 0)
              return this.toolStack[this.toolStack.length - 1];
          }
          activeToolName() {
            if (this.toolStack.length > 0) {
              const e5 = this.toolStack[this.toolStack.length - 1];
              for (const t5 in this.tools)
                if (this.tools[t5] == e5)
                  return t5;
            }
            return "";
          }
          onPointerDown(e5) {
            for (let t5 = this.toolStack.length - 1; t5 >= 0; t5--) {
              const n4 = this.toolStack[t5];
              if (n4.onPointerDown && (n4.onPointerDown(e5), !e5.propagating))
                break;
            }
          }
          onPointerMove(e5) {
            for (let t5 = this.toolStack.length - 1; t5 >= 0; t5--) {
              const n4 = this.toolStack[t5];
              if (n4.onPointerMove && (n4.onPointerMove(e5), !e5.propagating))
                break;
            }
          }
          onPointerUp(e5) {
            for (let t5 = this.toolStack.length - 1; t5 >= 0; t5--) {
              const n4 = this.toolStack[t5];
              if (n4.onPointerUp && (n4.onPointerUp(e5), !e5.propagating))
                break;
            }
          }
          onPointerDoublePress(e5) {
            for (let t5 = this.toolStack.length - 1; t5 >= 0; t5--) {
              const n4 = this.toolStack[t5];
              if (n4.onPointerDoublePress && (n4.onPointerDoublePress(e5), !e5.propagating))
                break;
            }
          }
          onWheel(e5) {
            for (let t5 = this.toolStack.length - 1; t5 >= 0; t5--) {
              const n4 = this.toolStack[t5];
              if (n4.onWheel && (n4.onWheel(e5), !e5.propagating))
                break;
            }
          }
          onKeyPressed(e5) {
            for (let t5 = this.toolStack.length - 1; t5 >= 0; t5--) {
              const n4 = this.toolStack[t5];
              if (n4.onKeyPressed && (n4.onKeyPressed(e5), !e5.propagating))
                break;
            }
          }
          onKeyDown(e5) {
            for (let t5 = this.toolStack.length - 1; t5 >= 0; t5--) {
              const n4 = this.toolStack[t5];
              if (n4.onKeyDown && (n4.onKeyDown(e5), !e5.propagating))
                break;
            }
          }
          onKeyUp(e5) {
            for (let t5 = this.toolStack.length - 1; t5 >= 0; t5--) {
              const n4 = this.toolStack[t5];
              if (n4.onKeyUp && (n4.onKeyUp(e5), !e5.propagating))
                break;
            }
          }
        }
        class le3 extends r3 {
          constructor(e5, n4 = 0.5, i4 = 0.02, s4 = new t4.Color("#F9CE03")) {
            super(e5), this.handleXfo = new t4.Xfo(), this.baseBarXfo = new t4.Xfo(), this.topBarXfo = new t4.Xfo(), this.lengthParam = new t4.NumberParameter("Length", n4), this.handleRadiusParam = new t4.NumberParameter("HandleRadius", i4), this.barRadiusParam = new t4.NumberParameter("BarRadius", 0.25 * i4), this.addParameter(this.lengthParam), this.addParameter(this.handleRadiusParam), this.addParameter(this.barRadiusParam), this.colorParam.value = s4, this.handleMat = new t4.Material("handle", "FlatSurfaceShader"), this.handleMat.getParameter("BaseColor").value = this.colorParam.getValue();
            const r4 = new t4.Material("topBar", "FlatSurfaceShader");
            r4.getParameter("BaseColor").value = new t4.Color(0.5, 0.5, 0.5);
            const a4 = new t4.Cylinder(0.25 * i4, 1, 64, 2, true, true), o4 = new t4.Sphere(i4, 64);
            this.handle = new t4.GeomItem("handle", o4, this.handleMat), this.baseBar = new t4.GeomItem("baseBar", a4, this.handleMat), this.topBar = new t4.GeomItem("topBar", a4, r4), this.barRadiusParam.on("valueChanged", () => {
              a4.radiusParam.value = this.barRadiusParam.getValue();
            }), this.handleRadiusParam.on("valueChanged", () => {
              o4.radiusParam.value = this.handleRadiusParam.getValue();
            }), this.lengthParam.on("valueChanged", () => {
              this.__updateSlider(this.value);
            }), this.colorParam.on("valueChanged", () => {
              this.handleMat.getParameter("BaseColor").value = this.colorParam.getValue();
            }), this.addChild(this.handle), this.addChild(this.baseBar), this.addChild(this.topBar), this.__updateSlider(0);
          }
          highlight() {
            super.highlight(), this.handleMat.getParameter("BaseColor").value = this.highlightColorParam.getValue();
          }
          unhighlight() {
            super.unhighlight(), this.handleMat.getParameter("BaseColor").value = this.colorParam.getValue();
          }
          setTargetParam(e5) {
            this.param = e5;
            const t5 = () => {
              this.__updateSlider(e5.getValue());
            };
            t5(), e5.on("valueChanged", t5);
          }
          __updateSlider(e5) {
            this.value = e5;
            const n4 = this.param, i4 = n4 && n4.getRange() ? n4.getRange() : [0, 1], s4 = t4.MathFunctions.remap(e5, i4[0], i4[1], 0, 1), r4 = this.lengthParam.getValue();
            this.baseBarXfo.sc.z = s4 * r4, this.handleXfo.tr.z = s4 * r4, this.topBarXfo.tr.z = s4 * r4, this.topBarXfo.sc.z = (1 - s4) * r4, this.handle.localXfoParam.value = this.handleXfo, this.baseBar.localXfoParam.value = this.baseBarXfo, this.topBar.localXfoParam.value = this.topBarXfo;
          }
          onDragStart(e5) {
            this.handleXfo.sc.x = this.handleXfo.sc.y = this.handleXfo.sc.z = 1.2, this.handle.localXfoParam.value = this.handleXfo, this.param && (this.change = new h3(this.param), a3.getInstance().addChange(this.change));
          }
          onDrag(e5) {
            const n4 = this.lengthParam.getValue(), i4 = this.param, s4 = i4 && i4.getRange() ? i4.getRange() : [0, 1], r4 = t4.MathFunctions.clamp(t4.MathFunctions.remap(this.value, 0, n4, s4[0], s4[1]), s4[0], s4[1]);
            if (!this.param)
              return this.__updateSlider(r4), void (this.value = r4);
            this.change.update({value: r4});
          }
          onDragEnd(e5) {
            this.change = null, this.handleXfo.sc.x = this.handleXfo.sc.y = this.handleXfo.sc.z = 1, this.handle.localXfoParam.value = this.handleXfo;
          }
          toJSON(e5) {
            const t5 = super.toJSON(e5);
            return this.param && (t5.targetParam = this.param.getPath()), t5;
          }
          fromJSON(e5, t5) {
            super.fromJSON(e5, t5), e5.targetParam && t5.resolvePath(e5.targetParam).then((e6) => {
              this.setTargetParam(e6);
            });
          }
        }
        t4.Registry.register("SliderHandle", le3);
        class he3 extends p3 {
          constructor(e5, n4 = 1, i4 = 1, s4 = 0.02, r4 = new t4.Color(1, 1, 0)) {
            super(e5), this.handleXfo = new t4.Xfo(), this.handleGeomOffsetXfo = new t4.Xfo(), this.arcRadiusParam = new t4.NumberParameter("ArcRadius", n4), this.arcAngleParam = new t4.NumberParameter("ArcAngle", i4), this.handleRadiusParam = new t4.NumberParameter("HandleRadius", s4), this.addParameter(this.arcRadiusParam), this.addParameter(this.arcAngleParam), this.addParameter(this.handleRadiusParam), this.colorParam.value = r4, this.handleMat = new t4.Material("handleMat", "HandleShader"), this.handleMat.getParameter("BaseColor").value = r4;
            const a4 = new t4.Circle(n4, 64, i4), o4 = new t4.Sphere(s4, 64);
            this.handle = new t4.GeomItem("handle", o4, this.handleMat), this.arc = new t4.GeomItem("arc", a4, this.handleMat), this.handleGeomOffsetXfo.tr.x = n4, this.handle.geomOffsetXfoParam.value = this.handleGeomOffsetXfo, this.range = [0, i4], this.arcAngleParam.on("valueChanged", () => {
              const e6 = this.arcAngleParam.getValue();
              a4.angleParam.value = e6, this.range = [0, e6];
            }), this.arcRadiusParam.on("valueChanged", () => {
              const e6 = this.arcRadiusParam.getValue();
              a4.radiusParam.value = e6, this.handleGeomOffsetXfo.tr.x = e6, this.handle.geomOffsetXfoParam.value = this.handleGeomOffsetXfo;
            }), this.handleRadiusParam.on("valueChanged", () => {
              o4.radiusParam.value = this.handleRadiusParam.getValue();
            }), this.colorParam.on("valueChanged", () => {
              this.handleMat.getParameter("BaseColor").value = this.colorParam.getValue();
            }), this.addChild(this.handle), this.addChild(this.arc), this.setTargetParam(this.handle.globalXfoParam, false);
          }
          onPointerEnter(e5) {
            e5.intersectionData && e5.intersectionData.geomItem == this.handle && this.highlight();
          }
          onPointerLeave(e5) {
            this.unhighlight();
          }
          onPointerDown(e5) {
            e5.intersectionData && e5.intersectionData.geomItem == this.handle && super.onPointerDown(e5);
          }
          highlight() {
            super.highlight(), this.handleMat.getParameter("BaseColor").value = this.highlightColorParam.getValue();
          }
          unhighlight() {
            super.unhighlight(), this.handleMat.getParameter("BaseColor").value = this.colorParam.getValue();
          }
          setTargetParam(e5, n4 = true) {
            if (this.param = e5, n4) {
              if (this.param instanceof t4.XfoParameter) {
                const t5 = () => {
                  this.globalXfoParam.value = e5.value;
                };
                t5(), e5.on("valueChanged", t5);
              } else if (this.param instanceof t4.NumberParameter) {
                const n5 = () => {
                  this.handleXfo.ori.setFromAxisAndAngle(new t4.Vec3(0, 0, 1), e5.getValue()), this.handle.globalXfoParam.value = this.handleXfo;
                };
                n5(), e5.on("valueChanged", n5);
              }
            }
          }
          getBaseXfo() {
            return this.handle.globalXfoParam.value;
          }
          onDragStart(e5) {
            this.baseXfo = this.globalXfoParam.value.clone(), this.baseXfo.sc.set(1, 1, 1), this.vec0 = this.globalXfoParam.value.ori.getXaxis(), this.vec0.normalizeInPlace(), this.change = new h3(this.param), a3.getInstance().addChange(this.change), this.handleGeomOffsetXfo.sc.x = this.handleGeomOffsetXfo.sc.y = this.handleGeomOffsetXfo.sc.z = 1.2, this.handle.geomOffsetXfoParam.value = this.handleGeomOffsetXfo, this.emit("dragStart");
          }
          onDrag(e5) {
            const n4 = this.holdPos.subtract(this.baseXfo.tr);
            n4.normalizeInPlace();
            let i4 = this.vec0.angleTo(n4);
            if (this.vec0.cross(n4).dot(this.baseXfo.ori.getZaxis()) < 0 && (i4 = -i4), this.range && (i4 = t4.MathFunctions.clamp(i4, this.range[0], this.range[1])), (e5 instanceof t4.ZeaMouseEvent || e5 instanceof t4.ZeaTouchEvent) && e5.shiftKey) {
              const e6 = Math.PI / 180 * 22.5;
              i4 = Math.floor(i4 / e6) * e6;
            }
            const s4 = new t4.Xfo();
            s4.ori.setFromAxisAndAngle(new t4.Vec3(0, 0, 1), i4);
            const r4 = this.baseXfo.multiply(s4);
            this.change ? this.param instanceof t4.XfoParameter ? this.change.update({value: r4}) : this.param instanceof t4.NumberParameter && this.change.update({value: i4}) : this.param instanceof t4.XfoParameter ? this.param.value = r4 : this.param instanceof t4.NumberParameter && (this.param.value = i4);
          }
          onDragEnd(e5) {
            this.change = null, this.handleGeomOffsetXfo.sc.x = this.handleGeomOffsetXfo.sc.y = this.handleGeomOffsetXfo.sc.z = 1, this.handle.geomOffsetXfoParam.value = this.handleGeomOffsetXfo, this.emit("dragEnd");
          }
          toJSON(e5) {
            const t5 = super.toJSON(e5);
            return this.param && (t5.targetParam = this.param.getPath()), t5;
          }
          fromJSON(e5, t5) {
            super.fromJSON(e5, t5), e5.targetParam && t5.resolvePath(e5.targetParam).then((e6) => {
              this.setTargetParam(e6);
            });
          }
        }
        t4.Registry.register("ArcSlider", he3);
        const ce3 = new t4.Sphere(3e-3, 24, 12, false);
        class de3 extends t4.TreeItem {
          constructor(e5 = "Measure", n4 = new t4.Color("#F9CE03")) {
            super(e5), this.colorParam = this.addParameter(new t4.ColorParameter("Color", n4)), this.markerMaterial = new c3("Marker"), this.markerMaterial.getParameter("BaseColor").value = new t4.Color(0, 0, 0), this.markerMaterial.getParameter("MaintainScreenSize").value = 1, this.markerMaterial.getParameter("Overlay").value = 0.5, this.lineMaterial = new t4.LinesMaterial("Line"), this.lineMaterial.baseColorParam.value = new t4.Color(0, 0, 0), this.lineMaterial.overlayParam.value = 0.5, this.markerA = new t4.GeomItem("markerA", ce3, this.markerMaterial), this.markerB = new t4.GeomItem("markerB", ce3, this.markerMaterial), this.addChild(this.markerA), this.addChild(this.markerB), this.colorParam.on("valueChanged", () => {
              const e6 = this.colorParam.getValue();
              this.label.getParameter("BackgroundColor").value = e6;
            });
          }
        }
        const ue3 = new t4.Lines();
        ue3.setNumVertices(2), ue3.setNumSegments(1), ue3.setSegmentVertexIndices(0, 0, 1), ue3.getVertexAttribute("positions").setValue(0, new t4.Vec3()), ue3.getVertexAttribute("positions").setValue(1, new t4.Vec3(0, 0, 1)), ue3.setBoundingBoxDirty();
        class fe3 extends de3 {
          constructor(e5 = "MeasureDistance", n4 = new t4.Color("#F9CE03"), i4 = "Meters") {
            super(e5, n4), this.lineGeomItem = null, this.sceneUnits = null, this.sceneUnits = i4;
          }
          updateMeasurement() {
            const e5 = this.markerA.globalXfoParam.value, n4 = this.markerB.globalXfoParam.value.tr.subtract(e5.tr), i4 = n4.length();
            if (i4 == 0)
              return;
            const s4 = this.colorParam.getValue();
            let r4 = 1;
            switch (this.sceneUnits) {
              case "Millimeters":
                break;
              case "Meters":
                r4 = 1e3;
            }
            const a4 = `${parseFloat((i4 * r4).toFixed(3))}mm`;
            this.label ? this.label.getParameter("Text").value = a4 : (this.label = new t4.Label("Distance"), this.label.getParameter("FontSize").value = 20, this.label.getParameter("BackgroundColor").value = s4, this.label.getParameter("Text").value = a4, this.billboard = new t4.BillboardItem("DistanceBillboard", this.label), this.billboard.localXfoParam.value = new t4.Xfo(), this.billboard.getParameter("PixelsPerMeter").value = 1500, this.billboard.getParameter("AlignedToCamera").value = true, this.billboard.getParameter("DrawOnTop").value = true, this.billboard.getParameter("FixedSizeOnscreen").value = true, this.billboard.getParameter("Alpha").value = 1, this.addChild(this.billboard), this.lineMaterial = new t4.LinesMaterial("Line"), this.lineMaterial.getParameter("BaseColor").value = new t4.Color(0, 0, 0), this.lineMaterial.getParameter("Overlay").value = 0.5, this.lineGeomItem = new t4.GeomItem("Line", ue3, this.lineMaterial), this.lineGeomItem.setSelectable(false), this.addChild(this.lineGeomItem));
            const o4 = e5.clone();
            o4.ori.setFromDirectionAndUpvector(n4, new t4.Vec3(n4.z, n4.x, n4.y)), o4.sc.z = i4, this.lineGeomItem.globalXfoParam.value = o4, n4.normalizeInPlace();
            const l4 = e5.tr.add(n4.scale(0.5 * i4)), h4 = new t4.Xfo(l4);
            h4.ori.setFromDirectionAndUpvector(n4, new t4.Vec3(n4.z, n4.x, n4.y)), this.billboard.globalXfoParam.value = h4;
          }
          setStartMarkerPos(e5) {
            const t5 = this.markerA.globalXfoParam.value;
            t5.tr = e5, this.markerA.globalXfoParam.value = t5, this.label && this.updateMeasurement();
          }
          setEndMarkerPos(e5) {
            const t5 = this.markerB.globalXfoParam.value;
            t5.tr = e5, this.markerB.globalXfoParam.value = t5, this.updateMeasurement();
          }
          setGeomBuffersVisibility(e5) {
            this.markerA.setSelectable(!e5), this.markerB.setSelectable(!e5);
          }
          getMeasurementText() {
            return this.label.getParameter("Text").getValue();
          }
        }
        t4.Registry.register("MeasureDistance", fe3);
        const me3 = new t4.Lines();
        me3.setNumVertices(2), me3.setNumSegments(1), me3.setSegmentVertexIndices(0, 0, 1);
        const ge3 = me3.getVertexAttribute("positions");
        ge3.setValue(0, new t4.Vec3()), ge3.setValue(1, new t4.Vec3(0, 0, 1)), me3.setBoundingBoxDirty();
        class pe3 extends de3 {
          constructor(e5 = "MeasureAngle", n4 = new t4.Color("#F9CE03")) {
            super(e5, n4);
          }
          createLinesAndLabel() {
            const e5 = this.markerA.globalXfoParam.value, n4 = this.markerB.globalXfoParam.value, i4 = e5.ori.getZaxis(), s4 = n4.ori.getZaxis(), r4 = i4.cross(s4).normalize(), a4 = r4.cross(i4).normalize(), o4 = r4.cross(s4).normalize(), l4 = new t4.Ray(e5.tr, a4), h4 = new t4.Ray(n4.tr, o4), c4 = l4.intersectRayVector(h4), d4 = i4.angleTo(s4), u4 = new t4.GeomItem("Line", me3, this.lineMaterial), f4 = new t4.GeomItem("Line", me3, this.lineMaterial);
            this.markerA.addChild(u4, false), this.markerB.addChild(f4, false), this.label = new t4.Label("Distance"), this.label.fontSizeParam.value = 20, this.label.backgroundColorParam.value = this.colorParam.getValue(), this.label.textParam.value = `${(d4 / (Math.PI / 180)).toFixed(3)} \xB0`, this.billboard = new t4.BillboardItem("DistanceBillboard", this.label), this.billboard.localXfoParam.value = new t4.Xfo(), this.billboard.pixelsPerMeterParam.value = 1500, this.billboard.alignedToCameraParam.value = true, this.billboard.drawOnTopParam.value = true, this.billboard.fixedSizeOnscreenParam.value = true, this.billboard.alphaParam.value = 1, this.addChild(this.billboard), this.colorParam.on("valueChanged", () => {
              const e6 = this.colorParam.getValue();
              this.markerMaterial.getParameter("BaseColor").value = e6, this.lineMaterial.baseColorParam.value = e6, this.label.backgroundColorParam.value = e6;
            });
            const m4 = new t4.Xfo();
            m4.tr.addInPlace(l4.pointAtDist(c4[0])), m4.tr.addInPlace(h4.pointAtDist(c4[1])), m4.tr.scaleInPlace(0.5), e5.ori.setFromDirectionAndUpvector(a4, i4), this.markerA.globalXfoParam.value = e5, n4.ori.setFromDirectionAndUpvector(o4, i4), this.markerB.globalXfoParam.value = n4;
            const g4 = new t4.Xfo();
            g4.sc.z = c4[0], u4.localXfoParam.value = g4;
            const p4 = new t4.Xfo();
            p4.sc.z = c4[1], f4.localXfoParam.value = p4, this.billboard.globalXfoParam.value = m4;
          }
          setXfoA(e5) {
            this.markerA.globalXfoParam.value = e5, this.markerB.globalXfoParam.value = e5;
          }
          getXfoA() {
            return this.markerA.globalXfoParam.value;
          }
          setXfoB(e5) {
            this.markerB.globalXfoParam.value = e5, this.createLinesAndLabel();
          }
        }
        t4.Registry.register("MeasureAngle", pe3);
        class ve3 extends l3 {
          constructor(e5) {
            super("MeasurementChange"), e5 && (this.measurement = e5);
          }
          update(e5) {
            this.measurement.fromJSON(e5.measurementData), this.emit("updated", e5);
          }
          end() {
            this.measurement.setGeomBuffersVisibility(true);
          }
          undo() {
            console.log("undo MeasurementChange"), this.parentItem = this.measurement.getOwner(), this.childIndex = this.parentItem.getChildIndex(this.measurement), this.parentItem.removeChild(this.childIndex);
          }
          redo() {
            console.log("redo MeasurementChange"), this.parentItem.insertChild(this.measurement, this.childIndex);
          }
          toJSON(e5) {
            const n4 = super.toJSON(e5);
            return n4.parentItemPath = this.measurement.getOwner().getPath(), n4.measurementType = t4.Registry.getClassName(Object.getPrototypeOf(this.measurement).constructor), n4.measurementData = this.measurement.toJSON(e5), n4;
          }
          fromJSON(e5, n4) {
            const i4 = n4.appData.scene.getRoot().resolvePath(e5.parentItemPath, 1);
            i4 && (this.measurement = t4.Registry.constructClass(e5.measurementType), this.measurement.fromJSON(e5.measurementData), i4.addChild(this.measurement));
          }
          destroy() {
          }
        }
        a3.registerChange("MeasurementChange", ve3);
        class we3 extends t4.BaseTool {
          constructor(e5) {
            super(), this.stage = 0, this.numStages = 1, this.geomConstraints = {}, this.colorParam = new t4.ColorParameter("Color", new t4.Color("#F9CE03")), this.addParameter(this.colorParam), e5 || console.error("App data not provided to tool"), this.appData = e5, this.measurementChange = null, this.highlightedItemA = null, this.highlightedItemB = null, this.stage = 0;
          }
          activateTool() {
            super.activateTool(), this.appData && this.appData.renderer && (this.prevCursor = this.appData.renderer.getGLCanvas().style.cursor, this.appData.renderer.getGLCanvas().style.cursor = "crosshair");
          }
          deactivateTool() {
            if (super.deactivateTool(), this.appData && this.appData.renderer && (this.appData.renderer.getGLCanvas().style.cursor = this.prevCursor), this.stage != 0) {
              const e5 = this.measurement.getOwner();
              e5.removeChild(e5.getChildIndex(this.measurement)), this.measurement = null, this.highlightedItemB && (this.highlightedItemB.removeHighlight(this.highlightedItemB_highlightKey, true), this.highlightedItemB = null), this.highlightedItemA && (this.highlightedItemA.removeHighlight(this.highlightedItemA_highlightKey, true), this.highlightedItemA = null), this.stage = 0;
            }
          }
          getGeomParams(e5, n4 = -1) {
            return new Promise((i4) => {
              const s4 = e5.geomParam.value;
              e5 instanceof t4.CADBody && s4 instanceof t4.CompoundGeom ? e5.assetItem.loadMetadata().then(() => {
                i4(s4.subGeoms[n4]);
              }) : i4(e5);
            });
          }
          getGeomParamsSync(e5, n4 = -1) {
            const i4 = e5.geomParam.value;
            return e5 instanceof t4.CADBody && i4 instanceof t4.CompoundGeom ? i4.subGeoms[n4] : e5;
          }
          getGeomXfo(e5, n4 = -1) {
            const i4 = e5.geomParam.value;
            if (i4 instanceof t4.CompoundGeom) {
              const t5 = i4.subGeoms[n4].getParameter("Xfo").value, s4 = e5.globalXfoParam.value, r4 = e5.geomOffsetXfoParam.value;
              return s4.multiply(r4).multiply(t5);
            }
            return e5.globalXfoParam.value;
          }
          checkGeom(e5, t5 = -1) {
            return new Promise((n4) => {
              this.getGeomParams(e5, t5).then((e6) => {
                if (e6) {
                  for (let t6 in this.geomConstraints) {
                    const i4 = e6.getParameter(t6);
                    i4 && this.geomConstraints[t6].includes(i4.value) && n4(e6);
                  }
                  n4(null);
                } else
                  n4(null);
              });
            });
          }
          onPointerMove(e5) {
            if (!((e5 instanceof t4.ZeaMouseEvent || e5 instanceof t4.ZeaTouchEvent) && e5.altKey || e5 instanceof t4.ZeaMouseEvent && e5.button !== 0))
              if (this.stage == 0) {
                if (e5.intersectionData && e5.intersectionData.geomItem instanceof t4.GeomItem) {
                  const n4 = e5.intersectionData.geomItem, i4 = e5.intersectionData.componentId;
                  if (n4 instanceof t4.CADBody && n4.geomParam.value instanceof t4.CompoundGeom) {
                    const e6 = n4;
                    if (!e6.shattered)
                      return void e6.setShatterState(true);
                  }
                  this.checkGeom(n4, i4).then((e6) => {
                    if (e6 && (n4 != this.highlightedItemA || i4 != this.highlightedItemA_componentId)) {
                      this.highlightedItemA && this.highlightedItemA.removeHighlight(this.highlightedItemA_highlightKey, true), this.highlightedItemA = n4, this.highlightedItemA_params = e6, this.highlightedItemA_componentId = i4, this.highlightedItemA_highlightKey = "measure:" + i4;
                      const t5 = this.colorParam.getValue();
                      t5.a = 0.2, this.highlightedItemA.addHighlight(this.highlightedItemA_highlightKey, t5, true);
                    }
                  });
                } else if (this.highlightedItemA) {
                  if (this.highlightedItemA.removeHighlight(this.highlightedItemA_highlightKey, true), this.highlightedItemA_componentId >= 0) {
                    const e6 = this.highlightedItemA;
                    e6.shattered && e6.setShatterState(false);
                  }
                  this.highlightedItemA = null;
                }
                e5.stopPropagation();
              } else {
                if (e5.intersectionData && e5.intersectionData.geomItem instanceof t4.GeomItem) {
                  const n4 = e5.intersectionData.geomItem, i4 = e5.intersectionData.componentId;
                  if (n4 instanceof t4.CADBody && n4.geomParam.value instanceof t4.CompoundGeom) {
                    const e6 = n4;
                    if (!e6.shattered)
                      return void e6.setShatterState(true);
                  }
                  n4 == this.highlightedItemA && i4 == this.highlightedItemA_componentId || n4 == this.highlightedItemB && i4 == this.highlightedItemB_componentId || this.checkGeom(n4, i4).then((e6) => {
                    if (e6) {
                      this.highlightedItemB && (this.highlightedItemB.removeHighlight(this.highlightedItemB_highlightKey, true), this.highlightedItemB = null), this.highlightedItemB = n4, this.highlightedItemB_params = e6, this.highlightedItemB_componentId = i4, this.highlightedItemB_highlightKey = "measure:" + i4;
                      const t5 = this.colorParam.value.clone();
                      t5.a = 0.2, this.highlightedItemB.addHighlight(this.highlightedItemB_highlightKey, t5, true);
                    }
                  });
                } else if (this.highlightedItemB) {
                  if (this.highlightedItemB.removeHighlight(this.highlightedItemB_highlightKey, true), this.highlightedItemA_componentId >= 0) {
                    const e6 = this.highlightedItemA;
                    e6.shattered && e6.setShatterState(false);
                  }
                  this.highlightedItemB = null;
                }
                e5.stopPropagation();
              }
          }
          onPointerUp(e5) {
            if (this.stage == this.numStages) {
              if (this.measurementChange = null, this.highlightedItemA) {
                if (this.highlightedItemA.removeHighlight(this.highlightedItemA_highlightKey, true), this.highlightedItemA_componentId >= 0) {
                  const e6 = this.highlightedItemA;
                  e6.shattered && e6.setShatterState(false);
                }
                this.highlightedItemA = null;
              }
              if (this.highlightedItemB) {
                if (this.highlightedItemB.removeHighlight(this.highlightedItemB_highlightKey, true), this.highlightedItemB_componentId >= 0) {
                  const e6 = this.highlightedItemB;
                  e6.shattered && e6.setShatterState(false);
                }
                this.highlightedItemB = null;
              }
              e5.stopPropagation();
            }
          }
        }
        class be3 extends HTMLElement {
          constructor() {
            var e5, n4, i4;
            super(), this.perspective = true, this.attachShadow({mode: "open"}), this.scene = document.createElement("div"), this.scene.classList.add("scene"), (e5 = this.shadowRoot) === null || e5 === void 0 || e5.appendChild(this.scene), this.cube = document.createElement("div"), this.cube.classList.add("cube"), this.scene.appendChild(this.cube);
            const s4 = (e6, t5) => {
              const n5 = document.createElement("div");
              n5.classList.add("cube__face"), n5.classList.add("cube__face_" + e6), n5.textContent = e6, n5.addEventListener("click", () => {
                this.alignFace(t5);
              }), this.cube.appendChild(n5);
            };
            s4("X", new t4.Vec3(1, 0, 0)), s4("-X", new t4.Vec3(-1, 0, 0)), s4("Y", new t4.Vec3(0, 1, 0)), s4("-Y", new t4.Vec3(0, -1, 0)), s4("Z", new t4.Vec3(0, 0, 1)), s4("-Z", new t4.Vec3(0, 0, -1));
            const r4 = document.createElement("div");
            r4.classList.add("home"), (n4 = this.shadowRoot) === null || n4 === void 0 || n4.appendChild(r4);
            const a4 = document.createElement("label"), o4 = document.createElement("input"), l4 = document.createElement("span");
            o4.setAttribute("type", "checkbox"), a4.classList.add("switch"), l4.classList.add("slider"), l4.classList.add("round"), a4.appendChild(o4);
            const h4 = document.createElement("span");
            h4.classList.add("switch-label"), h4.textContent = "Persp", r4.appendChild(h4), a4.appendChild(l4), r4.appendChild(a4), o4.checked = true, o4.addEventListener("change", () => {
              this.perspective = !this.perspective;
              const e6 = this.viewport.getCamera().globalXfoParam.getValue().ori.getZaxis();
              this.alignFace(e6);
            });
            const c4 = document.createElement("style");
            c4.appendChild(document.createTextNode('\n\n      \n      .home {\n        position: absolute;\n        bottom: 0px;\n        right: 10px;\n        font-family: sans-serif;\n      }\n\n      /* The switch - the box around the slider */\n.switch {\n  position: relative;\n  display: inline-block;\n  width: 40px;\n  height: 20px;\n}\n\n.switch-label {\n  position: absolute;\n  left: -50px;\n}\n\n/* Hide default HTML checkbox */\n.switch input {\n  opacity: 0;\n  width: 0;\n  height: 0;\n}\n\n/* The slider */\n.slider {\n  position: absolute;\n  cursor: pointer;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: #ccc;\n  -webkit-transition: .4s;\n  transition: .4s;\n}\n\n.slider:before {\n  position: absolute;\n  content: "";\n  height: 16px;\n  width: 16px;\n  left: 2px;\n  bottom: 2px;\n  background-color: white;\n  -webkit-transition: .4s;\n  transition: .4s;\n}\n\ninput:checked + .slider {\n  background-color: #2196F3;\n}\n\ninput:focus + .slider {\n  box-shadow: 0 0 1px #2196F3;\n}\n\ninput:checked + .slider:before {\n  -webkit-transform: translateX(20px);\n  -ms-transform: translateX(20px);\n  transform: translateX(20px);\n}\n\n/* Rounded sliders */\n.slider.round {\n  border-radius: 10px;\n}\n\n.slider.round:before {\n  border-radius: 50%;\n}\n\n      .scene {\n        width: 80px;\n        height: 95px;\n        border: 0px;\n        margin: 20px;\n        perspective: 800px;\n        font-family: sans-serif;\n        -webkit-touch-callout: none; /* iOS Safari */\n        -webkit-user-select: none; /* Safari */\n        user-select: none; /* Non-prefixed version, currently\n                                  supported by Chrome, Edge, Opera and Firefox */\n      }\n      \n      .cube {\n        width: 80px;\n        height: 80px;\n        position: relative;\n        transform-style: preserve-3d;\n        transform: translateZ(-80px);\n      }\n      \n      .cube__face {\n        position: absolute;\n        width: 76px;\n        height: 76px;\n        border: 2px solid black;\n        line-height: 76px;\n        font-size: 20px;\n        font-weight: bold;\n        color: black;\n        text-align: center;\n      }\n      \n      .cube__face:hover {\n        border: 2px solid white;\n        color: white;\n      }\n      \n      .cube__face_X   { background: rgba(255, 0, 0, 0.85); }\n      .cube__face_-X  { background: rgba(255, 0, 0, 0.85); }\n      .cube__face_Y  { background: rgba(  0, 255, 0, 0.85); }\n      .cube__face_-Y   { background: rgba(  0, 255, 0, 0.85); }\n      .cube__face_Z    { background: rgba(0, 0, 255, 0.85); }\n      .cube__face_-Z { background: rgba(0, 0, 255, 0.85); }\n      \n      .cube__face_X   { transform: rotateY(-90deg) translateZ(40px); }\n      .cube__face_-X  { transform: rotateY( 90deg) translateZ(40px); }\n      .cube__face_Y  { transform: rotateY(  0deg) translateZ(40px); }\n      .cube__face_-Y   { transform: rotateY(180deg) translateZ(40px); }\n      .cube__face_Z    { transform: rotateX( 90deg) translateZ(40px); }\n      .cube__face_-Z { transform: rotateX(-90deg) translateZ(40px); }\n      \n')), (i4 = this.shadowRoot) === null || i4 === void 0 || i4.appendChild(c4);
          }
          alignFace(e5, n4 = 400) {
            const i4 = this.viewport.getCamera(), s4 = i4.getTargetPosition(), r4 = i4.getFocalDistance(), a4 = i4.globalXfoParam.getValue(), o4 = a4.ori.getYaxis(), l4 = i4.isOrthographicParam.value;
            o4.subtractInPlace(e5.scale(o4.dot(e5)));
            const h4 = new t4.Vec3(), c4 = () => {
              Math.abs(o4.x) > Math.abs(o4.y) && Math.abs(o4.x) > Math.abs(o4.z) ? o4.x > 0 ? h4.x = 1 : h4.x = -1 : Math.abs(o4.y) > Math.abs(o4.x) && Math.abs(o4.y) > Math.abs(o4.z) ? o4.y > 0 ? h4.y = 1 : h4.y = -1 : Math.abs(o4.z) > Math.abs(o4.x) && Math.abs(o4.z) > Math.abs(o4.y) ? o4.z > 0 ? h4.z = 1 : h4.z = -1 : (console.warn("Invalid Starting Camera Xfo"), h4.z = 1);
            };
            let d4 = this.viewport.getManipulator();
            if (d4 instanceof oe3) {
              const e6 = d4;
              if ("CameraManipulator" in e6.tools)
                d4 = e6.tools.CameraManipulator;
              else
                for (let n5 in e6.tools)
                  if (e6.tools[n5] instanceof t4.CameraManipulator) {
                    d4 = e6.tools[n5];
                    break;
                  }
            }
            d4 instanceof t4.CameraManipulator && (d4.defaultManipulationState == t4.CameraManipulator.MANIPULATION_MODES.turntable ? e5.approxEqual(new t4.Vec3(0, 0, 1)) || e5.approxEqual(new t4.Vec3(0, 0, -1)) ? c4() : h4.z = 1 : c4());
            const u4 = new t4.Quat();
            u4.setFromDirectionAndUpvector(e5, h4), u4.alignWith(a4.ori);
            const f4 = s4.clone(), m4 = r4, g4 = this.perspective ? 0 : 1;
            g4 > 0.5 && l4 < 0.5 && (i4.viewHeight = Math.sin(0.5 * i4.fovParam.value) * r4 * 2);
            const p4 = Math.round(n4 / 20);
            let v4 = 1;
            const w4 = () => {
              const e6 = t4.MathFunctions.smoothStep(0, 1, v4 / p4), n5 = new t4.Xfo();
              n5.ori = a4.ori.slerp(u4, e6).normalize();
              const o5 = s4.lerp(f4, e6), h5 = t4.MathFunctions.lerp(r4, m4, e6), c5 = n5.ori.getZaxis().negate();
              if (n5.tr = o5.subtract(c5.scale(h5)), i4.globalXfoParam.setValue(n5), i4.setFocalDistance(h5), g4 > 0.5 && l4 < 0.5 || g4 < 0.5 && l4 > 0.5) {
                const n6 = t4.MathFunctions.lerp(l4, g4, e6);
                this.scene.style.perspective = g4 > 0.5 ? "none" : "800px", i4.setIsOrthographic(n6, 0);
              }
              v4++, v4 <= p4 ? setTimeout(w4, 20) : i4.emit("movementFinished");
            };
            w4();
          }
          updateViewCubeTransform(e5) {
            const t5 = e5.inverse().toMat4(), n4 = `translateZ(-80px) rotateY(180deg) matrix3d(${t5.m00},${t5.m01},${t5.m02},${t5.m03},${t5.m10},${t5.m11},${t5.m12},${t5.m13},${t5.m20},${t5.m21},${t5.m22},${t5.m23},0,0,0,1) rotateX( 90deg)`;
            this.cube.style.transform = n4;
          }
          setViewport(e5) {
            this.viewport = e5;
            const t5 = this.viewport.getCamera();
            this.updateViewCubeTransform(t5.globalXfoParam.value), t5.globalXfoParam.on("valueChanged", () => {
              this.updateViewCubeTransform(t5.globalXfoParam.value);
            });
          }
        }
        customElements.define("zea-view-cube", be3), t4.libsRegistry ? t4.libsRegistry.registerLib(n3) : console.warn("The version of the Zea Engine that you're using doesn't support the libraries registry. Please upgrade to the latest Zea Engine version."), e4.ArcSlider = he3, e4.AxialRotationHandle = v3, e4.Change = l3, e4.CreateCircleChange = ne3, e4.CreateCircleTool = class extends Y3 {
          constructor(e5) {
            super(e5);
          }
          createStart(e5) {
            this.change = new ne3(this.parentItem, e5), a3.getInstance().addChange(this.change), this.xfo = e5, this.stage = 1, this.radius = 0;
          }
          createMove(e5) {
            this.radius = e5.distanceTo(this.xfo.tr), this.change.update({radius: this.radius}), this.appData.renderer.forceRender();
          }
          createRelease(e5) {
            this.radius == 0 && a3.getInstance().cancel(), this.change = null, this.stage = 0, this.emit("actionFinished");
          }
        }, e4.CreateConeChange = te3, e4.CreateConeTool = class extends Y3 {
          constructor(e5) {
            super(e5);
          }
          createStart(e5) {
            this.xfo = e5, this.invXfo = e5.inverse(), this.change = new te3(this.parentItem, e5, this.colorParam.getValue()), this.change.geomItem.setSelectable(false), a3.getInstance().addChange(this.change), this.stage = 1, this._radius = 0, this._height = 0;
          }
          createMove(e5) {
            if (this.stage == 1) {
              const t5 = e5.subtract(this.xfo.tr);
              this._radius = t5.length(), this.change.update({radius: this._radius});
            } else
              this._height = this.invXfo.transformVec3(e5).y, this.change.update({height: this._height});
          }
          createRelease(e5) {
            if (this._radius == 0 && (a3.getInstance().cancel(), this.stage = 0, this.emit("actionFinished")), this.stage == 1) {
              this.stage = 2;
              const n4 = new t4.Quat();
              n4.setFromAxisAndAngle(new t4.Vec3(1, 0, 0), 0.5 * Math.PI), this.constructionPlane.ori = this.constructionPlane.ori.multiply(n4), this.constructionPlane.tr = e5, this.invXfo = this.constructionPlane.inverse();
            } else
              this.stage == 2 && (this.stage = 0, this.change.geomItem.setSelectable(true), this.emit("actionFinished"));
          }
        }, e4.CreateCuboidChange = ae3, e4.CreateCuboidTool = class extends Y3 {
          constructor(e5) {
            super(e5);
          }
          createStart(e5) {
            this.change = new ae3(this.parentItem, e5, this.colorParam.getValue()), this.change.geomItem.setSelectable(false), a3.getInstance().addChange(this.change), this.xfo = e5, this.invXfo = e5.inverse(), this.stage = 1, this._height = 0;
          }
          createMove(e5) {
            if (this.stage == 1) {
              const t5 = this.invXfo.transformVec3(e5);
              this.change.update({baseSize: [Math.abs(t5.x), Math.abs(t5.y)], tr: this.xfo.tr.add(t5.scale(0.5))});
            } else {
              const t5 = this.invXfo.transformVec3(e5);
              this.change.update({height: t5.y});
            }
          }
          createRelease(e5) {
            if (this.stage == 1) {
              this.stage = 2, this.pt1 = e5;
              const n4 = new t4.Quat();
              n4.setFromAxisAndAngle(new t4.Vec3(1, 0, 0), 0.5 * Math.PI), this.constructionPlane.ori = this.constructionPlane.ori.multiply(n4), this.constructionPlane.tr = e5, this.invXfo = this.constructionPlane.inverse();
            } else
              this.stage == 2 && (this.stage = 0, this.change.geomItem.setSelectable(true), this.emit("actionFinished"));
          }
        }, e4.CreateFreehandLineChange = se3, e4.CreateFreehandLineTool = class extends ee3 {
          constructor(e5) {
            super(e5), this.mp = new t4.BooleanParameter("Modulate Thickness By Stroke Speed", false), this.addParameter(this.mp);
          }
          createStart(e5) {
            const t5 = this.colorParam.getValue(), n4 = this.lineThickness.getValue();
            this.change = new se3(this.parentItem, e5, t5, n4), a3.getInstance().addChange(this.change), this.xfo = e5, this.invXfo = e5.inverse(), this.stage = 1, this.prevP = e5.tr, this.length = 0;
          }
          createMove(e5) {
            const t5 = this.invXfo.transformVec3(e5), n4 = t5.subtract(this.prevP).length();
            this.change.update({point: t5}), this.length += n4, this.prevP = t5;
          }
          createRelease(e5) {
            this.length == 0 && a3.getInstance().cancel(), this.stage = 0, this.emit("actionFinished");
          }
        }, e4.CreateLineChange = Q3, e4.CreateLineTool = ee3, e4.CreateRectChange = ie3, e4.CreateRectTool = class extends Y3 {
          constructor(e5) {
            super(e5);
          }
          createStart(e5) {
            this.change = new ie3(this.parentItem, e5), this.change.geomItem.setSelectable(false), a3.getInstance().addChange(this.change), this.xfo = e5, this.invXfo = e5.inverse(), this.stage = 1, this._size = 0;
          }
          createMove(e5) {
            if (this.stage == 1) {
              const t5 = this.invXfo.transformVec3(e5);
              this._size = Math.abs(t5.x), Math.abs(t5.y), this.change.update({baseSize: [Math.abs(t5.x), Math.abs(t5.y)], tr: this.xfo.tr.add(t5.scale(0.5))});
            } else {
              const t5 = this.invXfo.transformVec3(e5);
              this.change.update({height: t5.y});
            }
          }
          createRelease(e5) {
            this._size == 0 && a3.getInstance().cancel(), this.change.geomItem.setSelectable(true), this.stage = 0, this.emit("actionFinished");
          }
        }, e4.CreateSphereChange = re3, e4.CreateSphereTool = class extends Y3 {
          constructor(e5) {
            super(e5);
          }
          createStart(e5) {
            this.change = new re3(this.parentItem, e5, this.colorParam.getValue()), this.change.geomItem.setSelectable(false), a3.getInstance().addChange(this.change), this.xfo = e5, this.stage = 1, this.radius = 0;
          }
          createMove(e5) {
            this.radius = e5.distanceTo(this.xfo.tr), this.change.update({radius: this.radius});
          }
          createRelease(e5) {
            this.radius == 0 && a3.getInstance().cancel(), this.change.geomItem.setSelectable(true), this.stage = 0, this.emit("actionFinished");
          }
        }, e4.HandleMaterial = c3, e4.LinearMovementHandle = g3, e4.MeasureAngle = pe3, e4.MeasureAngleTool = class extends we3 {
          constructor(e5) {
            super(e5), this.highlightedItemAHitPos = null, this.geomConstraints = {SurfaceType: ["Plane", "Cylinder", "Cone"]}, this.numStages = 2;
          }
          snapToSurface(e5, n4, i4, s4, r4) {
            const a4 = new t4.Xfo();
            if (n4) {
              const o4 = n4.getParameter("SurfaceType").value;
              switch (o4) {
                case "Plane": {
                  const n5 = i4.subtract(e5.tr);
                  let o5 = e5.ori.getZaxis();
                  o5.dot(s4.dir) > 0 && (o5 = o5.negate());
                  const l4 = i4;
                  if (r4) {
                    const e6 = o5, t5 = r4.ori.getZaxis(), n6 = r4.tr.subtract(i4), s5 = e6.cross(t5).normalize();
                    l4.addInPlace(s5.scale(n6.dot(s5)));
                  }
                  a4.ori.setFromDirectionAndUpvector(o5, new t4.Vec3(o5.z, o5.x, o5.y)), a4.tr = l4.subtract(o5.scale(n5.dot(o5)));
                  break;
                }
                case "Cone": {
                  const o5 = n4.getParameter("SemiAngle").getValue(), l4 = n4.getParameter("StartRadius").getValue() * e5.sc.x, h4 = e5.ori.getZaxis(), c4 = i4.subtract(e5.tr).dot(h4), d4 = l4 + Math.tan(o5) * c4;
                  let u4 = i4;
                  if (r4) {
                    const t5 = r4.tr.subtract(e5.tr);
                    t5.subtractInPlace(h4.scale(t5.dot(h4))), u4 = e5.tr.add(t5.normalize().scale(d4)), u4.addInPlace(h4.scale(c4));
                  }
                  const f4 = u4.subtract(e5.tr);
                  a4.ori.setFromDirectionAndUpvector(h4, f4);
                  const m4 = new t4.Quat();
                  if (m4.setFromAxisAndAngle(new t4.Vec3(1, 0, 0), 0.5 * Math.PI - o5), a4.ori.multiplyInPlace(m4), a4.ori.getZaxis().dot(s4.dir) > 0) {
                    const e6 = new t4.Quat();
                    e6.setFromAxisAndAngle(new t4.Vec3(0, 1, 0), Math.PI), a4.ori.multiplyInPlace(e6);
                  }
                  a4.tr = u4;
                  break;
                }
                case "Cylinder": {
                  const o5 = n4.getParameter("Radius").getValue() * e5.sc.x, l4 = e5.ori.getZaxis(), h4 = i4.subtract(e5.tr).dot(l4), c4 = e5.tr.add(l4.scale(h4)), d4 = i4.subtract(c4), u4 = d4.length();
                  let f4 = c4.add(d4.scale(o5 / u4));
                  if (r4) {
                    const t5 = r4.tr.subtract(e5.tr);
                    t5.subtractInPlace(l4.scale(t5.dot(l4))), f4 = e5.tr.add(t5.normalize().scale(o5)), f4.addInPlace(l4.scale(h4));
                  }
                  const m4 = f4.subtract(c4);
                  a4.ori.setFromDirectionAndUpvector(l4, m4);
                  const g4 = new t4.Quat();
                  if (g4.setFromAxisAndAngle(new t4.Vec3(1, 0, 0), 0.5 * Math.PI), a4.ori.multiplyInPlace(g4), a4.ori.getZaxis().dot(s4.dir) > 0) {
                    const e6 = new t4.Quat();
                    e6.setFromAxisAndAngle(new t4.Vec3(0, 1, 0), Math.PI), a4.ori.multiplyInPlace(e6);
                  }
                  a4.tr = f4;
                  break;
                }
                default:
                  console.log("Unhandled Surface Type: ", o4);
              }
            }
            return a4;
          }
          onPointerDown(e5) {
            if (!((e5 instanceof t4.ZeaMouseEvent || e5 instanceof t4.ZeaTouchEvent) && e5.altKey || e5 instanceof t4.ZeaMouseEvent && e5.button !== 0) && e5.intersectionData) {
              if (this.stage == 0) {
                if (this.highlightedItemA) {
                  const t5 = this.colorParam.getValue(), n4 = new pe3("MeasureAngle", t5);
                  this.appData.scene.getRoot().addChild(n4);
                  const i4 = e5.pointerRay, s4 = i4.start.add(i4.dir.scale(e5.intersectionData.dist)), r4 = this.getGeomXfo(this.highlightedItemA, this.highlightedItemA_componentId), a4 = this.snapToSurface(r4, this.highlightedItemA_params, s4, i4);
                  n4.setXfoA(a4), this.measurement = n4, this.hitPosA = s4, this.stage++, e5.stopPropagation();
                }
              } else if (this.stage == 1 && this.highlightedItemB) {
                const t5 = e5.pointerRay, n4 = t5.start.add(t5.dir.scale(e5.intersectionData.dist)), i4 = this.getGeomXfo(this.highlightedItemB, this.highlightedItemB_componentId), s4 = this.snapToSurface(i4, this.highlightedItemB_params, n4, t5), r4 = this.getGeomXfo(this.highlightedItemA, this.highlightedItemA_componentId), o4 = this.snapToSurface(r4, this.highlightedItemA_params, this.hitPosA, t5, s4), l4 = this.measurement;
                l4.setXfoA(o4), l4.setXfoB(s4);
                const h4 = new ve3(l4);
                a3.getInstance().addChange(h4), this.highlightedItemA && (this.highlightedItemA.removeHighlight(this.highlightedItemA_highlightKey, true), this.highlightedItemA = null), this.highlightedItemB && (this.highlightedItemB.removeHighlight(this.highlightedItemB_highlightKey, true), this.highlightedItemB = null), this.stage = 0, e5.stopPropagation();
              }
            }
          }
        }, e4.MeasureCenterDistancesTool = class extends we3 {
          constructor(e5) {
            super(e5), this.geomConstraints = {CurveType: ["Circle"], SurfaceType: ["Cylinder"]}, this.numStages = 2;
          }
          snapToParametricCenter(e5, t5, n4) {
            if (t5.hasParameter("CurveType")) {
              const i4 = t5.getParameter("CurveType").value;
              if (i4 === "Circle") {
                const t6 = n4.subtract(e5.tr), i5 = e5.ori.getZaxis();
                return e5.tr.add(i5.scale(t6.dot(i5)));
              }
              console.log("Unhandled Edge Type: ", i4);
            } else if (t5.hasParameter("SurfaceType")) {
              const i4 = t5.getParameter("SurfaceType").value;
              switch (i4) {
                case "Cylinder":
                case "Cone": {
                  const t6 = n4.subtract(e5.tr), i5 = e5.ori.getZaxis();
                  return e5.tr.add(i5.scale(t6.dot(i5)));
                }
                default:
                  console.log("Unhandled Surface Type: ", i4);
              }
            }
          }
          onPointerDown(e5) {
            if (!((e5 instanceof t4.ZeaMouseEvent || e5 instanceof t4.ZeaTouchEvent) && e5.altKey || e5 instanceof t4.ZeaMouseEvent && e5.button !== 0) && e5.intersectionData) {
              if (this.stage == 0) {
                if (this.highlightedItemA) {
                  const n4 = i3(e5);
                  let s4;
                  if (e5.intersectionData)
                    s4 = n4.start.add(n4.dir.scale(e5.intersectionData.dist));
                  else {
                    const e6 = new t4.Ray(new t4.Vec3(), new t4.Vec3(0, 0, 1)), i4 = n4.intersectRayPlane(e6);
                    s4 = n4.start.add(n4.dir.scale(i4));
                  }
                  const r4 = this.getGeomXfo(this.highlightedItemA, this.highlightedItemA_componentId), o4 = this.snapToParametricCenter(r4, this.highlightedItemA_params, s4), l4 = this.colorParam.value, h4 = new fe3("Measure Distance", l4, this.appData.sceneUnits);
                  h4.setStartMarkerPos(o4), h4.setEndMarkerPos(o4), this.appData.scene.getRoot().addChild(h4), this.measurementChange = new ve3(h4), a3.getInstance().addChange(this.measurementChange), this.measurement = h4, this.stage++, e5.stopPropagation();
                }
              } else if (this.stage == 1 && this.highlightedItemB) {
                const t5 = i3(e5), n4 = t5.start.add(t5.dir.scale(e5.intersectionData.dist)), s4 = this.getGeomXfo(this.highlightedItemA, this.highlightedItemA_componentId), r4 = this.getGeomXfo(this.highlightedItemB, this.highlightedItemB_componentId);
                let a4 = this.snapToParametricCenter(r4, this.highlightedItemB_params, n4);
                const o4 = this.snapToParametricCenter(s4, this.highlightedItemA_params, a4);
                a4 = this.snapToParametricCenter(r4, this.highlightedItemB_params, o4);
                const l4 = this.measurement;
                l4.setStartMarkerPos(o4), l4.setEndMarkerPos(a4), this.highlightedItemA && (this.highlightedItemA.removeHighlight(this.highlightedItemA_highlightKey, true), this.highlightedItemA = null), this.highlightedItemB && (this.highlightedItemB.removeHighlight(this.highlightedItemB_highlightKey, true), this.highlightedItemB = null), this.stage = 0, this.measurement = null, e5.stopPropagation();
              }
            }
          }
        }, e4.MeasureDistance = fe3, e4.MeasureDistanceTool = class extends we3 {
          constructor(e5) {
            super(e5), this.geomConstraints = {CurveType: ["Line", "Circle"], SurfaceType: ["Plane", "Cylinder"]}, this.numStages = 2;
          }
          snapToParametricEdge(e5, t5, n4) {
            if (t5.hasParameter("CurveType")) {
              const i4 = t5.getParameter("CurveType").getValue();
              switch (i4) {
                case "Line": {
                  const t6 = n4.subtract(e5.tr), i5 = e5.ori.getXaxis();
                  return e5.tr.add(i5.scale(t6.dot(i5)));
                }
                case "Circle": {
                  const i5 = n4.subtract(e5.tr), s4 = t5.getParameter("Radius").getValue() * e5.sc.x, r4 = e5.ori.getZaxis();
                  i5.subtractInPlace(r4.scale(i5.dot(r4)));
                  const a4 = i5.length();
                  return e5.tr.add(i5.scale(s4 / a4));
                }
                default:
                  console.log("Unhandled Edge Type: ", i4);
              }
            } else if (t5.hasParameter("SurfaceType")) {
              const i4 = t5.getParameter("SurfaceType").getValue();
              switch (i4) {
                case "Plane": {
                  const t6 = n4.subtract(e5.tr), i5 = e5.ori.getZaxis();
                  return n4.subtract(i5.scale(t6.dot(i5)));
                }
                case "Cylinder": {
                  const i5 = n4.subtract(e5.tr), s4 = e5.ori.getZaxis(), r4 = e5.tr.add(s4.scale(i5.dot(s4))), a4 = t5.getParameter("Radius").getValue() * e5.sc.x, o4 = n4.subtract(r4), l4 = o4.length();
                  return r4.add(o4.scale(a4 / l4));
                }
                default:
                  console.log("Unhandled Surface Type: ", i4);
              }
            }
          }
          onPointerDown(e5) {
            if (!((e5 instanceof t4.ZeaMouseEvent || e5 instanceof t4.ZeaTouchEvent) && e5.altKey || e5 instanceof t4.ZeaMouseEvent && e5.button !== 0) && e5.intersectionData) {
              if (this.stage == 0) {
                if (this.highlightedItemA) {
                  const n4 = i3(e5);
                  let s4;
                  if (e5.intersectionData)
                    s4 = n4.start.add(n4.dir.scale(e5.intersectionData.dist));
                  else {
                    const e6 = new t4.Ray(new t4.Vec3(), new t4.Vec3(0, 0, 1)), i4 = n4.intersectRayPlane(e6);
                    s4 = n4.start.add(n4.dir.scale(i4));
                  }
                  const r4 = this.getGeomXfo(this.highlightedItemA, this.highlightedItemA_componentId), o4 = this.snapToParametricEdge(r4, this.highlightedItemA_params, s4), l4 = this.colorParam.getValue(), h4 = new fe3("Measure Distance", l4, this.appData.sceneUnits);
                  h4.setStartMarkerPos(o4), h4.setEndMarkerPos(o4), this.appData.scene.getRoot().addChild(h4), this.measurementChange = new ve3(h4), a3.getInstance().addChange(this.measurementChange), this.measurement = h4, this.stage++, e5.stopPropagation();
                }
              } else if (this.stage == 1 && this.highlightedItemB) {
                const t5 = i3(e5), n4 = t5.start.add(t5.dir.scale(e5.intersectionData.dist)), s4 = this.getGeomXfo(this.highlightedItemA, this.highlightedItemA_componentId), r4 = this.getGeomXfo(this.highlightedItemB, this.highlightedItemB_componentId), a4 = this.snapToParametricEdge(s4, this.highlightedItemA_params, n4), o4 = this.snapToParametricEdge(r4, this.highlightedItemB_params, n4), l4 = this.measurement;
                l4.setStartMarkerPos(a4), l4.setEndMarkerPos(o4), this.highlightedItemA && (this.highlightedItemA.removeHighlight(this.highlightedItemA_highlightKey, true), this.highlightedItemA = null), this.highlightedItemB && (this.highlightedItemB.removeHighlight(this.highlightedItemB_highlightKey, true), this.highlightedItemB = null), this.stage = 0, this.measurement = null, e5.stopPropagation();
              }
            }
          }
        }, e4.MeasureRadiusTool = class extends we3 {
          constructor(e5) {
            super(e5), this.geomConstraints = {CurveType: ["Circle"], SurfaceType: ["Cylinder"]};
          }
          onPointerDown(e5) {
            if (!((e5 instanceof t4.ZeaMouseEvent || e5 instanceof t4.ZeaTouchEvent) && e5.altKey || e5 instanceof t4.ZeaMouseEvent && e5.button !== 0) && e5.intersectionData && this.highlightedItemA) {
              const n4 = i3(e5);
              let s4;
              if (e5.intersectionData)
                s4 = n4.start.add(n4.dir.scale(e5.intersectionData.dist));
              else {
                const e6 = new t4.Ray(new t4.Vec3(), new t4.Vec3(0, 0, 1)), i4 = n4.intersectRayPlane(e6);
                s4 = n4.start.add(n4.dir.scale(i4));
              }
              const r4 = this.getGeomXfo(this.highlightedItemA, this.highlightedItemA_componentId);
              let o4, l4;
              const h4 = this.highlightedItemA_params;
              if (h4.hasParameter("CurveType")) {
                const e6 = h4.getParameter("CurveType").getValue();
                switch (e6) {
                  case "Circle": {
                    const e7 = s4.subtract(r4.tr), t5 = h4.getParameter("Radius").getValue() * r4.sc.x, n5 = r4.ori.getZaxis();
                    e7.subtractInPlace(n5.scale(e7.dot(n5)));
                    const i4 = e7.length();
                    o4 = r4.tr, l4 = o4.add(e7.scale(t5 / i4));
                    break;
                  }
                  default:
                    console.log("Unhandled Edge Type: ", e6);
                }
              } else if (h4.hasParameter("SurfaceType")) {
                const e6 = h4.getParameter("SurfaceType").getValue();
                switch (e6) {
                  case "Cylinder": {
                    const e7 = s4.subtract(r4.tr), t5 = r4.ori.getZaxis();
                    o4 = r4.tr.add(t5.scale(e7.dot(t5)));
                    const n5 = h4.getParameter("Radius").getValue() * r4.sc.x, i4 = s4.subtract(o4), a4 = i4.length();
                    l4 = o4.add(i4.scale(n5 / a4));
                    break;
                  }
                  default:
                    console.log("Unhandled Surface Type: ", e6);
                }
              }
              const c4 = this.colorParam.getValue(), d4 = new fe3("MeasureRadius", c4, this.appData.sceneUnits);
              d4.setStartMarkerPos(o4), d4.setEndMarkerPos(l4), d4.setGeomBuffersVisibility(false), this.appData.scene.getRoot().addChild(d4);
              const u4 = new ve3(d4);
              a3.getInstance().addChange(u4), this.highlightedItemA && this.highlightedItemA.removeHighlight(this.highlightedItemA_highlightKey, true), e5.stopPropagation();
            }
          }
        }, e4.MeasurementChange = ve3, e4.ParameterValueChange = h3, e4.PlanarMovementHandle = w3, e4.ScreenSpaceMovementHandle = class extends s3 {
          constructor(e5) {
            super(e5);
          }
          setSelectionGroup(e5) {
            this.selectionGroup = e5;
          }
          setTargetParam(e5, t5 = true) {
            if (this.param = e5, t5) {
              const t6 = () => {
                this.globalXfoParam.value = e5.getValue();
              };
              t6(), e5.on("valueChanged", t6);
            }
          }
          getTargetParam() {
            return this.param ? this.param : this.globalXfoParam;
          }
          handlePointerDown(e5) {
            this.gizmoRay = new t4.Ray();
            const n4 = i3(e5), s4 = e5.viewport.getCamera().globalXfoParam.value;
            this.gizmoRay.dir = s4.ori.getZaxis();
            const r4 = this.getTargetParam().value;
            this.gizmoRay.start = r4.tr;
            const a4 = n4.intersectRayPlane(this.gizmoRay);
            this.grabPos = n4.pointAtDist(a4), this.onDragStart(e5);
          }
          handlePointerMove(e5) {
            const t5 = i3(e5), n4 = t5.intersectRayPlane(this.gizmoRay);
            this.holdPos = t5.pointAtDist(n4), this.onDrag(e5);
          }
          handlePointerUp(e5) {
            const t5 = i3(e5);
            if (t5) {
              const e6 = t5.intersectRayPlane(this.gizmoRay);
              this.releasePos = t5.pointAtDist(e6);
            }
            this.onDragEnd(e5);
          }
          onDragStart(e5) {
            this.grabPos = this.grabPos;
            const t5 = this.getTargetParam();
            if (this.baseXfo = t5.value, this.selectionGroup) {
              const e6 = this.selectionGroup.getItems();
              this.change = new m3(Array.from(e6), this.globalXfoParam.value), a3.getInstance().addChange(this.change);
            } else
              this.change = new h3(t5), a3.getInstance().addChange(this.change);
          }
          onDrag(e5) {
            const n4 = this.holdPos.subtract(this.grabPos);
            if (this.selectionGroup) {
              const e6 = this.change, i4 = new t4.Xfo(n4);
              e6.setDeltaXfo(i4);
            } else {
              const e6 = this.baseXfo.clone();
              e6.tr.addInPlace(n4), this.change.update({value: e6});
            }
          }
          onDragEnd(e5) {
            this.change = null;
          }
        }, e4.SelectionChange = P3, e4.SelectionManager = k3, e4.SelectionTool = E3, e4.SelectionVisibilityChange = C3, e4.SelectionXfoChange = m3, e4.SliderHandle = le3, e4.ToolManager = oe3, e4.TreeItemAddChange = T3, e4.TreeItemMoveChange = A3, e4.TreeItemsRemoveChange = $3, e4.UndoRedoManager = a3, e4.VRHoldObjectsTool = K3, e4.VRUITool = Z3, e4.XfoHandle = _3, Object.defineProperty(e4, "__esModule", {value: true});
      }(t3, He3);
    });
    function Ze3(e3) {
      let t3, n3, g3, p3;
      const v3 = e3[3].default, w3 = d2(v3, e3, e3[2], null);
      return {c() {
        t3 = N2("div"), w3 && w3.c(), D2(t3, "class", "Menu absolute border border-gray-500 bg-background flex-col rounded p-2 shadow w-max"), J2(t3, "flex", e3[0]), J2(t3, "hidden", e3[1]);
      }, m(i3, s3) {
        I2(i3, t3, s3), w3 && w3.m(t3, null), n3 = true, g3 || (p3 = C2(t3, "mouseenter", e3[4]), g3 = true);
      }, p(e4, [i3]) {
        w3 && w3.p && (!n3 || 4 & i3) && g2(w3, v3, e4, e4[2], n3 ? m2(v3, e4[2], i3, null) : $2(e4[2]), null), 1 & i3 && J2(t3, "flex", e4[0]), 2 & i3 && J2(t3, "hidden", e4[1]);
      }, i(e4) {
        n3 || (St(w3, e4), n3 = true);
      }, o(e4) {
        Lt(w3, e4), n3 = false;
      }, d(e4) {
        e4 && S2(t3), w3 && w3.d(e4), g3 = false, p3();
      }};
    }
    function Je3(e3, t3, n3) {
      let i3, {$$slots: s3 = {}, $$scope: r3} = t3, {isOpen: a3 = false} = t3;
      return e3.$$set = (e4) => {
        "isOpen" in e4 && n3(0, a3 = e4.isOpen), "$$scope" in e4 && n3(2, r3 = e4.$$scope);
      }, e3.$$.update = () => {
        1 & e3.$$.dirty && n3(1, i3 = !a3);
      }, [a3, i3, r3, s3, function(t4) {
        lt.call(this, e3, t4);
      }];
    }
    var Ke3 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Je3, Ze3, a2, {isOpen: 0});
      }
    };
    function We3(e3) {
      let t3, n3, i3 = e3[6].length > 1 && function(e4) {
        let t4, n4, i4, a3 = e4[6].includes("shift"), l3 = e4[6].includes("ctrl"), h3 = e4[6].includes("alt"), c3 = a3 && function(e5) {
          let t5;
          return {c() {
            t5 = N2("span"), t5.textContent = "\u21E7", D2(t5, "class", "text-xs text-gray-400");
          }, m(e6, n5) {
            I2(e6, t5, n5);
          }, d(e6) {
            e6 && S2(t5);
          }};
        }(), d3 = l3 && function(e5) {
          let t5;
          return {c() {
            t5 = N2("span"), t5.textContent = "^", D2(t5, "class", "text-xs text-gray-400");
          }, m(e6, n5) {
            I2(e6, t5, n5);
          }, d(e6) {
            e6 && S2(t5);
          }};
        }(), u3 = h3 && function(e5) {
          let t5;
          return {c() {
            t5 = N2("span"), t5.textContent = "\u2387", D2(t5, "class", "text-xs text-gray-400");
          }, m(e6, n5) {
            I2(e6, t5, n5);
          }, d(e6) {
            e6 && S2(t5);
          }};
        }();
        return {c() {
          c3 && c3.c(), t4 = A2(), d3 && d3.c(), n4 = A2(), u3 && u3.c(), i4 = F2();
        }, m(e5, s3) {
          c3 && c3.m(e5, s3), I2(e5, t4, s3), d3 && d3.m(e5, s3), I2(e5, n4, s3), u3 && u3.m(e5, s3), I2(e5, i4, s3);
        }, p: t2, d(e5) {
          c3 && c3.d(e5), e5 && S2(t4), d3 && d3.d(e5), e5 && S2(n4), u3 && u3.d(e5), e5 && S2(i4);
        }};
      }(e3);
      return {c() {
        i3 && i3.c(), t3 = A2(), n3 = N2("span"), n3.textContent = `${e3[6].slice(-1)[0].toUpperCase()}`, D2(n3, "class", "text-xs text-gray-400 mr-1");
      }, m(e4, s3) {
        i3 && i3.m(e4, s3), I2(e4, t3, s3), I2(e4, n3, s3);
      }, p(e4, t4) {
        e4[6].length > 1 && i3.p(e4, t4);
      }, d(e4) {
        i3 && i3.d(e4), e4 && S2(t3), e4 && S2(n3);
      }};
    }
    function Ye3(e3) {
      let t3, n3;
      return {c() {
        t3 = N2("span"), n3 = T2(e3[2]), D2(t3, "class", "material-icons md-18 pointer-events-none");
      }, m(e4, i3) {
        I2(e4, t3, i3), E2(t3, n3);
      }, p(e4, t4) {
        4 & t4 && K2(n3, e4[2]);
      }, d(e4) {
        e4 && S2(t3);
      }};
    }
    function qe3(e3) {
      let t3, n3, i3, a3, h3, c3, d3, u3, f3, g3, I3, x3, P3 = (e3[1] || "block") + "", C3 = e3[4] && We3(e3), k3 = e3[2] && Ye3(e3);
      return {c() {
        t3 = N2("button"), n3 = N2("span"), i3 = T2(P3), h3 = A2(), c3 = N2("span"), d3 = T2(e3[3]), u3 = A2(), C3 && C3.c(), f3 = A2(), k3 && k3.c(), D2(n3, "class", a3 = "material-icons md-18 pointer-events-none ml-1 " + (e3[1] || "text-transparent")), D2(c3, "class", "flex-1 text-left mr-5 ml-3 pointer-events-none"), D2(t3, "class", g3 = "MenuItem cursor-default flex items-center w-full rounded hover:bg-gray-700 justify-between " + (e3[0] && "text-gray-500")), t3.disabled = e3[0];
      }, m(s3, r3) {
        I2(s3, t3, r3), E2(t3, n3), E2(n3, i3), E2(t3, h3), E2(t3, c3), E2(c3, d3), E2(t3, u3), C3 && C3.m(t3, null), E2(t3, f3), k3 && k3.m(t3, null), e3[10](t3), I3 || (x3 = [C2(t3, "click", e3[7]), C2(t3, "mouseenter", e3[8]), C2(t3, "mouseleave", e3[9])], I3 = true);
      }, p(e4, [s3]) {
        2 & s3 && P3 !== (P3 = (e4[1] || "block") + "") && K2(i3, P3), 2 & s3 && a3 !== (a3 = "material-icons md-18 pointer-events-none ml-1 " + (e4[1] || "text-transparent")) && D2(n3, "class", a3), 8 & s3 && K2(d3, e4[3]), e4[4] ? C3 ? C3.p(e4, s3) : (C3 = We3(e4), C3.c(), C3.m(t3, f3)) : C3 && (C3.d(1), C3 = null), e4[2] ? k3 ? k3.p(e4, s3) : (k3 = Ye3(e4), k3.c(), k3.m(t3, null)) : k3 && (k3.d(1), k3 = null), 1 & s3 && g3 !== (g3 = "MenuItem cursor-default flex items-center w-full rounded hover:bg-gray-700 justify-between " + (e4[0] && "text-gray-500")) && D2(t3, "class", g3), 1 & s3 && (t3.disabled = e4[0]);
      }, i: t2, o: t2, d(n4) {
        n4 && S2(t3), C3 && C3.d(), k3 && k3.d(), e3[10](null), I3 = false, s2(x3);
      }};
    }
    function Qe3(e3, t3, n3) {
      let i3, {disabled: s3 = false} = t3, {iconLeft: r3 = null} = t3, {iconRight: a3 = null} = t3, {label: o3} = t3, {shortcut: l3 = ""} = t3;
      const h3 = l3.toLowerCase(), c3 = h3.split("+"), d3 = (e4) => {
        if (e4.target instanceof HTMLInputElement)
          return;
        const t4 = [];
        e4.shiftKey && t4.push("shift"), e4.altKey && t4.push("alt"), e4.metaKey && t4.push("ctrl"), e4.ctrlKey && t4.push("ctrl"), e4.key != "Alt" && e4.key != "Control" && e4.key != "Ctrl" && e4.key != "Shift" && t4.push(e4.key);
        t4.join("+").toLowerCase() === h3 && (e4.preventDefault(), i3.dispatchEvent(new MouseEvent("click")));
      };
      return ot(() => (l3 && window.addEventListener("keydown", d3), () => {
        window.removeEventListener("keydown", d3);
      })), e3.$$set = (e4) => {
        "disabled" in e4 && n3(0, s3 = e4.disabled), "iconLeft" in e4 && n3(1, r3 = e4.iconLeft), "iconRight" in e4 && n3(2, a3 = e4.iconRight), "label" in e4 && n3(3, o3 = e4.label), "shortcut" in e4 && n3(4, l3 = e4.shortcut);
      }, [s3, r3, a3, o3, l3, i3, c3, function(t4) {
        lt.call(this, e3, t4);
      }, function(t4) {
        lt.call(this, e3, t4);
      }, function(t4) {
        lt.call(this, e3, t4);
      }, function(e4) {
        ft[e4 ? "unshift" : "push"](() => {
          i3 = e4, n3(5, i3);
        });
      }];
    }
    var et3 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Qe3, qe3, a2, {disabled: 0, iconLeft: 1, iconRight: 2, label: 3, shortcut: 4});
      }
    };
    function tt3(e3) {
      let t3, n3;
      return t3 = new et3({props: {disabled: e3[1], iconLeft: e3[0] ? "check" : "", label: e3[2], shortcut: e3[3]}}), t3.$on("click", e3[4]), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p(e4, [n4]) {
        const i3 = {};
        2 & n4 && (i3.disabled = e4[1]), 1 & n4 && (i3.iconLeft = e4[0] ? "check" : ""), 4 & n4 && (i3.label = e4[2]), 8 & n4 && (i3.shortcut = e4[3]), t3.$set(i3);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function nt2(e3, t3, n3) {
      let {disabled: i3 = false} = t3, {label: s3} = t3, {shortcut: r3 = ""} = t3, {checked: a3 = false} = t3;
      const o3 = it2();
      return e3.$$set = (e4) => {
        "disabled" in e4 && n3(1, i3 = e4.disabled), "label" in e4 && n3(2, s3 = e4.label), "shortcut" in e4 && n3(3, r3 = e4.shortcut), "checked" in e4 && n3(0, a3 = e4.checked);
      }, [a3, i3, s3, r3, () => {
        n3(0, a3 = !a3), o3("change");
      }];
    }
    var it3 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, nt2, tt3, a2, {disabled: 1, label: 2, shortcut: 3, checked: 0});
      }
    };
    function st2(e3) {
      let t3, n3;
      const a3 = e3[1].default, l3 = d2(a3, e3, e3[0], null);
      return {c() {
        t3 = N2("div"), l3 && l3.c(), D2(t3, "class", "MenuBar flex overflow-x-auto");
      }, m(e4, i3) {
        I2(e4, t3, i3), l3 && l3.m(t3, null), n3 = true;
      }, p(e4, [t4]) {
        l3 && l3.p && (!n3 || 1 & t4) && g2(l3, a3, e4, e4[0], n3 ? m2(a3, e4[0], t4, null) : $2(e4[0]), null);
      }, i(e4) {
        n3 || (St(l3, e4), n3 = true);
      }, o(e4) {
        Lt(l3, e4), n3 = false;
      }, d(e4) {
        e4 && S2(t3), l3 && l3.d(e4);
      }};
    }
    function rt2(e3, t3, n3) {
      let {$$slots: i3 = {}, $$scope: s3} = t3;
      return e3.$$set = (e4) => {
        "$$scope" in e4 && n3(0, s3 = e4.$$scope);
      }, [s3, i3];
    }
    var at2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, rt2, st2, a2, {});
      }
    };
    new URLSearchParams(window.location.search).has("embedded");
    var ot2 = se2({currentMenuBarItem: null, shouldShowDrawer: false, shouldShowParameterOwnerWidget: false, asmExplodeEnabled: false});
    var lt2 = (e3) => ({isOpen: 8 & e3});
    var ht2 = (e3) => ({isOpen: e3[3]});
    function ct2(e3) {
      let t3, n3, a3, g3, _3, I3, x3;
      const P3 = e3[8].default, C3 = d2(P3, e3, e3[7], ht2);
      return {c() {
        t3 = N2("div"), n3 = N2("button"), a3 = T2(e3[0]), g3 = A2(), C3 && C3.c(), D2(n3, "class", "cursor-default h-full px-3 hover:bg-gray-700 transition-colors rounded"), D2(t3, "class", "MenuBarItem");
      }, m(i3, s3) {
        I2(i3, t3, s3), E2(t3, n3), E2(n3, a3), e3[9](n3), E2(t3, g3), C3 && C3.m(t3, null), e3[10](t3), _3 = true, I3 || (x3 = [C2(n3, "click", e3[4]), C2(n3, "mouseenter", e3[5])], I3 = true);
      }, p(e4, [t4]) {
        (!_3 || 1 & t4) && K2(a3, e4[0]), C3 && C3.p && (!_3 || 136 & t4) && g2(C3, P3, e4, e4[7], _3 ? m2(P3, e4[7], t4, lt2) : $2(e4[7]), ht2);
      }, i(e4) {
        _3 || (St(C3, e4), _3 = true);
      }, o(e4) {
        Lt(C3, e4), _3 = false;
      }, d(n4) {
        n4 && S2(t3), e3[9](null), C3 && C3.d(n4), e3[10](null), I3 = false, s2(x3);
      }};
    }
    var dt2 = () => {
      ot2.update((e3) => ({...e3, currentMenuBarItem: null}));
    };
    function ut2(e3, t3, n3) {
      let i3, s3;
      p2(e3, ot2, (e4) => n3(6, s3 = e4));
      let r3, a3, {$$slots: o3 = {}, $$scope: l3} = t3, {label: h3} = t3;
      return e3.$$set = (e4) => {
        "label" in e4 && n3(0, h3 = e4.label), "$$scope" in e4 && n3(7, l3 = e4.$$scope);
      }, e3.$$.update = () => {
        66 & e3.$$.dirty && n3(3, i3 = s3.currentMenuBarItem === a3);
      }, [h3, a3, r3, i3, () => {
        _2(ot2, s3.currentMenuBarItem = i3 ? null : a3, s3);
      }, () => {
        s3.currentMenuBarItem && (_2(ot2, s3.currentMenuBarItem = a3, s3), r3.focus());
      }, s3, l3, o3, function(e4) {
        ft[e4 ? "unshift" : "push"](() => {
          r3 = e4, n3(2, r3);
        });
      }, function(e4) {
        ft[e4 ? "unshift" : "push"](() => {
          a3 = e4, n3(1, a3);
        });
      }];
    }
    window.addEventListener("click", (e3) => {
      if (!e3.target.parentElement)
        return;
      const t3 = e3.target.parentElement.classList.contains("MenuItemDropDown"), n3 = e3.target.parentElement.classList.contains("MenuBarItem");
      t3 || n3 || dt2();
    }), window.addEventListener("keydown", (e3) => {
      e3.key === "Escape" && dt2();
    });
    var ft2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, ut2, ct2, a2, {label: 0});
      }
    };
    function mt2(e3, {delay: t3 = 0, duration: n3 = 400, easing: i3 = e2} = {}) {
      const s3 = +getComputedStyle(e3).opacity;
      return {delay: t3, duration: n3, easing: i3, css: (e4) => "opacity: " + e4 * s3};
    }
    function gt3(e3) {
      let t3, n3;
      const r3 = e3[2].default, a3 = d2(r3, e3, e3[1], null);
      return {c() {
        t3 = N2("div"), a3 && a3.c();
      }, m(i3, s3) {
        I2(i3, t3, s3), a3 && a3.m(t3, null), e3[3](t3), n3 = true;
      }, p(e4, [t4]) {
        a3 && a3.p && (!n3 || 2 & t4) && g2(a3, r3, e4, e4[1], n3 ? m2(r3, e4[1], t4, null) : $2(e4[1]), null);
      }, i(e4) {
        n3 || (St(a3, e4), n3 = true);
      }, o(e4) {
        Lt(a3, e4), n3 = false;
      }, d(n4) {
        n4 && S2(t3), a3 && a3.d(n4), e3[3](null);
      }};
    }
    function pt2(e3, t3, n3) {
      let i3, s3, {$$slots: r3 = {}, $$scope: a3} = t3;
      return ot(() => (s3 = document.createElement("div"), s3.setAttribute("data-svelte-dialog-portal", "true"), document.body.appendChild(s3), s3.appendChild(i3), () => {
        document.body.removeChild(s3);
      })), e3.$$set = (e4) => {
        "$$scope" in e4 && n3(1, a3 = e4.$$scope);
      }, [i3, a3, r3, function(e4) {
        ft[e4 ? "unshift" : "push"](() => {
          i3 = e4, n3(0, i3);
        });
      }];
    }
    var vt2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, pt2, gt3, a2, {});
      }
    };
    function wt2(e3) {
      let t3;
      const n3 = e3[2].default, s3 = d2(n3, e3, e3[1], null);
      return {c() {
        s3 && s3.c();
      }, m(e4, n4) {
        s3 && s3.m(e4, n4), t3 = true;
      }, p(e4, [i3]) {
        s3 && s3.p && (!t3 || 2 & i3) && g2(s3, n3, e4, e4[1], t3 ? m2(n3, e4[1], i3, null) : $2(e4[1]), null);
      }, i(e4) {
        t3 || (St(s3, e4), t3 = true);
      }, o(e4) {
        Lt(s3, e4), t3 = false;
      }, d(e4) {
        s3 && s3.d(e4);
      }};
    }
    function bt2(e3, t3, n3) {
      let {$$slots: i3 = {}, $$scope: s3} = t3, {enabled: r3} = t3, a3 = [];
      const o3 = (e4) => {
        a3.push({ariaHidden: e4.getAttribute("aria-hidden"), inert: e4.getAttribute("inert")}), e4.setAttribute("aria-hidden", "true"), e4.setAttribute("inert", "true");
      }, l3 = (e4, t4) => {
        const {ariaHidden: n4, inert: i4} = a3[t4];
        n4 ? e4.setAttribute("aria-hidden", n4) : e4.removeAttribute("aria-hidden"), i4 || e4.removeAttribute("inert");
      };
      return ot(() => {
        if (!r3)
          return;
        const e4 = document.querySelectorAll("body > *:not([data-svelte-dialog-portal])");
        return e4.forEach(o3), () => {
          e4.forEach(l3);
        };
      }), e3.$$set = (e4) => {
        "enabled" in e4 && n3(0, r3 = e4.enabled), "$$scope" in e4 && n3(1, s3 = e4.$$scope);
      }, [r3, s3, i3];
    }
    var _t2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, bt2, wt2, a2, {enabled: 0});
      }
    };
    function yt2(e3) {
      let t3, n3, r3, a3;
      const g3 = e3[5].default, p3 = d2(g3, e3, e3[4], null);
      return {c() {
        t3 = N2("div"), p3 && p3.c();
      }, m(i3, s3) {
        I2(i3, t3, s3), p3 && p3.m(t3, null), e3[6](t3), n3 = true, r3 || (a3 = C2(window, "keydown", e3[1]), r3 = true);
      }, p(e4, [t4]) {
        p3 && p3.p && (!n3 || 16 & t4) && g2(p3, g3, e4, e4[4], n3 ? m2(g3, e4[4], t4, null) : $2(e4[4]), null);
      }, i(e4) {
        n3 || (St(p3, e4), n3 = true);
      }, o(e4) {
        Lt(p3, e4), n3 = false;
      }, d(n4) {
        n4 && S2(t3), p3 && p3.d(n4), e3[6](null), r3 = false, a3();
      }};
    }
    function It3(e3, t3, n3) {
      let i3, s3, r3, a3, o3, {$$slots: l3 = {}, $$scope: h3} = t3, {initialFocusElement: c3} = t3, {returnFocusElement: d3} = t3;
      ot(() => {
        o3 = d3 || document.activeElement, s3 = [...i3.querySelectorAll("*")].filter((e4) => e4.tabIndex >= 0), r3 = s3[0], a3 = s3[s3.length - 1], $t().then(() => {
          if (c3)
            c3.focus();
          else {
            (i3.querySelector("[autofocus]") || r3 || i3.querySelector("[data-svelte-dialog-content]")).focus();
          }
        });
      }), st(() => {
        o3 && o3.focus();
      });
      return e3.$$set = (e4) => {
        "initialFocusElement" in e4 && n3(2, c3 = e4.initialFocusElement), "returnFocusElement" in e4 && n3(3, d3 = e4.returnFocusElement), "$$scope" in e4 && n3(4, h3 = e4.$$scope);
      }, [i3, (e4) => {
        e4.key === "Tab" && (s3.length === 0 && e4.preventDefault(), e4.shiftKey ? document.activeElement === r3 && (e4.preventDefault(), a3.focus()) : document.activeElement === a3 && (e4.preventDefault(), r3.focus()));
      }, c3, d3, h3, l3, function(e4) {
        ft[e4 ? "unshift" : "push"](() => {
          i3 = e4, n3(0, i3);
        });
      }];
    }
    var xt2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, It3, yt2, a2, {initialFocusElement: 2, returnFocusElement: 3});
      }
    };
    function Pt2(e3) {
      let t3;
      const n3 = e3[1].default, s3 = d2(n3, e3, e3[0], null);
      return {c() {
        s3 && s3.c();
      }, m(e4, n4) {
        s3 && s3.m(e4, n4), t3 = true;
      }, p(e4, [i3]) {
        s3 && s3.p && (!t3 || 1 & i3) && g2(s3, n3, e4, e4[0], t3 ? m2(n3, e4[0], i3, null) : $2(e4[0]), null);
      }, i(e4) {
        t3 || (St(s3, e4), t3 = true);
      }, o(e4) {
        Lt(s3, e4), t3 = false;
      }, d(e4) {
        s3 && s3.d(e4);
      }};
    }
    function Ct3(e3, t3, n3) {
      let {$$slots: i3 = {}, $$scope: s3} = t3;
      return ot(() => {
        const {body: e4, documentElement: t4} = document, n4 = window.innerWidth - t4.clientWidth, i4 = parseInt(window.getComputedStyle(e4).getPropertyValue("padding-right")) || 0;
        return t4.style.position = "relative", t4.style.overflow = "hidden", e4.style.position = "relative", e4.style.overflow = "hidden", e4.style.paddingRight = `${i4 + n4}px`, () => {
          t4.style.position = "", t4.style.overflow = "", e4.style.position = "", e4.style.overflow = "", e4.style.paddingRight = "";
        };
      }), e3.$$set = (e4) => {
        "$$scope" in e4 && n3(0, s3 = e4.$$scope);
      }, [s3, i3];
    }
    var kt2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Ct3, Pt2, a2, {});
      }
    };
    function Tt2(e3) {
      let t3, n3, r3, g3;
      const p3 = e3[7].default, v3 = d2(p3, e3, e3[8], null);
      let w3 = [e3[5], {"data-svelte-dialog-overlay": ""}], b3 = {};
      for (let e4 = 0; e4 < w3.length; e4 += 1)
        b3 = n2(b3, w3[e4]);
      return {c() {
        t3 = N2("div"), v3 && v3.c(), U2(t3, b3), J2(t3, "svelte-1c5s5dv", true);
      }, m(i3, s3) {
        I2(i3, t3, s3), v3 && v3.m(t3, null), n3 = true, r3 || (g3 = C2(t3, "click", B2(q2(e3[3]))), r3 = true);
      }, p(e4, i3) {
        v3 && v3.p && (!n3 || 256 & i3) && g2(v3, p3, e4, e4[8], n3 ? m2(p3, e4[8], i3, null) : $2(e4[8]), null), U2(t3, b3 = Ct2(w3, [32 & i3 && e4[5], {"data-svelte-dialog-overlay": ""}])), J2(t3, "svelte-1c5s5dv", true);
      }, i(e4) {
        n3 || (St(v3, e4), n3 = true);
      }, o(e4) {
        Lt(v3, e4), n3 = false;
      }, d(e4) {
        e4 && S2(t3), v3 && v3.d(e4), r3 = false, g3();
      }};
    }
    function At3(e3) {
      let t3, n3;
      return t3 = new kt2({props: {$$slots: {default: [Tt2]}, $$scope: {ctx: e3}}}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p(e4, n4) {
        const i3 = {};
        288 & n4 && (i3.$$scope = {dirty: n4, ctx: e4}), t3.$set(i3);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function $t2(e3) {
      let t3, n3;
      return t3 = new xt2({props: {initialFocusElement: e3[0], returnFocusElement: e3[1], $$slots: {default: [At3]}, $$scope: {ctx: e3}}}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p(e4, n4) {
        const i3 = {};
        1 & n4 && (i3.initialFocusElement = e4[0]), 2 & n4 && (i3.returnFocusElement = e4[1]), 288 & n4 && (i3.$$scope = {dirty: n4, ctx: e4}), t3.$set(i3);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Et2(e3) {
      let t3, n3, i3, s3;
      return t3 = new _t2({props: {enabled: e3[2], $$slots: {default: [$t2]}, $$scope: {ctx: e3}}}), {c() {
        Bt2(t3.$$.fragment);
      }, m(r3, a3) {
        Dt(t3, r3, a3), n3 = true, i3 || (s3 = C2(window, "keydown", e3[4]), i3 = true);
      }, p(e4, [n4]) {
        const i4 = {};
        4 & n4 && (i4.enabled = e4[2]), 291 & n4 && (i4.$$scope = {dirty: n4, ctx: e4}), t3.$set(i4);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4), i3 = false, s3();
      }};
    }
    function St2(e3, t3, n3) {
      const i3 = ["onDismiss", "initialFocusElement", "returnFocusElement", "ariaModalLegacy"];
      let s3 = b2(t3, i3), {$$slots: r3 = {}, $$scope: a3} = t3, {onDismiss: o3} = t3, {initialFocusElement: l3} = t3, {returnFocusElement: h3} = t3, {ariaModalLegacy: c3} = t3;
      return e3.$$set = (e4) => {
        t3 = n2(n2({}, t3), y2(e4)), n3(5, s3 = b2(t3, i3)), "onDismiss" in e4 && n3(6, o3 = e4.onDismiss), "initialFocusElement" in e4 && n3(0, l3 = e4.initialFocusElement), "returnFocusElement" in e4 && n3(1, h3 = e4.returnFocusElement), "ariaModalLegacy" in e4 && n3(2, c3 = e4.ariaModalLegacy), "$$scope" in e4 && n3(8, a3 = e4.$$scope);
      }, [l3, h3, c3, () => {
        o3();
      }, (e4) => {
        e4.key === "Escape" && o3();
      }, s3, o3, r3, a3];
    }
    var Mt2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, St2, Et2, a2, {onDismiss: 6, initialFocusElement: 0, returnFocusElement: 1, ariaModalLegacy: 2});
      }
    };
    function Rt2(e3) {
      let t3, n3;
      return t3 = new vt2({props: {$$slots: {default: [Ot2]}, $$scope: {ctx: e3}}}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p(e4, n4) {
        const i3 = {};
        190 & n4 && (i3.$$scope = {dirty: n4, ctx: e4}), t3.$set(i3);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Dt2(e3) {
      let t3;
      const n3 = e3[6].default, s3 = d2(n3, e3, e3[7], null);
      return {c() {
        s3 && s3.c();
      }, m(e4, n4) {
        s3 && s3.m(e4, n4), t3 = true;
      }, p(e4, i3) {
        s3 && s3.p && (!t3 || 128 & i3) && g2(s3, n3, e4, e4[7], t3 ? m2(n3, e4[7], i3, null) : $2(e4[7]), null);
      }, i(e4) {
        t3 || (St(s3, e4), t3 = true);
      }, o(e4) {
        Lt(s3, e4), t3 = false;
      }, d(e4) {
        s3 && s3.d(e4);
      }};
    }
    function Ot2(e3) {
      let t3, n3;
      const i3 = [e3[5], {onDismiss: e3[1]}, {initialFocusElement: e3[2]}, {returnFocusElement: e3[3]}, {ariaModalLegacy: e3[4]}];
      let s3 = {$$slots: {default: [Dt2]}, $$scope: {ctx: e3}};
      for (let e4 = 0; e4 < i3.length; e4 += 1)
        s3 = n2(s3, i3[e4]);
      return t3 = new Mt2({props: s3}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i4) {
        Dt(t3, e4, i4), n3 = true;
      }, p(e4, n4) {
        const s4 = 62 & n4 ? Ct2(i3, [32 & n4 && Mt(e4[5]), 2 & n4 && {onDismiss: e4[1]}, 4 & n4 && {initialFocusElement: e4[2]}, 8 & n4 && {returnFocusElement: e4[3]}, 16 & n4 && {ariaModalLegacy: e4[4]}]) : {};
        128 & n4 && (s4.$$scope = {dirty: n4, ctx: e4}), t3.$set(s4);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Nt2(e3) {
      let t3, n3, i3 = e3[0] && Rt2(e3);
      return {c() {
        i3 && i3.c(), t3 = F2();
      }, m(e4, s3) {
        i3 && i3.m(e4, s3), I2(e4, t3, s3), n3 = true;
      }, p(e4, [n4]) {
        e4[0] ? i3 ? (i3.p(e4, n4), 1 & n4 && St(i3, 1)) : (i3 = Rt2(e4), i3.c(), St(i3, 1), i3.m(t3.parentNode, t3)) : i3 && (Ot(), Lt(i3, 1, 1, () => {
          i3 = null;
        }), It2());
      }, i(e4) {
        n3 || (St(i3), n3 = true);
      }, o(e4) {
        Lt(i3), n3 = false;
      }, d(e4) {
        i3 && i3.d(e4), e4 && S2(t3);
      }};
    }
    function zt2(e3, t3, n3) {
      const i3 = ["isOpen", "onDismiss", "initialFocusElement", "returnFocusElement", "ariaModalLegacy"];
      let s3 = b2(t3, i3), {$$slots: r3 = {}, $$scope: a3} = t3, {isOpen: o3} = t3, {onDismiss: l3} = t3, {initialFocusElement: h3 = null} = t3, {returnFocusElement: c3 = null} = t3, {ariaModalLegacy: d3 = false} = t3;
      return e3.$$set = (e4) => {
        t3 = n2(n2({}, t3), y2(e4)), n3(5, s3 = b2(t3, i3)), "isOpen" in e4 && n3(0, o3 = e4.isOpen), "onDismiss" in e4 && n3(1, l3 = e4.onDismiss), "initialFocusElement" in e4 && n3(2, h3 = e4.initialFocusElement), "returnFocusElement" in e4 && n3(3, c3 = e4.returnFocusElement), "ariaModalLegacy" in e4 && n3(4, d3 = e4.ariaModalLegacy), "$$scope" in e4 && n3(7, a3 = e4.$$scope);
      }, [o3, l3, h3, c3, d3, s3, r3, a3];
    }
    var Lt2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, zt2, Nt2, a2, {isOpen: 0, onDismiss: 1, initialFocusElement: 2, returnFocusElement: 3, ariaModalLegacy: 4});
      }
    };
    function Vt2(e3) {
      let t3, n3;
      const r3 = e3[2].default, l3 = d2(r3, e3, e3[1], null);
      let g3 = [e3[0], {"data-svelte-dialog-content": ""}, {"aria-modal": "true"}, {role: "dialog"}, {tabindex: "-1"}], p3 = {};
      for (let e4 = 0; e4 < g3.length; e4 += 1)
        p3 = n2(p3, g3[e4]);
      return {c() {
        t3 = N2("div"), l3 && l3.c(), U2(t3, p3), J2(t3, "svelte-lv7yuj", true);
      }, m(e4, i3) {
        I2(e4, t3, i3), l3 && l3.m(t3, null), n3 = true;
      }, p(e4, [i3]) {
        l3 && l3.p && (!n3 || 2 & i3) && g2(l3, r3, e4, e4[1], n3 ? m2(r3, e4[1], i3, null) : $2(e4[1]), null), U2(t3, p3 = Ct2(g3, [1 & i3 && e4[0], {"data-svelte-dialog-content": ""}, {"aria-modal": "true"}, {role: "dialog"}, {tabindex: "-1"}])), J2(t3, "svelte-lv7yuj", true);
      }, i(e4) {
        n3 || (St(l3, e4), n3 = true);
      }, o(e4) {
        Lt(l3, e4), n3 = false;
      }, d(e4) {
        e4 && S2(t3), l3 && l3.d(e4);
      }};
    }
    function Bt3(e3, t3, n3) {
      const i3 = [];
      let s3 = b2(t3, i3), {$$slots: r3 = {}, $$scope: a3} = t3;
      return e3.$$set = (e4) => {
        t3 = n2(n2({}, t3), y2(e4)), n3(0, s3 = b2(t3, i3)), "$$scope" in e4 && n3(1, a3 = e4.$$scope);
      }, [s3, a3, r3];
    }
    var Ut2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Bt3, Vt2, a2, {});
      }
    };
    var Xt2 = se2();
    function Ft2(e3) {
      let t3, n3, i3, a3, h3, c3, d3, u3, f3, g3, _3, y3, I3, x3, P3, C3, k3, T3, A3, $3, E3, S3, M3 = e3[2].ASSEMBLIES + "", R3 = e3[2].PARTS + "", D3 = e3[2].BODIES + "", O3 = e3[2].GEOMS + "", N3 = e3[2].TRIANGLES + "", z3 = e3[2].LINES + "";
      return {c() {
        t3 = N2("section"), n3 = N2("header"), n3.textContent = "Scene Stats", i3 = A2(), a3 = N2("main"), h3 = N2("pre"), c3 = T2("Assemblies:"), d3 = T2(M3), u3 = T2("\r\nParts:"), f3 = T2(R3), g3 = T2("\r\nBodies:"), _3 = T2(D3), y3 = T2("\r\nGeometries:"), I3 = T2(O3), x3 = T2("\r\nTriangles:"), P3 = T2(N3), C3 = T2("\r\nLines:"), k3 = T2(z3), T3 = A2(), A3 = N2("div"), $3 = N2("button"), $3.textContent = "Close", D2(h3, "class", "text-gray-100 my-3 py-3"), D2($3, "class", "bg-gray-700 border rounded px-2 text-white"), D2(A3, "class", "text-right"), D2(t3, "class", "p-2 svelte-6vpp6e");
      }, m(s3, r3) {
        I2(s3, t3, r3), E2(t3, n3), E2(t3, i3), E2(t3, a3), E2(a3, h3), E2(h3, c3), E2(h3, d3), E2(h3, u3), E2(h3, f3), E2(h3, g3), E2(h3, _3), E2(h3, y3), E2(h3, I3), E2(h3, x3), E2(h3, P3), E2(h3, C3), E2(h3, k3), E2(t3, T3), E2(t3, A3), E2(A3, $3), E3 || (S3 = C2($3, "click", function() {
          i2(e3[1]) && e3[1].apply(this, arguments);
        }), E3 = true);
      }, p(t4, n4) {
        e3 = t4, 4 & n4 && M3 !== (M3 = e3[2].ASSEMBLIES + "") && K2(d3, M3), 4 & n4 && R3 !== (R3 = e3[2].PARTS + "") && K2(f3, R3), 4 & n4 && D3 !== (D3 = e3[2].BODIES + "") && K2(_3, D3), 4 & n4 && O3 !== (O3 = e3[2].GEOMS + "") && K2(I3, O3), 4 & n4 && N3 !== (N3 = e3[2].TRIANGLES + "") && K2(P3, N3), 4 & n4 && z3 !== (z3 = e3[2].LINES + "") && K2(k3, z3);
      }, d(e4) {
        e4 && S2(t3), E3 = false, S3();
      }};
    }
    function Gt2(e3) {
      let t3, n3;
      return t3 = new Ut2({props: {class: "content", $$slots: {default: [Ft2]}, $$scope: {ctx: e3}}}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p(e4, n4) {
        const i3 = {};
        22 & n4 && (i3.$$scope = {dirty: n4, ctx: e4}), t3.$set(i3);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Ht2(e3) {
      let t3, n3;
      return t3 = new Lt2({props: {isOpen: e3[0], onDismiss: e3[1], class: "overlay", $$slots: {default: [Gt2]}, $$scope: {ctx: e3}}}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p(e4, [n4]) {
        const i3 = {};
        1 & n4 && (i3.isOpen = e4[0]), 2 & n4 && (i3.onDismiss = e4[1]), 22 & n4 && (i3.$$scope = {dirty: n4, ctx: e4}), t3.$set(i3);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function jt2(e3, t3, n3) {
      let i3;
      p2(e3, Xt2, (e4) => n3(3, i3 = e4));
      let s3, {isOpen: r3} = t3, {close: a3} = t3;
      return nt(() => {
        if (r3) {
          const {assets: e4} = i3;
          n3(2, s3 = ((e5) => {
            const t4 = {ASSEMBLIES: 0, INSTANCE_ITEMS: 0, PARTS: 0, BODIES: 0, GEOMS: 0, TRIANGLES: 0, LINES: 0};
            return e5.traverse((e6) => {
              if (e6 instanceof GC)
                return false;
              if (e6 instanceof lC)
                t4.ASSEMBLIES++;
              else if (e6 instanceof nC)
                t4.PARTS++;
              else if (e6 instanceof MI)
                t4.INSTANCE_ITEMS++;
              else if (e6 instanceof kI) {
                t4.GEOMS++, e6 instanceof dC && t4.BODIES++;
                const n4 = e6.geomParam.value;
                n4 && (n4 instanceof Mg ? (t4.TRIANGLES += n4.getNumTriangles(), t4.LINES += n4.getNumLineSegments()) : n4 instanceof Dg ? t4.TRIANGLES += n4.getNumTriangles() : n4 instanceof Jg && (t4.LINES += n4.getNumLineSegments()));
              }
            }), console.log(t4), t4;
          })(e4));
        }
      }), e3.$$set = (e4) => {
        "isOpen" in e4 && n3(0, r3 = e4.isOpen), "close" in e4 && n3(1, a3 = e4.close);
      }, [r3, a3, s3];
    }
    var Zt2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, jt2, Ht2, a2, {isOpen: 0, close: 1});
      }
    };
    function Jt2(e3) {
      let t3, n3, i3, s3, r3, a3, l3, h3, c3, d3, g3, v3, w3, b3, _3, y3;
      function I3(t4) {
        e3[27](t4);
      }
      t3 = new et3({props: {label: "Frame All", iconLeft: "crop_free", shortcut: "F"}}), t3.$on("click", e3[20]);
      let x3 = {label: "Camera Mode: TurnTable"};
      function A3(t4) {
        e3[28](t4);
      }
      e3[4] !== void 0 && (x3.checked = e3[4]), i3 = new it3({props: x3}), ft.push(() => qt(i3, "checked", I3)), i3.$on("change", e3[13]);
      let $3 = {label: "Camera Mode: Tumbler"};
      function E3(t4) {
        e3[29](t4);
      }
      e3[3] !== void 0 && ($3.checked = e3[3]), a3 = new it3({props: $3}), ft.push(() => qt(a3, "checked", A3)), a3.$on("change", e3[12]);
      let S3 = {label: "Viewport Background: Light"};
      function M3(t4) {
        e3[30](t4);
      }
      e3[5] !== void 0 && (S3.checked = e3[5]), c3 = new it3({props: S3}), ft.push(() => qt(c3, "checked", E3)), c3.$on("change", e3[14]);
      let R3 = {label: "Viewport Background: Dark"};
      return e3[6] !== void 0 && (R3.checked = e3[6]), v3 = new it3({props: R3}), ft.push(() => qt(v3, "checked", M3)), v3.$on("change", e3[15]), _3 = new et3({props: {label: "Display Scene Stats"}}), _3.$on("click", e3[19]), {c() {
        Bt2(t3.$$.fragment), n3 = A2(), Bt2(i3.$$.fragment), r3 = A2(), Bt2(a3.$$.fragment), h3 = A2(), Bt2(c3.$$.fragment), g3 = A2(), Bt2(v3.$$.fragment), b3 = A2(), Bt2(_3.$$.fragment);
      }, m(e4, s4) {
        Dt(t3, e4, s4), I2(e4, n3, s4), Dt(i3, e4, s4), I2(e4, r3, s4), Dt(a3, e4, s4), I2(e4, h3, s4), Dt(c3, e4, s4), I2(e4, g3, s4), Dt(v3, e4, s4), I2(e4, b3, s4), Dt(_3, e4, s4), y3 = true;
      }, p(e4, t4) {
        const n4 = {};
        !s3 && 16 & t4[0] && (s3 = true, n4.checked = e4[4], bt(() => s3 = false)), i3.$set(n4);
        const r4 = {};
        !l3 && 8 & t4[0] && (l3 = true, r4.checked = e4[3], bt(() => l3 = false)), a3.$set(r4);
        const o3 = {};
        !d3 && 32 & t4[0] && (d3 = true, o3.checked = e4[5], bt(() => d3 = false)), c3.$set(o3);
        const h4 = {};
        !w3 && 64 & t4[0] && (w3 = true, h4.checked = e4[6], bt(() => w3 = false)), v3.$set(h4);
      }, i(e4) {
        y3 || (St(t3.$$.fragment, e4), St(i3.$$.fragment, e4), St(a3.$$.fragment, e4), St(c3.$$.fragment, e4), St(v3.$$.fragment, e4), St(_3.$$.fragment, e4), y3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), Lt(i3.$$.fragment, e4), Lt(a3.$$.fragment, e4), Lt(c3.$$.fragment, e4), Lt(v3.$$.fragment, e4), Lt(_3.$$.fragment, e4), y3 = false;
      }, d(e4) {
        Ut(t3, e4), e4 && S2(n3), Ut(i3, e4), e4 && S2(r3), Ut(a3, e4), e4 && S2(h3), Ut(c3, e4), e4 && S2(g3), Ut(v3, e4), e4 && S2(b3), Ut(_3, e4);
      }};
    }
    function Kt2(e3) {
      let t3, n3;
      return t3 = new Ke3({props: {isOpen: e3[48], $$slots: {default: [Jt2]}, $$scope: {ctx: e3}}}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p(e4, n4) {
        const i3 = {};
        131072 & n4[1] && (i3.isOpen = e4[48]), 120 & n4[0] | 262144 & n4[1] && (i3.$$scope = {dirty: n4, ctx: e4}), t3.$set(i3);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Wt2(e3) {
      let t3, n3, i3, s3, r3, a3, l3, h3, c3, d3, g3, v3, w3;
      function b3(t4) {
        e3[31](t4);
      }
      t3 = new et3({props: {label: "Undo", iconLeft: "undo", shortcut: "Ctrl+Z"}}), t3.$on("click", e3[21]), i3 = new et3({props: {label: "Redo", iconLeft: "redo", shortcut: "Ctrl+Y"}}), i3.$on("click", e3[22]);
      let _3 = {label: "Enable Selection Tool", shortcut: "S"};
      function y3(t4) {
        e3[32](t4);
      }
      e3[7] !== void 0 && (_3.checked = e3[7]), r3 = new it3({props: _3}), ft.push(() => qt(r3, "checked", b3)), r3.$on("change", e3[16]);
      let I3 = {label: "Enable Transform Handles", shortcut: "T"};
      function x3(t4) {
        e3[33](t4);
      }
      e3[8] !== void 0 && (I3.checked = e3[8]), h3 = new it3({props: I3}), ft.push(() => qt(h3, "checked", y3)), h3.$on("change", e3[17]);
      let A3 = {label: "Enable Walk Mode (WASD)"};
      return e3[0] !== void 0 && (A3.checked = e3[0]), g3 = new it3({props: A3}), ft.push(() => qt(g3, "checked", x3)), {c() {
        Bt2(t3.$$.fragment), n3 = A2(), Bt2(i3.$$.fragment), s3 = A2(), Bt2(r3.$$.fragment), l3 = A2(), Bt2(h3.$$.fragment), d3 = A2(), Bt2(g3.$$.fragment);
      }, m(e4, a4) {
        Dt(t3, e4, a4), I2(e4, n3, a4), Dt(i3, e4, a4), I2(e4, s3, a4), Dt(r3, e4, a4), I2(e4, l3, a4), Dt(h3, e4, a4), I2(e4, d3, a4), Dt(g3, e4, a4), w3 = true;
      }, p(e4, t4) {
        const n4 = {};
        !a3 && 128 & t4[0] && (a3 = true, n4.checked = e4[7], bt(() => a3 = false)), r3.$set(n4);
        const i4 = {};
        !c3 && 256 & t4[0] && (c3 = true, i4.checked = e4[8], bt(() => c3 = false)), h3.$set(i4);
        const s4 = {};
        !v3 && 1 & t4[0] && (v3 = true, s4.checked = e4[0], bt(() => v3 = false)), g3.$set(s4);
      }, i(e4) {
        w3 || (St(t3.$$.fragment, e4), St(i3.$$.fragment, e4), St(r3.$$.fragment, e4), St(h3.$$.fragment, e4), St(g3.$$.fragment, e4), w3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), Lt(i3.$$.fragment, e4), Lt(r3.$$.fragment, e4), Lt(h3.$$.fragment, e4), Lt(g3.$$.fragment, e4), w3 = false;
      }, d(e4) {
        Ut(t3, e4), e4 && S2(n3), Ut(i3, e4), e4 && S2(s3), Ut(r3, e4), e4 && S2(l3), Ut(h3, e4), e4 && S2(d3), Ut(g3, e4);
      }};
    }
    function Yt2(e3) {
      let t3, n3;
      return t3 = new Ke3({props: {isOpen: e3[48], $$slots: {default: [Wt2]}, $$scope: {ctx: e3}}}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p(e4, n4) {
        const i3 = {};
        131072 & n4[1] && (i3.isOpen = e4[48]), 385 & n4[0] | 262144 & n4[1] && (i3.$$scope = {dirty: n4, ctx: e4}), t3.$set(i3);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function qt2(e3) {
      let t3, n3;
      return t3 = new et3({props: {disabled: e3[2], label: e3[1]}}), t3.$on("click", e3[24]), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p(e4, n4) {
        const i3 = {};
        4 & n4[0] && (i3.disabled = e4[2]), 2 & n4[0] && (i3.label = e4[1]), t3.$set(i3);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Qt2(e3) {
      let t3, n3;
      return t3 = new Ke3({props: {isOpen: e3[48], $$slots: {default: [qt2]}, $$scope: {ctx: e3}}}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p(e4, n4) {
        const i3 = {};
        131072 & n4[1] && (i3.isOpen = e4[48]), 6 & n4[0] | 262144 & n4[1] && (i3.$$scope = {dirty: n4, ctx: e4}), t3.$set(i3);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function en2(e3) {
      let t3, n3;
      return t3 = new et3({props: {label: "Explode"}}), t3.$on("click", e3[23]), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p: t2, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function tn2(e3) {
      let t3, n3;
      return t3 = new Ke3({props: {isOpen: e3[48], $$slots: {default: [en2]}, $$scope: {ctx: e3}}}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p(e4, n4) {
        const i3 = {};
        131072 & n4[1] && (i3.isOpen = e4[48]), 262144 & n4[1] && (i3.$$scope = {dirty: n4, ctx: e4}), t3.$set(i3);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function nn2(e3) {
      let t3, n3, i3, s3, r3, a3, l3, h3;
      return t3 = new ft2({props: {label: "View", $$slots: {default: [Kt2, ({isOpen: e4}) => ({48: e4}), ({isOpen: e4}) => [0, e4 ? 131072 : 0]]}, $$scope: {ctx: e3}}}), i3 = new ft2({props: {label: "Edit", $$slots: {default: [Yt2, ({isOpen: e4}) => ({48: e4}), ({isOpen: e4}) => [0, e4 ? 131072 : 0]]}, $$scope: {ctx: e3}}}), r3 = new ft2({props: {label: "VR", $$slots: {default: [Qt2, ({isOpen: e4}) => ({48: e4}), ({isOpen: e4}) => [0, e4 ? 131072 : 0]]}, $$scope: {ctx: e3}}}), l3 = new ft2({props: {label: "Asm", $$slots: {default: [tn2, ({isOpen: e4}) => ({48: e4}), ({isOpen: e4}) => [0, e4 ? 131072 : 0]]}, $$scope: {ctx: e3}}}), {c() {
        Bt2(t3.$$.fragment), n3 = A2(), Bt2(i3.$$.fragment), s3 = A2(), Bt2(r3.$$.fragment), a3 = A2(), Bt2(l3.$$.fragment);
      }, m(e4, c3) {
        Dt(t3, e4, c3), I2(e4, n3, c3), Dt(i3, e4, c3), I2(e4, s3, c3), Dt(r3, e4, c3), I2(e4, a3, c3), Dt(l3, e4, c3), h3 = true;
      }, p(e4, n4) {
        const s4 = {};
        120 & n4[0] | 393216 & n4[1] && (s4.$$scope = {dirty: n4, ctx: e4}), t3.$set(s4);
        const a4 = {};
        385 & n4[0] | 393216 & n4[1] && (a4.$$scope = {dirty: n4, ctx: e4}), i3.$set(a4);
        const o3 = {};
        6 & n4[0] | 393216 & n4[1] && (o3.$$scope = {dirty: n4, ctx: e4}), r3.$set(o3);
        const h4 = {};
        393216 & n4[1] && (h4.$$scope = {dirty: n4, ctx: e4}), l3.$set(h4);
      }, i(e4) {
        h3 || (St(t3.$$.fragment, e4), St(i3.$$.fragment, e4), St(r3.$$.fragment, e4), St(l3.$$.fragment, e4), h3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), Lt(i3.$$.fragment, e4), Lt(r3.$$.fragment, e4), Lt(l3.$$.fragment, e4), h3 = false;
      }, d(e4) {
        Ut(t3, e4), e4 && S2(n3), Ut(i3, e4), e4 && S2(s3), Ut(r3, e4), e4 && S2(a3), Ut(l3, e4);
      }};
    }
    function sn2(e3) {
      let t3, n3, i3 = !e3[11] && function(e4) {
        let t4, n4, i4, a3, h3, c3, d3, g3, _3, y3, I3, x3, P3, A3, $3, E3, S3 = e4[10].shouldShowDrawer ? "menu_open" : "menu";
        return c3 = new at2({props: {$$slots: {default: [nn2]}, $$scope: {ctx: e4}}}), P3 = new Zt2({props: {isOpen: e4[9], close: e4[18]}}), {c() {
          t4 = N2("header"), n4 = N2("img"), a3 = A2(), h3 = N2("div"), Bt2(c3.$$.fragment), d3 = A2(), g3 = N2("button"), _3 = N2("span"), y3 = T2(S3), x3 = A2(), Bt2(P3.$$.fragment), D2(n4, "class", "h-6 ml-8"), l2(n4.src, i4 = "/images/logo-zea.svg") || D2(n4, "src", "/images/logo-zea.svg"), D2(n4, "alt", "logo"), D2(t4, "class", "gap-2 items-center px-1 sm:px-2 py-1 text-gray-200 z-50 hidden sm:flex"), D2(_3, "class", "material-icons"), D2(g3, "class", "cursor-default flex justify-center rounded z-50 fixed bg-background top-1 left-1"), D2(g3, "title", I3 = (e4[10].shouldShowDrawer ? "Close" : "Open") + " drawer");
        }, m(i5, s3) {
          I2(i5, t4, s3), E2(t4, n4), E2(t4, a3), E2(t4, h3), Dt(c3, h3, null), I2(i5, d3, s3), I2(i5, g3, s3), E2(g3, _3), E2(_3, y3), I2(i5, x3, s3), Dt(P3, i5, s3), A3 = true, $3 || (E3 = C2(g3, "click", e4[25]), $3 = true);
        }, p(e5, t5) {
          const n5 = {};
          511 & t5[0] | 262144 & t5[1] && (n5.$$scope = {dirty: t5, ctx: e5}), c3.$set(n5), (!A3 || 1024 & t5[0]) && S3 !== (S3 = e5[10].shouldShowDrawer ? "menu_open" : "menu") && K2(y3, S3), (!A3 || 1024 & t5[0] && I3 !== (I3 = (e5[10].shouldShowDrawer ? "Close" : "Open") + " drawer")) && D2(g3, "title", I3);
          const i5 = {};
          512 & t5[0] && (i5.isOpen = e5[9]), P3.$set(i5);
        }, i(e5) {
          A3 || (St(c3.$$.fragment, e5), St(P3.$$.fragment, e5), A3 = true);
        }, o(e5) {
          Lt(c3.$$.fragment, e5), Lt(P3.$$.fragment, e5), A3 = false;
        }, d(e5) {
          e5 && S2(t4), Ut(c3), e5 && S2(d3), e5 && S2(g3), e5 && S2(x3), Ut(P3, e5), $3 = false, E3();
        }};
      }(e3);
      return {c() {
        i3 && i3.c(), t3 = F2();
      }, m(e4, s3) {
        i3 && i3.m(e4, s3), I2(e4, t3, s3), n3 = true;
      }, p(e4, t4) {
        e4[11] || i3.p(e4, t4);
      }, i(e4) {
        n3 || (St(i3), n3 = true);
      }, o(e4) {
        Lt(i3), n3 = false;
      }, d(e4) {
        i3 && i3.d(e4), e4 && S2(t3);
      }};
    }
    function rn2(e3, t3, n3) {
      let i3, s3;
      p2(e3, ot2, (e4) => n3(10, i3 = e4)), p2(e3, je2, (e4) => n3(41, e4)), p2(e3, Xt2, (e4) => n3(42, s3 = e4));
      const r3 = new URLSearchParams(window.location.search), a3 = r3.has("embedded");
      r3.has("roomId");
      let o3, l3, h3, c3, d3, u3, f3 = "Detecting VR...", m3 = true, g3 = true, p3 = false, v3 = true, w3 = false, b3 = false, _3 = false;
      document.addEventListener("keydown", (e4) => {
        if (!e4.target.contains(l3.getGLCanvas()))
          return;
        switch (e4.key.toLowerCase()) {
          case "f":
            l3 && l3.frameAll();
            break;
          case "z":
            e4.ctrlKey && u3 && u3.undo();
            break;
          case "y":
            e4.ctrlKey && u3 && u3.redo();
        }
      });
      let y3 = false;
      ot(() => {
        h3 && h3.leaveRoom(), n3(1, f3 = "VR Device Not Detected"), Xt2.subscribe((e4) => {
          if (e4 && !l3) {
            l3 = e4.renderer, c3 = e4.selectionManager, d3 = e4.toolManager, n3(26, o3 = e4.cameraManipulator), u3 = e4.undoRedoManager;
            {
              const {renderer: e5} = s3;
              e5.getXRViewport().then((e6) => {
                e6.spectatorMode = false, n3(1, f3 = "Launch VR"), n3(2, m3 = false), e6.on("presentingChanged", (e7) => {
                  const {state: t4} = e7;
                  n3(1, f3 = t4 ? "Exit VR" : "Launch VR");
                });
              }).catch((e6) => {
                console.warn("Unable to setup XR:" + e6);
              });
            }
          }
        }), Xt2.subscribe((e4) => {
          e4 && !h3 && e4.session && e4.sessionSync && (h3 = e4.session, window.addEventListener("zeaUserClicked", (e5) => {
          }));
        });
      });
      let x3 = false;
      return e3.$$.update = () => {
        67108865 & e3.$$.dirty[0] && o3 && n3(26, o3.enabledWASDWalkMode = x3, o3);
      }, [x3, f3, m3, g3, p3, v3, w3, b3, _3, y3, i3, a3, () => {
        o3.setDefaultManipulationMode(SC.MANIPULATION_MODES.tumbler), n3(3, g3 = true), n3(4, p3 = false);
      }, () => {
        o3.setDefaultManipulationMode(SC.MANIPULATION_MODES.turntable);
        const e4 = l3.getViewport().getCamera().getParameter("GlobalXfo").getValue(), t4 = e4.ori.getZaxis();
        let i4 = 0;
        const s4 = setInterval(() => {
          i4 += 0.1;
          const n4 = new c(), r4 = e4.clone();
          n4.setFromDirectionAndUpvector(t4, new o(0, 0, 1)), r4.ori = e4.ori.lerp(n4, Math.min(i4, 1)), l3.getViewport().getCamera().getParameter("GlobalXfo").setValue(r4), i4 >= 1 && clearInterval(s4);
        }, 20);
        n3(4, p3 = true), n3(3, g3 = false);
      }, () => {
        l3.getViewport().backgroundColorParam.value = new l(0.85, 0.85, 0.85), n3(5, v3 = true), n3(6, w3 = false);
      }, () => {
        l3.getViewport().backgroundColorParam.value = new l(0.25, 0.25, 0.25), n3(5, v3 = false), n3(6, w3 = true);
      }, () => {
        d3 && (b3 ? d3.pushTool("SelectionTool") : d3.popTool());
      }, () => {
        console.log("showHandles"), c3 && (c3.showHandles(_3), c3.updateHandleVisibility());
      }, () => {
        n3(9, y3 = false);
      }, () => {
        n3(9, y3 = true);
      }, () => {
        const {renderer: e4} = s3;
        e4.frameAll();
      }, () => {
        const {undoRedoManager: e4} = s3;
        e4.undo();
      }, () => {
        const {undoRedoManager: e4} = s3;
        e4.redo();
      }, () => {
        _2(ot2, i3.asmExplodeEnabled = !i3.asmExplodeEnabled, i3);
      }, () => {
        const {renderer: e4} = s3;
        e4.getXRViewport().then((e5) => {
          e5.togglePresenting();
        }).catch((e5) => {
          console.warn("Unable to setup XR:" + e5);
        });
      }, () => {
        _2(ot2, i3.shouldShowDrawer = !i3.shouldShowDrawer, i3);
      }, o3, function(e4) {
        p3 = e4, n3(4, p3);
      }, function(e4) {
        g3 = e4, n3(3, g3);
      }, function(e4) {
        v3 = e4, n3(5, v3);
      }, function(e4) {
        w3 = e4, n3(6, w3);
      }, function(e4) {
        b3 = e4, n3(7, b3);
      }, function(e4) {
        _3 = e4, n3(8, _3);
      }, function(e4) {
        x3 = e4, n3(0, x3);
      }];
    }
    var an2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, rn2, sn2, a2, {}, null, [-1, -1]);
      }
    };
    var on2 = class extends HTMLElement {
      constructor() {
        super();
        const e3 = this.attachShadow({mode: "open"});
        this.div = document.createElement("div"), this.div.classList.add("fps-display"), e3.appendChild(this.div);
        const t3 = document.createElement("style");
        t3.appendChild(document.createTextNode("\n      .fps-display {\n        position: absolute;\n        bottom: 10px;\n        right: 10px;\n        color: #000000;\n      }\n    ")), e3.appendChild(t3);
      }
      set renderer(e3) {
        let t3 = 0, n3 = 0;
        e3.on("redrawOccurred", () => {
          t3++;
        }), setInterval(() => {
          n3 != 2 * t3 && (n3 = 2 * t3, this.div.textContent = `FPS: ${n3}`), t3 = 0;
        }, 500);
      }
    };
    customElements.define("fps-display", on2);
    var ln2 = {};
    function hn2(e3) {
      let t3, n3, a3, g3, v3, w3;
      const b3 = e3[5].default, _3 = d2(b3, e3, e3[4], null);
      return {c() {
        t3 = A2(), n3 = N2("div"), _3 && _3.c(), D2(n3, "class", "Menu svelte-1lqkg4w"), W2(n3, "top", e3[1] + "px"), W2(n3, "left", e3[0] + "px");
      }, m(i3, s3) {
        I2(i3, t3, s3), I2(i3, n3, s3), _3 && _3.m(n3, null), e3[6](n3), g3 = true, v3 || (w3 = C2(document.body, "click", e3[3]), v3 = true);
      }, p(e4, [t4]) {
        _3 && _3.p && (!g3 || 16 & t4) && g2(_3, b3, e4, e4[4], g3 ? m2(b3, e4[4], t4, null) : $2(e4[4]), null), (!g3 || 2 & t4) && W2(n3, "top", e4[1] + "px"), (!g3 || 1 & t4) && W2(n3, "left", e4[0] + "px");
      }, i(e4) {
        g3 || (St(_3, e4), yt(() => {
          a3 || (a3 = Rt(n3, mt2, {duration: 100}, true)), a3.run(1);
        }), g3 = true);
      }, o(e4) {
        Lt(_3, e4), a3 || (a3 = Rt(n3, mt2, {duration: 100}, false)), a3.run(0), g3 = false;
      }, d(i3) {
        i3 && S2(t3), i3 && S2(n3), _3 && _3.d(i3), e3[6](null), i3 && a3 && a3.end(), v3 = false, w3();
      }};
    }
    function cn2(e3, t3, n3) {
      let {$$slots: i3 = {}, $$scope: s3} = t3, {x: r3} = t3, {y: a3} = t3;
      const o3 = it2();
      let l3;
      at(ln2, {dispatchClick: () => o3("click")});
      return e3.$$set = (e4) => {
        "x" in e4 && n3(0, r3 = e4.x), "y" in e4 && n3(1, a3 = e4.y), "$$scope" in e4 && n3(4, s3 = e4.$$scope);
      }, e3.$$.update = () => {
        7 & e3.$$.dirty && (() => {
          if (!l3)
            return;
          const e4 = l3.getBoundingClientRect();
          n3(0, r3 = Math.min(window.innerWidth - e4.width, r3)), a3 > window.innerHeight - e4.height && n3(1, a3 -= e4.height);
        })();
      }, [r3, a3, l3, (e4) => {
        e4.target === l3 || l3.contains(e4.target) || o3("clickoutside");
      }, s3, i3, function(e4) {
        ft[e4 ? "unshift" : "push"](() => {
          l3 = e4, n3(2, l3);
        });
      }];
    }
    var dn2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, cn2, hn2, a2, {x: 0, y: 1});
      }
    };
    function un2(e3) {
      let t3;
      const n3 = e3[3].default, s3 = d2(n3, e3, e3[2], null);
      return {c() {
        s3 && s3.c();
      }, m(e4, n4) {
        s3 && s3.m(e4, n4), t3 = true;
      }, p(e4, i3) {
        s3 && s3.p && (!t3 || 4 & i3) && g2(s3, n3, e4, e4[2], t3 ? m2(n3, e4[2], i3, null) : $2(e4[2]), null);
      }, i(e4) {
        t3 || (St(s3, e4), t3 = true);
      }, o(e4) {
        Lt(s3, e4), t3 = false;
      }, d(e4) {
        s3 && s3.d(e4);
      }};
    }
    function fn2(e3) {
      let t3;
      return {c() {
        t3 = T2(e3[0]);
      }, m(e4, n3) {
        I2(e4, t3, n3);
      }, p(e4, n3) {
        1 & n3 && K2(t3, e4[0]);
      }, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    function mn2(e3) {
      let t3, n3, i3, a3, h3, c3;
      const d3 = [fn2, un2], g3 = [];
      function p3(e4, t4) {
        return e4[0] ? 0 : 1;
      }
      return n3 = p3(e3), i3 = g3[n3] = d3[n3](e3), {c() {
        t3 = N2("div"), i3.c(), D2(t3, "class", "MenuOption text-gray svelte-13rtpoe");
      }, m(i4, s3) {
        I2(i4, t3, s3), g3[n3].m(t3, null), a3 = true, h3 || (c3 = C2(t3, "click", e3[1]), h3 = true);
      }, p(e4, [s3]) {
        let r3 = n3;
        n3 = p3(e4), n3 === r3 ? g3[n3].p(e4, s3) : (Ot(), Lt(g3[r3], 1, 1, () => {
          g3[r3] = null;
        }), It2(), i3 = g3[n3], i3 ? i3.p(e4, s3) : (i3 = g3[n3] = d3[n3](e4), i3.c()), St(i3, 1), i3.m(t3, null));
      }, i(e4) {
        a3 || (St(i3), a3 = true);
      }, o(e4) {
        Lt(i3), a3 = false;
      }, d(e4) {
        e4 && S2(t3), g3[n3].d(), h3 = false, c3();
      }};
    }
    function gn2(e3, t3, n3) {
      let {$$slots: i3 = {}, $$scope: s3} = t3, {text: r3 = ""} = t3;
      const a3 = it2(), {dispatchClick: o3} = ct(ln2);
      return e3.$$set = (e4) => {
        "text" in e4 && n3(0, r3 = e4.text), "$$scope" in e4 && n3(2, s3 = e4.$$scope);
      }, [r3, (e4) => {
        a3("click"), o3();
      }, s3, i3];
    }
    var pn2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, gn2, mn2, a2, {text: 0});
      }
    };
    function vn(e3) {
      let t3, n3, i3, a3, h3, c3, d3, u3, f3, g3, _3, y3, I3, x3 = e3[2].getName() + "", P3 = e3[2].getPath() + "";
      return {c() {
        t3 = N2("section"), n3 = N2("header"), n3.textContent = "Properties", i3 = A2(), a3 = N2("main"), h3 = N2("pre"), c3 = T2(x3), d3 = T2("\r\n"), u3 = T2(P3), f3 = A2(), g3 = N2("div"), _3 = N2("button"), _3.textContent = "Close", D2(h3, "class", "text-gray-100 my-3 py-3"), D2(_3, "class", "bg-gray-700 border rounded px-2 text-white"), D2(g3, "class", "text-right"), D2(t3, "class", "p-2 svelte-6vpp6e");
      }, m(s3, r3) {
        I2(s3, t3, r3), E2(t3, n3), E2(t3, i3), E2(t3, a3), E2(a3, h3), E2(h3, c3), E2(h3, d3), E2(h3, u3), E2(t3, f3), E2(t3, g3), E2(g3, _3), y3 || (I3 = C2(_3, "click", function() {
          i2(e3[1]) && e3[1].apply(this, arguments);
        }), y3 = true);
      }, p(t4, n4) {
        e3 = t4, 4 & n4 && x3 !== (x3 = e3[2].getName() + "") && K2(c3, x3), 4 & n4 && P3 !== (P3 = e3[2].getPath() + "") && K2(u3, P3);
      }, d(e4) {
        e4 && S2(t3), y3 = false, I3();
      }};
    }
    function wn(e3) {
      let t3, n3;
      return t3 = new Ut2({props: {class: "content", $$slots: {default: [vn]}, $$scope: {ctx: e3}}}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p(e4, n4) {
        const i3 = {};
        14 & n4 && (i3.$$scope = {dirty: n4, ctx: e4}), t3.$set(i3);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function bn2(e3) {
      let t3, n3;
      return t3 = new Lt2({props: {isOpen: e3[0], onDismiss: e3[1], class: "overlay", $$slots: {default: [wn]}, $$scope: {ctx: e3}}}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p(e4, [n4]) {
        const i3 = {};
        1 & n4 && (i3.isOpen = e4[0]), 2 & n4 && (i3.onDismiss = e4[1]), 14 & n4 && (i3.$$scope = {dirty: n4, ctx: e4}), t3.$set(i3);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function _n2(e3, t3, n3) {
      let {isOpen: i3} = t3, {close: s3} = t3, {contextItem: r3} = t3;
      return e3.$$set = (e4) => {
        "isOpen" in e4 && n3(0, i3 = e4.isOpen), "close" in e4 && n3(1, s3 = e4.close), "contextItem" in e4 && n3(2, r3 = e4.contextItem);
      }, [i3, s3, r3];
    }
    var yn2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, _n2, bn2, a2, {isOpen: 0, close: 1, contextItem: 2});
      }
    };
    var In = [];
    var xn = new class {
      registerComponent(e3, t3) {
        In.push({queryCb: e3, component: t3});
      }
      selectComponent(e3) {
        for (let t3 = In.length - 1; t3 >= 0; t3--)
          if (In[t3].queryCb(e3))
            return In[t3].component;
      }
    }();
    function Pn(e3) {
      let t3, n3, i3;
      return {c() {
        t3 = N2("input"), D2(t3, "type", "checkbox"), t3.readOnly = true, t3.checked = e3[0];
      }, m(s3, r3) {
        I2(s3, t3, r3), n3 || (i3 = C2(t3, "input", e3[1]), n3 = true);
      }, p(e4, [n4]) {
        1 & n4 && (t3.checked = e4[0]);
      }, i: t2, o: t2, d(e4) {
        e4 && S2(t3), n3 = false, i3();
      }};
    }
    function Cn(e3, t3, n3) {
      let {parameter: i3} = t3, s3 = i3.getValue(), r3 = false;
      return i3.on("valueChanged", (e4) => {
        r3 || n3(0, s3 = i3.getValue());
      }), e3.$$set = (e4) => {
        "parameter" in e4 && n3(2, i3 = e4.parameter);
      }, [s3, (e4) => {
        n3(0, s3 = e4.target.checked), r3 = true, i3.setValue(s3), r3 = false;
      }, i3];
    }
    var kn = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Cn, Pn, a2, {parameter: 2});
      }
    };
    function Tn(e3) {
      let t3, n3, i3;
      return {c() {
        t3 = N2("input"), D2(t3, "step", e3[1]), D2(t3, "type", "number"), t3.readOnly = true, t3.value = e3[0], D2(t3, "class", "NumberParameterWidget text-black rounded p-1 w-full");
      }, m(s3, r3) {
        I2(s3, t3, r3), n3 || (i3 = C2(t3, "input", e3[2]), n3 = true);
      }, p(e4, [n4]) {
        1 & n4 && (t3.value = e4[0]);
      }, i: t2, o: t2, d(e4) {
        e4 && S2(t3), n3 = false, i3();
      }};
    }
    function An(e3, t3, n3) {
      let {parameter: i3} = t3, s3 = i3.getStep(), r3 = i3.getValue(), a3 = false;
      return i3.on("valueChanged", (e4) => {
        a3 || n3(0, r3 = i3.getValue());
      }), e3.$$set = (e4) => {
        "parameter" in e4 && n3(3, i3 = e4.parameter);
      }, [r3, s3, (e4) => {
        n3(0, r3 = e4.target.valueAsNumber), a3 = true, i3.setValue(r3), a3 = false;
      }, i3];
    }
    var $n2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, An, Tn, a2, {parameter: 3});
      }
    };
    function En(e3) {
      let t3, n3, i3, a3, h3;
      return {c() {
        t3 = N2("input"), n3 = A2(), i3 = N2("input"), D2(t3, "max", Mn), D2(t3, "min", Sn), D2(t3, "type", "range"), D2(t3, "step", e3[3]), t3.value = e3[2], D2(i3, "max", Mn), D2(i3, "min", Sn), D2(i3, "step", e3[0]), D2(i3, "type", "number"), i3.readOnly = true, i3.value = e3[1], D2(i3, "class", "RangedNumberParameterWidget text-black rounded p-1");
      }, m(s3, r3) {
        I2(s3, t3, r3), I2(s3, n3, r3), I2(s3, i3, r3), a3 || (h3 = [C2(t3, "input", e3[4]), C2(i3, "input", e3[5])], a3 = true);
      }, p(e4, [n4]) {
        8 & n4 && D2(t3, "step", e4[3]), 4 & n4 && (t3.value = e4[2]), 1 & n4 && D2(i3, "step", e4[0]), 2 & n4 && (i3.value = e4[1]);
      }, i: t2, o: t2, d(e4) {
        e4 && S2(t3), e4 && S2(n3), e4 && S2(i3), a3 = false, s2(h3);
      }};
    }
    var Sn = 0;
    var Mn = 200;
    function Rn(e3, t3, n3) {
      let {parameter: i3} = t3;
      const s3 = (e4, t4, n4, i4, s4) => i4 + (e4 - t4) / (n4 - t4) * (s4 - i4);
      let r3 = i3.getRange()[0], a3 = i3.getRange()[1], o3 = i3.getStep() || s3(1, Sn, Mn, r3, a3), l3 = i3.getValue(), h3 = Math.round(s3(l3, r3, a3, Sn, Mn)), c3 = Math.round(s3(o3, r3, a3, Sn, Mn)), d3 = false;
      return i3.on("valueChanged", (e4) => {
        d3 || (n3(1, l3 = i3.getValue()), n3(2, h3 = s3(l3, r3, a3, Sn, Mn)));
      }), i3.on("rangeChanged", (e4) => {
        r3 = i3.getMin(), a3 = i3.getMax(), n3(0, o3 = i3.getStep()), n3(3, c3 = Math.round(s3(o3, r3, a3, Sn, Mn)));
      }), e3.$$set = (e4) => {
        "parameter" in e4 && n3(6, i3 = e4.parameter);
      }, [o3, l3, h3, c3, (e4) => {
        n3(2, h3 = e4.target.valueAsNumber), n3(1, l3 = ((e5, t4 = 6) => Number(Math.round(Number(`${e5}e${t4}`)) + `e-${t4}`))(Math.round(s3(h3, Sn, Mn, r3, a3) / o3) * o3)), d3 = true, i3.setValue(l3), d3 = false;
      }, (e4) => {
        n3(1, l3 = e4.target.valueAsNumber), n3(2, h3 = s3(l3, r3, a3, Sn, Mn)), d3 = true, i3.setValue(l3), d3 = false;
      }, i3];
    }
    var Dn = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Rn, En, a2, {parameter: 6});
      }
    };
    function On(e3) {
      let t3, n3, i3;
      return {c() {
        t3 = N2("input"), t3.value = e3[0], t3.readOnly = true, D2(t3, "class", "StringParameterWidget text-black rounded p-1 w-full");
      }, m(s3, r3) {
        I2(s3, t3, r3), n3 || (i3 = C2(t3, "input", e3[1]), n3 = true);
      }, p(e4, [n4]) {
        1 & n4 && t3.value !== e4[0] && (t3.value = e4[0]);
      }, i: t2, o: t2, d(e4) {
        e4 && S2(t3), n3 = false, i3();
      }};
    }
    function Nn(e3, t3, n3) {
      let {parameter: i3} = t3, s3 = i3.getValue(), r3 = false;
      return i3.on("valueChanged", (e4) => {
        r3 || n3(0, s3 = i3.getValue());
      }), e3.$$set = (e4) => {
        "parameter" in e4 && n3(2, i3 = e4.parameter);
      }, [s3, (e4) => {
        n3(0, s3 = e4.target.value), r3 = true, i3.setValue(s3), r3 = false;
      }, i3];
    }
    var zn = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Nn, On, a2, {parameter: 2});
      }
    };
    function Ln(e3) {
      let t3, n3, i3, a3;
      return {c() {
        t3 = N2("input"), D2(t3, "type", "color"), t3.readOnly = true, t3.value = n3 = e3[0].toHex(), D2(t3, "class", "text-black rounded h-full");
      }, m(n4, s3) {
        I2(n4, t3, s3), i3 || (a3 = C2(t3, "input", e3[1]), i3 = true);
      }, p(e4, [i4]) {
        1 & i4 && n3 !== (n3 = e4[0].toHex()) && (t3.value = n3);
      }, i: t2, o: t2, d(e4) {
        e4 && S2(t3), i3 = false, a3();
      }};
    }
    function Vn(e3, t3, n3) {
      let {parameter: i3} = t3, s3 = i3.getValue(), r3 = false;
      return i3.on("valueChanged", (e4) => {
        r3 || n3(0, s3 = i3.getValue());
      }), e3.$$set = (e4) => {
        "parameter" in e4 && n3(2, i3 = e4.parameter);
      }, [s3, (e4) => {
        r3 = true, s3.setFromHex(e4.target.value), i3.setValue(s3), r3 = false;
      }, i3];
    }
    var Bn = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Vn, Ln, a2, {parameter: 2});
      }
    };
    function Un(e3, t3, n3) {
      const i3 = e3.slice();
      return i3[3] = t3[n3], i3;
    }
    function Xn(e3, t3) {
      let n3, i3, a3, l3, h3, c3, d3, g3 = t3[3].parameter.getName() + "";
      var _3 = t3[3].component;
      function y3(e4) {
        return {props: {parameter: e4[3].parameter}};
      }
      return _3 && (h3 = new _3(y3(t3))), {key: e3, first: null, c() {
        n3 = N2("div"), i3 = T2(g3), a3 = A2(), l3 = N2("div"), h3 && Bt2(h3.$$.fragment), c3 = A2(), D2(n3, "class", "flex items-center justify-end mr-2 text-black"), D2(l3, "class", "pointer-events-auto"), this.first = n3;
      }, m(e4, t4) {
        I2(e4, n3, t4), E2(n3, i3), I2(e4, a3, t4), I2(e4, l3, t4), h3 && Dt(h3, l3, null), E2(l3, c3), d3 = true;
      }, p(e4, n4) {
        t3 = e4, (!d3 || 1 & n4) && g3 !== (g3 = t3[3].parameter.getName() + "") && K2(i3, g3);
        const s3 = {};
        if (1 & n4 && (s3.parameter = t3[3].parameter), _3 !== (_3 = t3[3].component)) {
          if (h3) {
            Ot();
            const e5 = h3;
            Lt(e5.$$.fragment, 1, 0, () => {
              Ut(e5, 1);
            }), It2();
          }
          _3 ? (h3 = new _3(y3(t3)), Bt2(h3.$$.fragment), St(h3.$$.fragment, 1), Dt(h3, l3, c3)) : h3 = null;
        } else
          _3 && h3.$set(s3);
      }, i(e4) {
        d3 || (h3 && St(h3.$$.fragment, e4), d3 = true);
      }, o(e4) {
        h3 && Lt(h3.$$.fragment, e4), d3 = false;
      }, d(e4) {
        e4 && S2(n3), e4 && S2(a3), e4 && S2(l3), h3 && Ut(h3);
      }};
    }
    function Fn(e3) {
      let t3, n3, i3 = [], a3 = new Map(), l3 = e3[0];
      const h3 = (e4) => e4[3].index;
      for (let t4 = 0; t4 < l3.length; t4 += 1) {
        let n4 = Un(e3, l3, t4), s3 = h3(n4);
        a3.set(s3, i3[t4] = Xn(s3, n4));
      }
      return {c() {
        t3 = N2("div");
        for (let e4 = 0; e4 < i3.length; e4 += 1)
          i3[e4].c();
        D2(t3, "class", "absolute top-36 right-0 p-2 overflow-hidden pointer-events-none ParameterOwnerWidget grid w-120 space-y-2  svelte-nhv82b");
      }, m(e4, s3) {
        I2(e4, t3, s3);
        for (let e5 = 0; e5 < i3.length; e5 += 1)
          i3[e5].m(t3, null);
        n3 = true;
      }, p(e4, [n4]) {
        1 & n4 && (l3 = e4[0], Ot(), i3 = Ft(i3, n4, h3, 1, e4, l3, a3, t3, At2, Xn, null, Un), It2());
      }, i(e4) {
        if (!n3) {
          for (let e5 = 0; e5 < l3.length; e5 += 1)
            St(i3[e5]);
          n3 = true;
        }
      }, o(e4) {
        for (let e5 = 0; e5 < i3.length; e5 += 1)
          Lt(i3[e5]);
        n3 = false;
      }, d(e4) {
        e4 && S2(t3);
        for (let e5 = 0; e5 < i3.length; e5 += 1)
          i3[e5].d();
      }};
    }
    function Gn(e3, t3, n3) {
      let {parameterOwner: i3} = t3, s3 = [];
      xn.registerComponent((e4) => e4 instanceof fA, kn), xn.registerComponent((e4) => e4 instanceof JA, $n2), xn.registerComponent((e4) => e4 instanceof JA && e4.getRange(), Dn), xn.registerComponent((e4) => e4 instanceof jA, zn), xn.registerComponent((e4) => e4 instanceof xA, Bn);
      let r3 = 0;
      return rt(async () => {
        n3(0, s3 = []);
      }), e3.$$set = (e4) => {
        "parameterOwner" in e4 && n3(1, i3 = e4.parameterOwner);
      }, e3.$$.update = () => {
        7 & e3.$$.dirty && i3.getParameters().forEach((e4) => {
          if (e4.getName() == "Visible")
            return;
          if (e4.getName() == "DisplayEdges")
            return;
          if (e4.getName() == "Color")
            return;
          if (e4.getName() == "EdgeColor")
            return;
          const t4 = xn.selectComponent(e4);
          t4 && (s3.push({index: r3, component: t4, parameter: e4}), n3(2, r3++, r3));
        });
      }, [s3, i3, r3];
    }
    var Hn = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Gn, Fn, a2, {parameterOwner: 1});
      }
    };
    function jn(e3) {
      let t3, n3, g3, p3;
      const v3 = e3[3].default, w3 = d2(v3, e3, e3[2], null);
      return {c() {
        t3 = N2("button"), w3 && w3.c(), D2(t3, "class", "ToolbarItem border border-gray-500 shadow cursor-default rounded transform hover:scale-105 transition-all h-10 w-10 p-1 bg-background bg-opacity-40 hover:opacity-100"), D2(t3, "title", e3[1]), J2(t3, "ring-4", e3[0]), J2(t3, "ring-primary", e3[0]);
      }, m(i3, s3) {
        I2(i3, t3, s3), w3 && w3.m(t3, null), n3 = true, g3 || (p3 = C2(t3, "click", e3[4]), g3 = true);
      }, p(e4, [i3]) {
        w3 && w3.p && (!n3 || 4 & i3) && g2(w3, v3, e4, e4[2], n3 ? m2(v3, e4[2], i3, null) : $2(e4[2]), null), (!n3 || 2 & i3) && D2(t3, "title", e4[1]), 1 & i3 && J2(t3, "ring-4", e4[0]), 1 & i3 && J2(t3, "ring-primary", e4[0]);
      }, i(e4) {
        n3 || (St(w3, e4), n3 = true);
      }, o(e4) {
        Lt(w3, e4), n3 = false;
      }, d(e4) {
        e4 && S2(t3), w3 && w3.d(e4), g3 = false, p3();
      }};
    }
    function Zn(e3, t3, n3) {
      let {$$slots: i3 = {}, $$scope: s3} = t3, {isHighlighted: r3 = false} = t3, {title: a3 = ""} = t3;
      return e3.$$set = (e4) => {
        "isHighlighted" in e4 && n3(0, r3 = e4.isHighlighted), "title" in e4 && n3(1, a3 = e4.title), "$$scope" in e4 && n3(2, s3 = e4.$$scope);
      }, [r3, a3, s3, i3, function(t4) {
        lt.call(this, e3, t4);
      }];
    }
    var Jn = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Zn, jn, a2, {isHighlighted: 0, title: 1});
      }
    };
    var Kn = (e3) => ({});
    var Wn = (e3) => ({});
    function Yn(e3) {
      let t3;
      const n3 = e3[4].default, s3 = d2(n3, e3, e3[5], null);
      return {c() {
        s3 && s3.c();
      }, m(e4, n4) {
        s3 && s3.m(e4, n4), t3 = true;
      }, p(e4, i3) {
        s3 && s3.p && (!t3 || 32 & i3) && g2(s3, n3, e4, e4[5], t3 ? m2(n3, e4[5], i3, null) : $2(e4[5]), null);
      }, i(e4) {
        t3 || (St(s3, e4), t3 = true);
      }, o(e4) {
        Lt(s3, e4), t3 = false;
      }, d(e4) {
        s3 && s3.d(e4);
      }};
    }
    function qn(e3) {
      let t3, n3, l3, g3, v3;
      n3 = new Jn({props: {isHighlighted: e3[1], title: e3[2], $$slots: {default: [Yn]}, $$scope: {ctx: e3}}}), n3.$on("click", e3[3]);
      const b3 = e3[4].popup, _3 = d2(b3, e3, e3[5], Wn);
      return {c() {
        t3 = N2("button"), Bt2(n3.$$.fragment), l3 = A2(), g3 = N2("div"), _3 && _3.c(), J2(g3, "hidden", !e3[0]), D2(t3, "class", "ToolbarItemPopup relative");
      }, m(e4, i3) {
        I2(e4, t3, i3), Dt(n3, t3, null), E2(t3, l3), E2(t3, g3), _3 && _3.m(g3, null), v3 = true;
      }, p(e4, [t4]) {
        const i3 = {};
        2 & t4 && (i3.isHighlighted = e4[1]), 4 & t4 && (i3.title = e4[2]), 32 & t4 && (i3.$$scope = {dirty: t4, ctx: e4}), n3.$set(i3), _3 && _3.p && (!v3 || 32 & t4) && g2(_3, b3, e4, e4[5], v3 ? m2(b3, e4[5], t4, Kn) : $2(e4[5]), Wn), 1 & t4 && J2(g3, "hidden", !e4[0]);
      }, i(e4) {
        v3 || (St(n3.$$.fragment, e4), St(_3, e4), v3 = true);
      }, o(e4) {
        Lt(n3.$$.fragment, e4), Lt(_3, e4), v3 = false;
      }, d(e4) {
        e4 && S2(t3), Ut(n3), _3 && _3.d(e4);
      }};
    }
    function Qn(e3, t3, n3) {
      let {$$slots: i3 = {}, $$scope: s3} = t3, {isHighlighted: r3 = false} = t3, {isOpen: a3 = false} = t3, {title: o3 = ""} = t3;
      const l3 = () => {
        n3(0, a3 = false), window.removeEventListener("click", l3);
      };
      return e3.$$set = (e4) => {
        "isHighlighted" in e4 && n3(1, r3 = e4.isHighlighted), "isOpen" in e4 && n3(0, a3 = e4.isOpen), "title" in e4 && n3(2, o3 = e4.title), "$$scope" in e4 && n3(5, s3 = e4.$$scope);
      }, [a3, r3, o3, (e4) => {
        e4.stopPropagation(), n3(0, a3 = !a3), window.addEventListener("click", l3);
      }, i3, s3];
    }
    var ei2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Qn, qn, a2, {isHighlighted: 1, isOpen: 0, title: 2});
      }
    };
    function ti2(e3) {
      let t3, n3, i3, s3, a3, l3, h3, c3, d3, u3, f3, g3, p3;
      return {c() {
        t3 = R2("svg"), n3 = R2("clipPath"), i3 = R2("path"), s3 = R2("g"), a3 = R2("path"), l3 = R2("path"), h3 = R2("path"), c3 = R2("path"), d3 = R2("path"), u3 = R2("path"), f3 = R2("path"), g3 = R2("path"), p3 = R2("path"), D2(i3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0l0 -108.94751z"), D2(i3, "clip-rule", "nonzero"), D2(n3, "id", "p.0"), D2(a3, "fill", "#000000"), D2(a3, "fill-opacity", "0.0"), D2(a3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0z"), D2(a3, "fill-rule", "evenodd"), D2(l3, "fill", "#f9ce03"), D2(l3, "d", "m13.020997 56.51719l0 0c0 -3.5631065 2.8884678 -6.4515724 6.4515734 -6.4515724l75.978745 0c1.7110596 0 3.3520432 0.679718 4.5619507 1.8896217c1.2098999 1.2099037 1.8896179 2.8508873 1.8896179 4.5619507l0 25.80552c0 3.5631027 -2.888466 6.4515686 -6.4515686 6.4515686l-75.978745 0l0 0c-3.5631056 0 -6.4515734 -2.888466 -6.4515734 -6.4515686z"), D2(l3, "fill-rule", "evenodd"), D2(h3, "stroke", "#000000"), D2(h3, "stroke-width", "3.0"), D2(h3, "stroke-linejoin", "round"), D2(h3, "stroke-linecap", "butt"), D2(h3, "d", "m13.020997 56.51719l0 0c0 -3.5631065 2.8884678 -6.4515724 6.4515734 -6.4515724l75.978745 0c1.7110596 0 3.3520432 0.679718 4.5619507 1.8896217c1.2098999 1.2099037 1.8896179 2.8508873 1.8896179 4.5619507l0 25.80552c0 3.5631027 -2.888466 6.4515686 -6.4515686 6.4515686l-75.978745 0l0 0c-3.5631056 0 -6.4515734 -2.888466 -6.4515734 -6.4515686z"), D2(h3, "fill-rule", "evenodd"), D2(c3, "fill", "#000000"), D2(c3, "fill-opacity", "0.0"), D2(c3, "d", "m31.444708 33.401573l57.16535 0"), D2(c3, "fill-rule", "evenodd"), D2(d3, "stroke", "#000000"), D2(d3, "stroke-width", "3.0"), D2(d3, "stroke-linejoin", "round"), D2(d3, "stroke-linecap", "butt"), D2(d3, "d", "m31.444708 33.401573l57.16535 0"), D2(d3, "fill-rule", "evenodd"), D2(u3, "fill", "#f9ce03"), D2(u3, "d", "m82.81548 27.070866l19.086617 6.3307076l-19.086617 6.3307114z"), D2(u3, "fill-rule", "evenodd"), D2(f3, "stroke", "#000000"), D2(f3, "stroke-width", "3.0"), D2(f3, "stroke-linejoin", "round"), D2(f3, "stroke-linecap", "butt"), D2(f3, "d", "m82.81548 27.070866l19.086617 6.3307076l-19.086617 6.3307114z"), D2(f3, "fill-rule", "evenodd"), D2(g3, "fill", "#f9ce03"), D2(g3, "d", "m31.444708 39.732285l-19.086615 -6.3307114l19.086615 -6.3307076z"), D2(g3, "fill-rule", "evenodd"), D2(p3, "stroke", "#000000"), D2(p3, "stroke-width", "3.0"), D2(p3, "stroke-linejoin", "round"), D2(p3, "stroke-linecap", "butt"), D2(p3, "d", "m31.444708 39.732285l-19.086615 -6.3307114l19.086615 -6.3307076z"), D2(p3, "fill-rule", "evenodd"), D2(s3, "clip-path", "url(#p.0)"), D2(t3, "version", "1.1"), D2(t3, "viewBox", "0.0 0.0 108.9238845144357 108.94750656167979"), D2(t3, "fill", "none"), D2(t3, "stroke", "none"), D2(t3, "stroke-linecap", "square"), D2(t3, "stroke-miterlimit", "10"), D2(t3, "xmlns:xlink", "http://www.w3.org/1999/xlink"), D2(t3, "xmlns", "http://www.w3.org/2000/svg");
      }, m(e4, r3) {
        I2(e4, t3, r3), E2(t3, n3), E2(n3, i3), E2(t3, s3), E2(s3, a3), E2(s3, l3), E2(s3, h3), E2(s3, c3), E2(s3, d3), E2(s3, u3), E2(s3, f3), E2(s3, g3), E2(s3, p3);
      }, p: t2, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    var ni2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, null, ti2, a2, {});
      }
    };
    function ii2(e3) {
      let t3, n3, i3, s3, a3, l3, h3, c3, d3, u3, f3, g3, p3, v3, b3;
      return {c() {
        t3 = R2("svg"), n3 = R2("clipPath"), i3 = R2("path"), s3 = R2("g"), a3 = R2("path"), l3 = R2("path"), h3 = R2("path"), c3 = R2("path"), d3 = R2("path"), u3 = R2("path"), f3 = R2("path"), g3 = R2("path"), p3 = R2("path"), v3 = R2("path"), b3 = R2("path"), D2(i3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0l0 -108.94751z"), D2(i3, "clip-rule", "nonzero"), D2(n3, "id", "p.0"), D2(a3, "fill", "#000000"), D2(a3, "fill-opacity", "0.0"), D2(a3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0z"), D2(a3, "fill-rule", "evenodd"), D2(l3, "fill", "#000000"), D2(l3, "fill-opacity", "0.0"), D2(l3, "d", "m31.444708 81.40157l57.16535 0"), D2(l3, "fill-rule", "evenodd"), D2(h3, "stroke", "#000000"), D2(h3, "stroke-width", "3.0"), D2(h3, "stroke-linejoin", "round"), D2(h3, "stroke-linecap", "butt"), D2(h3, "d", "m31.444708 81.40157l57.16535 0"), D2(h3, "fill-rule", "evenodd"), D2(c3, "fill", "#f9ce03"), D2(c3, "d", "m78.59998 63.178192l11.307091 18.566933l-21.763786 -0.51969147z"), D2(c3, "fill-rule", "evenodd"), D2(d3, "stroke", "#000000"), D2(d3, "stroke-width", "3.0"), D2(d3, "stroke-linejoin", "round"), D2(d3, "stroke-linecap", "butt"), D2(d3, "d", "m78.59998 63.178192l11.307091 18.566933l-21.763786 -0.51969147z"), D2(d3, "fill-rule", "evenodd"), D2(u3, "fill", "#f9ce03"), D2(u3, "d", "m21.238846 81.40157l0 0c0 -2.817955 2.2844048 -5.1023636 5.1023617 -5.1023636l0 0c1.3532295 0 2.6510353 0.53757477 3.607914 1.4944534c0.95687866 0.95687866 1.4944477 2.2546844 1.4944477 3.6079102l0 0c0 2.817955 -2.2844048 5.1023636 -5.1023617 5.1023636l0 0c-2.817957 0 -5.1023617 -2.2844086 -5.1023617 -5.1023636z"), D2(u3, "fill-rule", "evenodd"), D2(f3, "stroke", "#000000"), D2(f3, "stroke-width", "3.0"), D2(f3, "stroke-linejoin", "round"), D2(f3, "stroke-linecap", "butt"), D2(f3, "d", "m21.238846 81.40157l0 0c0 -2.817955 2.2844048 -5.1023636 5.1023617 -5.1023636l0 0c1.3532295 0 2.6510353 0.53757477 3.607914 1.4944534c0.95687866 0.95687866 1.4944477 2.2546844 1.4944477 3.6079102l0 0c0 2.817955 -2.2844048 5.1023636 -5.1023617 5.1023636l0 0c-2.817957 0 -5.1023617 -2.2844086 -5.1023617 -5.1023636z"), D2(f3, "fill-rule", "evenodd"), D2(g3, "fill", "#000000"), D2(g3, "fill-opacity", "0.0"), D2(g3, "d", "m60.99301 31.920135l28.566933 49.480316"), D2(g3, "fill-rule", "evenodd"), D2(p3, "stroke", "#000000"), D2(p3, "stroke-width", "3.0"), D2(p3, "stroke-linejoin", "round"), D2(p3, "stroke-linecap", "butt"), D2(p3, "d", "m60.99301 31.920135l28.566933 49.480316"), D2(p3, "fill-rule", "evenodd"), D2(v3, "fill", "#f9ce03"), D2(v3, "d", "m55.899406 23.0816l0 0c2.4352722 -1.4089794 5.551651 -0.5770035 6.9606323 1.8582668l0 0c0.67661285 1.1694584 0.86095047 2.559805 0.5124588 3.8651752c-0.34849167 1.3053722 -1.201271 2.4188404 -2.3707275 3.0954552l0 0c-2.4352722 1.4089775 -5.551651 0.5770035 -6.9606285 -1.8582668l0 0c-1.4089813 -2.4352722 -0.5770073 -5.551653 1.8582649 -6.9606304z"), D2(v3, "fill-rule", "evenodd"), D2(b3, "stroke", "#000000"), D2(b3, "stroke-width", "3.0"), D2(b3, "stroke-linejoin", "round"), D2(b3, "stroke-linecap", "butt"), D2(b3, "d", "m55.899406 23.0816l0 0c2.4352722 -1.4089794 5.551651 -0.5770035 6.9606323 1.8582668l0 0c0.67661285 1.1694584 0.86095047 2.559805 0.5124588 3.8651752c-0.34849167 1.3053722 -1.201271 2.4188404 -2.3707275 3.0954552l0 0c-2.4352722 1.4089775 -5.551651 0.5770035 -6.9606285 -1.8582668l0 0c-1.4089813 -2.4352722 -0.5770073 -5.551653 1.8582649 -6.9606304z"), D2(b3, "fill-rule", "evenodd"), D2(s3, "clip-path", "url(#p.0)"), D2(t3, "version", "1.1"), D2(t3, "viewBox", "0.0 0.0 108.9238845144357 108.94750656167979"), D2(t3, "fill", "none"), D2(t3, "stroke", "none"), D2(t3, "stroke-linecap", "square"), D2(t3, "stroke-miterlimit", "10"), D2(t3, "xmlns:xlink", "http://www.w3.org/1999/xlink"), D2(t3, "xmlns", "http://www.w3.org/2000/svg");
      }, m(e4, r3) {
        I2(e4, t3, r3), E2(t3, n3), E2(n3, i3), E2(t3, s3), E2(s3, a3), E2(s3, l3), E2(s3, h3), E2(s3, c3), E2(s3, d3), E2(s3, u3), E2(s3, f3), E2(s3, g3), E2(s3, p3), E2(s3, v3), E2(s3, b3);
      }, p: t2, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    var si2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, null, ii2, a2, {});
      }
    };
    function ri2(e3) {
      let t3, n3, i3, s3, a3, l3, h3, c3, d3, u3, f3, g3, p3, v3, b3, y3, I3, x3, P3, C3, k3, T3, A3;
      return {c() {
        t3 = R2("svg"), n3 = R2("clipPath"), i3 = R2("path"), s3 = R2("g"), a3 = R2("path"), l3 = R2("path"), h3 = R2("path"), c3 = R2("path"), d3 = R2("path"), u3 = R2("path"), f3 = R2("path"), g3 = R2("path"), p3 = R2("path"), v3 = R2("path"), b3 = R2("path"), y3 = R2("path"), I3 = R2("path"), x3 = R2("path"), P3 = R2("path"), C3 = R2("path"), k3 = R2("path"), T3 = R2("path"), A3 = R2("path"), D2(i3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0l0 -108.94751z"), D2(i3, "clip-rule", "nonzero"), D2(n3, "id", "p.0"), D2(a3, "fill", "#000000"), D2(a3, "fill-opacity", "0.0"), D2(a3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0z"), D2(a3, "fill-rule", "evenodd"), D2(l3, "fill", "#000000"), D2(l3, "fill-opacity", "0.0"), D2(l3, "d", "m44.812416 33.401573l26.362206 0"), D2(l3, "fill-rule", "evenodd"), D2(h3, "stroke", "#000000"), D2(h3, "stroke-width", "3.0"), D2(h3, "stroke-linejoin", "round"), D2(h3, "stroke-linecap", "butt"), D2(h3, "d", "m44.812416 33.401573l26.362206 0"), D2(h3, "fill-rule", "evenodd"), D2(c3, "fill", "#f9ce03"), D2(c3, "d", "m71.15952 27.070866l19.086617 6.3307076l-19.086617 6.3307114z"), D2(c3, "fill-rule", "evenodd"), D2(d3, "stroke", "#000000"), D2(d3, "stroke-width", "3.0"), D2(d3, "stroke-linejoin", "round"), D2(d3, "stroke-linecap", "butt"), D2(d3, "d", "m71.15952 27.070866l19.086617 6.3307076l-19.086617 6.3307114z"), D2(d3, "fill-rule", "evenodd"), D2(u3, "fill", "#f9ce03"), D2(u3, "d", "m44.812416 39.732285l-19.086613 -6.3307114l19.086613 -6.3307076z"), D2(u3, "fill-rule", "evenodd"), D2(f3, "stroke", "#000000"), D2(f3, "stroke-width", "3.0"), D2(f3, "stroke-linejoin", "round"), D2(f3, "stroke-linecap", "butt"), D2(f3, "d", "m44.812416 39.732285l-19.086613 -6.3307114l19.086613 -6.3307076z"), D2(f3, "fill-rule", "evenodd"), D2(g3, "fill", "#f9ce03"), D2(g3, "d", "m7.0835776 68.06037l0 0c0 3.1136627 8.171684 5.6377945 18.251968 5.6377945c10.080282 0 18.251966 -2.5241318 18.251966 -5.6377945l0 11.275589c0 3.1136627 -8.171684 5.6377945 -18.251966 5.6377945c-10.080284 0 -18.251968 -2.5241318 -18.251968 -5.6377945z"), D2(g3, "fill-rule", "evenodd"), D2(p3, "fill", "#fbe167"), D2(p3, "d", "m7.0835776 68.06037l0 0c0 -3.1136703 8.171684 -5.6377983 18.251968 -5.6377983c10.080282 0 18.251966 2.524128 18.251966 5.6377983l0 0c0 3.1136627 -8.171684 5.6377945 -18.251966 5.6377945c-10.080284 0 -18.251968 -2.5241318 -18.251968 -5.6377945z"), D2(p3, "fill-rule", "evenodd"), D2(v3, "fill", "#000000"), D2(v3, "fill-opacity", "0.0"), D2(v3, "d", "m43.587513 68.06037l0 0c0 3.1136627 -8.171684 5.6377945 -18.251966 5.6377945c-10.080284 0 -18.251968 -2.5241318 -18.251968 -5.6377945l0 0c0 -3.1136703 8.171684 -5.6377983 18.251968 -5.6377983c10.080282 0 18.251966 2.524128 18.251966 5.6377983l0 11.275589c0 3.1136627 -8.171684 5.6377945 -18.251966 5.6377945c-10.080284 0 -18.251968 -2.5241318 -18.251968 -5.6377945l0 -11.275589"), D2(v3, "fill-rule", "evenodd"), D2(b3, "stroke", "#000000"), D2(b3, "stroke-width", "2.0"), D2(b3, "stroke-linejoin", "round"), D2(b3, "stroke-linecap", "butt"), D2(b3, "d", "m43.587513 68.06037l0 0c0 3.1136627 -8.171684 5.6377945 -18.251966 5.6377945c-10.080284 0 -18.251968 -2.5241318 -18.251968 -5.6377945l0 0c0 -3.1136703 8.171684 -5.6377983 18.251968 -5.6377983c10.080282 0 18.251966 2.524128 18.251966 5.6377983l0 11.275589c0 3.1136627 -8.171684 5.6377945 -18.251966 5.6377945c-10.080284 0 -18.251968 -2.5241318 -18.251968 -5.6377945l0 -11.275589"), D2(b3, "fill-rule", "evenodd"), D2(y3, "fill", "#f9ce03"), D2(y3, "d", "m78.23173 69.87139l0 0c0 2.1221619 5.5559006 3.8425217 12.409454 3.8425217c6.853546 0 12.409447 -1.7203598 12.409447 -3.8425217l0 7.6850357c0 2.1221695 -5.5559006 3.8425217 -12.409447 3.8425217c-6.853554 0 -12.409454 -1.7203522 -12.409454 -3.8425217z"), D2(y3, "fill-rule", "evenodd"), D2(I3, "fill", "#fbe167"), D2(I3, "d", "m78.23173 69.87139l0 0c0 -2.1221619 5.5559006 -3.8425217 12.409454 -3.8425217c6.853546 0 12.409447 1.7203598 12.409447 3.8425217l0 0c0 2.1221619 -5.5559006 3.8425217 -12.409447 3.8425217c-6.853554 0 -12.409454 -1.7203598 -12.409454 -3.8425217z"), D2(I3, "fill-rule", "evenodd"), D2(x3, "fill", "#000000"), D2(x3, "fill-opacity", "0.0"), D2(x3, "d", "m103.05063 69.87139l0 0c0 2.1221619 -5.5559006 3.8425217 -12.409447 3.8425217c-6.853554 0 -12.409454 -1.7203598 -12.409454 -3.8425217l0 0c0 -2.1221619 5.5559006 -3.8425217 12.409454 -3.8425217c6.853546 0 12.409447 1.7203598 12.409447 3.8425217l0 7.6850357c0 2.1221695 -5.5559006 3.8425217 -12.409447 3.8425217c-6.853554 0 -12.409454 -1.7203522 -12.409454 -3.8425217l0 -7.6850357"), D2(x3, "fill-rule", "evenodd"), D2(P3, "stroke", "#000000"), D2(P3, "stroke-width", "2.0"), D2(P3, "stroke-linejoin", "round"), D2(P3, "stroke-linecap", "butt"), D2(P3, "d", "m103.05063 69.87139l0 0c0 2.1221619 -5.5559006 3.8425217 -12.409447 3.8425217c-6.853554 0 -12.409454 -1.7203598 -12.409454 -3.8425217l0 0c0 -2.1221619 5.5559006 -3.8425217 12.409454 -3.8425217c6.853546 0 12.409447 1.7203598 12.409447 3.8425217l0 7.6850357c0 2.1221695 -5.5559006 3.8425217 -12.409447 3.8425217c-6.853554 0 -12.409454 -1.7203522 -12.409454 -3.8425217l0 -7.6850357"), D2(P3, "fill-rule", "evenodd"), D2(C3, "fill", "#000000"), D2(C3, "fill-opacity", "0.0"), D2(C3, "d", "m25.448423 67.05249l0 -33.63779"), D2(C3, "fill-rule", "evenodd"), D2(k3, "stroke", "#000000"), D2(k3, "stroke-width", "2.0"), D2(k3, "stroke-linejoin", "round"), D2(k3, "stroke-linecap", "butt"), D2(k3, "stroke-dasharray", "8.0,6.0"), D2(k3, "d", "m25.448423 67.05249l0 -33.63779"), D2(k3, "fill-rule", "evenodd"), D2(T3, "fill", "#000000"), D2(T3, "fill-opacity", "0.0"), D2(T3, "d", "m90.763084 67.05249l0 -33.63779"), D2(T3, "fill-rule", "evenodd"), D2(A3, "stroke", "#000000"), D2(A3, "stroke-width", "2.0"), D2(A3, "stroke-linejoin", "round"), D2(A3, "stroke-linecap", "butt"), D2(A3, "stroke-dasharray", "8.0,6.0"), D2(A3, "d", "m90.763084 67.05249l0 -33.63779"), D2(A3, "fill-rule", "evenodd"), D2(s3, "clip-path", "url(#p.0)"), D2(t3, "version", "1.1"), D2(t3, "viewBox", "0.0 0.0 108.9238845144357 108.94750656167979"), D2(t3, "fill", "none"), D2(t3, "stroke", "none"), D2(t3, "stroke-linecap", "square"), D2(t3, "stroke-miterlimit", "10"), D2(t3, "xmlns:xlink", "http://www.w3.org/1999/xlink"), D2(t3, "xmlns", "http://www.w3.org/2000/svg");
      }, m(e4, r3) {
        I2(e4, t3, r3), E2(t3, n3), E2(n3, i3), E2(t3, s3), E2(s3, a3), E2(s3, l3), E2(s3, h3), E2(s3, c3), E2(s3, d3), E2(s3, u3), E2(s3, f3), E2(s3, g3), E2(s3, p3), E2(s3, v3), E2(s3, b3), E2(s3, y3), E2(s3, I3), E2(s3, x3), E2(s3, P3), E2(s3, C3), E2(s3, k3), E2(s3, T3), E2(s3, A3);
      }, p: t2, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    var ai2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, null, ri2, a2, {});
      }
    };
    function oi2(e3) {
      let t3, n3, i3, s3, a3, l3, h3, c3, d3, u3, f3, g3, p3, v3, b3;
      return {c() {
        t3 = R2("svg"), n3 = R2("clipPath"), i3 = R2("path"), s3 = R2("g"), a3 = R2("path"), l3 = R2("path"), h3 = R2("path"), c3 = R2("path"), d3 = R2("path"), u3 = R2("path"), f3 = R2("path"), g3 = R2("path"), p3 = R2("path"), v3 = R2("path"), b3 = R2("path"), D2(i3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0l0 -108.94751z"), D2(i3, "clip-rule", "nonzero"), D2(n3, "id", "p.0"), D2(a3, "fill", "#000000"), D2(a3, "fill-opacity", "0.0"), D2(a3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0z"), D2(a3, "fill-rule", "evenodd"), D2(l3, "fill", "#f9ce03"), D2(l3, "d", "m10.385827 41.390194l0 0c0 7.7189407 20.214169 13.976379 45.14961 13.976379c24.935436 0 45.1496 -6.2574387 45.1496 -13.976379l0 27.952755c0 7.7189407 -20.214165 13.976379 -45.1496 13.976379c-24.93544 0 -45.14961 -6.2574387 -45.14961 -13.976379z"), D2(l3, "fill-rule", "evenodd"), D2(h3, "fill", "#fbe167"), D2(h3, "d", "m10.385827 41.390194l0 0c0 -7.7189407 20.214169 -13.9763775 45.14961 -13.9763775c24.935436 0 45.1496 6.2574368 45.1496 13.9763775l0 0c0 7.7189407 -20.214165 13.976379 -45.1496 13.976379c-24.93544 0 -45.14961 -6.2574387 -45.14961 -13.976379z"), D2(h3, "fill-rule", "evenodd"), D2(c3, "fill", "#000000"), D2(c3, "fill-opacity", "0.0"), D2(c3, "d", "m100.685036 41.390194l0 0c0 7.7189407 -20.214165 13.976379 -45.1496 13.976379c-24.93544 0 -45.14961 -6.2574387 -45.14961 -13.976379l0 0c0 -7.7189407 20.214169 -13.9763775 45.14961 -13.9763775c24.935436 0 45.1496 6.2574368 45.1496 13.9763775l0 27.952755c0 7.7189407 -20.214165 13.976379 -45.1496 13.976379c-24.93544 0 -45.14961 -6.2574387 -45.14961 -13.976379l0 -27.952755"), D2(c3, "fill-rule", "evenodd"), D2(d3, "stroke", "#000000"), D2(d3, "stroke-width", "2.0"), D2(d3, "stroke-linejoin", "round"), D2(d3, "stroke-linecap", "butt"), D2(d3, "d", "m100.685036 41.390194l0 0c0 7.7189407 -20.214165 13.976379 -45.1496 13.976379c-24.93544 0 -45.14961 -6.2574387 -45.14961 -13.976379l0 0c0 -7.7189407 20.214169 -13.9763775 45.14961 -13.9763775c24.935436 0 45.1496 6.2574368 45.1496 13.9763775l0 27.952755c0 7.7189407 -20.214165 13.976379 -45.1496 13.976379c-24.93544 0 -45.14961 -6.2574387 -45.14961 -13.976379l0 -27.952755"), D2(d3, "fill-rule", "evenodd"), D2(u3, "fill", "#000000"), D2(u3, "fill-opacity", "0.0"), D2(u3, "d", "m55.719162 40.670383l32.88189 0"), D2(u3, "fill-rule", "evenodd"), D2(f3, "stroke", "#000000"), D2(f3, "stroke-width", "3.0"), D2(f3, "stroke-linejoin", "round"), D2(f3, "stroke-linecap", "butt"), D2(f3, "d", "m55.719162 40.670383l32.88189 0"), D2(f3, "fill-rule", "evenodd"), D2(g3, "fill", "#f9ce03"), D2(g3, "d", "m84.94488 35.749123l14.8346405 4.9291344l-14.8346405 4.9291344z"), D2(g3, "fill-rule", "evenodd"), D2(p3, "stroke", "#000000"), D2(p3, "stroke-width", "3.0"), D2(p3, "stroke-linejoin", "round"), D2(p3, "stroke-linecap", "butt"), D2(p3, "d", "m84.94488 35.749123l14.8346405 4.9291344l-14.8346405 4.9291344z"), D2(p3, "fill-rule", "evenodd"), D2(v3, "fill", "#f9ce03"), D2(v3, "d", "m51.771652 40.670383l0 0c0 -2.1830482 1.7697105 -3.952755 3.9527588 -3.952755l0 0c1.048336 0 2.0537338 0.4164505 2.7950172 1.1577339c0.74128723 0.74128723 1.1577377 1.746685 1.1577377 2.795021l0 0c0 2.1830482 -1.7697105 3.952755 -3.952755 3.952755l0 0c-2.1830482 0 -3.9527588 -1.7697067 -3.9527588 -3.952755z"), D2(v3, "fill-rule", "evenodd"), D2(b3, "stroke", "#000000"), D2(b3, "stroke-width", "3.0"), D2(b3, "stroke-linejoin", "round"), D2(b3, "stroke-linecap", "butt"), D2(b3, "d", "m51.771652 40.670383l0 0c0 -2.1830482 1.7697105 -3.952755 3.9527588 -3.952755l0 0c1.048336 0 2.0537338 0.4164505 2.7950172 1.1577339c0.74128723 0.74128723 1.1577377 1.746685 1.1577377 2.795021l0 0c0 2.1830482 -1.7697105 3.952755 -3.952755 3.952755l0 0c-2.1830482 0 -3.9527588 -1.7697067 -3.9527588 -3.952755z"), D2(b3, "fill-rule", "evenodd"), D2(s3, "clip-path", "url(#p.0)"), D2(t3, "version", "1.1"), D2(t3, "viewBox", "0.0 0.0 108.9238845144357 108.94750656167979"), D2(t3, "fill", "none"), D2(t3, "stroke", "none"), D2(t3, "stroke-linecap", "square"), D2(t3, "stroke-miterlimit", "10"), D2(t3, "xmlns:xlink", "http://www.w3.org/1999/xlink"), D2(t3, "xmlns", "http://www.w3.org/2000/svg");
      }, m(e4, r3) {
        I2(e4, t3, r3), E2(t3, n3), E2(n3, i3), E2(t3, s3), E2(s3, a3), E2(s3, l3), E2(s3, h3), E2(s3, c3), E2(s3, d3), E2(s3, u3), E2(s3, f3), E2(s3, g3), E2(s3, p3), E2(s3, v3), E2(s3, b3);
      }, p: t2, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    var li2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, null, oi2, a2, {});
      }
    };
    function hi2(e3) {
      let t3, n3, i3, s3, a3, l3, h3, c3, d3, u3, f3, g3, p3, v3, b3, y3, I3, x3;
      return {c() {
        t3 = R2("svg"), n3 = R2("clipPath"), i3 = R2("path"), s3 = R2("g"), a3 = R2("path"), l3 = R2("path"), h3 = R2("path"), c3 = R2("path"), d3 = R2("path"), u3 = R2("path"), f3 = R2("path"), g3 = R2("path"), p3 = R2("path"), v3 = R2("path"), b3 = R2("path"), y3 = R2("path"), I3 = R2("path"), x3 = R2("path"), D2(i3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0l0 -108.94751z"), D2(i3, "clip-rule", "nonzero"), D2(n3, "id", "p.0"), D2(a3, "fill", "#000000"), D2(a3, "fill-opacity", "0.0"), D2(a3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0z"), D2(a3, "fill-rule", "evenodd"), D2(l3, "fill", "#000000"), D2(l3, "fill-opacity", "0.0"), D2(l3, "d", "m7.0183725 30.921259l69.35433 0l0 69.35433l-69.35433 0z"), D2(l3, "fill-rule", "evenodd"), D2(h3, "fill", "#000000"), D2(h3, "fill-opacity", "0.0"), D2(h3, "d", "m76.3727 30.921259l23.11811 -23.118109l0 69.35433l-23.11811 23.11811z"), D2(h3, "fill-rule", "evenodd"), D2(c3, "fill", "#000000"), D2(c3, "fill-opacity", "0.0"), D2(c3, "d", "m7.0183725 30.921259l23.11811 -23.118109l69.35433 0l-23.11811 23.118109z"), D2(c3, "fill-rule", "evenodd"), D2(d3, "fill", "#000000"), D2(d3, "fill-opacity", "0.0"), D2(d3, "d", "m7.0183725 30.921259l23.11811 -23.118109l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.118109m-23.11811 23.118109l0 69.35433"), D2(d3, "fill-rule", "evenodd"), D2(u3, "fill", "#000000"), D2(u3, "fill-opacity", "0.2"), D2(u3, "d", "m76.3727 30.921259l23.11811 -23.118109l0 69.35433l-23.11811 23.11811z"), D2(u3, "fill-rule", "evenodd"), D2(f3, "fill", "#ffffff"), D2(f3, "fill-opacity", "0.2"), D2(f3, "d", "m7.0183725 30.921259l23.11811 -23.118109l69.35433 0l-23.11811 23.118109z"), D2(f3, "fill-rule", "evenodd"), D2(g3, "stroke", "#000000"), D2(g3, "stroke-width", "4.0"), D2(g3, "stroke-linejoin", "round"), D2(g3, "stroke-linecap", "butt"), D2(g3, "d", "m7.0183725 30.921259l23.11811 -23.118109l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.118109m-23.11811 23.118109l0 69.35433"), D2(g3, "fill-rule", "evenodd"), D2(p3, "fill", "#000000"), D2(p3, "fill-opacity", "0.0"), D2(p3, "d", "m6.9160104 101.20479l25.417322 -25.417328"), D2(p3, "fill-rule", "evenodd"), D2(v3, "stroke", "#000000"), D2(v3, "stroke-width", "3.0"), D2(v3, "stroke-linejoin", "round"), D2(v3, "stroke-linecap", "butt"), D2(v3, "d", "m6.9160104 101.20479l25.417322 -25.417328"), D2(v3, "fill-rule", "evenodd"), D2(b3, "fill", "#000000"), D2(b3, "fill-opacity", "0.0"), D2(b3, "d", "m99.386765 77.27097l-68.125984 0"), D2(b3, "fill-rule", "evenodd"), D2(y3, "stroke", "#000000"), D2(y3, "stroke-width", "3.0"), D2(y3, "stroke-linejoin", "round"), D2(y3, "stroke-linecap", "butt"), D2(y3, "d", "m99.386765 77.27097l-68.125984 0"), D2(y3, "fill-rule", "evenodd"), D2(I3, "fill", "#000000"), D2(I3, "fill-opacity", "0.0"), D2(I3, "d", "m29.96828 8.349007l0 69.13386"), D2(I3, "fill-rule", "evenodd"), D2(x3, "stroke", "#000000"), D2(x3, "stroke-width", "3.0"), D2(x3, "stroke-linejoin", "round"), D2(x3, "stroke-linecap", "butt"), D2(x3, "d", "m29.96828 8.349007l0 69.13386"), D2(x3, "fill-rule", "evenodd"), D2(s3, "clip-path", "url(#p.0)"), D2(t3, "version", "1.1"), D2(t3, "viewBox", "0.0 0.0 108.9238845144357 108.94750656167979"), D2(t3, "fill", "none"), D2(t3, "stroke", "none"), D2(t3, "stroke-linecap", "square"), D2(t3, "stroke-miterlimit", "10"), D2(t3, "xmlns:xlink", "http://www.w3.org/1999/xlink"), D2(t3, "xmlns", "http://www.w3.org/2000/svg");
      }, m(e4, r3) {
        I2(e4, t3, r3), E2(t3, n3), E2(n3, i3), E2(t3, s3), E2(s3, a3), E2(s3, l3), E2(s3, h3), E2(s3, c3), E2(s3, d3), E2(s3, u3), E2(s3, f3), E2(s3, g3), E2(s3, p3), E2(s3, v3), E2(s3, b3), E2(s3, y3), E2(s3, I3), E2(s3, x3);
      }, p: t2, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    var ci2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, null, hi2, a2, {});
      }
    };
    function di2(e3) {
      let t3, n3, i3, s3, a3, l3, h3, c3, d3, u3, f3, g3, p3, v3, b3, y3, I3, x3, P3, C3;
      return {c() {
        t3 = R2("svg"), n3 = R2("clipPath"), i3 = R2("path"), s3 = R2("g"), a3 = R2("path"), l3 = R2("path"), h3 = R2("path"), c3 = R2("path"), d3 = R2("path"), u3 = R2("path"), f3 = R2("path"), g3 = R2("path"), p3 = R2("path"), v3 = R2("path"), b3 = R2("path"), y3 = R2("path"), I3 = R2("path"), x3 = R2("path"), P3 = R2("path"), C3 = R2("path"), D2(i3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0l0 -108.94751z"), D2(i3, "clip-rule", "nonzero"), D2(n3, "id", "p.0"), D2(a3, "fill", "#000000"), D2(a3, "fill-opacity", "0.0"), D2(a3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0z"), D2(a3, "fill-rule", "evenodd"), D2(l3, "fill", "#000000"), D2(l3, "fill-opacity", "0.0"), D2(l3, "d", "m30.911938 7.158131l0 69.5748"), D2(l3, "fill-rule", "evenodd"), D2(h3, "stroke", "#000000"), D2(h3, "stroke-width", "3.0"), D2(h3, "stroke-linejoin", "round"), D2(h3, "stroke-linecap", "butt"), D2(h3, "d", "m30.911938 7.158131l0 69.5748"), D2(h3, "fill-rule", "evenodd"), D2(c3, "fill", "#000000"), D2(c3, "fill-opacity", "0.0"), D2(c3, "d", "m6.6742845 31.222435l69.35433 0l0 69.35433l-69.35433 0z"), D2(c3, "fill-rule", "evenodd"), D2(d3, "fill", "#000000"), D2(d3, "fill-opacity", "0.0"), D2(d3, "d", "m76.02862 31.222435l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(d3, "fill-rule", "evenodd"), D2(u3, "fill", "#000000"), D2(u3, "fill-opacity", "0.0"), D2(u3, "d", "m6.6742845 31.222435l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(u3, "fill-rule", "evenodd"), D2(f3, "fill", "#000000"), D2(f3, "fill-opacity", "0.0"), D2(f3, "d", "m6.6742845 31.222435l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2(f3, "fill-rule", "evenodd"), D2(g3, "fill", "#000000"), D2(g3, "fill-opacity", "0.2"), D2(g3, "d", "m76.02862 31.222435l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(g3, "fill-rule", "evenodd"), D2(p3, "fill", "#ffffff"), D2(p3, "fill-opacity", "0.2"), D2(p3, "d", "m6.6742845 31.222435l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(p3, "fill-rule", "evenodd"), D2(v3, "stroke", "#000000"), D2(v3, "stroke-width", "4.0"), D2(v3, "stroke-linejoin", "round"), D2(v3, "stroke-linecap", "butt"), D2(v3, "d", "m6.6742845 31.222435l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2(v3, "fill-rule", "evenodd"), D2(b3, "class", "viewIconColoredFace"), D2(b3, "d", "m7.8129287 32.24648l67.18111 0l0 67.40158l-67.18111 0z"), D2(b3, "fill-rule", "evenodd"), D2(y3, "stroke", "#000000"), D2(y3, "stroke-width", "1.0"), D2(y3, "stroke-linejoin", "round"), D2(y3, "stroke-linecap", "butt"), D2(y3, "d", "m7.8129287 32.24648l67.18111 0l0 67.40158l-67.18111 0z"), D2(y3, "fill-rule", "evenodd"), D2(I3, "class", "viewIconColoredFace"), D2(I3, "d", "m28.990873 7.5595646l-22.749775 22.97511l68.47466 0.45067215l23.501457 -23.599335z"), D2(I3, "fill-rule", "evenodd"), D2(x3, "stroke", "#000000"), D2(x3, "stroke-width", "3.0"), D2(x3, "stroke-linejoin", "round"), D2(x3, "stroke-linecap", "butt"), D2(x3, "d", "m28.990873 7.5595646l-22.749775 22.97511l68.47466 0.45067215l23.501457 -23.599335z"), D2(x3, "fill-rule", "evenodd"), D2(P3, "class", "viewIconColoredFace"), D2(P3, "d", "m75.39114 31.120354l0.42572784 69.36592l23.830978 -23.618652l0 -69.15306z"), D2(P3, "fill-rule", "evenodd"), D2(C3, "stroke", "#000000"), D2(C3, "stroke-width", "3.0"), D2(C3, "stroke-linejoin", "round"), D2(C3, "stroke-linecap", "butt"), D2(C3, "d", "m75.39114 31.120354l0.42572784 69.36592l23.830978 -23.618652l0 -69.15306z"), D2(C3, "fill-rule", "evenodd"), D2(s3, "clip-path", "url(#p.0)"), D2(t3, "version", "1.1"), D2(t3, "viewBox", "0.0 0.0 108.9238845144357 108.94750656167979"), D2(t3, "fill", "none"), D2(t3, "stroke", "none"), D2(t3, "stroke-linecap", "square"), D2(t3, "stroke-miterlimit", "10"), D2(t3, "xmlns:xlink", "http://www.w3.org/1999/xlink"), D2(t3, "xmlns", "http://www.w3.org/2000/svg");
      }, m(e4, r3) {
        I2(e4, t3, r3), E2(t3, n3), E2(n3, i3), E2(t3, s3), E2(s3, a3), E2(s3, l3), E2(s3, h3), E2(s3, c3), E2(s3, d3), E2(s3, u3), E2(s3, f3), E2(s3, g3), E2(s3, p3), E2(s3, v3), E2(s3, b3), E2(s3, y3), E2(s3, I3), E2(s3, x3), E2(s3, P3), E2(s3, C3);
      }, p: t2, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    var ui2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, null, di2, a2, {});
      }
    };
    function fi2(e3) {
      let t3, n3, i3, s3, a3, l3, h3, c3, d3, u3, f3, g3, p3, v3, b3, y3, I3, x3, P3, C3;
      return {c() {
        t3 = R2("svg"), n3 = R2("clipPath"), i3 = R2("path"), s3 = R2("g"), a3 = R2("path"), l3 = R2("path"), h3 = R2("path"), c3 = R2("path"), d3 = R2("path"), u3 = R2("path"), f3 = R2("path"), g3 = R2("path"), p3 = R2("path"), v3 = R2("path"), b3 = R2("path"), y3 = R2("path"), I3 = R2("path"), x3 = R2("path"), P3 = R2("path"), C3 = R2("path"), D2(i3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0l0 -108.94751z"), D2(i3, "clip-rule", "nonzero"), D2(n3, "id", "p.0"), D2(a3, "fill", "#000000"), D2(a3, "fill-opacity", "0.0"), D2(a3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0z"), D2(a3, "fill-rule", "evenodd"), D2(l3, "fill", "#000000"), D2(l3, "fill-opacity", "0.0"), D2(l3, "d", "m30.911938 7.158131l0 69.5748"), D2(l3, "fill-rule", "evenodd"), D2(h3, "stroke", "#000000"), D2(h3, "stroke-width", "3.0"), D2(h3, "stroke-linejoin", "round"), D2(h3, "stroke-linecap", "butt"), D2(h3, "d", "m30.911938 7.158131l0 69.5748"), D2(h3, "fill-rule", "evenodd"), D2(c3, "fill", "#000000"), D2(c3, "fill-opacity", "0.0"), D2(c3, "d", "m6.6742845 31.222435l69.35433 0l0 69.35433l-69.35433 0z"), D2(c3, "fill-rule", "evenodd"), D2(d3, "fill", "#000000"), D2(d3, "fill-opacity", "0.0"), D2(d3, "d", "m76.02862 31.222435l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(d3, "fill-rule", "evenodd"), D2(u3, "fill", "#000000"), D2(u3, "fill-opacity", "0.0"), D2(u3, "d", "m6.6742845 31.222435l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(u3, "fill-rule", "evenodd"), D2(f3, "fill", "#000000"), D2(f3, "fill-opacity", "0.0"), D2(f3, "d", "m6.6742845 31.222435l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2(f3, "fill-rule", "evenodd"), D2(g3, "fill", "#000000"), D2(g3, "fill-opacity", "0.2"), D2(g3, "d", "m76.02862 31.222435l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(g3, "fill-rule", "evenodd"), D2(p3, "fill", "#ffffff"), D2(p3, "fill-opacity", "0.2"), D2(p3, "d", "m6.6742845 31.222435l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(p3, "fill-rule", "evenodd"), D2(v3, "stroke", "#000000"), D2(v3, "stroke-width", "4.0"), D2(v3, "stroke-linejoin", "round"), D2(v3, "stroke-linecap", "butt"), D2(v3, "d", "m6.6742845 31.222435l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2(v3, "fill-rule", "evenodd"), D2(b3, "fill", "#DDDDDD"), D2(b3, "d", "m7.8129287 32.24648l67.18111 0l0 67.40158l-67.18111 0z"), D2(b3, "fill-rule", "evenodd"), D2(y3, "stroke", "#000000"), D2(y3, "stroke-width", "1.0"), D2(y3, "stroke-linejoin", "round"), D2(y3, "stroke-linecap", "butt"), D2(y3, "d", "m7.8129287 32.24648l67.18111 0l0 67.40158l-67.18111 0z"), D2(y3, "fill-rule", "evenodd"), D2(I3, "fill", "#DDDDDD"), D2(I3, "d", "m28.990873 7.5595646l-22.749775 22.97511l68.47466 0.45067215l23.501457 -23.599335z"), D2(I3, "fill-rule", "evenodd"), D2(x3, "stroke", "#000000"), D2(x3, "stroke-width", "3.0"), D2(x3, "stroke-linejoin", "round"), D2(x3, "stroke-linecap", "butt"), D2(x3, "d", "m28.990873 7.5595646l-22.749775 22.97511l68.47466 0.45067215l23.501457 -23.599335z"), D2(x3, "fill-rule", "evenodd"), D2(P3, "fill", "#DDDDDD"), D2(P3, "d", "m75.39114 31.120354l0.42572784 69.36592l23.830978 -23.618652l0 -69.15306z"), D2(P3, "fill-rule", "evenodd"), D2(C3, "stroke", "#000000"), D2(C3, "stroke-width", "3.0"), D2(C3, "stroke-linejoin", "round"), D2(C3, "stroke-linecap", "butt"), D2(C3, "d", "m75.39114 31.120354l0.42572784 69.36592l23.830978 -23.618652l0 -69.15306z"), D2(C3, "fill-rule", "evenodd"), D2(s3, "clip-path", "url(#p.0)"), D2(t3, "version", "1.1"), D2(t3, "viewBox", "0.0 0.0 108.9238845144357 108.94750656167979"), D2(t3, "fill", "none"), D2(t3, "stroke", "none"), D2(t3, "stroke-linecap", "square"), D2(t3, "stroke-miterlimit", "10"), D2(t3, "xmlns:xlink", "http://www.w3.org/1999/xlink"), D2(t3, "xmlns", "http://www.w3.org/2000/svg");
      }, m(e4, r3) {
        I2(e4, t3, r3), E2(t3, n3), E2(n3, i3), E2(t3, s3), E2(s3, a3), E2(s3, l3), E2(s3, h3), E2(s3, c3), E2(s3, d3), E2(s3, u3), E2(s3, f3), E2(s3, g3), E2(s3, p3), E2(s3, v3), E2(s3, b3), E2(s3, y3), E2(s3, I3), E2(s3, x3), E2(s3, P3), E2(s3, C3);
      }, p: t2, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    var mi2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, null, fi2, a2, {});
      }
    };
    function gi2(e3) {
      let t3, n3, i3, s3, a3, l3, h3, c3, d3, u3, f3, g3, p3, v3, b3, y3, I3, x3, P3, C3, k3, T3, A3, $3, E3, S3, M3;
      return {c() {
        t3 = R2("svg"), n3 = R2("clipPath"), i3 = R2("path"), s3 = R2("g"), a3 = R2("path"), l3 = R2("path"), h3 = R2("path"), c3 = R2("path"), d3 = R2("path"), u3 = R2("path"), f3 = R2("path"), g3 = R2("path"), p3 = R2("path"), v3 = R2("path"), b3 = R2("path"), y3 = R2("path"), I3 = R2("path"), x3 = R2("path"), P3 = R2("path"), C3 = R2("path"), k3 = R2("path"), T3 = R2("path"), A3 = R2("path"), $3 = R2("path"), E3 = R2("path"), S3 = R2("path"), M3 = R2("path"), D2(i3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0l0 -108.94751z"), D2(i3, "clip-rule", "nonzero"), D2(n3, "id", "p.0"), D2(a3, "fill", "#000000"), D2(a3, "fill-opacity", "0.0"), D2(a3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0z"), D2(a3, "fill-rule", "evenodd"), D2(l3, "fill", "#000000"), D2(l3, "fill-opacity", "0.0"), D2(l3, "d", "m6.945533 31.111237l69.35433 0l0 69.35433l-69.35433 0z"), D2(l3, "fill-rule", "evenodd"), D2(h3, "fill", "#000000"), D2(h3, "fill-opacity", "0.0"), D2(h3, "d", "m76.299866 31.111237l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(h3, "fill-rule", "evenodd"), D2(c3, "fill", "#000000"), D2(c3, "fill-opacity", "0.0"), D2(c3, "d", "m6.945533 31.111237l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(c3, "fill-rule", "evenodd"), D2(d3, "fill", "#000000"), D2(d3, "fill-opacity", "0.0"), D2(d3, "d", "m6.945533 31.111237l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2(d3, "fill-rule", "evenodd"), D2(u3, "fill", "#000000"), D2(u3, "fill-opacity", "0.2"), D2(u3, "d", "m76.299866 31.111237l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(u3, "fill-rule", "evenodd"), D2(f3, "fill", "#ffffff"), D2(f3, "fill-opacity", "0.2"), D2(f3, "d", "m6.945533 31.111237l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(f3, "fill-rule", "evenodd"), D2(g3, "stroke", "#000000"), D2(g3, "stroke-width", "4.0"), D2(g3, "stroke-linejoin", "round"), D2(g3, "stroke-linecap", "butt"), D2(g3, "d", "m6.945533 31.111237l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2(g3, "fill-rule", "evenodd"), D2(p3, "fill", "#000000"), D2(p3, "fill-opacity", "0.0"), D2(p3, "d", "m31.183187 7.0469313l0 69.57481"), D2(p3, "fill-rule", "evenodd"), D2(v3, "stroke", "#000000"), D2(v3, "stroke-width", "3.0"), D2(v3, "stroke-linejoin", "round"), D2(v3, "stroke-linecap", "butt"), D2(v3, "d", "m31.183187 7.0469313l0 69.57481"), D2(v3, "fill-rule", "evenodd"), D2(b3, "class", "viewIconFrontFace"), D2(b3, "d", "m8.084177 32.13528l67.18111 0l0 67.401566l-67.18111 0z"), D2(b3, "fill-rule", "evenodd"), D2(y3, "stroke", "#000000"), D2(y3, "stroke-width", "1.0"), D2(y3, "stroke-linejoin", "round"), D2(y3, "stroke-linecap", "butt"), D2(y3, "d", "m8.084177 32.13528l67.18111 0l0 67.401566l-67.18111 0z"), D2(y3, "fill-rule", "evenodd"), D2(I3, "class", "viewIconColoredFace"), D2(I3, "d", "m29.262121 7.4483647l-22.749775 22.97511l68.47466 0.45067215l23.501457 -23.599335z"), D2(I3, "fill-rule", "evenodd"), D2(x3, "stroke", "#000000"), D2(x3, "stroke-width", "1.0"), D2(x3, "stroke-linejoin", "round"), D2(x3, "stroke-linecap", "butt"), D2(x3, "d", "m29.262121 7.4483647l-22.749775 22.97511l68.47466 0.45067215l23.501457 -23.599335z"), D2(x3, "fill-rule", "evenodd"), D2(P3, "class", "viewIconDarkerFace"), D2(P3, "d", "m75.66239 31.009153l0.42572784 69.36592l23.830978 -23.61866l0 -69.15305z"), D2(P3, "fill-rule", "evenodd"), D2(C3, "stroke", "#000000"), D2(C3, "stroke-width", "1.0"), D2(C3, "stroke-linejoin", "round"), D2(C3, "stroke-linecap", "butt"), D2(C3, "d", "m75.66239 31.009153l0.42572784 69.36592l23.830978 -23.61866l0 -69.15305z"), D2(C3, "fill-rule", "evenodd"), D2(k3, "fill", "#000000"), D2(k3, "fill-opacity", "0.0"), D2(k3, "d", "m7.2652955 31.068003l69.35433 0l0 69.35433l-69.35433 0z"), D2(k3, "fill-rule", "evenodd"), D2(T3, "fill", "#000000"), D2(T3, "fill-opacity", "0.0"), D2(T3, "d", "m76.61963 31.068003l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(T3, "fill-rule", "evenodd"), D2(A3, "fill", "#000000"), D2(A3, "fill-opacity", "0.0"), D2(A3, "d", "m7.2652955 31.068003l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(A3, "fill-rule", "evenodd"), D2($3, "fill", "#000000"), D2($3, "fill-opacity", "0.0"), D2($3, "d", "m7.2652955 31.068003l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2($3, "fill-rule", "evenodd"), D2(E3, "fill", "#000000"), D2(E3, "fill-opacity", "0.2"), D2(E3, "d", "m76.61963 31.068003l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(E3, "fill-rule", "evenodd"), D2(S3, "fill", "#ffffff"), D2(S3, "fill-opacity", "0.2"), D2(S3, "d", "m7.2652955 31.068003l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(S3, "fill-rule", "evenodd"), D2(M3, "stroke", "#000000"), D2(M3, "stroke-width", "4.0"), D2(M3, "stroke-linejoin", "round"), D2(M3, "stroke-linecap", "butt"), D2(M3, "d", "m7.2652955 31.068003l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2(M3, "fill-rule", "evenodd"), D2(s3, "clip-path", "url(#p.0)"), D2(t3, "version", "1.1"), D2(t3, "viewBox", "0.0 0.0 108.9238845144357 108.94750656167979"), D2(t3, "fill", "none"), D2(t3, "stroke", "none"), D2(t3, "stroke-linecap", "square"), D2(t3, "stroke-miterlimit", "10"), D2(t3, "xmlns:xlink", "http://www.w3.org/1999/xlink"), D2(t3, "xmlns", "http://www.w3.org/2000/svg");
      }, m(e4, r3) {
        I2(e4, t3, r3), E2(t3, n3), E2(n3, i3), E2(t3, s3), E2(s3, a3), E2(s3, l3), E2(s3, h3), E2(s3, c3), E2(s3, d3), E2(s3, u3), E2(s3, f3), E2(s3, g3), E2(s3, p3), E2(s3, v3), E2(s3, b3), E2(s3, y3), E2(s3, I3), E2(s3, x3), E2(s3, P3), E2(s3, C3), E2(s3, k3), E2(s3, T3), E2(s3, A3), E2(s3, $3), E2(s3, E3), E2(s3, S3), E2(s3, M3);
      }, p: t2, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    var pi2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, null, gi2, a2, {});
      }
    };
    function vi2(e3) {
      let t3, n3, i3, s3, a3, l3, h3, c3, d3, u3, f3, g3, p3, v3, b3, y3, I3, x3, P3, C3, k3, T3, A3, $3, E3, S3, M3, R3, D3, O3, N3, z3, L3, V3, B3, U3, X3, F3, G3, H3, j3, Z3, J3, K3, W3, Y3, q3, Q3;
      return {c() {
        t3 = R2("svg"), n3 = R2("clipPath"), i3 = R2("path"), s3 = R2("g"), a3 = R2("path"), l3 = R2("path"), h3 = R2("path"), c3 = R2("path"), d3 = R2("path"), u3 = R2("path"), f3 = R2("path"), g3 = R2("path"), p3 = R2("path"), v3 = R2("path"), b3 = R2("path"), y3 = R2("path"), I3 = R2("path"), x3 = R2("path"), P3 = R2("path"), C3 = R2("path"), k3 = R2("path"), T3 = R2("path"), A3 = R2("path"), $3 = R2("path"), E3 = R2("path"), S3 = R2("path"), M3 = R2("path"), R3 = R2("path"), D3 = R2("path"), O3 = R2("path"), N3 = R2("path"), z3 = R2("path"), L3 = R2("path"), V3 = R2("path"), B3 = R2("path"), U3 = R2("path"), X3 = R2("path"), F3 = R2("path"), G3 = R2("path"), H3 = R2("path"), j3 = R2("path"), Z3 = R2("path"), J3 = R2("path"), K3 = R2("path"), W3 = R2("path"), Y3 = R2("path"), q3 = R2("path"), Q3 = R2("path"), D2(i3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0l0 -108.94751z"), D2(i3, "clip-rule", "nonzero"), D2(n3, "id", "p.0"), D2(a3, "fill", "#000000"), D2(a3, "fill-opacity", "0.0"), D2(a3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0z"), D2(a3, "fill-rule", "evenodd"), D2(l3, "fill", "#000000"), D2(l3, "fill-opacity", "0.0"), D2(l3, "d", "m6.945533 31.111237l69.35433 0l0 69.35433l-69.35433 0z"), D2(l3, "fill-rule", "evenodd"), D2(h3, "fill", "#000000"), D2(h3, "fill-opacity", "0.0"), D2(h3, "d", "m76.299866 31.111237l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(h3, "fill-rule", "evenodd"), D2(c3, "fill", "#000000"), D2(c3, "fill-opacity", "0.0"), D2(c3, "d", "m6.945533 31.111237l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(c3, "fill-rule", "evenodd"), D2(d3, "fill", "#000000"), D2(d3, "fill-opacity", "0.0"), D2(d3, "d", "m6.945533 31.111237l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2(d3, "fill-rule", "evenodd"), D2(u3, "fill", "#000000"), D2(u3, "fill-opacity", "0.2"), D2(u3, "d", "m76.299866 31.111237l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(u3, "fill-rule", "evenodd"), D2(f3, "fill", "#ffffff"), D2(f3, "fill-opacity", "0.2"), D2(f3, "d", "m6.945533 31.111237l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(f3, "fill-rule", "evenodd"), D2(g3, "stroke", "#000000"), D2(g3, "stroke-width", "4.0"), D2(g3, "stroke-linejoin", "round"), D2(g3, "stroke-linecap", "butt"), D2(g3, "d", "m6.945533 31.111237l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2(g3, "fill-rule", "evenodd"), D2(p3, "fill", "#000000"), D2(p3, "fill-opacity", "0.0"), D2(p3, "d", "m31.183187 7.0469313l0 69.57481"), D2(p3, "fill-rule", "evenodd"), D2(v3, "stroke", "#000000"), D2(v3, "stroke-width", "3.0"), D2(v3, "stroke-linejoin", "round"), D2(v3, "stroke-linecap", "butt"), D2(v3, "d", "m31.183187 7.0469313l0 69.57481"), D2(v3, "fill-rule", "evenodd"), D2(b3, "class", "viewIconFrontFace"), D2(b3, "d", "m8.084177 32.13528l67.18111 0l0 67.401566l-67.18111 0z"), D2(b3, "fill-rule", "evenodd"), D2(y3, "stroke", "#000000"), D2(y3, "stroke-width", "1.0"), D2(y3, "stroke-linejoin", "round"), D2(y3, "stroke-linecap", "butt"), D2(y3, "d", "m8.084177 32.13528l67.18111 0l0 67.401566l-67.18111 0z"), D2(y3, "fill-rule", "evenodd"), D2(I3, "class", "viewIconColoredFace"), D2(I3, "d", "m29.262121 7.4483647l-22.749775 22.97511l68.47466 0.45067215l23.501457 -23.599335z"), D2(I3, "fill-rule", "evenodd"), D2(x3, "stroke", "#000000"), D2(x3, "stroke-width", "1.0"), D2(x3, "stroke-linejoin", "round"), D2(x3, "stroke-linecap", "butt"), D2(x3, "d", "m29.262121 7.4483647l-22.749775 22.97511l68.47466 0.45067215l23.501457 -23.599335z"), D2(x3, "fill-rule", "evenodd"), D2(P3, "class", "viewIconDarkerFace"), D2(P3, "d", "m75.66239 31.009153l0.42572784 69.36592l23.830978 -23.61866l0 -69.15305z"), D2(P3, "fill-rule", "evenodd"), D2(C3, "stroke", "#000000"), D2(C3, "stroke-width", "1.0"), D2(C3, "stroke-linejoin", "round"), D2(C3, "stroke-linecap", "butt"), D2(C3, "d", "m75.66239 31.009153l0.42572784 69.36592l23.830978 -23.61866l0 -69.15305z"), D2(C3, "fill-rule", "evenodd"), D2(k3, "fill", "#000000"), D2(k3, "fill-opacity", "0.0"), D2(k3, "d", "m7.2652955 31.068003l69.35433 0l0 69.35433l-69.35433 0z"), D2(k3, "fill-rule", "evenodd"), D2(T3, "fill", "#000000"), D2(T3, "fill-opacity", "0.0"), D2(T3, "d", "m76.61963 31.068003l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(T3, "fill-rule", "evenodd"), D2(A3, "fill", "#000000"), D2(A3, "fill-opacity", "0.0"), D2(A3, "d", "m7.2652955 31.068003l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(A3, "fill-rule", "evenodd"), D2($3, "fill", "#000000"), D2($3, "fill-opacity", "0.0"), D2($3, "d", "m7.2652955 31.068003l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2($3, "fill-rule", "evenodd"), D2(E3, "fill", "#000000"), D2(E3, "fill-opacity", "0.2"), D2(E3, "d", "m76.61963 31.068003l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(E3, "fill-rule", "evenodd"), D2(S3, "fill", "#ffffff"), D2(S3, "fill-opacity", "0.2"), D2(S3, "d", "m7.2652955 31.068003l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(S3, "fill-rule", "evenodd"), D2(M3, "stroke", "#000000"), D2(M3, "stroke-width", "4.0"), D2(M3, "stroke-linejoin", "round"), D2(M3, "stroke-linecap", "butt"), D2(M3, "d", "m7.2652955 31.068003l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2(M3, "fill-rule", "evenodd"), D2(R3, "fill", "#000000"), D2(R3, "fill-opacity", "0.0"), D2(R3, "d", "m5.7087536 31.953627l69.35433 0l0 69.35433l-69.35433 0z"), D2(R3, "fill-rule", "evenodd"), D2(D3, "fill", "#000000"), D2(D3, "fill-opacity", "0.0"), D2(D3, "d", "m75.06309 31.953627l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(D3, "fill-rule", "evenodd"), D2(O3, "fill", "#000000"), D2(O3, "fill-opacity", "0.0"), D2(O3, "d", "m5.7087536 31.953627l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(O3, "fill-rule", "evenodd"), D2(N3, "fill", "#000000"), D2(N3, "fill-opacity", "0.0"), D2(N3, "d", "m5.7087536 31.953627l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2(N3, "fill-rule", "evenodd"), D2(z3, "fill", "#000000"), D2(z3, "fill-opacity", "0.2"), D2(z3, "d", "m75.06309 31.953627l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(z3, "fill-rule", "evenodd"), D2(L3, "fill", "#ffffff"), D2(L3, "fill-opacity", "0.2"), D2(L3, "d", "m5.7087536 31.953627l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(L3, "fill-rule", "evenodd"), D2(V3, "stroke", "#000000"), D2(V3, "stroke-width", "1.0"), D2(V3, "stroke-linejoin", "round"), D2(V3, "stroke-linecap", "butt"), D2(V3, "d", "m5.7087536 31.953627l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2(V3, "fill-rule", "evenodd"), D2(B3, "fill", "#000000"), D2(B3, "fill-opacity", "0.0"), D2(B3, "d", "m99.36328 7.8893228l0 69.57481"), D2(B3, "fill-rule", "evenodd"), D2(U3, "stroke", "#000000"), D2(U3, "stroke-width", "3.0"), D2(U3, "stroke-linejoin", "round"), D2(U3, "stroke-linecap", "butt"), D2(U3, "d", "m99.36328 7.8893228l0 69.57481"), D2(U3, "fill-rule", "evenodd"), D2(X3, "fill", "#000000"), D2(X3, "fill-opacity", "0.0"), D2(X3, "d", "m98.33496 8.093365l-68.12599 0"), D2(X3, "fill-rule", "evenodd"), D2(F3, "stroke", "#000000"), D2(F3, "stroke-width", "3.0"), D2(F3, "stroke-linejoin", "round"), D2(F3, "stroke-linecap", "butt"), D2(F3, "d", "m98.33496 8.093365l-68.12599 0"), D2(F3, "fill-rule", "evenodd"), D2(G3, "fill", "#000000"), D2(G3, "fill-opacity", "0.0"), D2(G3, "d", "m6.2755904 31.435696l24.598425 -24.220472"), D2(G3, "fill-rule", "evenodd"), D2(H3, "stroke", "#000000"), D2(H3, "stroke-width", "3.0"), D2(H3, "stroke-linejoin", "round"), D2(H3, "stroke-linecap", "butt"), D2(H3, "d", "m6.2755904 31.435696l24.598425 -24.220472"), D2(H3, "fill-rule", "evenodd"), D2(j3, "fill", "#000000"), D2(j3, "fill-opacity", "0.0"), D2(j3, "d", "m6.569554 30.706038l0.25196838 70.45669"), D2(j3, "fill-rule", "evenodd"), D2(Z3, "stroke", "#000000"), D2(Z3, "stroke-width", "3.0"), D2(Z3, "stroke-linejoin", "round"), D2(Z3, "stroke-linecap", "butt"), D2(Z3, "d", "m6.569554 30.706038l0.25196838 70.45669"), D2(Z3, "fill-rule", "evenodd"), D2(J3, "fill", "#000000"), D2(J3, "fill-opacity", "0.0"), D2(J3, "d", "m75.88714 101.04462l24.472443 -24.157478"), D2(J3, "fill-rule", "evenodd"), D2(K3, "stroke", "#000000"), D2(K3, "stroke-width", "3.0"), D2(K3, "stroke-linejoin", "round"), D2(K3, "stroke-linecap", "butt"), D2(K3, "d", "m75.88714 101.04462l24.472443 -24.157478"), D2(K3, "fill-rule", "evenodd"), D2(W3, "fill", "#000000"), D2(W3, "fill-opacity", "0.0"), D2(W3, "d", "m76.32546 101.04462l-69.51181 -0.12598419"), D2(W3, "fill-rule", "evenodd"), D2(Y3, "stroke", "#000000"), D2(Y3, "stroke-width", "3.0"), D2(Y3, "stroke-linejoin", "round"), D2(Y3, "stroke-linecap", "butt"), D2(Y3, "d", "m76.32546 101.04462l-69.51181 -0.12598419"), D2(Y3, "fill-rule", "evenodd"), D2(q3, "fill", "#ffe599"), D2(q3, "d", "m51.459316 33.11811l18.240559 -3.9169273l3.9169235 -18.240555l3.9169235 18.240555l18.240555 3.9169273l-18.240555 3.9169273l-3.9169235 18.240551l-3.9169235 -18.240551z"), D2(q3, "fill-rule", "evenodd"), D2(Q3, "stroke", "#000000"), D2(Q3, "stroke-width", "1.0"), D2(Q3, "stroke-linejoin", "round"), D2(Q3, "stroke-linecap", "butt"), D2(Q3, "d", "m51.459316 33.11811l18.240559 -3.9169273l3.9169235 -18.240555l3.9169235 18.240555l18.240555 3.9169273l-18.240555 3.9169273l-3.9169235 18.240551l-3.9169235 -18.240551z"), D2(Q3, "fill-rule", "evenodd"), D2(s3, "clip-path", "url(#p.0)"), D2(t3, "version", "1.1"), D2(t3, "viewBox", "0.0 0.0 108.9238845144357 108.94750656167979"), D2(t3, "fill", "none"), D2(t3, "stroke", "none"), D2(t3, "stroke-linecap", "square"), D2(t3, "stroke-miterlimit", "10"), D2(t3, "xmlns:xlink", "http://www.w3.org/1999/xlink"), D2(t3, "xmlns", "http://www.w3.org/2000/svg");
      }, m(e4, r3) {
        I2(e4, t3, r3), E2(t3, n3), E2(n3, i3), E2(t3, s3), E2(s3, a3), E2(s3, l3), E2(s3, h3), E2(s3, c3), E2(s3, d3), E2(s3, u3), E2(s3, f3), E2(s3, g3), E2(s3, p3), E2(s3, v3), E2(s3, b3), E2(s3, y3), E2(s3, I3), E2(s3, x3), E2(s3, P3), E2(s3, C3), E2(s3, k3), E2(s3, T3), E2(s3, A3), E2(s3, $3), E2(s3, E3), E2(s3, S3), E2(s3, M3), E2(s3, R3), E2(s3, D3), E2(s3, O3), E2(s3, N3), E2(s3, z3), E2(s3, L3), E2(s3, V3), E2(s3, B3), E2(s3, U3), E2(s3, X3), E2(s3, F3), E2(s3, G3), E2(s3, H3), E2(s3, j3), E2(s3, Z3), E2(s3, J3), E2(s3, K3), E2(s3, W3), E2(s3, Y3), E2(s3, q3), E2(s3, Q3);
      }, p: t2, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    var wi2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, null, vi2, a2, {});
      }
    };
    function bi2(e3) {
      let t3, n3, i3, s3, a3, l3, h3, c3, d3, u3, f3, g3, p3, v3, b3, y3, I3, x3, P3, C3, k3, T3, A3, $3, E3, S3;
      return {c() {
        t3 = R2("svg"), n3 = R2("clipPath"), i3 = R2("path"), s3 = R2("g"), a3 = R2("path"), l3 = R2("path"), h3 = R2("path"), c3 = R2("path"), d3 = R2("path"), u3 = R2("path"), f3 = R2("path"), g3 = R2("path"), p3 = R2("path"), v3 = R2("path"), b3 = R2("path"), y3 = R2("path"), I3 = R2("path"), x3 = R2("path"), P3 = R2("path"), C3 = R2("path"), k3 = R2("path"), T3 = R2("path"), A3 = R2("path"), $3 = R2("path"), E3 = R2("path"), S3 = R2("path"), D2(i3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0l0 -108.94751z"), D2(i3, "clip-rule", "nonzero"), D2(n3, "id", "p.0"), D2(a3, "fill", "#000000"), D2(a3, "fill-opacity", "0.0"), D2(a3, "d", "m0 0l108.92388 0l0 108.94751l-108.92388 0z"), D2(a3, "fill-rule", "evenodd"), D2(l3, "fill", "#000000"), D2(l3, "fill-opacity", "0.0"), D2(l3, "d", "m30.911938 7.158131l0 69.5748"), D2(l3, "fill-rule", "evenodd"), D2(h3, "stroke", "#000000"), D2(h3, "stroke-width", "3.0"), D2(h3, "stroke-linejoin", "round"), D2(h3, "stroke-linecap", "butt"), D2(h3, "d", "m30.911938 7.158131l0 69.5748"), D2(h3, "fill-rule", "evenodd"), D2(c3, "fill", "#000000"), D2(c3, "fill-opacity", "0.0"), D2(c3, "d", "m6.6742845 31.222435l69.35433 0l0 69.35433l-69.35433 0z"), D2(c3, "fill-rule", "evenodd"), D2(d3, "fill", "#000000"), D2(d3, "fill-opacity", "0.0"), D2(d3, "d", "m76.02862 31.222435l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(d3, "fill-rule", "evenodd"), D2(u3, "fill", "#000000"), D2(u3, "fill-opacity", "0.0"), D2(u3, "d", "m6.6742845 31.222435l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(u3, "fill-rule", "evenodd"), D2(f3, "fill", "#000000"), D2(f3, "fill-opacity", "0.0"), D2(f3, "d", "m6.6742845 31.222435l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2(f3, "fill-rule", "evenodd"), D2(g3, "fill", "#000000"), D2(g3, "fill-opacity", "0.2"), D2(g3, "d", "m76.02862 31.222435l23.11811 -23.11811l0 69.35433l-23.11811 23.11811z"), D2(g3, "fill-rule", "evenodd"), D2(p3, "fill", "#ffffff"), D2(p3, "fill-opacity", "0.2"), D2(p3, "d", "m6.6742845 31.222435l23.11811 -23.11811l69.35433 0l-23.11811 23.11811z"), D2(p3, "fill-rule", "evenodd"), D2(v3, "stroke", "#000000"), D2(v3, "stroke-width", "4.0"), D2(v3, "stroke-linejoin", "round"), D2(v3, "stroke-linecap", "butt"), D2(v3, "d", "m6.6742845 31.222435l23.11811 -23.11811l69.35433 0l0 69.35433l-23.11811 23.11811l-69.35433 0zm0 0l69.35433 0l23.11811 -23.11811m-23.11811 23.11811l0 69.35433"), D2(v3, "fill-rule", "evenodd"), D2(b3, "class", "viewIconColoredFace"), D2(b3, "d", "m7.8129287 32.24648l67.18111 0l0 67.40158l-67.18111 0z"), D2(b3, "fill-rule", "evenodd"), D2(y3, "stroke", "#000000"), D2(y3, "stroke-width", "1.0"), D2(y3, "stroke-linejoin", "round"), D2(y3, "stroke-linecap", "butt"), D2(y3, "d", "m7.8129287 32.24648l67.18111 0l0 67.40158l-67.18111 0z"), D2(y3, "fill-rule", "evenodd"), D2(I3, "class", "viewIconColoredFace"), D2(I3, "d", "m28.990873 7.5595646l-22.749775 22.97511l68.47466 0.45067215l23.501457 -23.599335z"), D2(I3, "fill-rule", "evenodd"), D2(x3, "stroke", "#000000"), D2(x3, "stroke-width", "3.0"), D2(x3, "stroke-linejoin", "round"), D2(x3, "stroke-linecap", "butt"), D2(x3, "d", "m28.990873 7.5595646l-22.749775 22.97511l68.47466 0.45067215l23.501457 -23.599335z"), D2(x3, "fill-rule", "evenodd"), D2(P3, "class", "viewIconColoredFace"), D2(P3, "d", "m75.39114 31.120354l0.42572784 69.36592l23.830978 -23.618652l0 -69.15306z"), D2(P3, "fill-rule", "evenodd"), D2(C3, "stroke", "#000000"), D2(C3, "stroke-width", "3.0"), D2(C3, "stroke-linejoin", "round"), D2(C3, "stroke-linecap", "butt"), D2(C3, "d", "m75.39114 31.120354l0.42572784 69.36592l23.830978 -23.618652l0 -69.15306z"), D2(C3, "fill-rule", "evenodd"), D2(k3, "fill", "#000000"), D2(k3, "fill-opacity", "0.0"), D2(k3, "d", "m7.3956966 101.59434l25.417322 -25.41732"), D2(k3, "fill-rule", "evenodd"), D2(T3, "stroke", "#000000"), D2(T3, "stroke-width", "3.0"), D2(T3, "stroke-linejoin", "round"), D2(T3, "stroke-linecap", "butt"), D2(T3, "stroke-dasharray", "12.0,9.0"), D2(T3, "d", "m7.3956966 101.59434l25.417322 -25.41732"), D2(T3, "fill-rule", "evenodd"), D2(A3, "fill", "#000000"), D2(A3, "fill-opacity", "0.0"), D2(A3, "d", "m99.86645 77.66052l-68.125984 0"), D2(A3, "fill-rule", "evenodd"), D2($3, "stroke", "#000000"), D2($3, "stroke-width", "3.0"), D2($3, "stroke-linejoin", "round"), D2($3, "stroke-linecap", "butt"), D2($3, "stroke-dasharray", "12.0,9.0"), D2($3, "d", "m99.86645 77.66052l-68.125984 0"), D2($3, "fill-rule", "evenodd"), D2(E3, "fill", "#000000"), D2(E3, "fill-opacity", "0.0"), D2(E3, "d", "m30.447966 8.738557l0 69.13386"), D2(E3, "fill-rule", "evenodd"), D2(S3, "stroke", "#000000"), D2(S3, "stroke-width", "3.0"), D2(S3, "stroke-linejoin", "round"), D2(S3, "stroke-linecap", "butt"), D2(S3, "stroke-dasharray", "12.0,9.0"), D2(S3, "d", "m30.447966 8.738557l0 69.13386"), D2(S3, "fill-rule", "evenodd"), D2(s3, "clip-path", "url(#p.0)"), D2(t3, "version", "1.1"), D2(t3, "viewBox", "0.0 0.0 108.9238845144357 108.94750656167979"), D2(t3, "fill", "none"), D2(t3, "stroke", "none"), D2(t3, "stroke-linecap", "square"), D2(t3, "stroke-miterlimit", "10"), D2(t3, "xmlns:xlink", "http://www.w3.org/1999/xlink"), D2(t3, "xmlns", "http://www.w3.org/2000/svg");
      }, m(e4, r3) {
        I2(e4, t3, r3), E2(t3, n3), E2(n3, i3), E2(t3, s3), E2(s3, a3), E2(s3, l3), E2(s3, h3), E2(s3, c3), E2(s3, d3), E2(s3, u3), E2(s3, f3), E2(s3, g3), E2(s3, p3), E2(s3, v3), E2(s3, b3), E2(s3, y3), E2(s3, I3), E2(s3, x3), E2(s3, P3), E2(s3, C3), E2(s3, k3), E2(s3, T3), E2(s3, A3), E2(s3, $3), E2(s3, E3), E2(s3, S3);
      }, p: t2, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    var _i2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, null, bi2, a2, {});
      }
    };
    var yi2 = {WIREFRAME: "WIREFRAME", FLAT: "FLAT", FLAT_WHITE: "FLAT_WHITE", HIDDEN_LINE: "HIDDEN_LINE", SHADED: "SHADED", SHADED_AND_EDGES: "SHADED_AND_EDGES", PBR: "PBR"};
    var Ii2 = yi2.PBR;
    var xi2 = () => {
      if (Ii2 == yi2.SHADED_AND_EDGES)
        return;
      Ii2 = yi2.SHADED_AND_EDGES;
      const {renderer: e3} = f2(Xt2);
      e3.renderMode = "hiddenline", e3.hiddenLineColor.a = 0, e3.requestRedraw();
    };
    var Pi2 = (e3) => {
      e3 === yi2.WIREFRAME ? (() => {
        if (Ii2 == yi2.WIREFRAME)
          return;
        Ii2 = yi2.WIREFRAME;
        const {renderer: e4} = f2(Xt2);
        e4.renderMode = "wireframe", e4.requestRedraw();
      })() : e3 === yi2.FLAT ? (() => {
        if (Ii2 == yi2.FLAT)
          return;
        Ii2 = yi2.FLAT;
        const {renderer: e4} = f2(Xt2);
        e4.renderMode = "flat", e4.hiddenLineColor.a = 0, e4.requestRedraw();
      })() : e3 === yi2.FLAT_WHITE ? ((e4 = true) => {
        if (Ii2 == yi2.FLAT_WHITE)
          return;
        Ii2 = yi2.FLAT_WHITE;
        const {renderer: t3} = f2(Xt2);
        t3.renderMode = "hiddenline", t3.hiddenLineColor.a = 0.2, t3.requestRedraw();
      })() : e3 === yi2.HIDDEN_LINE ? (() => {
        if (Ii2 == yi2.HIDDEN_LINE)
          return;
        Ii2 = yi2.HIDDEN_LINE;
        const {renderer: e4} = f2(Xt2);
        e4.renderMode = "flat", e4.hiddenLineColor.a = 0.1, e4.requestRedraw();
      })() : e3 === yi2.SHADED || e3 === yi2.SHADED_AND_EDGES ? xi2() : e3 === yi2.PBR && (() => {
        if (Ii2 == yi2.PBR)
          return;
        Ii2 = yi2.PBR;
        const {renderer: e4} = f2(Xt2);
        e4.renderMode = "pbr", e4.hiddenLineColor.a = 0, e4.requestRedraw();
      })();
    };
    var Ci2 = {NONE: Symbol(), MEASURE_DISTANCE: Symbol(), MEASURE_RADIUS: Symbol(), MEASURE_CENTER_DISTANCE: Symbol(), MEASURE_ANGLE: Symbol()};
    var ki2 = Ci2.NONE;
    var Ti2 = (e3) => {
      const {toolManager: t3} = f2(Xt2);
      return ki2 == Ci2.NONE || (ki2 == Ci2.MEASURE_DISTANCE || ki2 == Ci2.MEASURE_RADIUS || ki2 == Ci2.MEASURE_CENTER_DISTANCE || ki2 == Ci2.MEASURE_ANGLE) && t3.popTool(), e3 == Ci2.NONE || (e3 == Ci2.MEASURE_DISTANCE ? t3.pushTool("measureDistanceTool") : e3 == Ci2.MEASURE_RADIUS ? t3.pushTool("measureRadiusTool") : e3 == Ci2.MEASURE_CENTER_DISTANCE ? t3.pushTool("measureCenterDistancesTool") : e3 == Ci2.MEASURE_ANGLE && t3.pushTool("measureAngleTool")), ki2 = e3, ki2;
    };
    var Ai2 = (e3) => {
      if (ki2 == e3 && e3 != Ci2.NONE)
        return Ai2(Ci2.NONE);
      console.log("toggleMeasureTool");
      const {scene: t3} = f2(Xt2);
      let n3;
      if (t3.getRoot().traverse((e4) => !n3 && (e4 instanceof aC ? (n3 = e4, false) : void 0)), console.log("assetItem:", n3), n3)
        if (n3.getEngineDataVersion().compare([3, 9, 1]) >= 0) {
          if (n3.url.startsWith("blob"))
            return void (n3.metadataLoaded ? Ti2(e3) : new Promise((e4) => {
              let t4 = document.createElement("input");
              t4.addEventListener("change", (t5) => {
                const n4 = URL.createObjectURL(t5.target.files[0]);
                e4(n4);
              }), t4.setAttribute("type", "file"), t4.setAttribute("accept", ".zmetadata"), t4.click();
            }).then((t4) => {
              n3.loadMetadata(t4).then(() => {
                Ti2(e3);
              }).catch((e4) => {
                console.error(e4);
              });
            }));
          n3.loadMetadata().then(() => {
            Ti2(e3);
          }).catch((e4) => {
            console.error(e4);
          });
        } else
          Ti2(e3);
    };
    function $i2(e3) {
      let t3, n3;
      return t3 = new ni2({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Ei2(e3) {
      let t3, n3;
      return t3 = new ni2({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Si2(e3) {
      let t3, n3;
      return t3 = new li2({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Mi2(e3) {
      let t3, n3;
      return t3 = new ai2({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Ri2(e3) {
      let t3, n3;
      return t3 = new si2({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Di2(e3) {
      let t3, n3, i3, a3, l3, h3, c3, d3, g3;
      return n3 = new Jn({props: {isHighlighted: e3[1] === Ci2.MEASURE_DISTANCE, title: "MEASURE_DISTANCE", $$slots: {default: [Ei2]}, $$scope: {ctx: e3}}}), n3.$on("click", e3[3]), a3 = new Jn({props: {isHighlighted: e3[1] === Ci2.MEASURE_RADIUS, title: "MEASURE_RADIUS", $$slots: {default: [Si2]}, $$scope: {ctx: e3}}}), a3.$on("click", e3[4]), h3 = new Jn({props: {isHighlighted: e3[1] === Ci2.MEASURE_CENTER_DISTANCE, title: "MEASURE_CENTER_DISTANCE", $$slots: {default: [Mi2]}, $$scope: {ctx: e3}}}), h3.$on("click", e3[5]), d3 = new Jn({props: {isHighlighted: e3[1] === Ci2.MEASURE_ANGLE, title: "MEASURE_ANGLE", $$slots: {default: [Ri2]}, $$scope: {ctx: e3}}}), d3.$on("click", e3[6]), {c() {
        t3 = N2("div"), Bt2(n3.$$.fragment), i3 = A2(), Bt2(a3.$$.fragment), l3 = A2(), Bt2(h3.$$.fragment), c3 = A2(), Bt2(d3.$$.fragment), D2(t3, "class", "flex flex-col absolute bottom-full gap-1 mb-1"), D2(t3, "slot", "popup");
      }, m(e4, s3) {
        I2(e4, t3, s3), Dt(n3, t3, null), E2(t3, i3), Dt(a3, t3, null), E2(t3, l3), Dt(h3, t3, null), E2(t3, c3), Dt(d3, t3, null), g3 = true;
      }, p(e4, t4) {
        const i4 = {};
        2 & t4 && (i4.isHighlighted = e4[1] === Ci2.MEASURE_DISTANCE), 4096 & t4 && (i4.$$scope = {dirty: t4, ctx: e4}), n3.$set(i4);
        const s3 = {};
        2 & t4 && (s3.isHighlighted = e4[1] === Ci2.MEASURE_RADIUS), 4096 & t4 && (s3.$$scope = {dirty: t4, ctx: e4}), a3.$set(s3);
        const r3 = {};
        2 & t4 && (r3.isHighlighted = e4[1] === Ci2.MEASURE_CENTER_DISTANCE), 4096 & t4 && (r3.$$scope = {dirty: t4, ctx: e4}), h3.$set(r3);
        const o3 = {};
        2 & t4 && (o3.isHighlighted = e4[1] === Ci2.MEASURE_ANGLE), 4096 & t4 && (o3.$$scope = {dirty: t4, ctx: e4}), d3.$set(o3);
      }, i(e4) {
        g3 || (St(n3.$$.fragment, e4), St(a3.$$.fragment, e4), St(h3.$$.fragment, e4), St(d3.$$.fragment, e4), g3 = true);
      }, o(e4) {
        Lt(n3.$$.fragment, e4), Lt(a3.$$.fragment, e4), Lt(h3.$$.fragment, e4), Lt(d3.$$.fragment, e4), g3 = false;
      }, d(e4) {
        e4 && S2(t3), Ut(n3), Ut(a3), Ut(h3), Ut(d3);
      }};
    }
    function Oi2(e3) {
      let t3, n3;
      return t3 = new pi2({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Ni2(e3) {
      let t3, n3;
      return t3 = new ci2({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function zi2(e3) {
      let t3, n3;
      return t3 = new ui2({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Li2(e3) {
      let t3, n3;
      return t3 = new mi2({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Vi2(e3) {
      let t3, n3;
      return t3 = new _i2({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Bi2(e3) {
      let t3, n3;
      return t3 = new wi2({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Ui2(e3) {
      let t3, n3, i3, a3, l3, h3, c3, d3, g3, v3, b3;
      return n3 = new Jn({props: {isHighlighted: e3[2] === yi2.WIREFRAME, title: "Wireframe", $$slots: {default: [Ni2]}, $$scope: {ctx: e3}}}), n3.$on("click", e3[7]), a3 = new Jn({props: {isHighlighted: e3[2] === yi2.FLAT, title: "Flat", $$slots: {default: [zi2]}, $$scope: {ctx: e3}}}), a3.$on("click", e3[8]), h3 = new Jn({props: {isHighlighted: e3[2] === yi2.FLAT_WHITE, title: "FlatWhite", $$slots: {default: [Li2]}, $$scope: {ctx: e3}}}), h3.$on("click", e3[9]), d3 = new Jn({props: {isHighlighted: e3[2] === yi2.HIDDEN_LINE, title: "HiddenLine", $$slots: {default: [Vi2]}, $$scope: {ctx: e3}}}), d3.$on("click", e3[10]), v3 = new Jn({props: {isHighlighted: e3[2] === yi2.PBR, title: "PBR", $$slots: {default: [Bi2]}, $$scope: {ctx: e3}}}), v3.$on("click", e3[11]), {c() {
        t3 = N2("div"), Bt2(n3.$$.fragment), i3 = A2(), Bt2(a3.$$.fragment), l3 = A2(), Bt2(h3.$$.fragment), c3 = A2(), Bt2(d3.$$.fragment), g3 = A2(), Bt2(v3.$$.fragment), D2(t3, "class", "flex flex-col absolute bottom-full gap-1 mb-1"), D2(t3, "slot", "popup");
      }, m(e4, s3) {
        I2(e4, t3, s3), Dt(n3, t3, null), E2(t3, i3), Dt(a3, t3, null), E2(t3, l3), Dt(h3, t3, null), E2(t3, c3), Dt(d3, t3, null), E2(t3, g3), Dt(v3, t3, null), b3 = true;
      }, p(e4, t4) {
        const i4 = {};
        4 & t4 && (i4.isHighlighted = e4[2] === yi2.WIREFRAME), 4096 & t4 && (i4.$$scope = {dirty: t4, ctx: e4}), n3.$set(i4);
        const s3 = {};
        4 & t4 && (s3.isHighlighted = e4[2] === yi2.FLAT), 4096 & t4 && (s3.$$scope = {dirty: t4, ctx: e4}), a3.$set(s3);
        const r3 = {};
        4 & t4 && (r3.isHighlighted = e4[2] === yi2.FLAT_WHITE), 4096 & t4 && (r3.$$scope = {dirty: t4, ctx: e4}), h3.$set(r3);
        const o3 = {};
        4 & t4 && (o3.isHighlighted = e4[2] === yi2.HIDDEN_LINE), 4096 & t4 && (o3.$$scope = {dirty: t4, ctx: e4}), d3.$set(o3);
        const l4 = {};
        4 & t4 && (l4.isHighlighted = e4[2] === yi2.PBR), 4096 & t4 && (l4.$$scope = {dirty: t4, ctx: e4}), v3.$set(l4);
      }, i(e4) {
        b3 || (St(n3.$$.fragment, e4), St(a3.$$.fragment, e4), St(h3.$$.fragment, e4), St(d3.$$.fragment, e4), St(v3.$$.fragment, e4), b3 = true);
      }, o(e4) {
        Lt(n3.$$.fragment, e4), Lt(a3.$$.fragment, e4), Lt(h3.$$.fragment, e4), Lt(d3.$$.fragment, e4), Lt(v3.$$.fragment, e4), b3 = false;
      }, d(e4) {
        e4 && S2(t3), Ut(n3), Ut(a3), Ut(h3), Ut(d3), Ut(v3);
      }};
    }
    function Xi2(e3) {
      let t3, n3, i3, l3, h3;
      return n3 = new ei2({props: {isHighlighted: e3[1] !== Ci2.NONE, title: "Measure Tools", $$slots: {popup: [Di2], default: [$i2]}, $$scope: {ctx: e3}}}), l3 = new ei2({props: {isHighlighted: e3[2] !== yi2.PBR, title: "Renderer modes", $$slots: {popup: [Ui2], default: [Oi2]}, $$scope: {ctx: e3}}}), {c() {
        t3 = N2("div"), Bt2(n3.$$.fragment), i3 = A2(), Bt2(l3.$$.fragment), D2(t3, "class", "Toolbar flex gap-1"), J2(t3, "flex-col", e3[0] === "vertical");
      }, m(e4, s3) {
        I2(e4, t3, s3), Dt(n3, t3, null), E2(t3, i3), Dt(l3, t3, null), h3 = true;
      }, p(e4, [i4]) {
        const s3 = {};
        2 & i4 && (s3.isHighlighted = e4[1] !== Ci2.NONE), 4098 & i4 && (s3.$$scope = {dirty: i4, ctx: e4}), n3.$set(s3);
        const r3 = {};
        4 & i4 && (r3.isHighlighted = e4[2] !== yi2.PBR), 4100 & i4 && (r3.$$scope = {dirty: i4, ctx: e4}), l3.$set(r3), 1 & i4 && J2(t3, "flex-col", e4[0] === "vertical");
      }, i(e4) {
        h3 || (St(n3.$$.fragment, e4), St(l3.$$.fragment, e4), h3 = true);
      }, o(e4) {
        Lt(n3.$$.fragment, e4), Lt(l3.$$.fragment, e4), h3 = false;
      }, d(e4) {
        e4 && S2(t3), Ut(n3), Ut(l3);
      }};
    }
    function Fi2(e3, t3, n3) {
      let {orientation: i3 = "horizontal"} = t3, s3 = Ci2.NONE;
      let r3 = yi2.PBR;
      return e3.$$set = (e4) => {
        "orientation" in e4 && n3(0, i3 = e4.orientation);
      }, [i3, s3, r3, () => {
        n3(1, s3 = Ai2(Ci2.MEASURE_DISTANCE));
      }, () => {
        n3(1, s3 = Ai2(Ci2.MEASURE_RADIUS));
      }, () => {
        n3(1, s3 = Ai2(Ci2.MEASURE_CENTER_DISTANCE));
      }, () => {
        n3(1, s3 = Ai2(Ci2.MEASURE_ANGLE));
      }, () => {
        Pi2(yi2.WIREFRAME), n3(2, r3 = yi2.WIREFRAME);
      }, () => {
        Pi2(yi2.FLAT), n3(2, r3 = yi2.FLAT);
      }, () => {
        Pi2(yi2.FLAT_WHITE), n3(2, r3 = yi2.FLAT_WHITE);
      }, () => {
        Pi2(yi2.HIDDEN_LINE), n3(2, r3 = yi2.HIDDEN_LINE);
      }, () => {
        Pi2(yi2.PBR), n3(2, r3 = yi2.PBR);
      }];
    }
    var Gi2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Fi2, Xi2, a2, {orientation: 0});
      }
    };
    function Hi2(e3) {
      let t3, n3, a3, g3, v3, b3, _3, y3;
      const I3 = e3[4].default, x3 = d2(I3, e3, e3[3], null);
      return {c() {
        t3 = N2("nav"), n3 = N2("div"), x3 && x3.c(), a3 = A2(), g3 = N2("div"), g3.innerHTML = '<span class="material-icons transform rotate-90">drag_handle</span>', D2(n3, "class", "DrawerContent flex-1 overflow-hidden"), D2(g3, "class", "DrawerHandle flex items-center justify-center text-gray-400 w-2"), W2(g3, "cursor", "col-resize"), D2(t3, "class", v3 = "absolute bg-background flex h-full shadow w-72 top-0 transition transform " + (e3[1].shouldShowDrawer || "-translate-x-full"));
      }, m(i3, s3) {
        I2(i3, t3, s3), E2(t3, n3), x3 && x3.m(n3, null), E2(t3, a3), E2(t3, g3), e3[5](t3), b3 = true, _3 || (y3 = C2(g3, "mousedown", e3[2]), _3 = true);
      }, p(e4, [n4]) {
        x3 && x3.p && (!b3 || 8 & n4) && g2(x3, I3, e4, e4[3], b3 ? m2(I3, e4[3], n4, null) : $2(e4[3]), null), (!b3 || 2 & n4 && v3 !== (v3 = "absolute bg-background flex h-full shadow w-72 top-0 transition transform " + (e4[1].shouldShowDrawer || "-translate-x-full"))) && D2(t3, "class", v3);
      }, i(e4) {
        b3 || (St(x3, e4), b3 = true);
      }, o(e4) {
        Lt(x3, e4), b3 = false;
      }, d(n4) {
        n4 && S2(t3), x3 && x3.d(n4), e3[5](null), _3 = false, y3();
      }};
    }
    function ji2(e3, t3, n3) {
      let i3;
      p2(e3, ot2, (e4) => n3(1, i3 = e4));
      let s3, r3, a3, {$$slots: o3 = {}, $$scope: l3} = t3;
      const h3 = (e4) => {
        const t4 = r3.clientX - e4.clientX, i4 = a3.width - t4;
        n3(0, s3.style.width = `${i4}px`, s3);
      }, c3 = (e4) => {
        window.getSelection().removeAllRanges(), h3(e4);
      }, d3 = () => {
        document.body.style.cursor = null, window.removeEventListener("mousemove", c3);
      };
      return e3.$$set = (e4) => {
        "$$scope" in e4 && n3(3, l3 = e4.$$scope);
      }, [s3, i3, (e4) => {
        r3 = {clientX: e4.clientX}, a3 = {width: s3.offsetWidth}, h3(e4), document.body.style.cursor = "col-resize", window.addEventListener("mousemove", c3), window.addEventListener("mouseup", d3);
      }, l3, o3, function(e4) {
        ft[e4 ? "unshift" : "push"](() => {
          s3 = e4, n3(0, s3);
        });
      }];
    }
    var Zi2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, ji2, Hi2, a2, {});
      }
    };
    function Ji2(e3) {
      let t3, n3;
      return {c() {
        t3 = N2("div"), n3 = N2("div"), D2(n3, "class", "bg-primary h-1"), W2(n3, "width", e3[0] + "%"), D2(t3, "class", "ProgressBar");
      }, m(e4, i3) {
        I2(e4, t3, i3), E2(t3, n3);
      }, p(e4, [t4]) {
        1 & t4 && W2(n3, "width", e4[0] + "%");
      }, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    function Ki2(e3, t3, n3) {
      let {progress: i3 = 0} = t3;
      return e3.$$set = (e4) => {
        "progress" in e4 && n3(0, i3 = e4.progress);
      }, [i3];
    }
    var Wi2 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Ki2, Ji2, a2, {progress: 0});
      }
    };
    var Yi2 = se2();
    function qi2(e3) {
      let t3, n3, i3, a3, h3, c3, d3;
      return {c() {
        t3 = N2("div"), n3 = N2("form"), i3 = N2("input"), a3 = A2(), h3 = N2("ul"), D2(i3, "class", "rounded w-full text-black px-1"), D2(i3, "type", "search"), D2(h3, "class", "py-3"), D2(h3, "id", "searchResults"), D2(t3, "class", "h-full w-full px-3");
      }, m(s3, r3) {
        I2(s3, t3, r3), E2(t3, n3), E2(n3, i3), e3[4](i3), z2(i3, e3[0]), E2(t3, a3), E2(t3, h3), e3[6](h3), c3 || (d3 = [C2(i3, "input", e3[5]), C2(n3, "submit", M2(e3[3]))], c3 = true);
      }, p(e4, [t4]) {
        1 & t4 && z2(i3, e4[0]);
      }, i: t2, o: t2, d(n4) {
        n4 && S2(t3), e3[4](null), e3[6](null), c3 = false, s2(d3);
      }};
    }
    function Qi2(e3, t3, n3) {
      let i3, s3, r3;
      p2(e3, Yi2, (e4) => n3(8, i3 = e4));
      let a3 = "";
      const o3 = new Set(), l3 = new XI();
      l3.setShaderName("FlatSurfaceShader"), l3.getParameter("BaseColor").setValue(new l(0, 0, 1, 0.1));
      const h3 = {}, c3 = new Set(), d3 = new l(1, 0, 0, 0.2);
      return ot(() => {
        s3.focus();
      }), e3.$$.update = () => {
        1 & e3.$$.dirty && (() => {
          if (i3) {
            for (; r3.firstChild; )
              r3.removeChild(r3.lastChild);
            if (o3.forEach((e4) => {
              e4 instanceof kI && h3[e4.getId()] && e4.getParameter("Material").setValue(h3[e4.getId()]);
            }), o3.clear(), c3.forEach((e4) => {
              e4.removeHighlight("searchResult", true);
            }), c3.clear(), a3.length >= 2) {
              const e4 = new RegExp(a3, "i");
              i3.getRoot().traverse((t4) => {
                if (t4 instanceof ZC || !(t4 instanceof ag))
                  return false;
                if (e4.test(t4.getName())) {
                  const e5 = document.createElement("li");
                  return e5.classList.add("truncate"), e5.textContent = t4.getName(), r3.appendChild(e5), c3.add(t4), t4.addHighlight("searchResult", d3, true), false;
                }
                t4 instanceof kI && o3.add(t4);
              });
            }
          }
        })();
      }, [a3, s3, r3, () => {
        o3.forEach((e4) => {
          if (e4 instanceof kI) {
            const t4 = e4.getParameter("Material");
            h3[e4.getId()] = t4.getValue(), t4.setValue(l3);
          }
        }), c3.forEach((e4) => {
          e4.removeHighlight("searchResult", true);
        });
      }, function(e4) {
        ft[e4 ? "unshift" : "push"](() => {
          s3 = e4, n3(1, s3);
        });
      }, function() {
        a3 = this.value, n3(0, a3);
      }, function(e4) {
        ft[e4 ? "unshift" : "push"](() => {
          r3 = e4, n3(2, r3);
        });
      }];
    }
    var es = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Qi2, qi2, a2, {});
      }
    };
    function ts(e3, t3, n3) {
      const i3 = e3.slice();
      return i3[4] = t3[n3], i3;
    }
    function ns(e3) {
      let t3, n3, i3, h3, c3, d3 = e3[4] + "";
      function u3() {
        return e3[3](e3[4]);
      }
      return {c() {
        t3 = N2("button"), n3 = T2(d3), i3 = A2(), D2(t3, "class", "flex-1 leading-9 rounded-t"), J2(t3, "bg-gray-600", e3[0] === e3[4]), J2(t3, "bg-gray-800", e3[0] !== e3[4]), J2(t3, "hover:bg-gray-700", e3[0] !== e3[4]), J2(t3, "text-primary", e3[0] === e3[4]);
      }, m(e4, s3) {
        I2(e4, t3, s3), E2(t3, n3), E2(t3, i3), h3 || (c3 = C2(t3, "click", u3), h3 = true);
      }, p(i4, s3) {
        e3 = i4, 2 & s3 && d3 !== (d3 = e3[4] + "") && K2(n3, d3), 3 & s3 && J2(t3, "bg-gray-600", e3[0] === e3[4]), 3 & s3 && J2(t3, "bg-gray-800", e3[0] !== e3[4]), 3 & s3 && J2(t3, "hover:bg-gray-700", e3[0] !== e3[4]), 3 & s3 && J2(t3, "text-primary", e3[0] === e3[4]);
      }, d(e4) {
        e4 && S2(t3), h3 = false, c3();
      }};
    }
    function is(e3) {
      let t3, n3 = e3[1], i3 = [];
      for (let t4 = 0; t4 < n3.length; t4 += 1)
        i3[t4] = ns(ts(e3, n3, t4));
      return {c() {
        t3 = N2("div");
        for (let e4 = 0; e4 < i3.length; e4 += 1)
          i3[e4].c();
        D2(t3, "class", "TabsBar flex border-b border-gray-600 mb-2");
      }, m(e4, n4) {
        I2(e4, t3, n4);
        for (let e5 = 0; e5 < i3.length; e5 += 1)
          i3[e5].m(t3, null);
      }, p(e4, [s3]) {
        if (7 & s3) {
          let r3;
          for (n3 = e4[1], r3 = 0; r3 < n3.length; r3 += 1) {
            const a3 = ts(e4, n3, r3);
            i3[r3] ? i3[r3].p(a3, s3) : (i3[r3] = ns(a3), i3[r3].c(), i3[r3].m(t3, null));
          }
          for (; r3 < i3.length; r3 += 1)
            i3[r3].d(1);
          i3.length = n3.length;
        }
      }, i: t2, o: t2, d(e4) {
        e4 && S2(t3), L2(i3, e4);
      }};
    }
    function ss(e3, t3, n3) {
      let {tabs: i3 = []} = t3, {selectedTab: s3 = i3[0]} = t3;
      const r3 = (e4) => {
        n3(0, s3 = e4);
      };
      return e3.$$set = (e4) => {
        "tabs" in e4 && n3(1, i3 = e4.tabs), "selectedTab" in e4 && n3(0, s3 = e4.selectedTab);
      }, [s3, i3, r3, (e4) => {
        r3(e4);
      }];
    }
    var rs = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, ss, is, a2, {tabs: 1, selectedTab: 0});
      }
    };
    function as(e3) {
      let t3, n3, i3;
      return {c() {
        t3 = R2("svg"), n3 = R2("path"), i3 = R2("path"), D2(n3, "d", "M10 12a2 2 0 100-4 2 2 0 000 4z"), D2(i3, "fill-rule", "evenodd"), D2(i3, "d", "M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z"), D2(i3, "clip-rule", "evenodd"), D2(t3, "class", e3[0]), D2(t3, "xmlns", "http://www.w3.org/2000/svg"), D2(t3, "viewBox", "0 0 20 20"), D2(t3, "fill", "currentColor");
      }, m(e4, s3) {
        I2(e4, t3, s3), E2(t3, n3), E2(t3, i3);
      }, p(e4, [n4]) {
        1 & n4 && D2(t3, "class", e4[0]);
      }, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    function os(e3, t3, n3) {
      let {design: i3 = ""} = t3;
      return e3.$$set = (e4) => {
        "design" in e4 && n3(0, i3 = e4.design);
      }, [i3];
    }
    var ls = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, os, as, a2, {design: 0});
      }
    };
    function hs(e3) {
      let t3, n3, i3;
      return {c() {
        t3 = R2("svg"), n3 = R2("path"), i3 = R2("path"), D2(n3, "fill-rule", "evenodd"), D2(n3, "d", "M3.707 2.293a1 1 0 00-1.414 1.414l14 14a1 1 0 001.414-1.414l-1.473-1.473A10.014 10.014 0 0019.542 10C18.268 5.943 14.478 3 10 3a9.958 9.958 0 00-4.512 1.074l-1.78-1.781zm4.261 4.26l1.514 1.515a2.003 2.003 0 012.45 2.45l1.514 1.514a4 4 0 00-5.478-5.478z"), D2(n3, "clip-rule", "evenodd"), D2(i3, "d", "M12.454 16.697L9.75 13.992a4 4 0 01-3.742-3.741L2.335 6.578A9.98 9.98 0 00.458 10c1.274 4.057 5.065 7 9.542 7 .847 0 1.669-.105 2.454-.303z"), D2(t3, "class", e3[0]), D2(t3, "xmlns", "http://www.w3.org/2000/svg"), D2(t3, "viewBox", "0 0 20 20"), D2(t3, "fill", "currentColor");
      }, m(e4, s3) {
        I2(e4, t3, s3), E2(t3, n3), E2(t3, i3);
      }, p(e4, [n4]) {
        1 & n4 && D2(t3, "class", e4[0]);
      }, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    function cs(e3, t3, n3) {
      let {design: i3 = ""} = t3;
      return e3.$$set = (e4) => {
        "design" in e4 && n3(0, i3 = e4.design);
      }, [i3];
    }
    var ds = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, cs, hs, a2, {design: 0});
      }
    };
    function us(e3) {
      let t3, n3;
      return {c() {
        t3 = R2("svg"), n3 = R2("path"), D2(n3, "fill-rule", "evenodd"), D2(n3, "d", "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z"), D2(n3, "clip-rule", "evenodd"), D2(t3, "class", e3[0]), D2(t3, "xmlns", "http://www.w3.org/2000/svg"), D2(t3, "viewBox", "0 0 20 20"), D2(t3, "fill", "currentColor");
      }, m(e4, i3) {
        I2(e4, t3, i3), E2(t3, n3);
      }, p(e4, [n4]) {
        1 & n4 && D2(t3, "class", e4[0]);
      }, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    function fs(e3, t3, n3) {
      let {design: i3 = ""} = t3;
      return e3.$$set = (e4) => {
        "design" in e4 && n3(0, i3 = e4.design);
      }, [i3];
    }
    var ms = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, fs, us, a2, {design: 0});
      }
    };
    function gs(e3) {
      let t3, n3;
      return {c() {
        t3 = R2("svg"), n3 = R2("path"), D2(n3, "fill-rule", "evenodd"), D2(n3, "d", "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z"), D2(n3, "clip-rule", "evenodd"), D2(t3, "class", e3[0]), D2(t3, "xmlns", "http://www.w3.org/2000/svg"), D2(t3, "viewBox", "0 0 20 20"), D2(t3, "fill", "currentColor");
      }, m(e4, i3) {
        I2(e4, t3, i3), E2(t3, n3);
      }, p(e4, [n4]) {
        1 & n4 && D2(t3, "class", e4[0]);
      }, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    function ps(e3, t3, n3) {
      let {design: i3 = ""} = t3;
      return e3.$$set = (e4) => {
        "design" in e4 && n3(0, i3 = e4.design);
      }, [i3];
    }
    var vs = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, ps, gs, a2, {design: 0});
      }
    };
    function ws(e3, t3, n3) {
      const i3 = e3.slice();
      return i3[31] = t3[n3], i3[32] = t3, i3[33] = n3, i3;
    }
    function bs(e3) {
      let t3, n3, i3, h3, c3, d3, g3, _3, y3, I3, x3, P3, C3 = e3[12](e3[0]).name + "";
      const k3 = [ys, _s], T3 = [];
      function A3(e4, t4) {
        return e4[8] ? 0 : 1;
      }
      i3 = A3(e3), h3 = T3[i3] = k3[i3](e3);
      let $3 = e3[11] && Ps(e3), E3 = e3[8] && e3[3] && Ts(e3);
      return {c() {
        t3 = N2("div"), n3 = N2("div"), h3.c(), c3 = A2(), $3 && $3.c(), d3 = A2(), g3 = N2("span"), _3 = T2(C3), y3 = A2(), E3 && E3.c(), D2(g3, "class", "flex-1 border rounded px-1"), W2(g3, "background-color", e3[4] ? e3[9] : "transparent"), W2(g3, "border-color", e3[4] ? e3[10] : "transparent"), D2(n3, "class", "TreeItem__header flex items-center cursor-default hover:bg-gray-800 transition-colors mb-1"), D2(t3, "class", "TreeItem"), J2(t3, "text-gray-500", !e3[5]);
      }, m(s3, r3) {
        I2(s3, t3, r3), E2(t3, n3), T3[i3].m(n3, null), E2(n3, c3), $3 && $3.m(n3, null), E2(n3, d3), E2(n3, g3), E2(g3, _3), E2(t3, y3), E3 && E3.m(t3, null), e3[19](t3), I3 = true, x3 || (P3 = C2(g3, "click", e3[16]), x3 = true);
      }, p(e4, s3) {
        let r3 = i3;
        i3 = A3(e4), i3 === r3 ? T3[i3].p(e4, s3) : (Ot(), Lt(T3[r3], 1, 1, () => {
          T3[r3] = null;
        }), It2(), h3 = T3[i3], h3 ? h3.p(e4, s3) : (h3 = T3[i3] = k3[i3](e4), h3.c()), St(h3, 1), h3.m(n3, c3)), e4[11] ? $3 ? ($3.p(e4, s3), 2048 & s3[0] && St($3, 1)) : ($3 = Ps(e4), $3.c(), St($3, 1), $3.m(n3, d3)) : $3 && (Ot(), Lt($3, 1, 1, () => {
          $3 = null;
        }), It2()), (!I3 || 1 & s3[0]) && C3 !== (C3 = e4[12](e4[0]).name + "") && K2(_3, C3), (!I3 || 528 & s3[0]) && W2(g3, "background-color", e4[4] ? e4[9] : "transparent"), (!I3 || 1040 & s3[0]) && W2(g3, "border-color", e4[4] ? e4[10] : "transparent"), e4[8] && e4[3] ? E3 ? (E3.p(e4, s3), 264 & s3[0] && St(E3, 1)) : (E3 = Ts(e4), E3.c(), St(E3, 1), E3.m(t3, null)) : E3 && (Ot(), Lt(E3, 1, 1, () => {
          E3 = null;
        }), It2()), 32 & s3[0] && J2(t3, "text-gray-500", !e4[5]);
      }, i(e4) {
        I3 || (St(h3), St($3), St(E3), I3 = true);
      }, o(e4) {
        Lt(h3), Lt($3), Lt(E3), I3 = false;
      }, d(n4) {
        n4 && S2(t3), T3[i3].d(), $3 && $3.d(), E3 && E3.d(), e3[19](null), x3 = false, P3();
      }};
    }
    function _s(e3) {
      let t3;
      return {c() {
        t3 = N2("div"), D2(t3, "class", "w-8 md:w-6");
      }, m(e4, n3) {
        I2(e4, t3, n3);
      }, p: t2, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    function ys(e3) {
      let t3, n3, i3, a3, h3, c3;
      const d3 = [xs, Is], g3 = [];
      function p3(e4, t4) {
        return e4[3] ? 0 : 1;
      }
      return n3 = p3(e3), i3 = g3[n3] = d3[n3](e3), {c() {
        t3 = N2("button"), i3.c(), D2(t3, "class", "cursor-default hover:bg-gray-700 rounded w-8 md:w-6");
      }, m(i4, s3) {
        I2(i4, t3, s3), g3[n3].m(t3, null), a3 = true, h3 || (c3 = C2(t3, "click", e3[14]), h3 = true);
      }, p(e4, s3) {
        let r3 = n3;
        n3 = p3(e4), n3 !== r3 && (Ot(), Lt(g3[r3], 1, 1, () => {
          g3[r3] = null;
        }), It2(), i3 = g3[n3], i3 || (i3 = g3[n3] = d3[n3](e4), i3.c()), St(i3, 1), i3.m(t3, null));
      }, i(e4) {
        a3 || (St(i3), a3 = true);
      }, o(e4) {
        Lt(i3), a3 = false;
      }, d(e4) {
        e4 && S2(t3), g3[n3].d(), h3 = false, c3();
      }};
    }
    function Is(e3) {
      let t3, n3;
      return t3 = new vs({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function xs(e3) {
      let t3, n3;
      return t3 = new ms({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Ps(e3) {
      let t3, n3, i3, a3, h3, c3;
      const d3 = [ks, Cs], g3 = [];
      function p3(e4, t4) {
        return e4[5] ? 0 : 1;
      }
      return n3 = p3(e3), i3 = g3[n3] = d3[n3](e3), {c() {
        t3 = N2("button"), i3.c(), D2(t3, "class", "cursor-default hover:bg-gray-700 rounded p-1 w-8 md:w-6");
      }, m(i4, s3) {
        I2(i4, t3, s3), g3[n3].m(t3, null), a3 = true, h3 || (c3 = C2(t3, "click", e3[15]), h3 = true);
      }, p(e4, s3) {
        let r3 = n3;
        n3 = p3(e4), n3 !== r3 && (Ot(), Lt(g3[r3], 1, 1, () => {
          g3[r3] = null;
        }), It2(), i3 = g3[n3], i3 || (i3 = g3[n3] = d3[n3](e4), i3.c()), St(i3, 1), i3.m(t3, null));
      }, i(e4) {
        a3 || (St(i3), a3 = true);
      }, o(e4) {
        Lt(i3), a3 = false;
      }, d(e4) {
        e4 && S2(t3), g3[n3].d(), h3 = false, c3();
      }};
    }
    function Cs(e3) {
      let t3, n3;
      return t3 = new ds({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function ks(e3) {
      let t3, n3;
      return t3 = new ls({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Ts(e3) {
      let t3, n3, i3 = e3[11] && As(e3);
      return {c() {
        t3 = N2("div"), i3 && i3.c(), D2(t3, "class", "TreeItem__body ml-4 pl-4 md:ml-3 md:pl-3 border-dotted border-l-2 md:border-l");
      }, m(e4, s3) {
        I2(e4, t3, s3), i3 && i3.m(t3, null), n3 = true;
      }, p(e4, n4) {
        e4[11] ? i3 ? (i3.p(e4, n4), 2048 & n4[0] && St(i3, 1)) : (i3 = As(e4), i3.c(), St(i3, 1), i3.m(t3, null)) : i3 && (Ot(), Lt(i3, 1, 1, () => {
          i3 = null;
        }), It2());
      }, i(e4) {
        n3 || (St(i3), n3 = true);
      }, o(e4) {
        Lt(i3), n3 = false;
      }, d(e4) {
        e4 && S2(t3), i3 && i3.d();
      }};
    }
    function As(e3) {
      let t3, n3, i3 = e3[13](e3[0]), s3 = [];
      for (let t4 = 0; t4 < i3.length; t4 += 1)
        s3[t4] = $s(ws(e3, i3, t4));
      const r3 = (e4) => Lt(s3[e4], 1, 1, () => {
        s3[e4] = null;
      });
      return {c() {
        for (let e4 = 0; e4 < s3.length; e4 += 1)
          s3[e4].c();
        t3 = F2();
      }, m(e4, i4) {
        for (let t4 = 0; t4 < s3.length; t4 += 1)
          s3[t4].m(e4, i4);
        I2(e4, t3, i4), n3 = true;
      }, p(e4, n4) {
        if (8263 & n4[0]) {
          let a3;
          for (i3 = e4[13](e4[0]), a3 = 0; a3 < i3.length; a3 += 1) {
            const r4 = ws(e4, i3, a3);
            s3[a3] ? (s3[a3].p(r4, n4), St(s3[a3], 1)) : (s3[a3] = $s(r4), s3[a3].c(), St(s3[a3], 1), s3[a3].m(t3.parentNode, t3));
          }
          for (Ot(), a3 = i3.length; a3 < s3.length; a3 += 1)
            r3(a3);
          It2();
        }
      }, i(e4) {
        if (!n3) {
          for (let e5 = 0; e5 < i3.length; e5 += 1)
            St(s3[e5]);
          n3 = true;
        }
      }, o(e4) {
        s3 = s3.filter(Boolean);
        for (let e5 = 0; e5 < s3.length; e5 += 1)
          Lt(s3[e5]);
        n3 = false;
      }, d(e4) {
        L2(s3, e4), e4 && S2(t3);
      }};
    }
    function $s(e3) {
      let t3, n3, i3 = e3[33];
      const s3 = () => e3[18](t3, i3), r3 = () => e3[18](null, i3);
      let a3 = {item: e3[31], selectionManager: e3[1], undoRedoManager: e3[2]};
      return t3 = new Ms({props: a3}), s3(), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i4) {
        Dt(t3, e4, i4), n3 = true;
      }, p(e4, n4) {
        i3 !== e4[33] && (r3(), i3 = e4[33], s3());
        const a4 = {};
        1 & n4[0] && (a4.item = e4[31]), 2 & n4[0] && (a4.selectionManager = e4[1]), 4 & n4[0] && (a4.undoRedoManager = e4[2]), t3.$set(a4);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        r3(), Ut(t3, e4);
      }};
    }
    function Es(e3) {
      let t3, n3, i3 = e3[0] && bs(e3);
      return {c() {
        i3 && i3.c(), t3 = F2();
      }, m(e4, s3) {
        i3 && i3.m(e4, s3), I2(e4, t3, s3), n3 = true;
      }, p(e4, n4) {
        e4[0] ? i3 ? (i3.p(e4, n4), 1 & n4[0] && St(i3, 1)) : (i3 = bs(e4), i3.c(), St(i3, 1), i3.m(t3.parentNode, t3)) : i3 && (Ot(), Lt(i3, 1, 1, () => {
          i3 = null;
        }), It2());
      }, i(e4) {
        n3 || (St(i3), n3 = true);
      }, o(e4) {
        Lt(i3), n3 = false;
      }, d(e4) {
        i3 && i3.d(e4), e4 && S2(t3);
      }};
    }
    function Ss(e3, t3, n3) {
      let {item: i3} = t3, {selectionManager: s3 = null} = t3, {undoRedoManager: r3 = null} = t3;
      const a3 = (e4) => e4 instanceof MI && e4.getNumChildren() == 1 && (e4.getChild(0) instanceof lC || e4.getChild(0) instanceof nC);
      let o3, l3, h3 = false, c3 = false, d3 = false, u3 = [];
      function f3(e4) {
        if (e4.length > 1) {
          let t4, n4 = -1;
          if (a3(i3) ? (n4 = i3.getChild(0).getChildIndex(e4[2]), t4 = e4.slice(2)) : (n4 = i3.getChildIndex(e4[1]), t4 = e4.slice(1)), n4 != -1) {
            const e5 = u3[n4];
            e5 && e5.expandTree(t4);
          }
        }
      }
      let m3, g3, p3, v3, w3, b3, _3, y3 = false;
      const I3 = () => {
        if (i3 && "isHighlighted" in i3 && (n3(4, c3 = i3.isHighlighted()), c3 && "getHighlight" in i3)) {
          const e4 = i3.getHighlight(), t4 = e4.lerp(new l(0.75, 0.75, 0.75, 0), 0.5);
          n3(10, g3 = e4.toHex()), n3(9, m3 = `${t4.toHex()}60`);
        }
      }, x3 = () => {
        p3 && n3(5, d3 = i3.isVisible());
      }, C3 = () => {
        n3(0, i3);
      };
      return nt(() => {
        i3 && (n3(0, i3.elemRef = l3, i3), n3(11, p3 = i3 instanceof ag), I3(), x3(), p3 && (v3 > -1 && i3.off("childAdded", C3), v3 = i3.on("childAdded", C3), w3 > -1 && (w3 = i3.off("childRemoved", C3)), w3 = i3.on("childRemoved", C3), _3 > -1 && i3.off("visibilityChanged", x3), _3 = i3.on("visibilityChanged", x3), n3(8, y3 = i3.getNumChildren() > 0)), b3 > -1 && i3.off("highlightChanged", I3), b3 = i3.on("highlightChanged", I3));
      }), rt(() => {
        o3 && (f3(o3), o3 = null);
      }), e3.$$set = (e4) => {
        "item" in e4 && n3(0, i3 = e4.item), "selectionManager" in e4 && n3(1, s3 = e4.selectionManager), "undoRedoManager" in e4 && n3(2, r3 = e4.undoRedoManager);
      }, [i3, s3, r3, h3, c3, d3, u3, l3, y3, m3, g3, p3, (e4) => {
        let t4;
        const n4 = e4.getParameter("DisplayName");
        if (t4 = n4 ? n4.getValue() : e4.getName(), a3(e4)) {
          const n5 = e4.getChild(0);
          if (t4 == "") {
            const e5 = n5.getParameter("DisplayName");
            t4 = e5 ? e5.getValue() : n5.getName();
          }
          return {name: t4 + ` (Instance of ${n5.getClassName()})`, tooltip: `(Instance of ${n5.getClassName()})`};
        }
        return {name: t4 + ` (${e4.getClassName()})`, tooltip: `(${e4.getClassName()})`};
      }, (e4) => {
        if (e4 instanceof MI && e4.getNumChildren() == 1) {
          return e4.getChild(0).getChildren();
        }
        return e4.getChildren();
      }, () => {
        n3(3, h3 = !h3);
      }, () => {
        const e4 = i3.getParameter("Visible");
        if (n3(5, d3 = !e4.getValue()), r3) {
          const t4 = new je3.ParameterValueChange(e4, d3);
          r3.addChange(t4);
        } else
          e4.setValue(d3);
      }, (e4) => {
        if (!s3)
          return void i3.setSelected(!i3.getSelected());
        if (s3.pickingModeActive())
          return void s3.pick(i3);
        s3.toggleItemSelection(i3, !e4.ctrlKey);
        const t4 = s3.getSelection();
        i3.setSelected(t4.has(i3));
      }, function(e4) {
        e4[e4.length - 1] != i3 ? (n3(3, h3 = true), u3.length > 0 ? f3(e4) : o3 = e4) : l3.scrollIntoView({behavior: "auto", block: "center", inline: "center"});
      }, function(e4, t4) {
        ft[e4 ? "unshift" : "push"](() => {
          u3[t4] = e4, n3(6, u3);
        });
      }, function(e4) {
        ft[e4 ? "unshift" : "push"](() => {
          l3 = e4, n3(7, l3);
        });
      }];
    }
    var Ms = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Ss, Es, a2, {item: 0, selectionManager: 1, undoRedoManager: 2, expandTree: 17}, null, [-1, -1]);
      }
      get expandTree() {
        return this.$$.ctx[17];
      }
    };
    function Rs(e3, t3, n3) {
      const i3 = e3.slice();
      return i3[12] = t3[n3], i3[13] = t3, i3[14] = n3, i3;
    }
    function Ds(e3) {
      let t3, n3, i3 = e3[14];
      const s3 = () => e3[8](t3, i3), r3 = () => e3[8](null, i3);
      let a3 = {item: e3[12], selectionManager: e3[1], undoRedoManager: e3[2]};
      return t3 = new Ms({props: a3}), s3(), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i4) {
        Dt(t3, e4, i4), n3 = true;
      }, p(e4, n4) {
        i3 !== e4[14] && (r3(), i3 = e4[14], s3());
        const a4 = {};
        1 & n4 && (a4.item = e4[12]), 2 & n4 && (a4.selectionManager = e4[1]), 4 & n4 && (a4.undoRedoManager = e4[2]), t3.$set(a4);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        r3(), Ut(t3, e4);
      }};
    }
    function Os(e3) {
      let t3, n3, i3 = e3[0], a3 = [];
      for (let t4 = 0; t4 < i3.length; t4 += 1)
        a3[t4] = Ds(Rs(e3, i3, t4));
      const l3 = (e4) => Lt(a3[e4], 1, 1, () => {
        a3[e4] = null;
      });
      return {c() {
        t3 = N2("div");
        for (let e4 = 0; e4 < a3.length; e4 += 1)
          a3[e4].c();
        D2(t3, "class", "TreeView min-w-max noselect");
      }, m(i4, s3) {
        I2(i4, t3, s3);
        for (let e4 = 0; e4 < a3.length; e4 += 1)
          a3[e4].m(t3, null);
        e3[9](t3), n3 = true;
      }, p(e4, [n4]) {
        if (23 & n4) {
          let s3;
          for (i3 = e4[0], s3 = 0; s3 < i3.length; s3 += 1) {
            const r3 = Rs(e4, i3, s3);
            a3[s3] ? (a3[s3].p(r3, n4), St(a3[s3], 1)) : (a3[s3] = Ds(r3), a3[s3].c(), St(a3[s3], 1), a3[s3].m(t3, null));
          }
          for (Ot(), s3 = i3.length; s3 < a3.length; s3 += 1)
            l3(s3);
          It2();
        }
      }, i(e4) {
        if (!n3) {
          for (let e5 = 0; e5 < i3.length; e5 += 1)
            St(a3[e5]);
          n3 = true;
        }
      }, o(e4) {
        a3 = a3.filter(Boolean);
        for (let e5 = 0; e5 < a3.length; e5 += 1)
          Lt(a3[e5]);
        n3 = false;
      }, d(n4) {
        n4 && S2(t3), L2(a3, n4), e3[9](null);
      }};
    }
    function Ns(e3, t3, n3) {
      let i3, {rootTreeItems: s3} = t3, {selectionManager: r3 = null} = t3, {undoRedoManager: a3 = null} = t3, {isMouseOver: o3 = null} = t3, l3 = [], {onKeyDownRegistered: h3 = false} = t3, {selectionChangedRegistered: c3 = false} = t3;
      const d3 = (e4) => {
        if (o3 && r3) {
          if (e4.key == "ArrowLeft") {
            const t4 = r3.getSelection(), n4 = new Set();
            return Array.from(t4).forEach((e5) => {
              s3.includes(e5) || n4.add(e5.getOwner());
            }), n4.size > 0 && r3.setSelection(n4), e4.preventDefault(), void e4.stopPropagation();
          }
          if (e4.key == "ArrowRight") {
            const t4 = r3.getSelection(), n4 = new Set();
            return Array.from(t4).forEach((e5) => {
              e5 instanceof ag && e5.getNumChildren() > 0 && !(e5 instanceof dC) && n4.add(e5.getChild(0));
            }), n4.size > 0 && r3.setSelection(n4), e4.preventDefault(), void e4.stopPropagation();
          }
          if (e4.key == "ArrowUp") {
            const t4 = r3.getSelection(), n4 = new Set();
            return Array.from(t4).forEach((e5) => {
              const t5 = e5.getOwner().getChildIndex(e5);
              t5 == 0 ? n4.add(e5.getOwner()) : n4.add(e5.getOwner().getChild(t5 - 1));
            }), n4.size > 0 && r3.setSelection(n4), e4.preventDefault(), void e4.stopPropagation();
          }
          if (e4.key == "ArrowDown") {
            const t4 = r3.getSelection(), n4 = new Set();
            return Array.from(t4).forEach((e5) => {
              const t5 = e5.getOwner().getChildIndex(e5);
              if (t5 < e5.getOwner().getNumChildren() - 1)
                n4.add(e5.getOwner().getChild(t5 + 1));
              else {
                const t6 = e5.getOwner().getChildIndex(e5);
                e5.getOwner().getNumChildren() > t6 + 1 && n4.add(e5.getOwner().getChild(t6 + 1));
              }
            }), n4.size > 0 && r3.setSelection(n4), e4.preventDefault(), void e4.stopPropagation();
          }
        }
      };
      h3 || (document.addEventListener("keydown", d3), h3 = true), nt(() => {
        r3 && !c3 && (r3.on("leadSelectionChanged", () => {
          const e4 = r3.getSelection();
          u3(e4, true);
        }), n3(6, c3 = true));
      });
      const u3 = (e4, t4 = true) => {
        Array.from(e4).forEach((e5) => {
          const n4 = [];
          for (; n4.splice(0, 0, e5), !s3.includes(e5) && e5; )
            e5 = e5.getOwner();
          s3.forEach((e6, i4) => {
            if (e6 != n4[0])
              return;
            l3[i4].expandTree(n4, t4);
          });
        });
      };
      return e3.$$set = (e4) => {
        "rootTreeItems" in e4 && n3(0, s3 = e4.rootTreeItems), "selectionManager" in e4 && n3(1, r3 = e4.selectionManager), "undoRedoManager" in e4 && n3(2, a3 = e4.undoRedoManager), "isMouseOver" in e4 && n3(7, o3 = e4.isMouseOver), "onKeyDownRegistered" in e4 && n3(5, h3 = e4.onKeyDownRegistered), "selectionChangedRegistered" in e4 && n3(6, c3 = e4.selectionChangedRegistered);
      }, [s3, r3, a3, i3, l3, h3, c3, o3, function(e4, t4) {
        ft[e4 ? "unshift" : "push"](() => {
          l3[t4] = e4, n3(4, l3);
        });
      }, function(e4) {
        ft[e4 ? "unshift" : "push"](() => {
          i3 = e4, n3(3, i3);
        });
      }];
    }
    var zs = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Ns, Os, a2, {rootTreeItems: 0, selectionManager: 1, undoRedoManager: 2, isMouseOver: 7, onKeyDownRegistered: 5, selectionChangedRegistered: 6});
      }
    };
    var Ls = se2();
    var Vs = se2();
    function Bs(e3) {
      let t3, n3, i3, h3, c3, d3, g3, v3, b3, _3, I3, x3, A3;
      function $3(t4) {
        e3[9](t4);
      }
      let E3 = {tabs: e3[5]};
      return e3[0] !== void 0 && (E3.selectedTab = e3[0]), n3 = new rs({props: E3}), ft.push(() => qt(n3, "selectedTab", $3)), g3 = new zs({props: {rootTreeItems: e3[2], isMouseOver: e3[1], selectionManager: e3[3], undoRedoManager: e3[4] && e3[4].undoRedoManager}}), _3 = new es({}), {c() {
        t3 = N2("div"), Bt2(n3.$$.fragment), h3 = A2(), c3 = N2("div"), d3 = N2("div"), Bt2(g3.$$.fragment), v3 = A2(), b3 = N2("div"), Bt2(_3.$$.fragment), D2(d3, "class", "h-full"), J2(d3, "hidden", e3[0] !== e3[5][0]), J2(b3, "hidden", e3[0] !== e3[5][1]), D2(c3, "class", "flex-1 overflow-auto"), D2(t3, "class", "Sidebar h-full w-full flex flex-col");
      }, m(i4, s3) {
        I2(i4, t3, s3), Dt(n3, t3, null), E2(t3, h3), E2(t3, c3), E2(c3, d3), Dt(g3, d3, null), E2(c3, v3), E2(c3, b3), Dt(_3, b3, null), I3 = true, x3 || (A3 = [C2(d3, "mouseenter", e3[6]), C2(d3, "mouseleave", e3[7])], x3 = true);
      }, p(e4, [t4]) {
        const s3 = {};
        !i3 && 1 & t4 && (i3 = true, s3.selectedTab = e4[0], bt(() => i3 = false)), n3.$set(s3);
        const r3 = {};
        4 & t4 && (r3.rootTreeItems = e4[2]), 2 & t4 && (r3.isMouseOver = e4[1]), 8 & t4 && (r3.selectionManager = e4[3]), 16 & t4 && (r3.undoRedoManager = e4[4] && e4[4].undoRedoManager), g3.$set(r3), 33 & t4 && J2(d3, "hidden", e4[0] !== e4[5][0]), 33 & t4 && J2(b3, "hidden", e4[0] !== e4[5][1]);
      }, i(e4) {
        I3 || (St(n3.$$.fragment, e4), St(g3.$$.fragment, e4), St(_3.$$.fragment, e4), I3 = true);
      }, o(e4) {
        Lt(n3.$$.fragment, e4), Lt(g3.$$.fragment, e4), Lt(_3.$$.fragment, e4), I3 = false;
      }, d(e4) {
        e4 && S2(t3), Ut(n3), Ut(g3), Ut(_3), x3 = false, s2(A3);
      }};
    }
    function Us(e3, t3, n3) {
      let i3, s3, r3, a3;
      p2(e3, Ls, (e4) => n3(8, s3 = e4)), p2(e3, Vs, (e4) => n3(3, r3 = e4)), p2(e3, Xt2, (e4) => n3(4, a3 = e4));
      let o3, l3;
      return e3.$$.update = () => {
        256 & e3.$$.dirty && n3(2, i3 = [s3]);
      }, [o3, l3, i3, r3, a3, ["Assembly", "Search"], () => {
        n3(1, l3 = true);
      }, () => {
        n3(1, l3 = false);
      }, s3, function(e4) {
        o3 = e4, n3(0, o3);
      }];
    }
    var Xs = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Us, Bs, a2, {});
      }
    };
    function Fs(e3) {
      let t3;
      return {c() {
        t3 = N2("div"), t3.innerHTML = '<div class="m-auto"><div class="flex flex-col items-center justify-center space-y-2"><i class="fas fa-cloud-upload-alt fa-3x text-currentColor"></i> \n          <p class="text-center text-gray-700">Drag your gltf or zcad files here or click in this area.</p></div></div>', D2(t3, "class", "items-center justify-center w-3/12 p-4 py-12 m-auto text-black bg-gray-200 border-2 border-gray-400 rounded-lg h-1/3 bg-opacity-25 hover:bg-blue-200 hover:bg-opacity-25 grid justify-items-center");
      }, m(e4, n3) {
        I2(e4, t3, n3);
      }, d(e4) {
        e4 && S2(t3);
      }};
    }
    function Gs(e3) {
      let t3, n3, i3, h3, c3, d3 = !e3[0] && Fs();
      return {c() {
        t3 = N2("div"), n3 = N2("input"), i3 = A2(), d3 && d3.c(), D2(n3, "accept", ".zcad, .gltf, .glb"), n3.multiple = true, D2(n3, "type", "file"), D2(n3, "class", "absolute inset-0 z-50 w-full h-full p-0 m-0 outline-none opacity-0"), D2(t3, "class", "DropZone absolute inset-0 flex"), J2(t3, "pointer-events-none", e3[1]);
      }, m(s3, r3) {
        I2(s3, t3, r3), E2(t3, n3), E2(t3, i3), d3 && d3.m(t3, null), h3 || (c3 = [C2(n3, "drop", M2(e3[2])), C2(n3, "change", e3[4])], h3 = true);
      }, p(e4, [n4]) {
        e4[0] ? d3 && (d3.d(1), d3 = null) : d3 || (d3 = Fs(), d3.c(), d3.m(t3, null)), 2 & n4 && J2(t3, "pointer-events-none", e4[1]);
      }, i: t2, o: t2, d(e4) {
        e4 && S2(t3), d3 && d3.d(), h3 = false, s2(c3);
      }};
    }
    function Hs(e3, t3, n3) {
      const i3 = it2();
      let {fileLoaded: s3} = t3, r3 = false;
      const a3 = (e4) => {
        i3("changeFile", {files: e4});
      }, o3 = () => {
        s3 && n3(1, r3 = false);
      };
      document.body.addEventListener("dragover", o3), document.body.addEventListener("dragenter", o3);
      const l3 = (e4) => {
        const t4 = [];
        for (var i4 = 0; i4 < e4.target.files.length; i4++)
          t4.push(e4.target.files[i4]);
        a3(t4), n3(0, s3 = true), n3(1, r3 = true);
      };
      return e3.$$set = (e4) => {
        "fileLoaded" in e4 && n3(0, s3 = e4.fileLoaded);
      }, [s3, r3, (e4) => {
        const t4 = [];
        for (var i4 = 0; i4 < e4.dataTransfer.items.length; i4++)
          e4.dataTransfer.items[i4].kind === "file" && t4.push(e4.dataTransfer.items[i4].getAsFile());
        a3(t4), n3(0, s3 = true), n3(1, r3 = true);
      }, l3, (e4) => {
        l3(e4);
      }];
    }
    var js = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Hs, Gs, a2, {fileLoaded: 0});
      }
    };
    var Zs = () => new class extends V {
      constructor() {
        super(), console.log("iframe ChannelMessenger");
        let e3 = false, t3 = false;
        window.addEventListener("message", (i3) => {
          if (i3.data == "ping")
            e3 || t3 || (e3 = true, i3.source.postMessage("ping", "*"));
          else if (i3.data == "initPort") {
            if (console.log("=====initPort========="), t3 = true, this.port2 = i3.ports[0], !this.port2)
              return;
            this.port2.onmessage = n3, this.port2.postMessage("ready");
          }
        });
        const n3 = (e4) => {
          if (console.info("Message received by IFrame:"), console.info(e4.data), !Array.isArray(e4.data) || e4.data.length != 2)
            throw new Error(`Invalid message: ${e4.data}`);
          const t4 = e4.data[0], n4 = e4.data[1];
          this.emit(t4, n4);
        };
      }
      send(e3, t3) {
        this.port2 && this.port2.postMessage([e3, t3]);
      }
    }();
    var Js = (e3) => {
      const t3 = (e4, n3, i3) => {
        const s3 = [...i3, e4.getName()], r3 = {name: e4.getName()};
        if (["Revision", "Rev", "InstanceName"].forEach((t4) => {
          e4.hasParameter(t4) && (r3[t4] = e4.getParameter(t4).getValue());
        }), e4 instanceof nC)
          return r3;
        if (e4.getNumChildren() > 0) {
          const i4 = e4.getChildren();
          r3.children = [];
          for (const e5 of i4)
            e5 && r3.children.push(t3(e5, n3 + 1, s3));
        }
        return r3;
      };
      return t3(e3, 1, []);
    };
    function Ks(e3) {
      let t3, n3, i3;
      return {c() {
        t3 = N2("input"), D2(t3, "type", "range"), D2(t3, "min", "0"), D2(t3, "max", "1000"), D2(t3, "class", "svelte-1ynbs2x");
      }, m(s3, r3) {
        I2(s3, t3, r3), z2(t3, e3[0]), n3 || (i3 = [C2(t3, "change", e3[1]), C2(t3, "input", e3[1])], n3 = true);
      }, p(e4, [n4]) {
        1 & n4 && z2(t3, e4[0]);
      }, i: t2, o: t2, d(e4) {
        e4 && S2(t3), n3 = false, s2(i3);
      }};
    }
    function Ws(e3, t3, n3) {
      let i3;
      p2(e3, Yi2, (e4) => n3(7, i3 = e4));
      let s3 = 0, r3 = false, a3 = new m(), o3 = new o(), l3 = new b(), h3 = new Map();
      ot(async () => {
        console.log("Asm Explode onMount called;"), c3(), r3 = true;
      });
      const c3 = () => {
        new o(), new o();
        const e4 = i3.getRoot(), t4 = e4.boundingBoxParam.value;
        let n4 = t4.center();
        t4.size(), a3.sc = t4.diagonal();
        let s4 = Number.MAX_SAFE_INTEGER;
        e4.traverse((e5) => {
          if (e5 instanceof nC) {
            if (e5.getName() == "M10X25g")
              return;
            const t5 = e5.boundingBoxParam.value.center();
            l3.addPoint(t5);
            let i4 = t5.distanceTo(n4);
            i4 < s4 && (s4 = i4, o3 = t5);
            let r4 = e5.globalXfoParam.value;
            h3.set(e5, {gXfo: r4, center: t5});
          }
        }), a3.sc = l3.diagonal().normalize(), a3.sc.x > 0.8 && (a3.sc.x = 0.1), a3.sc.y > 0.8 && (a3.sc.y = 0.1), a3.sc.z > 0.8 && (a3.sc.z = 0.1);
      };
      return e3.$$.update = () => {
        var t4;
        1 & e3.$$.dirty && (t4 = s3, r3 && i3.getRoot().traverse((e4) => {
          if (e4 instanceof nC) {
            if (e4.getName() == "M10X25g")
              return;
            const n4 = h3.get(e4);
            let i4 = n4.center.subtract(o3);
            i4 = a3.transformVec3(i4);
            let s4 = t4;
            i4.scaleInPlace(s4 * s4 / 1e5);
            let r4 = new m();
            r4.setFromOther(n4.gXfo), r4.tr = n4.gXfo.tr.add(i4), e4.globalXfoParam.value = r4;
          }
        }));
      }, [s3, function() {
        s3 = H2(this.value), n3(0, s3);
      }];
    }
    var Ys = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Ws, Ks, a2, {});
      }
    };
    var qs = it(function(e3) {
      function t3(e4) {
        var t4, n3, i3, s3, r3, a3 = Math.floor, o3 = new Array(64), l3 = new Array(64), h3 = new Array(64), c3 = new Array(64), d3 = new Array(65535), u3 = new Array(65535), f3 = new Array(64), m3 = new Array(64), g3 = [], p3 = 0, v3 = 7, w3 = new Array(64), b3 = new Array(64), _3 = new Array(64), y3 = new Array(256), I3 = new Array(2048), x3 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], P3 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], C3 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], k3 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], T3 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], A3 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], $3 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], E3 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], S3 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
        function M3(e5, t5) {
          for (var n4 = 0, i4 = 0, s4 = new Array(), r4 = 1; r4 <= 16; r4++) {
            for (var a4 = 1; a4 <= e5[r4]; a4++)
              s4[t5[i4]] = [], s4[t5[i4]][0] = n4, s4[t5[i4]][1] = r4, i4++, n4++;
            n4 *= 2;
          }
          return s4;
        }
        function R3(e5) {
          for (var t5 = e5[0], n4 = e5[1] - 1; n4 >= 0; )
            t5 & 1 << n4 && (p3 |= 1 << v3), n4--, --v3 < 0 && (p3 == 255 ? (D3(255), D3(0)) : D3(p3), v3 = 7, p3 = 0);
        }
        function D3(e5) {
          g3.push(e5);
        }
        function O3(e5) {
          D3(e5 >> 8 & 255), D3(255 & e5);
        }
        function N3(e5, t5, n4, i4, s4) {
          for (var r4, a4 = s4[0], o4 = s4[240], l4 = function(e6, t6) {
            var n5, i5, s5, r5, a5, o5, l5, h5, c5, d4, u4 = 0;
            for (c5 = 0; c5 < 8; ++c5) {
              n5 = e6[u4], i5 = e6[u4 + 1], s5 = e6[u4 + 2], r5 = e6[u4 + 3], a5 = e6[u4 + 4], o5 = e6[u4 + 5], l5 = e6[u4 + 6];
              var m4 = n5 + (h5 = e6[u4 + 7]), g5 = n5 - h5, p5 = i5 + l5, v5 = i5 - l5, w5 = s5 + o5, b5 = s5 - o5, _5 = r5 + a5, y4 = r5 - a5, I4 = m4 + _5, x4 = m4 - _5, P4 = p5 + w5, C4 = p5 - w5;
              e6[u4] = I4 + P4, e6[u4 + 4] = I4 - P4;
              var k4 = 0.707106781 * (C4 + x4);
              e6[u4 + 2] = x4 + k4, e6[u4 + 6] = x4 - k4;
              var T4 = 0.382683433 * ((I4 = y4 + b5) - (C4 = v5 + g5)), A4 = 0.5411961 * I4 + T4, $4 = 1.306562965 * C4 + T4, E4 = 0.707106781 * (P4 = b5 + v5), S4 = g5 + E4, M4 = g5 - E4;
              e6[u4 + 5] = M4 + A4, e6[u4 + 3] = M4 - A4, e6[u4 + 1] = S4 + $4, e6[u4 + 7] = S4 - $4, u4 += 8;
            }
            for (u4 = 0, c5 = 0; c5 < 8; ++c5) {
              n5 = e6[u4], i5 = e6[u4 + 8], s5 = e6[u4 + 16], r5 = e6[u4 + 24], a5 = e6[u4 + 32], o5 = e6[u4 + 40], l5 = e6[u4 + 48];
              var R4 = n5 + (h5 = e6[u4 + 56]), D4 = n5 - h5, O4 = i5 + l5, N4 = i5 - l5, z4 = s5 + o5, L3 = s5 - o5, V3 = r5 + a5, B3 = r5 - a5, U3 = R4 + V3, X3 = R4 - V3, F3 = O4 + z4, G3 = O4 - z4;
              e6[u4] = U3 + F3, e6[u4 + 32] = U3 - F3;
              var H3 = 0.707106781 * (G3 + X3);
              e6[u4 + 16] = X3 + H3, e6[u4 + 48] = X3 - H3;
              var j3 = 0.382683433 * ((U3 = B3 + L3) - (G3 = N4 + D4)), Z3 = 0.5411961 * U3 + j3, J3 = 1.306562965 * G3 + j3, K3 = 0.707106781 * (F3 = L3 + N4), W3 = D4 + K3, Y3 = D4 - K3;
              e6[u4 + 40] = Y3 + Z3, e6[u4 + 24] = Y3 - Z3, e6[u4 + 8] = W3 + J3, e6[u4 + 56] = W3 - J3, u4++;
            }
            for (c5 = 0; c5 < 64; ++c5)
              d4 = e6[c5] * t6[c5], f3[c5] = d4 > 0 ? d4 + 0.5 | 0 : d4 - 0.5 | 0;
            return f3;
          }(e5, t5), h4 = 0; h4 < 64; ++h4)
            m3[x3[h4]] = l4[h4];
          var c4 = m3[0] - n4;
          n4 = m3[0], c4 == 0 ? R3(i4[0]) : (R3(i4[u3[r4 = 32767 + c4]]), R3(d3[r4]));
          for (var g4 = 63; g4 > 0 && m3[g4] == 0; g4--)
            ;
          if (g4 == 0)
            return R3(a4), n4;
          for (var p4, v4 = 1; v4 <= g4; ) {
            for (var w4 = v4; m3[v4] == 0 && v4 <= g4; ++v4)
              ;
            var b4 = v4 - w4;
            if (b4 >= 16) {
              p4 = b4 >> 4;
              for (var _4 = 1; _4 <= p4; ++_4)
                R3(o4);
              b4 &= 15;
            }
            r4 = 32767 + m3[v4], R3(s4[(b4 << 4) + u3[r4]]), R3(d3[r4]), v4++;
          }
          return g4 != 63 && R3(a4), n4;
        }
        function z3(e5) {
          if (e5 <= 0 && (e5 = 1), e5 > 100 && (e5 = 100), r3 != e5) {
            (function(e6) {
              for (var t5 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], n4 = 0; n4 < 64; n4++) {
                var i4 = a3((t5[n4] * e6 + 50) / 100);
                i4 < 1 ? i4 = 1 : i4 > 255 && (i4 = 255), o3[x3[n4]] = i4;
              }
              for (var s4 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], r4 = 0; r4 < 64; r4++) {
                var d4 = a3((s4[r4] * e6 + 50) / 100);
                d4 < 1 ? d4 = 1 : d4 > 255 && (d4 = 255), l3[x3[r4]] = d4;
              }
              for (var u4 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], f4 = 0, m4 = 0; m4 < 8; m4++)
                for (var g4 = 0; g4 < 8; g4++)
                  h3[f4] = 1 / (o3[x3[f4]] * u4[m4] * u4[g4] * 8), c3[f4] = 1 / (l3[x3[f4]] * u4[m4] * u4[g4] * 8), f4++;
            })(e5 < 50 ? Math.floor(5e3 / e5) : Math.floor(200 - 2 * e5)), r3 = e5;
          }
        }
        this.encode = function(e5, r4) {
          new Date().getTime(), r4 && z3(r4), g3 = new Array(), p3 = 0, v3 = 7, O3(65496), O3(65504), O3(16), D3(74), D3(70), D3(73), D3(70), D3(0), D3(1), D3(1), D3(0), O3(1), O3(1), D3(0), D3(0), function(e6) {
            if (e6) {
              O3(65505), e6[0] === 69 && e6[1] === 120 && e6[2] === 105 && e6[3] === 102 ? O3(e6.length + 2) : (O3(e6.length + 5 + 2), D3(69), D3(120), D3(105), D3(102), D3(0));
              for (var t5 = 0; t5 < e6.length; t5++)
                D3(e6[t5]);
            }
          }(e5.exifBuffer), function() {
            O3(65499), O3(132), D3(0);
            for (var e6 = 0; e6 < 64; e6++)
              D3(o3[e6]);
            D3(1);
            for (var t5 = 0; t5 < 64; t5++)
              D3(l3[t5]);
          }(), function(e6, t5) {
            O3(65472), O3(17), D3(8), O3(t5), O3(e6), D3(3), D3(1), D3(17), D3(0), D3(2), D3(17), D3(1), D3(3), D3(17), D3(1);
          }(e5.width, e5.height), function() {
            O3(65476), O3(418), D3(0);
            for (var e6 = 0; e6 < 16; e6++)
              D3(P3[e6 + 1]);
            for (var t5 = 0; t5 <= 11; t5++)
              D3(C3[t5]);
            D3(16);
            for (var n4 = 0; n4 < 16; n4++)
              D3(k3[n4 + 1]);
            for (var i4 = 0; i4 <= 161; i4++)
              D3(T3[i4]);
            D3(1);
            for (var s4 = 0; s4 < 16; s4++)
              D3(A3[s4 + 1]);
            for (var r5 = 0; r5 <= 11; r5++)
              D3($3[r5]);
            D3(17);
            for (var a5 = 0; a5 < 16; a5++)
              D3(E3[a5 + 1]);
            for (var o4 = 0; o4 <= 161; o4++)
              D3(S3[o4]);
          }(), O3(65498), O3(12), D3(3), D3(1), D3(0), D3(2), D3(17), D3(3), D3(17), D3(0), D3(63), D3(0);
          var a4 = 0, d4 = 0, u4 = 0;
          p3 = 0, v3 = 7, this.encode.displayName = "_encode_";
          for (var f4, m4, y4, x4, M4, L3, V3, B3, U3, X3 = e5.data, F3 = e5.width, G3 = e5.height, H3 = 4 * F3, j3 = 0; j3 < G3; ) {
            for (f4 = 0; f4 < H3; ) {
              for (L3 = M4 = H3 * j3 + f4, V3 = -1, B3 = 0, U3 = 0; U3 < 64; U3++)
                L3 = M4 + (B3 = U3 >> 3) * H3 + (V3 = 4 * (7 & U3)), j3 + B3 >= G3 && (L3 -= H3 * (j3 + 1 + B3 - G3)), f4 + V3 >= H3 && (L3 -= f4 + V3 - H3 + 4), m4 = X3[L3++], y4 = X3[L3++], x4 = X3[L3++], w3[U3] = (I3[m4] + I3[y4 + 256 >> 0] + I3[x4 + 512 >> 0] >> 16) - 128, b3[U3] = (I3[m4 + 768 >> 0] + I3[y4 + 1024 >> 0] + I3[x4 + 1280 >> 0] >> 16) - 128, _3[U3] = (I3[m4 + 1280 >> 0] + I3[y4 + 1536 >> 0] + I3[x4 + 1792 >> 0] >> 16) - 128;
              a4 = N3(w3, h3, a4, t4, i3), d4 = N3(b3, c3, d4, n3, s3), u4 = N3(_3, c3, u4, n3, s3), f4 += 32;
            }
            j3 += 8;
          }
          if (v3 >= 0) {
            var Z3 = [];
            Z3[1] = v3 + 1, Z3[0] = (1 << v3 + 1) - 1, R3(Z3);
          }
          return O3(65497), Buffer.from(g3);
        }, new Date().getTime(), e4 || (e4 = 50), function() {
          for (var e5 = String.fromCharCode, t5 = 0; t5 < 256; t5++)
            y3[t5] = e5(t5);
        }(), t4 = M3(P3, C3), n3 = M3(A3, $3), i3 = M3(k3, T3), s3 = M3(E3, S3), function() {
          for (var e5 = 1, t5 = 2, n4 = 1; n4 <= 15; n4++) {
            for (var i4 = e5; i4 < t5; i4++)
              u3[32767 + i4] = n4, d3[32767 + i4] = [], d3[32767 + i4][1] = n4, d3[32767 + i4][0] = i4;
            for (var s4 = -(t5 - 1); s4 <= -e5; s4++)
              u3[32767 + s4] = n4, d3[32767 + s4] = [], d3[32767 + s4][1] = n4, d3[32767 + s4][0] = t5 - 1 + s4;
            e5 <<= 1, t5 <<= 1;
          }
        }(), function() {
          for (var e5 = 0; e5 < 256; e5++)
            I3[e5] = 19595 * e5, I3[e5 + 256 >> 0] = 38470 * e5, I3[e5 + 512 >> 0] = 7471 * e5 + 32768, I3[e5 + 768 >> 0] = -11059 * e5, I3[e5 + 1024 >> 0] = -21709 * e5, I3[e5 + 1280 >> 0] = 32768 * e5 + 8421375, I3[e5 + 1536 >> 0] = -27439 * e5, I3[e5 + 1792 >> 0] = -5329 * e5;
        }(), z3(e4), new Date().getTime();
      }
      e3.exports = function(e4, n3) {
        n3 === void 0 && (n3 = 50);
        return {data: new t3(n3).encode(e4, n3), width: e4.width, height: e4.height};
      };
    });
    var Qs = it(function(e3) {
      var t3 = function() {
        var e4 = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), t4 = 4017, n3 = 799, i3 = 3406, s3 = 2276, r3 = 1567, a3 = 3784, o3 = 5793, l3 = 2896;
        function h3() {
        }
        function c3(e5, t5) {
          for (var n4, i4, s4 = 0, r4 = [], a4 = 16; a4 > 0 && !e5[a4 - 1]; )
            a4--;
          r4.push({children: [], index: 0});
          var o4, l4 = r4[0];
          for (n4 = 0; n4 < a4; n4++) {
            for (i4 = 0; i4 < e5[n4]; i4++) {
              for ((l4 = r4.pop()).children[l4.index] = t5[s4]; l4.index > 0; ) {
                if (r4.length === 0)
                  throw new Error("Could not recreate Huffman Table");
                l4 = r4.pop();
              }
              for (l4.index++, r4.push(l4); r4.length <= n4; )
                r4.push(o4 = {children: [], index: 0}), l4.children[l4.index] = o4.children, l4 = o4;
              s4++;
            }
            n4 + 1 < a4 && (r4.push(o4 = {children: [], index: 0}), l4.children[l4.index] = o4.children, l4 = o4);
          }
          return r4[0].children;
        }
        function d3(t5, n4, i4, s4, r4, a4, o4, l4, h4, c4) {
          i4.precision, i4.samplesPerLine, i4.scanLines;
          var d4 = i4.mcusPerLine, u4 = i4.progressive;
          i4.maxH, i4.maxV;
          var f4 = n4, m4 = 0, g4 = 0;
          function p4() {
            if (g4 > 0)
              return g4--, m4 >> g4 & 1;
            if ((m4 = t5[n4++]) == 255) {
              var e5 = t5[n4++];
              if (e5)
                throw new Error("unexpected marker: " + (m4 << 8 | e5).toString(16));
            }
            return g4 = 7, m4 >>> 7;
          }
          function v3(e5) {
            for (var t6, n5 = e5; (t6 = p4()) !== null; ) {
              if (typeof (n5 = n5[t6]) == "number")
                return n5;
              if (typeof n5 != "object")
                throw new Error("invalid huffman sequence");
            }
            return null;
          }
          function w3(e5) {
            for (var t6 = 0; e5 > 0; ) {
              var n5 = p4();
              if (n5 === null)
                return;
              t6 = t6 << 1 | n5, e5--;
            }
            return t6;
          }
          function b3(e5) {
            var t6 = w3(e5);
            return t6 >= 1 << e5 - 1 ? t6 : t6 + (-1 << e5) + 1;
          }
          var _3 = 0;
          var y3, I3 = 0;
          function x3(e5, t6, n5, i5, s5) {
            var r5 = n5 % d4, a5 = (n5 / d4 | 0) * e5.v + i5, o5 = r5 * e5.h + s5;
            e5.blocks[a5] === void 0 && c4.tolerantDecoding || t6(e5, e5.blocks[a5][o5]);
          }
          function P3(e5, t6, n5) {
            var i5 = n5 / e5.blocksPerLine | 0, s5 = n5 % e5.blocksPerLine;
            e5.blocks[i5] === void 0 && c4.tolerantDecoding || t6(e5, e5.blocks[i5][s5]);
          }
          var C3, k3, T3, A3, $3, E3, S3 = s4.length;
          E3 = u4 ? a4 === 0 ? l4 === 0 ? function(e5, t6) {
            var n5 = v3(e5.huffmanTableDC), i5 = n5 === 0 ? 0 : b3(n5) << h4;
            t6[0] = e5.pred += i5;
          } : function(e5, t6) {
            t6[0] |= p4() << h4;
          } : l4 === 0 ? function(t6, n5) {
            if (_3 > 0)
              _3--;
            else
              for (var i5 = a4, s5 = o4; i5 <= s5; ) {
                var r5 = v3(t6.huffmanTableAC), l5 = 15 & r5, c5 = r5 >> 4;
                if (l5 !== 0)
                  n5[e4[i5 += c5]] = b3(l5) * (1 << h4), i5++;
                else {
                  if (c5 < 15) {
                    _3 = w3(c5) + (1 << c5) - 1;
                    break;
                  }
                  i5 += 16;
                }
              }
          } : function(t6, n5) {
            for (var i5 = a4, s5 = o4, r5 = 0; i5 <= s5; ) {
              var l5 = e4[i5], c5 = n5[l5] < 0 ? -1 : 1;
              switch (I3) {
                case 0:
                  var d5 = v3(t6.huffmanTableAC), u5 = 15 & d5;
                  if (r5 = d5 >> 4, u5 === 0)
                    r5 < 15 ? (_3 = w3(r5) + (1 << r5), I3 = 4) : (r5 = 16, I3 = 1);
                  else {
                    if (u5 !== 1)
                      throw new Error("invalid ACn encoding");
                    y3 = b3(u5), I3 = r5 ? 2 : 3;
                  }
                  continue;
                case 1:
                case 2:
                  n5[l5] ? n5[l5] += (p4() << h4) * c5 : --r5 == 0 && (I3 = I3 == 2 ? 3 : 0);
                  break;
                case 3:
                  n5[l5] ? n5[l5] += (p4() << h4) * c5 : (n5[l5] = y3 << h4, I3 = 0);
                  break;
                case 4:
                  n5[l5] && (n5[l5] += (p4() << h4) * c5);
              }
              i5++;
            }
            I3 === 4 && --_3 == 0 && (I3 = 0);
          } : function(t6, n5) {
            var i5 = v3(t6.huffmanTableDC), s5 = i5 === 0 ? 0 : b3(i5);
            n5[0] = t6.pred += s5;
            for (var r5 = 1; r5 < 64; ) {
              var a5 = v3(t6.huffmanTableAC), o5 = 15 & a5, l5 = a5 >> 4;
              if (o5 !== 0)
                n5[e4[r5 += l5]] = b3(o5), r5++;
              else {
                if (l5 < 15)
                  break;
                r5 += 16;
              }
            }
          };
          var M3, R3, D3, O3, N3 = 0;
          for (R3 = S3 == 1 ? s4[0].blocksPerLine * s4[0].blocksPerColumn : d4 * i4.mcusPerColumn, r4 || (r4 = R3); N3 < R3; ) {
            for (k3 = 0; k3 < S3; k3++)
              s4[k3].pred = 0;
            if (_3 = 0, S3 == 1)
              for (C3 = s4[0], $3 = 0; $3 < r4; $3++)
                P3(C3, E3, N3), N3++;
            else
              for ($3 = 0; $3 < r4; $3++) {
                for (k3 = 0; k3 < S3; k3++)
                  for (D3 = (C3 = s4[k3]).h, O3 = C3.v, T3 = 0; T3 < O3; T3++)
                    for (A3 = 0; A3 < D3; A3++)
                      x3(C3, E3, N3, T3, A3);
                if (++N3 === R3)
                  break;
              }
            if (N3 === R3)
              do {
                if (t5[n4] === 255 && t5[n4 + 1] !== 0)
                  break;
                n4 += 1;
              } while (n4 < t5.length - 2);
            if (g4 = 0, (M3 = t5[n4] << 8 | t5[n4 + 1]) < 65280)
              throw new Error("marker was not found");
            if (!(M3 >= 65488 && M3 <= 65495))
              break;
            n4 += 2;
          }
          return n4 - f4;
        }
        function u3(e5, h4) {
          var c4, d4, u4 = [], f4 = h4.blocksPerLine, m4 = h4.blocksPerColumn, g4 = f4 << 3, v3 = new Int32Array(64), w3 = new Uint8Array(64);
          function b3(e6, c5, d5) {
            var u5, f5, m5, g5, p4, v4, w4, b4, _4, y4, I4 = h4.quantizationTable, x4 = d5;
            for (y4 = 0; y4 < 64; y4++)
              x4[y4] = e6[y4] * I4[y4];
            for (y4 = 0; y4 < 8; ++y4) {
              var P4 = 8 * y4;
              x4[1 + P4] != 0 || x4[2 + P4] != 0 || x4[3 + P4] != 0 || x4[4 + P4] != 0 || x4[5 + P4] != 0 || x4[6 + P4] != 0 || x4[7 + P4] != 0 ? (u5 = o3 * x4[0 + P4] + 128 >> 8, f5 = o3 * x4[4 + P4] + 128 >> 8, m5 = x4[2 + P4], g5 = x4[6 + P4], p4 = l3 * (x4[1 + P4] - x4[7 + P4]) + 128 >> 8, b4 = l3 * (x4[1 + P4] + x4[7 + P4]) + 128 >> 8, v4 = x4[3 + P4] << 4, w4 = x4[5 + P4] << 4, _4 = u5 - f5 + 1 >> 1, u5 = u5 + f5 + 1 >> 1, f5 = _4, _4 = m5 * a3 + g5 * r3 + 128 >> 8, m5 = m5 * r3 - g5 * a3 + 128 >> 8, g5 = _4, _4 = p4 - w4 + 1 >> 1, p4 = p4 + w4 + 1 >> 1, w4 = _4, _4 = b4 + v4 + 1 >> 1, v4 = b4 - v4 + 1 >> 1, b4 = _4, _4 = u5 - g5 + 1 >> 1, u5 = u5 + g5 + 1 >> 1, g5 = _4, _4 = f5 - m5 + 1 >> 1, f5 = f5 + m5 + 1 >> 1, m5 = _4, _4 = p4 * s3 + b4 * i3 + 2048 >> 12, p4 = p4 * i3 - b4 * s3 + 2048 >> 12, b4 = _4, _4 = v4 * n3 + w4 * t4 + 2048 >> 12, v4 = v4 * t4 - w4 * n3 + 2048 >> 12, w4 = _4, x4[0 + P4] = u5 + b4, x4[7 + P4] = u5 - b4, x4[1 + P4] = f5 + w4, x4[6 + P4] = f5 - w4, x4[2 + P4] = m5 + v4, x4[5 + P4] = m5 - v4, x4[3 + P4] = g5 + p4, x4[4 + P4] = g5 - p4) : (_4 = o3 * x4[0 + P4] + 512 >> 10, x4[0 + P4] = _4, x4[1 + P4] = _4, x4[2 + P4] = _4, x4[3 + P4] = _4, x4[4 + P4] = _4, x4[5 + P4] = _4, x4[6 + P4] = _4, x4[7 + P4] = _4);
            }
            for (y4 = 0; y4 < 8; ++y4) {
              var C4 = y4;
              x4[8 + C4] != 0 || x4[16 + C4] != 0 || x4[24 + C4] != 0 || x4[32 + C4] != 0 || x4[40 + C4] != 0 || x4[48 + C4] != 0 || x4[56 + C4] != 0 ? (u5 = o3 * x4[0 + C4] + 2048 >> 12, f5 = o3 * x4[32 + C4] + 2048 >> 12, m5 = x4[16 + C4], g5 = x4[48 + C4], p4 = l3 * (x4[8 + C4] - x4[56 + C4]) + 2048 >> 12, b4 = l3 * (x4[8 + C4] + x4[56 + C4]) + 2048 >> 12, v4 = x4[24 + C4], w4 = x4[40 + C4], _4 = u5 - f5 + 1 >> 1, u5 = u5 + f5 + 1 >> 1, f5 = _4, _4 = m5 * a3 + g5 * r3 + 2048 >> 12, m5 = m5 * r3 - g5 * a3 + 2048 >> 12, g5 = _4, _4 = p4 - w4 + 1 >> 1, p4 = p4 + w4 + 1 >> 1, w4 = _4, _4 = b4 + v4 + 1 >> 1, v4 = b4 - v4 + 1 >> 1, b4 = _4, _4 = u5 - g5 + 1 >> 1, u5 = u5 + g5 + 1 >> 1, g5 = _4, _4 = f5 - m5 + 1 >> 1, f5 = f5 + m5 + 1 >> 1, m5 = _4, _4 = p4 * s3 + b4 * i3 + 2048 >> 12, p4 = p4 * i3 - b4 * s3 + 2048 >> 12, b4 = _4, _4 = v4 * n3 + w4 * t4 + 2048 >> 12, v4 = v4 * t4 - w4 * n3 + 2048 >> 12, w4 = _4, x4[0 + C4] = u5 + b4, x4[56 + C4] = u5 - b4, x4[8 + C4] = f5 + w4, x4[48 + C4] = f5 - w4, x4[16 + C4] = m5 + v4, x4[40 + C4] = m5 - v4, x4[24 + C4] = g5 + p4, x4[32 + C4] = g5 - p4) : (_4 = o3 * d5[y4 + 0] + 8192 >> 14, x4[0 + C4] = _4, x4[8 + C4] = _4, x4[16 + C4] = _4, x4[24 + C4] = _4, x4[32 + C4] = _4, x4[40 + C4] = _4, x4[48 + C4] = _4, x4[56 + C4] = _4);
            }
            for (y4 = 0; y4 < 64; ++y4) {
              var k3 = 128 + (x4[y4] + 8 >> 4);
              c5[y4] = k3 < 0 ? 0 : k3 > 255 ? 255 : k3;
            }
          }
          p3(g4 * m4 * 8);
          for (var _3 = 0; _3 < m4; _3++) {
            var y3 = _3 << 3;
            for (c4 = 0; c4 < 8; c4++)
              u4.push(new Uint8Array(g4));
            for (var I3 = 0; I3 < f4; I3++) {
              b3(h4.blocks[_3][I3], w3, v3);
              var x3 = 0, P3 = I3 << 3;
              for (d4 = 0; d4 < 8; d4++) {
                var C3 = u4[y3 + d4];
                for (c4 = 0; c4 < 8; c4++)
                  C3[P3 + c4] = w3[x3++];
              }
            }
          }
          return u4;
        }
        function f3(e5) {
          return e5 < 0 ? 0 : e5 > 255 ? 255 : e5;
        }
        h3.prototype = {load: function(e5) {
          var t5 = new XMLHttpRequest();
          t5.open("GET", e5, true), t5.responseType = "arraybuffer", t5.onload = function() {
            var e6 = new Uint8Array(t5.response || t5.mozResponseArrayBuffer);
            this.parse(e6), this.onload && this.onload();
          }.bind(this), t5.send(null);
        }, parse: function(t5) {
          var n4 = 1e3 * this.opts.maxResolutionInMP * 1e3, i4 = 0;
          function s4() {
            var e5 = t5[i4] << 8 | t5[i4 + 1];
            return i4 += 2, e5;
          }
          function r4(e5) {
            var t6, n5, i5 = 0, s5 = 0;
            for (n5 in e5.components)
              e5.components.hasOwnProperty(n5) && (i5 < (t6 = e5.components[n5]).h && (i5 = t6.h), s5 < t6.v && (s5 = t6.v));
            var r5 = Math.ceil(e5.samplesPerLine / 8 / i5), a5 = Math.ceil(e5.scanLines / 8 / s5);
            for (n5 in e5.components)
              if (e5.components.hasOwnProperty(n5)) {
                t6 = e5.components[n5];
                var o5 = Math.ceil(Math.ceil(e5.samplesPerLine / 8) * t6.h / i5), l5 = Math.ceil(Math.ceil(e5.scanLines / 8) * t6.v / s5), h5 = r5 * t6.h, c4 = a5 * t6.v, d4 = [];
                p3(256 * (c4 * h5));
                for (var u4 = 0; u4 < c4; u4++) {
                  for (var f5 = [], m5 = 0; m5 < h5; m5++)
                    f5.push(new Int32Array(64));
                  d4.push(f5);
                }
                t6.blocksPerLine = o5, t6.blocksPerColumn = l5, t6.blocks = d4;
              }
            e5.maxH = i5, e5.maxV = s5, e5.mcusPerLine = r5, e5.mcusPerColumn = a5;
          }
          t5.length;
          var a4, o4, l4, h4, f4 = null, m4 = null, g4 = [], v3 = [], w3 = [], b3 = [], _3 = s4(), y3 = -1;
          if (this.comments = [], _3 != 65496)
            throw new Error("SOI not found");
          for (_3 = s4(); _3 != 65497; ) {
            switch (_3) {
              case 65280:
                break;
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534:
                var I3 = (l4 = void 0, h4 = void 0, l4 = s4(), h4 = t5.subarray(i4, i4 + l4 - 2), i4 += h4.length, h4);
                if (_3 === 65534) {
                  var x3 = String.fromCharCode.apply(null, I3);
                  this.comments.push(x3);
                }
                _3 === 65504 && I3[0] === 74 && I3[1] === 70 && I3[2] === 73 && I3[3] === 70 && I3[4] === 0 && (f4 = {version: {major: I3[5], minor: I3[6]}, densityUnits: I3[7], xDensity: I3[8] << 8 | I3[9], yDensity: I3[10] << 8 | I3[11], thumbWidth: I3[12], thumbHeight: I3[13], thumbData: I3.subarray(14, 14 + 3 * I3[12] * I3[13])}), _3 === 65505 && I3[0] === 69 && I3[1] === 120 && I3[2] === 105 && I3[3] === 102 && I3[4] === 0 && (this.exifBuffer = I3.subarray(5, I3.length)), _3 === 65518 && I3[0] === 65 && I3[1] === 100 && I3[2] === 111 && I3[3] === 98 && I3[4] === 101 && I3[5] === 0 && (m4 = {version: I3[6], flags0: I3[7] << 8 | I3[8], flags1: I3[9] << 8 | I3[10], transformCode: I3[11]});
                break;
              case 65499:
                for (var P3 = s4() + i4 - 2; i4 < P3; ) {
                  var C3 = t5[i4++];
                  p3(256);
                  var k3 = new Int32Array(64);
                  if (C3 >> 4 == 0)
                    for (J3 = 0; J3 < 64; J3++) {
                      k3[e4[J3]] = t5[i4++];
                    }
                  else {
                    if (C3 >> 4 != 1)
                      throw new Error("DQT: invalid table spec");
                    for (J3 = 0; J3 < 64; J3++) {
                      k3[e4[J3]] = s4();
                    }
                  }
                  g4[15 & C3] = k3;
                }
                break;
              case 65472:
              case 65473:
              case 65474:
                s4(), (a4 = {}).extended = _3 === 65473, a4.progressive = _3 === 65474, a4.precision = t5[i4++], a4.scanLines = s4(), a4.samplesPerLine = s4(), a4.components = {}, a4.componentsOrder = [];
                var T3 = a4.scanLines * a4.samplesPerLine;
                if (T3 > n4) {
                  var A3 = Math.ceil((T3 - n4) / 1e6);
                  throw new Error(`maxResolutionInMP limit exceeded by ${A3}MP`);
                }
                var $3, E3 = t5[i4++];
                for (j3 = 0; j3 < E3; j3++) {
                  $3 = t5[i4];
                  var S3 = t5[i4 + 1] >> 4, M3 = 15 & t5[i4 + 1], R3 = t5[i4 + 2];
                  a4.componentsOrder.push($3), a4.components[$3] = {h: S3, v: M3, quantizationIdx: R3}, i4 += 3;
                }
                r4(a4), v3.push(a4);
                break;
              case 65476:
                var D3 = s4();
                for (j3 = 2; j3 < D3; ) {
                  var O3 = t5[i4++], N3 = new Uint8Array(16), z3 = 0;
                  for (J3 = 0; J3 < 16; J3++, i4++)
                    z3 += N3[J3] = t5[i4];
                  p3(16 + z3);
                  var L3 = new Uint8Array(z3);
                  for (J3 = 0; J3 < z3; J3++, i4++)
                    L3[J3] = t5[i4];
                  j3 += 17 + z3, (O3 >> 4 == 0 ? b3 : w3)[15 & O3] = c3(N3, L3);
                }
                break;
              case 65501:
                s4(), o4 = s4();
                break;
              case 65500:
                s4(), s4();
                break;
              case 65498:
                s4();
                var V3 = t5[i4++], B3 = [];
                for (j3 = 0; j3 < V3; j3++) {
                  K3 = a4.components[t5[i4++]];
                  var U3 = t5[i4++];
                  K3.huffmanTableDC = b3[U3 >> 4], K3.huffmanTableAC = w3[15 & U3], B3.push(K3);
                }
                var X3 = t5[i4++], F3 = t5[i4++], G3 = t5[i4++], H3 = d3(t5, i4, a4, B3, o4, X3, F3, G3 >> 4, 15 & G3, this.opts);
                i4 += H3;
                break;
              case 65535:
                t5[i4] !== 255 && i4--;
                break;
              default:
                if (t5[i4 - 3] == 255 && t5[i4 - 2] >= 192 && t5[i4 - 2] <= 254) {
                  i4 -= 3;
                  break;
                }
                if (_3 === 224 || _3 == 225) {
                  if (y3 !== -1)
                    throw new Error(`first unknown JPEG marker at offset ${y3.toString(16)}, second unknown JPEG marker ${_3.toString(16)} at offset ${(i4 - 1).toString(16)}`);
                  y3 = i4 - 1;
                  const e5 = s4();
                  if (t5[i4 + e5 - 2] === 255) {
                    i4 += e5 - 2;
                    break;
                  }
                }
                throw new Error("unknown JPEG marker " + _3.toString(16));
            }
            _3 = s4();
          }
          if (v3.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var j3 = 0; j3 < v3.length; j3++) {
            var Z3 = v3[j3].components;
            for (var J3 in Z3)
              Z3[J3].quantizationTable = g4[Z3[J3].quantizationIdx], delete Z3[J3].quantizationIdx;
          }
          this.width = a4.samplesPerLine, this.height = a4.scanLines, this.jfif = f4, this.adobe = m4, this.components = [];
          for (j3 = 0; j3 < a4.componentsOrder.length; j3++) {
            var K3 = a4.components[a4.componentsOrder[j3]];
            this.components.push({lines: u3(0, K3), scaleX: K3.h / a4.maxH, scaleY: K3.v / a4.maxV});
          }
        }, getData: function(e5, t5) {
          var n4, i4, s4, r4, a4, o4, l4, h4, c4, d4, u4, m4, g4, v3, w3, b3, _3, y3, I3, x3, P3, C3 = this.width / e5, k3 = this.height / t5, T3 = 0, A3 = e5 * t5 * this.components.length;
          p3(A3);
          var $3 = new Uint8Array(A3);
          switch (this.components.length) {
            case 1:
              for (n4 = this.components[0], d4 = 0; d4 < t5; d4++)
                for (a4 = n4.lines[0 | d4 * n4.scaleY * k3], c4 = 0; c4 < e5; c4++)
                  u4 = a4[0 | c4 * n4.scaleX * C3], $3[T3++] = u4;
              break;
            case 2:
              for (n4 = this.components[0], i4 = this.components[1], d4 = 0; d4 < t5; d4++)
                for (a4 = n4.lines[0 | d4 * n4.scaleY * k3], o4 = i4.lines[0 | d4 * i4.scaleY * k3], c4 = 0; c4 < e5; c4++)
                  u4 = a4[0 | c4 * n4.scaleX * C3], $3[T3++] = u4, u4 = o4[0 | c4 * i4.scaleX * C3], $3[T3++] = u4;
              break;
            case 3:
              for (P3 = true, this.adobe && this.adobe.transformCode ? P3 = true : this.opts.colorTransform !== void 0 && (P3 = !!this.opts.colorTransform), n4 = this.components[0], i4 = this.components[1], s4 = this.components[2], d4 = 0; d4 < t5; d4++)
                for (a4 = n4.lines[0 | d4 * n4.scaleY * k3], o4 = i4.lines[0 | d4 * i4.scaleY * k3], l4 = s4.lines[0 | d4 * s4.scaleY * k3], c4 = 0; c4 < e5; c4++)
                  P3 ? (u4 = a4[0 | c4 * n4.scaleX * C3], m4 = o4[0 | c4 * i4.scaleX * C3], y3 = f3(u4 + 1.402 * ((g4 = l4[0 | c4 * s4.scaleX * C3]) - 128)), I3 = f3(u4 - 0.3441363 * (m4 - 128) - 0.71413636 * (g4 - 128)), x3 = f3(u4 + 1.772 * (m4 - 128))) : (y3 = a4[0 | c4 * n4.scaleX * C3], I3 = o4[0 | c4 * i4.scaleX * C3], x3 = l4[0 | c4 * s4.scaleX * C3]), $3[T3++] = y3, $3[T3++] = I3, $3[T3++] = x3;
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              for (P3 = false, this.adobe && this.adobe.transformCode ? P3 = true : this.opts.colorTransform !== void 0 && (P3 = !!this.opts.colorTransform), n4 = this.components[0], i4 = this.components[1], s4 = this.components[2], r4 = this.components[3], d4 = 0; d4 < t5; d4++)
                for (a4 = n4.lines[0 | d4 * n4.scaleY * k3], o4 = i4.lines[0 | d4 * i4.scaleY * k3], l4 = s4.lines[0 | d4 * s4.scaleY * k3], h4 = r4.lines[0 | d4 * r4.scaleY * k3], c4 = 0; c4 < e5; c4++)
                  P3 ? (u4 = a4[0 | c4 * n4.scaleX * C3], m4 = o4[0 | c4 * i4.scaleX * C3], g4 = l4[0 | c4 * s4.scaleX * C3], v3 = h4[0 | c4 * r4.scaleX * C3], w3 = 255 - f3(u4 + 1.402 * (g4 - 128)), b3 = 255 - f3(u4 - 0.3441363 * (m4 - 128) - 0.71413636 * (g4 - 128)), _3 = 255 - f3(u4 + 1.772 * (m4 - 128))) : (w3 = a4[0 | c4 * n4.scaleX * C3], b3 = o4[0 | c4 * i4.scaleX * C3], _3 = l4[0 | c4 * s4.scaleX * C3], v3 = h4[0 | c4 * r4.scaleX * C3]), $3[T3++] = 255 - w3, $3[T3++] = 255 - b3, $3[T3++] = 255 - _3, $3[T3++] = 255 - v3;
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return $3;
        }, copyToImageData: function(e5, t5) {
          var n4, i4, s4, r4, a4, o4, l4, h4, c4, d4 = e5.width, u4 = e5.height, m4 = e5.data, g4 = this.getData(d4, u4), p4 = 0, v3 = 0;
          switch (this.components.length) {
            case 1:
              for (i4 = 0; i4 < u4; i4++)
                for (n4 = 0; n4 < d4; n4++)
                  s4 = g4[p4++], m4[v3++] = s4, m4[v3++] = s4, m4[v3++] = s4, t5 && (m4[v3++] = 255);
              break;
            case 3:
              for (i4 = 0; i4 < u4; i4++)
                for (n4 = 0; n4 < d4; n4++)
                  l4 = g4[p4++], h4 = g4[p4++], c4 = g4[p4++], m4[v3++] = l4, m4[v3++] = h4, m4[v3++] = c4, t5 && (m4[v3++] = 255);
              break;
            case 4:
              for (i4 = 0; i4 < u4; i4++)
                for (n4 = 0; n4 < d4; n4++)
                  a4 = g4[p4++], o4 = g4[p4++], s4 = g4[p4++], l4 = 255 - f3(a4 * (1 - (r4 = g4[p4++]) / 255) + r4), h4 = 255 - f3(o4 * (1 - r4 / 255) + r4), c4 = 255 - f3(s4 * (1 - r4 / 255) + r4), m4[v3++] = l4, m4[v3++] = h4, m4[v3++] = c4, t5 && (m4[v3++] = 255);
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        }};
        var m3 = 0, g3 = 0;
        function p3(e5 = 0) {
          var t5 = m3 + e5;
          if (t5 > g3) {
            var n4 = Math.ceil((t5 - g3) / 1024 / 1024);
            throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${n4}MB`);
          }
          m3 = t5;
        }
        return h3.resetMaxMemoryUsage = function(e5) {
          m3 = 0, g3 = e5;
        }, h3.getBytesAllocated = function() {
          return m3;
        }, h3.requestMemoryAllocation = p3, h3;
      }();
      e3.exports = function(e4, n3 = {}) {
        var i3 = {colorTransform: void 0, useTArray: false, formatAsRGBA: true, tolerantDecoding: true, maxResolutionInMP: 100, maxMemoryUsageInMB: 512, ...n3}, s3 = new Uint8Array(e4), r3 = new t3();
        r3.opts = i3, t3.resetMaxMemoryUsage(1024 * i3.maxMemoryUsageInMB * 1024), r3.parse(s3);
        var a3 = i3.formatAsRGBA ? 4 : 3, o3 = r3.width * r3.height * a3;
        try {
          t3.requestMemoryAllocation(o3);
          var l3 = {width: r3.width, height: r3.height, exifBuffer: r3.exifBuffer, data: i3.useTArray ? new Uint8Array(o3) : Buffer.alloc(o3)};
          r3.comments.length > 0 && (l3.comments = r3.comments);
        } catch (e5) {
          throw e5 instanceof RangeError ? new Error("Could not allocate enough memory for the image. Required: " + o3) : e5;
        }
        return r3.copyToImageData(l3, i3.formatAsRGBA), l3;
      };
    });
    var er = {encode: qs, decode: Qs};
    !function(e3) {
      if (e3.TextEncoder && e3.TextDecoder)
        return false;
      function t3(e4 = "utf-8") {
        if (e4 !== "utf-8")
          throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${e4}') is invalid.`);
      }
      function n3(e4 = "utf-8", t4 = {fatal: false}) {
        if (e4 !== "utf-8")
          throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${e4}') is invalid.`);
        if (t4.fatal)
          throw new Error("Failed to construct 'TextDecoder': the 'fatal' option is unsupported.");
      }
      Object.defineProperty(t3.prototype, "encoding", {value: "utf-8"}), t3.prototype.encode = function(e4, t4 = {stream: false}) {
        if (t4.stream)
          throw new Error("Failed to encode: the 'stream' option is unsupported.");
        let n4 = 0;
        const i3 = e4.length;
        let s3 = 0, r3 = Math.max(32, i3 + (i3 >> 1) + 7), a3 = new Uint8Array(r3 >> 3 << 3);
        for (; n4 < i3; ) {
          let t5 = e4.charCodeAt(n4++);
          if (t5 >= 55296 && t5 <= 56319) {
            if (n4 < i3) {
              const i4 = e4.charCodeAt(n4);
              (64512 & i4) == 56320 && (++n4, t5 = ((1023 & t5) << 10) + (1023 & i4) + 65536);
            }
            if (t5 >= 55296 && t5 <= 56319)
              continue;
          }
          if (s3 + 4 > a3.length) {
            r3 += 8, r3 *= 1 + n4 / e4.length * 2, r3 = r3 >> 3 << 3;
            const t6 = new Uint8Array(r3);
            t6.set(a3), a3 = t6;
          }
          if ((4294967168 & t5) != 0) {
            if ((4294965248 & t5) == 0)
              a3[s3++] = t5 >> 6 & 31 | 192;
            else if ((4294901760 & t5) == 0)
              a3[s3++] = t5 >> 12 & 15 | 224, a3[s3++] = t5 >> 6 & 63 | 128;
            else {
              if ((4292870144 & t5) != 0)
                continue;
              a3[s3++] = t5 >> 18 & 7 | 240, a3[s3++] = t5 >> 12 & 63 | 128, a3[s3++] = t5 >> 6 & 63 | 128;
            }
            a3[s3++] = 63 & t5 | 128;
          } else
            a3[s3++] = t5;
        }
        return a3.slice(0, s3);
      }, Object.defineProperty(n3.prototype, "encoding", {value: "utf-8"}), Object.defineProperty(n3.prototype, "fatal", {value: false}), Object.defineProperty(n3.prototype, "ignoreBOM", {value: false}), n3.prototype.decode = function(e4, t4 = {stream: false}) {
        if (t4.stream)
          throw new Error("Failed to decode: the 'stream' option is unsupported.");
        const n4 = new Uint8Array(e4);
        let i3 = 0;
        const s3 = n4.length, r3 = [];
        for (; i3 < s3; ) {
          const e5 = n4[i3++];
          if (e5 === 0)
            break;
          if ((128 & e5) == 0)
            r3.push(e5);
          else if ((224 & e5) == 192) {
            const t5 = 63 & n4[i3++];
            r3.push((31 & e5) << 6 | t5);
          } else if ((240 & e5) == 224) {
            const t5 = 63 & n4[i3++], s4 = 63 & n4[i3++];
            r3.push((31 & e5) << 12 | t5 << 6 | s4);
          } else if ((248 & e5) == 240) {
            let t5 = (7 & e5) << 18 | (63 & n4[i3++]) << 12 | (63 & n4[i3++]) << 6 | 63 & n4[i3++];
            t5 > 65535 && (t5 -= 65536, r3.push(t5 >>> 10 & 1023 | 55296), t5 = 56320 | 1023 & t5), r3.push(t5);
          }
        }
        return String.fromCharCode.apply(null, r3);
      }, e3.TextEncoder = t3, e3.TextDecoder = n3;
    }(typeof window != "undefined" ? window : typeof self != "undefined" ? self : void 0);
    var tr = new TextDecoder("utf-8");
    var nr = new TextEncoder();
    var ir = class {
      constructor(e3 = 8192, t3 = {}) {
        let n3 = false;
        typeof e3 == "number" ? e3 = new ArrayBuffer(e3) : (n3 = true, this.lastWrittenByte = e3.byteLength);
        const i3 = t3.offset ? t3.offset >>> 0 : 0, s3 = e3.byteLength - i3;
        let r3 = i3;
        (ArrayBuffer.isView(e3) || e3 instanceof ir) && (e3.byteLength !== e3.buffer.byteLength && (r3 = e3.byteOffset + i3), e3 = e3.buffer), this.lastWrittenByte = n3 ? s3 : 0, this.buffer = e3, this.length = s3, this.byteLength = s3, this.byteOffset = r3, this.offset = 0, this.littleEndian = true, this._data = new DataView(this.buffer, r3, s3), this._mark = 0, this._marks = [];
      }
      available(e3 = 1) {
        return this.offset + e3 <= this.length;
      }
      isLittleEndian() {
        return this.littleEndian;
      }
      setLittleEndian() {
        return this.littleEndian = true, this;
      }
      isBigEndian() {
        return !this.littleEndian;
      }
      setBigEndian() {
        return this.littleEndian = false, this;
      }
      skip(e3 = 1) {
        return this.offset += e3, this;
      }
      seek(e3) {
        return this.offset = e3, this;
      }
      mark() {
        return this._mark = this.offset, this;
      }
      reset() {
        return this.offset = this._mark, this;
      }
      pushMark() {
        return this._marks.push(this.offset), this;
      }
      popMark() {
        const e3 = this._marks.pop();
        if (e3 === void 0)
          throw new Error("Mark stack empty");
        return this.seek(e3), this;
      }
      rewind() {
        return this.offset = 0, this;
      }
      ensureAvailable(e3 = 1) {
        if (!this.available(e3)) {
          const t3 = 2 * (this.offset + e3), n3 = new Uint8Array(t3);
          n3.set(new Uint8Array(this.buffer)), this.buffer = n3.buffer, this.length = this.byteLength = t3, this._data = new DataView(this.buffer);
        }
        return this;
      }
      readBoolean() {
        return this.readUint8() !== 0;
      }
      readInt8() {
        return this._data.getInt8(this.offset++);
      }
      readUint8() {
        return this._data.getUint8(this.offset++);
      }
      readByte() {
        return this.readUint8();
      }
      readBytes(e3 = 1) {
        const t3 = new Uint8Array(e3);
        for (let n3 = 0; n3 < e3; n3++)
          t3[n3] = this.readByte();
        return t3;
      }
      readInt16() {
        const e3 = this._data.getInt16(this.offset, this.littleEndian);
        return this.offset += 2, e3;
      }
      readUint16() {
        const e3 = this._data.getUint16(this.offset, this.littleEndian);
        return this.offset += 2, e3;
      }
      readInt32() {
        const e3 = this._data.getInt32(this.offset, this.littleEndian);
        return this.offset += 4, e3;
      }
      readUint32() {
        const e3 = this._data.getUint32(this.offset, this.littleEndian);
        return this.offset += 4, e3;
      }
      readFloat32() {
        const e3 = this._data.getFloat32(this.offset, this.littleEndian);
        return this.offset += 4, e3;
      }
      readFloat64() {
        const e3 = this._data.getFloat64(this.offset, this.littleEndian);
        return this.offset += 8, e3;
      }
      readChar() {
        return String.fromCharCode(this.readInt8());
      }
      readChars(e3 = 1) {
        let t3 = "";
        for (let n3 = 0; n3 < e3; n3++)
          t3 += this.readChar();
        return t3;
      }
      readUtf8(e3 = 1) {
        return t3 = this.readBytes(e3), tr.decode(t3);
        var t3;
      }
      writeBoolean(e3) {
        return this.writeUint8(e3 ? 255 : 0), this;
      }
      writeInt8(e3) {
        return this.ensureAvailable(1), this._data.setInt8(this.offset++, e3), this._updateLastWrittenByte(), this;
      }
      writeUint8(e3) {
        return this.ensureAvailable(1), this._data.setUint8(this.offset++, e3), this._updateLastWrittenByte(), this;
      }
      writeByte(e3) {
        return this.writeUint8(e3);
      }
      writeBytes(e3) {
        this.ensureAvailable(e3.length);
        for (let t3 = 0; t3 < e3.length; t3++)
          this._data.setUint8(this.offset++, e3[t3]);
        return this._updateLastWrittenByte(), this;
      }
      writeInt16(e3) {
        return this.ensureAvailable(2), this._data.setInt16(this.offset, e3, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
      }
      writeUint16(e3) {
        return this.ensureAvailable(2), this._data.setUint16(this.offset, e3, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this;
      }
      writeInt32(e3) {
        return this.ensureAvailable(4), this._data.setInt32(this.offset, e3, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
      }
      writeUint32(e3) {
        return this.ensureAvailable(4), this._data.setUint32(this.offset, e3, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
      }
      writeFloat32(e3) {
        return this.ensureAvailable(4), this._data.setFloat32(this.offset, e3, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this;
      }
      writeFloat64(e3) {
        return this.ensureAvailable(8), this._data.setFloat64(this.offset, e3, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this;
      }
      writeChar(e3) {
        return this.writeUint8(e3.charCodeAt(0));
      }
      writeChars(e3) {
        for (let t3 = 0; t3 < e3.length; t3++)
          this.writeUint8(e3.charCodeAt(t3));
        return this;
      }
      writeUtf8(e3) {
        return this.writeBytes(function(e4) {
          return nr.encode(e4);
        }(e3));
      }
      toArray() {
        return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
      }
      _updateLastWrittenByte() {
        this.offset > this.lastWrittenByte && (this.lastWrittenByte = this.offset);
      }
    };
    /*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */
    function sr(e3) {
      let t3 = e3.length;
      for (; --t3 >= 0; )
        e3[t3] = 0;
    }
    var rr = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
    var ar = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    var or = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
    var lr = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var hr = new Array(576);
    sr(hr);
    var cr = new Array(60);
    sr(cr);
    var dr = new Array(512);
    sr(dr);
    var ur = new Array(256);
    sr(ur);
    var fr = new Array(29);
    sr(fr);
    var mr = new Array(30);
    function gr(e3, t3, n3, i3, s3) {
      this.static_tree = e3, this.extra_bits = t3, this.extra_base = n3, this.elems = i3, this.max_length = s3, this.has_stree = e3 && e3.length;
    }
    var pr;
    var vr;
    var wr;
    function br(e3, t3) {
      this.dyn_tree = e3, this.max_code = 0, this.stat_desc = t3;
    }
    sr(mr);
    var _r = (e3) => e3 < 256 ? dr[e3] : dr[256 + (e3 >>> 7)];
    var yr = (e3, t3) => {
      e3.pending_buf[e3.pending++] = 255 & t3, e3.pending_buf[e3.pending++] = t3 >>> 8 & 255;
    };
    var Ir = (e3, t3, n3) => {
      e3.bi_valid > 16 - n3 ? (e3.bi_buf |= t3 << e3.bi_valid & 65535, yr(e3, e3.bi_buf), e3.bi_buf = t3 >> 16 - e3.bi_valid, e3.bi_valid += n3 - 16) : (e3.bi_buf |= t3 << e3.bi_valid & 65535, e3.bi_valid += n3);
    };
    var xr = (e3, t3, n3) => {
      Ir(e3, n3[2 * t3], n3[2 * t3 + 1]);
    };
    var Pr = (e3, t3) => {
      let n3 = 0;
      do {
        n3 |= 1 & e3, e3 >>>= 1, n3 <<= 1;
      } while (--t3 > 0);
      return n3 >>> 1;
    };
    var Cr = (e3, t3, n3) => {
      const i3 = new Array(16);
      let s3, r3, a3 = 0;
      for (s3 = 1; s3 <= 15; s3++)
        i3[s3] = a3 = a3 + n3[s3 - 1] << 1;
      for (r3 = 0; r3 <= t3; r3++) {
        let t4 = e3[2 * r3 + 1];
        t4 !== 0 && (e3[2 * r3] = Pr(i3[t4]++, t4));
      }
    };
    var kr = (e3) => {
      let t3;
      for (t3 = 0; t3 < 286; t3++)
        e3.dyn_ltree[2 * t3] = 0;
      for (t3 = 0; t3 < 30; t3++)
        e3.dyn_dtree[2 * t3] = 0;
      for (t3 = 0; t3 < 19; t3++)
        e3.bl_tree[2 * t3] = 0;
      e3.dyn_ltree[512] = 1, e3.opt_len = e3.static_len = 0, e3.last_lit = e3.matches = 0;
    };
    var Tr = (e3) => {
      e3.bi_valid > 8 ? yr(e3, e3.bi_buf) : e3.bi_valid > 0 && (e3.pending_buf[e3.pending++] = e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0;
    };
    var Ar = (e3, t3, n3, i3) => {
      const s3 = 2 * t3, r3 = 2 * n3;
      return e3[s3] < e3[r3] || e3[s3] === e3[r3] && i3[t3] <= i3[n3];
    };
    var $r = (e3, t3, n3) => {
      const i3 = e3.heap[n3];
      let s3 = n3 << 1;
      for (; s3 <= e3.heap_len && (s3 < e3.heap_len && Ar(t3, e3.heap[s3 + 1], e3.heap[s3], e3.depth) && s3++, !Ar(t3, i3, e3.heap[s3], e3.depth)); )
        e3.heap[n3] = e3.heap[s3], n3 = s3, s3 <<= 1;
      e3.heap[n3] = i3;
    };
    var Er = (e3, t3, n3) => {
      let i3, s3, r3, a3, o3 = 0;
      if (e3.last_lit !== 0)
        do {
          i3 = e3.pending_buf[e3.d_buf + 2 * o3] << 8 | e3.pending_buf[e3.d_buf + 2 * o3 + 1], s3 = e3.pending_buf[e3.l_buf + o3], o3++, i3 === 0 ? xr(e3, s3, t3) : (r3 = ur[s3], xr(e3, r3 + 256 + 1, t3), a3 = rr[r3], a3 !== 0 && (s3 -= fr[r3], Ir(e3, s3, a3)), i3--, r3 = _r(i3), xr(e3, r3, n3), a3 = ar[r3], a3 !== 0 && (i3 -= mr[r3], Ir(e3, i3, a3)));
        } while (o3 < e3.last_lit);
      xr(e3, 256, t3);
    };
    var Sr = (e3, t3) => {
      const n3 = t3.dyn_tree, i3 = t3.stat_desc.static_tree, s3 = t3.stat_desc.has_stree, r3 = t3.stat_desc.elems;
      let a3, o3, l3, h3 = -1;
      for (e3.heap_len = 0, e3.heap_max = 573, a3 = 0; a3 < r3; a3++)
        n3[2 * a3] !== 0 ? (e3.heap[++e3.heap_len] = h3 = a3, e3.depth[a3] = 0) : n3[2 * a3 + 1] = 0;
      for (; e3.heap_len < 2; )
        l3 = e3.heap[++e3.heap_len] = h3 < 2 ? ++h3 : 0, n3[2 * l3] = 1, e3.depth[l3] = 0, e3.opt_len--, s3 && (e3.static_len -= i3[2 * l3 + 1]);
      for (t3.max_code = h3, a3 = e3.heap_len >> 1; a3 >= 1; a3--)
        $r(e3, n3, a3);
      l3 = r3;
      do {
        a3 = e3.heap[1], e3.heap[1] = e3.heap[e3.heap_len--], $r(e3, n3, 1), o3 = e3.heap[1], e3.heap[--e3.heap_max] = a3, e3.heap[--e3.heap_max] = o3, n3[2 * l3] = n3[2 * a3] + n3[2 * o3], e3.depth[l3] = (e3.depth[a3] >= e3.depth[o3] ? e3.depth[a3] : e3.depth[o3]) + 1, n3[2 * a3 + 1] = n3[2 * o3 + 1] = l3, e3.heap[1] = l3++, $r(e3, n3, 1);
      } while (e3.heap_len >= 2);
      e3.heap[--e3.heap_max] = e3.heap[1], ((e4, t4) => {
        const n4 = t4.dyn_tree, i4 = t4.max_code, s4 = t4.stat_desc.static_tree, r4 = t4.stat_desc.has_stree, a4 = t4.stat_desc.extra_bits, o4 = t4.stat_desc.extra_base, l4 = t4.stat_desc.max_length;
        let h4, c3, d3, u3, f3, m3, g3 = 0;
        for (u3 = 0; u3 <= 15; u3++)
          e4.bl_count[u3] = 0;
        for (n4[2 * e4.heap[e4.heap_max] + 1] = 0, h4 = e4.heap_max + 1; h4 < 573; h4++)
          c3 = e4.heap[h4], u3 = n4[2 * n4[2 * c3 + 1] + 1] + 1, u3 > l4 && (u3 = l4, g3++), n4[2 * c3 + 1] = u3, c3 > i4 || (e4.bl_count[u3]++, f3 = 0, c3 >= o4 && (f3 = a4[c3 - o4]), m3 = n4[2 * c3], e4.opt_len += m3 * (u3 + f3), r4 && (e4.static_len += m3 * (s4[2 * c3 + 1] + f3)));
        if (g3 !== 0) {
          do {
            for (u3 = l4 - 1; e4.bl_count[u3] === 0; )
              u3--;
            e4.bl_count[u3]--, e4.bl_count[u3 + 1] += 2, e4.bl_count[l4]--, g3 -= 2;
          } while (g3 > 0);
          for (u3 = l4; u3 !== 0; u3--)
            for (c3 = e4.bl_count[u3]; c3 !== 0; )
              d3 = e4.heap[--h4], d3 > i4 || (n4[2 * d3 + 1] !== u3 && (e4.opt_len += (u3 - n4[2 * d3 + 1]) * n4[2 * d3], n4[2 * d3 + 1] = u3), c3--);
        }
      })(e3, t3), Cr(n3, h3, e3.bl_count);
    };
    var Mr = (e3, t3, n3) => {
      let i3, s3, r3 = -1, a3 = t3[1], o3 = 0, l3 = 7, h3 = 4;
      for (a3 === 0 && (l3 = 138, h3 = 3), t3[2 * (n3 + 1) + 1] = 65535, i3 = 0; i3 <= n3; i3++)
        s3 = a3, a3 = t3[2 * (i3 + 1) + 1], ++o3 < l3 && s3 === a3 || (o3 < h3 ? e3.bl_tree[2 * s3] += o3 : s3 !== 0 ? (s3 !== r3 && e3.bl_tree[2 * s3]++, e3.bl_tree[32]++) : o3 <= 10 ? e3.bl_tree[34]++ : e3.bl_tree[36]++, o3 = 0, r3 = s3, a3 === 0 ? (l3 = 138, h3 = 3) : s3 === a3 ? (l3 = 6, h3 = 3) : (l3 = 7, h3 = 4));
    };
    var Rr = (e3, t3, n3) => {
      let i3, s3, r3 = -1, a3 = t3[1], o3 = 0, l3 = 7, h3 = 4;
      for (a3 === 0 && (l3 = 138, h3 = 3), i3 = 0; i3 <= n3; i3++)
        if (s3 = a3, a3 = t3[2 * (i3 + 1) + 1], !(++o3 < l3 && s3 === a3)) {
          if (o3 < h3)
            do {
              xr(e3, s3, e3.bl_tree);
            } while (--o3 != 0);
          else
            s3 !== 0 ? (s3 !== r3 && (xr(e3, s3, e3.bl_tree), o3--), xr(e3, 16, e3.bl_tree), Ir(e3, o3 - 3, 2)) : o3 <= 10 ? (xr(e3, 17, e3.bl_tree), Ir(e3, o3 - 3, 3)) : (xr(e3, 18, e3.bl_tree), Ir(e3, o3 - 11, 7));
          o3 = 0, r3 = s3, a3 === 0 ? (l3 = 138, h3 = 3) : s3 === a3 ? (l3 = 6, h3 = 3) : (l3 = 7, h3 = 4);
        }
    };
    var Dr = false;
    var Or = (e3, t3, n3, i3) => {
      Ir(e3, 0 + (i3 ? 1 : 0), 3), ((e4, t4, n4, i4) => {
        Tr(e4), i4 && (yr(e4, n4), yr(e4, ~n4)), e4.pending_buf.set(e4.window.subarray(t4, t4 + n4), e4.pending), e4.pending += n4;
      })(e3, t3, n3, true);
    };
    var Nr = (e3, t3, n3, i3) => {
      let s3, r3, a3 = 0;
      e3.level > 0 ? (e3.strm.data_type === 2 && (e3.strm.data_type = ((e4) => {
        let t4, n4 = 4093624447;
        for (t4 = 0; t4 <= 31; t4++, n4 >>>= 1)
          if (1 & n4 && e4.dyn_ltree[2 * t4] !== 0)
            return 0;
        if (e4.dyn_ltree[18] !== 0 || e4.dyn_ltree[20] !== 0 || e4.dyn_ltree[26] !== 0)
          return 1;
        for (t4 = 32; t4 < 256; t4++)
          if (e4.dyn_ltree[2 * t4] !== 0)
            return 1;
        return 0;
      })(e3)), Sr(e3, e3.l_desc), Sr(e3, e3.d_desc), a3 = ((e4) => {
        let t4;
        for (Mr(e4, e4.dyn_ltree, e4.l_desc.max_code), Mr(e4, e4.dyn_dtree, e4.d_desc.max_code), Sr(e4, e4.bl_desc), t4 = 18; t4 >= 3 && e4.bl_tree[2 * lr[t4] + 1] === 0; t4--)
          ;
        return e4.opt_len += 3 * (t4 + 1) + 5 + 5 + 4, t4;
      })(e3), s3 = e3.opt_len + 3 + 7 >>> 3, r3 = e3.static_len + 3 + 7 >>> 3, r3 <= s3 && (s3 = r3)) : s3 = r3 = n3 + 5, n3 + 4 <= s3 && t3 !== -1 ? Or(e3, t3, n3, i3) : e3.strategy === 4 || r3 === s3 ? (Ir(e3, 2 + (i3 ? 1 : 0), 3), Er(e3, hr, cr)) : (Ir(e3, 4 + (i3 ? 1 : 0), 3), ((e4, t4, n4, i4) => {
        let s4;
        for (Ir(e4, t4 - 257, 5), Ir(e4, n4 - 1, 5), Ir(e4, i4 - 4, 4), s4 = 0; s4 < i4; s4++)
          Ir(e4, e4.bl_tree[2 * lr[s4] + 1], 3);
        Rr(e4, e4.dyn_ltree, t4 - 1), Rr(e4, e4.dyn_dtree, n4 - 1);
      })(e3, e3.l_desc.max_code + 1, e3.d_desc.max_code + 1, a3 + 1), Er(e3, e3.dyn_ltree, e3.dyn_dtree)), kr(e3), i3 && Tr(e3);
    };
    var zr = {_tr_init: (e3) => {
      Dr || ((() => {
        let e4, t3, n3, i3, s3;
        const r3 = new Array(16);
        for (n3 = 0, i3 = 0; i3 < 28; i3++)
          for (fr[i3] = n3, e4 = 0; e4 < 1 << rr[i3]; e4++)
            ur[n3++] = i3;
        for (ur[n3 - 1] = i3, s3 = 0, i3 = 0; i3 < 16; i3++)
          for (mr[i3] = s3, e4 = 0; e4 < 1 << ar[i3]; e4++)
            dr[s3++] = i3;
        for (s3 >>= 7; i3 < 30; i3++)
          for (mr[i3] = s3 << 7, e4 = 0; e4 < 1 << ar[i3] - 7; e4++)
            dr[256 + s3++] = i3;
        for (t3 = 0; t3 <= 15; t3++)
          r3[t3] = 0;
        for (e4 = 0; e4 <= 143; )
          hr[2 * e4 + 1] = 8, e4++, r3[8]++;
        for (; e4 <= 255; )
          hr[2 * e4 + 1] = 9, e4++, r3[9]++;
        for (; e4 <= 279; )
          hr[2 * e4 + 1] = 7, e4++, r3[7]++;
        for (; e4 <= 287; )
          hr[2 * e4 + 1] = 8, e4++, r3[8]++;
        for (Cr(hr, 287, r3), e4 = 0; e4 < 30; e4++)
          cr[2 * e4 + 1] = 5, cr[2 * e4] = Pr(e4, 5);
        pr = new gr(hr, rr, 257, 286, 15), vr = new gr(cr, ar, 0, 30, 15), wr = new gr(new Array(0), or, 0, 19, 7);
      })(), Dr = true), e3.l_desc = new br(e3.dyn_ltree, pr), e3.d_desc = new br(e3.dyn_dtree, vr), e3.bl_desc = new br(e3.bl_tree, wr), e3.bi_buf = 0, e3.bi_valid = 0, kr(e3);
    }, _tr_stored_block: Or, _tr_flush_block: Nr, _tr_tally: (e3, t3, n3) => (e3.pending_buf[e3.d_buf + 2 * e3.last_lit] = t3 >>> 8 & 255, e3.pending_buf[e3.d_buf + 2 * e3.last_lit + 1] = 255 & t3, e3.pending_buf[e3.l_buf + e3.last_lit] = 255 & n3, e3.last_lit++, t3 === 0 ? e3.dyn_ltree[2 * n3]++ : (e3.matches++, t3--, e3.dyn_ltree[2 * (ur[n3] + 256 + 1)]++, e3.dyn_dtree[2 * _r(t3)]++), e3.last_lit === e3.lit_bufsize - 1), _tr_align: (e3) => {
      Ir(e3, 2, 3), xr(e3, 256, hr), ((e4) => {
        e4.bi_valid === 16 ? (yr(e4, e4.bi_buf), e4.bi_buf = 0, e4.bi_valid = 0) : e4.bi_valid >= 8 && (e4.pending_buf[e4.pending++] = 255 & e4.bi_buf, e4.bi_buf >>= 8, e4.bi_valid -= 8);
      })(e3);
    }};
    var Lr = (e3, t3, n3, i3) => {
      let s3 = 65535 & e3 | 0, r3 = e3 >>> 16 & 65535 | 0, a3 = 0;
      for (; n3 !== 0; ) {
        a3 = n3 > 2e3 ? 2e3 : n3, n3 -= a3;
        do {
          s3 = s3 + t3[i3++] | 0, r3 = r3 + s3 | 0;
        } while (--a3);
        s3 %= 65521, r3 %= 65521;
      }
      return s3 | r3 << 16 | 0;
    };
    var Vr = new Uint32Array((() => {
      let e3, t3 = [];
      for (var n3 = 0; n3 < 256; n3++) {
        e3 = n3;
        for (var i3 = 0; i3 < 8; i3++)
          e3 = 1 & e3 ? 3988292384 ^ e3 >>> 1 : e3 >>> 1;
        t3[n3] = e3;
      }
      return t3;
    })());
    var Br = (e3, t3, n3, i3) => {
      const s3 = Vr, r3 = i3 + n3;
      e3 ^= -1;
      for (let n4 = i3; n4 < r3; n4++)
        e3 = e3 >>> 8 ^ s3[255 & (e3 ^ t3[n4])];
      return -1 ^ e3;
    };
    var Ur = {2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version"};
    var Xr = {Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8};
    var {_tr_init: Fr, _tr_stored_block: Gr, _tr_flush_block: Hr, _tr_tally: jr, _tr_align: Zr} = zr;
    var {Z_NO_FLUSH: Jr, Z_PARTIAL_FLUSH: Kr, Z_FULL_FLUSH: Wr, Z_FINISH: Yr, Z_BLOCK: qr, Z_OK: Qr, Z_STREAM_END: ea, Z_STREAM_ERROR: ta, Z_DATA_ERROR: na, Z_BUF_ERROR: ia, Z_DEFAULT_COMPRESSION: sa, Z_FILTERED: ra, Z_HUFFMAN_ONLY: aa, Z_RLE: oa, Z_FIXED: la, Z_DEFAULT_STRATEGY: ha, Z_UNKNOWN: ca, Z_DEFLATED: da} = Xr;
    var ua = (e3, t3) => (e3.msg = Ur[t3], t3);
    var fa = (e3) => (e3 << 1) - (e3 > 4 ? 9 : 0);
    var ma = (e3) => {
      let t3 = e3.length;
      for (; --t3 >= 0; )
        e3[t3] = 0;
    };
    var ga = (e3, t3, n3) => (t3 << e3.hash_shift ^ n3) & e3.hash_mask;
    var pa = (e3) => {
      const t3 = e3.state;
      let n3 = t3.pending;
      n3 > e3.avail_out && (n3 = e3.avail_out), n3 !== 0 && (e3.output.set(t3.pending_buf.subarray(t3.pending_out, t3.pending_out + n3), e3.next_out), e3.next_out += n3, t3.pending_out += n3, e3.total_out += n3, e3.avail_out -= n3, t3.pending -= n3, t3.pending === 0 && (t3.pending_out = 0));
    };
    var va = (e3, t3) => {
      Hr(e3, e3.block_start >= 0 ? e3.block_start : -1, e3.strstart - e3.block_start, t3), e3.block_start = e3.strstart, pa(e3.strm);
    };
    var wa = (e3, t3) => {
      e3.pending_buf[e3.pending++] = t3;
    };
    var ba = (e3, t3) => {
      e3.pending_buf[e3.pending++] = t3 >>> 8 & 255, e3.pending_buf[e3.pending++] = 255 & t3;
    };
    var _a = (e3, t3, n3, i3) => {
      let s3 = e3.avail_in;
      return s3 > i3 && (s3 = i3), s3 === 0 ? 0 : (e3.avail_in -= s3, t3.set(e3.input.subarray(e3.next_in, e3.next_in + s3), n3), e3.state.wrap === 1 ? e3.adler = Lr(e3.adler, t3, s3, n3) : e3.state.wrap === 2 && (e3.adler = Br(e3.adler, t3, s3, n3)), e3.next_in += s3, e3.total_in += s3, s3);
    };
    var ya = (e3, t3) => {
      let n3, i3, s3 = e3.max_chain_length, r3 = e3.strstart, a3 = e3.prev_length, o3 = e3.nice_match;
      const l3 = e3.strstart > e3.w_size - 262 ? e3.strstart - (e3.w_size - 262) : 0, h3 = e3.window, c3 = e3.w_mask, d3 = e3.prev, u3 = e3.strstart + 258;
      let f3 = h3[r3 + a3 - 1], m3 = h3[r3 + a3];
      e3.prev_length >= e3.good_match && (s3 >>= 2), o3 > e3.lookahead && (o3 = e3.lookahead);
      do {
        if (n3 = t3, h3[n3 + a3] === m3 && h3[n3 + a3 - 1] === f3 && h3[n3] === h3[r3] && h3[++n3] === h3[r3 + 1]) {
          r3 += 2, n3++;
          do {
          } while (h3[++r3] === h3[++n3] && h3[++r3] === h3[++n3] && h3[++r3] === h3[++n3] && h3[++r3] === h3[++n3] && h3[++r3] === h3[++n3] && h3[++r3] === h3[++n3] && h3[++r3] === h3[++n3] && h3[++r3] === h3[++n3] && r3 < u3);
          if (i3 = 258 - (u3 - r3), r3 = u3 - 258, i3 > a3) {
            if (e3.match_start = t3, a3 = i3, i3 >= o3)
              break;
            f3 = h3[r3 + a3 - 1], m3 = h3[r3 + a3];
          }
        }
      } while ((t3 = d3[t3 & c3]) > l3 && --s3 != 0);
      return a3 <= e3.lookahead ? a3 : e3.lookahead;
    };
    var Ia = (e3) => {
      const t3 = e3.w_size;
      let n3, i3, s3, r3, a3;
      do {
        if (r3 = e3.window_size - e3.lookahead - e3.strstart, e3.strstart >= t3 + (t3 - 262)) {
          e3.window.set(e3.window.subarray(t3, t3 + t3), 0), e3.match_start -= t3, e3.strstart -= t3, e3.block_start -= t3, i3 = e3.hash_size, n3 = i3;
          do {
            s3 = e3.head[--n3], e3.head[n3] = s3 >= t3 ? s3 - t3 : 0;
          } while (--i3);
          i3 = t3, n3 = i3;
          do {
            s3 = e3.prev[--n3], e3.prev[n3] = s3 >= t3 ? s3 - t3 : 0;
          } while (--i3);
          r3 += t3;
        }
        if (e3.strm.avail_in === 0)
          break;
        if (i3 = _a(e3.strm, e3.window, e3.strstart + e3.lookahead, r3), e3.lookahead += i3, e3.lookahead + e3.insert >= 3)
          for (a3 = e3.strstart - e3.insert, e3.ins_h = e3.window[a3], e3.ins_h = ga(e3, e3.ins_h, e3.window[a3 + 1]); e3.insert && (e3.ins_h = ga(e3, e3.ins_h, e3.window[a3 + 3 - 1]), e3.prev[a3 & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = a3, a3++, e3.insert--, !(e3.lookahead + e3.insert < 3)); )
            ;
      } while (e3.lookahead < 262 && e3.strm.avail_in !== 0);
    };
    var xa = (e3, t3) => {
      let n3, i3;
      for (; ; ) {
        if (e3.lookahead < 262) {
          if (Ia(e3), e3.lookahead < 262 && t3 === Jr)
            return 1;
          if (e3.lookahead === 0)
            break;
        }
        if (n3 = 0, e3.lookahead >= 3 && (e3.ins_h = ga(e3, e3.ins_h, e3.window[e3.strstart + 3 - 1]), n3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), n3 !== 0 && e3.strstart - n3 <= e3.w_size - 262 && (e3.match_length = ya(e3, n3)), e3.match_length >= 3)
          if (i3 = jr(e3, e3.strstart - e3.match_start, e3.match_length - 3), e3.lookahead -= e3.match_length, e3.match_length <= e3.max_lazy_match && e3.lookahead >= 3) {
            e3.match_length--;
            do {
              e3.strstart++, e3.ins_h = ga(e3, e3.ins_h, e3.window[e3.strstart + 3 - 1]), n3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart;
            } while (--e3.match_length != 0);
            e3.strstart++;
          } else
            e3.strstart += e3.match_length, e3.match_length = 0, e3.ins_h = e3.window[e3.strstart], e3.ins_h = ga(e3, e3.ins_h, e3.window[e3.strstart + 1]);
        else
          i3 = jr(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++;
        if (i3 && (va(e3, false), e3.strm.avail_out === 0))
          return 1;
      }
      return e3.insert = e3.strstart < 2 ? e3.strstart : 2, t3 === Yr ? (va(e3, true), e3.strm.avail_out === 0 ? 3 : 4) : e3.last_lit && (va(e3, false), e3.strm.avail_out === 0) ? 1 : 2;
    };
    var Pa = (e3, t3) => {
      let n3, i3, s3;
      for (; ; ) {
        if (e3.lookahead < 262) {
          if (Ia(e3), e3.lookahead < 262 && t3 === Jr)
            return 1;
          if (e3.lookahead === 0)
            break;
        }
        if (n3 = 0, e3.lookahead >= 3 && (e3.ins_h = ga(e3, e3.ins_h, e3.window[e3.strstart + 3 - 1]), n3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart), e3.prev_length = e3.match_length, e3.prev_match = e3.match_start, e3.match_length = 2, n3 !== 0 && e3.prev_length < e3.max_lazy_match && e3.strstart - n3 <= e3.w_size - 262 && (e3.match_length = ya(e3, n3), e3.match_length <= 5 && (e3.strategy === ra || e3.match_length === 3 && e3.strstart - e3.match_start > 4096) && (e3.match_length = 2)), e3.prev_length >= 3 && e3.match_length <= e3.prev_length) {
          s3 = e3.strstart + e3.lookahead - 3, i3 = jr(e3, e3.strstart - 1 - e3.prev_match, e3.prev_length - 3), e3.lookahead -= e3.prev_length - 1, e3.prev_length -= 2;
          do {
            ++e3.strstart <= s3 && (e3.ins_h = ga(e3, e3.ins_h, e3.window[e3.strstart + 3 - 1]), n3 = e3.prev[e3.strstart & e3.w_mask] = e3.head[e3.ins_h], e3.head[e3.ins_h] = e3.strstart);
          } while (--e3.prev_length != 0);
          if (e3.match_available = 0, e3.match_length = 2, e3.strstart++, i3 && (va(e3, false), e3.strm.avail_out === 0))
            return 1;
        } else if (e3.match_available) {
          if (i3 = jr(e3, 0, e3.window[e3.strstart - 1]), i3 && va(e3, false), e3.strstart++, e3.lookahead--, e3.strm.avail_out === 0)
            return 1;
        } else
          e3.match_available = 1, e3.strstart++, e3.lookahead--;
      }
      return e3.match_available && (i3 = jr(e3, 0, e3.window[e3.strstart - 1]), e3.match_available = 0), e3.insert = e3.strstart < 2 ? e3.strstart : 2, t3 === Yr ? (va(e3, true), e3.strm.avail_out === 0 ? 3 : 4) : e3.last_lit && (va(e3, false), e3.strm.avail_out === 0) ? 1 : 2;
    };
    function Ca(e3, t3, n3, i3, s3) {
      this.good_length = e3, this.max_lazy = t3, this.nice_length = n3, this.max_chain = i3, this.func = s3;
    }
    var ka = [new Ca(0, 0, 0, 0, (e3, t3) => {
      let n3 = 65535;
      for (n3 > e3.pending_buf_size - 5 && (n3 = e3.pending_buf_size - 5); ; ) {
        if (e3.lookahead <= 1) {
          if (Ia(e3), e3.lookahead === 0 && t3 === Jr)
            return 1;
          if (e3.lookahead === 0)
            break;
        }
        e3.strstart += e3.lookahead, e3.lookahead = 0;
        const i3 = e3.block_start + n3;
        if ((e3.strstart === 0 || e3.strstart >= i3) && (e3.lookahead = e3.strstart - i3, e3.strstart = i3, va(e3, false), e3.strm.avail_out === 0))
          return 1;
        if (e3.strstart - e3.block_start >= e3.w_size - 262 && (va(e3, false), e3.strm.avail_out === 0))
          return 1;
      }
      return e3.insert = 0, t3 === Yr ? (va(e3, true), e3.strm.avail_out === 0 ? 3 : 4) : (e3.strstart > e3.block_start && (va(e3, false), e3.strm.avail_out), 1);
    }), new Ca(4, 4, 8, 4, xa), new Ca(4, 5, 16, 8, xa), new Ca(4, 6, 32, 32, xa), new Ca(4, 4, 16, 16, Pa), new Ca(8, 16, 32, 32, Pa), new Ca(8, 16, 128, 128, Pa), new Ca(8, 32, 128, 256, Pa), new Ca(32, 128, 258, 1024, Pa), new Ca(32, 258, 258, 4096, Pa)];
    function Ta() {
      this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = da, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(1146), this.dyn_dtree = new Uint16Array(122), this.bl_tree = new Uint16Array(78), ma(this.dyn_ltree), ma(this.dyn_dtree), ma(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(16), this.heap = new Uint16Array(573), ma(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(573), ma(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
    }
    var Aa = (e3) => {
      if (!e3 || !e3.state)
        return ua(e3, ta);
      e3.total_in = e3.total_out = 0, e3.data_type = ca;
      const t3 = e3.state;
      return t3.pending = 0, t3.pending_out = 0, t3.wrap < 0 && (t3.wrap = -t3.wrap), t3.status = t3.wrap ? 42 : 113, e3.adler = t3.wrap === 2 ? 0 : 1, t3.last_flush = Jr, Fr(t3), Qr;
    };
    var $a = (e3) => {
      const t3 = Aa(e3);
      var n3;
      return t3 === Qr && ((n3 = e3.state).window_size = 2 * n3.w_size, ma(n3.head), n3.max_lazy_match = ka[n3.level].max_lazy, n3.good_match = ka[n3.level].good_length, n3.nice_match = ka[n3.level].nice_length, n3.max_chain_length = ka[n3.level].max_chain, n3.strstart = 0, n3.block_start = 0, n3.lookahead = 0, n3.insert = 0, n3.match_length = n3.prev_length = 2, n3.match_available = 0, n3.ins_h = 0), t3;
    };
    var Ea = (e3, t3, n3, i3, s3, r3) => {
      if (!e3)
        return ta;
      let a3 = 1;
      if (t3 === sa && (t3 = 6), i3 < 0 ? (a3 = 0, i3 = -i3) : i3 > 15 && (a3 = 2, i3 -= 16), s3 < 1 || s3 > 9 || n3 !== da || i3 < 8 || i3 > 15 || t3 < 0 || t3 > 9 || r3 < 0 || r3 > la)
        return ua(e3, ta);
      i3 === 8 && (i3 = 9);
      const o3 = new Ta();
      return e3.state = o3, o3.strm = e3, o3.wrap = a3, o3.gzhead = null, o3.w_bits = i3, o3.w_size = 1 << o3.w_bits, o3.w_mask = o3.w_size - 1, o3.hash_bits = s3 + 7, o3.hash_size = 1 << o3.hash_bits, o3.hash_mask = o3.hash_size - 1, o3.hash_shift = ~~((o3.hash_bits + 3 - 1) / 3), o3.window = new Uint8Array(2 * o3.w_size), o3.head = new Uint16Array(o3.hash_size), o3.prev = new Uint16Array(o3.w_size), o3.lit_bufsize = 1 << s3 + 6, o3.pending_buf_size = 4 * o3.lit_bufsize, o3.pending_buf = new Uint8Array(o3.pending_buf_size), o3.d_buf = 1 * o3.lit_bufsize, o3.l_buf = 3 * o3.lit_bufsize, o3.level = t3, o3.strategy = r3, o3.method = n3, $a(e3);
    };
    var Sa = {deflateInit: (e3, t3) => Ea(e3, t3, da, 15, 8, ha), deflateInit2: Ea, deflateReset: $a, deflateResetKeep: Aa, deflateSetHeader: (e3, t3) => e3 && e3.state ? e3.state.wrap !== 2 ? ta : (e3.state.gzhead = t3, Qr) : ta, deflate: (e3, t3) => {
      let n3, i3;
      if (!e3 || !e3.state || t3 > qr || t3 < 0)
        return e3 ? ua(e3, ta) : ta;
      const s3 = e3.state;
      if (!e3.output || !e3.input && e3.avail_in !== 0 || s3.status === 666 && t3 !== Yr)
        return ua(e3, e3.avail_out === 0 ? ia : ta);
      s3.strm = e3;
      const r3 = s3.last_flush;
      if (s3.last_flush = t3, s3.status === 42)
        if (s3.wrap === 2)
          e3.adler = 0, wa(s3, 31), wa(s3, 139), wa(s3, 8), s3.gzhead ? (wa(s3, (s3.gzhead.text ? 1 : 0) + (s3.gzhead.hcrc ? 2 : 0) + (s3.gzhead.extra ? 4 : 0) + (s3.gzhead.name ? 8 : 0) + (s3.gzhead.comment ? 16 : 0)), wa(s3, 255 & s3.gzhead.time), wa(s3, s3.gzhead.time >> 8 & 255), wa(s3, s3.gzhead.time >> 16 & 255), wa(s3, s3.gzhead.time >> 24 & 255), wa(s3, s3.level === 9 ? 2 : s3.strategy >= aa || s3.level < 2 ? 4 : 0), wa(s3, 255 & s3.gzhead.os), s3.gzhead.extra && s3.gzhead.extra.length && (wa(s3, 255 & s3.gzhead.extra.length), wa(s3, s3.gzhead.extra.length >> 8 & 255)), s3.gzhead.hcrc && (e3.adler = Br(e3.adler, s3.pending_buf, s3.pending, 0)), s3.gzindex = 0, s3.status = 69) : (wa(s3, 0), wa(s3, 0), wa(s3, 0), wa(s3, 0), wa(s3, 0), wa(s3, s3.level === 9 ? 2 : s3.strategy >= aa || s3.level < 2 ? 4 : 0), wa(s3, 3), s3.status = 113);
        else {
          let t4 = da + (s3.w_bits - 8 << 4) << 8, n4 = -1;
          n4 = s3.strategy >= aa || s3.level < 2 ? 0 : s3.level < 6 ? 1 : s3.level === 6 ? 2 : 3, t4 |= n4 << 6, s3.strstart !== 0 && (t4 |= 32), t4 += 31 - t4 % 31, s3.status = 113, ba(s3, t4), s3.strstart !== 0 && (ba(s3, e3.adler >>> 16), ba(s3, 65535 & e3.adler)), e3.adler = 1;
        }
      if (s3.status === 69)
        if (s3.gzhead.extra) {
          for (n3 = s3.pending; s3.gzindex < (65535 & s3.gzhead.extra.length) && (s3.pending !== s3.pending_buf_size || (s3.gzhead.hcrc && s3.pending > n3 && (e3.adler = Br(e3.adler, s3.pending_buf, s3.pending - n3, n3)), pa(e3), n3 = s3.pending, s3.pending !== s3.pending_buf_size)); )
            wa(s3, 255 & s3.gzhead.extra[s3.gzindex]), s3.gzindex++;
          s3.gzhead.hcrc && s3.pending > n3 && (e3.adler = Br(e3.adler, s3.pending_buf, s3.pending - n3, n3)), s3.gzindex === s3.gzhead.extra.length && (s3.gzindex = 0, s3.status = 73);
        } else
          s3.status = 73;
      if (s3.status === 73)
        if (s3.gzhead.name) {
          n3 = s3.pending;
          do {
            if (s3.pending === s3.pending_buf_size && (s3.gzhead.hcrc && s3.pending > n3 && (e3.adler = Br(e3.adler, s3.pending_buf, s3.pending - n3, n3)), pa(e3), n3 = s3.pending, s3.pending === s3.pending_buf_size)) {
              i3 = 1;
              break;
            }
            i3 = s3.gzindex < s3.gzhead.name.length ? 255 & s3.gzhead.name.charCodeAt(s3.gzindex++) : 0, wa(s3, i3);
          } while (i3 !== 0);
          s3.gzhead.hcrc && s3.pending > n3 && (e3.adler = Br(e3.adler, s3.pending_buf, s3.pending - n3, n3)), i3 === 0 && (s3.gzindex = 0, s3.status = 91);
        } else
          s3.status = 91;
      if (s3.status === 91)
        if (s3.gzhead.comment) {
          n3 = s3.pending;
          do {
            if (s3.pending === s3.pending_buf_size && (s3.gzhead.hcrc && s3.pending > n3 && (e3.adler = Br(e3.adler, s3.pending_buf, s3.pending - n3, n3)), pa(e3), n3 = s3.pending, s3.pending === s3.pending_buf_size)) {
              i3 = 1;
              break;
            }
            i3 = s3.gzindex < s3.gzhead.comment.length ? 255 & s3.gzhead.comment.charCodeAt(s3.gzindex++) : 0, wa(s3, i3);
          } while (i3 !== 0);
          s3.gzhead.hcrc && s3.pending > n3 && (e3.adler = Br(e3.adler, s3.pending_buf, s3.pending - n3, n3)), i3 === 0 && (s3.status = 103);
        } else
          s3.status = 103;
      if (s3.status === 103 && (s3.gzhead.hcrc ? (s3.pending + 2 > s3.pending_buf_size && pa(e3), s3.pending + 2 <= s3.pending_buf_size && (wa(s3, 255 & e3.adler), wa(s3, e3.adler >> 8 & 255), e3.adler = 0, s3.status = 113)) : s3.status = 113), s3.pending !== 0) {
        if (pa(e3), e3.avail_out === 0)
          return s3.last_flush = -1, Qr;
      } else if (e3.avail_in === 0 && fa(t3) <= fa(r3) && t3 !== Yr)
        return ua(e3, ia);
      if (s3.status === 666 && e3.avail_in !== 0)
        return ua(e3, ia);
      if (e3.avail_in !== 0 || s3.lookahead !== 0 || t3 !== Jr && s3.status !== 666) {
        let n4 = s3.strategy === aa ? ((e4, t4) => {
          let n5;
          for (; ; ) {
            if (e4.lookahead === 0 && (Ia(e4), e4.lookahead === 0)) {
              if (t4 === Jr)
                return 1;
              break;
            }
            if (e4.match_length = 0, n5 = jr(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++, n5 && (va(e4, false), e4.strm.avail_out === 0))
              return 1;
          }
          return e4.insert = 0, t4 === Yr ? (va(e4, true), e4.strm.avail_out === 0 ? 3 : 4) : e4.last_lit && (va(e4, false), e4.strm.avail_out === 0) ? 1 : 2;
        })(s3, t3) : s3.strategy === oa ? ((e4, t4) => {
          let n5, i4, s4, r4;
          const a3 = e4.window;
          for (; ; ) {
            if (e4.lookahead <= 258) {
              if (Ia(e4), e4.lookahead <= 258 && t4 === Jr)
                return 1;
              if (e4.lookahead === 0)
                break;
            }
            if (e4.match_length = 0, e4.lookahead >= 3 && e4.strstart > 0 && (s4 = e4.strstart - 1, i4 = a3[s4], i4 === a3[++s4] && i4 === a3[++s4] && i4 === a3[++s4])) {
              r4 = e4.strstart + 258;
              do {
              } while (i4 === a3[++s4] && i4 === a3[++s4] && i4 === a3[++s4] && i4 === a3[++s4] && i4 === a3[++s4] && i4 === a3[++s4] && i4 === a3[++s4] && i4 === a3[++s4] && s4 < r4);
              e4.match_length = 258 - (r4 - s4), e4.match_length > e4.lookahead && (e4.match_length = e4.lookahead);
            }
            if (e4.match_length >= 3 ? (n5 = jr(e4, 1, e4.match_length - 3), e4.lookahead -= e4.match_length, e4.strstart += e4.match_length, e4.match_length = 0) : (n5 = jr(e4, 0, e4.window[e4.strstart]), e4.lookahead--, e4.strstart++), n5 && (va(e4, false), e4.strm.avail_out === 0))
              return 1;
          }
          return e4.insert = 0, t4 === Yr ? (va(e4, true), e4.strm.avail_out === 0 ? 3 : 4) : e4.last_lit && (va(e4, false), e4.strm.avail_out === 0) ? 1 : 2;
        })(s3, t3) : ka[s3.level].func(s3, t3);
        if (n4 !== 3 && n4 !== 4 || (s3.status = 666), n4 === 1 || n4 === 3)
          return e3.avail_out === 0 && (s3.last_flush = -1), Qr;
        if (n4 === 2 && (t3 === Kr ? Zr(s3) : t3 !== qr && (Gr(s3, 0, 0, false), t3 === Wr && (ma(s3.head), s3.lookahead === 0 && (s3.strstart = 0, s3.block_start = 0, s3.insert = 0))), pa(e3), e3.avail_out === 0))
          return s3.last_flush = -1, Qr;
      }
      return t3 !== Yr ? Qr : s3.wrap <= 0 ? ea : (s3.wrap === 2 ? (wa(s3, 255 & e3.adler), wa(s3, e3.adler >> 8 & 255), wa(s3, e3.adler >> 16 & 255), wa(s3, e3.adler >> 24 & 255), wa(s3, 255 & e3.total_in), wa(s3, e3.total_in >> 8 & 255), wa(s3, e3.total_in >> 16 & 255), wa(s3, e3.total_in >> 24 & 255)) : (ba(s3, e3.adler >>> 16), ba(s3, 65535 & e3.adler)), pa(e3), s3.wrap > 0 && (s3.wrap = -s3.wrap), s3.pending !== 0 ? Qr : ea);
    }, deflateEnd: (e3) => {
      if (!e3 || !e3.state)
        return ta;
      const t3 = e3.state.status;
      return t3 !== 42 && t3 !== 69 && t3 !== 73 && t3 !== 91 && t3 !== 103 && t3 !== 113 && t3 !== 666 ? ua(e3, ta) : (e3.state = null, t3 === 113 ? ua(e3, na) : Qr);
    }, deflateSetDictionary: (e3, t3) => {
      let n3 = t3.length;
      if (!e3 || !e3.state)
        return ta;
      const i3 = e3.state, s3 = i3.wrap;
      if (s3 === 2 || s3 === 1 && i3.status !== 42 || i3.lookahead)
        return ta;
      if (s3 === 1 && (e3.adler = Lr(e3.adler, t3, n3, 0)), i3.wrap = 0, n3 >= i3.w_size) {
        s3 === 0 && (ma(i3.head), i3.strstart = 0, i3.block_start = 0, i3.insert = 0);
        let e4 = new Uint8Array(i3.w_size);
        e4.set(t3.subarray(n3 - i3.w_size, n3), 0), t3 = e4, n3 = i3.w_size;
      }
      const r3 = e3.avail_in, a3 = e3.next_in, o3 = e3.input;
      for (e3.avail_in = n3, e3.next_in = 0, e3.input = t3, Ia(i3); i3.lookahead >= 3; ) {
        let e4 = i3.strstart, t4 = i3.lookahead - 2;
        do {
          i3.ins_h = ga(i3, i3.ins_h, i3.window[e4 + 3 - 1]), i3.prev[e4 & i3.w_mask] = i3.head[i3.ins_h], i3.head[i3.ins_h] = e4, e4++;
        } while (--t4);
        i3.strstart = e4, i3.lookahead = 2, Ia(i3);
      }
      return i3.strstart += i3.lookahead, i3.block_start = i3.strstart, i3.insert = i3.lookahead, i3.lookahead = 0, i3.match_length = i3.prev_length = 2, i3.match_available = 0, e3.next_in = a3, e3.input = o3, e3.avail_in = r3, i3.wrap = s3, Qr;
    }, deflateInfo: "pako deflate (from Nodeca project)"};
    var Ma = (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3);
    var Ra = function(e3) {
      const t3 = Array.prototype.slice.call(arguments, 1);
      for (; t3.length; ) {
        const n3 = t3.shift();
        if (n3) {
          if (typeof n3 != "object")
            throw new TypeError(n3 + "must be non-object");
          for (const t4 in n3)
            Ma(n3, t4) && (e3[t4] = n3[t4]);
        }
      }
      return e3;
    };
    var Da = (e3) => {
      let t3 = 0;
      for (let n4 = 0, i3 = e3.length; n4 < i3; n4++)
        t3 += e3[n4].length;
      const n3 = new Uint8Array(t3);
      for (let t4 = 0, i3 = 0, s3 = e3.length; t4 < s3; t4++) {
        let s4 = e3[t4];
        n3.set(s4, i3), i3 += s4.length;
      }
      return n3;
    };
    var Oa = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (e3) {
      Oa = false;
    }
    var Na = new Uint8Array(256);
    for (let e3 = 0; e3 < 256; e3++)
      Na[e3] = e3 >= 252 ? 6 : e3 >= 248 ? 5 : e3 >= 240 ? 4 : e3 >= 224 ? 3 : e3 >= 192 ? 2 : 1;
    Na[254] = Na[254] = 1;
    var za = (e3) => {
      if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
        return new TextEncoder().encode(e3);
      let t3, n3, i3, s3, r3, a3 = e3.length, o3 = 0;
      for (s3 = 0; s3 < a3; s3++)
        n3 = e3.charCodeAt(s3), (64512 & n3) == 55296 && s3 + 1 < a3 && (i3 = e3.charCodeAt(s3 + 1), (64512 & i3) == 56320 && (n3 = 65536 + (n3 - 55296 << 10) + (i3 - 56320), s3++)), o3 += n3 < 128 ? 1 : n3 < 2048 ? 2 : n3 < 65536 ? 3 : 4;
      for (t3 = new Uint8Array(o3), r3 = 0, s3 = 0; r3 < o3; s3++)
        n3 = e3.charCodeAt(s3), (64512 & n3) == 55296 && s3 + 1 < a3 && (i3 = e3.charCodeAt(s3 + 1), (64512 & i3) == 56320 && (n3 = 65536 + (n3 - 55296 << 10) + (i3 - 56320), s3++)), n3 < 128 ? t3[r3++] = n3 : n3 < 2048 ? (t3[r3++] = 192 | n3 >>> 6, t3[r3++] = 128 | 63 & n3) : n3 < 65536 ? (t3[r3++] = 224 | n3 >>> 12, t3[r3++] = 128 | n3 >>> 6 & 63, t3[r3++] = 128 | 63 & n3) : (t3[r3++] = 240 | n3 >>> 18, t3[r3++] = 128 | n3 >>> 12 & 63, t3[r3++] = 128 | n3 >>> 6 & 63, t3[r3++] = 128 | 63 & n3);
      return t3;
    };
    var La = (e3, t3) => {
      const n3 = t3 || e3.length;
      if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
        return new TextDecoder().decode(e3.subarray(0, t3));
      let i3, s3;
      const r3 = new Array(2 * n3);
      for (s3 = 0, i3 = 0; i3 < n3; ) {
        let t4 = e3[i3++];
        if (t4 < 128) {
          r3[s3++] = t4;
          continue;
        }
        let a3 = Na[t4];
        if (a3 > 4)
          r3[s3++] = 65533, i3 += a3 - 1;
        else {
          for (t4 &= a3 === 2 ? 31 : a3 === 3 ? 15 : 7; a3 > 1 && i3 < n3; )
            t4 = t4 << 6 | 63 & e3[i3++], a3--;
          a3 > 1 ? r3[s3++] = 65533 : t4 < 65536 ? r3[s3++] = t4 : (t4 -= 65536, r3[s3++] = 55296 | t4 >> 10 & 1023, r3[s3++] = 56320 | 1023 & t4);
        }
      }
      return ((e4, t4) => {
        if (t4 < 65534 && e4.subarray && Oa)
          return String.fromCharCode.apply(null, e4.length === t4 ? e4 : e4.subarray(0, t4));
        let n4 = "";
        for (let i4 = 0; i4 < t4; i4++)
          n4 += String.fromCharCode(e4[i4]);
        return n4;
      })(r3, s3);
    };
    var Va = (e3, t3) => {
      (t3 = t3 || e3.length) > e3.length && (t3 = e3.length);
      let n3 = t3 - 1;
      for (; n3 >= 0 && (192 & e3[n3]) == 128; )
        n3--;
      return n3 < 0 || n3 === 0 ? t3 : n3 + Na[e3[n3]] > t3 ? n3 : t3;
    };
    var Ba = function() {
      this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
    };
    var Ua = Object.prototype.toString;
    var {Z_NO_FLUSH: Xa, Z_SYNC_FLUSH: Fa, Z_FULL_FLUSH: Ga, Z_FINISH: Ha, Z_OK: ja, Z_STREAM_END: Za, Z_DEFAULT_COMPRESSION: Ja, Z_DEFAULT_STRATEGY: Ka, Z_DEFLATED: Wa} = Xr;
    function Ya(e3) {
      this.options = Ra({level: Ja, method: Wa, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: Ka}, e3 || {});
      let t3 = this.options;
      t3.raw && t3.windowBits > 0 ? t3.windowBits = -t3.windowBits : t3.gzip && t3.windowBits > 0 && t3.windowBits < 16 && (t3.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new Ba(), this.strm.avail_out = 0;
      let n3 = Sa.deflateInit2(this.strm, t3.level, t3.method, t3.windowBits, t3.memLevel, t3.strategy);
      if (n3 !== ja)
        throw new Error(Ur[n3]);
      if (t3.header && Sa.deflateSetHeader(this.strm, t3.header), t3.dictionary) {
        let e4;
        if (e4 = typeof t3.dictionary == "string" ? za(t3.dictionary) : Ua.call(t3.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(t3.dictionary) : t3.dictionary, n3 = Sa.deflateSetDictionary(this.strm, e4), n3 !== ja)
          throw new Error(Ur[n3]);
        this._dict_set = true;
      }
    }
    function qa(e3, t3) {
      const n3 = new Ya(t3);
      if (n3.push(e3, true), n3.err)
        throw n3.msg || Ur[n3.err];
      return n3.result;
    }
    Ya.prototype.push = function(e3, t3) {
      const n3 = this.strm, i3 = this.options.chunkSize;
      let s3, r3;
      if (this.ended)
        return false;
      for (r3 = t3 === ~~t3 ? t3 : t3 === true ? Ha : Xa, typeof e3 == "string" ? n3.input = za(e3) : Ua.call(e3) === "[object ArrayBuffer]" ? n3.input = new Uint8Array(e3) : n3.input = e3, n3.next_in = 0, n3.avail_in = n3.input.length; ; )
        if (n3.avail_out === 0 && (n3.output = new Uint8Array(i3), n3.next_out = 0, n3.avail_out = i3), (r3 === Fa || r3 === Ga) && n3.avail_out <= 6)
          this.onData(n3.output.subarray(0, n3.next_out)), n3.avail_out = 0;
        else {
          if (s3 = Sa.deflate(n3, r3), s3 === Za)
            return n3.next_out > 0 && this.onData(n3.output.subarray(0, n3.next_out)), s3 = Sa.deflateEnd(this.strm), this.onEnd(s3), this.ended = true, s3 === ja;
          if (n3.avail_out !== 0) {
            if (r3 > 0 && n3.next_out > 0)
              this.onData(n3.output.subarray(0, n3.next_out)), n3.avail_out = 0;
            else if (n3.avail_in === 0)
              break;
          } else
            this.onData(n3.output);
        }
      return true;
    }, Ya.prototype.onData = function(e3) {
      this.chunks.push(e3);
    }, Ya.prototype.onEnd = function(e3) {
      e3 === ja && (this.result = Da(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
    };
    var Qa = {Deflate: Ya, deflate: qa, deflateRaw: function(e3, t3) {
      return (t3 = t3 || {}).raw = true, qa(e3, t3);
    }, gzip: function(e3, t3) {
      return (t3 = t3 || {}).gzip = true, qa(e3, t3);
    }, constants: Xr};
    var eo = function(e3, t3) {
      let n3, i3, s3, r3, a3, o3, l3, h3, c3, d3, u3, f3, m3, g3, p3, v3, w3, b3, _3, y3, I3, x3, P3, C3;
      const k3 = e3.state;
      n3 = e3.next_in, P3 = e3.input, i3 = n3 + (e3.avail_in - 5), s3 = e3.next_out, C3 = e3.output, r3 = s3 - (t3 - e3.avail_out), a3 = s3 + (e3.avail_out - 257), o3 = k3.dmax, l3 = k3.wsize, h3 = k3.whave, c3 = k3.wnext, d3 = k3.window, u3 = k3.hold, f3 = k3.bits, m3 = k3.lencode, g3 = k3.distcode, p3 = (1 << k3.lenbits) - 1, v3 = (1 << k3.distbits) - 1;
      e:
        do {
          f3 < 15 && (u3 += P3[n3++] << f3, f3 += 8, u3 += P3[n3++] << f3, f3 += 8), w3 = m3[u3 & p3];
          t:
            for (; ; ) {
              if (b3 = w3 >>> 24, u3 >>>= b3, f3 -= b3, b3 = w3 >>> 16 & 255, b3 === 0)
                C3[s3++] = 65535 & w3;
              else {
                if (!(16 & b3)) {
                  if ((64 & b3) == 0) {
                    w3 = m3[(65535 & w3) + (u3 & (1 << b3) - 1)];
                    continue t;
                  }
                  if (32 & b3) {
                    k3.mode = 12;
                    break e;
                  }
                  e3.msg = "invalid literal/length code", k3.mode = 30;
                  break e;
                }
                _3 = 65535 & w3, b3 &= 15, b3 && (f3 < b3 && (u3 += P3[n3++] << f3, f3 += 8), _3 += u3 & (1 << b3) - 1, u3 >>>= b3, f3 -= b3), f3 < 15 && (u3 += P3[n3++] << f3, f3 += 8, u3 += P3[n3++] << f3, f3 += 8), w3 = g3[u3 & v3];
                n:
                  for (; ; ) {
                    if (b3 = w3 >>> 24, u3 >>>= b3, f3 -= b3, b3 = w3 >>> 16 & 255, !(16 & b3)) {
                      if ((64 & b3) == 0) {
                        w3 = g3[(65535 & w3) + (u3 & (1 << b3) - 1)];
                        continue n;
                      }
                      e3.msg = "invalid distance code", k3.mode = 30;
                      break e;
                    }
                    if (y3 = 65535 & w3, b3 &= 15, f3 < b3 && (u3 += P3[n3++] << f3, f3 += 8, f3 < b3 && (u3 += P3[n3++] << f3, f3 += 8)), y3 += u3 & (1 << b3) - 1, y3 > o3) {
                      e3.msg = "invalid distance too far back", k3.mode = 30;
                      break e;
                    }
                    if (u3 >>>= b3, f3 -= b3, b3 = s3 - r3, y3 > b3) {
                      if (b3 = y3 - b3, b3 > h3 && k3.sane) {
                        e3.msg = "invalid distance too far back", k3.mode = 30;
                        break e;
                      }
                      if (I3 = 0, x3 = d3, c3 === 0) {
                        if (I3 += l3 - b3, b3 < _3) {
                          _3 -= b3;
                          do {
                            C3[s3++] = d3[I3++];
                          } while (--b3);
                          I3 = s3 - y3, x3 = C3;
                        }
                      } else if (c3 < b3) {
                        if (I3 += l3 + c3 - b3, b3 -= c3, b3 < _3) {
                          _3 -= b3;
                          do {
                            C3[s3++] = d3[I3++];
                          } while (--b3);
                          if (I3 = 0, c3 < _3) {
                            b3 = c3, _3 -= b3;
                            do {
                              C3[s3++] = d3[I3++];
                            } while (--b3);
                            I3 = s3 - y3, x3 = C3;
                          }
                        }
                      } else if (I3 += c3 - b3, b3 < _3) {
                        _3 -= b3;
                        do {
                          C3[s3++] = d3[I3++];
                        } while (--b3);
                        I3 = s3 - y3, x3 = C3;
                      }
                      for (; _3 > 2; )
                        C3[s3++] = x3[I3++], C3[s3++] = x3[I3++], C3[s3++] = x3[I3++], _3 -= 3;
                      _3 && (C3[s3++] = x3[I3++], _3 > 1 && (C3[s3++] = x3[I3++]));
                    } else {
                      I3 = s3 - y3;
                      do {
                        C3[s3++] = C3[I3++], C3[s3++] = C3[I3++], C3[s3++] = C3[I3++], _3 -= 3;
                      } while (_3 > 2);
                      _3 && (C3[s3++] = C3[I3++], _3 > 1 && (C3[s3++] = C3[I3++]));
                    }
                    break;
                  }
              }
              break;
            }
        } while (n3 < i3 && s3 < a3);
      _3 = f3 >> 3, n3 -= _3, f3 -= _3 << 3, u3 &= (1 << f3) - 1, e3.next_in = n3, e3.next_out = s3, e3.avail_in = n3 < i3 ? i3 - n3 + 5 : 5 - (n3 - i3), e3.avail_out = s3 < a3 ? a3 - s3 + 257 : 257 - (s3 - a3), k3.hold = u3, k3.bits = f3;
    };
    var to = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]);
    var no = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]);
    var io = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]);
    var so = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]);
    var ro = (e3, t3, n3, i3, s3, r3, a3, o3) => {
      const l3 = o3.bits;
      let h3, c3, d3, u3, f3, m3, g3 = 0, p3 = 0, v3 = 0, w3 = 0, b3 = 0, _3 = 0, y3 = 0, I3 = 0, x3 = 0, P3 = 0, C3 = null, k3 = 0;
      const T3 = new Uint16Array(16), A3 = new Uint16Array(16);
      let $3, E3, S3, M3 = null, R3 = 0;
      for (g3 = 0; g3 <= 15; g3++)
        T3[g3] = 0;
      for (p3 = 0; p3 < i3; p3++)
        T3[t3[n3 + p3]]++;
      for (b3 = l3, w3 = 15; w3 >= 1 && T3[w3] === 0; w3--)
        ;
      if (b3 > w3 && (b3 = w3), w3 === 0)
        return s3[r3++] = 20971520, s3[r3++] = 20971520, o3.bits = 1, 0;
      for (v3 = 1; v3 < w3 && T3[v3] === 0; v3++)
        ;
      for (b3 < v3 && (b3 = v3), I3 = 1, g3 = 1; g3 <= 15; g3++)
        if (I3 <<= 1, I3 -= T3[g3], I3 < 0)
          return -1;
      if (I3 > 0 && (e3 === 0 || w3 !== 1))
        return -1;
      for (A3[1] = 0, g3 = 1; g3 < 15; g3++)
        A3[g3 + 1] = A3[g3] + T3[g3];
      for (p3 = 0; p3 < i3; p3++)
        t3[n3 + p3] !== 0 && (a3[A3[t3[n3 + p3]]++] = p3);
      if (e3 === 0 ? (C3 = M3 = a3, m3 = 19) : e3 === 1 ? (C3 = to, k3 -= 257, M3 = no, R3 -= 257, m3 = 256) : (C3 = io, M3 = so, m3 = -1), P3 = 0, p3 = 0, g3 = v3, f3 = r3, _3 = b3, y3 = 0, d3 = -1, x3 = 1 << b3, u3 = x3 - 1, e3 === 1 && x3 > 852 || e3 === 2 && x3 > 592)
        return 1;
      for (; ; ) {
        $3 = g3 - y3, a3[p3] < m3 ? (E3 = 0, S3 = a3[p3]) : a3[p3] > m3 ? (E3 = M3[R3 + a3[p3]], S3 = C3[k3 + a3[p3]]) : (E3 = 96, S3 = 0), h3 = 1 << g3 - y3, c3 = 1 << _3, v3 = c3;
        do {
          c3 -= h3, s3[f3 + (P3 >> y3) + c3] = $3 << 24 | E3 << 16 | S3 | 0;
        } while (c3 !== 0);
        for (h3 = 1 << g3 - 1; P3 & h3; )
          h3 >>= 1;
        if (h3 !== 0 ? (P3 &= h3 - 1, P3 += h3) : P3 = 0, p3++, --T3[g3] == 0) {
          if (g3 === w3)
            break;
          g3 = t3[n3 + a3[p3]];
        }
        if (g3 > b3 && (P3 & u3) !== d3) {
          for (y3 === 0 && (y3 = b3), f3 += v3, _3 = g3 - y3, I3 = 1 << _3; _3 + y3 < w3 && (I3 -= T3[_3 + y3], !(I3 <= 0)); )
            _3++, I3 <<= 1;
          if (x3 += 1 << _3, e3 === 1 && x3 > 852 || e3 === 2 && x3 > 592)
            return 1;
          d3 = P3 & u3, s3[d3] = b3 << 24 | _3 << 16 | f3 - r3 | 0;
        }
      }
      return P3 !== 0 && (s3[f3 + P3] = g3 - y3 << 24 | 64 << 16 | 0), o3.bits = b3, 0;
    };
    var {Z_FINISH: ao, Z_BLOCK: oo, Z_TREES: lo, Z_OK: ho, Z_STREAM_END: co, Z_NEED_DICT: uo, Z_STREAM_ERROR: fo, Z_DATA_ERROR: mo, Z_MEM_ERROR: go, Z_BUF_ERROR: po, Z_DEFLATED: vo} = Xr;
    var wo = (e3) => (e3 >>> 24 & 255) + (e3 >>> 8 & 65280) + ((65280 & e3) << 8) + ((255 & e3) << 24);
    function bo() {
      this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
    }
    var _o = (e3) => {
      if (!e3 || !e3.state)
        return fo;
      const t3 = e3.state;
      return e3.total_in = e3.total_out = t3.total = 0, e3.msg = "", t3.wrap && (e3.adler = 1 & t3.wrap), t3.mode = 1, t3.last = 0, t3.havedict = 0, t3.dmax = 32768, t3.head = null, t3.hold = 0, t3.bits = 0, t3.lencode = t3.lendyn = new Int32Array(852), t3.distcode = t3.distdyn = new Int32Array(592), t3.sane = 1, t3.back = -1, ho;
    };
    var yo = (e3) => {
      if (!e3 || !e3.state)
        return fo;
      const t3 = e3.state;
      return t3.wsize = 0, t3.whave = 0, t3.wnext = 0, _o(e3);
    };
    var Io = (e3, t3) => {
      let n3;
      if (!e3 || !e3.state)
        return fo;
      const i3 = e3.state;
      return t3 < 0 ? (n3 = 0, t3 = -t3) : (n3 = 1 + (t3 >> 4), t3 < 48 && (t3 &= 15)), t3 && (t3 < 8 || t3 > 15) ? fo : (i3.window !== null && i3.wbits !== t3 && (i3.window = null), i3.wrap = n3, i3.wbits = t3, yo(e3));
    };
    var xo = (e3, t3) => {
      if (!e3)
        return fo;
      const n3 = new bo();
      e3.state = n3, n3.window = null;
      const i3 = Io(e3, t3);
      return i3 !== ho && (e3.state = null), i3;
    };
    var Po;
    var Co;
    var ko = true;
    var To = (e3) => {
      if (ko) {
        Po = new Int32Array(512), Co = new Int32Array(32);
        let t3 = 0;
        for (; t3 < 144; )
          e3.lens[t3++] = 8;
        for (; t3 < 256; )
          e3.lens[t3++] = 9;
        for (; t3 < 280; )
          e3.lens[t3++] = 7;
        for (; t3 < 288; )
          e3.lens[t3++] = 8;
        for (ro(1, e3.lens, 0, 288, Po, 0, e3.work, {bits: 9}), t3 = 0; t3 < 32; )
          e3.lens[t3++] = 5;
        ro(2, e3.lens, 0, 32, Co, 0, e3.work, {bits: 5}), ko = false;
      }
      e3.lencode = Po, e3.lenbits = 9, e3.distcode = Co, e3.distbits = 5;
    };
    var Ao = (e3, t3, n3, i3) => {
      let s3;
      const r3 = e3.state;
      return r3.window === null && (r3.wsize = 1 << r3.wbits, r3.wnext = 0, r3.whave = 0, r3.window = new Uint8Array(r3.wsize)), i3 >= r3.wsize ? (r3.window.set(t3.subarray(n3 - r3.wsize, n3), 0), r3.wnext = 0, r3.whave = r3.wsize) : (s3 = r3.wsize - r3.wnext, s3 > i3 && (s3 = i3), r3.window.set(t3.subarray(n3 - i3, n3 - i3 + s3), r3.wnext), (i3 -= s3) ? (r3.window.set(t3.subarray(n3 - i3, n3), 0), r3.wnext = i3, r3.whave = r3.wsize) : (r3.wnext += s3, r3.wnext === r3.wsize && (r3.wnext = 0), r3.whave < r3.wsize && (r3.whave += s3))), 0;
    };
    var $o = {inflateReset: yo, inflateReset2: Io, inflateResetKeep: _o, inflateInit: (e3) => xo(e3, 15), inflateInit2: xo, inflate: (e3, t3) => {
      let n3, i3, s3, r3, a3, o3, l3, h3, c3, d3, u3, f3, m3, g3, p3, v3, w3, b3, _3, y3, I3, x3, P3 = 0;
      const C3 = new Uint8Array(4);
      let k3, T3;
      const A3 = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      if (!e3 || !e3.state || !e3.output || !e3.input && e3.avail_in !== 0)
        return fo;
      n3 = e3.state, n3.mode === 12 && (n3.mode = 13), a3 = e3.next_out, s3 = e3.output, l3 = e3.avail_out, r3 = e3.next_in, i3 = e3.input, o3 = e3.avail_in, h3 = n3.hold, c3 = n3.bits, d3 = o3, u3 = l3, x3 = ho;
      e:
        for (; ; )
          switch (n3.mode) {
            case 1:
              if (n3.wrap === 0) {
                n3.mode = 13;
                break;
              }
              for (; c3 < 16; ) {
                if (o3 === 0)
                  break e;
                o3--, h3 += i3[r3++] << c3, c3 += 8;
              }
              if (2 & n3.wrap && h3 === 35615) {
                n3.check = 0, C3[0] = 255 & h3, C3[1] = h3 >>> 8 & 255, n3.check = Br(n3.check, C3, 2, 0), h3 = 0, c3 = 0, n3.mode = 2;
                break;
              }
              if (n3.flags = 0, n3.head && (n3.head.done = false), !(1 & n3.wrap) || (((255 & h3) << 8) + (h3 >> 8)) % 31) {
                e3.msg = "incorrect header check", n3.mode = 30;
                break;
              }
              if ((15 & h3) !== vo) {
                e3.msg = "unknown compression method", n3.mode = 30;
                break;
              }
              if (h3 >>>= 4, c3 -= 4, I3 = 8 + (15 & h3), n3.wbits === 0)
                n3.wbits = I3;
              else if (I3 > n3.wbits) {
                e3.msg = "invalid window size", n3.mode = 30;
                break;
              }
              n3.dmax = 1 << n3.wbits, e3.adler = n3.check = 1, n3.mode = 512 & h3 ? 10 : 12, h3 = 0, c3 = 0;
              break;
            case 2:
              for (; c3 < 16; ) {
                if (o3 === 0)
                  break e;
                o3--, h3 += i3[r3++] << c3, c3 += 8;
              }
              if (n3.flags = h3, (255 & n3.flags) !== vo) {
                e3.msg = "unknown compression method", n3.mode = 30;
                break;
              }
              if (57344 & n3.flags) {
                e3.msg = "unknown header flags set", n3.mode = 30;
                break;
              }
              n3.head && (n3.head.text = h3 >> 8 & 1), 512 & n3.flags && (C3[0] = 255 & h3, C3[1] = h3 >>> 8 & 255, n3.check = Br(n3.check, C3, 2, 0)), h3 = 0, c3 = 0, n3.mode = 3;
            case 3:
              for (; c3 < 32; ) {
                if (o3 === 0)
                  break e;
                o3--, h3 += i3[r3++] << c3, c3 += 8;
              }
              n3.head && (n3.head.time = h3), 512 & n3.flags && (C3[0] = 255 & h3, C3[1] = h3 >>> 8 & 255, C3[2] = h3 >>> 16 & 255, C3[3] = h3 >>> 24 & 255, n3.check = Br(n3.check, C3, 4, 0)), h3 = 0, c3 = 0, n3.mode = 4;
            case 4:
              for (; c3 < 16; ) {
                if (o3 === 0)
                  break e;
                o3--, h3 += i3[r3++] << c3, c3 += 8;
              }
              n3.head && (n3.head.xflags = 255 & h3, n3.head.os = h3 >> 8), 512 & n3.flags && (C3[0] = 255 & h3, C3[1] = h3 >>> 8 & 255, n3.check = Br(n3.check, C3, 2, 0)), h3 = 0, c3 = 0, n3.mode = 5;
            case 5:
              if (1024 & n3.flags) {
                for (; c3 < 16; ) {
                  if (o3 === 0)
                    break e;
                  o3--, h3 += i3[r3++] << c3, c3 += 8;
                }
                n3.length = h3, n3.head && (n3.head.extra_len = h3), 512 & n3.flags && (C3[0] = 255 & h3, C3[1] = h3 >>> 8 & 255, n3.check = Br(n3.check, C3, 2, 0)), h3 = 0, c3 = 0;
              } else
                n3.head && (n3.head.extra = null);
              n3.mode = 6;
            case 6:
              if (1024 & n3.flags && (f3 = n3.length, f3 > o3 && (f3 = o3), f3 && (n3.head && (I3 = n3.head.extra_len - n3.length, n3.head.extra || (n3.head.extra = new Uint8Array(n3.head.extra_len)), n3.head.extra.set(i3.subarray(r3, r3 + f3), I3)), 512 & n3.flags && (n3.check = Br(n3.check, i3, f3, r3)), o3 -= f3, r3 += f3, n3.length -= f3), n3.length))
                break e;
              n3.length = 0, n3.mode = 7;
            case 7:
              if (2048 & n3.flags) {
                if (o3 === 0)
                  break e;
                f3 = 0;
                do {
                  I3 = i3[r3 + f3++], n3.head && I3 && n3.length < 65536 && (n3.head.name += String.fromCharCode(I3));
                } while (I3 && f3 < o3);
                if (512 & n3.flags && (n3.check = Br(n3.check, i3, f3, r3)), o3 -= f3, r3 += f3, I3)
                  break e;
              } else
                n3.head && (n3.head.name = null);
              n3.length = 0, n3.mode = 8;
            case 8:
              if (4096 & n3.flags) {
                if (o3 === 0)
                  break e;
                f3 = 0;
                do {
                  I3 = i3[r3 + f3++], n3.head && I3 && n3.length < 65536 && (n3.head.comment += String.fromCharCode(I3));
                } while (I3 && f3 < o3);
                if (512 & n3.flags && (n3.check = Br(n3.check, i3, f3, r3)), o3 -= f3, r3 += f3, I3)
                  break e;
              } else
                n3.head && (n3.head.comment = null);
              n3.mode = 9;
            case 9:
              if (512 & n3.flags) {
                for (; c3 < 16; ) {
                  if (o3 === 0)
                    break e;
                  o3--, h3 += i3[r3++] << c3, c3 += 8;
                }
                if (h3 !== (65535 & n3.check)) {
                  e3.msg = "header crc mismatch", n3.mode = 30;
                  break;
                }
                h3 = 0, c3 = 0;
              }
              n3.head && (n3.head.hcrc = n3.flags >> 9 & 1, n3.head.done = true), e3.adler = n3.check = 0, n3.mode = 12;
              break;
            case 10:
              for (; c3 < 32; ) {
                if (o3 === 0)
                  break e;
                o3--, h3 += i3[r3++] << c3, c3 += 8;
              }
              e3.adler = n3.check = wo(h3), h3 = 0, c3 = 0, n3.mode = 11;
            case 11:
              if (n3.havedict === 0)
                return e3.next_out = a3, e3.avail_out = l3, e3.next_in = r3, e3.avail_in = o3, n3.hold = h3, n3.bits = c3, uo;
              e3.adler = n3.check = 1, n3.mode = 12;
            case 12:
              if (t3 === oo || t3 === lo)
                break e;
            case 13:
              if (n3.last) {
                h3 >>>= 7 & c3, c3 -= 7 & c3, n3.mode = 27;
                break;
              }
              for (; c3 < 3; ) {
                if (o3 === 0)
                  break e;
                o3--, h3 += i3[r3++] << c3, c3 += 8;
              }
              switch (n3.last = 1 & h3, h3 >>>= 1, c3 -= 1, 3 & h3) {
                case 0:
                  n3.mode = 14;
                  break;
                case 1:
                  if (To(n3), n3.mode = 20, t3 === lo) {
                    h3 >>>= 2, c3 -= 2;
                    break e;
                  }
                  break;
                case 2:
                  n3.mode = 17;
                  break;
                case 3:
                  e3.msg = "invalid block type", n3.mode = 30;
              }
              h3 >>>= 2, c3 -= 2;
              break;
            case 14:
              for (h3 >>>= 7 & c3, c3 -= 7 & c3; c3 < 32; ) {
                if (o3 === 0)
                  break e;
                o3--, h3 += i3[r3++] << c3, c3 += 8;
              }
              if ((65535 & h3) != (h3 >>> 16 ^ 65535)) {
                e3.msg = "invalid stored block lengths", n3.mode = 30;
                break;
              }
              if (n3.length = 65535 & h3, h3 = 0, c3 = 0, n3.mode = 15, t3 === lo)
                break e;
            case 15:
              n3.mode = 16;
            case 16:
              if (f3 = n3.length, f3) {
                if (f3 > o3 && (f3 = o3), f3 > l3 && (f3 = l3), f3 === 0)
                  break e;
                s3.set(i3.subarray(r3, r3 + f3), a3), o3 -= f3, r3 += f3, l3 -= f3, a3 += f3, n3.length -= f3;
                break;
              }
              n3.mode = 12;
              break;
            case 17:
              for (; c3 < 14; ) {
                if (o3 === 0)
                  break e;
                o3--, h3 += i3[r3++] << c3, c3 += 8;
              }
              if (n3.nlen = 257 + (31 & h3), h3 >>>= 5, c3 -= 5, n3.ndist = 1 + (31 & h3), h3 >>>= 5, c3 -= 5, n3.ncode = 4 + (15 & h3), h3 >>>= 4, c3 -= 4, n3.nlen > 286 || n3.ndist > 30) {
                e3.msg = "too many length or distance symbols", n3.mode = 30;
                break;
              }
              n3.have = 0, n3.mode = 18;
            case 18:
              for (; n3.have < n3.ncode; ) {
                for (; c3 < 3; ) {
                  if (o3 === 0)
                    break e;
                  o3--, h3 += i3[r3++] << c3, c3 += 8;
                }
                n3.lens[A3[n3.have++]] = 7 & h3, h3 >>>= 3, c3 -= 3;
              }
              for (; n3.have < 19; )
                n3.lens[A3[n3.have++]] = 0;
              if (n3.lencode = n3.lendyn, n3.lenbits = 7, k3 = {bits: n3.lenbits}, x3 = ro(0, n3.lens, 0, 19, n3.lencode, 0, n3.work, k3), n3.lenbits = k3.bits, x3) {
                e3.msg = "invalid code lengths set", n3.mode = 30;
                break;
              }
              n3.have = 0, n3.mode = 19;
            case 19:
              for (; n3.have < n3.nlen + n3.ndist; ) {
                for (; P3 = n3.lencode[h3 & (1 << n3.lenbits) - 1], p3 = P3 >>> 24, v3 = P3 >>> 16 & 255, w3 = 65535 & P3, !(p3 <= c3); ) {
                  if (o3 === 0)
                    break e;
                  o3--, h3 += i3[r3++] << c3, c3 += 8;
                }
                if (w3 < 16)
                  h3 >>>= p3, c3 -= p3, n3.lens[n3.have++] = w3;
                else {
                  if (w3 === 16) {
                    for (T3 = p3 + 2; c3 < T3; ) {
                      if (o3 === 0)
                        break e;
                      o3--, h3 += i3[r3++] << c3, c3 += 8;
                    }
                    if (h3 >>>= p3, c3 -= p3, n3.have === 0) {
                      e3.msg = "invalid bit length repeat", n3.mode = 30;
                      break;
                    }
                    I3 = n3.lens[n3.have - 1], f3 = 3 + (3 & h3), h3 >>>= 2, c3 -= 2;
                  } else if (w3 === 17) {
                    for (T3 = p3 + 3; c3 < T3; ) {
                      if (o3 === 0)
                        break e;
                      o3--, h3 += i3[r3++] << c3, c3 += 8;
                    }
                    h3 >>>= p3, c3 -= p3, I3 = 0, f3 = 3 + (7 & h3), h3 >>>= 3, c3 -= 3;
                  } else {
                    for (T3 = p3 + 7; c3 < T3; ) {
                      if (o3 === 0)
                        break e;
                      o3--, h3 += i3[r3++] << c3, c3 += 8;
                    }
                    h3 >>>= p3, c3 -= p3, I3 = 0, f3 = 11 + (127 & h3), h3 >>>= 7, c3 -= 7;
                  }
                  if (n3.have + f3 > n3.nlen + n3.ndist) {
                    e3.msg = "invalid bit length repeat", n3.mode = 30;
                    break;
                  }
                  for (; f3--; )
                    n3.lens[n3.have++] = I3;
                }
              }
              if (n3.mode === 30)
                break;
              if (n3.lens[256] === 0) {
                e3.msg = "invalid code -- missing end-of-block", n3.mode = 30;
                break;
              }
              if (n3.lenbits = 9, k3 = {bits: n3.lenbits}, x3 = ro(1, n3.lens, 0, n3.nlen, n3.lencode, 0, n3.work, k3), n3.lenbits = k3.bits, x3) {
                e3.msg = "invalid literal/lengths set", n3.mode = 30;
                break;
              }
              if (n3.distbits = 6, n3.distcode = n3.distdyn, k3 = {bits: n3.distbits}, x3 = ro(2, n3.lens, n3.nlen, n3.ndist, n3.distcode, 0, n3.work, k3), n3.distbits = k3.bits, x3) {
                e3.msg = "invalid distances set", n3.mode = 30;
                break;
              }
              if (n3.mode = 20, t3 === lo)
                break e;
            case 20:
              n3.mode = 21;
            case 21:
              if (o3 >= 6 && l3 >= 258) {
                e3.next_out = a3, e3.avail_out = l3, e3.next_in = r3, e3.avail_in = o3, n3.hold = h3, n3.bits = c3, eo(e3, u3), a3 = e3.next_out, s3 = e3.output, l3 = e3.avail_out, r3 = e3.next_in, i3 = e3.input, o3 = e3.avail_in, h3 = n3.hold, c3 = n3.bits, n3.mode === 12 && (n3.back = -1);
                break;
              }
              for (n3.back = 0; P3 = n3.lencode[h3 & (1 << n3.lenbits) - 1], p3 = P3 >>> 24, v3 = P3 >>> 16 & 255, w3 = 65535 & P3, !(p3 <= c3); ) {
                if (o3 === 0)
                  break e;
                o3--, h3 += i3[r3++] << c3, c3 += 8;
              }
              if (v3 && (240 & v3) == 0) {
                for (b3 = p3, _3 = v3, y3 = w3; P3 = n3.lencode[y3 + ((h3 & (1 << b3 + _3) - 1) >> b3)], p3 = P3 >>> 24, v3 = P3 >>> 16 & 255, w3 = 65535 & P3, !(b3 + p3 <= c3); ) {
                  if (o3 === 0)
                    break e;
                  o3--, h3 += i3[r3++] << c3, c3 += 8;
                }
                h3 >>>= b3, c3 -= b3, n3.back += b3;
              }
              if (h3 >>>= p3, c3 -= p3, n3.back += p3, n3.length = w3, v3 === 0) {
                n3.mode = 26;
                break;
              }
              if (32 & v3) {
                n3.back = -1, n3.mode = 12;
                break;
              }
              if (64 & v3) {
                e3.msg = "invalid literal/length code", n3.mode = 30;
                break;
              }
              n3.extra = 15 & v3, n3.mode = 22;
            case 22:
              if (n3.extra) {
                for (T3 = n3.extra; c3 < T3; ) {
                  if (o3 === 0)
                    break e;
                  o3--, h3 += i3[r3++] << c3, c3 += 8;
                }
                n3.length += h3 & (1 << n3.extra) - 1, h3 >>>= n3.extra, c3 -= n3.extra, n3.back += n3.extra;
              }
              n3.was = n3.length, n3.mode = 23;
            case 23:
              for (; P3 = n3.distcode[h3 & (1 << n3.distbits) - 1], p3 = P3 >>> 24, v3 = P3 >>> 16 & 255, w3 = 65535 & P3, !(p3 <= c3); ) {
                if (o3 === 0)
                  break e;
                o3--, h3 += i3[r3++] << c3, c3 += 8;
              }
              if ((240 & v3) == 0) {
                for (b3 = p3, _3 = v3, y3 = w3; P3 = n3.distcode[y3 + ((h3 & (1 << b3 + _3) - 1) >> b3)], p3 = P3 >>> 24, v3 = P3 >>> 16 & 255, w3 = 65535 & P3, !(b3 + p3 <= c3); ) {
                  if (o3 === 0)
                    break e;
                  o3--, h3 += i3[r3++] << c3, c3 += 8;
                }
                h3 >>>= b3, c3 -= b3, n3.back += b3;
              }
              if (h3 >>>= p3, c3 -= p3, n3.back += p3, 64 & v3) {
                e3.msg = "invalid distance code", n3.mode = 30;
                break;
              }
              n3.offset = w3, n3.extra = 15 & v3, n3.mode = 24;
            case 24:
              if (n3.extra) {
                for (T3 = n3.extra; c3 < T3; ) {
                  if (o3 === 0)
                    break e;
                  o3--, h3 += i3[r3++] << c3, c3 += 8;
                }
                n3.offset += h3 & (1 << n3.extra) - 1, h3 >>>= n3.extra, c3 -= n3.extra, n3.back += n3.extra;
              }
              if (n3.offset > n3.dmax) {
                e3.msg = "invalid distance too far back", n3.mode = 30;
                break;
              }
              n3.mode = 25;
            case 25:
              if (l3 === 0)
                break e;
              if (f3 = u3 - l3, n3.offset > f3) {
                if (f3 = n3.offset - f3, f3 > n3.whave && n3.sane) {
                  e3.msg = "invalid distance too far back", n3.mode = 30;
                  break;
                }
                f3 > n3.wnext ? (f3 -= n3.wnext, m3 = n3.wsize - f3) : m3 = n3.wnext - f3, f3 > n3.length && (f3 = n3.length), g3 = n3.window;
              } else
                g3 = s3, m3 = a3 - n3.offset, f3 = n3.length;
              f3 > l3 && (f3 = l3), l3 -= f3, n3.length -= f3;
              do {
                s3[a3++] = g3[m3++];
              } while (--f3);
              n3.length === 0 && (n3.mode = 21);
              break;
            case 26:
              if (l3 === 0)
                break e;
              s3[a3++] = n3.length, l3--, n3.mode = 21;
              break;
            case 27:
              if (n3.wrap) {
                for (; c3 < 32; ) {
                  if (o3 === 0)
                    break e;
                  o3--, h3 |= i3[r3++] << c3, c3 += 8;
                }
                if (u3 -= l3, e3.total_out += u3, n3.total += u3, u3 && (e3.adler = n3.check = n3.flags ? Br(n3.check, s3, u3, a3 - u3) : Lr(n3.check, s3, u3, a3 - u3)), u3 = l3, (n3.flags ? h3 : wo(h3)) !== n3.check) {
                  e3.msg = "incorrect data check", n3.mode = 30;
                  break;
                }
                h3 = 0, c3 = 0;
              }
              n3.mode = 28;
            case 28:
              if (n3.wrap && n3.flags) {
                for (; c3 < 32; ) {
                  if (o3 === 0)
                    break e;
                  o3--, h3 += i3[r3++] << c3, c3 += 8;
                }
                if (h3 !== (4294967295 & n3.total)) {
                  e3.msg = "incorrect length check", n3.mode = 30;
                  break;
                }
                h3 = 0, c3 = 0;
              }
              n3.mode = 29;
            case 29:
              x3 = co;
              break e;
            case 30:
              x3 = mo;
              break e;
            case 31:
              return go;
            default:
              return fo;
          }
      return e3.next_out = a3, e3.avail_out = l3, e3.next_in = r3, e3.avail_in = o3, n3.hold = h3, n3.bits = c3, (n3.wsize || u3 !== e3.avail_out && n3.mode < 30 && (n3.mode < 27 || t3 !== ao)) && Ao(e3, e3.output, e3.next_out, u3 - e3.avail_out), d3 -= e3.avail_in, u3 -= e3.avail_out, e3.total_in += d3, e3.total_out += u3, n3.total += u3, n3.wrap && u3 && (e3.adler = n3.check = n3.flags ? Br(n3.check, s3, u3, e3.next_out - u3) : Lr(n3.check, s3, u3, e3.next_out - u3)), e3.data_type = n3.bits + (n3.last ? 64 : 0) + (n3.mode === 12 ? 128 : 0) + (n3.mode === 20 || n3.mode === 15 ? 256 : 0), (d3 === 0 && u3 === 0 || t3 === ao) && x3 === ho && (x3 = po), x3;
    }, inflateEnd: (e3) => {
      if (!e3 || !e3.state)
        return fo;
      let t3 = e3.state;
      return t3.window && (t3.window = null), e3.state = null, ho;
    }, inflateGetHeader: (e3, t3) => {
      if (!e3 || !e3.state)
        return fo;
      const n3 = e3.state;
      return (2 & n3.wrap) == 0 ? fo : (n3.head = t3, t3.done = false, ho);
    }, inflateSetDictionary: (e3, t3) => {
      const n3 = t3.length;
      let i3, s3, r3;
      return e3 && e3.state ? (i3 = e3.state, i3.wrap !== 0 && i3.mode !== 11 ? fo : i3.mode === 11 && (s3 = 1, s3 = Lr(s3, t3, n3, 0), s3 !== i3.check) ? mo : (r3 = Ao(e3, t3, n3, n3), r3 ? (i3.mode = 31, go) : (i3.havedict = 1, ho))) : fo;
    }, inflateInfo: "pako inflate (from Nodeca project)"};
    var Eo = function() {
      this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
    };
    var So = Object.prototype.toString;
    var {Z_NO_FLUSH: Mo, Z_FINISH: Ro, Z_OK: Do, Z_STREAM_END: Oo, Z_NEED_DICT: No, Z_STREAM_ERROR: zo, Z_DATA_ERROR: Lo, Z_MEM_ERROR: Vo} = Xr;
    function Bo(e3) {
      this.options = Ra({chunkSize: 65536, windowBits: 15, to: ""}, e3 || {});
      const t3 = this.options;
      t3.raw && t3.windowBits >= 0 && t3.windowBits < 16 && (t3.windowBits = -t3.windowBits, t3.windowBits === 0 && (t3.windowBits = -15)), !(t3.windowBits >= 0 && t3.windowBits < 16) || e3 && e3.windowBits || (t3.windowBits += 32), t3.windowBits > 15 && t3.windowBits < 48 && (15 & t3.windowBits) == 0 && (t3.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new Ba(), this.strm.avail_out = 0;
      let n3 = $o.inflateInit2(this.strm, t3.windowBits);
      if (n3 !== Do)
        throw new Error(Ur[n3]);
      if (this.header = new Eo(), $o.inflateGetHeader(this.strm, this.header), t3.dictionary && (typeof t3.dictionary == "string" ? t3.dictionary = za(t3.dictionary) : So.call(t3.dictionary) === "[object ArrayBuffer]" && (t3.dictionary = new Uint8Array(t3.dictionary)), t3.raw && (n3 = $o.inflateSetDictionary(this.strm, t3.dictionary), n3 !== Do)))
        throw new Error(Ur[n3]);
    }
    function Uo(e3, t3) {
      const n3 = new Bo(t3);
      if (n3.push(e3), n3.err)
        throw n3.msg || Ur[n3.err];
      return n3.result;
    }
    Bo.prototype.push = function(e3, t3) {
      const n3 = this.strm, i3 = this.options.chunkSize, s3 = this.options.dictionary;
      let r3, a3, o3;
      if (this.ended)
        return false;
      for (a3 = t3 === ~~t3 ? t3 : t3 === true ? Ro : Mo, So.call(e3) === "[object ArrayBuffer]" ? n3.input = new Uint8Array(e3) : n3.input = e3, n3.next_in = 0, n3.avail_in = n3.input.length; ; ) {
        for (n3.avail_out === 0 && (n3.output = new Uint8Array(i3), n3.next_out = 0, n3.avail_out = i3), r3 = $o.inflate(n3, a3), r3 === No && s3 && (r3 = $o.inflateSetDictionary(n3, s3), r3 === Do ? r3 = $o.inflate(n3, a3) : r3 === Lo && (r3 = No)); n3.avail_in > 0 && r3 === Oo && n3.state.wrap > 0 && e3[n3.next_in] !== 0; )
          $o.inflateReset(n3), r3 = $o.inflate(n3, a3);
        switch (r3) {
          case zo:
          case Lo:
          case No:
          case Vo:
            return this.onEnd(r3), this.ended = true, false;
        }
        if (o3 = n3.avail_out, n3.next_out && (n3.avail_out === 0 || r3 === Oo))
          if (this.options.to === "string") {
            let e4 = Va(n3.output, n3.next_out), t4 = n3.next_out - e4, s4 = La(n3.output, e4);
            n3.next_out = t4, n3.avail_out = i3 - t4, t4 && n3.output.set(n3.output.subarray(e4, e4 + t4), 0), this.onData(s4);
          } else
            this.onData(n3.output.length === n3.next_out ? n3.output : n3.output.subarray(0, n3.next_out));
        if (r3 !== Do || o3 !== 0) {
          if (r3 === Oo)
            return r3 = $o.inflateEnd(this.strm), this.onEnd(r3), this.ended = true, true;
          if (n3.avail_in === 0)
            break;
        }
      }
      return true;
    }, Bo.prototype.onData = function(e3) {
      this.chunks.push(e3);
    }, Bo.prototype.onEnd = function(e3) {
      e3 === Do && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = Da(this.chunks)), this.chunks = [], this.err = e3, this.msg = this.strm.msg;
    };
    var Xo = {Inflate: Bo, inflate: Uo, inflateRaw: function(e3, t3) {
      return (t3 = t3 || {}).raw = true, Uo(e3, t3);
    }, ungzip: Uo, constants: Xr};
    var {Deflate: Fo, deflate: Go, deflateRaw: Ho, gzip: jo} = Qa;
    var {Inflate: Zo, inflate: Jo, inflateRaw: Ko, ungzip: Wo} = Xo;
    var Yo = Go;
    var qo = Zo;
    var Qo = Jo;
    var el = [137, 80, 78, 71, 13, 10, 26, 10];
    var tl = [];
    for (let e3 = 0; e3 < 256; e3++) {
      let t3 = e3;
      for (let e4 = 0; e4 < 8; e4++)
        1 & t3 ? t3 = 3988292384 ^ t3 >>> 1 : t3 >>>= 1;
      tl[e3] = t3;
    }
    function nl(e3, t3) {
      return (4294967295 ^ function(e4, t4, n3) {
        let i3 = e4;
        for (let e5 = 0; e5 < n3; e5++)
          i3 = tl[255 & (i3 ^ t4[e5])] ^ i3 >>> 8;
        return i3;
      }(4294967295, e3, t3)) >>> 0;
    }
    var il;
    var sl;
    var rl;
    var al;
    !function(e3) {
      e3[e3.UNKNOWN = -1] = "UNKNOWN", e3[e3.GREYSCALE = 0] = "GREYSCALE", e3[e3.TRUECOLOUR = 2] = "TRUECOLOUR", e3[e3.INDEXED_COLOUR = 3] = "INDEXED_COLOUR", e3[e3.GREYSCALE_ALPHA = 4] = "GREYSCALE_ALPHA", e3[e3.TRUECOLOUR_ALPHA = 6] = "TRUECOLOUR_ALPHA";
    }(il || (il = {})), function(e3) {
      e3[e3.UNKNOWN = -1] = "UNKNOWN", e3[e3.DEFLATE = 0] = "DEFLATE";
    }(sl || (sl = {})), function(e3) {
      e3[e3.UNKNOWN = -1] = "UNKNOWN", e3[e3.ADAPTIVE = 0] = "ADAPTIVE";
    }(rl || (rl = {})), function(e3) {
      e3[e3.UNKNOWN = -1] = "UNKNOWN", e3[e3.NO_INTERLACE = 0] = "NO_INTERLACE", e3[e3.ADAM7 = 1] = "ADAM7";
    }(al || (al = {}));
    var ol = new Uint8Array(0);
    var ll = new Uint16Array([255]);
    var hl = new Uint8Array(ll.buffer)[0] === 255;
    var cl = class extends ir {
      constructor(e3, t3 = {}) {
        super(e3);
        const {checkCrc: n3 = false} = t3;
        this._checkCrc = n3, this._inflator = new qo(), this._png = {width: -1, height: -1, channels: -1, data: new Uint8Array(0), depth: 1, text: {}}, this._end = false, this._hasPalette = false, this._palette = [], this._compressionMethod = sl.UNKNOWN, this._filterMethod = rl.UNKNOWN, this._interlaceMethod = al.UNKNOWN, this._colorType = -1, this.setBigEndian();
      }
      decode() {
        for (this.decodeSignature(); !this._end; )
          this.decodeChunk();
        return this.decodeImage(), this._png;
      }
      decodeSignature() {
        for (let e3 = 0; e3 < el.length; e3++)
          if (this.readUint8() !== el[e3])
            throw new Error(`wrong PNG signature. Byte at ${e3} should be ${el[e3]}.`);
      }
      decodeChunk() {
        const e3 = this.readUint32(), t3 = this.readChars(4), n3 = this.offset;
        switch (t3) {
          case "IHDR":
            this.decodeIHDR();
            break;
          case "PLTE":
            this.decodePLTE(e3);
            break;
          case "IDAT":
            this.decodeIDAT(e3);
            break;
          case "IEND":
            this._end = true;
            break;
          case "tRNS":
            this.decodetRNS(e3);
            break;
          case "iCCP":
            this.decodeiCCP(e3);
            break;
          case "tEXt":
            this.decodetEXt(e3);
            break;
          case "pHYs":
            this.decodepHYs();
            break;
          default:
            this.skip(e3);
        }
        if (this.offset - n3 !== e3)
          throw new Error(`Length mismatch while decoding chunk ${t3}`);
        if (this._checkCrc) {
          const n4 = this.readUint32(), i3 = e3 + 4, s3 = nl(new Uint8Array(this.buffer, this.byteOffset + this.offset - i3 - 4, i3), i3);
          if (s3 !== n4)
            throw new Error(`CRC mismatch for chunk ${t3}. Expected ${n4}, found ${s3}`);
        } else
          this.skip(4);
      }
      decodeIHDR() {
        const e3 = this._png;
        e3.width = this.readUint32(), e3.height = this.readUint32(), e3.depth = function(e4) {
          if (e4 !== 1 && e4 !== 2 && e4 !== 4 && e4 !== 8 && e4 !== 16)
            throw new Error(`invalid bit depth: ${e4}`);
          return e4;
        }(this.readUint8());
        const t3 = this.readUint8();
        let n3;
        switch (this._colorType = t3, t3) {
          case il.GREYSCALE:
            n3 = 1;
            break;
          case il.TRUECOLOUR:
            n3 = 3;
            break;
          case il.INDEXED_COLOUR:
            n3 = 1;
            break;
          case il.GREYSCALE_ALPHA:
            n3 = 2;
            break;
          case il.TRUECOLOUR_ALPHA:
            n3 = 4;
            break;
          default:
            throw new Error(`Unknown color type: ${t3}`);
        }
        if (this._png.channels = n3, this._compressionMethod = this.readUint8(), this._compressionMethod !== sl.DEFLATE)
          throw new Error(`Unsupported compression method: ${this._compressionMethod}`);
        this._filterMethod = this.readUint8(), this._interlaceMethod = this.readUint8();
      }
      decodePLTE(e3) {
        if (e3 % 3 != 0)
          throw new RangeError(`PLTE field length must be a multiple of 3. Got ${e3}`);
        const t3 = e3 / 3;
        this._hasPalette = true;
        const n3 = [];
        this._palette = n3;
        for (let e4 = 0; e4 < t3; e4++)
          n3.push([this.readUint8(), this.readUint8(), this.readUint8()]);
      }
      decodeIDAT(e3) {
        this._inflator.push(new Uint8Array(this.buffer, this.offset + this.byteOffset, e3)), this.skip(e3);
      }
      decodetRNS(e3) {
        if (this._colorType === 3) {
          if (e3 > this._palette.length)
            throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${e3} vs ${this._palette.length})`);
          let t3 = 0;
          for (; t3 < e3; t3++) {
            const e4 = this.readByte();
            this._palette[t3].push(e4);
          }
          for (; t3 < this._palette.length; t3++)
            this._palette[t3].push(255);
        }
      }
      decodeiCCP(e3) {
        let t3, n3 = "";
        for (; (t3 = this.readChar()) !== "\0"; )
          n3 += t3;
        const i3 = this.readUint8();
        if (i3 !== sl.DEFLATE)
          throw new Error(`Unsupported iCCP compression method: ${i3}`);
        const s3 = this.readBytes(e3 - n3.length - 2);
        this._png.iccEmbeddedProfile = {name: n3, profile: Qo(s3)};
      }
      decodetEXt(e3) {
        let t3, n3 = "";
        for (; (t3 = this.readChar()) !== "\0"; )
          n3 += t3;
        this._png.text[n3] = this.readChars(e3 - n3.length - 1);
      }
      decodepHYs() {
        const e3 = this.readUint32(), t3 = this.readUint32(), n3 = this.readByte();
        this._png.resolution = {x: e3, y: t3, unit: n3};
      }
      decodeImage() {
        if (this._inflator.err)
          throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
        const e3 = this._inflator.result;
        if (this._filterMethod !== rl.ADAPTIVE)
          throw new Error(`Filter method ${this._filterMethod} not supported`);
        if (this._interlaceMethod !== al.NO_INTERLACE)
          throw new Error(`Interlace method ${this._interlaceMethod} not supported`);
        this.decodeInterlaceNull(e3);
      }
      decodeInterlaceNull(e3) {
        const t3 = this._png.height, n3 = this._png.channels * this._png.depth / 8, i3 = this._png.width * n3, s3 = new Uint8Array(this._png.height * i3);
        let r3, a3, o3 = ol, l3 = 0;
        for (let h4 = 0; h4 < t3; h4++) {
          switch (r3 = e3.subarray(l3 + 1, l3 + 1 + i3), a3 = s3.subarray(h4 * i3, (h4 + 1) * i3), e3[l3]) {
            case 0:
              dl(r3, a3, i3);
              break;
            case 1:
              ul(r3, a3, i3, n3);
              break;
            case 2:
              fl(r3, a3, o3, i3);
              break;
            case 3:
              ml(r3, a3, o3, i3, n3);
              break;
            case 4:
              gl(r3, a3, o3, i3, n3);
              break;
            default:
              throw new Error(`Unsupported filter: ${e3[l3]}`);
          }
          o3 = a3, l3 += i3 + 1;
        }
        if (this._hasPalette && (this._png.palette = this._palette), this._png.depth === 16) {
          const e4 = new Uint16Array(s3.buffer);
          if (hl)
            for (let t4 = 0; t4 < e4.length; t4++)
              e4[t4] = (255 & (h3 = e4[t4])) << 8 | h3 >> 8 & 255;
          this._png.data = e4;
        } else
          this._png.data = s3;
        var h3;
      }
    };
    function dl(e3, t3, n3) {
      for (let i3 = 0; i3 < n3; i3++)
        t3[i3] = e3[i3];
    }
    function ul(e3, t3, n3, i3) {
      let s3 = 0;
      for (; s3 < i3; s3++)
        t3[s3] = e3[s3];
      for (; s3 < n3; s3++)
        t3[s3] = e3[s3] + t3[s3 - i3] & 255;
    }
    function fl(e3, t3, n3, i3) {
      let s3 = 0;
      if (n3.length === 0)
        for (; s3 < i3; s3++)
          t3[s3] = e3[s3];
      else
        for (; s3 < i3; s3++)
          t3[s3] = e3[s3] + n3[s3] & 255;
    }
    function ml(e3, t3, n3, i3, s3) {
      let r3 = 0;
      if (n3.length === 0) {
        for (; r3 < s3; r3++)
          t3[r3] = e3[r3];
        for (; r3 < i3; r3++)
          t3[r3] = e3[r3] + (t3[r3 - s3] >> 1) & 255;
      } else {
        for (; r3 < s3; r3++)
          t3[r3] = e3[r3] + (n3[r3] >> 1) & 255;
        for (; r3 < i3; r3++)
          t3[r3] = e3[r3] + (t3[r3 - s3] + n3[r3] >> 1) & 255;
      }
    }
    function gl(e3, t3, n3, i3, s3) {
      let r3 = 0;
      if (n3.length === 0) {
        for (; r3 < s3; r3++)
          t3[r3] = e3[r3];
        for (; r3 < i3; r3++)
          t3[r3] = e3[r3] + t3[r3 - s3] & 255;
      } else {
        for (; r3 < s3; r3++)
          t3[r3] = e3[r3] + n3[r3] & 255;
        for (; r3 < i3; r3++)
          t3[r3] = e3[r3] + pl(t3[r3 - s3], n3[r3], n3[r3 - s3]) & 255;
      }
    }
    function pl(e3, t3, n3) {
      const i3 = e3 + t3 - n3, s3 = Math.abs(i3 - e3), r3 = Math.abs(i3 - t3), a3 = Math.abs(i3 - n3);
      return s3 <= r3 && s3 <= a3 ? e3 : r3 <= a3 ? t3 : n3;
    }
    var vl = {level: 3};
    var wl = class extends ir {
      constructor(e3, t3 = {}) {
        super(), this._colorType = il.UNKNOWN, this._zlibOptions = Object.assign({}, vl, t3.zlib), this._png = this._checkData(e3), this.setBigEndian();
      }
      encode() {
        return this.encodeSignature(), this.encodeIHDR(), this.encodeData(), this.encodeIEND(), this.toArray();
      }
      encodeSignature() {
        this.writeBytes(el);
      }
      encodeIHDR() {
        this.writeUint32(13), this.writeChars("IHDR"), this.writeUint32(this._png.width), this.writeUint32(this._png.height), this.writeByte(this._png.depth), this.writeByte(this._colorType), this.writeByte(sl.DEFLATE), this.writeByte(rl.ADAPTIVE), this.writeByte(al.NO_INTERLACE), this.writeCrc(17);
      }
      encodeIEND() {
        this.writeUint32(0), this.writeChars("IEND"), this.writeCrc(4);
      }
      encodeIDAT(e3) {
        this.writeUint32(e3.length), this.writeChars("IDAT"), this.writeBytes(e3), this.writeCrc(e3.length + 4);
      }
      encodeData() {
        const {width: e3, height: t3, channels: n3, depth: i3, data: s3} = this._png, r3 = n3 * e3, a3 = new ir().setBigEndian();
        let o3 = 0;
        for (let e4 = 0; e4 < t3; e4++)
          if (a3.writeByte(0), i3 === 8)
            o3 = _l(s3, a3, r3, o3);
          else {
            if (i3 !== 16)
              throw new Error("unreachable");
            o3 = yl(s3, a3, r3, o3);
          }
        const l3 = a3.toArray(), h3 = Yo(l3, this._zlibOptions);
        this.encodeIDAT(h3);
      }
      _checkData(e3) {
        const {colorType: t3, channels: n3, depth: i3} = function(e4) {
          const {channels: t4 = 4, depth: n4 = 8} = e4;
          if (t4 !== 4 && t4 !== 3 && t4 !== 2 && t4 !== 1)
            throw new RangeError(`unsupported number of channels: ${t4}`);
          if (n4 !== 8 && n4 !== 16)
            throw new RangeError(`unsupported bit depth: ${n4}`);
          const i4 = {channels: t4, depth: n4, colorType: il.UNKNOWN};
          switch (t4) {
            case 4:
              i4.colorType = il.TRUECOLOUR_ALPHA;
              break;
            case 3:
              i4.colorType = il.TRUECOLOUR;
              break;
            case 1:
              i4.colorType = il.GREYSCALE;
              break;
            case 2:
              i4.colorType = il.GREYSCALE_ALPHA;
              break;
            default:
              throw new Error("unsupported number of channels");
          }
          return i4;
        }(e3), s3 = {width: bl(e3.width, "width"), height: bl(e3.height, "height"), channels: n3, data: e3.data, depth: i3, text: {}};
        this._colorType = t3;
        const r3 = s3.width * s3.height * n3;
        if (s3.data.length !== r3)
          throw new RangeError(`wrong data size. Found ${s3.data.length}, expected ${r3}`);
        return s3;
      }
      writeCrc(e3) {
        this.writeUint32(nl(new Uint8Array(this.buffer, this.byteOffset + this.offset - e3, e3), e3));
      }
    };
    function bl(e3, t3) {
      if (Number.isInteger(e3) && e3 > 0)
        return e3;
      throw new TypeError(`${t3} must be a positive integer`);
    }
    function _l(e3, t3, n3, i3) {
      for (let s3 = 0; s3 < n3; s3++)
        t3.writeByte(e3[i3++]);
      return i3;
    }
    function yl(e3, t3, n3, i3) {
      for (let s3 = 0; s3 < n3; s3++)
        t3.writeUint16(e3[i3++]);
      return i3;
    }
    var Il;
    !function(e3) {
      e3[e3.UNKNOWN = 0] = "UNKNOWN", e3[e3.METRE = 1] = "METRE";
    }(Il || (Il = {}));
    var xl = et(Object.freeze({__proto__: null, decode: function(e3, t3) {
      return new cl(e3, t3).decode();
    }, encode: function(e3, t3) {
      return new wl(e3, t3).encode();
    }, get ResolutionUnitSpecifier() {
      return Il;
    }}));
    var Pl = it(function(e3, t3) {
      !function(e4, t4, n3, i3) {
        function s3(e5) {
          if (e5 && e5.__esModule)
            return e5;
          var t5 = Object.create(null);
          return e5 && Object.keys(e5).forEach(function(n4) {
            if (n4 !== "default") {
              var i4 = Object.getOwnPropertyDescriptor(e5, n4);
              Object.defineProperty(t5, n4, i4.get ? i4 : {enumerable: true, get: function() {
                return e5[n4];
              }});
            }
          }), t5.default = e5, Object.freeze(t5);
        }
        var r3 = s3(n3), a3 = s3(i3), o3 = {name: "@zeainc/gltf-loader", libraryName: "GLTFLoader", author: "Philip Taylor", description: "A plugin to load GLTF files in Zea Engine.", version: "4.0.7", license: "MIT", main: "dist/index.cjs.js", module: "dist/index.esm.js", browser: "dist/index.umd.js", files: ["dist/"], keywords: ["WebGL", "ES6", "Zea", "GLTF", "Draco"], repository: {type: "git", url: "https://github.com/ZeaInc/gltf-loader"}, scripts: {build: "rollup -c", "build:watch": "rollup -w -c", dev: "npm-run-all --parallel build:watch start:watch", dist: "yarn publish --access=public", generate: "plop", prepare: "yarn run build", release: "standard-version", start: "es-dev-server", "start:watch": "es-dev-server --app-index testing-e2e/index.html --open --watch", "test:e2e": "percy exec cypress run --browser chrome --headless", "test:e2e:watch": "percy exec cypress open"}, devDependencies: {"@percy/cypress": "^2.3.2", "@rollup/plugin-json": "^4.1.0", "@zeainc/zea-engine": "^4", cypress: "^5.4.0", "es-dev-server": "^1.57.8", eslint: "^6.5.1", "eslint-config-google": "^0.14.0", "eslint-config-prettier": "^6.3.0", "eslint-plugin-prettier": "^3.1.1", "npm-run-all": "^4.1.5", plop: "^2.7.4", prettier: "^2.1.1", rollup: "^2.2.0", "rollup-plugin-terser": "^5.3.0", "rollup-plugin-web-worker-loader": "^0.9.0", "standard-version": "^9.0.0", yargs: "12.0.2"}, dependencies: {"fast-png": "^6.1.0", "jpeg-js": "^0.4.3"}};
        const l3 = {BYTE: 5120, UNSIGNED_BYTE: 5121, SHORT: 5122, UNSIGNED_SHORT: 5123, INT: 5124, UNSIGNED_INT: 5125, FLOAT: 5126};
        function h3(e5, t5, n4) {
          let i4 = new glMatrix.ARRAY_TYPE(n4);
          for (let s4 = 0; s4 < n4; ++s4)
            i4[s4] = e5[t5 + s4];
          return i4;
        }
        function c3(e5, t5, n4) {
          for (const i4 of Object.keys(e5)) {
            const s4 = e5[i4];
            if (s4 != null && typeof a_string != "string" && (s4.initGl !== void 0 && s4.initGl(t5, n4), Array.isArray(s4)))
              for (const e6 of s4)
                e6 != null && e6.initGl !== void 0 && e6.initGl(t5, n4);
          }
        }
        function d3(e5, t5) {
          if (e5 === void 0)
            return [];
          const n4 = [];
          for (const i4 of e5)
            n4.push(u3(i4, t5));
          return n4;
        }
        function u3(e5, t5) {
          const n4 = new t5();
          return n4.fromJson(e5), n4;
        }
        function f3(e5, t5, n4 = []) {
          for (let i4 of Object.keys(e5))
            n4 && n4.find(function(e6) {
              return e6 == i4;
            }) !== void 0 || t5[i4] === void 0 || (e5[i4.replace("^@", "")] = t5[i4]);
        }
        function m3(e5, t5, n4) {
          return Math.min(Math.max(e5, t5), n4);
        }
        function g3(e5) {
          return function(e6) {
            const t5 = e6.toLowerCase().split(".");
            if (t5.length != 1)
              return t5[t5.length - 1];
          }(e5) == "glb";
        }
        function p3(e5) {
          return e5.substring(0, e5.lastIndexOf("/") + 1);
        }
        class v3 {
          constructor() {
            this.extensions = void 0, this.extras = void 0;
          }
          fromJson(e5) {
            f3(this, e5);
          }
          initGl(e5, t5) {
            c3(this, e5, t5);
          }
        }
        class w3 extends v3 {
          constructor() {
            super(), this.bufferView = void 0, this.byteOffset = 0, this.componentType = void 0, this.normalized = false, this.count = void 0, this.type = void 0, this.max = void 0, this.min = void 0, this.sparse = void 0, this.name = void 0, this.glBuffer = void 0, this.typedView = void 0, this.filteredView = void 0, this.normalizedFilteredView = void 0, this.normalizedTypedView = void 0;
          }
          getTypedView(e5) {
            if (this.typedView !== void 0)
              return this.typedView;
            if (this.bufferView !== void 0) {
              const t5 = e5.bufferViews[this.bufferView], n4 = e5.buffers[t5.buffer], i4 = this.byteOffset + t5.byteOffset, s4 = this.getComponentSize(this.componentType);
              let r4 = this.getComponentCount(this.type), a4 = 0;
              switch (t5.byteStride !== 0 ? s4 !== 0 ? a4 = t5.byteStride / s4 * (this.count - 1) + r4 : console.warn("Invalid component type in accessor '" + (this.name ? this.name : "") + "'") : a4 = this.count * r4, a4 * s4 > n4.buffer.byteLength - i4 && (a4 = (n4.buffer.byteLength - i4) / s4, console.warn("Count in accessor '" + (this.name ? this.name : "") + "' is too large.")), this.componentType) {
                case l3.BYTE:
                  this.typedView = new Int8Array(n4.buffer, i4, a4);
                  break;
                case l3.UNSIGNED_BYTE:
                  this.typedView = new Uint8Array(n4.buffer, i4, a4);
                  break;
                case l3.SHORT:
                  this.typedView = new Int16Array(n4.buffer, i4, a4);
                  break;
                case l3.UNSIGNED_SHORT:
                  this.typedView = new Uint16Array(n4.buffer, i4, a4);
                  break;
                case l3.UNSIGNED_INT:
                  this.typedView = new Uint32Array(n4.buffer, i4, a4);
                  break;
                case l3.FLOAT:
                  this.typedView = new Float32Array(n4.buffer, i4, a4);
              }
            }
            return this.typedView === void 0 ? console.warn("Failed to convert buffer view to typed view!: " + this.bufferView) : this.sparse !== void 0 && this.applySparse(e5, this.typedView), this.typedView;
          }
          getNormalizedTypedView(e5) {
            if (this.normalizedTypedView !== void 0)
              return this.normalizedTypedView;
            const t5 = this.getTypedView(e5);
            return this.normalizedTypedView = this.normalized ? w3.dequantize(t5, this.componentType) : t5, this.normalizedTypedView;
          }
          getDeinterlacedView(e5) {
            if (this.filteredView !== void 0)
              return this.filteredView;
            if (this.bufferView !== void 0) {
              const t5 = e5.bufferViews[this.bufferView], n4 = e5.buffers[t5.buffer], i4 = this.byteOffset + t5.byteOffset, s4 = this.getComponentSize(this.componentType), r4 = this.getComponentCount(this.type), a4 = this.count * r4;
              let o4 = t5.byteStride !== 0 ? t5.byteStride : r4 * s4;
              const h4 = n4.buffer.byteLength - i4;
              let c4 = new DataView(n4.buffer, i4, Math.min(h4, this.count * o4)), d4 = c4.getFloat32.bind(c4);
              switch (this.componentType) {
                case l3.BYTE:
                  this.filteredView = new Int8Array(a4), d4 = c4.getInt8.bind(c4);
                  break;
                case l3.UNSIGNED_BYTE:
                  this.filteredView = new Uint8Array(a4), d4 = c4.getUint8.bind(c4);
                  break;
                case l3.SHORT:
                  this.filteredView = new Int16Array(a4), d4 = c4.getInt16.bind(c4);
                  break;
                case l3.UNSIGNED_SHORT:
                  this.filteredView = new Uint16Array(a4), d4 = c4.getUint16.bind(c4);
                  break;
                case l3.UNSIGNED_INT:
                  this.filteredView = new Uint32Array(a4), d4 = c4.getUint32.bind(c4);
                  break;
                case l3.FLOAT:
                  this.filteredView = new Float32Array(a4), d4 = c4.getFloat32.bind(c4);
              }
              for (let e6 = 0; e6 < a4; ++e6) {
                let t6 = Math.floor(e6 / r4) * o4 + e6 % r4 * s4;
                this.filteredView[e6] = d4(t6, true);
              }
            }
            return this.filteredView === void 0 ? console.warn("Failed to convert buffer view to filtered view!: " + this.bufferView) : this.sparse !== void 0 && this.applySparse(e5, this.filteredView), this.filteredView;
          }
          getNormalizedDeinterlacedView(e5) {
            if (this.normalizedFilteredView !== void 0)
              return this.normalizedFilteredView;
            const t5 = this.getDeinterlacedView(e5);
            return this.normalizedFilteredView = this.normalized ? w3.dequantize(t5, this.componentType) : t5, this.normalizedFilteredView;
          }
          applySparse(e5, t5) {
            const n4 = e5.bufferViews[this.sparse.indices.bufferView], i4 = e5.buffers[n4.buffer], s4 = this.sparse.indices.byteOffset + n4.byteOffset, r4 = this.getComponentSize(this.sparse.indices.componentType);
            let a4 = 1;
            n4.byteStride !== 0 && (a4 = n4.byteStride / r4);
            const o4 = this.sparse.count * a4;
            let h4;
            switch (this.sparse.indices.componentType) {
              case l3.UNSIGNED_BYTE:
                h4 = new Uint8Array(i4.buffer, s4, o4);
                break;
              case l3.UNSIGNED_SHORT:
                h4 = new Uint16Array(i4.buffer, s4, o4);
                break;
              case l3.UNSIGNED_INT:
                h4 = new Uint32Array(i4.buffer, s4, o4);
            }
            const c4 = e5.bufferViews[this.sparse.values.bufferView], d4 = e5.buffers[c4.buffer], u4 = this.sparse.values.byteOffset + c4.byteOffset, f4 = this.getComponentSize(this.componentType);
            let m4 = this.getComponentCount(this.type);
            c4.byteStride !== 0 && (m4 = c4.byteStride / f4);
            const g4 = this.sparse.count * m4;
            let p4;
            switch (this.componentType) {
              case l3.BYTE:
                p4 = new Int8Array(d4.buffer, u4, g4);
                break;
              case l3.UNSIGNED_BYTE:
                p4 = new Uint8Array(d4.buffer, u4, g4);
                break;
              case l3.SHORT:
                p4 = new Int16Array(d4.buffer, u4, g4);
                break;
              case l3.UNSIGNED_SHORT:
                p4 = new Uint16Array(d4.buffer, u4, g4);
                break;
              case l3.UNSIGNED_INT:
                p4 = new Uint32Array(d4.buffer, u4, g4);
                break;
              case l3.FLOAT:
                p4 = new Float32Array(d4.buffer, u4, g4);
            }
            for (let e6 = 0; e6 < this.sparse.count; ++e6)
              for (let n5 = 0; n5 < m4; ++n5)
                t5[h4[e6] * m4 + n5] = p4[e6 * m4 + n5];
          }
          static dequantize(e5, t5) {
            switch (t5) {
              case l3.BYTE:
                return new Float32Array(e5).map((e6) => Math.max(e6 / 127, -1));
              case l3.UNSIGNED_BYTE:
                return new Float32Array(e5).map((e6) => e6 / 255);
              case l3.SHORT:
                return new Float32Array(e5).map((e6) => Math.max(e6 / 32767, -1));
              case l3.UNSIGNED_SHORT:
                return new Float32Array(e5).map((e6) => e6 / 65535);
              default:
                return e5;
            }
          }
          getComponentCount(e5) {
            return b3.get(e5);
          }
          getComponentSize(e5) {
            switch (e5) {
              case l3.BYTE:
              case l3.UNSIGNED_BYTE:
                return 1;
              case l3.SHORT:
              case l3.UNSIGNED_SHORT:
                return 2;
              case l3.UNSIGNED_INT:
              case l3.FLOAT:
                return 4;
              default:
                return 0;
            }
          }
          destroy() {
            this.glBuffer !== void 0 && WebGl.context.deleteBuffer(this.glBuffer), this.glBuffer = void 0;
          }
        }
        const b3 = new Map([["SCALAR", 1], ["VEC2", 2], ["VEC3", 3], ["VEC4", 4], ["MAT2", 4], ["MAT3", 9], ["MAT4", 16]]);
        class _3 extends v3 {
          constructor() {
            super(), this.uri = void 0, this.byteLength = void 0, this.name = void 0, this.buffer = void 0;
          }
          load(e5, t5) {
            if (this.buffer !== void 0)
              return void console.error("buffer has already been loaded");
            const n4 = this;
            return new Promise(function(i4) {
              n4.setBufferFromFiles(t5, i4) || n4.setBufferFromUri(e5, i4) || (console.error("Was not able to resolve buffer with uri '%s'", n4.uri), i4());
            });
          }
          setBufferFromUri(e5, n4) {
            if (this.uri === void 0)
              return false;
            const i4 = this;
            return this.uri.startsWith("data:application") ? t4.resourceLoader.loadFile("binary", this.uri).then(function(e6) {
              i4.buffer = e6, n4();
            }) : t4.resourceLoader.loadFile("binary", p3(e5.path) + this.uri).then(function(e6) {
              i4.buffer = e6, n4();
            }), true;
          }
          setBufferFromFiles(e5, t5) {
            if (this.uri === void 0 || e5 === void 0)
              return false;
            const n4 = e5.find(function(e6) {
              if (e6.name === this.uri || e6.fullPath === this.uri)
                return true;
            }, this);
            if (n4 === void 0)
              return false;
            const i4 = this, s4 = new FileReader();
            return s4.onloadend = function(e6) {
              i4.buffer = e6.target.result, t5();
            }, s4.readAsArrayBuffer(n4), true;
          }
        }
        class y3 extends v3 {
          constructor() {
            super(), this.buffer = void 0, this.byteOffset = 0, this.byteLength = void 0, this.byteStride = 0, this.target = void 0, this.name = void 0;
          }
        }
        class I3 extends v3 {
          constructor(e5 = "perspective", t5 = 0.01, n4 = 1 / 0, i4 = 45 * Math.PI / 180, s4, r4 = 1, a4 = 1, o4, l4) {
            super(), this.type = e5, this.znear = t5, this.zfar = n4, this.yfov = i4, this.xmag = r4, this.ymag = a4, this.aspectRatio = s4, this.name = o4, this.node = l4;
          }
          initGl(e5, t5) {
            let n4;
            super.initGl(e5, t5);
            for (let t6 = 0; t6 < e5.nodes.length; t6++)
              if (n4 = e5.nodes[t6].camera, n4 !== void 0 && e5.cameras[n4] === this) {
                this.node = t6;
                break;
              }
            this.node === void 0 && n4 !== void 0 && console.error("Invalid node for camera " + n4);
          }
          fromJson(e5) {
            this.name = name, e5.perspective !== void 0 ? (this.type = "perspective", f3(this, e5.perspective)) : e5.orthographic !== void 0 && (this.type = "orthographic", f3(this, e5.orthographic));
          }
          sortPrimitivesByDepth(e5, t5) {
            for (const n4 of t5) {
              const t6 = mat4.create();
              mat4.multiply(t6, this.getViewMatrix(e5), n4.node.worldTransform);
              const i4 = vec3.transformMat4(vec3.create(), vec3.clone(n4.primitive.centroid), t6);
              n4.depth = i4[2];
            }
            return t5.filter((e6) => e6.depth <= 0).sort((e6, t6) => e6.depth - t6.depth);
          }
          getProjectionMatrix() {
            const e5 = mat4.create();
            return this.type === "perspective" ? mat4.perspective(e5, this.yfov, this.aspectRatio, this.znear, this.zfar) : this.type === "orthographic" && (e5[0] = 1 / this.xmag, e5[5] = 1 / this.ymag, e5[10] = 2 / (this.znear - this.zfar), e5[14] = (this.zfar + this.znear) / (this.znear - this.zfar)), e5;
          }
          getViewMatrix(e5) {
            const t5 = mat4.create(), n4 = this.getPosition(e5), i4 = this.getTarget(e5);
            return mat4.lookAt(t5, n4, i4, vec3.fromValues(0, 1, 0)), t5;
          }
          getTarget(e5) {
            const t5 = vec3.create(), n4 = this.getPosition(e5), i4 = this.getLookDirection(e5);
            return vec3.add(t5, i4, n4), t5;
          }
          getPosition(e5) {
            const t5 = vec3.create(), n4 = this.getNode(e5);
            return mat4.getTranslation(t5, n4.worldTransform), t5;
          }
          getLookDirection(e5) {
            const t5 = vec3.create(), n4 = this.getRotation(e5);
            return vec3.transformQuat(t5, vec3.fromValues(0, 0, -1), n4), t5;
          }
          getRotation(e5) {
            const t5 = quat.create(), n4 = this.getNode(e5);
            return mat4.getRotation(t5, n4.worldTransform), t5;
          }
          clone() {
            return new I3(this.type, this.znear, this.zfar, this.yfov, this.aspectRatio, this.xmag, this.ymag, this.name, this.node);
          }
          getNode(e5) {
            return e5.nodes[this.node];
          }
          getTransformMatrix(e5) {
            const t5 = this.getNode(e5);
            return t5 !== void 0 && t5.worldTransform !== void 0 ? t5.worldTransform : mat4.create();
          }
          getDescription(e5) {
            const t5 = {type: this.type};
            this.name !== void 0 && (t5.name = this.name), this.type === "perspective" ? (t5.perspective = {}, this.aspectRatio !== void 0 && (t5.perspective.aspectRatio = this.aspectRatio), t5.perspective.yfov = this.yfov, this.zfar != 1 / 0 && (t5.perspective.zfar = this.zfar), t5.perspective.znear = this.znear) : this.type === "orthographic" && (t5.orthographic = {}, t5.orthographic.xmag = this.xmag, t5.orthographic.ymag = this.ymag, t5.orthographic.zfar = this.zfar, t5.orthographic.znear = this.znear);
            const n4 = this.getTransformMatrix(e5), i4 = {camera: 0, matrix: [n4[0], n4[1], n4[2], n4[3], n4[4], n4[5], n4[6], n4[7], n4[8], n4[9], n4[10], n4[11], n4[12], n4[13], n4[14], n4[15]]};
            return this.nodeIndex !== void 0 && e5.nodes[this.nodeIndex].name !== void 0 && (i4.name = e5.nodes[this.nodeIndex].name), {asset: {generator: "gltf-sample-viewer", version: "2.0"}, cameras: [t5], nodes: [i4]};
          }
        }
        class x3 {
          static async readAsArrayBuffer(e5) {
            return new Promise((t5, n4) => {
              const i4 = new FileReader();
              i4.onload = () => t5(i4.result), i4.onerror = n4, i4.readAsArrayBuffer(e5);
            });
          }
          static async readAsText(e5) {
            return new Promise((t5, n4) => {
              const i4 = new FileReader();
              i4.onload = () => t5(i4.result), i4.onerror = n4, i4.readAsText(e5);
            });
          }
          static async readAsDataURL(e5) {
            return new Promise((t5, n4) => {
              const i4 = new FileReader();
              i4.onload = () => t5(i4.result), i4.onerror = n4, i4.readAsDataURL(e5);
            });
          }
        }
        const P3 = "image/jpeg", C3 = "image/png", k3 = "image/ktx2", T3 = "image/texture";
        class A3 extends v3 {
          constructor(e5, t5 = l3.TEXTURE_2D, n4 = 0, i4, s4, r4 = P3, a4) {
            super(), this.uri = e5, this.bufferView = i4, this.mimeType = r4, this.image = a4, this.name = s4, this.type = t5, this.miplevel = n4;
          }
          fromJson(e5) {
            super.fromJson(e5);
          }
          resolveRelativePath(e5) {
            (typeof this.uri == "string" || this.uri instanceof String) && (this.uri.startsWith("./") && (this.uri = this.uri.substr(2)), this.uri = e5 + this.uri);
          }
          async load(e5, t5) {
            this.image === void 0 ? await this.setImageFromBufferView(e5) || await this.setImageFromFiles(t5, e5) || await this.setImageFromUri(e5) || console.error("Was not able to resolve image with uri '%s'", this.uri) : this.mimeType !== T3 && console.error("image has already been loaded");
          }
          static loadHTMLImage(e5) {
            return new Promise((n4, i4) => {
              const s4 = new t4.FileImage(this.name);
              s4.load(e5).then(() => {
                n4(s4);
              }, () => {
                i4();
              });
            });
          }
          async setImageFromUri(e5) {
            return this.uri !== void 0 && (typeof Image == "undefined" || this.mimeType !== P3 && this.mimeType !== C3 ? (console.error("Unsupported image type " + this.mimeType), false) : (this.zeaImage = await A3.loadHTMLImage(this.uri).catch((e6) => {
              console.error(e6);
            }), true));
          }
          async setImageFromBufferView(e5) {
            const t5 = e5.bufferViews[this.bufferView];
            if (t5 === void 0)
              return false;
            const n4 = e5.buffers[t5.buffer].buffer, i4 = new Uint8Array(n4, t5.byteOffset, t5.byteLength);
            if (this.mimeType === k3)
              e5.ktxDecoder !== void 0 ? this.image = await e5.ktxDecoder.loadKtxFromBuffer(i4) : console.warn("Loading of ktx images failed: KtxDecoder not initalized");
            else if (typeof Image == "undefined" || this.mimeType !== P3 && this.mimeType !== C3)
              if (this.mimeType === P3)
                this.image = r3.decode(i4, {useTArray: true});
              else {
                if (this.mimeType !== C3)
                  return console.error("Unsupported image type " + this.mimeType), false;
                this.image = a3.decode(i4);
              }
            else {
              const e6 = new Blob([i4], {type: this.mimeType}), t6 = URL.createObjectURL(e6);
              this.image = await A3.loadHTMLImage(t6).catch(() => {
                console.error("Could not load image from buffer view");
              });
            }
            return true;
          }
          async setImageFromFiles(e5, t5) {
            if (this.uri === void 0 || e5 === void 0)
              return false;
            let n4 = e5.find(function(e6) {
              const t6 = this.uri.split("\\").pop().split("/").pop();
              if (e6.name === t6)
                return true;
            }, this);
            if (n4 === void 0)
              return false;
            if (this.mimeType === k3)
              if (t5.ktxDecoder !== void 0) {
                const e6 = new Uint8Array(await n4.arrayBuffer());
                this.image = await t5.ktxDecoder.loadKtxFromBuffer(e6);
              } else
                console.warn("Loading of ktx images failed: KtxDecoder not initalized");
            else {
              if (typeof Image == "undefined" || this.mimeType !== P3 && this.mimeType !== C3)
                return console.error("Unsupported image type " + this.mimeType), false;
              {
                const e6 = await x3.readAsDataURL(n4).catch(() => {
                  console.error("Could not load image with FileReader");
                });
                this.image = await A3.loadHTMLImage(e6).catch(() => {
                  console.error("Could not create image from FileReader image data");
                });
              }
            }
            return true;
          }
        }
        class $3 extends v3 {
          constructor(e5 = "directional", t5 = [1, 1, 1], n4 = 1, i4 = 0, s4 = Math.PI / 4, r4 = -1, a4, o4) {
            super(), this.type = e5, this.color = t5, this.intensity = n4, this.innerConeAngle = i4, this.outerConeAngle = s4, this.range = r4, this.name = a4, this.node = o4, this.direction = void 0;
          }
          initGl(e5, t5) {
            super.initGl(e5, t5);
            for (let t6 = 0; t6 < e5.nodes.length; t6++) {
              const n4 = e5.nodes[t6].extensions;
              if (n4 === void 0)
                continue;
              const i4 = n4.KHR_lights_punctual;
              if (i4 === void 0)
                continue;
              const s4 = i4.light;
              if (e5.lights[s4] === this) {
                this.node = t6;
                break;
              }
            }
          }
          fromJson(e5) {
            super.fromJson(e5), e5.spot !== void 0 && f3(this, e5.spot);
          }
          toUniform(e5) {
            const t5 = new R3();
            if (this.node !== void 0) {
              const r4 = e5.nodes[this.node].worldTransform;
              var n4 = vec3.fromValues(1, 1, 1);
              mat4.getScaling(n4, r4);
              const a4 = mat4.create();
              for (const e6 of [0, 1, 2])
                a4[e6] = r4[e6] / n4[0], a4[e6 + 4] = r4[e6 + 4] / n4[1], a4[e6 + 8] = r4[e6 + 8] / n4[2];
              var i4 = quat.create();
              mat4.getRotation(i4, a4), quat.normalize(i4, i4);
              const o4 = vec3.fromValues(0, 0, -1);
              vec3.transformQuat(t5.direction, o4, i4);
              var s4 = vec3.fromValues(0, 0, 0);
              mat4.getTranslation(s4, r4), t5.position = s4;
            }
            switch (this.direction !== void 0 && (t5.direction = this.direction), t5.range = this.range, t5.color = this.color, t5.intensity = this.intensity, t5.innerConeCos = Math.cos(this.innerConeAngle), t5.outerConeCos = Math.cos(this.outerConeAngle), this.type) {
              case "spot":
                t5.type = M3;
                break;
              case "point":
                t5.type = S3;
                break;
              default:
                t5.type = E3;
            }
            return t5;
          }
        }
        const E3 = 0, S3 = 1, M3 = 2;
        class R3 extends class {
        } {
          constructor() {
            super();
            const e5 = vec3.fromValues(-0.7399, -0.6428, -0.1983);
            this.direction = e5, this.range = -1, this.color = [1, 1, 1], this.intensity = 1, this.position = [0, 0, 0], this.innerConeCos = 0, this.outerConeCos = Math.PI / 4, this.type = E3, this.padding1 = 0, this.padding2 = 0;
          }
        }
        class D3 extends v3 {
          constructor() {
            super(), this.rotation = [0, 0, 0, 1], this.brightnessFactor = 1, this.brightnessOffset = 0, this.specularEnvironmentTexture = void 0, this.diffuseEnvironmentTexture = void 0, this.sheenEnvironmentTexture = void 0, this.levelCount = 1;
          }
          fromJson(e5) {
            super.fromJson(e5), e5.extensions !== void 0 && this.fromJsonExtensions(e5.extensions);
          }
          fromJsonExtensions(e5) {
            e5.KHR_materials_sheen !== void 0 && (this.sheenEnvironmentTexture = e5.KHR_materials_sheen.sheenEnvironmentTexture);
          }
          initGl(e5, t5) {
            if (this.diffuseEnvironmentTexture !== void 0 && (e5.textures[this.diffuseEnvironmentTexture].type = l3.TEXTURE_CUBE_MAP), this.specularEnvironmentTexture !== void 0) {
              const t6 = e5.textures[this.specularEnvironmentTexture];
              t6.type = l3.TEXTURE_CUBE_MAP;
              const n4 = e5.images[t6.source];
              this.levelCount = n4.image.levelCount;
            }
            if (this.sheenEnvironmentTexture !== void 0) {
              const t6 = e5.textures[this.sheenEnvironmentTexture];
              t6.type = l3.TEXTURE_CUBE_MAP;
              const n4 = e5.images[t6.source];
              this.levelCount !== n4.image.levelCount && console.error("Specular and sheen do not have same level count");
            }
          }
        }
        class O3 extends v3 {
          constructor(e5, t5, n4 = l3.TEXTURE_2D) {
            super(), this.sampler = e5, this.source = t5, this.glTexture = void 0, this.type = n4, this.initialized = false, this.mipLevelCount = 0;
          }
          initGl(e5, t5) {
            this.sampler === void 0 && (this.sampler = e5.samplers.length - 1), c3(this, e5, t5);
          }
          fromJson(e5) {
            super.fromJson(e5), e5.extensions !== void 0 && e5.extensions.KHR_texture_basisu !== void 0 && e5.extensions.KHR_texture_basisu.source !== void 0 && (this.source = e5.extensions.KHR_texture_basisu.source);
          }
          destroy() {
          }
        }
        class N3 {
          constructor(e5, t5 = 0, n4 = true, i4 = "", s4 = true) {
            this.index = e5, this.texCoord = t5, this.linear = n4, this.samplerName = i4, this.strength = 1, this.scale = 1, this.generateMips = s4, this.extensions = void 0;
          }
          initGl(e5, t5) {
            c3(this, e5, t5);
          }
          fromJson(e5) {
            f3(this, e5);
          }
        }
        class z3 extends v3 {
          constructor() {
            super(), this.name = void 0, this.pbrMetallicRoughness = void 0, this.normalTexture = void 0, this.occlusionTexture = void 0, this.emissiveTexture = void 0, this.emissiveFactor = [0, 0, 0], this.alphaMode = "OPAQUE", this.alphaCutoff = 0.5, this.doubleSided = false, this.hasClearcoat = false, this.hasSheen = false, this.hasTransmission = false, this.hasIOR = false, this.hasVolume = false, this.type = "unlit", this.textures = [], this.properties = new Map(), this.defines = [];
          }
          static createDefault() {
            const e5 = new z3();
            e5.type = "MR", e5.name = "Default Material", e5.defines.push("MATERIAL_METALLICROUGHNESS 1");
            const n4 = new t4.Vec4(1, 1, 1, 1);
            return e5.properties.set("u_BaseColorFactor", n4), e5.properties.set("u_MetallicFactor", 1), e5.properties.set("u_RoughnessFactor", 1), e5;
          }
          getShaderIdentifier() {
            return this.type, "pbr.frag";
          }
          getDefines(e5) {
            const t5 = Array.from(this.defines);
            return this.hasClearcoat && e5.enabledExtensions.KHR_materials_clearcoat && t5.push("MATERIAL_CLEARCOAT 1"), this.hasSheen && e5.enabledExtensions.KHR_materials_sheen && t5.push("MATERIAL_SHEEN 1"), this.hasTransmission && e5.enabledExtensions.KHR_materials_transmission && t5.push("MATERIAL_TRANSMISSION 1"), this.hasVolume && e5.enabledExtensions.KHR_materials_volume && t5.push("MATERIAL_VOLUME 1"), this.hasIOR && e5.enabledExtensions.KHR_materials_ior && t5.push("MATERIAL_IOR 1"), this.hasSpecular && e5.enabledExtensions.KHR_materials_specular && t5.push("MATERIAL_SPECULAR 1"), t5;
          }
          getProperties() {
            return this.properties;
          }
          getTextures() {
            return this.textures;
          }
          parseTextureInfoExtensions(e5, n4) {
            if (e5.extensions !== void 0 && e5.extensions.KHR_texture_transform !== void 0) {
              const i4 = e5.extensions.KHR_texture_transform;
              i4.texCoord !== void 0 && (e5.texCoord = i4.texCoord);
              let s4 = new t4.Mat3(), r4 = new t4.Mat3(), a4 = new t4.Mat3();
              if (i4.rotation !== void 0) {
                const e6 = Math.sin(i4.rotation), n5 = Math.cos(i4.rotation);
                s4 = new t4.Mat3([n5, e6, 0, -e6, n5, 0, 0, 0, 1]);
              }
              i4.scale !== void 0 && (r4 = new t4.Mat3([i4.scale[0], 0, 0, 0, i4.scale[1], 0, 0, 0, 1])), i4.offset !== void 0 && (a4 = new t4.Mat3([1, 0, i4.offset[0], 0, 1, i4.offset[1], 0, 0, 1]));
              const o4 = s4.multiply(r4);
              o4.multiplyInPlace(a4), this.defines.push("HAS_" + n4.toUpperCase() + "_UV_TRANSFORM 1"), this.properties.set("u_" + n4 + "UVTransform", o4);
            }
          }
          initGl(e5, n4) {
            this.zeaMaterial = new t4.Material(this.name, "StandardSurfaceShader");
            const i4 = (t5, n5) => {
              const i5 = e5.textures[t5.index], s4 = e5.samplers[i5.sampler], r4 = e5.images[i5.source];
              r4.zeaImage.wrapS = s4.wrapS, r4.zeaImage.wrapT = s4.wrapT, n5.setImage(r4.zeaImage);
            };
            if (this.normalTexture !== void 0 && i4(this.normalTexture, this.zeaMaterial.getParameter("Normal")), this.occlusionTexture !== void 0 && i4(this.occlusionTexture, this.zeaMaterial.getParameter("AmbientOcclusion")), this.properties.set("u_EmissiveFactor", this.emissiveFactor), this.emissiveTexture !== void 0 && i4(this.emissiveTexture, this.zeaMaterial.getParameter("EmissiveStrength")), this.baseColorTexture !== void 0 && i4(this.baseColorTexture, this.zeaMaterial.getParameter("BaseColor")), this.metallicRoughnessTexture !== void 0 && i4(this.metallicRoughnessTexture, this.zeaMaterial.getParameter("Metallic")), this.diffuseTexture !== void 0 && i4(this.diffuseTexture, this.zeaMaterial.getParameter("BaseColor")), this.specularGlossinessTexture !== void 0 && i4(this.specularGlossinessTexture, this.zeaMaterial.getParameter("Reflectance")), this.alphaMode === "MASK" ? (this.defines.push("ALPHAMODE_MASK 1"), this.properties.set("u_AlphaCutoff", this.alphaCutoff)) : this.alphaMode === "OPAQUE" && this.defines.push("ALPHAMODE_OPAQUE 1"), this.pbrMetallicRoughness !== void 0 && this.type !== "SG") {
              this.defines.push("MATERIAL_METALLICROUGHNESS 1");
              let e6 = new t4.Color(1, 1, 1, 1), n5 = 1, i5 = 1;
              this.pbrMetallicRoughness.baseColorFactor !== void 0 && e6.set(...this.pbrMetallicRoughness.baseColorFactor), this.pbrMetallicRoughness.metallicFactor !== void 0 && (n5 = this.pbrMetallicRoughness.metallicFactor), this.pbrMetallicRoughness.roughnessFactor !== void 0 && (i5 = this.pbrMetallicRoughness.roughnessFactor), this.properties.set("u_BaseColorFactor", e6), this.properties.set("u_MetallicFactor", n5), this.properties.set("u_RoughnessFactor", i5), this.zeaMaterial.getParameter("BaseColor").setValue(e6), this.zeaMaterial.getParameter("Metallic").setValue(n5), this.zeaMaterial.getParameter("Roughness").setValue(i5);
            }
            if (this.extensions !== void 0 && (this.extensions.KHR_materials_unlit !== void 0 && this.defines.push("MATERIAL_UNLIT 1"), this.extensions.KHR_materials_pbrSpecularGlossiness !== void 0)) {
              this.defines.push("MATERIAL_SPECULARGLOSSINESS 1");
              let e6 = new t4.Color(1, 1, 1, 1), n5 = new t4.Vec3(1, 1, 1), i5 = 1;
              this.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor !== void 0 && (e6 = this.extensions.KHR_materials_pbrSpecularGlossiness.diffuseFactor), this.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor !== void 0 && (n5 = this.extensions.KHR_materials_pbrSpecularGlossiness.specularFactor), this.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor !== void 0 && (i5 = this.extensions.KHR_materials_pbrSpecularGlossiness.glossinessFactor), this.properties.set("u_DiffuseFactor", e6), this.properties.set("u_SpecularFactor", n5), this.properties.set("u_GlossinessFactor", i5);
            }
            c3(this, e5, n4);
          }
          fromJson(e5) {
            if (super.fromJson(e5), e5.emissiveFactor !== void 0 && (this.emissiveFactor = e5.emissiveFactor), e5.normalTexture !== void 0) {
              const t5 = new N3();
              t5.fromJson(e5.normalTexture), this.normalTexture = t5;
            }
            if (e5.occlusionTexture !== void 0) {
              const t5 = new N3();
              t5.fromJson(e5.occlusionTexture), this.occlusionTexture = t5;
            }
            if (e5.emissiveTexture !== void 0) {
              const t5 = new N3(void 0, 0, false);
              t5.fromJson(e5.emissiveTexture), this.emissiveTexture = t5;
            }
            e5.extensions !== void 0 && this.fromJsonMaterialExtensions(e5.extensions), e5.pbrMetallicRoughness !== void 0 && this.type !== "SG" && (this.type = "MR", this.fromJsonMetallicRoughness(e5.pbrMetallicRoughness));
          }
          fromJsonMaterialExtensions(e5) {
            e5.KHR_materials_pbrSpecularGlossiness !== void 0 && (this.type = "SG", this.fromJsonSpecularGlossiness(e5.KHR_materials_pbrSpecularGlossiness)), e5.KHR_materials_unlit !== void 0 && (this.type = "unlit"), e5.KHR_materials_clearcoat !== void 0 && this.fromJsonClearcoat(e5.KHR_materials_clearcoat), e5.KHR_materials_sheen !== void 0 && this.fromJsonSheen(e5.KHR_materials_sheen), e5.KHR_materials_transmission !== void 0 && this.fromJsonTransmission(e5.KHR_materials_transmission), e5.KHR_materials_specular !== void 0 && this.fromJsonSpecular(e5.KHR_materials_specular), e5.KHR_materials_volume !== void 0 && this.fromJsonVolume(e5.KHR_materials_volume);
          }
          fromJsonMetallicRoughness(e5) {
            if (e5.baseColorTexture !== void 0) {
              const t5 = new N3(void 0, 0, false);
              t5.fromJson(e5.baseColorTexture), this.baseColorTexture = t5;
            }
            if (e5.metallicRoughnessTexture !== void 0) {
              const t5 = new N3();
              t5.fromJson(e5.metallicRoughnessTexture), this.metallicRoughnessTexture = t5;
            }
          }
          fromJsonSpecularGlossiness(e5) {
            if (e5.diffuseTexture !== void 0) {
              const t5 = new N3(void 0, 0, false);
              t5.fromJson(e5.diffuseTexture), this.diffuseTexture = t5;
            }
            if (e5.specularGlossinessTexture !== void 0) {
              const t5 = new N3(void 0, 0, false);
              t5.fromJson(e5.specularGlossinessTexture), this.specularGlossinessTexture = t5;
            }
          }
          fromJsonClearcoat(e5) {
            if (e5.clearcoatTexture !== void 0) {
              const t5 = new N3();
              t5.fromJson(e5.clearcoatTexture), this.clearcoatTexture = t5;
            }
            if (e5.clearcoatRoughnessTexture !== void 0) {
              const t5 = new N3();
              t5.fromJson(e5.clearcoatRoughnessTexture), this.clearcoatRoughnessTexture = t5;
            }
            if (e5.clearcoatNormalTexture !== void 0) {
              const t5 = new N3();
              t5.fromJson(e5.clearcoatNormalTexture), this.clearcoatNormalTexture = t5;
            }
          }
          fromJsonSheen(e5) {
            if (e5.sheenColorTexture !== void 0) {
              const t5 = new N3(void 0, 0, false);
              t5.fromJson(e5.sheenColorTexture), this.sheenColorTexture = t5;
            }
            if (e5.sheenRoughnessTexture !== void 0) {
              const t5 = new N3();
              t5.fromJson(e5.sheenRoughnessTexture), this.sheenRoughnessTexture = t5;
            }
          }
          fromJsonTransmission(e5) {
            if (e5.transmissionTexture !== void 0) {
              const t5 = new N3();
              t5.fromJson(e5.transmissionTexture), this.transmissionTexture = t5;
            }
          }
          fromJsonSpecular(e5) {
            if (e5.specularTexture !== void 0) {
              const t5 = new N3();
              t5.fromJson(e5.specularTexture), this.specularTexture = t5;
            }
            if (e5.specularTexture !== void 0) {
              const t5 = new N3();
              t5.fromJson(e5.specularTexture), this.specularTexture = t5;
            }
          }
          fromJsonVolume(e5) {
            if (e5.thicknessTexture !== void 0) {
              const t5 = new N3();
              t5.fromJson(e5.thicknessTexture), this.thicknessTexture = t5;
            }
          }
        }
        class L3 {
          constructor(e5) {
            if (!L3.instance && e5 === void 0) {
              if (DracoDecoderModule === void 0)
                return void console.error("Failed to initalize DracoDecoder: draco library undefined");
              e5 = DracoDecoderModule;
            }
            return L3.instance || (L3.instance = this, this.module = null, this.initializingPromise = new Promise((t5) => {
              let n4 = {};
              n4.onModuleLoaded = (e6) => {
                this.module = e6, t5();
              }, e5(n4);
            })), L3.instance;
          }
          async ready() {
            await this.initializingPromise, Object.freeze(L3.instance);
          }
        }
        class V3 extends v3 {
          constructor() {
            super(), this.attributes = [], this.targets = [], this.indices = void 0, this.material = void 0, this.mode = "TRIANGLES", this.glAttributes = [], this.defines = [], this.skip = true, this.hasWeights = false, this.hasJoints = false, this.hasNormals = false, this.hasTangents = false, this.hasTexcoord = false, this.hasColor = false, this.centroid = void 0;
          }
          initGl(e5, n4) {
            if (this.material === void 0 && (this.material = e5.materials.length - 1), this.extensions !== void 0 && this.extensions.KHR_draco_mesh_compression !== void 0) {
              const t5 = new L3();
              if (t5 !== void 0 && Object.isFrozen(t5)) {
                let t6 = this.decodeDracoBufferToIntermediate(this.extensions.KHR_draco_mesh_compression, e5);
                this.copyDataFromDecodedGeometry(e5, t6, this.attributes);
              } else
                console.warn("Failed to load draco compressed mesh: DracoDecoder not initialized");
            }
            for (const t5 of Object.keys(this.attributes)) {
              const n5 = this.attributes[t5];
              switch (t5) {
                case "POSITION":
                  this.skip = false, this.glAttributes.push({attribute: t5, name: "a_Position", accessor: n5});
                  break;
                case "NORMAL":
                  this.hasNormals = true, this.defines.push("HAS_NORMALS 1"), this.glAttributes.push({attribute: t5, name: "a_Normal", accessor: n5});
                  break;
                case "TANGENT":
                  this.hasTangents = true, this.defines.push("HAS_TANGENTS 1"), this.glAttributes.push({attribute: t5, name: "a_Tangent", accessor: n5});
                  break;
                case "TEXCOORD_0":
                  this.hasTexcoord = true, this.defines.push("HAS_UV_SET1 1"), this.glAttributes.push({attribute: t5, name: "a_UV1", accessor: n5});
                  break;
                case "TEXCOORD_1":
                  this.hasTexcoord = true, this.defines.push("HAS_UV_SET2 1"), this.glAttributes.push({attribute: t5, name: "a_UV2", accessor: n5});
                  break;
                case "COLOR_0":
                  this.hasColor = true;
                  const i5 = e5.accessors[n5];
                  this.defines.push("HAS_VERTEX_COLOR_" + i5.type + " 1"), this.glAttributes.push({attribute: t5, name: "a_Color", accessor: n5});
                  break;
                case "JOINTS_0":
                  this.hasJoints = true, this.defines.push("HAS_JOINT_SET1 1"), this.glAttributes.push({attribute: t5, name: "a_Joint1", accessor: n5});
                  break;
                case "WEIGHTS_0":
                  this.hasWeights = true, this.defines.push("HAS_WEIGHT_SET1 1"), this.glAttributes.push({attribute: t5, name: "a_Weight1", accessor: n5});
                  break;
                case "JOINTS_1":
                  this.hasJoints = true, this.defines.push("HAS_JOINT_SET2 1"), this.glAttributes.push({attribute: t5, name: "a_Joint2", accessor: n5});
                  break;
                case "WEIGHTS_1":
                  this.hasWeights = true, this.defines.push("HAS_WEIGHT_SET2 1"), this.glAttributes.push({attribute: t5, name: "a_Weight2", accessor: n5});
                  break;
                default:
                  console.log("Unknown attribute: " + t5);
              }
            }
            const i4 = e5.materials[this.material];
            let s4 = i4.zeaMaterial;
            const r4 = e5.accessors[this.attributes.POSITION], a4 = {geomBuffers: {numVertices: r4.count, attrBuffers: {}}, bbox: new t4.Box3(new t4.Vec3(...r4.min), new t4.Vec3(...r4.max))};
            if (this.indices !== void 0) {
              const t5 = e5.accessors[this.indices].getTypedView(e5);
              a4.geomBuffers.indices = t5;
            }
            for (const n5 of Object.keys(this.attributes)) {
              const i5 = this.attributes[n5], r5 = e5.accessors[i5], o5 = e5.bufferViews[r5.bufferView], l4 = r5.getComponentSize(r5.componentType), h4 = r5.getComponentCount(r5.type);
              let c4;
              switch (c4 = o5.byteStride == 0 || o5.byteStride == l4 * h4 ? r5.getTypedView(e5) : r5.getDeinterlacedView(e5), n5) {
                case "POSITION":
                  a4.geomBuffers.attrBuffers.positions = {dataType: "Vec3", normalized: false, values: c4};
                  break;
                case "NORMAL":
                  a4.geomBuffers.attrBuffers.normals = {dataType: "Vec3", normalized: true, values: c4};
                  break;
                case "TEXCOORD_0":
                  a4.geomBuffers.attrBuffers.texCoords = {dataType: "Vec2", normalized: false, values: c4};
                  break;
                case "COLOR_0":
                  let n6 = true;
                  for (let e6 = 1; e6 < c4.length / h4; e6++)
                    for (let t5 = 0; t5 < h4; t5++)
                      c4[t5] != c4[e6 * h4 + t5] && (n6 = false);
                  if (n6) {
                    const n7 = `Material [R=${c4[0]}, G=${c4[1]}, B=${c4[2]}]`;
                    if (e5.materialsMap[n7])
                      s4 = e5.materialsMap[n7];
                    else {
                      const i6 = new t4.Color();
                      l4 == 1 ? i6.set(c4[0] / 256, c4[1] / 256, c4[2] / 256, h4 == 4 ? c4[3] / 256 : 1) : l4 == 4 && i6.set(c4[0], c4[1], c4[2], h4 == 4 ? c4[3] : 1), s4 = s4.clone(), s4.getParameter("BaseColor").setValue(i6), e5.materialsMap[n7] = s4;
                    }
                  } else
                    a4.geomBuffers.attrBuffers.vertexColors = {dataType: "Color", normalized: false, values: c4};
              }
            }
            let o4;
            switch (this.mode) {
              case "POINTS":
              case 0: {
                a4.name = "GLTFPoints", o4 = new t4.PointsProxy(a4);
                const n5 = s4.getParameter("BaseColor").getValue(), i5 = `PointsMaterial [${n5.r.toFixed(2)}, ${n5.g.toFixed(2)}, ${n5.b.toFixed(2)}]`;
                e5.materialsMap[i5] ? s4 = e5.materialsMap[i5] : (s4 = s4.clone(), s4.setShaderName("PointsShader"), e5.materialsMap[i5] = s4);
                break;
              }
              case "LINES":
              case 1: {
                a4.name = "GLTFLines", o4 = new t4.LinesProxy(a4);
                const n5 = s4.getParameter("BaseColor").getValue(), i5 = `LinesMaterial [R=${n5.r.toFixed(2)}, G=${n5.g.toFixed(2)}, B=${n5.b.toFixed(2)}]`;
                e5.materialsMap[i5] ? s4 = e5.materialsMap[i5] : (s4 = s4.clone(), s4.setShaderName("LinesShader"), e5.materialsMap[i5] = s4);
                break;
              }
              case "LINE_LOOP":
              case 2: {
                if (a4.name = "GLTFLineLoop", a4.geomBuffers.indices == null) {
                  const e6 = new Uint32Array(2 * a4.geomBuffers.numVertices);
                  for (let t5 = 0; t5 < a4.geomBuffers.numVertices; t5++)
                    e6[2 * t5] = t5, e6[2 * t5 + 1] = (t5 + 1) % e6.length;
                  a4.geomBuffers.indices = e6;
                } else {
                  const e6 = a4.geomBuffers.indices, t5 = new Uint32Array(2 * e6.length);
                  t5[0] = e6[0], t5[1] = e6[1];
                  let n6 = 1;
                  for (let i6 = 2; i6 <= e6.length; i6++)
                    t5[2 * n6] = e6[i6 - 1], t5[2 * n6 + 1] = e6[i6 % e6.length], n6++;
                  t5[0] == 1209 && console.log(a4.name, a4.geomBuffers.indices.toString()), a4.geomBuffers.indices = t5;
                }
                o4 = new t4.LinesProxy(a4);
                const n5 = s4.getParameter("BaseColor").getValue(), i5 = `LinesMaterial [R=${n5.r.toFixed(2)}, G=${n5.g.toFixed(2)}, B=${n5.b.toFixed(2)}]`;
                e5.materialsMap[i5] ? s4 = e5.materialsMap[i5] : (s4 = s4.clone(), s4.setShaderName("LinesShader"), e5.materialsMap[i5] = s4);
                break;
              }
              case "LINE_STRIP":
              case 3: {
                if (a4.name = "GLTFLineStrip", a4.geomBuffers.indices == null) {
                  const e6 = new Uint32Array(2 * (a4.geomBuffers.numVertices - 1));
                  for (let t5 = 0; t5 < a4.geomBuffers.numVertices - 1; t5++)
                    e6[2 * t5] = t5, e6[2 * t5 + 1] = t5 + 1;
                  a4.geomBuffers.indices = e6;
                } else {
                  const e6 = a4.geomBuffers.indices, t5 = new Uint32Array(2 * (e6.length - 1));
                  t5[0] = e6[0], t5[1] = e6[1];
                  let n6 = 1;
                  for (let i6 = 2; i6 < e6.length; i6++)
                    t5[2 * n6] = e6[i6 - 1], t5[2 * n6 + 1] = e6[i6], n6++;
                  t5[0] == 1209 && console.log(a4.name, a4.geomBuffers.indices.toString()), a4.geomBuffers.indices = t5;
                }
                o4 = new t4.LinesProxy(a4);
                const n5 = s4.getParameter("BaseColor").getValue(), i5 = `LinesMaterial [R=${n5.r.toFixed(2)}, G=${n5.g.toFixed(2)}, B=${n5.b.toFixed(2)}]`;
                e5.materialsMap[i5] ? s4 = e5.materialsMap[i5] : (s4 = s4.clone(), s4.setShaderName("LinesShader"), e5.materialsMap[i5] = s4);
                break;
              }
              case "TRIANGLES":
              case 4:
                if (a4.name = "GLTFMesh", a4.geomBuffers.indices == null) {
                  const e6 = new Uint32Array(a4.geomBuffers.numVertices);
                  for (let t5 = 0; t5 < a4.geomBuffers.numVertices; t5++)
                    e6[t5] = t5;
                  a4.geomBuffers.indices = e6;
                }
                o4 = new t4.MeshProxy(a4);
                break;
              case "TRIANGLE_STRIP":
              case 5:
                if (a4.name = "GLTFMesh", a4.geomBuffers.indices == null) {
                  const e6 = new Uint32Array(3 * a4.geomBuffers.numVertices - 2);
                  e6[0] = 0, e6[1] = 1, e6[2] = 2;
                  for (let t5 = 3; t5 < e6.length; t5 += 3)
                    e6[t5 - 2] = e6[t5 - 1], e6[t5 - 1] = e6[t5 - 2], e6[t5] = t5;
                  a4.geomBuffers.indices = e6;
                } else {
                  const e6 = a4.geomBuffers.indices, t5 = e6.length - 2, n5 = new Uint32Array(3 * t5);
                  n5[0] = e6[0], n5[1] = e6[1], n5[2] = e6[2];
                  let i5 = 1;
                  for (let t6 = 3; t6 < e6.length; t6++)
                    n5[3 * i5] = e6[t6 - 2], n5[3 * i5 + 1] = e6[t6 - 1], n5[3 * i5 + 2] = e6[t6], i5++;
                  a4.geomBuffers.indices = n5;
                }
                o4 = new t4.MeshProxy(a4);
                break;
              case "TRIANGLE_FAN":
              case 6:
                if (a4.name = "GLTFMesh", a4.geomBuffers.indices == null) {
                  const e6 = new Uint32Array(3 * a4.geomBuffers.numVertices - 2);
                  e6[0] = 0, e6[1] = 1, e6[2] = 2;
                  for (let t5 = 3; t5 < e6.length; t5 += 3)
                    e6[t5 - 2] = e6[0], e6[t5 - 1] = e6[t5 - 1], e6[t5] = t5;
                  a4.geomBuffers.indices = e6;
                } else {
                  const e6 = a4.geomBuffers.indices, t5 = e6.length - 2, n5 = new Uint32Array(3 * t5);
                  n5[0] = e6[0], n5[1] = e6[1], n5[2] = e6[2];
                  let i5 = 1;
                  for (let t6 = 3; t6 < e6.length; t6++)
                    n5[3 * i5] = e6[0], n5[3 * i5 + 1] = e6[t6 - 1], n5[3 * i5 + 2] = e6[t6], i5++;
                  a4.geomBuffers.indices = n5;
                }
                o4 = new t4.MeshProxy(a4);
            }
            if (o4) {
              if (i4.alphaMode == "OPAQUE") {
                const e7 = s4.getParameter("BaseColor").getValue();
                e7.a = 1, s4.getParameter("BaseColor").setValue(e7);
              }
              const e6 = new t4.GeomItem(a4.name, o4, s4);
              n4.addChild(e6, false);
            }
          }
          computeCentroid(e5, t5) {
            const n4 = e5.accessors[this.attributes.POSITION].getTypedView(e5);
            if (this.indices !== void 0) {
              const t6 = e5.accessors[this.indices].getTypedView(e5), i4 = new Float32Array(3);
              for (let e6 = 0; e6 < t6.length; e6++) {
                const s5 = 3 * t6[e6];
                i4[0] += n4[s5], i4[1] += n4[s5 + 1], i4[2] += n4[s5 + 2];
              }
              const s4 = new Float32Array([i4[0] / t6.length, i4[1] / t6.length, i4[2] / t6.length]);
              this.centroid = s4;
            } else {
              const e6 = new Float32Array(3);
              for (let t7 = 0; t7 < n4.length; t7 += 3)
                e6[0] += n4[t7], e6[1] += n4[t7 + 1], e6[2] += n4[t7 + 2];
              const t6 = n4.length / 3, i4 = new Float32Array([e6[0] / t6, e6[1] / t6, e6[2] / t6]);
              this.centroid = i4;
            }
          }
          getShaderIdentifier() {
            return "primitive.vert";
          }
          getDefines() {
            return this.defines;
          }
          fromJson(e5) {
            super.fromJson(e5), e5.extensions !== void 0 && this.fromJsonPrimitiveExtensions(e5.extensions);
          }
          fromJsonPrimitiveExtensions(e5) {
            e5.KHR_materials_variants !== void 0 && this.fromJsonVariants(e5.KHR_materials_variants);
          }
          fromJsonVariants(e5) {
            e5.mappings !== void 0 && (this.mappings = e5.mappings);
          }
          copyDataFromDecodedGeometry(e5, t5, n4) {
            let i4 = t5.index.array;
            if (this.loadBufferIntoGltf(i4, e5, this.indices, 34963, "index buffer view"), t5.attributes.POSITION !== void 0) {
              let i5 = this.loadArrayIntoArrayBuffer(t5.attributes.POSITION.array, t5.attributes.POSITION.componentType);
              this.loadBufferIntoGltf(i5, e5, n4.POSITION, 34962, "position buffer view");
            }
            if (t5.attributes.NORMAL !== void 0) {
              let i5 = this.loadArrayIntoArrayBuffer(t5.attributes.NORMAL.array, t5.attributes.NORMAL.componentType);
              this.loadBufferIntoGltf(i5, e5, n4.NORMAL, 34962, "normal buffer view");
            }
            if (t5.attributes.TEXCOORD_0 !== void 0) {
              let i5 = this.loadArrayIntoArrayBuffer(t5.attributes.TEXCOORD_0.array, t5.attributes.TEXCOORD_0.componentType);
              this.loadBufferIntoGltf(i5, e5, n4.TEXCOORD_0, 34962, "TEXCOORD_0 buffer view");
            }
            if (t5.attributes.TEXCOORD_1 !== void 0) {
              let i5 = this.loadArrayIntoArrayBuffer(t5.attributes.TEXCOORD_1.array, t5.attributes.TEXCOORD_1.componentType);
              this.loadBufferIntoGltf(i5, e5, n4.TEXCOORD_1, 34962, "TEXCOORD_1 buffer view");
            }
            if (t5.attributes.TANGENT !== void 0) {
              let i5 = this.loadArrayIntoArrayBuffer(t5.attributes.TANGENT.array, t5.attributes.TANGENT.componentType);
              this.loadBufferIntoGltf(i5, e5, n4.TANGENT, 34962, "Tangent buffer view");
            }
            if (t5.attributes.COLOR_0 !== void 0) {
              let i5 = this.loadArrayIntoArrayBuffer(t5.attributes.COLOR_0.array, t5.attributes.COLOR_0.componentType);
              this.loadBufferIntoGltf(i5, e5, n4.COLOR_0, 34962, "color buffer view");
            }
            if (t5.attributes.JOINTS_0 !== void 0) {
              let i5 = this.loadArrayIntoArrayBuffer(t5.attributes.JOINTS_0.array, t5.attributes.JOINTS_0.componentType);
              this.loadBufferIntoGltf(i5, e5, n4.JOINTS_0, 34963, "JOINTS_0 buffer view");
            }
            if (t5.attributes.WEIGHTS_0 !== void 0) {
              let i5 = this.loadArrayIntoArrayBuffer(t5.attributes.WEIGHTS_0.array, t5.attributes.WEIGHTS_0.componentType);
              this.loadBufferIntoGltf(i5, e5, n4.WEIGHTS_0, 34963, "WEIGHTS_0 buffer view");
            }
            if (t5.attributes.JOINTS_1 !== void 0) {
              let i5 = this.loadArrayIntoArrayBuffer(t5.attributes.JOINTS_1.array, t5.attributes.JOINTS_1.componentType);
              this.loadBufferIntoGltf(i5, e5, n4.JOINTS_1, 34963, "JOINTS_1 buffer view");
            }
            if (t5.attributes.WEIGHTS_1 !== void 0) {
              let i5 = this.loadArrayIntoArrayBuffer(t5.attributes.WEIGHTS_1.array, t5.attributes.WEIGHTS_1.componentType);
              this.loadBufferIntoGltf(i5, e5, n4.WEIGHTS_1, 34963, "WEIGHTS_1 buffer view");
            }
          }
          loadBufferIntoGltf(e5, t5, n4, i4, s4) {
            const r4 = new _3();
            r4.byteLength = e5.byteLength, r4.buffer = e5, t5.buffers.push(r4);
            const a4 = new y3();
            a4.buffer = t5.buffers.length - 1, a4.byteLength = e5.byteLength, s4 !== void 0 && (a4.name = s4), a4.target = i4, t5.bufferViews.push(a4), t5.accessors[n4].byteOffset = 0, t5.accessors[n4].bufferView = t5.bufferViews.length - 1;
          }
          loadArrayIntoArrayBuffer(e5, t5) {
            let n4;
            switch (t5) {
              case "Int8Array":
                n4 = new ArrayBuffer(e5.length), new Int8Array(n4).set(e5);
                break;
              case "Uint8Array":
                n4 = new ArrayBuffer(e5.length), new Uint8Array(n4).set(e5);
                break;
              case "Int16Array":
                n4 = new ArrayBuffer(2 * e5.length), new Int16Array(n4).set(e5);
                break;
              case "Uint16Array":
                n4 = new ArrayBuffer(2 * e5.length), new Uint16Array(n4).set(e5);
                break;
              case "Int32Array":
                n4 = new ArrayBuffer(4 * e5.length), new Int32Array(n4).set(e5);
                break;
              case "Uint32Array":
                n4 = new ArrayBuffer(4 * e5.length), new Uint32Array(n4).set(e5);
                break;
              default:
                n4 = new ArrayBuffer(4 * e5.length), new Float32Array(n4).set(e5);
            }
            return n4;
          }
          decodeDracoBufferToIntermediate(e5, t5) {
            let n4 = e5.bufferView;
            const i4 = t5.bufferViews[n4], s4 = t5.buffers[i4.buffer], r4 = new Int8Array(s4.buffer).slice(i4.byteOffset, i4.byteOffset + i4.byteLength);
            let a4 = new L3().module, o4 = new a4.Decoder(), l4 = new a4.DecoderBuffer();
            l4.Init(r4, i4.byteLength);
            let h4 = this.decodeGeometry(a4, o4, l4, e5.attributes, t5);
            return a4.destroy(l4), h4;
          }
          getDracoArrayTypeFromComponentType(e5) {
            switch (e5) {
              case l3.BYTE:
                return "Int8Array";
              case l3.UNSIGNED_BYTE:
                return "Uint8Array";
              case l3.SHORT:
                return "Int16Array";
              case l3.UNSIGNED_SHORT:
                return "Uint16Array";
              case l3.INT:
                return "Int32Array";
              case l3.UNSIGNED_INT:
                return "Uint32Array";
              case l3.FLOAT:
              default:
                return "Float32Array";
            }
          }
          decodeGeometry(e5, t5, n4, i4, s4) {
            let r4, a4, o4 = t5.GetEncodedGeometryType(n4);
            if (o4 !== e5.TRIANGULAR_MESH)
              throw new Error("DRACOLoader: Unexpected geometry type.");
            if (r4 = new e5.Mesh(), a4 = t5.DecodeBufferToMesh(n4, r4), !a4.ok() || r4.ptr === 0)
              throw new Error("DRACOLoader: Decoding failed: " + a4.error_msg());
            let h4 = {index: null, attributes: {}}, c4 = r4.num_points();
            for (let n5 in i4) {
              let a5, o5 = l3.BYTE;
              for (const [e6, t6] of Object.entries(this.attributes))
                if (e6 === n5) {
                  o5 = s4.accessors[t6].componentType, a5 = s4.accessors[t6].count;
                  break;
                }
              if (c4 !== a5)
                throw new Error(`DRACOLoader: Accessor vertex count ${a5} does not match draco decoder vertex count  ${c4}`);
              o5 = this.getDracoArrayTypeFromComponentType(o5);
              let u4 = t5.GetAttributeByUniqueId(r4, i4[n5]);
              var d4 = this.decodeAttribute(e5, t5, r4, n5, u4, o5);
              h4.attributes[d4.name] = d4;
            }
            if (o4 === e5.TRIANGULAR_MESH) {
              let n5 = 3 * r4.num_faces(), i5 = 4 * n5, s5 = e5._malloc(i5);
              t5.GetTrianglesUInt32Array(r4, i5, s5);
              let a5 = new Uint32Array(e5.HEAPU32.buffer, s5, n5).slice();
              e5._free(s5), h4.index = {array: a5, itemSize: 1};
            }
            return e5.destroy(r4), h4;
          }
          decodeAttribute(e5, t5, n4, i4, s4, r4) {
            let a4, o4, l4, h4 = s4.num_components(), c4 = n4.num_points() * h4;
            switch (r4) {
              case "Float32Array":
                l4 = 4 * c4, a4 = e5._malloc(l4), t5.GetAttributeDataArrayForAllPoints(n4, s4, e5.DT_FLOAT32, l4, a4), o4 = new Float32Array(e5.HEAPF32.buffer, a4, c4).slice(), e5._free(a4);
                break;
              case "Int8Array":
                a4 = e5._malloc(c4), t5.GetAttributeDataArrayForAllPoints(n4, s4, e5.DT_INT8, c4, a4), o4 = new Int8Array(e5.HEAP8.buffer, a4, c4).slice(), e5._free(a4);
                break;
              case "Int16Array":
                l4 = 2 * c4, a4 = e5._malloc(l4), t5.GetAttributeDataArrayForAllPoints(n4, s4, e5.DT_INT16, l4, a4), o4 = new Int16Array(e5.HEAP16.buffer, a4, c4).slice(), e5._free(a4);
                break;
              case "Int32Array":
                l4 = 4 * c4, a4 = e5._malloc(l4), t5.GetAttributeDataArrayForAllPoints(n4, s4, e5.DT_INT32, l4, a4), o4 = new Int32Array(e5.HEAP32.buffer, a4, c4).slice(), e5._free(a4);
                break;
              case "Uint8Array":
                a4 = e5._malloc(c4), t5.GetAttributeDataArrayForAllPoints(n4, s4, e5.DT_UINT8, c4, a4), o4 = new Uint8Array(e5.HEAPU8.buffer, a4, c4).slice(), e5._free(a4);
                break;
              case "Uint16Array":
                l4 = 2 * c4, a4 = e5._malloc(l4), t5.GetAttributeDataArrayForAllPoints(n4, s4, e5.DT_UINT16, l4, a4), o4 = new Uint16Array(e5.HEAPU16.buffer, a4, c4).slice(), e5._free(a4);
                break;
              case "Uint32Array":
                l4 = 4 * c4, a4 = e5._malloc(l4), t5.GetAttributeDataArrayForAllPoints(n4, s4, e5.DT_UINT32, l4, a4), o4 = new Uint32Array(e5.HEAPU32.buffer, a4, c4).slice(), e5._free(a4);
                break;
              default:
                throw new Error("DRACOLoader: Unexpected attribute type.");
            }
            return {name: i4, array: o4, itemSize: h4, componentType: r4};
          }
        }
        class B3 extends v3 {
          constructor() {
            super(), this.primitives = [], this.name = void 0, this.weights = [], this.weightsAnimated = void 0;
          }
          fromJson(e5) {
            super.fromJson(e5), e5.name !== void 0 && (this.name = e5.name), this.primitives = d3(e5.primitives, V3), e5.weights !== void 0 && (this.weights = e5.weights);
          }
          getWeightsAnimated() {
            return this.weightsAnimated !== void 0 ? this.weightsAnimated : this.weights;
          }
          initGl(e5, t5) {
            this.primitives.forEach((n4) => {
              n4.initGl(e5, t5);
            });
          }
        }
        class U3 extends v3 {
          constructor() {
            super(), this.camera = void 0, this.children = [], this.matrix = void 0, this.rotation = [0, 0, 0, 1], this.scale = [1, 1, 1], this.translation = [0, 0, 0], this.name = void 0, this.mesh = void 0, this.skin = void 0, this.light = void 0, this.changed = true, this.animationRotation = void 0, this.animationTranslation = void 0, this.animationScale = void 0;
          }
          fromJson(e5) {
            super.fromJson(e5);
          }
          initGl(e5, n4) {
            let i4;
            if (this.extras) {
              if (window.zeaCad) {
                const {CADBody: e6} = zeaCad;
                i4 = new e6(this.name);
              } else
                i4 = new t4.TreeItem(this.name);
              for (let e6 in this.extras) {
                const n5 = this.extras[e6];
                typeof n5 == "string" ? i4.addParameter(new t4.StringParameter(e6, n5)) : typeof n5 == "boolean" ? i4.addParameter(new t4.BooleanParameter(e6, n5)) : typeof n5 == "number" ? i4.addParameter(new t4.NumberParameter(e6, n5)) : typeof n5 == "object" && i4.addParameter(new t4.Parameter(e6, n5, "json"));
              }
              i4.extras = this.extras;
            } else
              i4 = new t4.TreeItem(this.name);
            const s4 = new t4.Xfo();
            if (this.matrix !== void 0) {
              const e6 = new t4.Mat4(Float32Array.from(this.matrix));
              s4.setFromMat4(e6);
            } else
              this.scale !== void 0 && s4.sc.set(...this.scale), this.rotation !== void 0 && s4.ori.set(...this.rotation), this.translation !== void 0 && s4.tr.set(...this.translation);
            i4.getParameter("LocalXfo").setValue(s4), this.children.forEach((t5) => {
              e5.nodes[t5].initGl(e5, i4);
            }), this.mesh != null && e5.meshes[this.mesh].initGl(e5, i4), n4.addChild(i4, false), t4.resourceLoader.incrementWorkDone(1);
          }
          applyMatrix(e5) {
            this.matrix = e5, mat4.getScaling(this.scale, this.matrix);
            const t5 = mat4.create();
            for (const e6 of [0, 1, 2])
              t5[e6] = this.matrix[e6] / this.scale[0], t5[e6 + 4] = this.matrix[e6 + 4] / this.scale[1], t5[e6 + 8] = this.matrix[e6 + 8] / this.scale[2];
            mat4.getRotation(this.rotation, t5), quat.normalize(this.rotation, this.rotation), mat4.getTranslation(this.translation, this.matrix), this.changed = true;
          }
          applyTranslationAnimation(e5) {
            this.animationTranslation = e5, this.changed = true;
          }
          applyRotationAnimation(e5) {
            this.animationRotation = e5, this.changed = true;
          }
          applyScaleAnimation(e5) {
            this.animationScale = e5, this.changed = true;
          }
          resetTransform() {
            this.rotation = [0, 0, 0, 1], this.scale = [1, 1, 1], this.translation = [0, 0, 0], this.changed = true;
          }
          getLocalTransform() {
            if (this.transform === void 0 || this.changed) {
              this.transform = mat4.create();
              const e5 = this.animationTranslation !== void 0 ? this.animationTranslation : this.translation, t5 = this.animationRotation !== void 0 ? this.animationRotation : this.rotation, n4 = this.animationScale !== void 0 ? this.animationScale : this.scale;
              mat4.fromRotationTranslationScale(this.transform, t5, e5, n4), this.changed = false;
            }
            return mat4.clone(this.transform);
          }
        }
        class X3 extends v3 {
          constructor(e5 = "LINEAR", t5 = "LINEAR_MIPMAP_LINEAR", n4 = "REPEAT", i4 = "REPEAT") {
            super(), this.magFilter = e5, this.minFilter = t5, this.wrapS = n4, this.wrapT = i4, this.name = void 0;
          }
          static createDefault() {
            return new X3();
          }
        }
        class F3 extends v3 {
          constructor(e5 = [], t5) {
            super(), this.nodes = e5, this.name = t5, this.imageBasedLight = void 0;
          }
          initGl(e5, t5) {
            if (this.extensions !== void 0 && this.extensions.KHR_lights_image_based !== void 0) {
              const t6 = this.extensions.KHR_lights_image_based.imageBasedLight;
              this.imageBasedLight = e5.imageBasedLights[t6];
            }
            this.nodes.forEach((n4) => {
              e5.nodes[n4].initGl(e5, t5);
            });
          }
          gatherNodes(e5) {
            const t5 = [];
            function n4(i4) {
              const s4 = e5.nodes[i4];
              t5.push(s4);
              for (const e6 of s4.children)
                n4(e6);
            }
            for (const e6 of this.nodes)
              n4(e6);
            return t5;
          }
          includesNode(e5, t5) {
            let n4 = [...this.nodes];
            for (; n4.length > 0; ) {
              const i4 = n4.pop();
              if (i4 === t5)
                return true;
              n4 = n4.concat(e5.nodes[i4].children);
            }
            return false;
          }
        }
        class G3 extends v3 {
          constructor() {
            super(), this.copyright = void 0, this.generator = void 0, this.version = void 0, this.minVersion = void 0;
          }
        }
        class H3 extends v3 {
          constructor() {
            super(), this.target = {node: void 0, path: void 0}, this.sampler = void 0;
          }
        }
        const j3 = "translation", Z3 = "rotation", J3 = "scale", K3 = "weights";
        class W3 extends v3 {
          constructor() {
            super(), this.input = void 0, this.interpolation = void 0, this.output = void 0;
          }
        }
        const Y3 = "LINEAR", q3 = "STEP", Q3 = "CUBICSPLINE";
        class ee3 {
          constructor() {
            this.prevKey = 0, this.prevT = 0;
          }
          slerpQuat(e5, t5, n4) {
            const i4 = quat.create(), s4 = quat.create();
            quat.normalize(i4, e5), quat.normalize(s4, t5);
            const r4 = quat.create();
            return quat.slerp(r4, i4, s4, n4), quat.normalize(r4, r4), r4;
          }
          step(e5, t5, n4) {
            const i4 = new glMatrix.ARRAY_TYPE(n4);
            for (let s4 = 0; s4 < n4; ++s4)
              i4[s4] = t5[e5 * n4 + s4];
            return i4;
          }
          linear(e5, t5, n4, i4, s4) {
            const r4 = new glMatrix.ARRAY_TYPE(s4);
            for (let a4 = 0; a4 < s4; ++a4)
              r4[a4] = n4[e5 * s4 + a4] * (1 - i4) + n4[t5 * s4 + a4] * i4;
            return r4;
          }
          cubicSpline(e5, t5, n4, i4, s4, r4) {
            const a4 = e5 * r4 * 3, o4 = t5 * r4 * 3, l4 = 1 * r4, h4 = 2 * r4, c4 = new glMatrix.ARRAY_TYPE(r4), d4 = s4 ** 2, u4 = s4 ** 3;
            for (let e6 = 0; e6 < r4; ++e6) {
              const t6 = n4[a4 + e6 + l4], r5 = i4 * n4[o4 + e6 + 0], f4 = i4 * n4[a4 + e6 + h4], m4 = n4[o4 + e6 + l4];
              c4[e6] = (2 * u4 - 3 * d4 + 1) * t6 + (u4 - 2 * d4 + s4) * f4 + (-2 * u4 + 3 * d4) * m4 + (u4 - d4) * r5;
            }
            return c4;
          }
          resetKey() {
            this.prevKey = 0;
          }
          interpolate(e5, t5, n4, i4, s4, r4) {
            if (i4 === void 0)
              return;
            const a4 = e5.accessors[n4.input].getNormalizedDeinterlacedView(e5), o4 = e5.accessors[n4.output].getNormalizedDeinterlacedView(e5);
            if (o4.length === s4)
              return h3(o4, 0, s4);
            i4 = m3(i4 %= r4, a4[0], a4[a4.length - 1]), this.prevT > i4 && (this.prevKey = 0), this.prevT = i4;
            let l4 = null;
            for (let e6 = this.prevKey; e6 < a4.length; ++e6)
              if (i4 <= a4[e6]) {
                l4 = m3(e6, 1, a4.length - 1);
                break;
              }
            this.prevKey = m3(l4 - 1, 0, l4);
            const c4 = a4[l4] - a4[this.prevKey], d4 = (i4 - a4[this.prevKey]) / c4;
            if (t5.target.path === Z3) {
              if (Q3 === n4.interpolation) {
                const e6 = this.cubicSpline(this.prevKey, l4, o4, c4, d4, 4);
                return quat.normalize(e6, e6), e6;
              }
              if (n4.interpolation === Y3) {
                const e6 = this.getQuat(o4, this.prevKey), t6 = this.getQuat(o4, l4);
                return this.slerpQuat(e6, t6, d4);
              }
              if (n4.interpolation === q3)
                return this.getQuat(o4, this.prevKey);
            }
            switch (n4.interpolation) {
              case q3:
                return this.step(this.prevKey, o4, s4);
              case Q3:
                return this.cubicSpline(this.prevKey, l4, o4, c4, d4, s4);
              default:
                return this.linear(this.prevKey, l4, o4, d4, s4);
            }
          }
          getQuat(e5, t5) {
            const n4 = e5[4 * t5], i4 = e5[4 * t5 + 1], s4 = e5[4 * t5 + 2], r4 = e5[4 * t5 + 3];
            return quat.fromValues(n4, i4, s4, r4);
          }
        }
        class te3 extends v3 {
          constructor() {
            super(), this.channels = [], this.samplers = [], this.name = "", this.interpolators = [], this.maxTime = 0, this.disjointAnimations = [];
          }
          fromJson(e5) {
            if (super.fromJson(e5), this.channels = d3(e5.channels, H3), this.samplers = d3(e5.samplers, W3), this.name = e5.name, this.channels !== void 0)
              for (let e6 = 0; e6 < this.channels.length; ++e6)
                this.interpolators.push(new ee3());
            else
              console.error("No channel data found for skin");
          }
          advance(e5, t5) {
            if (this.channels !== void 0) {
              if (this.maxTime == 0)
                for (let t6 = 0; t6 < this.channels.length; ++t6) {
                  const n4 = this.channels[t6], i4 = this.samplers[n4.sampler], s4 = e5.accessors[i4.input].getDeinterlacedView(e5), r4 = s4[s4.length - 1];
                  r4 > this.maxTime && (this.maxTime = r4);
                }
              for (let n4 = 0; n4 < this.interpolators.length; ++n4) {
                const i4 = this.channels[n4], s4 = this.samplers[i4.sampler], r4 = this.interpolators[n4], a4 = e5.nodes[i4.target.node];
                switch (i4.target.path) {
                  case j3:
                    a4.applyTranslationAnimation(r4.interpolate(e5, i4, s4, t5, 3, this.maxTime));
                    break;
                  case Z3:
                    a4.applyRotationAnimation(r4.interpolate(e5, i4, s4, t5, 4, this.maxTime));
                    break;
                  case J3:
                    a4.applyScaleAnimation(r4.interpolate(e5, i4, s4, t5, 3, this.maxTime));
                    break;
                  case K3: {
                    const n5 = e5.meshes[a4.mesh];
                    n5.weightsAnimated = r4.interpolate(e5, i4, s4, t5, n5.weights.length, this.maxTime);
                    break;
                  }
                }
              }
            }
          }
        }
        class ne3 extends v3 {
          constructor() {
            super(), this.name = "", this.inverseBindMatrices = void 0, this.joints = [], this.skeleton = void 0, this.jointMatrices = [], this.jointNormalMatrices = [];
          }
          computeJoints(e5, t5) {
            const n4 = e5.accessors[this.inverseBindMatrices].getDeinterlacedView(e5);
            this.jointMatrices = [], this.jointNormalMatrices = [];
            let i4 = 0;
            for (const s4 of this.joints) {
              const r4 = e5.nodes[s4];
              let a4 = mat4.create(), o4 = h3(n4, 16 * i4++, 16);
              mat4.mul(a4, r4.worldTransform, o4), mat4.mul(a4, t5.inverseWorldTransform, a4), this.jointMatrices.push(a4);
              let l4 = mat4.create();
              mat4.invert(l4, a4), mat4.transpose(l4, l4), this.jointNormalMatrices.push(l4);
            }
          }
        }
        class ie3 extends v3 {
          constructor() {
            super(), this.name = void 0;
          }
          fromJson(e5) {
            e5.name !== void 0 && (this.name = e5.name);
          }
        }
        class se3 extends v3 {
          constructor(e5) {
            super(), this.asset = void 0, this.accessors = [], this.nodes = [], this.scene = void 0, this.scenes = [], this.cameras = [], this.lights = [], this.imageBasedLights = [], this.textures = [], this.images = [], this.samplers = [], this.meshes = [], this.buffers = [], this.bufferViews = [], this.materials = [], this.materialsMap = {}, this.animations = [], this.skins = [], this.path = e5;
          }
          initGl(e5) {
            const t5 = this;
            for (const n4 of this.images)
              n4 != null && n4.initGl !== void 0 && n4.initGl(t5, e5);
            for (const n4 of this.samplers)
              n4 != null && n4.initGl !== void 0 && n4.initGl(t5, e5);
            for (const n4 of this.textures)
              n4 != null && n4.initGl !== void 0 && n4.initGl(t5, e5);
            for (const n4 of this.materials)
              n4 != null && n4.initGl !== void 0 && n4.initGl(t5, e5);
            this.scenes[this.scene].initGl(this, e5);
          }
          fromJson(e5) {
            super.fromJson(e5), this.asset = u3(e5.asset, G3), this.cameras = d3(e5.cameras, I3), this.accessors = d3(e5.accessors, w3), this.meshes = d3(e5.meshes, B3), this.samplers = d3(e5.samplers, X3), this.materials = d3(e5.materials, z3), this.buffers = d3(e5.buffers, _3), this.bufferViews = d3(e5.bufferViews, y3), this.scenes = d3(e5.scenes, F3), this.textures = d3(e5.textures, O3), this.nodes = d3(e5.nodes, U3), this.lights = d3(function(e6) {
              return e6 === void 0 || e6.KHR_lights_punctual === void 0 ? [] : e6.KHR_lights_punctual.lights;
            }(e5.extensions), $3), this.imageBasedLights = d3(function(e6) {
              return e6 === void 0 || e6.KHR_lights_image_based === void 0 ? [] : e6.KHR_lights_image_based.imageBasedLights;
            }(e5.extensions), D3), this.images = d3(e5.images, A3), this.animations = d3(e5.animations, te3), this.skins = d3(e5.skins, ne3), this.variants = d3(function(e6) {
              return e6 === void 0 || e6.KHR_materials_variants === void 0 ? [] : e6.KHR_materials_variants.variants;
            }(e5.extensions), ie3), this.variants = function(e6) {
              for (let t5 = 0; t5 < e6.length; t5++) {
                const n4 = e6[t5].name;
                for (let i4 = t5 + 1; i4 < e6.length; i4++)
                  e6[i4].name == n4 && (e6[i4].name += "0");
              }
              return e6;
            }(this.variants), this.materials.push(z3.createDefault()), this.samplers.push(X3.createDefault()), e5.scenes !== void 0 && (e5.scene === void 0 && e5.scenes.length > 0 ? this.scene = 0 : this.scene = e5.scene), this.computeDisjointAnimations();
          }
          computeDisjointAnimations() {
            for (let e5 = 0; e5 < this.animations.length; e5++) {
              this.animations[e5].disjointAnimations = [];
              for (let t5 = 0; t5 < this.animations.length; t5++) {
                if (e5 == t5)
                  continue;
                let n4 = true;
                for (const i4 of this.animations[e5].channels)
                  for (const e6 of this.animations[t5].channels)
                    if (i4.target.node === e6.target.node && i4.target.path === e6.target.path) {
                      n4 = false;
                      break;
                    }
                n4 && this.animations[e5].disjointAnimations.push(t5);
              }
            }
          }
          nonDisjointAnimations(e5) {
            const t5 = this.animations, n4 = [];
            for (let i4 = 0; i4 < t5.length; i4++) {
              let s4 = true;
              for (const n5 of e5)
                i4 != n5 && (t5[n5].disjointAnimations.includes(i4) || (s4 = false));
              s4 || n4.push(i4);
            }
            return n4;
          }
        }
        class re3 {
          constructor(e5) {
            this.data = e5, this.glbHeaderInts = 3, this.glbChunkHeaderInts = 2, this.glbMagic = 1179937895, this.glbVersion = 2, this.jsonChunkType = 1313821514, this.binaryChunkType = 5130562;
          }
          extractGlbData() {
            if (this.getCheckedGlbInfo() === void 0)
              return;
            let e5, t5 = [];
            const n4 = this.getAllChunkInfos();
            for (let i4 of n4)
              i4.type != this.jsonChunkType || e5 ? i4.type == this.binaryChunkType && t5.push(this.getBufferFromChunk(i4)) : e5 = this.getJsonFromChunk(i4);
            return {json: e5, buffers: t5};
          }
          getCheckedGlbInfo() {
            const e5 = new Uint32Array(this.data, 0, this.glbHeaderInts), t5 = e5[0], n4 = e5[1], i4 = e5[2];
            if (this.checkEquality(t5, this.glbMagic, "glb magic") && this.checkEquality(n4, this.glbVersion, "glb header version") && this.checkEquality(i4, this.data.byteLength, "glb byte length"))
              return {magic: t5, version: n4, length: i4};
          }
          getAllChunkInfos() {
            let e5 = [], t5 = 4 * this.glbHeaderInts;
            for (; t5 < this.data.byteLength; ) {
              const n4 = this.getChunkInfo(t5);
              e5.push(n4), t5 += n4.length + 4 * this.glbChunkHeaderInts;
            }
            return e5;
          }
          getChunkInfo(e5) {
            const t5 = new Uint32Array(this.data, e5, this.glbChunkHeaderInts);
            return {start: e5 + 4 * this.glbChunkHeaderInts, length: t5[0], type: t5[1]};
          }
          getJsonFromChunk(e5) {
            const t5 = e5.length, n4 = 4 * (this.glbHeaderInts + this.glbChunkHeaderInts), i4 = new Uint8Array(this.data, n4, t5), s4 = new TextDecoder("utf-8").decode(i4);
            return JSON.parse(s4);
          }
          getBufferFromChunk(e5) {
            return this.data.slice(e5.start, e5.start + e5.length);
          }
          checkEquality(e5, t5, n4) {
            return e5 == t5 || (console.error("Found invalid/unsupported " + n4 + ", expected: " + t5 + ", but was: " + e5), false);
          }
        }
        class ae3 {
          static async load(e5, t5, n4) {
            const i4 = ae3.getBuffers(n4), s4 = ae3.getAdditionalFiles(n4), r4 = ae3.loadBuffers(e5, i4, s4);
            await r4;
            const a4 = ae3.loadImages(e5, s4);
            return await Promise.all([r4, a4]).then(() => {
              e5.initGl(t5);
            });
          }
          static unload(e5) {
            for (let t5 of e5.images)
              t5.image = void 0;
            e5.images = [];
            for (let t5 of e5.textures)
              t5.destroy();
            e5.textures = [];
            for (let t5 of e5.accessors)
              t5.destroy();
            e5.accessors = [];
          }
          static getBuffers(e5) {
            return ae3.getTypedAppendix(e5, ArrayBuffer);
          }
          static getAdditionalFiles(e5) {
            return typeof File != "undefined" ? ae3.getTypedAppendix(e5, File) : void 0;
          }
          static getTypedAppendix(e5, t5) {
            if (e5 && e5.length > 0 && e5[0] instanceof t5)
              return e5;
          }
          static loadBuffers(e5, t5, n4) {
            const i4 = [];
            if (t5 !== void 0 && t5[0] !== void 0) {
              t5.length > 1 && console.warn("Too many buffer chunks in GLB file. Only one or zero allowed"), e5.buffers[0].buffer = t5[0];
              for (let t6 = 1; t6 < e5.buffers.length; ++t6)
                i4.push(e5.buffers[t6].load(e5, n4));
            } else
              for (const t6 of e5.buffers)
                i4.push(t6.load(e5, n4));
            return Promise.all(i4);
          }
          static loadImages(e5, t5) {
            const n4 = [];
            for (let i4 of e5.images)
              n4.push(i4.load(e5, t5));
            return Promise.all(n4);
          }
        }
        async function oe3(e5) {
          let t5 = "", n4 = 0;
          const i4 = e5;
          let s4;
          for (; !t5.match(/\n\n[^\n]+\n/g); )
            t5 += String.fromCharCode(i4[n4++]);
          if (s4 = t5.match(/FORMAT=(.*)$/m), s4.length < 2)
            return;
          if (s4 = s4[1], s4 != "32-bit_rle_rgbe")
            return console.warn("unknown format : " + s4), this.onerror();
          let r4 = t5.split(/\n/).reverse();
          if (r4.length < 2)
            return;
          if (r4 = r4[1].split(" "), r4.length < 4)
            return;
          const a4 = 1 * r4[3], o4 = 1 * r4[1], l4 = new Uint8Array(a4 * o4 * 4);
          let h4 = 0;
          for (let e6 = 0; e6 < o4; e6++) {
            const e7 = [];
            let t6 = i4.slice(n4, n4 += 4);
            if (t6[0] == 2 && t6[1] == 2 && t6[2] == (a4 >> 8 & 255) && t6[3] == (255 & a4) && a4 >= 8 && a4 < 32768) {
              for (let t7 = 0; t7 < 4; t7++) {
                let s5 = t7 * a4;
                const r5 = (t7 + 1) * a4;
                let o5, l5;
                for (; s5 < r5; )
                  if (o5 = i4.slice(n4, n4 += 2), o5[0] > 128)
                    for (l5 = o5[0] - 128; l5-- > 0; )
                      e7[s5++] = o5[1];
                  else
                    for (l5 = o5[0] - 1, e7[s5++] = o5[1]; l5-- > 0; )
                      e7[s5++] = i4[n4++];
              }
              for (let t7 = 0; t7 < a4; t7++)
                l4[h4++] = e7[t7 + 0 * a4], l4[h4++] = e7[t7 + 1 * a4], l4[h4++] = e7[t7 + 2 * a4], l4[h4++] = e7[t7 + 3 * a4];
            } else {
              n4 -= 4;
              for (let e8 = 0; e8 < a4; e8++)
                t6 = i4.slice(n4, n4 += 4), l4[h4++] = t6[0], l4[h4++] = t6[1], l4[h4++] = t6[2], l4[h4++] = t6[3];
            }
          }
          return {dataFloat: function(e6) {
            const t6 = e6.byteLength >> 2, n5 = new Float32Array(3 * t6);
            for (let i5 = 0; i5 < t6; i5++) {
              const t7 = Math.pow(2, e6[4 * i5 + 3] - 136);
              n5[3 * i5] = e6[4 * i5] * t7, n5[3 * i5 + 1] = e6[4 * i5 + 1] * t7, n5[3 * i5 + 2] = e6[4 * i5 + 2] * t7;
            }
            return n5;
          }(l4), width: a4, height: o4};
        }
        class le3 extends t4.TreeItem {
          constructor(e5) {
            super(e5), this.init();
          }
          init(e5, t5) {
            this.initKtxLib(t5), this.initDracoLib(e5);
          }
          async load(e5, n4) {
            let i4, s4, r4, a4;
            if (await this.init(), n4 || (n4 = e5), t4.resourceLoader.incrementWorkload(1), typeof e5 == "string") {
              i4 = g3(n4);
              let s5 = await t4.resourceLoader.loadFile(i4 ? "binary" : "json", e5);
              r4 = s5, a4 = s5;
            } else
              console.error("Passed invalid type to loadGltf " + typeof gltfFile);
            if (i4) {
              const e6 = new re3(a4).extractGlbData();
              r4 = e6.json, s4 = e6.buffers;
            }
            const o4 = new se3(n4);
            o4.fromJson(r4);
            for (const e6 of o4.images)
              e6.resolveRelativePath(p3(o4.path));
            return t4.resourceLoader.incrementWorkload(o4.nodes.length), await ae3.load(o4, this, s4), t4.resourceLoader.incrementWorkDone(1), o4;
          }
          async loadEnvironment(e5, n4) {
            let i4;
            if (typeof e5 == "string") {
              let n5 = await t4.resourceLoader.loadFile(e5 ? "binary" : "json", url);
              i4 = await oe3(new Uint8Array(n5.data));
            } else if (e5 instanceof ArrayBuffer)
              i4 = await oe3(new Uint8Array(e5));
            else if (typeof File != "undefined" && e5 instanceof File) {
              const t5 = await x3.readAsArrayBuffer(e5).catch(() => {
                console.error("Could not load image with FileReader");
              });
              i4 = await oe3(new Uint8Array(t5));
            } else
              console.error("Passed invalid type to loadEnvironment " + typeof gltfFile);
            if (i4 !== void 0)
              return _loadEnvironmentFromPanorama(i4, this.view, n4);
          }
          initKtxLib(e5) {
          }
          async initDracoLib(e5) {
            const t5 = new L3(e5);
            t5 !== void 0 && await t5.ready();
          }
        }
        t4.Registry.register("GLTFAsset", le3), t4.libsRegistry ? t4.libsRegistry.registerLib(o3) : console.warn("The version of the Zea Engine that you're using doesn't support the libraries registry. Please upgrade to the latest Zea Engine version."), e4.GLTFAsset = le3, Object.defineProperty(e4, "__esModule", {value: true});
      }(t3, He3, er, xl);
    });
    function Cl(e3) {
      let t3, n3, i3;
      return n3 = new Ys({}), {c() {
        t3 = N2("div"), Bt2(n3.$$.fragment), D2(t3, "id", "asmSlider"), D2(t3, "class", "svelte-j5667");
      }, m(e4, s3) {
        I2(e4, t3, s3), Dt(n3, t3, null), i3 = true;
      }, i(e4) {
        i3 || (St(n3.$$.fragment, e4), i3 = true);
      }, o(e4) {
        Lt(n3.$$.fragment, e4), i3 = false;
      }, d(e4) {
        e4 && S2(t3), Ut(n3);
      }};
    }
    function kl(e3) {
      let t3, n3;
      return t3 = new js({props: {fileLoaded: e3[3]}}), t3.$on("changeFile", e3[12]), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p(e4, n4) {
        const i3 = {};
        8 & n4 && (i3.fileLoaded = e4[3]), t3.$set(i3);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Tl(e3) {
      let t3, n3;
      return t3 = new Xs({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Al(e3) {
      let t3, n3;
      return t3 = new Hn({props: {parameterOwner: e3[8]}}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i3) {
        Dt(t3, e4, i3), n3 = true;
      }, p(e4, n4) {
        const i3 = {};
        256 & n4 && (i3.parameterOwner = e4[8]), t3.$set(i3);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function $l(e3) {
      let t3, n3, i3;
      return n3 = new Wi2({props: {progress: e3[2]}}), {c() {
        t3 = N2("div"), Bt2(n3.$$.fragment), D2(t3, "class", "fixed bottom-0 w-full");
      }, m(e4, s3) {
        I2(e4, t3, s3), Dt(n3, t3, null), i3 = true;
      }, p(e4, t4) {
        const i4 = {};
        4 & t4 && (i4.progress = e4[2]), n3.$set(i4);
      }, i(e4) {
        i3 || (St(n3.$$.fragment, e4), i3 = true);
      }, o(e4) {
        Lt(n3.$$.fragment, e4), i3 = false;
      }, d(e4) {
        e4 && S2(t3), Ut(n3);
      }};
    }
    function El(e3) {
      let t3, n3;
      const i3 = [e3[5]];
      let s3 = {$$slots: {default: [Sl]}, $$scope: {ctx: e3}};
      for (let e4 = 0; e4 < i3.length; e4 += 1)
        s3 = n2(s3, i3[e4]);
      return t3 = new dn2({props: s3}), t3.$on("click", e3[10]), t3.$on("clickoutside", e3[10]), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, i4) {
        Dt(t3, e4, i4), n3 = true;
      }, p(e4, n4) {
        const s4 = 32 & n4 ? Ct2(i3, [Mt(e4[5])]) : {};
        1073742016 & n4 && (s4.$$scope = {dirty: n4, ctx: e4}), t3.$set(s4);
      }, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function Sl(e3) {
      let t3, n3, i3, s3;
      return t3 = new pn2({props: {text: "Hide"}}), t3.$on("click", e3[15]), i3 = new pn2({props: {text: "Properties"}}), i3.$on("click", e3[16]), {c() {
        Bt2(t3.$$.fragment), n3 = A2(), Bt2(i3.$$.fragment);
      }, m(e4, r3) {
        Dt(t3, e4, r3), I2(e4, n3, r3), Dt(i3, e4, r3), s3 = true;
      }, p: t2, i(e4) {
        s3 || (St(t3.$$.fragment, e4), St(i3.$$.fragment, e4), s3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), Lt(i3.$$.fragment, e4), s3 = false;
      }, d(e4) {
        Ut(t3, e4), e4 && S2(n3), Ut(i3, e4);
      }};
    }
    function Ml(e3) {
      let t3, n3, i3, a3, l3, h3, c3, d3, g3, v3, b3, _3, y3, I3, P3, A3, $3, E3, S3 = e3[9].asmExplodeEnabled && Cl(), M3 = !e3[3] && kl(e3);
      c3 = new Gi2({}), b3 = new Zi2({props: {$$slots: {default: [Tl]}, $$scope: {ctx: e3}}});
      let R3 = e3[9].shouldShowParameterOwnerWidget && Al(e3), D3 = e3[2] < 100 && $l(e3);
      P3 = new yn2({props: {isOpen: e3[7], close: e3[11], contextItem: e3[6]}});
      let O3 = e3[4] && El(e3);
      return {c() {
        t3 = N2("main"), S3 && S3.c(), n3 = A2(), i3 = N2("canvas"), a3 = A2(), M3 && M3.c(), l3 = A2(), h3 = N2("div"), Bt2(c3.$$.fragment), d3 = A2(), g3 = N2("div"), v3 = A2(), Bt2(b3.$$.fragment), _3 = A2(), R3 && R3.c(), y3 = A2(), D3 && D3.c(), I3 = A2(), Bt2(P3.$$.fragment), A3 = A2(), O3 && O3.c(), $3 = F2(), D2(i3, "class", "absolute w-full h-full svelte-j5667"), D2(h3, "class", "absolute flex justify-center w-full bottom-3"), D2(t3, "class", "relative flex-1 Main");
      }, m(s3, r3) {
        I2(s3, t3, r3), S3 && S3.m(t3, null), E2(t3, n3), E2(t3, i3), e3[13](i3), E2(t3, a3), M3 && M3.m(t3, null), E2(t3, l3), E2(t3, h3), Dt(c3, h3, null), E2(t3, d3), E2(t3, g3), e3[14](g3), E2(t3, v3), Dt(b3, t3, null), E2(t3, _3), R3 && R3.m(t3, null), I2(s3, y3, r3), D3 && D3.m(s3, r3), I2(s3, I3, r3), Dt(P3, s3, r3), I2(s3, A3, r3), O3 && O3.m(s3, r3), I2(s3, $3, r3), E3 = true;
      }, p(e4, [i4]) {
        e4[9].asmExplodeEnabled ? S3 ? 512 & i4 && St(S3, 1) : (S3 = Cl(), S3.c(), St(S3, 1), S3.m(t3, n3)) : S3 && (Ot(), Lt(S3, 1, 1, () => {
          S3 = null;
        }), It2()), e4[3] ? M3 && (Ot(), Lt(M3, 1, 1, () => {
          M3 = null;
        }), It2()) : M3 ? (M3.p(e4, i4), 8 & i4 && St(M3, 1)) : (M3 = kl(e4), M3.c(), St(M3, 1), M3.m(t3, l3));
        const s3 = {};
        1073741824 & i4 && (s3.$$scope = {dirty: i4, ctx: e4}), b3.$set(s3), e4[9].shouldShowParameterOwnerWidget ? R3 ? (R3.p(e4, i4), 512 & i4 && St(R3, 1)) : (R3 = Al(e4), R3.c(), St(R3, 1), R3.m(t3, null)) : R3 && (Ot(), Lt(R3, 1, 1, () => {
          R3 = null;
        }), It2()), e4[2] < 100 ? D3 ? (D3.p(e4, i4), 4 & i4 && St(D3, 1)) : (D3 = $l(e4), D3.c(), St(D3, 1), D3.m(I3.parentNode, I3)) : D3 && (Ot(), Lt(D3, 1, 1, () => {
          D3 = null;
        }), It2());
        const r3 = {};
        128 & i4 && (r3.isOpen = e4[7]), 64 & i4 && (r3.contextItem = e4[6]), P3.$set(r3), e4[4] ? O3 ? (O3.p(e4, i4), 16 & i4 && St(O3, 1)) : (O3 = El(e4), O3.c(), St(O3, 1), O3.m($3.parentNode, $3)) : O3 && (Ot(), Lt(O3, 1, 1, () => {
          O3 = null;
        }), It2());
      }, i(e4) {
        E3 || (St(S3), St(M3), St(c3.$$.fragment, e4), St(b3.$$.fragment, e4), St(R3), St(D3), St(P3.$$.fragment, e4), St(O3), E3 = true);
      }, o(e4) {
        Lt(S3), Lt(M3), Lt(c3.$$.fragment, e4), Lt(b3.$$.fragment, e4), Lt(R3), Lt(D3), Lt(P3.$$.fragment, e4), Lt(O3), E3 = false;
      }, d(n4) {
        n4 && S2(t3), S3 && S3.d(), e3[13](null), M3 && M3.d(), Ut(c3), e3[14](null), Ut(b3), R3 && R3.d(), n4 && S2(y3), D3 && D3.d(n4), n4 && S2(I3), Ut(P3, n4), n4 && S2(A3), O3 && O3.d(n4), n4 && S2($3);
      }};
    }
    function Rl(e3, t3, n3) {
      let i3, s3, r3, a3, o3, l3, h3;
      p2(e3, Ls, (e4) => n3(18, s3 = e4)), p2(e3, ot2, (e4) => n3(9, r3 = e4)), p2(e3, Vs, (e4) => n3(19, a3 = e4)), p2(e3, Yi2, (e4) => n3(20, o3 = e4));
      const c3 = new URLSearchParams(window.location.search), d3 = c3.has("embedded");
      let u3;
      c3.has("roomId");
      let f3, m3 = false;
      const g3 = (e4) => {
        let t4 = e4;
        for (; e4 && !(e4 instanceof GC); )
          e4 = e4.getOwner();
        return e4 || t4;
      }, p3 = (e4, t4) => {
        const i4 = new aC(), r4 = new AC();
        return r4.resources = t4, r4.camera = f3.getViewport().getCamera(), i4.load(e4, r4).then(() => {
          console.log("Loading CAD File version:", i4.cadfileVersion, " exported using SDK:", i4.sdk);
          i4.getMaterialLibrary().getMaterials().forEach((e5) => {
            if (e5.getShaderName() == "LinesShader") {
              e5.getParameter("Opacity").value = 1;
            } else if (e5.getShaderName() == "StandardSurfaceShader") {
              e5.getParameter("EdgeColor").value = f3.outlineColor;
            }
          }), f3.frameAll();
        }), s3.addChild(i4), n3(3, m3 = true), i4;
      }, v3 = (e4, t4) => {
        const i4 = new Pl.GLTFAsset();
        return i4.load(e4, t4).then(() => {
          f3.frameAll();
        }), s3.addChild(i4), n3(3, m3 = true), i4;
      };
      ot(async () => {
        const {isMobileDevice: e4} = g;
        if (f3 = new re(l3, {debugGeomIds: c3.has("debugGeomIds"), enableFrustumCulling: true, enableOcclusionCulling: false, disableMultiDraw: ZeaSystemDesc.OS == "Android"}), _2(Yi2, o3 = new uC(), o3), !e4 && g.gpuDesc.supportsWebGL2) {
          const e5 = new RI("envMap");
          e5.load("data/StudioG.zenv"), e5.headlightModeParam.value = true, _2(Yi2, o3.envMapParam.value = e5, o3);
        }
        f3.outlineThickness = 1.5, f3.outlineSensitivity = 5, f3.highlightOutlineThickness = 1.75, f3.outlineColor = new l(0, 0, 0, 0.6), f3.hiddenLineColor = new l(0.2, 0.2, 0.2, 0), o3.setupGrid(10, 10), f3.getViewport().backgroundColorParam.value = new l(0.85, 0.85, 0.85, 1), f3.setScene(o3);
        const t4 = {};
        t4.renderer = f3, t4.scene = o3, _2(Ls, s3 = new ag("Assets"), s3), t4.assets = s3, o3.getRoot().addChild(s3);
        const m4 = je3.UndoRedoManager.getInstance();
        t4.undoRedoManager = m4;
        const w4 = f3.getViewport().getManipulator();
        w4.setDefaultManipulationMode(SC.MANIPULATION_MODES.tumbler), w4.aimFocusOnTouchTap = 2, w4.aimFocusOnMouseClick = 2, t4.cameraManipulator = w4;
        const _4 = new je3.ToolManager(t4);
        _2(Vs, a3 = new je3.SelectionManager(t4, {enableXfoHandles: true}), a3), a3.showHandles(false), t4.selectionManager = a3;
        const I3 = new je3.SelectionTool(t4);
        I3.setSelectionFilter(g3), _4.registerTool("SelectionTool", I3), _4.registerTool("CameraManipulator", w4), f3.getViewport().setManipulator(_4), _4.pushTool("CameraManipulator"), t4.toolManager = _4, ((e5, t5) => {
          const {renderer: n4} = t5, i4 = new je3.MeasureDistanceTool(t5), s4 = new je3.MeasureRadiusTool(t5), r4 = new je3.MeasureAngleTool(t5), a4 = new je3.MeasureCenterDistancesTool(t5), o4 = n4.getViewport().getManipulator();
          e5.registerTool("cameraManipulator", o4), e5.registerTool("measureDistanceTool", i4), e5.registerTool("measureRadiusTool", s4), e5.registerTool("measureAngleTool", r4), e5.registerTool("measureCenterDistancesTool", a4);
        })(_4, t4);
        const P3 = new l("#F9CE03");
        P3.a = 0.1, a3.selectionGroup.getParameter("HighlightColor").setValue(P3);
        const C4 = new l(0, 0, 0, 1);
        I3.rectItem.getParameter("Material").getValue().getParameter("BaseColor").setValue(C4);
        var k3 = 0;
        const T3 = f3.getViewport().getCamera(), A3 = () => {
          clearTimeout(k3), k3 = 0, T3.getParameter("GlobalXfo").off("valueChanged", A3);
        };
        f3.getViewport().on("pointerDown", (e5) => {
          if (b3 && x3(), e5.pointerType == "touch" && e5.intersectionData) {
            ((e6, t5) => {
              k3 = setTimeout(function() {
                y3(e6, t5), k3 = 0, T3.getParameter("GlobalXfo").off("valueChanged", A3);
              }, 1e3), T3.getParameter("GlobalXfo").on("valueChanged", A3);
            })(e5, g3(e5.intersectionData.geomItem));
          }
        }), f3.getViewport().on("pointerUp", (e5) => {
          if (k3 && A3(), e5.pointerType == "touch" && e5.intersectionData && b3 && e5.stopPropagation(), e5.pointerType == "touch" && e5.touches.length == 0 && e5.changedTouches.length == 1 || e5.pointerType == "mouse" && e5.button == 0) {
            const t5 = _4.toolStack;
            if (t5[t5.length - 1] == I3)
              return;
            if (e5.intersectionData) {
              const t6 = g3(e5.intersectionData.geomItem);
              if (t6)
                if (e5.shiftKey) {
                  const e6 = new Set();
                  e6.add(t6), a3.deselectItems(e6);
                } else
                  a3.toggleItemSelection(t6, !e5.ctrlKey);
            } else
              a3.setSelection(new Set(), true);
          } else if (e5.button == 2 && e5.intersectionData) {
            const t5 = g3(e5.intersectionData.geomItem);
            y3(e5, t5), e5.stopPropagation();
          }
        }), f3.getViewport().on("pointerDoublePressed", (e5) => {
          e5.pointerType == "touch" && e5.touches.length == 2 || e5.intersectionData || f3.frameAll();
        }), FA.on("progressIncremented", (e5) => {
          n3(2, u3 = e5.percent);
        });
        const $3 = document.createElement("fps-display");
        let E3;
        if ($3.renderer = f3, h3.appendChild($3), c3.has("zcad") && (E3 = c3.get("zcad"), p3(E3, E3)), c3.has("gltf") && (E3 = c3.get("gltf"), v3(E3, E3)), d3) {
          const e5 = Zs();
          let t5;
          e5.on("setBackgroundColor", (e6) => {
            const t6 = new l(e6.color);
            o3.getSettings().getParameter("BackgroundColor").setValue(t6);
          }), e5.on("setHighlightColor", (e6) => {
            const t6 = new l(e6.color);
            t6.a = 0.1, a3.selectionGroup.getParameter("HighlightColor").setValue(t6), a3.selectionGroup.getParameter("SubtreeHighlightColor").setValue(t6);
          }), e5.on("setRenderMode", (e6) => {
            Pi2(yi2[e6.mode]);
          }), e5.on("setCameraManipulationMode", (e6) => {
            const t6 = e6.mode.toLowerCase();
            w4.setDefaultManipulationMode(SC.MANIPULATION_MODES[t6]);
          }), e5.on("loadCADFile", (n5) => {
            console.log("loadCADFile", n5), n5.addToCurrentScene || s3.removeAllChildren();
            const i5 = p3(n5.url, n5.resources);
            if (!n5.convertZtoY) {
              const e6 = i5.getParameter("LocalXfo").getValue();
              e6.ori.setFromAxisAndAngle(new o(1, 0, 0), 0.5 * Math.PI), i5.getParameter("LocalXfo").setValue(e6);
            }
            i5.once("loaded", () => {
              if (console.log("loadCADFile", n5._id), n5._id) {
                const t6 = Js(i5);
                e5.send(n5._id, {modelStructure: t6});
              }
            }), t5 = i5;
          }), e5.on("getModelStructure", (t6) => {
            if (t6._id) {
              const n5 = Js(s3);
              e5.send(t6._id, {modelStructure: n5});
            }
          });
          let n4 = false;
          e5.on("selectItems", (e6) => {
            n4 = true;
            const i5 = [];
            e6.paths.forEach((e7) => {
              const n5 = t5.resolvePath(e7);
              n5 && i5.push(n5);
            }), a3.selectItems(i5, false), n4 = false;
          }), e5.on("deselectItems", (e6) => {
            n4 = true, console.log("deselectItems", e6.paths);
            const i5 = [];
            e6.paths.forEach((e7) => {
              const n5 = t5.resolvePath(e7);
              n5 && i5.push(n5);
            }), a3.deselectItems(i5), n4 = false;
          }), e5.on("unloadCADFile", (t6) => {
            console.log("unloadCADFile", t6), s3.removeChildByName(t6.name), t6._id && e5.send(t6._id, {done: true});
          });
          const i4 = (e6) => {
            for (; e6 && !(e6 instanceof nC); )
              e6 = e6.getOwner();
            return e6;
          };
          a3.on("selectionChanged", (t6) => {
            if (n4)
              return;
            const {selection: s4, prevSelection: r4} = t6, a4 = [];
            s4.forEach((e6) => {
              if (!r4.has(e6)) {
                const t7 = i4(e6);
                if (t7) {
                  const e7 = t7.getPath().slice(2);
                  a4.push(e7);
                }
              }
            });
            const o4 = [];
            r4.forEach((e6) => {
              if (!s4.has(e6)) {
                const t7 = i4(e6);
                if (t7) {
                  const e7 = t7.getPath().slice(2);
                  o4.push(e7);
                }
              }
            }), console.log(a4, o4), e5.send("selectionChanged", {selection: a4, deselection: o4});
          });
        }
        a3.on("leadSelectionChanged", (e5) => {
          n3(8, i3 = e5.treeItem), _2(ot2, r3.shouldShowParameterOwnerWidget = i3, r3);
        }), Xt2.set(t4);
      });
      let w3, b3 = false, _3 = {x: 0, y: 0};
      const y3 = (e4, t4) => {
        n3(6, w3 = t4), n3(5, _3 = e4.touches ? {x: e4.touches[0].clientX, y: e4.touches[0].clientY} : {x: e4.clientX, y: e4.clientY}), n3(4, b3 = true);
      }, x3 = () => {
        console.log("closeMenu:"), n3(4, b3 = false);
      };
      let C3 = false;
      return n3(8, i3 = null), [l3, h3, u3, m3, b3, _3, w3, C3, i3, r3, x3, () => {
        n3(7, C3 = false);
      }, (e4) => {
        const {files: t4} = e4.detail;
        s3.removeAllChildren();
        const n4 = {};
        t4.forEach((e5) => {
          const t5 = e5.name, i4 = URL.createObjectURL(e5);
          n4[t5] = i4;
        }), t4.forEach((e5) => {
          if (e5.name.endsWith(".zcad")) {
            const t5 = e5.name, i4 = ((e6, t6) => t6.endsWith("zcad") ? p3(e6) : t6.endsWith("gltf") || t6.endsWith("glb") ? v3(e6, t6) : void 0)(n4[t5], t5), s4 = t5.slice(0, t5.length - 5) + ".zmetadata";
            s4 in n4 && i4.geomLibrary.once("loaded", () => {
              i4.loadMetadata(n4[s4]);
            });
          }
        });
      }, function(e4) {
        ft[e4 ? "unshift" : "push"](() => {
          l3 = e4, n3(0, l3);
        });
      }, function(e4) {
        ft[e4 ? "unshift" : "push"](() => {
          h3 = e4, n3(1, h3);
        });
      }, () => {
        w3.getParameter("Visible").setValue(false);
      }, () => {
        w3 && (n3(7, C3 = true), x3());
      }];
    }
    var Dl = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, Rl, Ml, a2, {});
      }
    };
    function Ol(e3) {
      let t3, n3, i3, a3, l3;
      return n3 = new an2({}), a3 = new Dl({}), {c() {
        t3 = N2("div"), Bt2(n3.$$.fragment), i3 = A2(), Bt2(a3.$$.fragment), D2(t3, "class", "flex flex-col h-full");
      }, m(e4, s3) {
        I2(e4, t3, s3), Dt(n3, t3, null), E2(t3, i3), Dt(a3, t3, null), l3 = true;
      }, p: t2, i(e4) {
        l3 || (St(n3.$$.fragment, e4), St(a3.$$.fragment, e4), l3 = true);
      }, o(e4) {
        Lt(n3.$$.fragment, e4), Lt(a3.$$.fragment, e4), l3 = false;
      }, d(e4) {
        e4 && S2(t3), Ut(n3), Ut(a3);
      }};
    }
    var Nl = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, null, Ol, a2, {});
      }
    };
  });

  // dist/build/layout-33693570.js
  var require_layout_33693570 = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => V3
    });
    function L3(e3) {
      let t3, s3;
      const f3 = e3[3].default, m3 = d2(f3, e3, e3[2], null);
      return {c() {
        t3 = N2("div"), m3 && m3.c(), D2(t3, "class", "SplitPane flex h-full " + e3[0] + " svelte-naesig");
      }, m(e4, n3) {
        I2(e4, t3, n3), m3 && m3.m(t3, null), s3 = true;
      }, p(e4, [t4]) {
        m3 && m3.p && (!s3 || 4 & t4) && g2(m3, f3, e4, e4[2], s3 ? m2(f3, e4[2], t4, null) : $2(e4[2]), null);
      }, i(e4) {
        s3 || (St(m3, e4), s3 = true);
      }, o(e4) {
        Lt(m3, e4), s3 = false;
      }, d(e4) {
        e4 && S2(t3), m3 && m3.d(e4);
      }};
    }
    function E3(e3, t3, s3) {
      let {$$slots: n3 = {}, $$scope: l3} = t3, {split: i3 = "vertical"} = t3;
      const c3 = i3 == "vertical", o3 = !c3;
      at("__IS_VERTICAL__", c3);
      const a3 = o3 && "flex-col";
      return e3.$$set = (e4) => {
        "split" in e4 && s3(1, i3 = e4.split), "$$scope" in e4 && s3(2, l3 = e4.$$scope);
      }, [a3, i3, l3, n3];
    }
    var P3 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, E3, L3, a2, {split: 1});
      }
    };
    function R3(e3) {
      let t3, s3, n3;
      return {c() {
        t3 = N2("span"), s3 = T2("drag_handle"), D2(t3, "class", n3 = "material-icons " + e3[5]);
      }, m(e4, n4) {
        I2(e4, t3, n4), E2(t3, s3);
      }, p: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    function A3(e3) {
      let t3, s3, f3, m3, h3, v3, y3;
      const z3 = e3[11].default, S3 = d2(z3, e3, e3[10], null);
      let _3 = !e3[0] && R3(e3);
      return {c() {
        t3 = N2("div"), s3 = N2("div"), S3 && S3.c(), f3 = A2(), m3 = N2("div"), _3 && _3.c(), D2(s3, "class", "PaneContent flex-1"), D2(m3, "class", "PaneHandle bg-gray-300 flex items-center justify-center text-gray-400 " + (e3[2] ? "w-2" : "h-2")), W2(m3, "cursor", e3[3]), D2(t3, "class", "Pane flex flex-1 " + e3[4]);
      }, m(n3, l3) {
        I2(n3, t3, l3), E2(t3, s3), S3 && S3.m(s3, null), E2(t3, f3), E2(t3, m3), _3 && _3.m(m3, null), e3[12](t3), h3 = true, v3 || (y3 = C2(m3, "mousedown", e3[6]), v3 = true);
      }, p(e4, [t4]) {
        S3 && S3.p && (!h3 || 1024 & t4) && g2(S3, z3, e4, e4[10], h3 ? m2(z3, e4[10], t4, null) : $2(e4[10]), null), e4[0] ? _3 && (_3.d(1), _3 = null) : _3 ? _3.p(e4, t4) : (_3 = R3(e4), _3.c(), _3.m(m3, null));
      }, i(e4) {
        h3 || (St(S3, e4), h3 = true);
      }, o(e4) {
        Lt(S3, e4), h3 = false;
      }, d(s4) {
        s4 && S2(t3), S3 && S3.d(s4), _3 && _3.d(), e3[12](null), v3 = false, y3();
      }};
    }
    function C3(e3, t3, s3) {
      let {$$slots: n3 = {}, $$scope: l3} = t3, {disableResize: i3 = null} = t3, {maxSize: c3 = 1 / 0} = t3, {minSize: o3 = 0} = t3, {size: a3 = null} = t3;
      const r3 = ct("__IS_VERTICAL__"), $3 = i3 ? null : (r3 ? "col" : "row") + "-resize", u3 = !r3 && "flex-col", d3 = r3 && "transform rotate-90";
      let f3, m3, p3, h3, x3;
      const g3 = (e4) => e4 >= o3 && e4 <= c3, w3 = (e4) => {
        if (r3) {
          const t4 = f3.clientX - e4.clientX, n4 = m3.width - t4;
          if (!g3(n4))
            return;
          const l4 = p3.width + t4;
          s3(1, h3.style.width = `${n4}px`, h3), x3.style.width = `${l4}px`;
        } else {
          const t4 = f3.clientY - e4.clientY, n4 = m3.height - t4;
          if (!g3(n4))
            return;
          const l4 = p3.height + t4;
          s3(1, h3.style.height = `${n4}px`, h3), x3.style.height = `${l4}px`;
        }
      }, S3 = (e4) => {
        window.getSelection().removeAllRanges(), w3(e4);
      }, _3 = () => {
        document.body.style.cursor = null, window.removeEventListener("mousemove", S3);
      };
      return ot(() => {
        if (a3) {
          h3.classList.remove("flex-1");
          const e4 = r3 ? "width" : "height";
          s3(1, h3.style[e4] = `${a3}px`, h3);
        }
      }), e3.$$set = (e4) => {
        "disableResize" in e4 && s3(0, i3 = e4.disableResize), "maxSize" in e4 && s3(7, c3 = e4.maxSize), "minSize" in e4 && s3(8, o3 = e4.minSize), "size" in e4 && s3(9, a3 = e4.size), "$$scope" in e4 && s3(10, l3 = e4.$$scope);
      }, [i3, h3, r3, $3, u3, d3, (e4) => {
        if (i3)
          return;
        const t4 = Array.from(h3.parentElement.children);
        x3 = h3.nextElementSibling, t4.filter((e5) => e5 !== h3 && e5 !== x3), f3 = {clientX: e4.clientX, clientY: e4.clientY}, m3 = {height: h3.offsetHeight, width: h3.offsetWidth}, p3 = {height: x3.offsetHeight, width: x3.offsetWidth}, h3.classList.remove("flex-1"), x3.classList.remove("flex-1"), w3(e4), document.body.style.cursor = $3, window.addEventListener("mousemove", S3), window.addEventListener("mouseup", _3);
      }, c3, o3, a3, l3, n3, function(e4) {
        ft[e4 ? "unshift" : "push"](() => {
          h3 = e4, s3(1, h3);
        });
      }];
    }
    var I3 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, C3, A3, a2, {disableResize: 0, maxSize: 7, minSize: 8, size: 9});
      }
    };
    function X3(e3) {
      let t3;
      return {c() {
        t3 = T2("Pane");
      }, m(e4, s3) {
        I2(e4, t3, s3);
      }, d(e4) {
        e4 && S2(t3);
      }};
    }
    function Y3(e3) {
      let t3;
      return {c() {
        t3 = T2("Pane");
      }, m(e4, s3) {
        I2(e4, t3, s3);
      }, d(e4) {
        e4 && S2(t3);
      }};
    }
    function H3(e3) {
      let t3;
      return {c() {
        t3 = T2("Pane");
      }, m(e4, s3) {
        I2(e4, t3, s3);
      }, d(e4) {
        e4 && S2(t3);
      }};
    }
    function j3(e3) {
      let t3, s3, n3, l3, i3, o3;
      return t3 = new I3({props: {$$slots: {default: [X3]}, $$scope: {ctx: e3}}}), n3 = new I3({props: {$$slots: {default: [Y3]}, $$scope: {ctx: e3}}}), i3 = new I3({props: {$$slots: {default: [H3]}, $$scope: {ctx: e3}}}), {c() {
        Bt2(t3.$$.fragment), s3 = A2(), Bt2(n3.$$.fragment), l3 = A2(), Bt2(i3.$$.fragment);
      }, m(e4, a3) {
        Dt(t3, e4, a3), I2(e4, s3, a3), Dt(n3, e4, a3), I2(e4, l3, a3), Dt(i3, e4, a3), o3 = true;
      }, p(e4, s4) {
        const l4 = {};
        1 & s4 && (l4.$$scope = {dirty: s4, ctx: e4}), t3.$set(l4);
        const c3 = {};
        1 & s4 && (c3.$$scope = {dirty: s4, ctx: e4}), n3.$set(c3);
        const o4 = {};
        1 & s4 && (o4.$$scope = {dirty: s4, ctx: e4}), i3.$set(o4);
      }, i(e4) {
        o3 || (St(t3.$$.fragment, e4), St(n3.$$.fragment, e4), St(i3.$$.fragment, e4), o3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), Lt(n3.$$.fragment, e4), Lt(i3.$$.fragment, e4), o3 = false;
      }, d(e4) {
        Ut(t3, e4), e4 && S2(s3), Ut(n3, e4), e4 && S2(l3), Ut(i3, e4);
      }};
    }
    function T3(e3) {
      let t3, s3, n3;
      return s3 = new P3({props: {$$slots: {default: [j3]}, $$scope: {ctx: e3}}}), {c() {
        t3 = N2("div"), Bt2(s3.$$.fragment), D2(t3, "class", "h-full bg-gray-200");
      }, m(e4, l3) {
        I2(e4, t3, l3), Dt(s3, t3, null), n3 = true;
      }, p(e4, [t4]) {
        const n4 = {};
        1 & t4 && (n4.$$scope = {dirty: t4, ctx: e4}), s3.$set(n4);
      }, i(e4) {
        n3 || (St(s3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(s3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        e4 && S2(t3), Ut(s3);
      }};
    }
    var V3 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, null, T3, a2, {});
      }
    };
  });

  // dist/build/index-849ba556.js
  var require_index_849ba556 = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => N3
    });
    var S3 = new class {
      async isAuthenticated() {
        return true;
      }
      async getUserData() {
        const {zeaUserData: e3} = window.localStorage;
        return e3 && JSON.parse(e3);
      }
      async setUserData(e3) {
        window.localStorage.zeaUserData = JSON.stringify(e3);
      }
      async signOut() {
        localStorage.removeItem("zeaUserData");
      }
    }();
    var z3 = (e3 = 3) => Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, e3);
    function j3(e3) {
      let t3, a3, p3, h3, w3, y3, x3, b3, v3, I3, U3, S4, z4, j4, k4, C4, N4, R3, O3, T3, A3, L3, P3, $3, q3, H3 = function(e4) {
        let t4, a4, r3, u3, m3, p4;
        return {c() {
          t4 = N2("div"), a4 = N2("p"), a4.textContent = "The roomId allows other users to join you in a collaborative session.", r3 = A2(), u3 = N2("input"), D2(a4, "class", "mt-6 text-center"), D2(u3, "autocomplete", "off"), D2(u3, "class", "appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-yellow-500 focus:border-yellow-500 focus:z-10 sm:text-sm"), D2(u3, "name", "roomId"), D2(u3, "placeholder", "Room ID (optional)"), D2(u3, "type", "text"), D2(t4, "class", "mb-2");
        }, m(s3, o3) {
          I2(s3, t4, o3), E2(t4, a4), E2(t4, r3), E2(t4, u3), z2(u3, e4[4].roomId), m3 || (p4 = C2(u3, "input", e4[9]), m3 = true);
        }, p(e5, t5) {
          16 & t5 && u3.value !== e5[4].roomId && z2(u3, e5[4].roomId);
        }, d(e5) {
          e5 && S2(t4), m3 = false, p4();
        }};
      }(e3), J3 = e3[0] && D3(e3);
      return {c() {
        t3 = N2("div"), a3 = N2("div"), p3 = N2("h2"), p3.textContent = "Zea Svelte Template", h3 = A2(), w3 = N2("p"), w3.textContent = "This is an MIT open sourced template application that can be used to build your own custom applications.", y3 = A2(), x3 = N2("form"), b3 = N2("div"), v3 = N2("p"), v3.textContent = "Enter a username and the password to start the app.", I3 = A2(), U3 = N2("p"), U3.textContent = "Note: the defualt password is 'zea' and can be modified in 'auth.js' or you can integrate an authentication\r\n            service like Auth0.", S4 = A2(), z4 = N2("div"), j4 = N2("input"), k4 = A2(), C4 = N2("div"), N4 = N2("input"), R3 = A2(), H3 && H3.c(), O3 = A2(), J3 && J3.c(), T3 = A2(), A3 = N2("div"), L3 = N2("button"), P3 = T2("Login"), D2(p3, "class", "mt-6 text-center text-3xl font-extrabold"), D2(w3, "class", "mt-6 text-center"), D2(v3, "class", "mt-6 text-center"), D2(U3, "class", "text-center"), D2(j4, "autocomplete", "off"), D2(j4, "class", "appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-yellow-500 focus:border-yellow-500 focus:z-10 sm:text-sm"), D2(j4, "name", "username"), D2(j4, "placeholder", "Username"), j4.required = true, D2(j4, "type", "text"), D2(z4, "class", "mb-2"), D2(N4, "autocomplete", "off"), D2(N4, "class", "appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-yellow-500 focus:border-yellow-500 focus:z-10 sm:text-sm"), D2(N4, "name", "password"), D2(N4, "placeholder", "Password (zea)"), N4.required = true, D2(N4, "type", "password"), D2(C4, "class", "mb-2"), D2(b3, "class", "rounded-md shadow-sm"), L3.disabled = e3[2], D2(L3, "type", "submit"), D2(L3, "class", "group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-gray-800 bg-primary hover:bg-primary-light focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-yellow-500"), D2(x3, "class", "mt-8 space-y-6"), D2(a3, "class", "max-w-md w-full space-y-8"), D2(t3, "class", "bg-background min-h-full flex items-center justify-center py-12 px-4 text-foreground sm:px-6 lg:px-8");
      }, m(s3, o3) {
        I2(s3, t3, o3), E2(t3, a3), E2(a3, p3), E2(a3, h3), E2(a3, w3), E2(a3, y3), E2(a3, x3), E2(x3, b3), E2(b3, v3), E2(b3, I3), E2(b3, U3), E2(b3, S4), E2(b3, z4), E2(z4, j4), e3[6](j4), z2(j4, e3[4].username), E2(b3, k4), E2(b3, C4), E2(C4, N4), z2(N4, e3[4].password), E2(b3, R3), H3 && H3.m(b3, null), E2(x3, O3), J3 && J3.m(x3, null), E2(x3, T3), E2(x3, A3), E2(A3, L3), E2(L3, P3), $3 || (q3 = [C2(j4, "input", e3[7]), C2(N4, "input", e3[8]), C2(x3, "submit", q2(M2(e3[5])))], $3 = true);
      }, p(e4, t4) {
        16 & t4 && j4.value !== e4[4].username && z2(j4, e4[4].username), 16 & t4 && N4.value !== e4[4].password && z2(N4, e4[4].password), H3.p(e4, t4), e4[0] ? J3 ? J3.p(e4, t4) : (J3 = D3(e4), J3.c(), J3.m(x3, T3)) : J3 && (J3.d(1), J3 = null), 4 & t4 && (L3.disabled = e4[2]);
      }, d(a4) {
        a4 && S2(t3), e3[6](null), H3 && H3.d(), J3 && J3.d(), $3 = false, s2(q3);
      }};
    }
    function D3(e3) {
      let t3, a3, o3 = e3[0].message + "";
      return {c() {
        t3 = N2("span"), a3 = T2(o3), D2(t3, "class", "font-medium tracking-wide text-red-500 text-xs");
      }, m(e4, s3) {
        I2(e4, t3, s3), E2(t3, a3);
      }, p(e4, t4) {
        1 & t4 && o3 !== (o3 = e4[0].message + "") && K2(a3, o3);
      }, d(e4) {
        e4 && S2(t3);
      }};
    }
    function k3(e3) {
      let t3, a3 = e3[1] && j3(e3);
      return {c() {
        a3 && a3.c(), t3 = F2();
      }, m(e4, s3) {
        a3 && a3.m(e4, s3), I2(e4, t3, s3);
      }, p(e4, [s3]) {
        e4[1] ? a3 ? a3.p(e4, s3) : (a3 = j3(e4), a3.c(), a3.m(t3.parentNode, t3)) : a3 && (a3.d(1), a3 = null);
      }, i: t2, o: t2, d(e4) {
        a3 && a3.d(e4), e4 && S2(t3);
      }};
    }
    function C3(e3, t3, a3) {
      let s3;
      p2(e3, je2, (e4) => a3(10, s3 = e4));
      const o3 = new URLSearchParams(window.location.search);
      let r3, n3, l3, c3;
      o3.has("embedded");
      const i3 = {password: "", username: "", roomId: o3.has("roomId") ? o3.get("roomId") : `${z3(3)}-${z3(3)}-${z3(3)}`}, d3 = z3();
      return ot(async () => {
        if (await S3.isAuthenticated() && o3.get("roomId"))
          return void (() => {
            const e5 = new URLSearchParams(window.location.search);
            s3("/?" + e5.toString());
          })();
        a3(1, n3 = true);
        const e4 = await S3.getUserData();
        e4 && a3(3, c3.value = e4.firstName, c3), await $t(), c3.focus();
      }), [r3, n3, l3, c3, i3, async () => {
        const e4 = {color: l.random().toHex(), firstName: i3.username, id: d3, lastName: "", password: i3.password, username: i3.username};
        try {
          await S3.setUserData(e4), a3(2, l3 = true), ((e5, t4) => {
            e5 = encodeURIComponent(e5), t4 = encodeURIComponent(t4);
            var a4 = document.location.search.substr(1).split("&");
            let o4 = 0;
            for (; o4 < a4.length; o4++)
              if (a4[o4].startsWith(e5)) {
                const e6 = a4[o4].split("=");
                e6[1] = t4, a4[o4] = e6.join("=");
                break;
              }
            o4 >= a4.length && (a4[a4.length] = [e5, t4].join("="));
            const r4 = a4.length > 1 ? a4.join("&") : a4[0];
            s3("/?" + r4);
          })("roomId", i3.roomId);
        } catch (e5) {
          a3(0, r3 = e5);
        }
      }, function(e4) {
        ft[e4 ? "unshift" : "push"](() => {
          c3 = e4, a3(3, c3);
        });
      }, function() {
        i3.username = this.value, a3(4, i3);
      }, function() {
        i3.password = this.value, a3(4, i3);
      }, function() {
        i3.roomId = this.value, a3(4, i3);
      }];
    }
    var N3 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, C3, k3, a2, {});
      }
    };
  });

  // dist/build/index-913c809f.js
  var require_index_913c809f = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => bc
    });
    function v3(e3) {
      let t3;
      return {c() {
        t3 = N2("div"), t3.innerHTML = '<img class="w-40" alt="Zea Inc." src="/images/logo-zea.svg" title="Zea Inc."/>', D2(t3, "class", "animate-pulse flex flex-col gap-2 h-full items-center justify-center");
      }, m(e4, n3) {
        I2(e4, t3, n3);
      }, p: t2, i: t2, o: t2, d(e4) {
        e4 && S2(t3);
      }};
    }
    var b3 = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, null, v3, a2, {});
      }
    };
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
    
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
    
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    var g3 = function(e3, t3) {
      return (g3 = Object.setPrototypeOf || {__proto__: []} instanceof Array && function(e4, t4) {
        e4.__proto__ = t4;
      } || function(e4, t4) {
        for (var n3 in t4)
          Object.prototype.hasOwnProperty.call(t4, n3) && (e4[n3] = t4[n3]);
      })(e3, t3);
    };
    function w3(e3, t3) {
      if (typeof t3 != "function" && t3 !== null)
        throw new TypeError("Class extends value " + String(t3) + " is not a constructor or null");
      function n3() {
        this.constructor = e3;
      }
      g3(e3, t3), e3.prototype = t3 === null ? Object.create(t3) : (n3.prototype = t3.prototype, new n3());
    }
    var S3 = function() {
      return (S3 = Object.assign || function(e3) {
        for (var t3, n3 = 1, r3 = arguments.length; n3 < r3; n3++)
          for (var o3 in t3 = arguments[n3])
            Object.prototype.hasOwnProperty.call(t3, o3) && (e3[o3] = t3[o3]);
        return e3;
      }).apply(this, arguments);
    };
    function I3(e3, t3) {
      var n3 = {};
      for (var r3 in e3)
        Object.prototype.hasOwnProperty.call(e3, r3) && t3.indexOf(r3) < 0 && (n3[r3] = e3[r3]);
      if (e3 != null && typeof Object.getOwnPropertySymbols == "function") {
        var o3 = 0;
        for (r3 = Object.getOwnPropertySymbols(e3); o3 < r3.length; o3++)
          t3.indexOf(r3[o3]) < 0 && Object.prototype.propertyIsEnumerable.call(e3, r3[o3]) && (n3[r3[o3]] = e3[r3[o3]]);
      }
      return n3;
    }
    function k3(e3, t3, n3, r3) {
      return new (n3 || (n3 = Promise))(function(o3, i3) {
        function a3(e4) {
          try {
            s3(r3.next(e4));
          } catch (e5) {
            i3(e5);
          }
        }
        function c3(e4) {
          try {
            s3(r3.throw(e4));
          } catch (e5) {
            i3(e5);
          }
        }
        function s3(e4) {
          var t4;
          e4.done ? o3(e4.value) : (t4 = e4.value, t4 instanceof n3 ? t4 : new n3(function(e5) {
            e5(t4);
          })).then(a3, c3);
        }
        s3((r3 = r3.apply(e3, t3 || [])).next());
      });
    }
    function T3(e3, t3) {
      var n3, r3, o3, i3, a3 = {label: 0, sent: function() {
        if (1 & o3[0])
          throw o3[1];
        return o3[1];
      }, trys: [], ops: []};
      return i3 = {next: c3(0), throw: c3(1), return: c3(2)}, typeof Symbol == "function" && (i3[Symbol.iterator] = function() {
        return this;
      }), i3;
      function c3(i4) {
        return function(c4) {
          return function(i5) {
            if (n3)
              throw new TypeError("Generator is already executing.");
            for (; a3; )
              try {
                if (n3 = 1, r3 && (o3 = 2 & i5[0] ? r3.return : i5[0] ? r3.throw || ((o3 = r3.return) && o3.call(r3), 0) : r3.next) && !(o3 = o3.call(r3, i5[1])).done)
                  return o3;
                switch (r3 = 0, o3 && (i5 = [2 & i5[0], o3.value]), i5[0]) {
                  case 0:
                  case 1:
                    o3 = i5;
                    break;
                  case 4:
                    return a3.label++, {value: i5[1], done: false};
                  case 5:
                    a3.label++, r3 = i5[1], i5 = [0];
                    continue;
                  case 7:
                    i5 = a3.ops.pop(), a3.trys.pop();
                    continue;
                  default:
                    if (!((o3 = (o3 = a3.trys).length > 0 && o3[o3.length - 1]) || i5[0] !== 6 && i5[0] !== 2)) {
                      a3 = 0;
                      continue;
                    }
                    if (i5[0] === 3 && (!o3 || i5[1] > o3[0] && i5[1] < o3[3])) {
                      a3.label = i5[1];
                      break;
                    }
                    if (i5[0] === 6 && a3.label < o3[1]) {
                      a3.label = o3[1], o3 = i5;
                      break;
                    }
                    if (o3 && a3.label < o3[2]) {
                      a3.label = o3[2], a3.ops.push(i5);
                      break;
                    }
                    o3[2] && a3.ops.pop(), a3.trys.pop();
                    continue;
                }
                i5 = t3.call(e3, a3);
              } catch (e4) {
                i5 = [6, e4], r3 = 0;
              } finally {
                n3 = o3 = 0;
              }
            if (5 & i5[0])
              throw i5[1];
            return {value: i5[0] ? i5[1] : void 0, done: true};
          }([i4, c4]);
        };
      }
    }
    function _3(e3, t3) {
      var n3 = typeof Symbol == "function" && e3[Symbol.iterator];
      if (!n3)
        return e3;
      var r3, o3, i3 = n3.call(e3), a3 = [];
      try {
        for (; (t3 === void 0 || t3-- > 0) && !(r3 = i3.next()).done; )
          a3.push(r3.value);
      } catch (e4) {
        o3 = {error: e4};
      } finally {
        try {
          r3 && !r3.done && (n3 = i3.return) && n3.call(i3);
        } finally {
          if (o3)
            throw o3.error;
        }
      }
      return a3;
    }
    function K3(e3, t3, n3) {
      if (n3 || arguments.length === 2)
        for (var r3, o3 = 0, i3 = t3.length; o3 < i3; o3++)
          !r3 && o3 in t3 || (r3 || (r3 = Array.prototype.slice.call(t3, 0, o3)), r3[o3] = t3[o3]);
      return e3.concat(r3 || Array.prototype.slice.call(t3));
    }
    var Z3 = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
    function R3(e3) {
      return e3 && e3.__esModule && Object.prototype.hasOwnProperty.call(e3, "default") ? e3.default : e3;
    }
    function E3(e3, t3) {
      return e3(t3 = {exports: {}}, t3.exports), t3.exports;
    }
    var O3;
    var F3;
    var x3 = function(e3) {
      return e3 && e3.Math == Math && e3;
    };
    var C3 = x3(typeof globalThis == "object" && globalThis) || x3(typeof window == "object" && window) || x3(typeof self == "object" && self) || x3(typeof Z3 == "object" && Z3) || function() {
      return this;
    }() || Function("return this")();
    var V3 = function(e3) {
      try {
        return !!e3();
      } catch (e4) {
        return true;
      }
    };
    var W3 = !V3(function() {
      return Object.defineProperty({}, 1, {get: function() {
        return 7;
      }})[1] != 7;
    });
    var U3 = Function.prototype.call;
    var X3 = U3.bind ? U3.bind(U3) : function() {
      return U3.apply(U3, arguments);
    };
    var L3 = {}.propertyIsEnumerable;
    var Y3 = Object.getOwnPropertyDescriptor;
    var j3 = {f: Y3 && !L3.call({1: 2}, 1) ? function(e3) {
      var t3 = Y3(this, e3);
      return !!t3 && t3.enumerable;
    } : L3};
    var J3 = function(e3, t3) {
      return {enumerable: !(1 & e3), configurable: !(2 & e3), writable: !(4 & e3), value: t3};
    };
    var N3 = Function.prototype;
    var P3 = N3.bind;
    var G3 = N3.call;
    var A3 = P3 && P3.bind(G3);
    var B3 = P3 ? function(e3) {
      return e3 && A3(G3, e3);
    } : function(e3) {
      return e3 && function() {
        return G3.apply(e3, arguments);
      };
    };
    var z3 = B3({}.toString);
    var H3 = B3("".slice);
    var D3 = function(e3) {
      return H3(z3(e3), 8, -1);
    };
    var M3 = C3.Object;
    var q3 = B3("".split);
    var Q3 = V3(function() {
      return !M3("z").propertyIsEnumerable(0);
    }) ? function(e3) {
      return D3(e3) == "String" ? q3(e3, "") : M3(e3);
    } : M3;
    var $3 = C3.TypeError;
    var ee3 = function(e3) {
      if (e3 == null)
        throw $3("Can't call method on " + e3);
      return e3;
    };
    var te3 = function(e3) {
      return Q3(ee3(e3));
    };
    var ne3 = function(e3) {
      return typeof e3 == "function";
    };
    var re3 = function(e3) {
      return typeof e3 == "object" ? e3 !== null : ne3(e3);
    };
    var oe3 = function(e3) {
      return ne3(e3) ? e3 : void 0;
    };
    var ie3 = function(e3, t3) {
      return arguments.length < 2 ? oe3(C3[e3]) : C3[e3] && C3[e3][t3];
    };
    var ae3 = B3({}.isPrototypeOf);
    var ce3 = ie3("navigator", "userAgent") || "";
    var se3 = C3.process;
    var ue3 = C3.Deno;
    var le3 = se3 && se3.versions || ue3 && ue3.version;
    var fe3 = le3 && le3.v8;
    fe3 && (F3 = (O3 = fe3.split("."))[0] > 0 && O3[0] < 4 ? 1 : +(O3[0] + O3[1])), !F3 && ce3 && (!(O3 = ce3.match(/Edge\/(\d+)/)) || O3[1] >= 74) && (O3 = ce3.match(/Chrome\/(\d+)/)) && (F3 = +O3[1]);
    var de3 = F3;
    var he3 = !!Object.getOwnPropertySymbols && !V3(function() {
      var e3 = Symbol();
      return !String(e3) || !(Object(e3) instanceof Symbol) || !Symbol.sham && de3 && de3 < 41;
    });
    var pe3 = he3 && !Symbol.sham && typeof Symbol.iterator == "symbol";
    var ye3 = C3.Object;
    var me3 = pe3 ? function(e3) {
      return typeof e3 == "symbol";
    } : function(e3) {
      var t3 = ie3("Symbol");
      return ne3(t3) && ae3(t3.prototype, ye3(e3));
    };
    var ve3 = C3.String;
    var be3 = function(e3) {
      try {
        return ve3(e3);
      } catch (e4) {
        return "Object";
      }
    };
    var ge3 = C3.TypeError;
    var we3 = function(e3) {
      if (ne3(e3))
        return e3;
      throw ge3(be3(e3) + " is not a function");
    };
    var Se3 = function(e3, t3) {
      var n3 = e3[t3];
      return n3 == null ? void 0 : we3(n3);
    };
    var Ie3 = C3.TypeError;
    var ke3 = Object.defineProperty;
    var Te3 = function(e3, t3) {
      try {
        ke3(C3, e3, {value: t3, configurable: true, writable: true});
      } catch (n3) {
        C3[e3] = t3;
      }
      return t3;
    };
    var _e3 = C3["__core-js_shared__"] || Te3("__core-js_shared__", {});
    var Ke3 = E3(function(e3) {
      (e3.exports = function(e4, t3) {
        return _e3[e4] || (_e3[e4] = t3 !== void 0 ? t3 : {});
      })("versions", []).push({version: "3.19.1", mode: "global", copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"});
    });
    var Ze3 = C3.Object;
    var Re3 = function(e3) {
      return Ze3(ee3(e3));
    };
    var Ee3 = B3({}.hasOwnProperty);
    var Oe3 = Object.hasOwn || function(e3, t3) {
      return Ee3(Re3(e3), t3);
    };
    var Fe3 = 0;
    var xe3 = Math.random();
    var Ce3 = B3(1 .toString);
    var Ve3 = function(e3) {
      return "Symbol(" + (e3 === void 0 ? "" : e3) + ")_" + Ce3(++Fe3 + xe3, 36);
    };
    var We3 = Ke3("wks");
    var Ue3 = C3.Symbol;
    var Xe3 = Ue3 && Ue3.for;
    var Le3 = pe3 ? Ue3 : Ue3 && Ue3.withoutSetter || Ve3;
    var Ye3 = function(e3) {
      if (!Oe3(We3, e3) || !he3 && typeof We3[e3] != "string") {
        var t3 = "Symbol." + e3;
        he3 && Oe3(Ue3, e3) ? We3[e3] = Ue3[e3] : We3[e3] = pe3 && Xe3 ? Xe3(t3) : Le3(t3);
      }
      return We3[e3];
    };
    var je3 = C3.TypeError;
    var Je3 = Ye3("toPrimitive");
    var Ne3 = function(e3) {
      var t3 = function(e4, t4) {
        if (!re3(e4) || me3(e4))
          return e4;
        var n3, r3 = Se3(e4, Je3);
        if (r3) {
          if (t4 === void 0 && (t4 = "default"), n3 = X3(r3, e4, t4), !re3(n3) || me3(n3))
            return n3;
          throw je3("Can't convert object to primitive value");
        }
        return t4 === void 0 && (t4 = "number"), function(e5, t5) {
          var n4, r4;
          if (t5 === "string" && ne3(n4 = e5.toString) && !re3(r4 = X3(n4, e5)))
            return r4;
          if (ne3(n4 = e5.valueOf) && !re3(r4 = X3(n4, e5)))
            return r4;
          if (t5 !== "string" && ne3(n4 = e5.toString) && !re3(r4 = X3(n4, e5)))
            return r4;
          throw Ie3("Can't convert object to primitive value");
        }(e4, t4);
      }(e3, "string");
      return me3(t3) ? t3 : t3 + "";
    };
    var Pe3 = C3.document;
    var Ge3 = re3(Pe3) && re3(Pe3.createElement);
    var Ae3 = function(e3) {
      return Ge3 ? Pe3.createElement(e3) : {};
    };
    var Be3 = !W3 && !V3(function() {
      return Object.defineProperty(Ae3("div"), "a", {get: function() {
        return 7;
      }}).a != 7;
    });
    var ze3 = Object.getOwnPropertyDescriptor;
    var He3 = {f: W3 ? ze3 : function(e3, t3) {
      if (e3 = te3(e3), t3 = Ne3(t3), Be3)
        try {
          return ze3(e3, t3);
        } catch (e4) {
        }
      if (Oe3(e3, t3))
        return J3(!X3(j3.f, e3, t3), e3[t3]);
    }};
    var De3 = C3.String;
    var Me3 = C3.TypeError;
    var qe3 = function(e3) {
      if (re3(e3))
        return e3;
      throw Me3(De3(e3) + " is not an object");
    };
    var Qe3 = C3.TypeError;
    var $e3 = Object.defineProperty;
    var et3 = {f: W3 ? $e3 : function(e3, t3, n3) {
      if (qe3(e3), t3 = Ne3(t3), qe3(n3), Be3)
        try {
          return $e3(e3, t3, n3);
        } catch (e4) {
        }
      if ("get" in n3 || "set" in n3)
        throw Qe3("Accessors not supported");
      return "value" in n3 && (e3[t3] = n3.value), e3;
    }};
    var tt3 = W3 ? function(e3, t3, n3) {
      return et3.f(e3, t3, J3(1, n3));
    } : function(e3, t3, n3) {
      return e3[t3] = n3, e3;
    };
    var nt2 = B3(Function.toString);
    ne3(_e3.inspectSource) || (_e3.inspectSource = function(e3) {
      return nt2(e3);
    });
    var rt2;
    var ot2;
    var it3;
    var at2 = _e3.inspectSource;
    var ct2 = C3.WeakMap;
    var st2 = ne3(ct2) && /native code/.test(at2(ct2));
    var ut2 = Ke3("keys");
    var lt2 = function(e3) {
      return ut2[e3] || (ut2[e3] = Ve3(e3));
    };
    var ft2 = {};
    var dt2 = C3.TypeError;
    var ht2 = C3.WeakMap;
    if (st2 || _e3.state) {
      pt2 = _e3.state || (_e3.state = new ht2()), yt2 = B3(pt2.get), mt2 = B3(pt2.has), vt2 = B3(pt2.set);
      rt2 = function(e3, t3) {
        if (mt2(pt2, e3))
          throw new dt2("Object already initialized");
        return t3.facade = e3, vt2(pt2, e3, t3), t3;
      }, ot2 = function(e3) {
        return yt2(pt2, e3) || {};
      }, it3 = function(e3) {
        return mt2(pt2, e3);
      };
    } else {
      bt2 = lt2("state");
      ft2[bt2] = true, rt2 = function(e3, t3) {
        if (Oe3(e3, bt2))
          throw new dt2("Object already initialized");
        return t3.facade = e3, tt3(e3, bt2, t3), t3;
      }, ot2 = function(e3) {
        return Oe3(e3, bt2) ? e3[bt2] : {};
      }, it3 = function(e3) {
        return Oe3(e3, bt2);
      };
    }
    var pt2;
    var yt2;
    var mt2;
    var vt2;
    var bt2;
    var gt3 = {set: rt2, get: ot2, has: it3, enforce: function(e3) {
      return it3(e3) ? ot2(e3) : rt2(e3, {});
    }, getterFor: function(e3) {
      return function(t3) {
        var n3;
        if (!re3(t3) || (n3 = ot2(t3)).type !== e3)
          throw dt2("Incompatible receiver, " + e3 + " required");
        return n3;
      };
    }};
    var wt2 = Function.prototype;
    var St2 = W3 && Object.getOwnPropertyDescriptor;
    var It3 = Oe3(wt2, "name");
    var kt2 = {EXISTS: It3, PROPER: It3 && function() {
    }.name === "something", CONFIGURABLE: It3 && (!W3 || W3 && St2(wt2, "name").configurable)};
    var Tt2 = E3(function(e3) {
      var t3 = kt2.CONFIGURABLE, n3 = gt3.get, r3 = gt3.enforce, o3 = String(String).split("String");
      (e3.exports = function(e4, n4, i3, a3) {
        var c3, s3 = !!a3 && !!a3.unsafe, u3 = !!a3 && !!a3.enumerable, l3 = !!a3 && !!a3.noTargetGet, f3 = a3 && a3.name !== void 0 ? a3.name : n4;
        ne3(i3) && (String(f3).slice(0, 7) === "Symbol(" && (f3 = "[" + String(f3).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"), (!Oe3(i3, "name") || t3 && i3.name !== f3) && tt3(i3, "name", f3), (c3 = r3(i3)).source || (c3.source = o3.join(typeof f3 == "string" ? f3 : ""))), e4 !== C3 ? (s3 ? !l3 && e4[n4] && (u3 = true) : delete e4[n4], u3 ? e4[n4] = i3 : tt3(e4, n4, i3)) : u3 ? e4[n4] = i3 : Te3(n4, i3);
      })(Function.prototype, "toString", function() {
        return ne3(this) && n3(this).source || at2(this);
      });
    });
    var _t2 = Math.ceil;
    var Kt2 = Math.floor;
    var Zt2 = function(e3) {
      var t3 = +e3;
      return t3 != t3 || t3 === 0 ? 0 : (t3 > 0 ? Kt2 : _t2)(t3);
    };
    var Rt2 = Math.max;
    var Et2 = Math.min;
    var Ot2 = Math.min;
    var Ft2 = function(e3) {
      return e3 > 0 ? Ot2(Zt2(e3), 9007199254740991) : 0;
    };
    var xt2 = function(e3) {
      return Ft2(e3.length);
    };
    var Ct3 = function(e3) {
      return function(t3, n3, r3) {
        var o3, i3 = te3(t3), a3 = xt2(i3), c3 = function(e4, t4) {
          var n4 = Zt2(e4);
          return n4 < 0 ? Rt2(n4 + t4, 0) : Et2(n4, t4);
        }(r3, a3);
        if (e3 && n3 != n3) {
          for (; a3 > c3; )
            if ((o3 = i3[c3++]) != o3)
              return true;
        } else
          for (; a3 > c3; c3++)
            if ((e3 || c3 in i3) && i3[c3] === n3)
              return e3 || c3 || 0;
        return !e3 && -1;
      };
    };
    var Vt2 = {includes: Ct3(true), indexOf: Ct3(false)};
    var Wt2 = Vt2.indexOf;
    var Ut2 = B3([].push);
    var Xt2 = function(e3, t3) {
      var n3, r3 = te3(e3), o3 = 0, i3 = [];
      for (n3 in r3)
        !Oe3(ft2, n3) && Oe3(r3, n3) && Ut2(i3, n3);
      for (; t3.length > o3; )
        Oe3(r3, n3 = t3[o3++]) && (~Wt2(i3, n3) || Ut2(i3, n3));
      return i3;
    };
    var Lt2 = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"];
    var Yt2 = Lt2.concat("length", "prototype");
    var jt2 = {f: Object.getOwnPropertyNames || function(e3) {
      return Xt2(e3, Yt2);
    }};
    var Jt2 = {f: Object.getOwnPropertySymbols};
    var Nt2 = B3([].concat);
    var Pt2 = ie3("Reflect", "ownKeys") || function(e3) {
      var t3 = jt2.f(qe3(e3)), n3 = Jt2.f;
      return n3 ? Nt2(t3, n3(e3)) : t3;
    };
    var Gt2 = function(e3, t3) {
      for (var n3 = Pt2(t3), r3 = et3.f, o3 = He3.f, i3 = 0; i3 < n3.length; i3++) {
        var a3 = n3[i3];
        Oe3(e3, a3) || r3(e3, a3, o3(t3, a3));
      }
    };
    var At3 = /#|\.prototype\./;
    var Bt3 = function(e3, t3) {
      var n3 = Ht2[zt2(e3)];
      return n3 == Mt2 || n3 != Dt2 && (ne3(t3) ? V3(t3) : !!t3);
    };
    var zt2 = Bt3.normalize = function(e3) {
      return String(e3).replace(At3, ".").toLowerCase();
    };
    var Ht2 = Bt3.data = {};
    var Dt2 = Bt3.NATIVE = "N";
    var Mt2 = Bt3.POLYFILL = "P";
    var qt2 = Bt3;
    var Qt2 = He3.f;
    var $t2 = function(e3, t3) {
      var n3, r3, o3, i3, a3, c3 = e3.target, s3 = e3.global, u3 = e3.stat;
      if (n3 = s3 ? C3 : u3 ? C3[c3] || Te3(c3, {}) : (C3[c3] || {}).prototype)
        for (r3 in t3) {
          if (i3 = t3[r3], o3 = e3.noTargetGet ? (a3 = Qt2(n3, r3)) && a3.value : n3[r3], !qt2(s3 ? r3 : c3 + (u3 ? "." : "#") + r3, e3.forced) && o3 !== void 0) {
            if (typeof i3 == typeof o3)
              continue;
            Gt2(i3, o3);
          }
          (e3.sham || o3 && o3.sham) && tt3(i3, "sham", true), Tt2(n3, r3, i3, e3);
        }
    };
    var en2 = {};
    en2[Ye3("toStringTag")] = "z";
    var tn2;
    var nn2 = String(en2) === "[object z]";
    var rn2 = Ye3("toStringTag");
    var on2 = C3.Object;
    var an2 = D3(function() {
      return arguments;
    }()) == "Arguments";
    var cn2 = nn2 ? D3 : function(e3) {
      var t3, n3, r3;
      return e3 === void 0 ? "Undefined" : e3 === null ? "Null" : typeof (n3 = function(e4, t4) {
        try {
          return e4[t4];
        } catch (e5) {
        }
      }(t3 = on2(e3), rn2)) == "string" ? n3 : an2 ? D3(t3) : (r3 = D3(t3)) == "Object" && ne3(t3.callee) ? "Arguments" : r3;
    };
    var sn2 = C3.String;
    var un2 = function(e3) {
      if (cn2(e3) === "Symbol")
        throw TypeError("Cannot convert a Symbol value to a string");
      return sn2(e3);
    };
    var ln2 = Ye3("match");
    var fn2 = C3.TypeError;
    var dn2 = function(e3) {
      if (function(e4) {
        var t3;
        return re3(e4) && ((t3 = e4[ln2]) !== void 0 ? !!t3 : D3(e4) == "RegExp");
      }(e3))
        throw fn2("The method doesn't accept regular expressions");
      return e3;
    };
    var hn2 = Ye3("match");
    var pn2 = function(e3) {
      var t3 = /./;
      try {
        "/./"[e3](t3);
      } catch (n3) {
        try {
          return t3[hn2] = false, "/./"[e3](t3);
        } catch (e4) {
        }
      }
      return false;
    };
    var yn2 = He3.f;
    var mn2 = B3("".startsWith);
    var vn = B3("".slice);
    var bn2 = Math.min;
    var gn2 = pn2("startsWith");
    var wn = !(gn2 || (tn2 = yn2(String.prototype, "startsWith"), !tn2 || tn2.writable));
    $t2({target: "String", proto: true, forced: !wn && !gn2}, {startsWith: function(e3) {
      var t3 = un2(ee3(this));
      dn2(e3);
      var n3 = Ft2(bn2(arguments.length > 1 ? arguments[1] : void 0, t3.length)), r3 = un2(e3);
      return mn2 ? mn2(t3, r3, n3) : vn(t3, n3, n3 + r3.length) === r3;
    }});
    var Sn = function(e3, t3) {
      return B3(C3[e3].prototype[t3]);
    };
    Sn("String", "startsWith");
    var In = Array.isArray || function(e3) {
      return D3(e3) == "Array";
    };
    var kn = function(e3, t3, n3) {
      var r3 = Ne3(t3);
      r3 in e3 ? et3.f(e3, r3, J3(0, n3)) : e3[r3] = n3;
    };
    var Tn = function() {
    };
    var _n2 = [];
    var Kn = ie3("Reflect", "construct");
    var Zn = /^\s*(?:class|function)\b/;
    var Rn = B3(Zn.exec);
    var En = !Zn.exec(Tn);
    var On = function(e3) {
      if (!ne3(e3))
        return false;
      try {
        return Kn(Tn, _n2, e3), true;
      } catch (e4) {
        return false;
      }
    };
    var Fn = !Kn || V3(function() {
      var e3;
      return On(On.call) || !On(Object) || !On(function() {
        e3 = true;
      }) || e3;
    }) ? function(e3) {
      if (!ne3(e3))
        return false;
      switch (cn2(e3)) {
        case "AsyncFunction":
        case "GeneratorFunction":
        case "AsyncGeneratorFunction":
          return false;
      }
      return En || !!Rn(Zn, at2(e3));
    } : On;
    var xn = Ye3("species");
    var Cn = C3.Array;
    var Vn = function(e3, t3) {
      return new (function(e4) {
        var t4;
        return In(e4) && (t4 = e4.constructor, (Fn(t4) && (t4 === Cn || In(t4.prototype)) || re3(t4) && (t4 = t4[xn]) === null) && (t4 = void 0)), t4 === void 0 ? Cn : t4;
      }(e3))(t3 === 0 ? 0 : t3);
    };
    var Wn = Ye3("species");
    var Un = Ye3("isConcatSpreadable");
    var Xn = C3.TypeError;
    var Ln = de3 >= 51 || !V3(function() {
      var e3 = [];
      return e3[Un] = false, e3.concat()[0] !== e3;
    });
    var Yn = ("concat", de3 >= 51 || !V3(function() {
      var e3 = [];
      return (e3.constructor = {})[Wn] = function() {
        return {foo: 1};
      }, e3.concat(Boolean).foo !== 1;
    }));
    var jn = function(e3) {
      if (!re3(e3))
        return false;
      var t3 = e3[Un];
      return t3 !== void 0 ? !!t3 : In(e3);
    };
    $t2({target: "Array", proto: true, forced: !Ln || !Yn}, {concat: function(e3) {
      var t3, n3, r3, o3, i3, a3 = Re3(this), c3 = Vn(a3, 0), s3 = 0;
      for (t3 = -1, r3 = arguments.length; t3 < r3; t3++)
        if (jn(i3 = t3 === -1 ? a3 : arguments[t3])) {
          if (s3 + (o3 = xt2(i3)) > 9007199254740991)
            throw Xn("Maximum allowed index exceeded");
          for (n3 = 0; n3 < o3; n3++, s3++)
            n3 in i3 && kn(c3, s3, i3[n3]);
        } else {
          if (s3 >= 9007199254740991)
            throw Xn("Maximum allowed index exceeded");
          kn(c3, s3++, i3);
        }
      return c3.length = s3, c3;
    }});
    var Jn = nn2 ? {}.toString : function() {
      return "[object " + cn2(this) + "]";
    };
    nn2 || Tt2(Object.prototype, "toString", Jn, {unsafe: true});
    var Nn;
    var Pn = Function.prototype;
    var Gn = Pn.apply;
    var An = Pn.bind;
    var Bn = Pn.call;
    var zn = typeof Reflect == "object" && Reflect.apply || (An ? Bn.bind(Gn) : function() {
      return Bn.apply(Gn, arguments);
    });
    var Hn = Object.keys || function(e3) {
      return Xt2(e3, Lt2);
    };
    var Dn = W3 ? Object.defineProperties : function(e3, t3) {
      qe3(e3);
      for (var n3, r3 = te3(t3), o3 = Hn(t3), i3 = o3.length, a3 = 0; i3 > a3; )
        et3.f(e3, n3 = o3[a3++], r3[n3]);
      return e3;
    };
    var Mn = ie3("document", "documentElement");
    var qn = lt2("IE_PROTO");
    var Qn = function() {
    };
    var $n2 = function(e3) {
      return "<script>" + e3 + "</script>";
    };
    var er = function(e3) {
      e3.write($n2("")), e3.close();
      var t3 = e3.parentWindow.Object;
      return e3 = null, t3;
    };
    var tr = function() {
      try {
        Nn = new ActiveXObject("htmlfile");
      } catch (e4) {
      }
      var e3, t3;
      tr = typeof document != "undefined" ? document.domain && Nn ? er(Nn) : ((t3 = Ae3("iframe")).style.display = "none", Mn.appendChild(t3), t3.src = String("javascript:"), (e3 = t3.contentWindow.document).open(), e3.write($n2("document.F=Object")), e3.close(), e3.F) : er(Nn);
      for (var n3 = Lt2.length; n3--; )
        delete tr.prototype[Lt2[n3]];
      return tr();
    };
    ft2[qn] = true;
    var nr = Object.create || function(e3, t3) {
      var n3;
      return e3 !== null ? (Qn.prototype = qe3(e3), n3 = new Qn(), Qn.prototype = null, n3[qn] = e3) : n3 = tr(), t3 === void 0 ? n3 : Dn(n3, t3);
    };
    var rr = B3([].slice);
    var or = jt2.f;
    var ir = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
    var ar = {f: function(e3) {
      return ir && D3(e3) == "Window" ? function(e4) {
        try {
          return or(e4);
        } catch (e5) {
          return rr(ir);
        }
      }(e3) : or(te3(e3));
    }};
    var cr = {f: Ye3};
    var sr = C3;
    var ur = et3.f;
    var lr = function(e3) {
      var t3 = sr.Symbol || (sr.Symbol = {});
      Oe3(t3, e3) || ur(t3, e3, {value: cr.f(e3)});
    };
    var fr = et3.f;
    var dr = Ye3("toStringTag");
    var hr = function(e3, t3, n3) {
      e3 && !Oe3(e3 = n3 ? e3 : e3.prototype, dr) && fr(e3, dr, {configurable: true, value: t3});
    };
    var pr = B3(B3.bind);
    var yr = function(e3, t3) {
      return we3(e3), t3 === void 0 ? e3 : pr ? pr(e3, t3) : function() {
        return e3.apply(t3, arguments);
      };
    };
    var mr = B3([].push);
    var vr = function(e3) {
      var t3 = e3 == 1, n3 = e3 == 2, r3 = e3 == 3, o3 = e3 == 4, i3 = e3 == 6, a3 = e3 == 7, c3 = e3 == 5 || i3;
      return function(s3, u3, l3, f3) {
        for (var d3, h3, p3 = Re3(s3), y3 = Q3(p3), m3 = yr(u3, l3), v4 = xt2(y3), b4 = 0, g4 = f3 || Vn, w4 = t3 ? g4(s3, v4) : n3 || a3 ? g4(s3, 0) : void 0; v4 > b4; b4++)
          if ((c3 || b4 in y3) && (h3 = m3(d3 = y3[b4], b4, p3), e3))
            if (t3)
              w4[b4] = h3;
            else if (h3)
              switch (e3) {
                case 3:
                  return true;
                case 5:
                  return d3;
                case 6:
                  return b4;
                case 2:
                  mr(w4, d3);
              }
            else
              switch (e3) {
                case 4:
                  return false;
                case 7:
                  mr(w4, d3);
              }
        return i3 ? -1 : r3 || o3 ? o3 : w4;
      };
    };
    var br = [vr(0), vr(1), vr(2), vr(3), vr(4), vr(5), vr(6), vr(7)][0];
    var gr = lt2("hidden");
    var wr = Ye3("toPrimitive");
    var Sr = gt3.set;
    var Ir = gt3.getterFor("Symbol");
    var kr = Object.prototype;
    var Tr = C3.Symbol;
    var _r = Tr && Tr.prototype;
    var Kr = C3.TypeError;
    var Zr = C3.QObject;
    var Rr = ie3("JSON", "stringify");
    var Er = He3.f;
    var Or = et3.f;
    var Fr = ar.f;
    var xr = j3.f;
    var Cr = B3([].push);
    var Vr = Ke3("symbols");
    var Wr = Ke3("op-symbols");
    var Ur = Ke3("string-to-symbol-registry");
    var Xr = Ke3("symbol-to-string-registry");
    var Lr = Ke3("wks");
    var Yr = !Zr || !Zr.prototype || !Zr.prototype.findChild;
    var jr = W3 && V3(function() {
      return nr(Or({}, "a", {get: function() {
        return Or(this, "a", {value: 7}).a;
      }})).a != 7;
    }) ? function(e3, t3, n3) {
      var r3 = Er(kr, t3);
      r3 && delete kr[t3], Or(e3, t3, n3), r3 && e3 !== kr && Or(kr, t3, r3);
    } : Or;
    var Jr = function(e3, t3) {
      var n3 = Vr[e3] = nr(_r);
      return Sr(n3, {type: "Symbol", tag: e3, description: t3}), W3 || (n3.description = t3), n3;
    };
    var Nr = function(e3, t3, n3) {
      e3 === kr && Nr(Wr, t3, n3), qe3(e3);
      var r3 = Ne3(t3);
      return qe3(n3), Oe3(Vr, r3) ? (n3.enumerable ? (Oe3(e3, gr) && e3[gr][r3] && (e3[gr][r3] = false), n3 = nr(n3, {enumerable: J3(0, false)})) : (Oe3(e3, gr) || Or(e3, gr, J3(1, {})), e3[gr][r3] = true), jr(e3, r3, n3)) : Or(e3, r3, n3);
    };
    var Pr = function(e3, t3) {
      qe3(e3);
      var n3 = te3(t3), r3 = Hn(n3).concat(zr(n3));
      return br(r3, function(t4) {
        W3 && !X3(Gr, n3, t4) || Nr(e3, t4, n3[t4]);
      }), e3;
    };
    var Gr = function(e3) {
      var t3 = Ne3(e3), n3 = X3(xr, this, t3);
      return !(this === kr && Oe3(Vr, t3) && !Oe3(Wr, t3)) && (!(n3 || !Oe3(this, t3) || !Oe3(Vr, t3) || Oe3(this, gr) && this[gr][t3]) || n3);
    };
    var Ar = function(e3, t3) {
      var n3 = te3(e3), r3 = Ne3(t3);
      if (n3 !== kr || !Oe3(Vr, r3) || Oe3(Wr, r3)) {
        var o3 = Er(n3, r3);
        return !o3 || !Oe3(Vr, r3) || Oe3(n3, gr) && n3[gr][r3] || (o3.enumerable = true), o3;
      }
    };
    var Br = function(e3) {
      var t3 = Fr(te3(e3)), n3 = [];
      return br(t3, function(e4) {
        Oe3(Vr, e4) || Oe3(ft2, e4) || Cr(n3, e4);
      }), n3;
    };
    var zr = function(e3) {
      var t3 = e3 === kr, n3 = Fr(t3 ? Wr : te3(e3)), r3 = [];
      return br(n3, function(e4) {
        !Oe3(Vr, e4) || t3 && !Oe3(kr, e4) || Cr(r3, Vr[e4]);
      }), r3;
    };
    if (he3 || (_r = (Tr = function() {
      if (ae3(_r, this))
        throw Kr("Symbol is not a constructor");
      var e3 = arguments.length && arguments[0] !== void 0 ? un2(arguments[0]) : void 0, t3 = Ve3(e3), n3 = function(e4) {
        this === kr && X3(n3, Wr, e4), Oe3(this, gr) && Oe3(this[gr], t3) && (this[gr][t3] = false), jr(this, t3, J3(1, e4));
      };
      return W3 && Yr && jr(kr, t3, {configurable: true, set: n3}), Jr(t3, e3);
    }).prototype, Tt2(_r, "toString", function() {
      return Ir(this).tag;
    }), Tt2(Tr, "withoutSetter", function(e3) {
      return Jr(Ve3(e3), e3);
    }), j3.f = Gr, et3.f = Nr, He3.f = Ar, jt2.f = ar.f = Br, Jt2.f = zr, cr.f = function(e3) {
      return Jr(Ye3(e3), e3);
    }, W3 && (Or(_r, "description", {configurable: true, get: function() {
      return Ir(this).description;
    }}), Tt2(kr, "propertyIsEnumerable", Gr, {unsafe: true}))), $t2({global: true, wrap: true, forced: !he3, sham: !he3}, {Symbol: Tr}), br(Hn(Lr), function(e3) {
      lr(e3);
    }), $t2({target: "Symbol", stat: true, forced: !he3}, {for: function(e3) {
      var t3 = un2(e3);
      if (Oe3(Ur, t3))
        return Ur[t3];
      var n3 = Tr(t3);
      return Ur[t3] = n3, Xr[n3] = t3, n3;
    }, keyFor: function(e3) {
      if (!me3(e3))
        throw Kr(e3 + " is not a symbol");
      if (Oe3(Xr, e3))
        return Xr[e3];
    }, useSetter: function() {
      Yr = true;
    }, useSimple: function() {
      Yr = false;
    }}), $t2({target: "Object", stat: true, forced: !he3, sham: !W3}, {create: function(e3, t3) {
      return t3 === void 0 ? nr(e3) : Pr(nr(e3), t3);
    }, defineProperty: Nr, defineProperties: Pr, getOwnPropertyDescriptor: Ar}), $t2({target: "Object", stat: true, forced: !he3}, {getOwnPropertyNames: Br, getOwnPropertySymbols: zr}), $t2({target: "Object", stat: true, forced: V3(function() {
      Jt2.f(1);
    })}, {getOwnPropertySymbols: function(e3) {
      return Jt2.f(Re3(e3));
    }}), Rr) {
      Hr = !he3 || V3(function() {
        var e3 = Tr();
        return Rr([e3]) != "[null]" || Rr({a: e3}) != "{}" || Rr(Object(e3)) != "{}";
      });
      $t2({target: "JSON", stat: true, forced: Hr}, {stringify: function(e3, t3, n3) {
        var r3 = rr(arguments), o3 = t3;
        if ((re3(t3) || e3 !== void 0) && !me3(e3))
          return In(t3) || (t3 = function(e4, t4) {
            if (ne3(o3) && (t4 = X3(o3, this, e4, t4)), !me3(t4))
              return t4;
          }), r3[1] = t3, zn(Rr, null, r3);
      }});
    }
    var Hr;
    if (!_r[wr]) {
      Dr = _r.valueOf;
      Tt2(_r, wr, function(e3) {
        return X3(Dr, this);
      });
    }
    var Dr;
    hr(Tr, "Symbol"), ft2[gr] = true, lr("asyncIterator");
    var Mr = et3.f;
    var qr = C3.Symbol;
    var Qr = qr && qr.prototype;
    if (W3 && ne3(qr) && (!("description" in Qr) || qr().description !== void 0)) {
      $r = {}, eo = function() {
        var e3 = arguments.length < 1 || arguments[0] === void 0 ? void 0 : un2(arguments[0]), t3 = ae3(Qr, this) ? new qr(e3) : e3 === void 0 ? qr() : qr(e3);
        return e3 === "" && ($r[t3] = true), t3;
      };
      Gt2(eo, qr), eo.prototype = Qr, Qr.constructor = eo;
      to = String(qr("test")) == "Symbol(test)", no = B3(Qr.toString), ro = B3(Qr.valueOf), oo = /^Symbol\((.*)\)[^)]+$/, io = B3("".replace), ao = B3("".slice);
      Mr(Qr, "description", {configurable: true, get: function() {
        var e3 = ro(this), t3 = no(e3);
        if (Oe3($r, e3))
          return "";
        var n3 = to ? ao(t3, 7, -1) : io(t3, oo, "$1");
        return n3 === "" ? void 0 : n3;
      }}), $t2({global: true, forced: true}, {Symbol: eo});
    }
    var $r;
    var eo;
    var to;
    var no;
    var ro;
    var oo;
    var io;
    var ao;
    lr("hasInstance"), lr("isConcatSpreadable"), lr("iterator"), lr("match"), lr("matchAll"), lr("replace"), lr("search"), lr("species"), lr("split"), lr("toPrimitive"), lr("toStringTag"), lr("unscopables"), hr(C3.JSON, "JSON", true), hr(Math, "Math", true), $t2({global: true}, {Reflect: {}}), hr(C3.Reflect, "Reflect", true), sr.Symbol;
    var co;
    var so;
    var uo;
    var lo = B3("".charAt);
    var fo = B3("".charCodeAt);
    var ho = B3("".slice);
    var po = function(e3) {
      return function(t3, n3) {
        var r3, o3, i3 = un2(ee3(t3)), a3 = Zt2(n3), c3 = i3.length;
        return a3 < 0 || a3 >= c3 ? e3 ? "" : void 0 : (r3 = fo(i3, a3)) < 55296 || r3 > 56319 || a3 + 1 === c3 || (o3 = fo(i3, a3 + 1)) < 56320 || o3 > 57343 ? e3 ? lo(i3, a3) : r3 : e3 ? ho(i3, a3, a3 + 2) : o3 - 56320 + (r3 - 55296 << 10) + 65536;
      };
    };
    var yo = {codeAt: po(false), charAt: po(true)};
    var mo = !V3(function() {
      function e3() {
      }
      return e3.prototype.constructor = null, Object.getPrototypeOf(new e3()) !== e3.prototype;
    });
    var vo = lt2("IE_PROTO");
    var bo = C3.Object;
    var go = bo.prototype;
    var wo = mo ? bo.getPrototypeOf : function(e3) {
      var t3 = Re3(e3);
      if (Oe3(t3, vo))
        return t3[vo];
      var n3 = t3.constructor;
      return ne3(n3) && t3 instanceof n3 ? n3.prototype : t3 instanceof bo ? go : null;
    };
    var So = Ye3("iterator");
    var Io = false;
    [].keys && ("next" in (uo = [].keys()) ? (so = wo(wo(uo))) !== Object.prototype && (co = so) : Io = true), (co == null || V3(function() {
      var e3 = {};
      return co[So].call(e3) !== e3;
    })) && (co = {}), ne3(co[So]) || Tt2(co, So, function() {
      return this;
    });
    var ko = {IteratorPrototype: co, BUGGY_SAFARI_ITERATORS: Io};
    var To = {};
    var _o = ko.IteratorPrototype;
    var Ko = function() {
      return this;
    };
    var Zo = C3.String;
    var Ro = C3.TypeError;
    var Eo = Object.setPrototypeOf || ("__proto__" in {} ? function() {
      var e3, t3 = false, n3 = {};
      try {
        (e3 = B3(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(n3, []), t3 = n3 instanceof Array;
      } catch (e4) {
      }
      return function(n4, r3) {
        return qe3(n4), function(e4) {
          if (typeof e4 == "object" || ne3(e4))
            return e4;
          throw Ro("Can't set " + Zo(e4) + " as a prototype");
        }(r3), t3 ? e3(n4, r3) : n4.__proto__ = r3, n4;
      };
    }() : void 0);
    var Oo = kt2.PROPER;
    var Fo = kt2.CONFIGURABLE;
    var xo = ko.IteratorPrototype;
    var Co = ko.BUGGY_SAFARI_ITERATORS;
    var Vo = Ye3("iterator");
    var Wo = function() {
      return this;
    };
    var Uo = function(e3, t3, n3, r3, o3, i3, a3) {
      !function(e4, t4, n4) {
        var r4 = t4 + " Iterator";
        e4.prototype = nr(_o, {next: J3(1, n4)}), hr(e4, r4, false), To[r4] = Ko;
      }(n3, t3, r3);
      var c3, s3, u3, l3 = function(e4) {
        if (e4 === o3 && y3)
          return y3;
        if (!Co && e4 in h3)
          return h3[e4];
        switch (e4) {
          case "keys":
          case "values":
          case "entries":
            return function() {
              return new n3(this, e4);
            };
        }
        return function() {
          return new n3(this);
        };
      }, f3 = t3 + " Iterator", d3 = false, h3 = e3.prototype, p3 = h3[Vo] || h3["@@iterator"] || o3 && h3[o3], y3 = !Co && p3 || l3(o3), m3 = t3 == "Array" && h3.entries || p3;
      if (m3 && (c3 = wo(m3.call(new e3()))) !== Object.prototype && c3.next && (wo(c3) !== xo && (Eo ? Eo(c3, xo) : ne3(c3[Vo]) || Tt2(c3, Vo, Wo)), hr(c3, f3, true)), Oo && o3 == "values" && p3 && p3.name !== "values" && (Fo ? tt3(h3, "name", "values") : (d3 = true, y3 = function() {
        return X3(p3, this);
      })), o3)
        if (s3 = {values: l3("values"), keys: i3 ? y3 : l3("keys"), entries: l3("entries")}, a3)
          for (u3 in s3)
            (Co || d3 || !(u3 in h3)) && Tt2(h3, u3, s3[u3]);
        else
          $t2({target: t3, proto: true, forced: Co || d3}, s3);
      return h3[Vo] !== y3 && Tt2(h3, Vo, y3, {name: o3}), To[t3] = y3, s3;
    };
    var Xo = yo.charAt;
    var Lo = gt3.set;
    var Yo = gt3.getterFor("String Iterator");
    Uo(String, "String", function(e3) {
      Lo(this, {type: "String Iterator", string: un2(e3), index: 0});
    }, function() {
      var e3, t3 = Yo(this), n3 = t3.string, r3 = t3.index;
      return r3 >= n3.length ? {value: void 0, done: true} : (e3 = Xo(n3, r3), t3.index += e3.length, {value: e3, done: false});
    });
    var jo = function(e3, t3, n3) {
      var r3, o3;
      qe3(e3);
      try {
        if (!(r3 = Se3(e3, "return"))) {
          if (t3 === "throw")
            throw n3;
          return n3;
        }
        r3 = X3(r3, e3);
      } catch (e4) {
        o3 = true, r3 = e4;
      }
      if (t3 === "throw")
        throw n3;
      if (o3)
        throw r3;
      return qe3(r3), n3;
    };
    var Jo = function(e3, t3, n3, r3) {
      try {
        return r3 ? t3(qe3(n3)[0], n3[1]) : t3(n3);
      } catch (t4) {
        jo(e3, "throw", t4);
      }
    };
    var No = Ye3("iterator");
    var Po = Array.prototype;
    var Go = function(e3) {
      return e3 !== void 0 && (To.Array === e3 || Po[No] === e3);
    };
    var Ao = Ye3("iterator");
    var Bo = function(e3) {
      if (e3 != null)
        return Se3(e3, Ao) || Se3(e3, "@@iterator") || To[cn2(e3)];
    };
    var zo = C3.TypeError;
    var Ho = function(e3, t3) {
      var n3 = arguments.length < 2 ? Bo(e3) : t3;
      if (we3(n3))
        return qe3(X3(n3, e3));
      throw zo(be3(e3) + " is not iterable");
    };
    var Do = C3.Array;
    var Mo = Ye3("iterator");
    var qo = false;
    try {
      Qo = 0, $o = {next: function() {
        return {done: !!Qo++};
      }, return: function() {
        qo = true;
      }};
      $o[Mo] = function() {
        return this;
      }, Array.from($o, function() {
        throw 2;
      });
    } catch (g4) {
    }
    var Qo;
    var $o;
    var ei2 = function(e3, t3) {
      if (!t3 && !qo)
        return false;
      var n3 = false;
      try {
        var r3 = {};
        r3[Mo] = function() {
          return {next: function() {
            return {done: n3 = true};
          }};
        }, e3(r3);
      } catch (e4) {
      }
      return n3;
    };
    var ti2 = !ei2(function(e3) {
      Array.from(e3);
    });
    $t2({target: "Array", stat: true, forced: ti2}, {from: function(e3) {
      var t3 = Re3(e3), n3 = Fn(this), r3 = arguments.length, o3 = r3 > 1 ? arguments[1] : void 0, i3 = o3 !== void 0;
      i3 && (o3 = yr(o3, r3 > 2 ? arguments[2] : void 0));
      var a3, c3, s3, u3, l3, f3, d3 = Bo(t3), h3 = 0;
      if (!d3 || this == Do && Go(d3))
        for (a3 = xt2(t3), c3 = n3 ? new this(a3) : Do(a3); a3 > h3; h3++)
          f3 = i3 ? o3(t3[h3], h3) : t3[h3], kn(c3, h3, f3);
      else
        for (l3 = (u3 = Ho(t3, d3)).next, c3 = n3 ? new this() : []; !(s3 = X3(l3, u3)).done; h3++)
          f3 = i3 ? Jo(u3, o3, [s3.value, h3], true) : s3.value, kn(c3, h3, f3);
      return c3.length = h3, c3;
    }}), sr.Array.from;
    var ni2;
    var ri2;
    var oi2;
    var ii2 = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
    var ai2 = et3.f;
    var ci2 = C3.Int8Array;
    var si2 = ci2 && ci2.prototype;
    var ui2 = C3.Uint8ClampedArray;
    var li2 = ui2 && ui2.prototype;
    var fi2 = ci2 && wo(ci2);
    var di2 = si2 && wo(si2);
    var hi2 = Object.prototype;
    var pi2 = C3.TypeError;
    var yi2 = Ye3("toStringTag");
    var mi2 = Ve3("TYPED_ARRAY_TAG");
    var vi2 = Ve3("TYPED_ARRAY_CONSTRUCTOR");
    var bi2 = ii2 && !!Eo && cn2(C3.opera) !== "Opera";
    var gi2 = false;
    var wi2 = {Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8};
    var Si2 = {BigInt64Array: 8, BigUint64Array: 8};
    var Ii2 = function(e3) {
      if (!re3(e3))
        return false;
      var t3 = cn2(e3);
      return Oe3(wi2, t3) || Oe3(Si2, t3);
    };
    for (ni2 in wi2)
      (oi2 = (ri2 = C3[ni2]) && ri2.prototype) ? tt3(oi2, vi2, ri2) : bi2 = false;
    for (ni2 in Si2)
      (oi2 = (ri2 = C3[ni2]) && ri2.prototype) && tt3(oi2, vi2, ri2);
    if ((!bi2 || !ne3(fi2) || fi2 === Function.prototype) && (fi2 = function() {
      throw pi2("Incorrect invocation");
    }, bi2))
      for (ni2 in wi2)
        C3[ni2] && Eo(C3[ni2], fi2);
    if ((!bi2 || !di2 || di2 === hi2) && (di2 = fi2.prototype, bi2))
      for (ni2 in wi2)
        C3[ni2] && Eo(C3[ni2].prototype, di2);
    if (bi2 && wo(li2) !== di2 && Eo(li2, di2), W3 && !Oe3(di2, yi2))
      for (ni2 in gi2 = true, ai2(di2, yi2, {get: function() {
        return re3(this) ? this[mi2] : void 0;
      }}), wi2)
        C3[ni2] && tt3(C3[ni2], mi2, ni2);
    var ki2 = {NATIVE_ARRAY_BUFFER_VIEWS: bi2, TYPED_ARRAY_CONSTRUCTOR: vi2, TYPED_ARRAY_TAG: gi2 && mi2, aTypedArray: function(e3) {
      if (Ii2(e3))
        return e3;
      throw pi2("Target is not a typed array");
    }, aTypedArrayConstructor: function(e3) {
      if (ne3(e3) && (!Eo || ae3(fi2, e3)))
        return e3;
      throw pi2(be3(e3) + " is not a typed array constructor");
    }, exportTypedArrayMethod: function(e3, t3, n3) {
      if (W3) {
        if (n3)
          for (var r3 in wi2) {
            var o3 = C3[r3];
            if (o3 && Oe3(o3.prototype, e3))
              try {
                delete o3.prototype[e3];
              } catch (e4) {
              }
          }
        di2[e3] && !n3 || Tt2(di2, e3, n3 ? t3 : bi2 && si2[e3] || t3);
      }
    }, exportTypedArrayStaticMethod: function(e3, t3, n3) {
      var r3, o3;
      if (W3) {
        if (Eo) {
          if (n3) {
            for (r3 in wi2)
              if ((o3 = C3[r3]) && Oe3(o3, e3))
                try {
                  delete o3[e3];
                } catch (e4) {
                }
          }
          if (fi2[e3] && !n3)
            return;
          try {
            return Tt2(fi2, e3, n3 ? t3 : bi2 && fi2[e3] || t3);
          } catch (e4) {
          }
        }
        for (r3 in wi2)
          !(o3 = C3[r3]) || o3[e3] && !n3 || Tt2(o3, e3, t3);
      }
    }, isView: function(e3) {
      if (!re3(e3))
        return false;
      var t3 = cn2(e3);
      return t3 === "DataView" || Oe3(wi2, t3) || Oe3(Si2, t3);
    }, isTypedArray: Ii2, TypedArray: fi2, TypedArrayPrototype: di2};
    var Ti2 = C3.TypeError;
    var _i2 = Ye3("species");
    var Ki2 = ki2.TYPED_ARRAY_CONSTRUCTOR;
    var Zi2 = ki2.aTypedArrayConstructor;
    var Ri2 = ki2.aTypedArray;
    (0, ki2.exportTypedArrayMethod)("slice", function(e3, t3) {
      for (var n3 = rr(Ri2(this), e3, t3), r3 = Zi2(function(e4, t4) {
        var n4, r4 = qe3(e4).constructor;
        return r4 === void 0 || (n4 = qe3(r4)[_i2]) == null ? t4 : function(e5) {
          if (Fn(e5))
            return e5;
          throw Ti2(be3(e5) + " is not a constructor");
        }(n4);
      }(this, this[Ki2])), o3 = 0, i3 = n3.length, a3 = new r3(i3); i3 > o3; )
        a3[o3] = n3[o3++];
      return a3;
    }, V3(function() {
      new Int8Array(1).slice();
    }));
    var Ei2 = Ye3("unscopables");
    var Oi2 = Array.prototype;
    Oi2[Ei2] == null && et3.f(Oi2, Ei2, {configurable: true, value: nr(null)});
    var Fi2 = function(e3) {
      Oi2[Ei2][e3] = true;
    };
    var xi2 = Vt2.includes;
    $t2({target: "Array", proto: true}, {includes: function(e3) {
      return xi2(this, e3, arguments.length > 1 ? arguments[1] : void 0);
    }}), Fi2("includes"), Sn("Array", "includes");
    var Ci2 = B3("".indexOf);
    $t2({target: "String", proto: true, forced: !pn2("includes")}, {includes: function(e3) {
      return !!~Ci2(un2(ee3(this)), un2(dn2(e3)), arguments.length > 1 ? arguments[1] : void 0);
    }}), Sn("String", "includes");
    var Vi2 = gt3.set;
    var Wi2 = gt3.getterFor("Array Iterator");
    Uo(Array, "Array", function(e3, t3) {
      Vi2(this, {type: "Array Iterator", target: te3(e3), index: 0, kind: t3});
    }, function() {
      var e3 = Wi2(this), t3 = e3.target, n3 = e3.kind, r3 = e3.index++;
      return !t3 || r3 >= t3.length ? (e3.target = void 0, {value: void 0, done: true}) : n3 == "keys" ? {value: r3, done: false} : n3 == "values" ? {value: t3[r3], done: false} : {value: [r3, t3[r3]], done: false};
    }, "values"), To.Arguments = To.Array, Fi2("keys"), Fi2("values"), Fi2("entries");
    var Ui2 = V3(function() {
      if (typeof ArrayBuffer == "function") {
        var e3 = new ArrayBuffer(8);
        Object.isExtensible(e3) && Object.defineProperty(e3, "a", {value: 8});
      }
    });
    var Xi2 = Object.isExtensible;
    var Li2 = V3(function() {
      Xi2(1);
    }) || Ui2 ? function(e3) {
      return !!re3(e3) && (!Ui2 || D3(e3) != "ArrayBuffer") && (!Xi2 || Xi2(e3));
    } : Xi2;
    var Yi2 = !V3(function() {
      return Object.isExtensible(Object.preventExtensions({}));
    });
    var ji2 = E3(function(e3) {
      var t3 = et3.f, n3 = false, r3 = Ve3("meta"), o3 = 0, i3 = function(e4) {
        t3(e4, r3, {value: {objectID: "O" + o3++, weakData: {}}});
      }, a3 = e3.exports = {enable: function() {
        a3.enable = function() {
        }, n3 = true;
        var e4 = jt2.f, t4 = B3([].splice), o4 = {};
        o4[r3] = 1, e4(o4).length && (jt2.f = function(n4) {
          for (var o5 = e4(n4), i4 = 0, a4 = o5.length; i4 < a4; i4++)
            if (o5[i4] === r3) {
              t4(o5, i4, 1);
              break;
            }
          return o5;
        }, $t2({target: "Object", stat: true, forced: true}, {getOwnPropertyNames: ar.f}));
      }, fastKey: function(e4, t4) {
        if (!re3(e4))
          return typeof e4 == "symbol" ? e4 : (typeof e4 == "string" ? "S" : "P") + e4;
        if (!Oe3(e4, r3)) {
          if (!Li2(e4))
            return "F";
          if (!t4)
            return "E";
          i3(e4);
        }
        return e4[r3].objectID;
      }, getWeakData: function(e4, t4) {
        if (!Oe3(e4, r3)) {
          if (!Li2(e4))
            return true;
          if (!t4)
            return false;
          i3(e4);
        }
        return e4[r3].weakData;
      }, onFreeze: function(e4) {
        return Yi2 && n3 && Li2(e4) && !Oe3(e4, r3) && i3(e4), e4;
      }};
      ft2[r3] = true;
    });
    ji2.enable, ji2.fastKey, ji2.getWeakData, ji2.onFreeze;
    var Ji2 = C3.TypeError;
    var Ni2 = function(e3, t3) {
      this.stopped = e3, this.result = t3;
    };
    var Pi2 = Ni2.prototype;
    var Gi2 = function(e3, t3, n3) {
      var r3, o3, i3, a3, c3, s3, u3, l3 = n3 && n3.that, f3 = !(!n3 || !n3.AS_ENTRIES), d3 = !(!n3 || !n3.IS_ITERATOR), h3 = !(!n3 || !n3.INTERRUPTED), p3 = yr(t3, l3), y3 = function(e4) {
        return r3 && jo(r3, "normal", e4), new Ni2(true, e4);
      }, m3 = function(e4) {
        return f3 ? (qe3(e4), h3 ? p3(e4[0], e4[1], y3) : p3(e4[0], e4[1])) : h3 ? p3(e4, y3) : p3(e4);
      };
      if (d3)
        r3 = e3;
      else {
        if (!(o3 = Bo(e3)))
          throw Ji2(be3(e3) + " is not iterable");
        if (Go(o3)) {
          for (i3 = 0, a3 = xt2(e3); a3 > i3; i3++)
            if ((c3 = m3(e3[i3])) && ae3(Pi2, c3))
              return c3;
          return new Ni2(false);
        }
        r3 = Ho(e3, o3);
      }
      for (s3 = r3.next; !(u3 = X3(s3, r3)).done; ) {
        try {
          c3 = m3(u3.value);
        } catch (e4) {
          jo(r3, "throw", e4);
        }
        if (typeof c3 == "object" && c3 && ae3(Pi2, c3))
          return c3;
      }
      return new Ni2(false);
    };
    var Ai2 = C3.TypeError;
    var Bi2 = function(e3, t3) {
      if (ae3(t3, e3))
        return e3;
      throw Ai2("Incorrect invocation");
    };
    var zi2 = function(e3, t3, n3) {
      for (var r3 in t3)
        Tt2(e3, r3, t3[r3], n3);
      return e3;
    };
    var Hi2 = Ye3("species");
    var Di2 = et3.f;
    var Mi2 = ji2.fastKey;
    var qi2 = gt3.set;
    var Qi2 = gt3.getterFor;
    var $i2 = {getConstructor: function(e3, t3, n3, r3) {
      var o3 = e3(function(e4, o4) {
        Bi2(e4, i3), qi2(e4, {type: t3, index: nr(null), first: void 0, last: void 0, size: 0}), W3 || (e4.size = 0), o4 != null && Gi2(o4, e4[r3], {that: e4, AS_ENTRIES: n3});
      }), i3 = o3.prototype, a3 = Qi2(t3), c3 = function(e4, t4, n4) {
        var r4, o4, i4 = a3(e4), c4 = s3(e4, t4);
        return c4 ? c4.value = n4 : (i4.last = c4 = {index: o4 = Mi2(t4, true), key: t4, value: n4, previous: r4 = i4.last, next: void 0, removed: false}, i4.first || (i4.first = c4), r4 && (r4.next = c4), W3 ? i4.size++ : e4.size++, o4 !== "F" && (i4.index[o4] = c4)), e4;
      }, s3 = function(e4, t4) {
        var n4, r4 = a3(e4), o4 = Mi2(t4);
        if (o4 !== "F")
          return r4.index[o4];
        for (n4 = r4.first; n4; n4 = n4.next)
          if (n4.key == t4)
            return n4;
      };
      return zi2(i3, {clear: function() {
        for (var e4 = a3(this), t4 = e4.index, n4 = e4.first; n4; )
          n4.removed = true, n4.previous && (n4.previous = n4.previous.next = void 0), delete t4[n4.index], n4 = n4.next;
        e4.first = e4.last = void 0, W3 ? e4.size = 0 : this.size = 0;
      }, delete: function(e4) {
        var t4 = this, n4 = a3(t4), r4 = s3(t4, e4);
        if (r4) {
          var o4 = r4.next, i4 = r4.previous;
          delete n4.index[r4.index], r4.removed = true, i4 && (i4.next = o4), o4 && (o4.previous = i4), n4.first == r4 && (n4.first = o4), n4.last == r4 && (n4.last = i4), W3 ? n4.size-- : t4.size--;
        }
        return !!r4;
      }, forEach: function(e4) {
        for (var t4, n4 = a3(this), r4 = yr(e4, arguments.length > 1 ? arguments[1] : void 0); t4 = t4 ? t4.next : n4.first; )
          for (r4(t4.value, t4.key, this); t4 && t4.removed; )
            t4 = t4.previous;
      }, has: function(e4) {
        return !!s3(this, e4);
      }}), zi2(i3, n3 ? {get: function(e4) {
        var t4 = s3(this, e4);
        return t4 && t4.value;
      }, set: function(e4, t4) {
        return c3(this, e4 === 0 ? 0 : e4, t4);
      }} : {add: function(e4) {
        return c3(this, e4 = e4 === 0 ? 0 : e4, e4);
      }}), W3 && Di2(i3, "size", {get: function() {
        return a3(this).size;
      }}), o3;
    }, setStrong: function(e3, t3, n3) {
      var r3 = t3 + " Iterator", o3 = Qi2(t3), i3 = Qi2(r3);
      Uo(e3, t3, function(e4, t4) {
        qi2(this, {type: r3, target: e4, state: o3(e4), kind: t4, last: void 0});
      }, function() {
        for (var e4 = i3(this), t4 = e4.kind, n4 = e4.last; n4 && n4.removed; )
          n4 = n4.previous;
        return e4.target && (e4.last = n4 = n4 ? n4.next : e4.state.first) ? t4 == "keys" ? {value: n4.key, done: false} : t4 == "values" ? {value: n4.value, done: false} : {value: [n4.key, n4.value], done: false} : (e4.target = void 0, {value: void 0, done: true});
      }, n3 ? "entries" : "values", !n3, true), function(e4) {
        var t4 = ie3(e4), n4 = et3.f;
        W3 && t4 && !t4[Hi2] && n4(t4, Hi2, {configurable: true, get: function() {
          return this;
        }});
      }(t3);
    }};
    function ea(e3) {
      var t3 = this.constructor;
      return this.then(function(n3) {
        return t3.resolve(e3()).then(function() {
          return n3;
        });
      }, function(n3) {
        return t3.resolve(e3()).then(function() {
          return t3.reject(n3);
        });
      });
    }
    function ta(e3) {
      return new this(function(t3, n3) {
        if (!e3 || e3.length === void 0)
          return n3(new TypeError(typeof e3 + " " + e3 + " is not iterable(cannot read property Symbol(Symbol.iterator))"));
        var r3 = Array.prototype.slice.call(e3);
        if (r3.length === 0)
          return t3([]);
        var o3 = r3.length;
        function i3(e4, n4) {
          if (n4 && (typeof n4 == "object" || typeof n4 == "function")) {
            var a4 = n4.then;
            if (typeof a4 == "function")
              return void a4.call(n4, function(t4) {
                i3(e4, t4);
              }, function(n5) {
                r3[e4] = {status: "rejected", reason: n5}, --o3 == 0 && t3(r3);
              });
          }
          r3[e4] = {status: "fulfilled", value: n4}, --o3 == 0 && t3(r3);
        }
        for (var a3 = 0; a3 < r3.length; a3++)
          i3(a3, r3[a3]);
      });
    }
    !function(e3, t3, n3) {
      var r3 = e3.indexOf("Map") !== -1, o3 = e3.indexOf("Weak") !== -1, i3 = r3 ? "set" : "add", a3 = C3[e3], c3 = a3 && a3.prototype, s3 = a3, u3 = {}, l3 = function(e4) {
        var t4 = B3(c3[e4]);
        Tt2(c3, e4, e4 == "add" ? function(e5) {
          return t4(this, e5 === 0 ? 0 : e5), this;
        } : e4 == "delete" ? function(e5) {
          return !(o3 && !re3(e5)) && t4(this, e5 === 0 ? 0 : e5);
        } : e4 == "get" ? function(e5) {
          return o3 && !re3(e5) ? void 0 : t4(this, e5 === 0 ? 0 : e5);
        } : e4 == "has" ? function(e5) {
          return !(o3 && !re3(e5)) && t4(this, e5 === 0 ? 0 : e5);
        } : function(e5, n4) {
          return t4(this, e5 === 0 ? 0 : e5, n4), this;
        });
      };
      if (qt2(e3, !ne3(a3) || !(o3 || c3.forEach && !V3(function() {
        new a3().entries().next();
      }))))
        s3 = n3.getConstructor(t3, e3, r3, i3), ji2.enable();
      else if (qt2(e3, true)) {
        var f3 = new s3(), d3 = f3[i3](o3 ? {} : -0, 1) != f3, h3 = V3(function() {
          f3.has(1);
        }), p3 = ei2(function(e4) {
          new a3(e4);
        }), y3 = !o3 && V3(function() {
          for (var e4 = new a3(), t4 = 5; t4--; )
            e4[i3](t4, t4);
          return !e4.has(-0);
        });
        p3 || ((s3 = t3(function(e4, t4) {
          Bi2(e4, c3);
          var n4 = function(e5, t5, n5) {
            var r4, o4;
            return Eo && ne3(r4 = t5.constructor) && r4 !== n5 && re3(o4 = r4.prototype) && o4 !== n5.prototype && Eo(e5, o4), e5;
          }(new a3(), e4, s3);
          return t4 != null && Gi2(t4, n4[i3], {that: n4, AS_ENTRIES: r3}), n4;
        })).prototype = c3, c3.constructor = s3), (h3 || y3) && (l3("delete"), l3("has"), r3 && l3("get")), (y3 || d3) && l3(i3), o3 && c3.clear && delete c3.clear;
      }
      u3[e3] = s3, $t2({global: true, forced: s3 != a3}, u3), hr(s3, e3), o3 || n3.setStrong(s3, e3, r3);
    }("Set", function(e3) {
      return function() {
        return e3(this, arguments.length ? arguments[0] : void 0);
      };
    }, $i2), sr.Set;
    var na = setTimeout;
    var ra = typeof setImmediate != "undefined" ? setImmediate : null;
    function oa(e3) {
      return Boolean(e3 && e3.length !== void 0);
    }
    function ia() {
    }
    function aa(e3) {
      if (!(this instanceof aa))
        throw new TypeError("Promises must be constructed via new");
      if (typeof e3 != "function")
        throw new TypeError("not a function");
      this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], da(e3, this);
    }
    function ca(e3, t3) {
      for (; e3._state === 3; )
        e3 = e3._value;
      e3._state !== 0 ? (e3._handled = true, aa._immediateFn(function() {
        var n3 = e3._state === 1 ? t3.onFulfilled : t3.onRejected;
        if (n3 !== null) {
          var r3;
          try {
            r3 = n3(e3._value);
          } catch (e4) {
            return void ua(t3.promise, e4);
          }
          sa(t3.promise, r3);
        } else
          (e3._state === 1 ? sa : ua)(t3.promise, e3._value);
      })) : e3._deferreds.push(t3);
    }
    function sa(e3, t3) {
      try {
        if (t3 === e3)
          throw new TypeError("A promise cannot be resolved with itself.");
        if (t3 && (typeof t3 == "object" || typeof t3 == "function")) {
          var n3 = t3.then;
          if (t3 instanceof aa)
            return e3._state = 3, e3._value = t3, void la(e3);
          if (typeof n3 == "function")
            return void da((r3 = n3, o3 = t3, function() {
              r3.apply(o3, arguments);
            }), e3);
        }
        e3._state = 1, e3._value = t3, la(e3);
      } catch (t4) {
        ua(e3, t4);
      }
      var r3, o3;
    }
    function ua(e3, t3) {
      e3._state = 2, e3._value = t3, la(e3);
    }
    function la(e3) {
      e3._state === 2 && e3._deferreds.length === 0 && aa._immediateFn(function() {
        e3._handled || aa._unhandledRejectionFn(e3._value);
      });
      for (var t3 = 0, n3 = e3._deferreds.length; t3 < n3; t3++)
        ca(e3, e3._deferreds[t3]);
      e3._deferreds = null;
    }
    function fa(e3, t3, n3) {
      this.onFulfilled = typeof e3 == "function" ? e3 : null, this.onRejected = typeof t3 == "function" ? t3 : null, this.promise = n3;
    }
    function da(e3, t3) {
      var n3 = false;
      try {
        e3(function(e4) {
          n3 || (n3 = true, sa(t3, e4));
        }, function(e4) {
          n3 || (n3 = true, ua(t3, e4));
        });
      } catch (e4) {
        if (n3)
          return;
        n3 = true, ua(t3, e4);
      }
    }
    aa.prototype.catch = function(e3) {
      return this.then(null, e3);
    }, aa.prototype.then = function(e3, t3) {
      var n3 = new this.constructor(ia);
      return ca(this, new fa(e3, t3, n3)), n3;
    }, aa.prototype.finally = ea, aa.all = function(e3) {
      return new aa(function(t3, n3) {
        if (!oa(e3))
          return n3(new TypeError("Promise.all accepts an array"));
        var r3 = Array.prototype.slice.call(e3);
        if (r3.length === 0)
          return t3([]);
        var o3 = r3.length;
        function i3(e4, a4) {
          try {
            if (a4 && (typeof a4 == "object" || typeof a4 == "function")) {
              var c3 = a4.then;
              if (typeof c3 == "function")
                return void c3.call(a4, function(t4) {
                  i3(e4, t4);
                }, n3);
            }
            r3[e4] = a4, --o3 == 0 && t3(r3);
          } catch (e5) {
            n3(e5);
          }
        }
        for (var a3 = 0; a3 < r3.length; a3++)
          i3(a3, r3[a3]);
      });
    }, aa.allSettled = ta, aa.resolve = function(e3) {
      return e3 && typeof e3 == "object" && e3.constructor === aa ? e3 : new aa(function(t3) {
        t3(e3);
      });
    }, aa.reject = function(e3) {
      return new aa(function(t3, n3) {
        n3(e3);
      });
    }, aa.race = function(e3) {
      return new aa(function(t3, n3) {
        if (!oa(e3))
          return n3(new TypeError("Promise.race accepts an array"));
        for (var r3 = 0, o3 = e3.length; r3 < o3; r3++)
          aa.resolve(e3[r3]).then(t3, n3);
      });
    }, aa._immediateFn = typeof ra == "function" && function(e3) {
      ra(e3);
    } || function(e3) {
      na(e3, 0);
    }, aa._unhandledRejectionFn = function(e3) {
      typeof console != "undefined" && console && console.warn("Possible Unhandled Promise Rejection:", e3);
    };
    var ha = function() {
      if (typeof self != "undefined")
        return self;
      if (typeof window != "undefined")
        return window;
      if (typeof global != "undefined")
        return global;
      throw new Error("unable to locate global object");
    }();
    typeof ha.Promise != "function" ? ha.Promise = aa : (ha.Promise.prototype.finally || (ha.Promise.prototype.finally = ea), ha.Promise.allSettled || (ha.Promise.allSettled = ta)), function(e3) {
      function t3() {
      }
      function n3(e4, t4) {
        if (e4 = e4 === void 0 ? "utf-8" : e4, t4 = t4 === void 0 ? {fatal: false} : t4, o3.indexOf(e4.toLowerCase()) === -1)
          throw new RangeError("Failed to construct 'TextDecoder': The encoding label provided ('" + e4 + "') is invalid.");
        if (t4.fatal)
          throw Error("Failed to construct 'TextDecoder': the 'fatal' option is unsupported.");
      }
      function r3(e4) {
        for (var t4 = 0, n4 = Math.min(65536, e4.length + 1), r4 = new Uint16Array(n4), o4 = [], i4 = 0; ; ) {
          var a3 = t4 < e4.length;
          if (!a3 || i4 >= n4 - 1) {
            if (o4.push(String.fromCharCode.apply(null, r4.subarray(0, i4))), !a3)
              return o4.join("");
            e4 = e4.subarray(t4), i4 = t4 = 0;
          }
          if ((128 & (a3 = e4[t4++])) == 0)
            r4[i4++] = a3;
          else if ((224 & a3) == 192) {
            var c3 = 63 & e4[t4++];
            r4[i4++] = (31 & a3) << 6 | c3;
          } else if ((240 & a3) == 224) {
            c3 = 63 & e4[t4++];
            var s3 = 63 & e4[t4++];
            r4[i4++] = (31 & a3) << 12 | c3 << 6 | s3;
          } else
            (248 & a3) == 240 && (65535 < (a3 = (7 & a3) << 18 | (c3 = 63 & e4[t4++]) << 12 | (s3 = 63 & e4[t4++]) << 6 | 63 & e4[t4++]) && (a3 -= 65536, r4[i4++] = a3 >>> 10 & 1023 | 55296, a3 = 56320 | 1023 & a3), r4[i4++] = a3);
        }
      }
      if (e3.TextEncoder && e3.TextDecoder)
        return false;
      var o3 = ["utf-8", "utf8", "unicode-1-1-utf-8"];
      Object.defineProperty(t3.prototype, "encoding", {value: "utf-8"}), t3.prototype.encode = function(e4, t4) {
        if ((t4 = t4 === void 0 ? {stream: false} : t4).stream)
          throw Error("Failed to encode: the 'stream' option is unsupported.");
        t4 = 0;
        for (var n4 = e4.length, r4 = 0, o4 = Math.max(32, n4 + (n4 >>> 1) + 7), i4 = new Uint8Array(o4 >>> 3 << 3); t4 < n4; ) {
          var a3 = e4.charCodeAt(t4++);
          if (55296 <= a3 && 56319 >= a3) {
            if (t4 < n4) {
              var c3 = e4.charCodeAt(t4);
              (64512 & c3) == 56320 && (++t4, a3 = ((1023 & a3) << 10) + (1023 & c3) + 65536);
            }
            if (55296 <= a3 && 56319 >= a3)
              continue;
          }
          if (r4 + 4 > i4.length && (o4 += 8, o4 = (o4 *= 1 + t4 / e4.length * 2) >>> 3 << 3, (c3 = new Uint8Array(o4)).set(i4), i4 = c3), (4294967168 & a3) == 0)
            i4[r4++] = a3;
          else {
            if ((4294965248 & a3) == 0)
              i4[r4++] = a3 >>> 6 & 31 | 192;
            else if ((4294901760 & a3) == 0)
              i4[r4++] = a3 >>> 12 & 15 | 224, i4[r4++] = a3 >>> 6 & 63 | 128;
            else {
              if ((4292870144 & a3) != 0)
                continue;
              i4[r4++] = a3 >>> 18 & 7 | 240, i4[r4++] = a3 >>> 12 & 63 | 128, i4[r4++] = a3 >>> 6 & 63 | 128;
            }
            i4[r4++] = 63 & a3 | 128;
          }
        }
        return i4.slice ? i4.slice(0, r4) : i4.subarray(0, r4);
      }, Object.defineProperty(n3.prototype, "encoding", {value: "utf-8"}), Object.defineProperty(n3.prototype, "fatal", {value: false}), Object.defineProperty(n3.prototype, "ignoreBOM", {value: false});
      var i3 = r3;
      typeof Buffer == "function" && Buffer.from ? i3 = function(e4) {
        return Buffer.from(e4.buffer, e4.byteOffset, e4.byteLength).toString("utf-8");
      } : typeof Blob == "function" && typeof URL == "function" && typeof URL.createObjectURL == "function" && (i3 = function(e4) {
        var t4 = URL.createObjectURL(new Blob([e4], {type: "text/plain;charset=UTF-8"}));
        try {
          var n4 = new XMLHttpRequest();
          return n4.open("GET", t4, false), n4.send(), n4.responseText;
        } catch (t5) {
          return r3(e4);
        } finally {
          URL.revokeObjectURL(t4);
        }
      }), n3.prototype.decode = function(e4, t4) {
        if ((t4 = t4 === void 0 ? {stream: false} : t4).stream)
          throw Error("Failed to decode: the 'stream' option is unsupported.");
        return e4 = e4 instanceof Uint8Array ? e4 : e4.buffer instanceof ArrayBuffer ? new Uint8Array(e4.buffer) : new Uint8Array(e4), i3(e4);
      }, e3.TextEncoder = t3, e3.TextDecoder = n3;
    }(typeof window != "undefined" ? window : Z3), function() {
      function e3(e4, t4) {
        if (!(e4 instanceof t4))
          throw new TypeError("Cannot call a class as a function");
      }
      function t3(e4, t4) {
        for (var n4 = 0; n4 < t4.length; n4++) {
          var r4 = t4[n4];
          r4.enumerable = r4.enumerable || false, r4.configurable = true, "value" in r4 && (r4.writable = true), Object.defineProperty(e4, r4.key, r4);
        }
      }
      function n3(e4, n4, r4) {
        return n4 && t3(e4.prototype, n4), r4 && t3(e4, r4), e4;
      }
      function r3(e4, t4) {
        if (typeof t4 != "function" && t4 !== null)
          throw new TypeError("Super expression must either be null or a function");
        e4.prototype = Object.create(t4 && t4.prototype, {constructor: {value: e4, writable: true, configurable: true}}), t4 && i3(e4, t4);
      }
      function o3(e4) {
        return (o3 = Object.setPrototypeOf ? Object.getPrototypeOf : function(e5) {
          return e5.__proto__ || Object.getPrototypeOf(e5);
        })(e4);
      }
      function i3(e4, t4) {
        return (i3 = Object.setPrototypeOf || function(e5, t5) {
          return e5.__proto__ = t5, e5;
        })(e4, t4);
      }
      function a3(e4) {
        if (e4 === void 0)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e4;
      }
      function c3(e4, t4) {
        return !t4 || typeof t4 != "object" && typeof t4 != "function" ? a3(e4) : t4;
      }
      function s3(e4) {
        var t4 = function() {
          if (typeof Reflect == "undefined" || !Reflect.construct)
            return false;
          if (Reflect.construct.sham)
            return false;
          if (typeof Proxy == "function")
            return true;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
            })), true;
          } catch (e5) {
            return false;
          }
        }();
        return function() {
          var n4, r4 = o3(e4);
          if (t4) {
            var i4 = o3(this).constructor;
            n4 = Reflect.construct(r4, arguments, i4);
          } else
            n4 = r4.apply(this, arguments);
          return c3(this, n4);
        };
      }
      function u3(e4, t4) {
        for (; !Object.prototype.hasOwnProperty.call(e4, t4) && (e4 = o3(e4)) !== null; )
          ;
        return e4;
      }
      function l3(e4, t4, n4) {
        return (l3 = typeof Reflect != "undefined" && Reflect.get ? Reflect.get : function(e5, t5, n5) {
          var r4 = u3(e5, t5);
          if (r4) {
            var o4 = Object.getOwnPropertyDescriptor(r4, t5);
            return o4.get ? o4.get.call(n5) : o4.value;
          }
        })(e4, t4, n4 || e4);
      }
      var f3 = function() {
        function t4() {
          e3(this, t4), Object.defineProperty(this, "listeners", {value: {}, writable: true, configurable: true});
        }
        return n3(t4, [{key: "addEventListener", value: function(e4, t5, n4) {
          e4 in this.listeners || (this.listeners[e4] = []), this.listeners[e4].push({callback: t5, options: n4});
        }}, {key: "removeEventListener", value: function(e4, t5) {
          if (e4 in this.listeners) {
            for (var n4 = this.listeners[e4], r4 = 0, o4 = n4.length; r4 < o4; r4++)
              if (n4[r4].callback === t5)
                return void n4.splice(r4, 1);
          }
        }}, {key: "dispatchEvent", value: function(e4) {
          if (e4.type in this.listeners) {
            for (var t5 = this.listeners[e4.type].slice(), n4 = 0, r4 = t5.length; n4 < r4; n4++) {
              var o4 = t5[n4];
              try {
                o4.callback.call(this, e4);
              } catch (e5) {
                Promise.resolve().then(function() {
                  throw e5;
                });
              }
              o4.options && o4.options.once && this.removeEventListener(e4.type, o4.callback);
            }
            return !e4.defaultPrevented;
          }
        }}]), t4;
      }(), d3 = function(t4) {
        r3(c4, t4);
        var i4 = s3(c4);
        function c4() {
          var t5;
          return e3(this, c4), (t5 = i4.call(this)).listeners || f3.call(a3(t5)), Object.defineProperty(a3(t5), "aborted", {value: false, writable: true, configurable: true}), Object.defineProperty(a3(t5), "onabort", {value: null, writable: true, configurable: true}), t5;
        }
        return n3(c4, [{key: "toString", value: function() {
          return "[object AbortSignal]";
        }}, {key: "dispatchEvent", value: function(e4) {
          e4.type === "abort" && (this.aborted = true, typeof this.onabort == "function" && this.onabort.call(this, e4)), l3(o3(c4.prototype), "dispatchEvent", this).call(this, e4);
        }}]), c4;
      }(f3), h3 = function() {
        function t4() {
          e3(this, t4), Object.defineProperty(this, "signal", {value: new d3(), writable: true, configurable: true});
        }
        return n3(t4, [{key: "abort", value: function() {
          var e4;
          try {
            e4 = new Event("abort");
          } catch (t5) {
            typeof document != "undefined" ? document.createEvent ? (e4 = document.createEvent("Event")).initEvent("abort", false, false) : (e4 = document.createEventObject()).type = "abort" : e4 = {type: "abort", bubbles: false, cancelable: false};
          }
          this.signal.dispatchEvent(e4);
        }}, {key: "toString", value: function() {
          return "[object AbortController]";
        }}]), t4;
      }();
      typeof Symbol != "undefined" && Symbol.toStringTag && (h3.prototype[Symbol.toStringTag] = "AbortController", d3.prototype[Symbol.toStringTag] = "AbortSignal"), function(e4) {
        (function(e5) {
          return e5.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL ? (console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill"), true) : typeof e5.Request == "function" && !e5.Request.prototype.hasOwnProperty("signal") || !e5.AbortController;
        })(e4) && (e4.AbortController = h3, e4.AbortSignal = d3);
      }(typeof self != "undefined" ? self : Z3);
    }();
    var pa = E3(function(e3, t3) {
      Object.defineProperty(t3, "__esModule", {value: true});
      var n3 = function() {
        function e4() {
          var e5 = this;
          this.locked = new Map(), this.addToLocked = function(t4, n4) {
            var r3 = e5.locked.get(t4);
            r3 === void 0 ? n4 === void 0 ? e5.locked.set(t4, []) : e5.locked.set(t4, [n4]) : n4 !== void 0 && (r3.unshift(n4), e5.locked.set(t4, r3));
          }, this.isLocked = function(t4) {
            return e5.locked.has(t4);
          }, this.lock = function(t4) {
            return new Promise(function(n4, r3) {
              e5.isLocked(t4) ? e5.addToLocked(t4, n4) : (e5.addToLocked(t4), n4());
            });
          }, this.unlock = function(t4) {
            var n4 = e5.locked.get(t4);
            if (n4 !== void 0 && n4.length !== 0) {
              var r3 = n4.pop();
              e5.locked.set(t4, n4), r3 !== void 0 && setTimeout(r3, 0);
            } else
              e5.locked.delete(t4);
          };
        }
        return e4.getInstance = function() {
          return e4.instance === void 0 && (e4.instance = new e4()), e4.instance;
        }, e4;
      }();
      t3.default = function() {
        return n3.getInstance();
      };
    });
    R3(pa);
    var ya = R3(E3(function(e3, t3) {
      var n3 = Z3 && Z3.__awaiter || function(e4, t4, n4, r4) {
        return new (n4 || (n4 = Promise))(function(o4, i4) {
          function a4(e5) {
            try {
              s3(r4.next(e5));
            } catch (e6) {
              i4(e6);
            }
          }
          function c4(e5) {
            try {
              s3(r4.throw(e5));
            } catch (e6) {
              i4(e6);
            }
          }
          function s3(e5) {
            e5.done ? o4(e5.value) : new n4(function(t5) {
              t5(e5.value);
            }).then(a4, c4);
          }
          s3((r4 = r4.apply(e4, t4 || [])).next());
        });
      }, r3 = Z3 && Z3.__generator || function(e4, t4) {
        var n4, r4, o4, i4, a4 = {label: 0, sent: function() {
          if (1 & o4[0])
            throw o4[1];
          return o4[1];
        }, trys: [], ops: []};
        return i4 = {next: c4(0), throw: c4(1), return: c4(2)}, typeof Symbol == "function" && (i4[Symbol.iterator] = function() {
          return this;
        }), i4;
        function c4(i5) {
          return function(c5) {
            return function(i6) {
              if (n4)
                throw new TypeError("Generator is already executing.");
              for (; a4; )
                try {
                  if (n4 = 1, r4 && (o4 = 2 & i6[0] ? r4.return : i6[0] ? r4.throw || ((o4 = r4.return) && o4.call(r4), 0) : r4.next) && !(o4 = o4.call(r4, i6[1])).done)
                    return o4;
                  switch (r4 = 0, o4 && (i6 = [2 & i6[0], o4.value]), i6[0]) {
                    case 0:
                    case 1:
                      o4 = i6;
                      break;
                    case 4:
                      return a4.label++, {value: i6[1], done: false};
                    case 5:
                      a4.label++, r4 = i6[1], i6 = [0];
                      continue;
                    case 7:
                      i6 = a4.ops.pop(), a4.trys.pop();
                      continue;
                    default:
                      if (!((o4 = (o4 = a4.trys).length > 0 && o4[o4.length - 1]) || i6[0] !== 6 && i6[0] !== 2)) {
                        a4 = 0;
                        continue;
                      }
                      if (i6[0] === 3 && (!o4 || i6[1] > o4[0] && i6[1] < o4[3])) {
                        a4.label = i6[1];
                        break;
                      }
                      if (i6[0] === 6 && a4.label < o4[1]) {
                        a4.label = o4[1], o4 = i6;
                        break;
                      }
                      if (o4 && a4.label < o4[2]) {
                        a4.label = o4[2], a4.ops.push(i6);
                        break;
                      }
                      o4[2] && a4.ops.pop(), a4.trys.pop();
                      continue;
                  }
                  i6 = t4.call(e4, a4);
                } catch (e5) {
                  i6 = [6, e5], r4 = 0;
                } finally {
                  n4 = o4 = 0;
                }
              if (5 & i6[0])
                throw i6[1];
              return {value: i6[0] ? i6[1] : void 0, done: true};
            }([i5, c5]);
          };
        }
      };
      Object.defineProperty(t3, "__esModule", {value: true});
      var o3 = "browser-tabs-lock-key";
      function i3(e4) {
        return new Promise(function(t4) {
          return setTimeout(t4, e4);
        });
      }
      function a3(e4) {
        for (var t4 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz", n4 = "", r4 = 0; r4 < e4; r4++)
          n4 += t4[Math.floor(Math.random() * t4.length)];
        return n4;
      }
      var c3 = function() {
        function e4() {
          this.acquiredIatSet = new Set(), this.id = Date.now().toString() + a3(15), this.acquireLock = this.acquireLock.bind(this), this.releaseLock = this.releaseLock.bind(this), this.releaseLock__private__ = this.releaseLock__private__.bind(this), this.waitForSomethingToChange = this.waitForSomethingToChange.bind(this), this.refreshLockWhileAcquired = this.refreshLockWhileAcquired.bind(this), e4.waiters === void 0 && (e4.waiters = []);
        }
        return e4.prototype.acquireLock = function(t4, c4) {
          return c4 === void 0 && (c4 = 5e3), n3(this, void 0, void 0, function() {
            var n4, s3, u3, l3, f3, d3;
            return r3(this, function(r4) {
              switch (r4.label) {
                case 0:
                  n4 = Date.now() + a3(4), s3 = Date.now() + c4, u3 = o3 + "-" + t4, l3 = window.localStorage, r4.label = 1;
                case 1:
                  return Date.now() < s3 ? [4, i3(30)] : [3, 8];
                case 2:
                  return r4.sent(), l3.getItem(u3) !== null ? [3, 5] : (f3 = this.id + "-" + t4 + "-" + n4, [4, i3(Math.floor(25 * Math.random()))]);
                case 3:
                  return r4.sent(), l3.setItem(u3, JSON.stringify({id: this.id, iat: n4, timeoutKey: f3, timeAcquired: Date.now(), timeRefreshed: Date.now()})), [4, i3(30)];
                case 4:
                  return r4.sent(), (d3 = l3.getItem(u3)) !== null && (d3 = JSON.parse(d3)).id === this.id && d3.iat === n4 ? (this.acquiredIatSet.add(n4), this.refreshLockWhileAcquired(u3, n4), [2, true]) : [3, 7];
                case 5:
                  return e4.lockCorrector(), [4, this.waitForSomethingToChange(s3)];
                case 6:
                  r4.sent(), r4.label = 7;
                case 7:
                  return n4 = Date.now() + a3(4), [3, 1];
                case 8:
                  return [2, false];
              }
            });
          });
        }, e4.prototype.refreshLockWhileAcquired = function(e5, t4) {
          return n3(this, void 0, void 0, function() {
            var o4 = this;
            return r3(this, function(i4) {
              return setTimeout(function() {
                return n3(o4, void 0, void 0, function() {
                  var n4, o5;
                  return r3(this, function(r4) {
                    switch (r4.label) {
                      case 0:
                        return [4, pa.default().lock(t4)];
                      case 1:
                        return r4.sent(), this.acquiredIatSet.has(t4) ? (n4 = window.localStorage, (o5 = n4.getItem(e5)) === null ? (pa.default().unlock(t4), [2]) : ((o5 = JSON.parse(o5)).timeRefreshed = Date.now(), n4.setItem(e5, JSON.stringify(o5)), pa.default().unlock(t4), this.refreshLockWhileAcquired(e5, t4), [2])) : (pa.default().unlock(t4), [2]);
                    }
                  });
                });
              }, 1e3), [2];
            });
          });
        }, e4.prototype.waitForSomethingToChange = function(t4) {
          return n3(this, void 0, void 0, function() {
            return r3(this, function(n4) {
              switch (n4.label) {
                case 0:
                  return [4, new Promise(function(n5) {
                    var r4 = false, o4 = Date.now(), i4 = false;
                    function a4() {
                      if (i4 || (window.removeEventListener("storage", a4), e4.removeFromWaiting(a4), clearTimeout(c4), i4 = true), !r4) {
                        r4 = true;
                        var t5 = 50 - (Date.now() - o4);
                        t5 > 0 ? setTimeout(n5, t5) : n5();
                      }
                    }
                    window.addEventListener("storage", a4), e4.addToWaiting(a4);
                    var c4 = setTimeout(a4, Math.max(0, t4 - Date.now()));
                  })];
                case 1:
                  return n4.sent(), [2];
              }
            });
          });
        }, e4.addToWaiting = function(t4) {
          this.removeFromWaiting(t4), e4.waiters !== void 0 && e4.waiters.push(t4);
        }, e4.removeFromWaiting = function(t4) {
          e4.waiters !== void 0 && (e4.waiters = e4.waiters.filter(function(e5) {
            return e5 !== t4;
          }));
        }, e4.notifyWaiters = function() {
          e4.waiters !== void 0 && e4.waiters.slice().forEach(function(e5) {
            return e5();
          });
        }, e4.prototype.releaseLock = function(e5) {
          return n3(this, void 0, void 0, function() {
            return r3(this, function(t4) {
              switch (t4.label) {
                case 0:
                  return [4, this.releaseLock__private__(e5)];
                case 1:
                  return [2, t4.sent()];
              }
            });
          });
        }, e4.prototype.releaseLock__private__ = function(t4) {
          return n3(this, void 0, void 0, function() {
            var n4, i4, a4;
            return r3(this, function(r4) {
              switch (r4.label) {
                case 0:
                  return n4 = window.localStorage, i4 = o3 + "-" + t4, (a4 = n4.getItem(i4)) === null ? [2] : (a4 = JSON.parse(a4)).id !== this.id ? [3, 2] : [4, pa.default().lock(a4.iat)];
                case 1:
                  r4.sent(), this.acquiredIatSet.delete(a4.iat), n4.removeItem(i4), pa.default().unlock(a4.iat), e4.notifyWaiters(), r4.label = 2;
                case 2:
                  return [2];
              }
            });
          });
        }, e4.lockCorrector = function() {
          for (var t4 = Date.now() - 5e3, n4 = window.localStorage, r4 = Object.keys(n4), i4 = false, a4 = 0; a4 < r4.length; a4++) {
            var c4 = r4[a4];
            if (c4.includes(o3)) {
              var s3 = n4.getItem(c4);
              s3 !== null && ((s3 = JSON.parse(s3)).timeRefreshed === void 0 && s3.timeAcquired < t4 || s3.timeRefreshed !== void 0 && s3.timeRefreshed < t4) && (n4.removeItem(c4), i4 = true);
            }
          }
          i4 && e4.notifyWaiters();
        }, e4.waiters = void 0, e4;
      }();
      t3.default = c3;
    }));
    var ma = {timeoutInSeconds: 60};
    var va = ["login_required", "consent_required", "interaction_required", "account_selection_required", "access_denied"];
    var ba = {name: "auth0-spa-js", version: "1.19.3"};
    var ga = function() {
      return Date.now();
    };
    var wa = function(e3) {
      function t3(n3, r3) {
        var o3 = e3.call(this, r3) || this;
        return o3.error = n3, o3.error_description = r3, Object.setPrototypeOf(o3, t3.prototype), o3;
      }
      return w3(t3, e3), t3.fromPayload = function(e4) {
        return new t3(e4.error, e4.error_description);
      }, t3;
    }(Error);
    var Sa = function(e3) {
      function t3(n3, r3, o3, i3) {
        i3 === void 0 && (i3 = null);
        var a3 = e3.call(this, n3, r3) || this;
        return a3.state = o3, a3.appState = i3, Object.setPrototypeOf(a3, t3.prototype), a3;
      }
      return w3(t3, e3), t3;
    }(wa);
    var Ia = function(e3) {
      function t3() {
        var n3 = e3.call(this, "timeout", "Timeout") || this;
        return Object.setPrototypeOf(n3, t3.prototype), n3;
      }
      return w3(t3, e3), t3;
    }(wa);
    var ka = function(e3) {
      function t3(n3) {
        var r3 = e3.call(this) || this;
        return r3.popup = n3, Object.setPrototypeOf(r3, t3.prototype), r3;
      }
      return w3(t3, e3), t3;
    }(Ia);
    var Ta = function(e3) {
      function t3(n3) {
        var r3 = e3.call(this, "cancelled", "Popup closed") || this;
        return r3.popup = n3, Object.setPrototypeOf(r3, t3.prototype), r3;
      }
      return w3(t3, e3), t3;
    }(wa);
    var _a = function(e3) {
      function t3(n3, r3, o3) {
        var i3 = e3.call(this, n3, r3) || this;
        return i3.mfa_token = o3, Object.setPrototypeOf(i3, t3.prototype), i3;
      }
      return w3(t3, e3), t3;
    }(wa);
    var Ka = function(e3) {
      return new Promise(function(t3, n3) {
        var r3, o3 = setInterval(function() {
          e3.popup && e3.popup.closed && (clearInterval(o3), clearTimeout(i3), window.removeEventListener("message", r3, false), n3(new Ta(e3.popup)));
        }, 1e3), i3 = setTimeout(function() {
          clearInterval(o3), n3(new ka(e3.popup)), window.removeEventListener("message", r3, false);
        }, 1e3 * (e3.timeoutInSeconds || 60));
        r3 = function(a3) {
          if (a3.data && a3.data.type === "authorization_response") {
            if (clearTimeout(i3), clearInterval(o3), window.removeEventListener("message", r3, false), e3.popup.close(), a3.data.response.error)
              return n3(wa.fromPayload(a3.data.response));
            t3(a3.data.response);
          }
        }, window.addEventListener("message", r3);
      });
    };
    var Za = function() {
      return window.crypto || window.msCrypto;
    };
    var Ra = function() {
      var e3 = Za();
      return e3.subtle || e3.webkitSubtle;
    };
    var Ea = function() {
      var e3 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.", t3 = "";
      return Array.from(Za().getRandomValues(new Uint8Array(43))).forEach(function(n3) {
        return t3 += e3[n3 % e3.length];
      }), t3;
    };
    var Oa = function(e3) {
      return btoa(e3);
    };
    var Fa = function(e3) {
      return Object.keys(e3).filter(function(t3) {
        return e3[t3] !== void 0;
      }).map(function(t3) {
        return encodeURIComponent(t3) + "=" + encodeURIComponent(e3[t3]);
      }).join("&");
    };
    var xa = function(e3) {
      return k3(void 0, void 0, void 0, function() {
        var t3;
        return T3(this, function(n3) {
          switch (n3.label) {
            case 0:
              return t3 = Ra().digest({name: "SHA-256"}, new TextEncoder().encode(e3)), window.msCrypto ? [2, new Promise(function(e4, n4) {
                t3.oncomplete = function(t4) {
                  e4(t4.target.result);
                }, t3.onerror = function(e5) {
                  n4(e5.error);
                }, t3.onabort = function() {
                  n4("The digest operation was aborted");
                };
              })] : [4, t3];
            case 1:
              return [2, n3.sent()];
          }
        });
      });
    };
    var Ca = function(e3) {
      return function(e4) {
        return decodeURIComponent(atob(e4).split("").map(function(e5) {
          return "%" + ("00" + e5.charCodeAt(0).toString(16)).slice(-2);
        }).join(""));
      }(e3.replace(/_/g, "/").replace(/-/g, "+"));
    };
    var Va = function(e3) {
      var t3 = new Uint8Array(e3);
      return function(e4) {
        var t4 = {"+": "-", "/": "_", "=": ""};
        return e4.replace(/[+/=]/g, function(e5) {
          return t4[e5];
        });
      }(window.btoa(String.fromCharCode.apply(String, K3([], _3(Array.from(t3)), false))));
    };
    var Wa = function(e3, t3) {
      return k3(void 0, void 0, void 0, function() {
        var n3, r3;
        return T3(this, function(o3) {
          switch (o3.label) {
            case 0:
              return [4, (i3 = e3, a3 = t3, a3 = a3 || {}, new Promise(function(e4, t4) {
                var n4 = new XMLHttpRequest(), r4 = [], o4 = [], c3 = {}, s3 = function() {
                  return {ok: (n4.status / 100 | 0) == 2, statusText: n4.statusText, status: n4.status, url: n4.responseURL, text: function() {
                    return Promise.resolve(n4.responseText);
                  }, json: function() {
                    return Promise.resolve(n4.responseText).then(JSON.parse);
                  }, blob: function() {
                    return Promise.resolve(new Blob([n4.response]));
                  }, clone: s3, headers: {keys: function() {
                    return r4;
                  }, entries: function() {
                    return o4;
                  }, get: function(e5) {
                    return c3[e5.toLowerCase()];
                  }, has: function(e5) {
                    return e5.toLowerCase() in c3;
                  }}};
                };
                for (var u3 in n4.open(a3.method || "get", i3, true), n4.onload = function() {
                  n4.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(e5, t5, n5) {
                    r4.push(t5 = t5.toLowerCase()), o4.push([t5, n5]), c3[t5] = c3[t5] ? c3[t5] + "," + n5 : n5;
                  }), e4(s3());
                }, n4.onerror = t4, n4.withCredentials = a3.credentials == "include", a3.headers)
                  n4.setRequestHeader(u3, a3.headers[u3]);
                n4.send(a3.body || null);
              }))];
            case 1:
              return n3 = o3.sent(), r3 = {ok: n3.ok}, [4, n3.json()];
            case 2:
              return [2, (r3.json = o3.sent(), r3)];
          }
          var i3, a3;
        });
      });
    };
    var Ua = function(e3, t3, n3) {
      return k3(void 0, void 0, void 0, function() {
        var r3, o3;
        return T3(this, function(i3) {
          return r3 = new AbortController(), t3.signal = r3.signal, [2, Promise.race([Wa(e3, t3), new Promise(function(e4, t4) {
            o3 = setTimeout(function() {
              r3.abort(), t4(new Error("Timeout when executing 'fetch'"));
            }, n3);
          })]).finally(function() {
            clearTimeout(o3);
          })];
        });
      });
    };
    var Xa = function(e3, t3, n3, r3, o3, i3, a3) {
      return k3(void 0, void 0, void 0, function() {
        return T3(this, function(c3) {
          return [2, (s3 = {auth: {audience: t3, scope: n3}, timeout: o3, fetchUrl: e3, fetchOptions: r3, useFormData: a3}, u3 = i3, new Promise(function(e4, t4) {
            var n4 = new MessageChannel();
            n4.port1.onmessage = function(n5) {
              n5.data.error ? t4(new Error(n5.data.error)) : e4(n5.data);
            }, u3.postMessage(s3, [n4.port2]);
          }))];
          var s3, u3;
        });
      });
    };
    var La = function(e3, t3, n3, r3, o3, i3, a3) {
      return a3 === void 0 && (a3 = 1e4), k3(void 0, void 0, void 0, function() {
        return T3(this, function(c3) {
          return o3 ? [2, Xa(e3, t3, n3, r3, a3, o3, i3)] : [2, Ua(e3, r3, a3)];
        });
      });
    };
    function Ya(e3, t3, n3, r3, o3, i3, a3) {
      return k3(this, void 0, void 0, function() {
        var c3, s3, u3, l3, f3, d3, h3, p3, y3;
        return T3(this, function(m3) {
          switch (m3.label) {
            case 0:
              c3 = null, u3 = 0, m3.label = 1;
            case 1:
              if (!(u3 < 3))
                return [3, 6];
              m3.label = 2;
            case 2:
              return m3.trys.push([2, 4, , 5]), [4, La(e3, n3, r3, o3, i3, a3, t3)];
            case 3:
              return s3 = m3.sent(), c3 = null, [3, 6];
            case 4:
              return l3 = m3.sent(), c3 = l3, [3, 5];
            case 5:
              return u3++, [3, 1];
            case 6:
              if (c3)
                throw c3.message = c3.message || "Failed to fetch", c3;
              if (f3 = s3.json, d3 = f3.error, h3 = f3.error_description, p3 = I3(f3, ["error", "error_description"]), !s3.ok) {
                if (y3 = h3 || "HTTP error. Unable to fetch " + e3, d3 === "mfa_required")
                  throw new _a(d3, y3, p3.mfa_token);
                throw new wa(d3 || "request_error", y3);
              }
              return [2, p3];
          }
        });
      });
    }
    function ja(e3, t3) {
      var n3 = e3.baseUrl, r3 = e3.timeout, o3 = e3.audience, i3 = e3.scope, a3 = e3.auth0Client, c3 = e3.useFormData, s3 = I3(e3, ["baseUrl", "timeout", "audience", "scope", "auth0Client", "useFormData"]);
      return k3(this, void 0, void 0, function() {
        var e4;
        return T3(this, function(u3) {
          switch (u3.label) {
            case 0:
              return e4 = c3 ? Fa(s3) : JSON.stringify(s3), [4, Ya(n3 + "/oauth/token", r3, o3 || "default", i3, {method: "POST", body: e4, headers: {"Content-Type": c3 ? "application/x-www-form-urlencoded" : "application/json", "Auth0-Client": btoa(JSON.stringify(a3 || ba))}}, t3, c3)];
            case 1:
              return [2, u3.sent()];
          }
        });
      });
    }
    var Ja = function(e3) {
      return Array.from(new Set(e3));
    };
    var Na = function() {
      for (var e3 = [], t3 = 0; t3 < arguments.length; t3++)
        e3[t3] = arguments[t3];
      return Ja(e3.join(" ").trim().split(/\s+/)).join(" ");
    };
    var Pa = function() {
      function e3(e4, t3) {
        t3 === void 0 && (t3 = "@@auth0spajs@@"), this.prefix = t3, this.client_id = e4.client_id, this.scope = e4.scope, this.audience = e4.audience;
      }
      return e3.prototype.toKey = function() {
        return this.prefix + "::" + this.client_id + "::" + this.audience + "::" + this.scope;
      }, e3.fromKey = function(t3) {
        var n3 = _3(t3.split("::"), 4), r3 = n3[0], o3 = n3[1], i3 = n3[2];
        return new e3({client_id: o3, scope: n3[3], audience: i3}, r3);
      }, e3.fromCacheEntry = function(t3) {
        return new e3({scope: t3.scope, audience: t3.audience, client_id: t3.client_id});
      }, e3;
    }();
    var Ga = function() {
      function e3() {
      }
      return e3.prototype.set = function(e4, t3) {
        localStorage.setItem(e4, JSON.stringify(t3));
      }, e3.prototype.get = function(e4) {
        var t3 = window.localStorage.getItem(e4);
        if (t3)
          try {
            return JSON.parse(t3);
          } catch (e5) {
            return;
          }
      }, e3.prototype.remove = function(e4) {
        localStorage.removeItem(e4);
      }, e3.prototype.allKeys = function() {
        return Object.keys(window.localStorage).filter(function(e4) {
          return e4.startsWith("@@auth0spajs@@");
        });
      }, e3;
    }();
    var Aa = function() {
      var e3;
      this.enclosedCache = (e3 = {}, {set: function(t3, n3) {
        e3[t3] = n3;
      }, get: function(t3) {
        var n3 = e3[t3];
        if (n3)
          return n3;
      }, remove: function(t3) {
        delete e3[t3];
      }, allKeys: function() {
        return Object.keys(e3);
      }});
    };
    var Ba = function() {
      function e3(e4, t3, n3) {
        this.cache = e4, this.keyManifest = t3, this.nowProvider = n3, this.nowProvider = this.nowProvider || ga;
      }
      return e3.prototype.get = function(e4, t3) {
        var n3;
        return t3 === void 0 && (t3 = 0), k3(this, void 0, void 0, function() {
          var r3, o3, i3, a3, c3;
          return T3(this, function(s3) {
            switch (s3.label) {
              case 0:
                return [4, this.cache.get(e4.toKey())];
              case 1:
                return (r3 = s3.sent()) ? [3, 4] : [4, this.getCacheKeys()];
              case 2:
                return (o3 = s3.sent()) ? (i3 = this.matchExistingCacheKey(e4, o3), [4, this.cache.get(i3)]) : [2];
              case 3:
                r3 = s3.sent(), s3.label = 4;
              case 4:
                return r3 ? [4, this.nowProvider()] : [2];
              case 5:
                return a3 = s3.sent(), c3 = Math.floor(a3 / 1e3), r3.expiresAt - t3 < c3 ? r3.body.refresh_token ? (r3.body = {refresh_token: r3.body.refresh_token}, [4, this.cache.set(e4.toKey(), r3)]) : [3, 7] : [3, 10];
              case 6:
                return s3.sent(), [2, r3.body];
              case 7:
                return [4, this.cache.remove(e4.toKey())];
              case 8:
                return s3.sent(), [4, (n3 = this.keyManifest) === null || n3 === void 0 ? void 0 : n3.remove(e4.toKey())];
              case 9:
                return s3.sent(), [2];
              case 10:
                return [2, r3.body];
            }
          });
        });
      }, e3.prototype.set = function(e4) {
        var t3;
        return k3(this, void 0, void 0, function() {
          var n3, r3;
          return T3(this, function(o3) {
            switch (o3.label) {
              case 0:
                return n3 = new Pa({client_id: e4.client_id, scope: e4.scope, audience: e4.audience}), [4, this.wrapCacheEntry(e4)];
              case 1:
                return r3 = o3.sent(), [4, this.cache.set(n3.toKey(), r3)];
              case 2:
                return o3.sent(), [4, (t3 = this.keyManifest) === null || t3 === void 0 ? void 0 : t3.add(n3.toKey())];
              case 3:
                return o3.sent(), [2];
            }
          });
        });
      }, e3.prototype.clear = function(e4) {
        var t3;
        return k3(this, void 0, void 0, function() {
          var n3, r3 = this;
          return T3(this, function(o3) {
            switch (o3.label) {
              case 0:
                return [4, this.getCacheKeys()];
              case 1:
                return (n3 = o3.sent()) ? [4, n3.filter(function(t4) {
                  return !e4 || t4.includes(e4);
                }).reduce(function(e5, t4) {
                  return k3(r3, void 0, void 0, function() {
                    return T3(this, function(n4) {
                      switch (n4.label) {
                        case 0:
                          return [4, e5];
                        case 1:
                          return n4.sent(), [4, this.cache.remove(t4)];
                        case 2:
                          return n4.sent(), [2];
                      }
                    });
                  });
                }, Promise.resolve())] : [2];
              case 2:
                return o3.sent(), [4, (t3 = this.keyManifest) === null || t3 === void 0 ? void 0 : t3.clear()];
              case 3:
                return o3.sent(), [2];
            }
          });
        });
      }, e3.prototype.clearSync = function(e4) {
        var t3 = this, n3 = this.cache.allKeys();
        n3 && n3.filter(function(t4) {
          return !e4 || t4.includes(e4);
        }).forEach(function(e5) {
          t3.cache.remove(e5);
        });
      }, e3.prototype.wrapCacheEntry = function(e4) {
        return k3(this, void 0, void 0, function() {
          var t3, n3, r3;
          return T3(this, function(o3) {
            switch (o3.label) {
              case 0:
                return [4, this.nowProvider()];
              case 1:
                return t3 = o3.sent(), n3 = Math.floor(t3 / 1e3) + e4.expires_in, r3 = Math.min(n3, e4.decodedToken.claims.exp), [2, {body: e4, expiresAt: r3}];
            }
          });
        });
      }, e3.prototype.getCacheKeys = function() {
        var e4;
        return k3(this, void 0, void 0, function() {
          var t3;
          return T3(this, function(n3) {
            switch (n3.label) {
              case 0:
                return this.keyManifest ? [4, this.keyManifest.get()] : [3, 2];
              case 1:
                return t3 = (e4 = n3.sent()) === null || e4 === void 0 ? void 0 : e4.keys, [3, 4];
              case 2:
                return [4, this.cache.allKeys()];
              case 3:
                t3 = n3.sent(), n3.label = 4;
              case 4:
                return [2, t3];
            }
          });
        });
      }, e3.prototype.matchExistingCacheKey = function(e4, t3) {
        return t3.filter(function(t4) {
          var n3 = Pa.fromKey(t4), r3 = new Set(n3.scope && n3.scope.split(" ")), o3 = e4.scope.split(" "), i3 = n3.scope && o3.reduce(function(e5, t5) {
            return e5 && r3.has(t5);
          }, true);
          return n3.prefix === "@@auth0spajs@@" && n3.client_id === e4.client_id && n3.audience === e4.audience && i3;
        })[0];
      }, e3;
    }();
    var za = function() {
      function e3(e4, t3) {
        this.storage = e4, this.clientId = t3, this.storageKey = "a0.spajs.txs." + this.clientId, this.transaction = this.storage.get(this.storageKey);
      }
      return e3.prototype.create = function(e4) {
        this.transaction = e4, this.storage.save(this.storageKey, e4, {daysUntilExpire: 1});
      }, e3.prototype.get = function() {
        return this.transaction;
      }, e3.prototype.remove = function() {
        delete this.transaction, this.storage.remove(this.storageKey);
      }, e3;
    }();
    var Ha = function(e3) {
      return typeof e3 == "number";
    };
    var Da = ["iss", "aud", "exp", "nbf", "iat", "jti", "azp", "nonce", "auth_time", "at_hash", "c_hash", "acr", "amr", "sub_jwk", "cnf", "sip_from_tag", "sip_date", "sip_callid", "sip_cseq_num", "sip_via_branch", "orig", "dest", "mky", "events", "toe", "txn", "rph", "sid", "vot", "vtm"];
    var Ma = function(e3) {
      if (!e3.id_token)
        throw new Error("ID token is required but missing");
      var t3 = function(e4) {
        var t4 = e4.split("."), n4 = _3(t4, 3), r4 = n4[0], o4 = n4[1], i4 = n4[2];
        if (t4.length !== 3 || !r4 || !o4 || !i4)
          throw new Error("ID token could not be decoded");
        var a4 = JSON.parse(Ca(o4)), c3 = {__raw: e4}, s3 = {};
        return Object.keys(a4).forEach(function(e5) {
          c3[e5] = a4[e5], Da.includes(e5) || (s3[e5] = a4[e5]);
        }), {encoded: {header: r4, payload: o4, signature: i4}, header: JSON.parse(Ca(r4)), claims: c3, user: s3};
      }(e3.id_token);
      if (!t3.claims.iss)
        throw new Error("Issuer (iss) claim must be a string present in the ID token");
      if (t3.claims.iss !== e3.iss)
        throw new Error('Issuer (iss) claim mismatch in the ID token; expected "' + e3.iss + '", found "' + t3.claims.iss + '"');
      if (!t3.user.sub)
        throw new Error("Subject (sub) claim must be a string present in the ID token");
      if (t3.header.alg !== "RS256")
        throw new Error('Signature algorithm of "' + t3.header.alg + '" is not supported. Expected the ID token to be signed with "RS256".');
      if (!t3.claims.aud || typeof t3.claims.aud != "string" && !Array.isArray(t3.claims.aud))
        throw new Error("Audience (aud) claim must be a string or array of strings present in the ID token");
      if (Array.isArray(t3.claims.aud)) {
        if (!t3.claims.aud.includes(e3.aud))
          throw new Error('Audience (aud) claim mismatch in the ID token; expected "' + e3.aud + '" but was not one of "' + t3.claims.aud.join(", ") + '"');
        if (t3.claims.aud.length > 1) {
          if (!t3.claims.azp)
            throw new Error("Authorized Party (azp) claim must be a string present in the ID token when Audience (aud) claim has multiple values");
          if (t3.claims.azp !== e3.aud)
            throw new Error('Authorized Party (azp) claim mismatch in the ID token; expected "' + e3.aud + '", found "' + t3.claims.azp + '"');
        }
      } else if (t3.claims.aud !== e3.aud)
        throw new Error('Audience (aud) claim mismatch in the ID token; expected "' + e3.aud + '" but found "' + t3.claims.aud + '"');
      if (e3.nonce) {
        if (!t3.claims.nonce)
          throw new Error("Nonce (nonce) claim must be a string present in the ID token");
        if (t3.claims.nonce !== e3.nonce)
          throw new Error('Nonce (nonce) claim mismatch in the ID token; expected "' + e3.nonce + '", found "' + t3.claims.nonce + '"');
      }
      if (e3.max_age && !Ha(t3.claims.auth_time))
        throw new Error("Authentication Time (auth_time) claim must be a number present in the ID token when Max Age (max_age) is specified");
      if (!Ha(t3.claims.exp))
        throw new Error("Expiration Time (exp) claim must be a number present in the ID token");
      if (!Ha(t3.claims.iat))
        throw new Error("Issued At (iat) claim must be a number present in the ID token");
      var n3 = e3.leeway || 60, r3 = new Date(e3.now || Date.now()), o3 = new Date(0), i3 = new Date(0), a3 = new Date(0);
      if (a3.setUTCSeconds(parseInt(t3.claims.auth_time) + e3.max_age + n3), o3.setUTCSeconds(t3.claims.exp + n3), i3.setUTCSeconds(t3.claims.nbf - n3), r3 > o3)
        throw new Error("Expiration Time (exp) claim error in the ID token; current time (" + r3 + ") is after expiration time (" + o3 + ")");
      if (Ha(t3.claims.nbf) && r3 < i3)
        throw new Error("Not Before time (nbf) claim in the ID token indicates that this token can't be used just yet. Currrent time (" + r3 + ") is before " + i3);
      if (Ha(t3.claims.auth_time) && r3 > a3)
        throw new Error("Authentication Time (auth_time) claim in the ID token indicates that too much time has passed since the last end-user authentication. Currrent time (" + r3 + ") is after last auth at " + a3);
      if (e3.organizationId) {
        if (!t3.claims.org_id)
          throw new Error("Organization ID (org_id) claim must be a string present in the ID token");
        if (e3.organizationId !== t3.claims.org_id)
          throw new Error('Organization ID (org_id) claim mismatch in the ID token; expected "' + e3.organizationId + '", found "' + t3.claims.org_id + '"');
      }
      return t3;
    };
    var qa = E3(function(e3, t3) {
      var n3 = Z3 && Z3.__assign || function() {
        return (n3 = Object.assign || function(e4) {
          for (var t4, n4 = 1, r4 = arguments.length; n4 < r4; n4++)
            for (var o4 in t4 = arguments[n4])
              Object.prototype.hasOwnProperty.call(t4, o4) && (e4[o4] = t4[o4]);
          return e4;
        }).apply(this, arguments);
      };
      function r3(e4, t4) {
        if (!t4)
          return "";
        var n4 = "; " + e4;
        return t4 === true ? n4 : n4 + "=" + t4;
      }
      function o3(e4, t4, n4) {
        return encodeURIComponent(e4).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/\(/g, "%28").replace(/\)/g, "%29") + "=" + encodeURIComponent(t4).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent) + function(e5) {
          if (typeof e5.expires == "number") {
            var t5 = new Date();
            t5.setMilliseconds(t5.getMilliseconds() + 864e5 * e5.expires), e5.expires = t5;
          }
          return r3("Expires", e5.expires ? e5.expires.toUTCString() : "") + r3("Domain", e5.domain) + r3("Path", e5.path) + r3("Secure", e5.secure) + r3("SameSite", e5.sameSite);
        }(n4);
      }
      function i3(e4) {
        for (var t4 = {}, n4 = e4 ? e4.split("; ") : [], r4 = /(%[\dA-F]{2})+/gi, o4 = 0; o4 < n4.length; o4++) {
          var i4 = n4[o4].split("="), a4 = i4.slice(1).join("=");
          a4.charAt(0) === '"' && (a4 = a4.slice(1, -1));
          try {
            t4[i4[0].replace(r4, decodeURIComponent)] = a4.replace(r4, decodeURIComponent);
          } catch (e5) {
          }
        }
        return t4;
      }
      function a3() {
        return i3(document.cookie);
      }
      function c3(e4, t4, r4) {
        document.cookie = o3(e4, t4, n3({path: "/"}, r4));
      }
      t3.__esModule = true, t3.encode = o3, t3.parse = i3, t3.getAll = a3, t3.get = function(e4) {
        return a3()[e4];
      }, t3.set = c3, t3.remove = function(e4, t4) {
        c3(e4, "", n3(n3({}, t4), {expires: -1}));
      };
    });
    R3(qa), qa.encode, qa.parse, qa.getAll;
    var Qa = qa.get;
    var $a = qa.set;
    var ec = qa.remove;
    var tc = {get: function(e3) {
      var t3 = Qa(e3);
      if (t3 !== void 0)
        return JSON.parse(t3);
    }, save: function(e3, t3, n3) {
      var r3 = {};
      window.location.protocol === "https:" && (r3 = {secure: true, sameSite: "none"}), (n3 == null ? void 0 : n3.daysUntilExpire) && (r3.expires = n3.daysUntilExpire), $a(e3, JSON.stringify(t3), r3);
    }, remove: function(e3) {
      ec(e3);
    }};
    var nc = {get: function(e3) {
      return tc.get(e3) || tc.get("_legacy_" + e3);
    }, save: function(e3, t3, n3) {
      var r3 = {};
      window.location.protocol === "https:" && (r3 = {secure: true}), (n3 == null ? void 0 : n3.daysUntilExpire) && (r3.expires = n3.daysUntilExpire), $a("_legacy_" + e3, JSON.stringify(t3), r3), tc.save(e3, t3, n3);
    }, remove: function(e3) {
      tc.remove(e3), tc.remove("_legacy_" + e3);
    }};
    var rc = {get: function(e3) {
      if (typeof sessionStorage != "undefined") {
        var t3 = sessionStorage.getItem(e3);
        if (t3 !== void 0)
          return JSON.parse(t3);
      }
    }, save: function(e3, t3) {
      sessionStorage.setItem(e3, JSON.stringify(t3));
    }, remove: function(e3) {
      sessionStorage.removeItem(e3);
    }};
    var oc;
    var ic = ("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Ci8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKgogICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uCgogICAgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55CiAgICBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuCgogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEgKICAgIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWQogICAgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULAogICAgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NCiAgICBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUgogICAgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUgogICAgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS4KICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovdmFyIGU9ZnVuY3Rpb24oKXtyZXR1cm4oZT1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHIsdD0xLG49YXJndW1lbnRzLmxlbmd0aDt0PG47dCsrKWZvcih2YXIgbyBpbiByPWFyZ3VtZW50c1t0XSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixvKSYmKGVbb109cltvXSk7cmV0dXJuIGV9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIHIoZSxyLHQsbil7cmV0dXJuIG5ldyh0fHwodD1Qcm9taXNlKSkoKGZ1bmN0aW9uKG8sYSl7ZnVuY3Rpb24gcyhlKXt0cnl7dShuLm5leHQoZSkpfWNhdGNoKGUpe2EoZSl9fWZ1bmN0aW9uIGkoZSl7dHJ5e3Uobi50aHJvdyhlKSl9Y2F0Y2goZSl7YShlKX19ZnVuY3Rpb24gdShlKXt2YXIgcjtlLmRvbmU/byhlLnZhbHVlKToocj1lLnZhbHVlLHIgaW5zdGFuY2VvZiB0P3I6bmV3IHQoKGZ1bmN0aW9uKGUpe2Uocil9KSkpLnRoZW4ocyxpKX11KChuPW4uYXBwbHkoZSxyfHxbXSkpLm5leHQoKSl9KSl9ZnVuY3Rpb24gdChlLHIpe3ZhciB0LG4sbyxhLHM9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmb1swXSl0aHJvdyBvWzFdO3JldHVybiBvWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIGE9e25leHQ6aSgwKSx0aHJvdzppKDEpLHJldHVybjppKDIpfSwiZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiYoYVtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxhO2Z1bmN0aW9uIGkoYSl7cmV0dXJuIGZ1bmN0aW9uKGkpe3JldHVybiBmdW5jdGlvbihhKXtpZih0KXRocm93IG5ldyBUeXBlRXJyb3IoIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy4iKTtmb3IoO3M7KXRyeXtpZih0PTEsbiYmKG89MiZhWzBdP24ucmV0dXJuOmFbMF0/bi50aHJvd3x8KChvPW4ucmV0dXJuKSYmby5jYWxsKG4pLDApOm4ubmV4dCkmJiEobz1vLmNhbGwobixhWzFdKSkuZG9uZSlyZXR1cm4gbztzd2l0Y2gobj0wLG8mJihhPVsyJmFbMF0sby52YWx1ZV0pLGFbMF0pe2Nhc2UgMDpjYXNlIDE6bz1hO2JyZWFrO2Nhc2UgNDpyZXR1cm4gcy5sYWJlbCsrLHt2YWx1ZTphWzFdLGRvbmU6ITF9O2Nhc2UgNTpzLmxhYmVsKyssbj1hWzFdLGE9WzBdO2NvbnRpbnVlO2Nhc2UgNzphPXMub3BzLnBvcCgpLHMudHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKCEobz1zLnRyeXMsKG89by5sZW5ndGg+MCYmb1tvLmxlbmd0aC0xXSl8fDYhPT1hWzBdJiYyIT09YVswXSkpe3M9MDtjb250aW51ZX1pZigzPT09YVswXSYmKCFvfHxhWzFdPm9bMF0mJmFbMV08b1szXSkpe3MubGFiZWw9YVsxXTticmVha31pZig2PT09YVswXSYmcy5sYWJlbDxvWzFdKXtzLmxhYmVsPW9bMV0sbz1hO2JyZWFrfWlmKG8mJnMubGFiZWw8b1syXSl7cy5sYWJlbD1vWzJdLHMub3BzLnB1c2goYSk7YnJlYWt9b1syXSYmcy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlfWE9ci5jYWxsKGUscyl9Y2F0Y2goZSl7YT1bNixlXSxuPTB9ZmluYWxseXt0PW89MH1pZig1JmFbMF0pdGhyb3cgYVsxXTtyZXR1cm57dmFsdWU6YVswXT9hWzFdOnZvaWQgMCxkb25lOiEwfX0oW2EsaV0pfX19dmFyIG49e30sbz1mdW5jdGlvbihlLHIpe3JldHVybiBlKyJ8IityfTthZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwoZnVuY3Rpb24oYSl7dmFyIHM9YS5kYXRhLGk9cy50aW1lb3V0LHU9cy5hdXRoLGM9cy5mZXRjaFVybCxmPXMuZmV0Y2hPcHRpb25zLGw9cy51c2VGb3JtRGF0YSxoPWZ1bmN0aW9uKGUscil7dmFyIHQ9ImZ1bmN0aW9uIj09dHlwZW9mIFN5bWJvbCYmZVtTeW1ib2wuaXRlcmF0b3JdO2lmKCF0KXJldHVybiBlO3ZhciBuLG8sYT10LmNhbGwoZSkscz1bXTt0cnl7Zm9yKDsodm9pZCAwPT09cnx8ci0tID4wKSYmIShuPWEubmV4dCgpKS5kb25lOylzLnB1c2gobi52YWx1ZSl9Y2F0Y2goZSl7bz17ZXJyb3I6ZX19ZmluYWxseXt0cnl7biYmIW4uZG9uZSYmKHQ9YS5yZXR1cm4pJiZ0LmNhbGwoYSl9ZmluYWxseXtpZihvKXRocm93IG8uZXJyb3J9fXJldHVybiBzfShhLnBvcnRzLDEpWzBdO3JldHVybiByKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciByLGEscyxwLHksYixkLHYsdyxnO3JldHVybiB0KHRoaXMsKGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cz0oYT11fHx7fSkuYXVkaWVuY2UscD1hLnNjb3BlLHQubGFiZWw9MTtjYXNlIDE6aWYodC50cnlzLnB1c2goWzEsNywsOF0pLCEoeT1sPyhrPWYuYm9keSxTPW5ldyBVUkxTZWFyY2hQYXJhbXMoayksXz17fSxTLmZvckVhY2goKGZ1bmN0aW9uKGUscil7X1tyXT1lfSkpLF8pOkpTT04ucGFyc2UoZi5ib2R5KSkucmVmcmVzaF90b2tlbiYmInJlZnJlc2hfdG9rZW4iPT09eS5ncmFudF90eXBlKXtpZighKGI9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gbltvKGUscildfShzLHApKSl0aHJvdyBuZXcgRXJyb3IoIlRoZSB3ZWIgd29ya2VyIGlzIG1pc3NpbmcgdGhlIHJlZnJlc2ggdG9rZW4iKTtmLmJvZHk9bD9uZXcgVVJMU2VhcmNoUGFyYW1zKGUoZSh7fSx5KSx7cmVmcmVzaF90b2tlbjpifSkpLnRvU3RyaW5nKCk6SlNPTi5zdHJpbmdpZnkoZShlKHt9LHkpLHtyZWZyZXNoX3Rva2VuOmJ9KSl9ZD12b2lkIDAsImZ1bmN0aW9uIj09dHlwZW9mIEFib3J0Q29udHJvbGxlciYmKGQ9bmV3IEFib3J0Q29udHJvbGxlcixmLnNpZ25hbD1kLnNpZ25hbCksdj12b2lkIDAsdC5sYWJlbD0yO2Nhc2UgMjpyZXR1cm4gdC50cnlzLnB1c2goWzIsNCwsNV0pLFs0LFByb21pc2UucmFjZShbKG09aSxuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7cmV0dXJuIHNldFRpbWVvdXQoZSxtKX0pKSksZmV0Y2goYyxlKHt9LGYpKV0pXTtjYXNlIDM6cmV0dXJuIHY9dC5zZW50KCksWzMsNV07Y2FzZSA0OnJldHVybiB3PXQuc2VudCgpLGgucG9zdE1lc3NhZ2Uoe2Vycm9yOncubWVzc2FnZX0pLFsyXTtjYXNlIDU6cmV0dXJuIHY/WzQsdi5qc29uKCldOihkJiZkLmFib3J0KCksaC5wb3N0TWVzc2FnZSh7ZXJyb3I6IlRpbWVvdXQgd2hlbiBleGVjdXRpbmcgJ2ZldGNoJyJ9KSxbMl0pO2Nhc2UgNjpyZXR1cm4ocj10LnNlbnQoKSkucmVmcmVzaF90b2tlbj8oZnVuY3Rpb24oZSxyLHQpe25bbyhyLHQpXT1lfShyLnJlZnJlc2hfdG9rZW4scyxwKSxkZWxldGUgci5yZWZyZXNoX3Rva2VuKTpmdW5jdGlvbihlLHIpe2RlbGV0ZSBuW28oZSxyKV19KHMscCksaC5wb3N0TWVzc2FnZSh7b2s6di5vayxqc29uOnJ9KSxbMyw4XTtjYXNlIDc6cmV0dXJuIGc9dC5zZW50KCksaC5wb3N0TWVzc2FnZSh7b2s6ITEsanNvbjp7ZXJyb3JfZGVzY3JpcHRpb246Zy5tZXNzYWdlfX0pLFszLDhdO2Nhc2UgODpyZXR1cm5bMl19dmFyIG0sayxTLF99KSl9KSl9KSl9KCk7Cgo=", null, false, function(e3) {
      return oc = oc || function(e4, t3, n3) {
        var r3 = t3 === void 0 ? null : t3, o3 = function(e5, t4) {
          var n4 = atob(e5);
          if (t4) {
            for (var r4 = new Uint8Array(n4.length), o4 = 0, i4 = n4.length; o4 < i4; ++o4)
              r4[o4] = n4.charCodeAt(o4);
            return String.fromCharCode.apply(null, new Uint16Array(r4.buffer));
          }
          return n4;
        }(e4, n3 !== void 0 && n3), i3 = o3.indexOf("\n", 10) + 1, a3 = o3.substring(i3) + (r3 ? "//# sourceMappingURL=" + r3 : ""), c3 = new Blob([a3], {type: "application/javascript"});
        return URL.createObjectURL(c3);
      }("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwohZnVuY3Rpb24oKXsidXNlIHN0cmljdCI7Ci8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKgogICAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uCgogICAgUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55CiAgICBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuCgogICAgVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICJBUyBJUyIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEgKICAgIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWQogICAgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULAogICAgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NCiAgICBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUgogICAgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUgogICAgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS4KICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovdmFyIGU9ZnVuY3Rpb24oKXtyZXR1cm4oZT1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHIsdD0xLG49YXJndW1lbnRzLmxlbmd0aDt0PG47dCsrKWZvcih2YXIgbyBpbiByPWFyZ3VtZW50c1t0XSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixvKSYmKGVbb109cltvXSk7cmV0dXJuIGV9KS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2Z1bmN0aW9uIHIoZSxyLHQsbil7cmV0dXJuIG5ldyh0fHwodD1Qcm9taXNlKSkoKGZ1bmN0aW9uKG8sYSl7ZnVuY3Rpb24gcyhlKXt0cnl7dShuLm5leHQoZSkpfWNhdGNoKGUpe2EoZSl9fWZ1bmN0aW9uIGkoZSl7dHJ5e3Uobi50aHJvdyhlKSl9Y2F0Y2goZSl7YShlKX19ZnVuY3Rpb24gdShlKXt2YXIgcjtlLmRvbmU/byhlLnZhbHVlKToocj1lLnZhbHVlLHIgaW5zdGFuY2VvZiB0P3I6bmV3IHQoKGZ1bmN0aW9uKGUpe2Uocil9KSkpLnRoZW4ocyxpKX11KChuPW4uYXBwbHkoZSxyfHxbXSkpLm5leHQoKSl9KSl9ZnVuY3Rpb24gdChlLHIpe3ZhciB0LG4sbyxhLHM9e2xhYmVsOjAsc2VudDpmdW5jdGlvbigpe2lmKDEmb1swXSl0aHJvdyBvWzFdO3JldHVybiBvWzFdfSx0cnlzOltdLG9wczpbXX07cmV0dXJuIGE9e25leHQ6aSgwKSx0aHJvdzppKDEpLHJldHVybjppKDIpfSwiZnVuY3Rpb24iPT10eXBlb2YgU3ltYm9sJiYoYVtTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSxhO2Z1bmN0aW9uIGkoYSl7cmV0dXJuIGZ1bmN0aW9uKGkpe3JldHVybiBmdW5jdGlvbihhKXtpZih0KXRocm93IG5ldyBUeXBlRXJyb3IoIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy4iKTtmb3IoO3M7KXRyeXtpZih0PTEsbiYmKG89MiZhWzBdP24ucmV0dXJuOmFbMF0/bi50aHJvd3x8KChvPW4ucmV0dXJuKSYmby5jYWxsKG4pLDApOm4ubmV4dCkmJiEobz1vLmNhbGwobixhWzFdKSkuZG9uZSlyZXR1cm4gbztzd2l0Y2gobj0wLG8mJihhPVsyJmFbMF0sby52YWx1ZV0pLGFbMF0pe2Nhc2UgMDpjYXNlIDE6bz1hO2JyZWFrO2Nhc2UgNDpyZXR1cm4gcy5sYWJlbCsrLHt2YWx1ZTphWzFdLGRvbmU6ITF9O2Nhc2UgNTpzLmxhYmVsKyssbj1hWzFdLGE9WzBdO2NvbnRpbnVlO2Nhc2UgNzphPXMub3BzLnBvcCgpLHMudHJ5cy5wb3AoKTtjb250aW51ZTtkZWZhdWx0OmlmKCEobz1zLnRyeXMsKG89by5sZW5ndGg+MCYmb1tvLmxlbmd0aC0xXSl8fDYhPT1hWzBdJiYyIT09YVswXSkpe3M9MDtjb250aW51ZX1pZigzPT09YVswXSYmKCFvfHxhWzFdPm9bMF0mJmFbMV08b1szXSkpe3MubGFiZWw9YVsxXTticmVha31pZig2PT09YVswXSYmcy5sYWJlbDxvWzFdKXtzLmxhYmVsPW9bMV0sbz1hO2JyZWFrfWlmKG8mJnMubGFiZWw8b1syXSl7cy5sYWJlbD1vWzJdLHMub3BzLnB1c2goYSk7YnJlYWt9b1syXSYmcy5vcHMucG9wKCkscy50cnlzLnBvcCgpO2NvbnRpbnVlfWE9ci5jYWxsKGUscyl9Y2F0Y2goZSl7YT1bNixlXSxuPTB9ZmluYWxseXt0PW89MH1pZig1JmFbMF0pdGhyb3cgYVsxXTtyZXR1cm57dmFsdWU6YVswXT9hWzFdOnZvaWQgMCxkb25lOiEwfX0oW2EsaV0pfX19dmFyIG49e30sbz1mdW5jdGlvbihlLHIpe3JldHVybiBlKyJ8IityfTthZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIiwoZnVuY3Rpb24oYSl7dmFyIHM9YS5kYXRhLGk9cy50aW1lb3V0LHU9cy5hdXRoLGM9cy5mZXRjaFVybCxmPXMuZmV0Y2hPcHRpb25zLGw9cy51c2VGb3JtRGF0YSxoPWZ1bmN0aW9uKGUscil7dmFyIHQ9ImZ1bmN0aW9uIj09dHlwZW9mIFN5bWJvbCYmZVtTeW1ib2wuaXRlcmF0b3JdO2lmKCF0KXJldHVybiBlO3ZhciBuLG8sYT10LmNhbGwoZSkscz1bXTt0cnl7Zm9yKDsodm9pZCAwPT09cnx8ci0tID4wKSYmIShuPWEubmV4dCgpKS5kb25lOylzLnB1c2gobi52YWx1ZSl9Y2F0Y2goZSl7bz17ZXJyb3I6ZX19ZmluYWxseXt0cnl7biYmIW4uZG9uZSYmKHQ9YS5yZXR1cm4pJiZ0LmNhbGwoYSl9ZmluYWxseXtpZihvKXRocm93IG8uZXJyb3J9fXJldHVybiBzfShhLnBvcnRzLDEpWzBdO3JldHVybiByKHZvaWQgMCx2b2lkIDAsdm9pZCAwLChmdW5jdGlvbigpe3ZhciByLGEscyxwLHksYixkLHYsdyxnO3JldHVybiB0KHRoaXMsKGZ1bmN0aW9uKHQpe3N3aXRjaCh0LmxhYmVsKXtjYXNlIDA6cz0oYT11fHx7fSkuYXVkaWVuY2UscD1hLnNjb3BlLHQubGFiZWw9MTtjYXNlIDE6aWYodC50cnlzLnB1c2goWzEsNywsOF0pLCEoeT1sPyhrPWYuYm9keSxTPW5ldyBVUkxTZWFyY2hQYXJhbXMoayksXz17fSxTLmZvckVhY2goKGZ1bmN0aW9uKGUscil7X1tyXT1lfSkpLF8pOkpTT04ucGFyc2UoZi5ib2R5KSkucmVmcmVzaF90b2tlbiYmInJlZnJlc2hfdG9rZW4iPT09eS5ncmFudF90eXBlKXtpZighKGI9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gbltvKGUscildfShzLHApKSl0aHJvdyBuZXcgRXJyb3IoIlRoZSB3ZWIgd29ya2VyIGlzIG1pc3NpbmcgdGhlIHJlZnJlc2ggdG9rZW4iKTtmLmJvZHk9bD9uZXcgVVJMU2VhcmNoUGFyYW1zKGUoZSh7fSx5KSx7cmVmcmVzaF90b2tlbjpifSkpLnRvU3RyaW5nKCk6SlNPTi5zdHJpbmdpZnkoZShlKHt9LHkpLHtyZWZyZXNoX3Rva2VuOmJ9KSl9ZD12b2lkIDAsImZ1bmN0aW9uIj09dHlwZW9mIEFib3J0Q29udHJvbGxlciYmKGQ9bmV3IEFib3J0Q29udHJvbGxlcixmLnNpZ25hbD1kLnNpZ25hbCksdj12b2lkIDAsdC5sYWJlbD0yO2Nhc2UgMjpyZXR1cm4gdC50cnlzLnB1c2goWzIsNCwsNV0pLFs0LFByb21pc2UucmFjZShbKG09aSxuZXcgUHJvbWlzZSgoZnVuY3Rpb24oZSl7cmV0dXJuIHNldFRpbWVvdXQoZSxtKX0pKSksZmV0Y2goYyxlKHt9LGYpKV0pXTtjYXNlIDM6cmV0dXJuIHY9dC5zZW50KCksWzMsNV07Y2FzZSA0OnJldHVybiB3PXQuc2VudCgpLGgucG9zdE1lc3NhZ2Uoe2Vycm9yOncubWVzc2FnZX0pLFsyXTtjYXNlIDU6cmV0dXJuIHY/WzQsdi5qc29uKCldOihkJiZkLmFib3J0KCksaC5wb3N0TWVzc2FnZSh7ZXJyb3I6IlRpbWVvdXQgd2hlbiBleGVjdXRpbmcgJ2ZldGNoJyJ9KSxbMl0pO2Nhc2UgNjpyZXR1cm4ocj10LnNlbnQoKSkucmVmcmVzaF90b2tlbj8oZnVuY3Rpb24oZSxyLHQpe25bbyhyLHQpXT1lfShyLnJlZnJlc2hfdG9rZW4scyxwKSxkZWxldGUgci5yZWZyZXNoX3Rva2VuKTpmdW5jdGlvbihlLHIpe2RlbGV0ZSBuW28oZSxyKV19KHMscCksaC5wb3N0TWVzc2FnZSh7b2s6di5vayxqc29uOnJ9KSxbMyw4XTtjYXNlIDc6cmV0dXJuIGc9dC5zZW50KCksaC5wb3N0TWVzc2FnZSh7b2s6ITEsanNvbjp7ZXJyb3JfZGVzY3JpcHRpb246Zy5tZXNzYWdlfX0pLFszLDhdO2Nhc2UgODpyZXR1cm5bMl19dmFyIG0sayxTLF99KSl9KSl9KSl9KCk7Cgo=", null, false), new Worker(oc, e3);
    });
    var ac = {};
    var cc = function() {
      function e3(e4, t3) {
        this.cache = e4, this.clientId = t3, this.manifestKey = this.createManifestKeyFrom(this.clientId);
      }
      return e3.prototype.add = function(e4) {
        var t3;
        return k3(this, void 0, void 0, function() {
          var n3, r3;
          return T3(this, function(o3) {
            switch (o3.label) {
              case 0:
                return r3 = Set.bind, [4, this.cache.get(this.manifestKey)];
              case 1:
                return (n3 = new (r3.apply(Set, [void 0, ((t3 = o3.sent()) === null || t3 === void 0 ? void 0 : t3.keys) || []]))()).add(e4), [4, this.cache.set(this.manifestKey, {keys: K3([], _3(n3), false)})];
              case 2:
                return o3.sent(), [2];
            }
          });
        });
      }, e3.prototype.remove = function(e4) {
        return k3(this, void 0, void 0, function() {
          var t3, n3;
          return T3(this, function(r3) {
            switch (r3.label) {
              case 0:
                return [4, this.cache.get(this.manifestKey)];
              case 1:
                return (t3 = r3.sent()) ? ((n3 = new Set(t3.keys)).delete(e4), n3.size > 0 ? [4, this.cache.set(this.manifestKey, {keys: K3([], _3(n3), false)})] : [3, 3]) : [3, 5];
              case 2:
              case 4:
                return [2, r3.sent()];
              case 3:
                return [4, this.cache.remove(this.manifestKey)];
              case 5:
                return [2];
            }
          });
        });
      }, e3.prototype.get = function() {
        return this.cache.get(this.manifestKey);
      }, e3.prototype.clear = function() {
        return this.cache.remove(this.manifestKey);
      }, e3.prototype.createManifestKeyFrom = function(e4) {
        return "@@auth0spajs@@::" + e4;
      }, e3;
    }();
    var sc = new ya();
    var uc = {memory: function() {
      return new Aa().enclosedCache;
    }, localstorage: function() {
      return new Ga();
    }};
    var lc = function(e3) {
      return uc[e3];
    };
    var fc = function() {
      function e3(e4) {
        var t3, n3, r3;
        if (this.options = e4, typeof window != "undefined" && function() {
          if (!Za())
            throw new Error("For security reasons, `window.crypto` is required to run `auth0-spa-js`.");
          if (Ra() === void 0)
            throw new Error("\n      auth0-spa-js must run on a secure origin. See https://github.com/auth0/auth0-spa-js/blob/master/FAQ.md#why-do-i-get-auth0-spa-js-must-run-on-a-secure-origin for more information.\n    ");
        }(), e4.cache && e4.cacheLocation && console.warn("Both `cache` and `cacheLocation` options have been specified in the Auth0Client configuration; ignoring `cacheLocation` and using `cache`."), e4.cache)
          r3 = e4.cache;
        else {
          if (this.cacheLocation = e4.cacheLocation || "memory", !lc(this.cacheLocation))
            throw new Error('Invalid cache location "' + this.cacheLocation + '"');
          r3 = lc(this.cacheLocation)();
        }
        this.cookieStorage = e4.legacySameSiteCookie === false ? tc : nc, this.orgHintCookieName = "auth0." + this.options.client_id + ".organization_hint", this.isAuthenticatedCookieName = function(e5) {
          return "auth0." + e5 + ".is.authenticated";
        }(this.options.client_id), this.sessionCheckExpiryDays = e4.sessionCheckExpiryDays || 1;
        var o3, i3 = e4.useCookiesForTransactions ? this.cookieStorage : rc;
        this.scope = this.options.scope, this.transactionManager = new za(i3, this.options.client_id), this.nowProvider = this.options.nowProvider || ga, this.cacheManager = new Ba(r3, r3.allKeys ? null : new cc(r3, this.options.client_id), this.nowProvider), this.domainUrl = (o3 = this.options.domain, /^https?:\/\//.test(o3) ? o3 : "https://" + o3), this.tokenIssuer = function(e5, t4) {
          return e5 ? e5.startsWith("https://") ? e5 : "https://" + e5 + "/" : t4 + "/";
        }(this.options.issuer, this.domainUrl), this.defaultScope = Na("openid", ((n3 = (t3 = this.options) === null || t3 === void 0 ? void 0 : t3.advancedOptions) === null || n3 === void 0 ? void 0 : n3.defaultScope) !== void 0 ? this.options.advancedOptions.defaultScope : "openid profile email"), this.options.useRefreshTokens && (this.scope = Na(this.scope, "offline_access")), typeof window != "undefined" && window.Worker && this.options.useRefreshTokens && this.cacheLocation === "memory" && !/Trident.*rv:11\.0/.test(navigator.userAgent) && (this.worker = new ic()), this.customOptions = function(e5) {
          return e5.advancedOptions, e5.audience, e5.auth0Client, e5.authorizeTimeoutInSeconds, e5.cacheLocation, e5.client_id, e5.domain, e5.issuer, e5.leeway, e5.max_age, e5.redirect_uri, e5.scope, e5.useRefreshTokens, e5.useCookiesForTransactions, e5.useFormData, I3(e5, ["advancedOptions", "audience", "auth0Client", "authorizeTimeoutInSeconds", "cacheLocation", "client_id", "domain", "issuer", "leeway", "max_age", "redirect_uri", "scope", "useRefreshTokens", "useCookiesForTransactions", "useFormData"]);
        }(e4);
      }
      return e3.prototype._url = function(e4) {
        var t3 = encodeURIComponent(btoa(JSON.stringify(this.options.auth0Client || ba)));
        return "" + this.domainUrl + e4 + "&auth0Client=" + t3;
      }, e3.prototype._getParams = function(e4, t3, n3, r3, o3) {
        var i3 = this.options;
        i3.useRefreshTokens, i3.useCookiesForTransactions, i3.useFormData, i3.auth0Client, i3.cacheLocation, i3.advancedOptions, i3.detailedResponse, i3.nowProvider, i3.authorizeTimeoutInSeconds, i3.legacySameSiteCookie, i3.sessionCheckExpiryDays, i3.domain, i3.leeway;
        var a3 = I3(i3, ["useRefreshTokens", "useCookiesForTransactions", "useFormData", "auth0Client", "cacheLocation", "advancedOptions", "detailedResponse", "nowProvider", "authorizeTimeoutInSeconds", "legacySameSiteCookie", "sessionCheckExpiryDays", "domain", "leeway"]);
        return S3(S3(S3({}, a3), e4), {scope: Na(this.defaultScope, this.scope, e4.scope), response_type: "code", response_mode: "query", state: t3, nonce: n3, redirect_uri: o3 || this.options.redirect_uri, code_challenge: r3, code_challenge_method: "S256"});
      }, e3.prototype._authorizeUrl = function(e4) {
        return this._url("/authorize?" + Fa(e4));
      }, e3.prototype._verifyIdToken = function(e4, t3, n3) {
        return k3(this, void 0, void 0, function() {
          var r3;
          return T3(this, function(o3) {
            switch (o3.label) {
              case 0:
                return [4, this.nowProvider()];
              case 1:
                return r3 = o3.sent(), [2, Ma({iss: this.tokenIssuer, aud: this.options.client_id, id_token: e4, nonce: t3, organizationId: n3, leeway: this.options.leeway, max_age: this._parseNumber(this.options.max_age), now: r3})];
            }
          });
        });
      }, e3.prototype._parseNumber = function(e4) {
        return typeof e4 != "string" ? e4 : parseInt(e4, 10) || void 0;
      }, e3.prototype._processOrgIdHint = function(e4) {
        e4 ? this.cookieStorage.save(this.orgHintCookieName, e4) : this.cookieStorage.remove(this.orgHintCookieName);
      }, e3.prototype.buildAuthorizeUrl = function(e4) {
        return e4 === void 0 && (e4 = {}), k3(this, void 0, void 0, function() {
          var t3, n3, r3, o3, i3, a3, c3, s3, u3, l3, f3, d3;
          return T3(this, function(h3) {
            switch (h3.label) {
              case 0:
                return t3 = e4.redirect_uri, n3 = e4.appState, r3 = I3(e4, ["redirect_uri", "appState"]), o3 = Oa(Ea()), i3 = Oa(Ea()), a3 = Ea(), [4, xa(a3)];
              case 1:
                return c3 = h3.sent(), s3 = Va(c3), u3 = e4.fragment ? "#" + e4.fragment : "", l3 = this._getParams(r3, o3, i3, s3, t3), f3 = this._authorizeUrl(l3), d3 = e4.organization || this.options.organization, this.transactionManager.create(S3({nonce: i3, code_verifier: a3, appState: n3, scope: l3.scope, audience: l3.audience || "default", redirect_uri: l3.redirect_uri, state: o3}, d3 && {organizationId: d3})), [2, f3 + u3];
            }
          });
        });
      }, e3.prototype.loginWithPopup = function(e4, t3) {
        return k3(this, void 0, void 0, function() {
          var n3, r3, o3, i3, a3, c3, s3, u3, l3, f3, d3, h3, p3;
          return T3(this, function(y3) {
            switch (y3.label) {
              case 0:
                return e4 = e4 || {}, (t3 = t3 || {}).popup || (t3.popup = function(e5) {
                  var t4 = window.screenX + (window.innerWidth - 400) / 2, n4 = window.screenY + (window.innerHeight - 600) / 2;
                  return window.open("", "auth0:authorize:popup", "left=" + t4 + ",top=" + n4 + ",width=400,height=600,resizable,scrollbars=yes,status=1");
                }()), n3 = I3(e4, []), r3 = Oa(Ea()), o3 = Oa(Ea()), i3 = Ea(), [4, xa(i3)];
              case 1:
                return a3 = y3.sent(), c3 = Va(a3), s3 = this._getParams(n3, r3, o3, c3, this.options.redirect_uri || window.location.origin), u3 = this._authorizeUrl(S3(S3({}, s3), {response_mode: "web_message"})), t3.popup.location.href = u3, [4, Ka(S3(S3({}, t3), {timeoutInSeconds: t3.timeoutInSeconds || this.options.authorizeTimeoutInSeconds || 60}))];
              case 2:
                if (l3 = y3.sent(), r3 !== l3.state)
                  throw new Error("Invalid state");
                return [4, ja({audience: s3.audience, scope: s3.scope, baseUrl: this.domainUrl, client_id: this.options.client_id, code_verifier: i3, code: l3.code, grant_type: "authorization_code", redirect_uri: s3.redirect_uri, auth0Client: this.options.auth0Client, useFormData: this.options.useFormData}, this.worker)];
              case 3:
                return f3 = y3.sent(), d3 = e4.organization || this.options.organization, [4, this._verifyIdToken(f3.id_token, o3, d3)];
              case 4:
                return h3 = y3.sent(), p3 = S3(S3({}, f3), {decodedToken: h3, scope: s3.scope, audience: s3.audience || "default", client_id: this.options.client_id}), [4, this.cacheManager.set(p3)];
              case 5:
                return y3.sent(), this.cookieStorage.save(this.isAuthenticatedCookieName, true, {daysUntilExpire: this.sessionCheckExpiryDays}), this._processOrgIdHint(h3.claims.org_id), [2];
            }
          });
        });
      }, e3.prototype.getUser = function(e4) {
        return e4 === void 0 && (e4 = {}), k3(this, void 0, void 0, function() {
          var t3, n3, r3;
          return T3(this, function(o3) {
            switch (o3.label) {
              case 0:
                return t3 = e4.audience || this.options.audience || "default", n3 = Na(this.defaultScope, this.scope, e4.scope), [4, this.cacheManager.get(new Pa({client_id: this.options.client_id, audience: t3, scope: n3}))];
              case 1:
                return [2, (r3 = o3.sent()) && r3.decodedToken && r3.decodedToken.user];
            }
          });
        });
      }, e3.prototype.getIdTokenClaims = function(e4) {
        return e4 === void 0 && (e4 = {}), k3(this, void 0, void 0, function() {
          var t3, n3, r3;
          return T3(this, function(o3) {
            switch (o3.label) {
              case 0:
                return t3 = e4.audience || this.options.audience || "default", n3 = Na(this.defaultScope, this.scope, e4.scope), [4, this.cacheManager.get(new Pa({client_id: this.options.client_id, audience: t3, scope: n3}))];
              case 1:
                return [2, (r3 = o3.sent()) && r3.decodedToken && r3.decodedToken.claims];
            }
          });
        });
      }, e3.prototype.loginWithRedirect = function(e4) {
        return e4 === void 0 && (e4 = {}), k3(this, void 0, void 0, function() {
          var t3, n3, r3;
          return T3(this, function(o3) {
            switch (o3.label) {
              case 0:
                return t3 = e4.redirectMethod, n3 = I3(e4, ["redirectMethod"]), [4, this.buildAuthorizeUrl(n3)];
              case 1:
                return r3 = o3.sent(), window.location[t3 || "assign"](r3), [2];
            }
          });
        });
      }, e3.prototype.handleRedirectCallback = function(e4) {
        return e4 === void 0 && (e4 = window.location.href), k3(this, void 0, void 0, function() {
          var t3, n3, r3, o3, i3, a3, c3, s3, u3, l3;
          return T3(this, function(f3) {
            switch (f3.label) {
              case 0:
                if ((t3 = e4.split("?").slice(1)).length === 0)
                  throw new Error("There are no query params available for parsing.");
                if (n3 = function(e5) {
                  e5.indexOf("#") > -1 && (e5 = e5.substr(0, e5.indexOf("#")));
                  var t4 = e5.split("&"), n4 = {};
                  return t4.forEach(function(e6) {
                    var t5 = _3(e6.split("="), 2), r4 = t5[0], o4 = t5[1];
                    n4[r4] = decodeURIComponent(o4);
                  }), n4.expires_in && (n4.expires_in = parseInt(n4.expires_in)), n4;
                }(t3.join("")), r3 = n3.state, o3 = n3.code, i3 = n3.error, a3 = n3.error_description, !(c3 = this.transactionManager.get()))
                  throw new Error("Invalid state");
                if (this.transactionManager.remove(), i3)
                  throw new Sa(i3, a3, r3, c3.appState);
                if (!c3.code_verifier || c3.state && c3.state !== r3)
                  throw new Error("Invalid state");
                return s3 = {audience: c3.audience, scope: c3.scope, baseUrl: this.domainUrl, client_id: this.options.client_id, code_verifier: c3.code_verifier, grant_type: "authorization_code", code: o3, auth0Client: this.options.auth0Client, useFormData: this.options.useFormData}, c3.redirect_uri !== void 0 && (s3.redirect_uri = c3.redirect_uri), [4, ja(s3, this.worker)];
              case 1:
                return u3 = f3.sent(), [4, this._verifyIdToken(u3.id_token, c3.nonce, c3.organizationId)];
              case 2:
                return l3 = f3.sent(), [4, this.cacheManager.set(S3(S3(S3(S3({}, u3), {decodedToken: l3, audience: c3.audience, scope: c3.scope}), u3.scope ? {oauthTokenScope: u3.scope} : null), {client_id: this.options.client_id}))];
              case 3:
                return f3.sent(), this.cookieStorage.save(this.isAuthenticatedCookieName, true, {daysUntilExpire: this.sessionCheckExpiryDays}), this._processOrgIdHint(l3.claims.org_id), [2, {appState: c3.appState}];
            }
          });
        });
      }, e3.prototype.checkSession = function(e4) {
        return k3(this, void 0, void 0, function() {
          var t3;
          return T3(this, function(n3) {
            switch (n3.label) {
              case 0:
                if (!this.cookieStorage.get(this.isAuthenticatedCookieName)) {
                  if (!this.cookieStorage.get("auth0.is.authenticated"))
                    return [2];
                  this.cookieStorage.save(this.isAuthenticatedCookieName, true, {daysUntilExpire: this.sessionCheckExpiryDays}), this.cookieStorage.remove("auth0.is.authenticated");
                }
                n3.label = 1;
              case 1:
                return n3.trys.push([1, 3, , 4]), [4, this.getTokenSilently(e4)];
              case 2:
                return n3.sent(), [3, 4];
              case 3:
                if (t3 = n3.sent(), !va.includes(t3.error))
                  throw t3;
                return [3, 4];
              case 4:
                return [2];
            }
          });
        });
      }, e3.prototype.getTokenSilently = function(e4) {
        return e4 === void 0 && (e4 = {}), k3(this, void 0, void 0, function() {
          var t3, n3, r3, o3 = this;
          return T3(this, function(i3) {
            return t3 = S3(S3({audience: this.options.audience, ignoreCache: false}, e4), {scope: Na(this.defaultScope, this.scope, e4.scope)}), n3 = t3.ignoreCache, r3 = I3(t3, ["ignoreCache"]), [2, (a3 = function() {
              return o3._getTokenSilently(S3({ignoreCache: n3}, r3));
            }, c3 = this.options.client_id + "::" + r3.audience + "::" + r3.scope, s3 = ac[c3], s3 || (s3 = a3().finally(function() {
              delete ac[c3], s3 = null;
            }), ac[c3] = s3), s3)];
            var a3, c3, s3;
          });
        });
      }, e3.prototype._getTokenSilently = function(e4) {
        return e4 === void 0 && (e4 = {}), k3(this, void 0, void 0, function() {
          var t3, n3, r3, o3, i3, a3, c3, s3, u3;
          return T3(this, function(l3) {
            switch (l3.label) {
              case 0:
                return t3 = e4.ignoreCache, n3 = I3(e4, ["ignoreCache"]), t3 ? [3, 2] : [4, this._getEntryFromCache({scope: n3.scope, audience: n3.audience || "default", client_id: this.options.client_id, getDetailedEntry: e4.detailedResponse})];
              case 1:
                if (r3 = l3.sent())
                  return [2, r3];
                l3.label = 2;
              case 2:
                return [4, (f3 = function() {
                  return sc.acquireLock("auth0.lock.getTokenSilently", 5e3);
                }, d3 = 10, d3 === void 0 && (d3 = 3), k3(void 0, void 0, void 0, function() {
                  var e5;
                  return T3(this, function(t4) {
                    switch (t4.label) {
                      case 0:
                        e5 = 0, t4.label = 1;
                      case 1:
                        return e5 < d3 ? [4, f3()] : [3, 4];
                      case 2:
                        if (t4.sent())
                          return [2, true];
                        t4.label = 3;
                      case 3:
                        return e5++, [3, 1];
                      case 4:
                        return [2, false];
                    }
                  });
                }))];
              case 3:
                if (!l3.sent())
                  return [3, 15];
                l3.label = 4;
              case 4:
                return l3.trys.push([4, , 12, 14]), t3 ? [3, 6] : [4, this._getEntryFromCache({scope: n3.scope, audience: n3.audience || "default", client_id: this.options.client_id, getDetailedEntry: e4.detailedResponse})];
              case 5:
                if (r3 = l3.sent())
                  return [2, r3];
                l3.label = 6;
              case 6:
                return this.options.useRefreshTokens ? [4, this._getTokenUsingRefreshToken(n3)] : [3, 8];
              case 7:
                return i3 = l3.sent(), [3, 10];
              case 8:
                return [4, this._getTokenFromIFrame(n3)];
              case 9:
                i3 = l3.sent(), l3.label = 10;
              case 10:
                return o3 = i3, [4, this.cacheManager.set(S3({client_id: this.options.client_id}, o3))];
              case 11:
                return l3.sent(), this.cookieStorage.save(this.isAuthenticatedCookieName, true, {daysUntilExpire: this.sessionCheckExpiryDays}), e4.detailedResponse ? (a3 = o3.id_token, c3 = o3.access_token, s3 = o3.oauthTokenScope, u3 = o3.expires_in, [2, S3(S3({id_token: a3, access_token: c3}, s3 ? {scope: s3} : null), {expires_in: u3})]) : [2, o3.access_token];
              case 12:
                return [4, sc.releaseLock("auth0.lock.getTokenSilently")];
              case 13:
                return l3.sent(), [7];
              case 14:
                return [3, 16];
              case 15:
                throw new Ia();
              case 16:
                return [2];
            }
            var f3, d3;
          });
        });
      }, e3.prototype.getTokenWithPopup = function(e4, t3) {
        return e4 === void 0 && (e4 = {}), t3 === void 0 && (t3 = {}), k3(this, void 0, void 0, function() {
          return T3(this, function(n3) {
            switch (n3.label) {
              case 0:
                return e4.audience = e4.audience || this.options.audience, e4.scope = Na(this.defaultScope, this.scope, e4.scope), t3 = S3(S3({}, ma), t3), [4, this.loginWithPopup(e4, t3)];
              case 1:
                return n3.sent(), [4, this.cacheManager.get(new Pa({scope: e4.scope, audience: e4.audience || "default", client_id: this.options.client_id}))];
              case 2:
                return [2, n3.sent().access_token];
            }
          });
        });
      }, e3.prototype.isAuthenticated = function() {
        return k3(this, void 0, void 0, function() {
          return T3(this, function(e4) {
            switch (e4.label) {
              case 0:
                return [4, this.getUser()];
              case 1:
                return [2, !!e4.sent()];
            }
          });
        });
      }, e3.prototype.buildLogoutUrl = function(e4) {
        e4 === void 0 && (e4 = {}), e4.client_id !== null ? e4.client_id = e4.client_id || this.options.client_id : delete e4.client_id;
        var t3 = e4.federated, n3 = I3(e4, ["federated"]), r3 = t3 ? "&federated" : "";
        return this._url("/v2/logout?" + Fa(n3)) + r3;
      }, e3.prototype.logout = function(e4) {
        var t3 = this;
        e4 === void 0 && (e4 = {});
        var n3 = e4.localOnly, r3 = I3(e4, ["localOnly"]);
        if (n3 && r3.federated)
          throw new Error("It is invalid to set both the `federated` and `localOnly` options to `true`");
        var o3 = function() {
          if (t3.cookieStorage.remove(t3.orgHintCookieName), t3.cookieStorage.remove(t3.isAuthenticatedCookieName), !n3) {
            var e5 = t3.buildLogoutUrl(r3);
            window.location.assign(e5);
          }
        };
        if (this.options.cache)
          return this.cacheManager.clear().then(function() {
            return o3();
          });
        this.cacheManager.clearSync(), o3();
      }, e3.prototype._getTokenFromIFrame = function(e4) {
        return k3(this, void 0, void 0, function() {
          var t3, n3, r3, o3, i3, a3, c3, s3, u3, l3, f3, d3, h3, p3, y3, m3, v4;
          return T3(this, function(b4) {
            switch (b4.label) {
              case 0:
                return t3 = Oa(Ea()), n3 = Oa(Ea()), r3 = Ea(), [4, xa(r3)];
              case 1:
                o3 = b4.sent(), i3 = Va(o3), a3 = I3(e4, ["detailedResponse"]), c3 = this._getParams(a3, t3, n3, i3, e4.redirect_uri || this.options.redirect_uri || window.location.origin), (s3 = this.cookieStorage.get(this.orgHintCookieName)) && !c3.organization && (c3.organization = s3), u3 = this._authorizeUrl(S3(S3({}, c3), {prompt: "none", response_mode: "web_message"})), l3 = e4.timeoutInSeconds || this.options.authorizeTimeoutInSeconds, b4.label = 2;
              case 2:
                if (b4.trys.push([2, 6, , 7]), window.crossOriginIsolated)
                  throw new wa("login_required", "The application is running in a Cross-Origin Isolated context, silently retrieving a token without refresh token is not possible.");
                return [4, (g4 = u3, w4 = this.domainUrl, k4 = l3, k4 === void 0 && (k4 = 60), new Promise(function(e5, t4) {
                  var n4 = window.document.createElement("iframe");
                  n4.setAttribute("width", "0"), n4.setAttribute("height", "0"), n4.style.display = "none";
                  var r4, o4 = function() {
                    window.document.body.contains(n4) && (window.document.body.removeChild(n4), window.removeEventListener("message", r4, false));
                  }, i4 = setTimeout(function() {
                    t4(new Ia()), o4();
                  }, 1e3 * k4);
                  r4 = function(n5) {
                    if (n5.origin == w4 && n5.data && n5.data.type === "authorization_response") {
                      var a4 = n5.source;
                      a4 && a4.close(), n5.data.response.error ? t4(wa.fromPayload(n5.data.response)) : e5(n5.data.response), clearTimeout(i4), window.removeEventListener("message", r4, false), setTimeout(o4, 2e3);
                    }
                  }, window.addEventListener("message", r4, false), window.document.body.appendChild(n4), n4.setAttribute("src", g4);
                }))];
              case 3:
                if (f3 = b4.sent(), t3 !== f3.state)
                  throw new Error("Invalid state");
                return d3 = e4.scope, h3 = e4.audience, p3 = I3(e4, ["scope", "audience", "redirect_uri", "ignoreCache", "timeoutInSeconds", "detailedResponse"]), [4, ja(S3(S3(S3({}, this.customOptions), p3), {scope: d3, audience: h3, baseUrl: this.domainUrl, client_id: this.options.client_id, code_verifier: r3, code: f3.code, grant_type: "authorization_code", redirect_uri: c3.redirect_uri, auth0Client: this.options.auth0Client, useFormData: this.options.useFormData}), this.worker)];
              case 4:
                return y3 = b4.sent(), [4, this._verifyIdToken(y3.id_token, n3)];
              case 5:
                return m3 = b4.sent(), this._processOrgIdHint(m3.claims.org_id), [2, S3(S3({}, y3), {decodedToken: m3, scope: c3.scope, oauthTokenScope: y3.scope, audience: c3.audience || "default"})];
              case 6:
                throw (v4 = b4.sent()).error === "login_required" && this.logout({localOnly: true}), v4;
              case 7:
                return [2];
            }
            var g4, w4, k4;
          });
        });
      }, e3.prototype._getTokenUsingRefreshToken = function(e4) {
        return k3(this, void 0, void 0, function() {
          var t3, n3, r3, o3, i3, a3, c3, s3, u3;
          return T3(this, function(l3) {
            switch (l3.label) {
              case 0:
                return e4.scope = Na(this.defaultScope, this.options.scope, e4.scope), [4, this.cacheManager.get(new Pa({scope: e4.scope, audience: e4.audience || "default", client_id: this.options.client_id}))];
              case 1:
                return (t3 = l3.sent()) && t3.refresh_token || this.worker ? [3, 3] : [4, this._getTokenFromIFrame(e4)];
              case 2:
                return [2, l3.sent()];
              case 3:
                n3 = e4.redirect_uri || this.options.redirect_uri || window.location.origin, o3 = e4.scope, i3 = e4.audience, a3 = I3(e4, ["scope", "audience", "ignoreCache", "timeoutInSeconds", "detailedResponse"]), c3 = typeof e4.timeoutInSeconds == "number" ? 1e3 * e4.timeoutInSeconds : null, l3.label = 4;
              case 4:
                return l3.trys.push([4, 6, , 9]), [4, ja(S3(S3(S3(S3(S3({}, this.customOptions), a3), {audience: i3, scope: o3, baseUrl: this.domainUrl, client_id: this.options.client_id, grant_type: "refresh_token", refresh_token: t3 && t3.refresh_token, redirect_uri: n3}), c3 && {timeout: c3}), {auth0Client: this.options.auth0Client, useFormData: this.options.useFormData}), this.worker)];
              case 5:
                return r3 = l3.sent(), [3, 9];
              case 6:
                return (s3 = l3.sent()).message === "The web worker is missing the refresh token" || s3.message && s3.message.indexOf("invalid refresh token") > -1 ? [4, this._getTokenFromIFrame(e4)] : [3, 8];
              case 7:
                return [2, l3.sent()];
              case 8:
                throw s3;
              case 9:
                return [4, this._verifyIdToken(r3.id_token)];
              case 10:
                return u3 = l3.sent(), [2, S3(S3({}, r3), {decodedToken: u3, scope: e4.scope, oauthTokenScope: r3.scope, audience: e4.audience || "default"})];
            }
          });
        });
      }, e3.prototype._getEntryFromCache = function(e4) {
        var t3 = e4.scope, n3 = e4.audience, r3 = e4.client_id, o3 = e4.getDetailedEntry, i3 = o3 !== void 0 && o3;
        return k3(this, void 0, void 0, function() {
          var e5, o4, a3, c3, s3;
          return T3(this, function(u3) {
            switch (u3.label) {
              case 0:
                return [4, this.cacheManager.get(new Pa({scope: t3, audience: n3, client_id: r3}), 60)];
              case 1:
                return (e5 = u3.sent()) && e5.access_token ? i3 ? (o4 = e5.id_token, a3 = e5.access_token, c3 = e5.oauthTokenScope, s3 = e5.expires_in, [2, S3(S3({id_token: o4, access_token: a3}, c3 ? {scope: c3} : null), {expires_in: s3})]) : [2, e5.access_token] : [2];
            }
          });
        });
      }, e3;
    }();
    var dc = {client_id: "p6VtJXuHxzMbduitjEwHo8Aog8KoFAHe", domain: "zea-staging.auth0.com", redirect_uri: `${window.location.origin}/sign-in-callback`, audience: "cloud-api.zea.live"};
    var hc;
    var pc;
    var yc = re2(null, (e3) => {
      if (console.info("Subscribers went from zero to one in `authClient` readable store."), !hc)
        return function(e4) {
          return k3(this, void 0, void 0, function() {
            var t3;
            return T3(this, function(n3) {
              switch (n3.label) {
                case 0:
                  return [4, (t3 = new fc(e4)).checkSession()];
                case 1:
                  return n3.sent(), [2, t3];
              }
            });
          });
        }(dc).then((t3) => {
          hc = t3, e3(t3);
        }), () => {
          console.info("Subscribers went from one to zero in `authClient` readable store.");
        };
      e3(hc);
    });
    function mc(e3) {
      let t3, n3;
      return t3 = new b3({}), {c() {
        Bt2(t3.$$.fragment);
      }, m(e4, r3) {
        Dt(t3, e4, r3), n3 = true;
      }, p: t2, i(e4) {
        n3 || (St(t3.$$.fragment, e4), n3 = true);
      }, o(e4) {
        Lt(t3.$$.fragment, e4), n3 = false;
      }, d(e4) {
        Ut(t3, e4);
      }};
    }
    function vc(e3, t3, n3) {
      let r3, o3;
      return p2(e3, je2, (e4) => n3(0, r3 = e4)), p2(e3, yc, (e4) => n3(1, o3 = e4)), e3.$$.update = () => {
        if (3 & e3.$$.dirty && o3) {
          const e4 = new URLSearchParams(window.location.search);
          e4.has("code") && e4.has("state") && o3.handleRedirectCallback().then(() => {
            e4.delete("code"), e4.delete("state"), r3(`/?${e4.toString()}`);
          });
        }
      }, [r3, o3];
    }
    ie2(yc, (e3, t3) => {
      pc ? t3(pc) : e3 && e3.isAuthenticated().then((n3) => {
        n3 && e3.getUser().then((e4) => {
          pc = e4, t3(e4);
        });
      });
    });
    var bc = class extends Kt {
      constructor(e3) {
        super(), Ht(this, e3, vc, mc, a2, {});
      }
    };
  });

  // dist/build/_reset-c057f75c.js
  var require_reset_c057f75c = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => p3
    });
    function r3(s3) {
      let t3;
      const a3 = s3[1].default, r4 = d2(a3, s3, s3[0], null);
      return {c() {
        r4 && r4.c();
      }, m(s4, a4) {
        r4 && r4.m(s4, a4), t3 = true;
      }, p(s4, [e3]) {
        r4 && r4.p && (!t3 || 1 & e3) && g2(r4, a3, s4, s4[0], t3 ? m2(a3, s4[0], e3, null) : $2(s4[0]), null);
      }, i(s4) {
        t3 || (St(r4, s4), t3 = true);
      }, o(s4) {
        Lt(r4, s4), t3 = false;
      }, d(s4) {
        r4 && r4.d(s4);
      }};
    }
    function $3(s3, t3, a3) {
      let {$$slots: e3 = {}, $$scope: n3} = t3;
      return s3.$$set = (s4) => {
        "$$scope" in s4 && a3(0, n3 = s4.$$scope);
      }, [n3, e3];
    }
    var p3 = class extends Kt {
      constructor(s3) {
        super(), Ht(this, s3, $3, r3, a2, {});
      }
    };
  });

  // dist/build/_layout-bb6274c2.js
  var require_layout_bb6274c2 = __commonJS((exports) => {
    __markAsModule(exports);
    __export(exports, {
      default: () => q3
    });
    function x3(s3) {
      let t3;
      const e3 = s3[1].default, r3 = d2(e3, s3, s3[0], null);
      return {c() {
        r3 && r3.c();
      }, m(s4, e4) {
        r3 && r3.m(s4, e4), t3 = true;
      }, p(s4, [n3]) {
        r3 && r3.p && (!t3 || 1 & n3) && g2(r3, e3, s4, s4[0], t3 ? m2(e3, s4[0], n3, null) : $2(s4[0]), null);
      }, i(s4) {
        t3 || (St(r3, s4), t3 = true);
      }, o(s4) {
        Lt(r3, s4), t3 = false;
      }, d(s4) {
        r3 && r3.d(s4);
      }};
    }
    function w3(s3, t3, e3) {
      let n3;
      p2(s3, je2, (s4) => e3(2, n3 = s4));
      let {$$slots: o3 = {}, $$scope: a3} = t3;
      const c3 = new URLSearchParams(window.location.search);
      return n3(`/?${c3.toString()}`), s3.$$set = (s4) => {
        "$$scope" in s4 && e3(0, a3 = s4.$$scope);
      }, [a3, o3];
    }
    var b3 = class extends Kt {
      constructor(s3) {
        super(), Ht(this, s3, w3, x3, a2, {});
      }
    };
    function S3(s3) {
      let t3, e3;
      const r3 = s3[0].default, u3 = d2(r3, s3, s3[1], null);
      return {c() {
        t3 = N2("div"), u3 && u3.c(), D2(t3, "class", "h-full bg-background text-foreground");
      }, m(s4, n3) {
        I2(s4, t3, n3), u3 && u3.m(t3, null), e3 = true;
      }, p(s4, t4) {
        u3 && u3.p && (!e3 || 2 & t4) && g2(u3, r3, s4, s4[1], e3 ? m2(r3, s4[1], t4, null) : $2(s4[1]), null);
      }, i(s4) {
        e3 || (St(u3, s4), e3 = true);
      }, o(s4) {
        Lt(u3, s4), e3 = false;
      }, d(s4) {
        s4 && S2(t3), u3 && u3.d(s4);
      }};
    }
    function k3(s3) {
      let t3, e3;
      return t3 = new b3({props: {$$slots: {default: [S3]}, $$scope: {ctx: s3}}}), {c() {
        Bt2(t3.$$.fragment);
      }, m(s4, n3) {
        Dt(t3, s4, n3), e3 = true;
      }, p(s4, [e4]) {
        const n3 = {};
        2 & e4 && (n3.$$scope = {dirty: e4, ctx: s4}), t3.$set(n3);
      }, i(s4) {
        e3 || (St(t3.$$.fragment, s4), e3 = true);
      }, o(s4) {
        Lt(t3.$$.fragment, s4), e3 = false;
      }, d(s4) {
        Ut(t3, s4);
      }};
    }
    function j3(s3, t3, e3) {
      let {$$slots: n3 = {}, $$scope: o3} = t3;
      return s3.$$set = (s4) => {
        "$$scope" in s4 && e3(1, o3 = s4.$$scope);
      }, [n3, o3];
    }
    var q3 = class extends Kt {
      constructor(s3) {
        super(), Ht(this, s3, j3, k3, a2, {});
      }
    };
  });

  // dist/build/main.js
  function t2() {
  }
  var e2 = (t3) => t3;
  function n2(t3, e3) {
    for (const n3 in e3)
      t3[n3] = e3[n3];
    return t3;
  }
  function o2(t3) {
    return t3();
  }
  function r2() {
    return Object.create(null);
  }
  function s2(t3) {
    t3.forEach(o2);
  }
  function i2(t3) {
    return typeof t3 == "function";
  }
  function a2(t3, e3) {
    return t3 != t3 ? e3 == e3 : t3 !== e3 || t3 && typeof t3 == "object" || typeof t3 == "function";
  }
  var c2;
  function l2(t3, e3) {
    return c2 || (c2 = document.createElement("a")), c2.href = e3, t3 === c2.href;
  }
  function u2(e3, ...n3) {
    if (e3 == null)
      return t2;
    const o3 = e3.subscribe(...n3);
    return o3.unsubscribe ? () => o3.unsubscribe() : o3;
  }
  function f2(t3) {
    let e3;
    return u2(t3, (t4) => e3 = t4)(), e3;
  }
  function p2(t3, e3, n3) {
    t3.$$.on_destroy.push(u2(e3, n3));
  }
  function d2(t3, e3, n3, o3) {
    if (t3) {
      const r3 = h2(t3, e3, n3, o3);
      return t3[0](r3);
    }
  }
  function h2(t3, e3, o3, r3) {
    return t3[1] && r3 ? n2(o3.ctx.slice(), t3[1](r3(e3))) : o3.ctx;
  }
  function m2(t3, e3, n3, o3) {
    if (t3[2] && o3) {
      const r3 = t3[2](o3(n3));
      if (e3.dirty === void 0)
        return r3;
      if (typeof r3 == "object") {
        const t4 = [], n4 = Math.max(e3.dirty.length, r3.length);
        for (let o4 = 0; o4 < n4; o4 += 1)
          t4[o4] = e3.dirty[o4] | r3[o4];
        return t4;
      }
      return e3.dirty | r3;
    }
    return e3.dirty;
  }
  function g2(t3, e3, n3, o3, r3, s3) {
    if (r3) {
      const i3 = h2(e3, n3, o3, s3);
      t3.p(i3, r3);
    }
  }
  function $2(t3) {
    if (t3.ctx.length > 32) {
      const e3 = [], n3 = t3.ctx.length / 32;
      for (let t4 = 0; t4 < n3; t4++)
        e3[t4] = -1;
      return e3;
    }
    return -1;
  }
  function y2(t3) {
    const e3 = {};
    for (const n3 in t3)
      n3[0] !== "$" && (e3[n3] = t3[n3]);
    return e3;
  }
  function b2(t3, e3) {
    const n3 = {};
    e3 = new Set(e3);
    for (const o3 in t3)
      e3.has(o3) || o3[0] === "$" || (n3[o3] = t3[o3]);
    return n3;
  }
  function _2(t3, e3, n3) {
    return t3.set(n3), e3;
  }
  var w2 = typeof window != "undefined";
  var x2 = w2 ? () => window.performance.now() : () => Date.now();
  var v2 = w2 ? (t3) => requestAnimationFrame(t3) : t2;
  var P2 = new Set();
  function k2(t3) {
    P2.forEach((e3) => {
      e3.c(t3) || (P2.delete(e3), e3.f());
    }), P2.size !== 0 && v2(k2);
  }
  function E2(t3, e3) {
    t3.appendChild(e3);
  }
  function j2(t3) {
    if (!t3)
      return document;
    const e3 = t3.getRootNode ? t3.getRootNode() : t3.ownerDocument;
    return e3 && e3.host ? e3 : t3.ownerDocument;
  }
  function O2(t3) {
    const e3 = N2("style");
    return function(t4, e4) {
      E2(t4.head || t4, e4);
    }(j2(t3), e3), e3;
  }
  function I2(t3, e3, n3) {
    t3.insertBefore(e3, n3 || null);
  }
  function S2(t3) {
    t3.parentNode.removeChild(t3);
  }
  function L2(t3, e3) {
    for (let n3 = 0; n3 < t3.length; n3 += 1)
      t3[n3] && t3[n3].d(e3);
  }
  function N2(t3) {
    return document.createElement(t3);
  }
  function R2(t3) {
    return document.createElementNS("http://www.w3.org/2000/svg", t3);
  }
  function T2(t3) {
    return document.createTextNode(t3);
  }
  function A2() {
    return T2(" ");
  }
  function F2() {
    return T2("");
  }
  function C2(t3, e3, n3, o3) {
    return t3.addEventListener(e3, n3, o3), () => t3.removeEventListener(e3, n3, o3);
  }
  function M2(t3) {
    return function(e3) {
      return e3.preventDefault(), t3.call(this, e3);
    };
  }
  function q2(t3) {
    return function(e3) {
      return e3.stopPropagation(), t3.call(this, e3);
    };
  }
  function B2(t3) {
    return function(e3) {
      e3.target === this && t3.call(this, e3);
    };
  }
  function D2(t3, e3, n3) {
    n3 == null ? t3.removeAttribute(e3) : t3.getAttribute(e3) !== n3 && t3.setAttribute(e3, n3);
  }
  function U2(t3, e3) {
    const n3 = Object.getOwnPropertyDescriptors(t3.__proto__);
    for (const o3 in e3)
      e3[o3] == null ? t3.removeAttribute(o3) : o3 === "style" ? t3.style.cssText = e3[o3] : o3 === "__value" ? t3.value = t3[o3] = e3[o3] : n3[o3] && n3[o3].set ? t3[o3] = e3[o3] : D2(t3, o3, e3[o3]);
  }
  function H2(t3) {
    return t3 === "" ? null : +t3;
  }
  function K2(t3, e3) {
    e3 = "" + e3, t3.wholeText !== e3 && (t3.data = e3);
  }
  function z2(t3, e3) {
    t3.value = e3 == null ? "" : e3;
  }
  function W2(t3, e3, n3, o3) {
    t3.style.setProperty(e3, n3, o3 ? "important" : "");
  }
  function J2(t3, e3, n3) {
    t3.classList[n3 ? "add" : "remove"](e3);
  }
  function G2(t3, e3, n3 = false) {
    const o3 = document.createEvent("CustomEvent");
    return o3.initCustomEvent(t3, n3, false, e3), o3;
  }
  var Q2 = new Set();
  var V2;
  var Z2 = 0;
  function X2(t3, e3, n3, o3, r3, s3, i3, a3 = 0) {
    const c3 = 16.666 / o3;
    let l3 = "{\n";
    for (let t4 = 0; t4 <= 1; t4 += c3) {
      const o4 = e3 + (n3 - e3) * s3(t4);
      l3 += 100 * t4 + `%{${i3(o4, 1 - o4)}}
`;
    }
    const u3 = l3 + `100% {${i3(n3, 1 - n3)}}
}`, f3 = `__svelte_${function(t4) {
      let e4 = 5381, n4 = t4.length;
      for (; n4--; )
        e4 = (e4 << 5) - e4 ^ t4.charCodeAt(n4);
      return e4 >>> 0;
    }(u3)}_${a3}`, p3 = j2(t3);
    Q2.add(p3);
    const d3 = p3.__svelte_stylesheet || (p3.__svelte_stylesheet = O2(t3).sheet), h3 = p3.__svelte_rules || (p3.__svelte_rules = {});
    h3[f3] || (h3[f3] = true, d3.insertRule(`@keyframes ${f3} ${u3}`, d3.cssRules.length));
    const m3 = t3.style.animation || "";
    return t3.style.animation = `${m3 ? `${m3}, ` : ""}${f3} ${o3}ms linear ${r3}ms 1 both`, Z2 += 1, f3;
  }
  function Y2(t3, e3) {
    const n3 = (t3.style.animation || "").split(", "), o3 = n3.filter(e3 ? (t4) => t4.indexOf(e3) < 0 : (t4) => t4.indexOf("__svelte") === -1), r3 = n3.length - o3.length;
    r3 && (t3.style.animation = o3.join(", "), Z2 -= r3, Z2 || v2(() => {
      Z2 || (Q2.forEach((t4) => {
        const e4 = t4.__svelte_stylesheet;
        let n4 = e4.cssRules.length;
        for (; n4--; )
          e4.deleteRule(n4);
        t4.__svelte_rules = {};
      }), Q2.clear());
    }));
  }
  function tt2(t3) {
    V2 = t3;
  }
  function et2() {
    if (!V2)
      throw new Error("Function called outside component initialization");
    return V2;
  }
  function nt(t3) {
    et2().$$.before_update.push(t3);
  }
  function ot(t3) {
    et2().$$.on_mount.push(t3);
  }
  function rt(t3) {
    et2().$$.after_update.push(t3);
  }
  function st(t3) {
    et2().$$.on_destroy.push(t3);
  }
  function it2() {
    const t3 = et2();
    return (e3, n3) => {
      const o3 = t3.$$.callbacks[e3];
      if (o3) {
        const r3 = G2(e3, n3);
        o3.slice().forEach((e4) => {
          e4.call(t3, r3);
        });
      }
    };
  }
  function at(t3, e3) {
    et2().$$.context.set(t3, e3);
  }
  function ct(t3) {
    return et2().$$.context.get(t3);
  }
  function lt(t3, e3) {
    const n3 = t3.$$.callbacks[e3.type];
    n3 && n3.slice().forEach((t4) => t4.call(this, e3));
  }
  var ut = [];
  var ft = [];
  var pt = [];
  var dt = [];
  var ht = Promise.resolve();
  var mt = false;
  function gt2() {
    mt || (mt = true, ht.then(xt));
  }
  function $t() {
    return gt2(), ht;
  }
  function yt(t3) {
    pt.push(t3);
  }
  function bt(t3) {
    dt.push(t3);
  }
  var _t = false;
  var wt = new Set();
  function xt() {
    if (!_t) {
      _t = true;
      do {
        for (let t3 = 0; t3 < ut.length; t3 += 1) {
          const e3 = ut[t3];
          tt2(e3), vt(e3.$$);
        }
        for (tt2(null), ut.length = 0; ft.length; )
          ft.pop()();
        for (let t3 = 0; t3 < pt.length; t3 += 1) {
          const e3 = pt[t3];
          wt.has(e3) || (wt.add(e3), e3());
        }
        pt.length = 0;
      } while (ut.length);
      for (; dt.length; )
        dt.pop()();
      mt = false, _t = false, wt.clear();
    }
  }
  function vt(t3) {
    if (t3.fragment !== null) {
      t3.update(), s2(t3.before_update);
      const e3 = t3.dirty;
      t3.dirty = [-1], t3.fragment && t3.fragment.p(t3.ctx, e3), t3.after_update.forEach(yt);
    }
  }
  var Pt;
  function kt(t3, e3, n3) {
    t3.dispatchEvent(G2(`${e3 ? "intro" : "outro"}${n3}`));
  }
  var Et = new Set();
  var jt;
  function Ot() {
    jt = {r: 0, c: [], p: jt};
  }
  function It2() {
    jt.r || s2(jt.c), jt = jt.p;
  }
  function St(t3, e3) {
    t3 && t3.i && (Et.delete(t3), t3.i(e3));
  }
  function Lt(t3, e3, n3, o3) {
    if (t3 && t3.o) {
      if (Et.has(t3))
        return;
      Et.add(t3), jt.c.push(() => {
        Et.delete(t3), o3 && (n3 && t3.d(1), o3());
      }), t3.o(e3);
    }
  }
  var Nt = {duration: 0};
  function Rt(n3, o3, r3, a3) {
    let c3 = o3(n3, r3), l3 = a3 ? 0 : 1, u3 = null, f3 = null, p3 = null;
    function d3() {
      p3 && Y2(n3, p3);
    }
    function h3(t3, e3) {
      const n4 = t3.b - l3;
      return e3 *= Math.abs(n4), {a: l3, b: t3.b, d: n4, duration: e3, start: t3.start, end: t3.start + e3, group: t3.group};
    }
    function m3(o4) {
      const {delay: r4 = 0, duration: i3 = 300, easing: a4 = e2, tick: m4 = t2, css: g3} = c3 || Nt, $3 = {start: x2() + r4, b: o4};
      o4 || ($3.group = jt, jt.r += 1), u3 || f3 ? f3 = $3 : (g3 && (d3(), p3 = X2(n3, l3, o4, i3, r4, a4, g3)), o4 && m4(0, 1), u3 = h3($3, i3), yt(() => kt(n3, o4, "start")), function(t3) {
        let e3;
        P2.size === 0 && v2(k2), new Promise((n4) => {
          P2.add(e3 = {c: t3, f: n4});
        });
      }((t3) => {
        if (f3 && t3 > f3.start && (u3 = h3(f3, i3), f3 = null, kt(n3, u3.b, "start"), g3 && (d3(), p3 = X2(n3, l3, u3.b, u3.duration, 0, a4, c3.css))), u3) {
          if (t3 >= u3.end)
            m4(l3 = u3.b, 1 - l3), kt(n3, u3.b, "end"), f3 || (u3.b ? d3() : --u3.group.r || s2(u3.group.c)), u3 = null;
          else if (t3 >= u3.start) {
            const e3 = t3 - u3.start;
            l3 = u3.a + u3.d * a4(e3 / u3.duration), m4(l3, 1 - l3);
          }
        }
        return !(!u3 && !f3);
      }));
    }
    return {run(t3) {
      i2(c3) ? (Pt || (Pt = Promise.resolve(), Pt.then(() => {
        Pt = null;
      })), Pt).then(() => {
        c3 = c3(), m3(t3);
      }) : m3(t3);
    }, end() {
      d3(), u3 = f3 = null;
    }};
  }
  function Tt(t3, e3) {
    t3.d(1), e3.delete(t3.key);
  }
  function At2(t3, e3) {
    Lt(t3, 1, 1, () => {
      e3.delete(t3.key);
    });
  }
  function Ft(t3, e3, n3, o3, r3, s3, i3, a3, c3, l3, u3, f3) {
    let p3 = t3.length, d3 = s3.length, h3 = p3;
    const m3 = {};
    for (; h3--; )
      m3[t3[h3].key] = h3;
    const g3 = [], $3 = new Map(), y3 = new Map();
    for (h3 = d3; h3--; ) {
      const t4 = f3(r3, s3, h3), a4 = n3(t4);
      let c4 = i3.get(a4);
      c4 ? o3 && c4.p(t4, e3) : (c4 = l3(a4, t4), c4.c()), $3.set(a4, g3[h3] = c4), a4 in m3 && y3.set(a4, Math.abs(h3 - m3[a4]));
    }
    const b3 = new Set(), _3 = new Set();
    function w3(t4) {
      St(t4, 1), t4.m(a3, u3), i3.set(t4.key, t4), u3 = t4.first, d3--;
    }
    for (; p3 && d3; ) {
      const e4 = g3[d3 - 1], n4 = t3[p3 - 1], o4 = e4.key, r4 = n4.key;
      e4 === n4 ? (u3 = e4.first, p3--, d3--) : $3.has(r4) ? !i3.has(o4) || b3.has(o4) ? w3(e4) : _3.has(r4) ? p3-- : y3.get(o4) > y3.get(r4) ? (_3.add(o4), w3(e4)) : (b3.add(r4), p3--) : (c3(n4, i3), p3--);
    }
    for (; p3--; ) {
      const e4 = t3[p3];
      $3.has(e4.key) || c3(e4, i3);
    }
    for (; d3; )
      w3(g3[d3 - 1]);
    return g3;
  }
  function Ct2(t3, e3) {
    const n3 = {}, o3 = {}, r3 = {$$scope: 1};
    let s3 = t3.length;
    for (; s3--; ) {
      const i3 = t3[s3], a3 = e3[s3];
      if (a3) {
        for (const t4 in i3)
          t4 in a3 || (o3[t4] = 1);
        for (const t4 in a3)
          r3[t4] || (n3[t4] = a3[t4], r3[t4] = 1);
        t3[s3] = a3;
      } else
        for (const t4 in i3)
          r3[t4] = 1;
    }
    for (const t4 in o3)
      t4 in n3 || (n3[t4] = void 0);
    return n3;
  }
  function Mt(t3) {
    return typeof t3 == "object" && t3 !== null ? t3 : {};
  }
  function qt(t3, e3, n3) {
    const o3 = t3.$$.props[e3];
    o3 !== void 0 && (t3.$$.bound[o3] = n3, n3(t3.$$.ctx[o3]));
  }
  function Bt2(t3) {
    t3 && t3.c();
  }
  function Dt(t3, e3, n3, r3) {
    const {fragment: a3, on_mount: c3, on_destroy: l3, after_update: u3} = t3.$$;
    a3 && a3.m(e3, n3), r3 || yt(() => {
      const e4 = c3.map(o2).filter(i2);
      l3 ? l3.push(...e4) : s2(e4), t3.$$.on_mount = [];
    }), u3.forEach(yt);
  }
  function Ut(t3, e3) {
    const n3 = t3.$$;
    n3.fragment !== null && (s2(n3.on_destroy), n3.fragment && n3.fragment.d(e3), n3.on_destroy = n3.fragment = null, n3.ctx = []);
  }
  function Ht(e3, n3, o3, i3, a3, c3, l3, u3 = [-1]) {
    const f3 = V2;
    tt2(e3);
    const p3 = e3.$$ = {fragment: null, ctx: null, props: c3, update: t2, not_equal: a3, bound: r2(), on_mount: [], on_destroy: [], on_disconnect: [], before_update: [], after_update: [], context: new Map(n3.context || (f3 ? f3.$$.context : [])), callbacks: r2(), dirty: u3, skip_bound: false, root: n3.target || f3.$$.root};
    l3 && l3(p3.root);
    let d3 = false;
    if (p3.ctx = o3 ? o3(e3, n3.props || {}, (t3, n4, ...o4) => {
      const r3 = o4.length ? o4[0] : n4;
      return p3.ctx && a3(p3.ctx[t3], p3.ctx[t3] = r3) && (!p3.skip_bound && p3.bound[t3] && p3.bound[t3](r3), d3 && function(t4, e4) {
        t4.$$.dirty[0] === -1 && (ut.push(t4), gt2(), t4.$$.dirty.fill(0)), t4.$$.dirty[e4 / 31 | 0] |= 1 << e4 % 31;
      }(e3, t3)), n4;
    }) : [], p3.update(), d3 = true, s2(p3.before_update), p3.fragment = !!i3 && i3(p3.ctx), n3.target) {
      if (n3.hydrate) {
        const t3 = function(t4) {
          return Array.from(t4.childNodes);
        }(n3.target);
        p3.fragment && p3.fragment.l(t3), t3.forEach(S2);
      } else
        p3.fragment && p3.fragment.c();
      n3.intro && St(e3.$$.fragment), Dt(e3, n3.target, n3.anchor, n3.customElement), xt();
    }
    tt2(f3);
  }
  var Kt = class {
    $destroy() {
      Ut(this, 1), this.$destroy = t2;
    }
    $on(t3, e3) {
      const n3 = this.$$.callbacks[t3] || (this.$$.callbacks[t3] = []);
      return n3.push(e3), () => {
        const t4 = n3.indexOf(e3);
        t4 !== -1 && n3.splice(t4, 1);
      };
    }
    $set(t3) {
      var e3;
      this.$$set && (e3 = t3, Object.keys(e3).length !== 0) && (this.$$.skip_bound = true, this.$$set(t3), this.$$.skip_bound = false);
    }
  };
  var zt = {queryHandler: {parse: (t3) => {
    return e3 = new URLSearchParams(t3), [...e3].reduce((t4, [e4, n3]) => (t4[e4] = n3, t4), {});
    var e3;
  }, stringify: (t3) => "?" + new URLSearchParams(t3).toString()}, urlTransform: {apply: (t3) => t3, remove: (t3) => t3}, useHash: false};
  var Wt = RegExp(/\:([^/()]+)/g);
  function Jt(t3, e3) {
    if (navigator.userAgent.includes("jsdom"))
      return false;
    e3 && Gt(t3), function() {
      if (navigator.userAgent.includes("jsdom"))
        return false;
      const {hash: t4} = window.location;
      if (t4) {
        if (/^[A-Za-z]+[\w\-\:\.]*$/.test(t4.substring(1))) {
          const e4 = document.querySelector(t4);
          e4 && e4.scrollIntoView();
        }
      }
    }();
  }
  function Gt(t3) {
    t3 && t3.scrollTo && t3.dataset.routify !== "scroll-lock" && t3.dataset["routify-scroll"] !== "lock" && (t3.style["scroll-behavior"] = "auto", t3.scrollTo({top: 0, behavior: "auto"}), t3.style["scroll-behavior"] = "", Gt(t3.parentElement));
  }
  var Qt = (t3) => {
    const e3 = [];
    let n3;
    for (; n3 = Wt.exec(t3); )
      e3.push(n3[1]);
    return e3;
  };
  function Vt(t3, e3) {
    Vt._console = Vt._console || {log: console.log, warn: console.warn};
    const {_console: n3} = Vt, o3 = t3.componentFile.name.replace(/Proxy<_?(.+)>/, "$1").replace(/^Index$/, t3.component.shortPath.split("/").pop()).replace(/^./, (t4) => t4.toUpperCase()).replace(/\:(.+)/, "U5B$1u5D"), r3 = [`<${o3}> received an unexpected slot "default".`, `<${o3}> was created with unknown prop 'scoped'`, `<${o3}> was created with unknown prop 'scopedSync'`];
    for (const t4 of ["log", "warn"])
      console[t4] = (...e4) => {
        r3.includes(e4[0]) || n3[t4](...e4);
      }, e3().then(() => {
        console[t4] = n3[t4];
      });
  }
  function Zt() {
    let t3 = window.location.pathname + window.location.search + window.location.hash;
    const {url: e3, options: n3} = function(t4) {
      const [e4, n4] = t4.split("__[[routify_url_options]]__"), o3 = JSON.parse(decodeURIComponent(n4 || "") || "{}");
      return window.routify = window.routify || {}, window.routify.prefetched = o3.prefetch, {url: e4, options: o3};
    }(t3);
    return {...Xt(e3), options: n3};
  }
  function Xt(t3) {
    zt.useHash && (t3 = t3.replace(/.*#(.+)/, "$1"));
    const e3 = t3.startsWith("/") ? window.location.origin : void 0, n3 = new URL(t3, e3);
    return {url: n3, fullpath: n3.pathname + n3.search + n3.hash};
  }
  function Yt(t3, e3, n3) {
    const o3 = zt.useHash ? "#" : "";
    let r3;
    return r3 = function(t4, e4, n4) {
      const o4 = Object.assign({}, n4, e4), r4 = function(t5, e5) {
        if (!zt.queryHandler)
          return "";
        const n5 = Qt(t5), o5 = {};
        e5 && Object.entries(e5).forEach(([t6, e6]) => {
          n5.includes(t6) || (o5[t6] = e6);
        });
        return zt.queryHandler.stringify(o5).replace(/\?$/, "");
      }(t4, e4);
      for (const [e5, n5] of Object.entries(o4))
        t4 = t4.replace(`:${e5}`, n5);
      return `${t4}${r4}`;
    }(t3, e3, n3), r3 = zt.urlTransform.apply(r3), r3 = o3 + r3, r3;
  }
  function te2(t3) {
    let e3;
    const n3 = t3[2].default, o3 = d2(n3, t3, t3[1], null);
    return {c() {
      o3 && o3.c();
    }, m(t4, n4) {
      o3 && o3.m(t4, n4), e3 = true;
    }, p(t4, [r3]) {
      o3 && o3.p && (!e3 || 2 & r3) && g2(o3, n3, t4, t4[1], e3 ? m2(n3, t4[1], r3, null) : $2(t4[1]), null);
    }, i(t4) {
      e3 || (St(o3, t4), e3 = true);
    }, o(t4) {
      Lt(o3, t4), e3 = false;
    }, d(t4) {
      o3 && o3.d(t4);
    }};
  }
  function ee2(t3, e3, n3) {
    let {$$slots: o3 = {}, $$scope: r3} = e3, {scoped: s3 = {}} = e3;
    return t3.$$set = (t4) => {
      "scoped" in t4 && n3(0, s3 = t4.scoped), "$$scope" in t4 && n3(1, r3 = t4.$$scope);
    }, [s3, r3, o3];
  }
  var ne2 = class extends Kt {
    constructor(t3) {
      super(), Ht(this, t3, ee2, te2, a2, {scoped: 0});
    }
  };
  var oe2 = [];
  function re2(t3, e3) {
    return {subscribe: se2(t3, e3).subscribe};
  }
  function se2(e3, n3 = t2) {
    let o3;
    const r3 = new Set();
    function s3(t3) {
      if (a2(e3, t3) && (e3 = t3, o3)) {
        const t4 = !oe2.length;
        for (const t5 of r3)
          t5[1](), oe2.push(t5, e3);
        if (t4) {
          for (let t5 = 0; t5 < oe2.length; t5 += 2)
            oe2[t5][0](oe2[t5 + 1]);
          oe2.length = 0;
        }
      }
    }
    return {set: s3, update: function(t3) {
      s3(t3(e3));
    }, subscribe: function(i3, a3 = t2) {
      const c3 = [i3, a3];
      return r3.add(c3), r3.size === 1 && (o3 = n3(s3) || t2), i3(e3), () => {
        r3.delete(c3), r3.size === 0 && (o3(), o3 = null);
      };
    }};
  }
  function ie2(e3, n3, o3) {
    const r3 = !Array.isArray(e3), a3 = r3 ? [e3] : e3, c3 = n3.length < 2;
    return re2(o3, (e4) => {
      let o4 = false;
      const l3 = [];
      let f3 = 0, p3 = t2;
      const d3 = () => {
        if (f3)
          return;
        p3();
        const o5 = n3(r3 ? l3[0] : l3, e4);
        c3 ? e4(o5) : p3 = i2(o5) ? o5 : t2;
      }, h3 = a3.map((t3, e5) => u2(t3, (t4) => {
        l3[e5] = t4, f3 &= ~(1 << e5), o4 && d3();
      }, () => {
        f3 |= 1 << e5;
      }));
      return o4 = true, d3(), function() {
        s2(h3), p3();
      };
    });
  }
  window.routify = window.routify || {};
  var ae2 = se2(null);
  var ce2 = se2([]);
  ce2.subscribe((t3) => window.routify.routes = t3);
  var le2 = se2({component: {params: {}}});
  var ue2 = se2(null);
  var fe2 = se2(true);
  function pe2(t3, e3 = false) {
    t3 = zt.urlTransform.remove(t3);
    let {pathname: n3, search: o3} = Xt(t3).url;
    const r3 = f2(ce2), s3 = r3.find((t4) => n3 === t4.meta.name) || r3.find((t4) => n3.match(t4.regex));
    if (!s3)
      throw new Error(`Route could not be found for "${n3}".`);
    const i3 = e3 ? Object.create(s3) : s3, {route: a3, redirectPath: c3, rewritePath: l3} = de2(i3, r3);
    return l3 && ({pathname: n3, search: o3} = Xt(Yt(l3, a3.params)).url, c3 && (a3.redirectTo = Yt(c3, a3.params || {}))), zt.queryHandler && (a3.params = Object.assign({}, zt.queryHandler.parse(o3))), function(t4, e4) {
      if (t4.paramKeys) {
        const n4 = function(t5) {
          const e5 = [];
          return t5.forEach((t6) => {
            e5[t6.path.split("/").filter(Boolean).length - 1] = t6;
          }), e5;
        }(t4.layouts), o4 = e4.split("/").filter(Boolean), r4 = function(t5) {
          return t5.split("/").filter(Boolean).map((t6) => t6.match(/\:(.+)/)).map((t6) => t6 && t6[1]);
        }(t4.path);
        r4.forEach((e5, r5) => {
          e5 && (t4.params[e5] = o4[r5], n4[r5] ? n4[r5].param = {[e5]: o4[r5]} : t4.param = {[e5]: o4[r5]});
        });
      }
    }(a3, n3), a3.leftover = t3.replace(new RegExp(a3.regex), ""), a3;
  }
  function de2(t3, e3, n3, o3) {
    const {redirect: r3, rewrite: s3} = t3.meta;
    if (r3 || s3) {
      n3 = r3 ? r3.path || r3 : n3, o3 = s3 ? s3.path || s3 : n3;
      const i3 = r3 && r3.params, a3 = s3 && s3.params, c3 = e3.find((t4) => t4.path.replace(/\/index$/, "") === o3);
      return c3 === t3 && console.error(`${o3} is redirecting to itself`), c3 || console.error(`${t3.path} is redirecting to non-existent path: ${o3}`), (i3 || a3) && (c3.params = Object.assign({}, c3.params, i3, a3)), de2(c3, e3, n3, o3);
    }
    return {route: t3, redirectPath: n3, rewritePath: o3};
  }
  function he2(t3, e3, n3) {
    const o3 = t3.slice();
    return o3[1] = e3[n3], o3;
  }
  function me2(t3, e3) {
    let n3, o3;
    return {key: t3, first: null, c() {
      n3 = N2("iframe"), l2(n3.src, o3 = e3[1].url) || D2(n3, "src", o3), D2(n3, "frameborder", "0"), D2(n3, "title", "routify prefetcher"), this.first = n3;
    }, m(t4, e4) {
      I2(t4, n3, e4);
    }, p(t4, r3) {
      e3 = t4, 1 & r3 && !l2(n3.src, o3 = e3[1].url) && D2(n3, "src", o3);
    }, d(t4) {
      t4 && S2(n3);
    }};
  }
  function ge2(e3) {
    let n3, o3 = [], r3 = new Map(), s3 = e3[0];
    const i3 = (t3) => t3[1].options.prefetch;
    for (let t3 = 0; t3 < s3.length; t3 += 1) {
      let n4 = he2(e3, s3, t3), a3 = i3(n4);
      r3.set(a3, o3[t3] = me2(a3, n4));
    }
    return {c() {
      n3 = N2("div");
      for (let t3 = 0; t3 < o3.length; t3 += 1)
        o3[t3].c();
      D2(n3, "id", "__routify_iframes"), W2(n3, "display", "none");
    }, m(t3, e4) {
      I2(t3, n3, e4);
      for (let t4 = 0; t4 < o3.length; t4 += 1)
        o3[t4].m(n3, null);
    }, p(t3, [e4]) {
      1 & e4 && (s3 = t3[0], o3 = Ft(o3, e4, i3, 1, t3, s3, r3, n3, Tt, me2, null, he2));
    }, i: t2, o: t2, d(t3) {
      t3 && S2(n3);
      for (let t4 = 0; t4 < o3.length; t4 += 1)
        o3[t4].d();
    }};
  }
  var $e2 = se2([]);
  var ye2 = ie2($e2, (t3) => t3.slice(0, 2));
  function be2(t3) {
    const e3 = t3.data ? t3.data.prefetchId : t3;
    if (!e3)
      return null;
    const n3 = f2($e2).find((t4) => t4 && t4.options.prefetch == e3);
    if (n3) {
      const {gracePeriod: t4} = n3.options, o3 = new Promise((e4) => setTimeout(e4, t4)), r3 = new Promise((e4) => {
        window.requestIdleCallback ? window.requestIdleCallback(e4) : setTimeout(e4, t4 + 1e3);
      });
      Promise.all([o3, r3]).then(() => {
        $e2.update((t5) => t5.filter((t6) => t6.options.prefetch != e3));
      });
    }
  }
  function _e2(t3, e3, n3) {
    let o3;
    return p2(t3, ye2, (t4) => n3(0, o3 = t4)), [o3];
  }
  ye2.subscribe((t3) => t3.forEach(({options: t4}) => {
    setTimeout(() => be2(t4.prefetch), t4.timeout);
  })), addEventListener("message", be2, false);
  var we2 = class extends Kt {
    constructor(t3) {
      super(), Ht(this, t3, _e2, ge2, a2, {});
    }
  };
  function xe2() {
    return ct("routify") || le2;
  }
  var ve2 = {_hooks: [(t3) => fe2.set(false)], subscribe: ke2};
  var Pe2 = {_hooks: [], subscribe: ke2};
  function ke2(t3) {
    const e3 = this._hooks, n3 = e3.length;
    return t3((t4) => {
      e3[n3] = t4;
    }), (...o3) => {
      delete e3[n3], t3(...o3);
    };
  }
  var Ee2 = {subscribe: (t3) => ie2(xe2(), (t4) => {
    return e3 = t4, n3 = t4.route, o3 = t4.routes, function(t5, r3 = {}, s3) {
      const {component: i3} = e3, a3 = Object.assign({}, n3.params, i3.params);
      let c3 = t5 && t5.nodeType && t5;
      c3 && (t5 = t5.getAttribute("href")), t5 = t5 ? f3(t5) : i3.shortPath;
      const l3 = o3.find((e4) => [e4.shortPath || "/", e4.path].includes(t5));
      if (l3 && l3.meta.preload === "proximity" && window.requestIdleCallback) {
        const t6 = routify.appLoaded ? 0 : 1500;
        setTimeout(() => {
          window.requestIdleCallback(() => l3.api.preload());
        }, t6);
      }
      s3 && s3.strict !== false || (t5 = t5.replace(/index$/, ""));
      let u3 = Yt(t5, r3, a3);
      return c3 ? (c3.href = u3, {update(e4) {
        c3.href = Yt(t5, e4, a3);
      }}) : u3;
      function f3(t6) {
        if (t6.match(/^\.\.?\//)) {
          let [, e4, n4] = t6.match(/^([\.\/]+)(.*)/), o4 = i3.path.replace(/\/$/, "");
          const r4 = e4.match(/\.\.\//g) || [];
          i3.isPage && r4.push(null), r4.forEach(() => o4 = o4.replace(/\/[^\/]+\/?$/, "")), t6 = (t6 = `${o4}/${n4}`.replace(/\/$/, "")) || "/";
        } else if (t6.match(/^\//))
          ;
        else {
          const e4 = o3.find((e5) => e5.meta.name === t6);
          e4 && (t6 = e4.shortPath);
        }
        return t6;
      }
    };
    var e3, n3, o3;
  }).subscribe(t3)};
  var je2 = {subscribe(t3) {
    const e3 = ct("routifyupdatepage");
    return ie2(Ee2, (t4) => function(n3, o3, r3, s3) {
      const i3 = t4(n3, o3);
      r3 ? e3(i3, s3) : history.replaceState({}, null, i3);
    }).subscribe(t3);
  }};
  var Oe2 = {subscribe(t3) {
    return this._origin = this.getOrigin(), t3(Ie2);
  }, props: {}, templates: {}, services: {plain: {propField: "name", valueField: "content"}, twitter: {propField: "name", valueField: "content"}, og: {propField: "property", valueField: "content"}}, plugins: [{name: "applyTemplate", condition: () => true, action: (t3, e3) => [t3, (Oe2.getLongest(Oe2.templates, t3) || ((t4) => t4))(e3)]}, {name: "createMeta", condition: () => true, action(t3, e3) {
    Oe2.writeMeta(t3, e3);
  }}, {name: "createOG", condition: (t3) => !t3.match(":"), action(t3, e3) {
    Oe2.writeMeta(`og:${t3}`, e3);
  }}, {name: "createTitle", condition: (t3) => t3 === "title", action(t3, e3) {
    document.title = e3;
  }}], getLongest(t3, e3) {
    const n3 = t3[e3];
    if (n3) {
      const o3 = f2(ae2).path;
      return n3[Object.keys(t3[e3]).filter((t4) => o3.includes(t4)).sort((t4, e4) => e4.length - t4.length)[0]];
    }
  }, writeMeta(t3, e3) {
    const n3 = document.getElementsByTagName("head")[0], o3 = t3.match(/(.+)\:/), r3 = o3 && o3[1] || "plain", {propField: s3, valueField: i3} = Ie2.services[r3] || Ie2.services.plain, a3 = document.querySelector(`meta[${s3}='${t3}']`);
    a3 && a3.remove();
    const c3 = document.createElement("meta");
    c3.setAttribute(s3, t3), c3.setAttribute(i3, e3), c3.setAttribute("data-origin", "routify"), n3.appendChild(c3);
  }, set(t3, e3) {
    typeof t3 == "string" && Oe2.plugins.forEach((n3) => {
      n3.condition(t3, e3) && ([t3, e3] = n3.action(t3, e3) || [t3, e3]);
    });
  }, clear() {
    const t3 = document.querySelector("meta");
    t3 && t3.remove();
  }, template(t3, e3) {
    const n3 = Oe2.getOrigin;
    Oe2.templates[t3] = Oe2.templates[t3] || {}, Oe2.templates[t3][n3] = e3;
  }, update() {
    Object.keys(Oe2.props).forEach((t3) => {
      let e3 = Oe2.getLongest(Oe2.props, t3);
      Oe2.plugins.forEach((n3) => {
        n3.condition(t3, e3) && ([t3, e3] = n3.action(t3, e3) || [t3, e3]);
      });
    });
  }, batchedUpdate() {
    Oe2._pendingUpdate || (Oe2._pendingUpdate = true, setTimeout(() => {
      Oe2._pendingUpdate = false, this.update();
    }));
  }, _updateQueued: false, _origin: false, getOrigin() {
    if (this._origin)
      return this._origin;
    const t3 = xe2();
    return t3 && f2(t3).path || "/";
  }, _pendingUpdate: false};
  var Ie2 = new Proxy(Oe2, {set(t3, e3, n3, o3) {
    const {props: r3} = t3;
    return Reflect.has(t3, e3) ? Reflect.set(t3, e3, n3, o3) : (r3[e3] = r3[e3] || {}, r3[e3][t3.getOrigin()] = n3), window.routify.appLoaded && t3.batchedUpdate(), true;
  }});
  function Se2(t3, e3, n3) {
    const o3 = t3.slice();
    return o3[21] = e3[n3].component, o3[22] = e3[n3].componentFile, o3[2] = e3[n3].decorator, o3[1] = e3[n3].nodes, o3;
  }
  function Le2(t3) {
    let e3, n3, o3 = [], r3 = new Map(), s3 = [t3[4]];
    const i3 = (t4) => t4[7];
    for (let e4 = 0; e4 < 1; e4 += 1) {
      let n4 = Se2(t3, s3, e4), a3 = i3(n4);
      r3.set(a3, o3[e4] = Ae2(a3, n4));
    }
    return {c() {
      for (let t4 = 0; t4 < 1; t4 += 1)
        o3[t4].c();
      e3 = F2();
    }, m(t4, r4) {
      for (let e4 = 0; e4 < 1; e4 += 1)
        o3[e4].m(t4, r4);
      I2(t4, e3, r4), n3 = true;
    }, p(t4, n4) {
      33554621 & n4 && (s3 = [t4[4]], Ot(), o3 = Ft(o3, n4, i3, 1, t4, s3, r3, e3.parentNode, At2, Ae2, e3, Se2), It2());
    }, i(t4) {
      if (!n3) {
        for (let t5 = 0; t5 < 1; t5 += 1)
          St(o3[t5]);
        n3 = true;
      }
    }, o(t4) {
      for (let t5 = 0; t5 < 1; t5 += 1)
        Lt(o3[t5]);
      n3 = false;
    }, d(t4) {
      for (let e4 = 0; e4 < 1; e4 += 1)
        o3[e4].d(t4);
      t4 && S2(e3);
    }};
  }
  function Ne2(t3) {
    let e3, n3;
    return e3 = new qe2({props: {decorator: t3[2], nodes: t3[1], scoped: {...t3[0], ...t3[25]}}}), {c() {
      Bt2(e3.$$.fragment);
    }, m(t4, o3) {
      Dt(e3, t4, o3), n3 = true;
    }, p(t4, n4) {
      const o3 = {};
      4 & n4 && (o3.decorator = t4[2]), 16 & n4 && (o3.nodes = t4[1]), 33554433 & n4 && (o3.scoped = {...t4[0], ...t4[25]}), e3.$set(o3);
    }, i(t4) {
      n3 || (St(e3.$$.fragment, t4), n3 = true);
    }, o(t4) {
      Lt(e3.$$.fragment, t4), n3 = false;
    }, d(t4) {
      Ut(e3, t4);
    }};
  }
  function Re2(t3) {
    let e3, n3, o3 = t3[21] && t3[1].length && Ne2(t3);
    return {c() {
      o3 && o3.c(), e3 = F2();
    }, m(t4, r3) {
      o3 && o3.m(t4, r3), I2(t4, e3, r3), n3 = true;
    }, p(t4, n4) {
      t4[21] && t4[1].length ? o3 ? (o3.p(t4, n4), 16 & n4 && St(o3, 1)) : (o3 = Ne2(t4), o3.c(), St(o3, 1), o3.m(e3.parentNode, e3)) : o3 && (Ot(), Lt(o3, 1, 1, () => {
        o3 = null;
      }), It2());
    }, i(t4) {
      n3 || (St(o3), n3 = true);
    }, o(t4) {
      Lt(o3), n3 = false;
    }, d(t4) {
      o3 && o3.d(t4), t4 && S2(e3);
    }};
  }
  function Te2(t3) {
    let e3, o3, r3;
    const s3 = [{scoped: t3[0]}, {scopedSync: t3[5]}, t3[3].param || {}];
    var i3 = t3[22];
    function a3(t4) {
      let e4 = {$$slots: {default: [Re2, ({scoped: t5, decorator: e5}) => ({25: t5, 2: e5}), ({scoped: t5, decorator: e5}) => (t5 ? 33554432 : 0) | (e5 ? 4 : 0)]}, $$scope: {ctx: t4}};
      for (let t5 = 0; t5 < s3.length; t5 += 1)
        e4 = n2(e4, s3[t5]);
      return {props: e4};
    }
    return i3 && (e3 = new i3(a3(t3))), {c() {
      e3 && Bt2(e3.$$.fragment), o3 = A2();
    }, m(t4, n3) {
      e3 && Dt(e3, t4, n3), I2(t4, o3, n3), r3 = true;
    }, p(t4, n3) {
      const r4 = 41 & n3 ? Ct2(s3, [1 & n3 && {scoped: t4[0]}, 32 & n3 && {scopedSync: t4[5]}, 8 & n3 && Mt(t4[3].param || {})]) : {};
      if (100663317 & n3 && (r4.$$scope = {dirty: n3, ctx: t4}), i3 !== (i3 = t4[22])) {
        if (e3) {
          Ot();
          const t5 = e3;
          Lt(t5.$$.fragment, 1, 0, () => {
            Ut(t5, 1);
          }), It2();
        }
        i3 ? (e3 = new i3(a3(t4)), Bt2(e3.$$.fragment), St(e3.$$.fragment, 1), Dt(e3, o3.parentNode, o3)) : e3 = null;
      } else
        i3 && e3.$set(r4);
    }, i(t4) {
      r3 || (e3 && St(e3.$$.fragment, t4), r3 = true);
    }, o(t4) {
      e3 && Lt(e3.$$.fragment, t4), r3 = false;
    }, d(t4) {
      e3 && Ut(e3, t4), t4 && S2(o3);
    }};
  }
  function Ae2(t3, e3) {
    let n3, o3, r3, s3;
    var i3 = e3[2];
    function a3(t4) {
      return {props: {scoped: t4[0], $$slots: {default: [Te2]}, $$scope: {ctx: t4}}};
    }
    return i3 && (o3 = new i3(a3(e3))), {key: t3, first: null, c() {
      n3 = F2(), o3 && Bt2(o3.$$.fragment), r3 = F2(), this.first = n3;
    }, m(t4, e4) {
      I2(t4, n3, e4), o3 && Dt(o3, t4, e4), I2(t4, r3, e4), s3 = true;
    }, p(t4, n4) {
      e3 = t4;
      const s4 = {};
      if (1 & n4 && (s4.scoped = e3[0]), 67108925 & n4 && (s4.$$scope = {dirty: n4, ctx: e3}), i3 !== (i3 = e3[2])) {
        if (o3) {
          Ot();
          const t5 = o3;
          Lt(t5.$$.fragment, 1, 0, () => {
            Ut(t5, 1);
          }), It2();
        }
        i3 ? (o3 = new i3(a3(e3)), Bt2(o3.$$.fragment), St(o3.$$.fragment, 1), Dt(o3, r3.parentNode, r3)) : o3 = null;
      } else
        i3 && o3.$set(s4);
    }, i(t4) {
      s3 || (o3 && St(o3.$$.fragment, t4), s3 = true);
    }, o(t4) {
      o3 && Lt(o3.$$.fragment, t4), s3 = false;
    }, d(t4) {
      t4 && S2(n3), t4 && S2(r3), o3 && Ut(o3, t4);
    }};
  }
  function Fe2(e3) {
    let n3, o3, r3, s3;
    return {c() {
      n3 = N2("div"), W2(n3, "display", "contents");
    }, m(a3, c3) {
      var l3;
      I2(a3, n3, c3), r3 || (l3 = o3 = e3[10].call(null, n3), s3 = l3 && i2(l3.destroy) ? l3.destroy : t2, r3 = true);
    }, d(t3) {
      t3 && S2(n3), r3 = false, s3();
    }};
  }
  function Ce2(t3) {
    let e3, n3, o3, r3 = t3[4] && Le2(t3), s3 = !t3[6] && Fe2(t3);
    return {c() {
      r3 && r3.c(), e3 = A2(), s3 && s3.c(), n3 = F2();
    }, m(t4, i3) {
      r3 && r3.m(t4, i3), I2(t4, e3, i3), s3 && s3.m(t4, i3), I2(t4, n3, i3), o3 = true;
    }, p(t4, [o4]) {
      t4[4] ? r3 ? (r3.p(t4, o4), 16 & o4 && St(r3, 1)) : (r3 = Le2(t4), r3.c(), St(r3, 1), r3.m(e3.parentNode, e3)) : r3 && (Ot(), Lt(r3, 1, 1, () => {
        r3 = null;
      }), It2()), t4[6] ? s3 && (s3.d(1), s3 = null) : s3 || (s3 = Fe2(t4), s3.c(), s3.m(n3.parentNode, n3));
    }, i(t4) {
      o3 || (St(r3), o3 = true);
    }, o(t4) {
      Lt(r3), o3 = false;
    }, d(t4) {
      r3 && r3.d(t4), t4 && S2(e3), s3 && s3.d(t4), t4 && S2(n3);
    }};
  }
  function Me2(t3, e3, n3) {
    let o3, r3, s3, i3, a3;
    p2(t3, ae2, (t4) => n3(14, s3 = t4)), p2(t3, ce2, (t4) => n3(16, a3 = t4));
    let c3, {nodes: l3 = []} = e3, {scoped: u3 = {}} = e3, {decorator: f3} = e3, d3 = null, h3 = null, m3 = {}, g3 = 1;
    const $3 = se2(null);
    p2(t3, $3, (t4) => n3(4, r3 = t4));
    const y3 = ct("routify") || le2;
    p2(t3, y3, (t4) => n3(15, i3 = t4));
    at("routify", $3);
    let b3 = [];
    function w3(t4) {
      n3(5, m3 = {...u3});
      const e4 = {...r3, nodes: h3, decorator: f3 || ne2, layout: d3.isLayout ? d3 : i3.layout, component: d3, route: s3, routes: a3, componentFile: t4, parentNode: c3 || i3.parentNode};
      $3.set(e4), _2(y3, i3.child = d3, i3), h3.length === 0 && async function() {
        await new Promise((t6) => setTimeout(t6));
        const t5 = r3.component.path === s3.path;
        !window.routify.stopAutoReady && t5 && async function({page: t6, metatags: e5, afterPageLoad: n4, parentNode: o4}) {
          const r4 = t6.last !== t6;
          setTimeout(() => Jt(o4, r4));
          const {path: s4} = t6, {options: i4} = Zt(), a4 = i4.prefetch;
          for (const e6 of n4._hooks)
            e6 && await e6(t6.api);
          e5.update(), dispatchEvent(new CustomEvent("app-loaded")), parent.postMessage({msg: "app-loaded", prefetched: window.routify.prefetched, path: s4, prefetchId: a4}, "*"), window.routify.appLoaded = true, window.routify.stopAutoReady = false;
        }({page: r3.component, metatags: Ie2, afterPageLoad: ve2, parentNode: c3});
      }();
    }
    return t3.$$set = (t4) => {
      "nodes" in t4 && n3(1, l3 = t4.nodes), "scoped" in t4 && n3(0, u3 = t4.scoped), "decorator" in t4 && n3(2, f3 = t4.decorator);
    }, t3.$$.update = () => {
      6146 & t3.$$.dirty && b3 !== l3 && (n3(12, b3 = l3), n3(3, [d3, ...h3] = [...l3], d3), n3(3, d3.api.reset = () => n3(11, g3++, g3), d3)), 8 & t3.$$.dirty && function(t4) {
        let e4 = t4.component();
        e4 instanceof Promise ? e4.then(w3) : w3(e4);
      }(d3), 2064 & t3.$$.dirty && n3(7, o3 = r3 && g3 && function({meta: t4, path: e4, param: n4, params: o4}) {
        return JSON.stringify({path: e4, invalidate: g3, param: (t4["param-is-page"] || t4["slug-is-page"]) && n4, queryParams: t4["query-params-is-page"] && o4});
      }(r3.component)), 16 & t3.$$.dirty && r3 && Vt(r3, $t);
    }, [u3, l3, f3, d3, r3, m3, c3, o3, $3, y3, (t4) => n3(6, c3 = t4.parentNode), g3, b3];
  }
  var qe2 = class extends Kt {
    constructor(t3) {
      super(), Ht(this, t3, Me2, Ce2, a2, {nodes: 1, scoped: 0, decorator: 2});
    }
  };
  function Be2(t3, e3) {
    let n3 = false;
    function o3(o4, r4) {
      const s3 = pe2(o4 || Zt().fullpath);
      s3.redirectTo && (history.replaceStateNative({}, null, s3.redirectTo), delete s3.redirectTo);
      const i3 = [...(r4 && pe2(Zt().fullpath, t3) || s3).layouts, s3];
      n3 && delete n3.last, s3.last = n3, n3 = s3, o4 || ue2.set(s3), ae2.set(s3), s3.api.preload().then(() => {
        fe2.set(true), e3(i3);
      });
    }
    const r3 = function(t4) {
      ["pushState", "replaceState"].forEach((t5) => {
        history[t5 + "Native"] || (history[t5 + "Native"] = history[t5]), history[t5] = async function(e5 = {}, n5, o4) {
          if (o4 === location.pathname + location.search + location.hash)
            return false;
          const {id: r4, path: s3, params: i3} = f2(ae2);
          e5 = {id: r4, path: s3, params: i3, ...e5};
          const a3 = new Event(t5.toLowerCase());
          Object.assign(a3, {state: e5, title: n5, url: o4});
          return await Ue2(a3, o4) ? (history[t5 + "Native"].apply(this, [e5, n5, o4]), dispatchEvent(a3)) : void 0;
        };
      });
      let e4 = false;
      const n4 = {click: De2, pushstate: () => t4(), replacestate: () => t4(), popstate: async (n5) => {
        e4 ? e4 = false : await Ue2(n5, Zt().fullpath) ? t4() : (e4 = true, n5.preventDefault(), history.go(1));
      }};
      Object.entries(n4).forEach((t5) => addEventListener(...t5));
      return () => {
        Object.entries(n4).forEach((t5) => removeEventListener(...t5));
      };
    }(o3);
    return {updatePage: o3, destroy: r3};
  }
  function De2(t3) {
    const e3 = t3.target.closest("a"), n3 = e3 && e3.href;
    if (t3.ctrlKey || t3.metaKey || t3.altKey || t3.shiftKey || t3.button || t3.defaultPrevented)
      return;
    if (!n3 || e3.target || e3.host !== location.host)
      return;
    const o3 = new URL(n3), r3 = o3.pathname + o3.search + o3.hash;
    t3.preventDefault(), history.pushState({}, "", r3);
  }
  async function Ue2(t3, e3) {
    const n3 = pe2(e3).api;
    for (const o3 of Pe2._hooks.filter(Boolean)) {
      if (!await o3(t3, n3, {url: e3}))
        return false;
    }
    return true;
  }
  function He2(t3) {
    let e3, n3;
    return e3 = new qe2({props: {nodes: t3[0]}}), {c() {
      Bt2(e3.$$.fragment);
    }, m(t4, o3) {
      Dt(e3, t4, o3), n3 = true;
    }, p(t4, n4) {
      const o3 = {};
      1 & n4 && (o3.nodes = t4[0]), e3.$set(o3);
    }, i(t4) {
      n3 || (St(e3.$$.fragment, t4), n3 = true);
    }, o(t4) {
      Lt(e3.$$.fragment, t4), n3 = false;
    }, d(t4) {
      Ut(e3, t4);
    }};
  }
  function Ke2(t3) {
    let e3, n3, o3, r3 = t3[0] && t3[1] !== null && He2(t3);
    return n3 = new we2({}), {c() {
      r3 && r3.c(), e3 = A2(), Bt2(n3.$$.fragment);
    }, m(t4, s3) {
      r3 && r3.m(t4, s3), I2(t4, e3, s3), Dt(n3, t4, s3), o3 = true;
    }, p(t4, [n4]) {
      t4[0] && t4[1] !== null ? r3 ? (r3.p(t4, n4), 3 & n4 && St(r3, 1)) : (r3 = He2(t4), r3.c(), St(r3, 1), r3.m(e3.parentNode, e3)) : r3 && (Ot(), Lt(r3, 1, 1, () => {
        r3 = null;
      }), It2());
    }, i(t4) {
      o3 || (St(r3), St(n3.$$.fragment, t4), o3 = true);
    }, o(t4) {
      Lt(r3), Lt(n3.$$.fragment, t4), o3 = false;
    }, d(t4) {
      r3 && r3.d(t4), t4 && S2(e3), Ut(n3, t4);
    }};
  }
  function ze2(t3, e3, n3) {
    let o3;
    p2(t3, ae2, (t4) => n3(1, o3 = t4));
    let r3, s3, {routes: i3} = e3, {config: a3 = {}} = e3;
    window.routify = window.routify || {}, window.routify.inBrowser = !window.navigator.userAgent.match("jsdom"), Object.assign(zt, a3);
    at("routifyupdatepage", (...t4) => s3 && s3.updatePage(...t4));
    const c3 = (t4) => n3(0, r3 = t4), l3 = () => {
      s3 && (s3.destroy(), s3 = null);
    };
    let u3 = null;
    return st(l3), t3.$$set = (t4) => {
      "routes" in t4 && n3(2, i3 = t4.routes), "config" in t4 && n3(3, a3 = t4.config);
    }, t3.$$.update = () => {
      4 & t3.$$.dirty && i3 && (clearTimeout(u3), u3 = setTimeout(() => {
        l3(), s3 = Be2(i3, c3), ce2.set(i3), s3.updatePage();
      }));
    }, [r3, o3, i3, a3];
  }
  var We2 = class extends Kt {
    constructor(t3) {
      super(), Ht(this, t3, ze2, Ke2, a2, {routes: 2, config: 3});
    }
  };
  function Je2(t3) {
    const e3 = async function(e4) {
      return await Ge2(t3, {file: e4.tree, state: {treePayload: e4}, scope: {}});
    };
    return e3.sync = function(e4) {
      return Qe2(t3, {file: e4.tree, state: {treePayload: e4}, scope: {}});
    }, e3;
  }
  async function Ge2(t3, e3) {
    const n3 = await t3(e3);
    if (n3 === false)
      return false;
    const o3 = n3 || e3.file;
    if (o3.children) {
      const n4 = await Promise.all(o3.children.map(async (n5) => Ge2(t3, {state: e3.state, scope: Ve2(e3.scope || {}), parent: e3.file, file: await n5})));
      o3.children = n4.filter(Boolean);
    }
    return o3;
  }
  function Qe2(t3, e3) {
    const n3 = t3(e3);
    if (n3 === false)
      return false;
    const o3 = n3 || e3.file;
    if (o3.children) {
      const n4 = o3.children.map((n5) => Qe2(t3, {state: e3.state, scope: Ve2(e3.scope || {}), parent: e3.file, file: n5}));
      o3.children = n4.filter(Boolean);
    }
    return o3;
  }
  function Ve2(t3) {
    return JSON.parse(JSON.stringify(t3));
  }
  var Ze2 = Je2(({file: t3}) => {
    (t3.isPage || t3.isFallback) && (t3.regex = ((t4, e3) => {
      const n3 = e3 ? "" : "/?$";
      return `^${t4 = (t4 = (t4 = t4.replace(/\/_fallback?$/, "(/|$)")).replace(/\/index$/, "(/index)?")).replace(Wt, "([^/]+)") + n3}`;
    })(t3.path, t3.isFallback));
  });
  var Xe2 = Je2(({file: t3}) => {
    t3.paramKeys = Qt(t3.path);
  });
  var Ye2 = Je2(({file: t3}) => {
    t3.isFallback || t3.isIndex ? t3.shortPath = t3.path.replace(/\/[^/]+$/, "") : t3.shortPath = t3.path;
  });
  var tn = Je2(({file: t3}) => {
    t3.ranking = (({path: t4}) => t4.split("/").filter(Boolean).map((t5) => t5 === "_fallback" ? "A" : t5.startsWith(":") ? "B" : "C").join(""))(t3);
  });
  var en = Je2(({file: t3}) => {
    const e3 = t3, n3 = t3.meta && t3.meta.children || [];
    n3.length && (e3.children = e3.children || [], e3.children.push(...n3.map((t4) => ({isMeta: true, ...t4, meta: t4}))));
  });
  var nn = Je2((t3) => {
    const {file: e3} = t3, {isFallback: n3, meta: o3} = e3, r3 = e3.path.split("/").pop().startsWith(":"), s3 = e3.path.endsWith("/index"), i3 = o3.index || o3.index === 0, a3 = o3.index === false;
    e3.isIndexable = i3 || !n3 && !r3 && !s3 && !a3, e3.isNonIndexable = !e3.isIndexable;
  });
  var on = Je2(({file: t3, parent: e3}) => {
    Object.defineProperty(t3, "parent", {get: () => e3}), Object.defineProperty(t3, "nextSibling", {get: () => sn(t3, 1)}), Object.defineProperty(t3, "prevSibling", {get: () => sn(t3, -1)}), Object.defineProperty(t3, "lineage", {get: () => rn(e3)});
  });
  function rn(t3, e3 = []) {
    return t3 && (e3.unshift(t3), rn(t3.parent, e3)), e3;
  }
  function sn(t3, e3) {
    if (!t3.root) {
      const n3 = t3.parent.children.filter((t4) => t4.isIndexable), o3 = n3.indexOf(t3);
      return n3[o3 + e3];
    }
  }
  var an = Je2(({file: t3, parent: e3}) => {
    t3.isIndex && Object.defineProperty(e3, "index", {get: () => t3});
  });
  var cn = Je2(({file: t3, scope: e3}) => {
    function n3(t4) {
      if (!t4.isLayout && t4.meta.reset)
        return [];
      const {parent: e4} = t4, o3 = e4 && e4.component && e4, r3 = o3 && (o3.isReset || o3.meta.reset), s3 = e4 && !r3 && n3(e4) || [];
      return o3 && s3.push(o3), s3;
    }
    Object.defineProperty(t3, "layouts", {get: () => n3(t3)});
  });
  var ln = Je2(({file: t3}) => {
    const e3 = t3.root ? function() {
    } : t3.children ? (t3.isPage, function() {
    }) : (t3.isReset || t3.isLayout || t3.isFallback, function() {
    });
    Object.setPrototypeOf(t3, e3.prototype);
  });
  var un = Object.freeze({__proto__: null, setRegex: Ze2, setParamKeys: Xe2, setShortPath: Ye2, setRank: tn, addMetaChildren: en, setIsIndexable: nn, assignRelations: on, assignIndex: an, assignLayout: cn, createFlatList: (t3) => {
    Je2((t4) => {
      (t4.file.isPage || t4.file.isFallback) && t4.state.treePayload.routes.push(t4.file);
    }).sync(t3), t3.routes.sort((t4, e3) => t4.ranking >= e3.ranking ? -1 : 1);
  }, setPrototype: ln});
  var fn = {isDir: false, ext: "svelte", isLayout: false, isReset: false, isIndex: false, isFallback: false, isPage: false, ownMeta: {}, meta: {recursive: true, preload: false, prerender: true}, id: "__fallback"};
  function pn(t3) {
    return Object.entries(fn).forEach(([e3, n3]) => {
      t3[e3] === void 0 && (t3[e3] = n3);
    }), t3.children && (t3.children = t3.children.map(pn)), t3;
  }
  var dn = Je2(({file: t3}) => {
    t3.api = new hn(t3);
  });
  var hn = class {
    constructor(t3) {
      this.__file = t3, Object.defineProperty(this, "__file", {enumerable: false}), this.isMeta = !!t3.isMeta, this.path = t3.path, this.title = function(t4) {
        return t4.meta.title !== void 0 ? t4.meta.title : (t4.shortPath || t4.path).split("/").pop().replace(/-/g, " ");
      }(t3), this.meta = t3.meta;
    }
    get parent() {
      return !this.__file.root && this.__file.parent.api;
    }
    get children() {
      return (this.__file.children || this.__file.isLayout && this.__file.parent.children || []).filter((t3) => !t3.isNonIndexable).sort((t3, e3) => t3.isMeta && e3.isMeta ? 0 : (t3 = (t3.meta.index || t3.meta.title || t3.path).toString(), e3 = (e3.meta.index || e3.meta.title || e3.path).toString(), t3.localeCompare(e3, void 0, {numeric: true, sensitivity: "base"}))).map(({api: t3}) => t3);
    }
    get next() {
      return mn(this, 1);
    }
    get prev() {
      return mn(this, -1);
    }
    async preload() {
      const t3 = [...this.__file.layouts, this.__file, this.index && this.index.__file].filter(Boolean).map((t4) => t4.component());
      await Promise.all(t3);
    }
    get component() {
      return this.__file.component ? this.__file.component() : !!this.__file.index && this.__file.index.component();
    }
    get componentWithIndex() {
      return new Promise((t3) => Promise.all([this.component, this.index && this.index.component]).then((e3) => t3(e3)));
    }
    get index() {
      const t3 = this.__file.children && this.__file.children.find((t4) => t4.isIndex);
      return t3 && t3.api;
    }
  };
  function mn(t3, e3) {
    if (!t3.__file.root) {
      const n3 = t3.parent.children.indexOf(t3);
      return t3.parent.children[n3 + e3];
    }
  }
  var gn = {...un, restoreDefaults: ({tree: t3}) => pn(t3), assignAPI: dn};

  // dist/build/sha256-806d8515.js
  var A = () => {
    const A3 = window.navigator.userAgent;
    let g3 = null;
    return /macintosh/i.test(A3) ? g3 = "macOS" : /ios/i.test(A3) ? g3 = "iOS" : /win/i.test(A3) ? g3 = "Windows" : /android/i.test(A3) ? g3 = "Android" : /linux/i.test(A3) && (g3 = "Linux"), g3;
  };
  var g = function() {
    if (!globalThis.navigator)
      return {OS: "Node", isMobileDevice: false, isIOSDevice: false, browserName: "Node", webGLSupported: false, deviceCategory: "High", hardwareConcurrency: 4};
    const g3 = (navigator.userAgent.match(/Android/i) || navigator.userAgent.match(/webOS/i) || navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i) || navigator.userAgent.match(/BlackBerry/i) || navigator.userAgent.match(/Pixel/i) || navigator.userAgent.match(/Windows Phone/i)) != null, I3 = function() {
      const A3 = navigator.userAgent;
      let g4, I4, C4, i4 = navigator.appName, e4 = "" + parseFloat(navigator.appVersion), t3 = parseInt(navigator.appVersion, 10);
      return navigator.brave ? (i4 = "Brave", I4 = A3.indexOf("Chrome"), e4 = A3.substring(I4 + 7, A3.indexOf(" ", I4 + 7))) : (I4 = A3.indexOf("Opera")) != -1 ? (i4 = "Opera", e4 = A3.substring(I4 + 6), (I4 = A3.indexOf("Version")) != -1 && (e4 = A3.substring(I4 + 8))) : (I4 = A3.indexOf("MSIE")) != -1 ? (i4 = "Microsoft Internet Explorer", e4 = A3.substring(I4 + 5)) : (I4 = A3.indexOf("Edge")) != -1 ? (i4 = "Edge", e4 = A3.substring(I4 + 4)) : (I4 = A3.indexOf("Chrome")) != -1 ? (i4 = "Chrome", e4 = A3.substring(I4 + 7, A3.indexOf(" ", I4 + 7))) : (I4 = A3.indexOf("Safari")) != -1 ? (i4 = "Safari", e4 = A3.substring(I4 + 7), (I4 = A3.indexOf("Version")) != -1 && (e4 = A3.substring(I4 + 8))) : (I4 = A3.indexOf("Firefox")) != -1 ? (i4 = "Firefox", e4 = A3.substring(I4 + 8)) : (g4 = A3.lastIndexOf(" ") + 1) < (I4 = A3.lastIndexOf("/")) && (i4 = A3.substring(g4, I4), e4 = A3.substring(I4 + 1), i4.toLowerCase() == i4.toUpperCase() && (i4 = navigator.appName)), (C4 = e4.indexOf(";")) != -1 && (e4 = e4.substring(0, C4)), (C4 = e4.indexOf(" ")) != -1 && (e4 = e4.substring(0, C4)), t3 = parseInt("" + e4, 10), isNaN(t3) && (e4 = "" + parseFloat(navigator.appVersion), t3 = parseInt(navigator.appVersion, 10)), {browserName: i4, fullVersion: e4, majorVersion: t3, appName: navigator.appName, userAgent: navigator.userAgent};
    }(), C3 = function() {
      let A3, g4;
      try {
        A3 = document.createElement("canvas").getContext("webgl");
      } catch (A4) {
      }
      if (!A3)
        return {vendor: "Unknown", renderer: "Unknown", gpuVendor: "Unknown", maxTextureSize: 0, supportsWebGL: false, supportsWebGL2: false};
      try {
        g4 = document.createElement("canvas").getContext("webgl2");
      } catch (A4) {
      }
      const I4 = A3.getExtension("WEBGL_debug_renderer_info");
      if (!I4)
        return console.warn("Unable to determine GPU Info:"), {vendor: "Unknown", renderer: "Unknown", gpuVendor: "Unknown", maxTextureSize: 0, supportsWebGL: A3 != null, supportsWebGL2: g4 != null};
      const C4 = A3.getParameter(I4.UNMASKED_VENDOR_WEBGL), i4 = A3.getParameter(I4.UNMASKED_RENDERER_WEBGL), e4 = A3.getParameter(A3.MAX_TEXTURE_SIZE);
      let t3;
      return i4.match(/NVIDIA/i) ? t3 = "NVidia" : i4.match(/AMD/i) || i4.match(/Radeon/i) ? t3 = "AMD" : i4.match(/Intel/i) ? t3 = "Intel" : i4.match(/Mali/i) ? t3 = "ARM" : i4.match(/Apple/i) ? t3 = "Apple" : i4.match(/Adreno/i) ? t3 = "Adreno" : i4.match(/Swiftshader/i) ? (t3 = "Google", console.warn("Hardware rendering is disabled or not working on your system. Falling back to the Swiftshader. Expect poor performance:", i4)) : console.warn("Unable to determine GPU vendor:", i4), {vendor: C4, renderer: i4, gpuVendor: t3, maxTextureSize: e4, supportsWebGL: true, supportsWebGL2: g4 != null};
    }();
    let i3 = "Low";
    if (C3.supportsWebGL)
      if (g3)
        i3 = "Low";
      else {
        const A3 = C3.renderer.replace(/[()]/g, "").split(" ");
        if (C3.gpuVendor == "NVidia") {
          const g4 = A3.indexOf("GTX");
          if (g4 != -1) {
            const I4 = A3[g4 + 1];
            if (I4.endsWith("M")) {
              i3 = parseInt(I4.substring(0, I4.length - 2)) >= 900 ? "Medium" : "Low";
            } else {
              i3 = parseInt(I4) >= 1030 ? "High" : "Medium";
            }
          } else
            i3 = A3.includes("RTX") || A3.includes("TITAN") || A3.includes("Quadro") ? "High" : "Low";
        } else if (C3.gpuVendor == "AMD") {
          const g4 = A3.indexOf("Radeon");
          if (g4 != -1) {
            const I4 = A3.indexOf("RX");
            if (I4 != -1)
              if (A3[I4 + 1] == "Vega")
                i3 = "High";
              else {
                const g5 = A3[I4 + 1];
                let C4;
                g5.endsWith("X") ? (C4 = parseInt(g5.substring(0, g5.length - 2)), i3 = "High") : C4 = parseInt(g5), i3 = C4 >= 480 ? "High" : "Medium";
              }
            else if (A3[g4 + 1] == "Pro") {
              i3 = parseInt(A3[I4 + 1]) >= 450 ? "Medium" : "Low";
            } else if (A3[g4 + 1] == "Sky") {
              i3 = parseInt(A3[I4 + 1]) >= 700 ? "Medium" : "Low";
            } else
              i3 = "Low";
          } else
            i3 = A3.includes("FirePro") || A3.includes("Quadro") ? "High" : "Low";
        } else
          (C3.gpuVendor == "Adreno" || C3.gpuVendor == "Intel" || C3.gpuVendor == "Google") && (i3 = "Low");
      }
    let e3 = globalThis.navigator.hardwareConcurrency;
    return e3 || (e3 = g3 ? 4 : 6), {OS: A(), isMobileDevice: g3, isIOSDevice: (navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i)) != null, browserName: I3.browserName, fullVersion: I3.fullVersion, majorVersion: I3.majorVersion, appName: I3.appName, userAgent: I3.userAgent, webGLSupported: C3.supportsWebGL, gpuDesc: C3, deviceCategory: i3, hardwareConcurrency: e3};
  }();
  globalThis.ZeaSystemDesc || (globalThis.ZeaSystemDesc = g);
  var I = {};
  var C = {};
  var i = [];
  var e = class {
    static register(A3, g3) {
      if (A3 in I)
        return void console.warn(`There's a class registered with '${A3}' name. Second registration failed.`);
      const e3 = i.length;
      i.push(g3), C[e3] = A3, I[A3] = e3;
    }
    static getClassDefinition(A3) {
      if (!(A3 in I))
        throw new Error(`${A3} class is not registered`);
      return i[I[A3]];
    }
    static getClassName(A3) {
      const g3 = i.indexOf(A3);
      if (g3 >= 0 && C[g3])
        return C[g3];
      throw new Error("class is not registered");
    }
    static constructClass(A3) {
      const g3 = i[I[A3]];
      if (!g3)
        throw new Error(`${A3} class is not registered`);
      return new g3();
    }
    static flush() {
      I = {}, C = {}, i = [];
    }
  };
  var t = class {
    static replaceAll(A3, g3, I3) {
      return A3.replace(new RegExp(g3, "g"), I3);
    }
    static stringifyJSONWithFixedPrecision(A3, g3 = 0, I3 = 5) {
      return JSON.stringify(A3, (A4, g4) => g4 && g4.toFixed ? Number(g4.toFixed(I3)) : g4, g3);
    }
    static hashStr(A3) {
      let g3, I3, C3, i3 = 0;
      if (A3.length === 0)
        return i3;
      for (g3 = 0, C3 = A3.length; g3 < C3; g3++)
        I3 = A3.charCodeAt(g3), i3 = (i3 << 5) - i3 + I3, i3 |= 0;
      return Math.abs(i3);
    }
  };
  var B = class {
    constructor(A3 = 0, g3 = 0) {
      A3 instanceof Float32Array || A3 instanceof Uint32Array || A3 instanceof Int32Array ? this.__data = A3 : typeof A3 == "number" && typeof g3 == "number" ? (this.__data = new Float32Array(2), this.__data[0] = A3, this.__data[1] = g3) : typeof A3 == "object" ? (this.__data = new Float32Array(2), this.fromJSON(A3)) : this.__data = new Float32Array(2);
    }
    get x() {
      return this.__data[0];
    }
    set x(A3) {
      this.__data[0] = A3;
    }
    get y() {
      return this.__data[1];
    }
    set y(A3) {
      this.__data[1] = A3;
    }
    set(A3, g3) {
      this.__data[0] = A3, this.__data[1] = g3;
    }
    setFromOther(A3) {
      this.x = A3.x, this.y = A3.y;
    }
    isEqual(A3) {
      return this.x == A3.x && this.y == A3.y;
    }
    notEqual(A3) {
      return this.x != A3.x && this.y != A3.y;
    }
    approxEqual(A3, g3 = Number.EPSILON) {
      return Math.abs(this.x - A3.x) < g3 && Math.abs(this.y - A3.y) < g3;
    }
    add(A3) {
      return new B(this.x + A3.x, this.y + A3.y);
    }
    addInPlace(A3) {
      this.x += A3.x, this.y += A3.y;
    }
    subtract(A3) {
      return new B(this.x - A3.x, this.y - A3.y);
    }
    subtractInPlace(A3) {
      return this.x -= A3.x, this.y -= A3.y, this;
    }
    scale(A3) {
      return new B(this.x * A3, this.y * A3);
    }
    scaleInPlace(A3) {
      this.x *= A3, this.y *= A3;
    }
    invert() {
      return new B(1 / this.x, 1 / this.y);
    }
    invertInPlace() {
      return this.x = 1 / this.x, this.y = 1 / this.y, this;
    }
    multiply(A3) {
      return new B(this.x * A3.x, this.y * A3.y);
    }
    multiplyInPlace(A3) {
      this.x *= A3.x, this.y *= A3.y;
    }
    lengthSquared() {
      const A3 = this.__data[0], g3 = this.__data[1];
      return A3 * A3 + g3 * g3;
    }
    length() {
      return Math.sqrt(this.lengthSquared());
    }
    distanceTo(A3) {
      const g3 = this.__data[0] - A3.x, I3 = this.__data[1] - A3.y;
      return Math.sqrt(g3 * g3 + I3 * I3);
    }
    normalize() {
      const A3 = this.__data[0], g3 = this.__data[1];
      let I3 = A3 * A3 + g3 * g3;
      return I3 < Number.EPSILON ? new B() : (I3 = 1 / Math.sqrt(I3), new B(A3 * I3, g3 * I3));
    }
    normalizeInPlace() {
      const A3 = this.__data[0], g3 = this.__data[1];
      let I3 = A3 * A3 + g3 * g3;
      I3 < Number.EPSILON || (I3 = 1 / Math.sqrt(I3), this.set(A3 * I3, g3 * I3));
    }
    dot(A3) {
      return this.x * A3.x + this.y * A3.y;
    }
    cross(A3) {
      return this.x * A3.y - this.y * A3.x;
    }
    angleTo(A3) {
      const g3 = this.normalize().dot(A3.normalize());
      return g3 > 1 ? 0 : g3 < -1 ? Math.PI : Math.acos(g3);
    }
    signedAngleTo(A3) {
      const g3 = this.angleTo(A3);
      return this.cross(A3) < 0 ? -g3 : g3;
    }
    rotate(A3) {
      const g3 = Math.cos(A3), I3 = Math.sin(A3);
      return new B(this.x * g3 - this.y * I3, this.x * I3 + this.y * g3);
    }
    lerp(A3, g3) {
      const I3 = this.x, C3 = this.y;
      return new B(I3 + g3 * (A3.x - I3), C3 + g3 * (A3.y - C3));
    }
    setRandomDir(A3 = 1) {
      const g3 = 2 * Math.random() * Math.PI;
      return this.__data[0] = Math.cos(g3) * A3, this.__data[1] = Math.sin(g3) * A3, this;
    }
    setRandom(A3 = 1) {
      return this.__data[0] = Math.random() * A3, this.__data[1] = Math.random() * A3, this;
    }
    clone() {
      return new B(this.__data[0], this.__data[1]);
    }
    asArray() {
      return this.__data;
    }
    toString() {
      return t.stringifyJSONWithFixedPrecision(this.toJSON());
    }
    toJSON() {
      return {x: this.x, y: this.y};
    }
    fromJSON(A3) {
      this.x = A3.x, this.y = A3.y;
    }
    readBinary(A3) {
      this.x = A3.loadFloat32(), this.y = A3.loadFloat32();
    }
    static intersectionOfLines(A3, g3, I3, C3) {
      const i3 = (A3.x - g3.x) * (I3.y - C3.y) - (A3.y - g3.y) * (I3.x - C3.x);
      if (i3 == 0)
        return null;
      const e3 = A3.x * g3.y - A3.y * g3.x, t3 = I3.x * C3.y - I3.y * C3.x, o3 = I3.x - C3.x, s3 = A3.x - g3.x, a3 = I3.y - C3.y, l3 = A3.y - g3.y;
      return new B((e3 * o3 - s3 * t3) / i3, (e3 * a3 - l3 * t3) / i3);
    }
    isValid() {
      for (const A3 of this.__data)
        if (A3 == 1 / 0 || isNaN(A3))
          return false;
      return true;
    }
  };
  var o = class {
    constructor(A3 = 0, g3 = 0, I3 = 0) {
      if (A3 instanceof Float32Array || A3 instanceof Uint32Array)
        this.__data = A3;
      else if (A3 instanceof ArrayBuffer) {
        console.warn("deprecated, please use new Vec3(new Float32Array(buffer, byteOffset, 3))");
        const I4 = A3, C3 = g3;
        this.__data = new Float32Array(I4, C3, 3);
      } else
        typeof A3 == "number" && typeof g3 == "number" && typeof I3 == "number" ? (this.__data = new Float32Array(3), this.__data[0] = A3, this.__data[1] = g3, this.__data[2] = I3) : A3 != null && typeof A3 == "object" ? (this.__data = new Float32Array(3), this.fromJSON(A3)) : this.__data = new Float32Array(3);
    }
    get x() {
      return this.__data[0];
    }
    set x(A3) {
      this.__data[0] = A3;
    }
    get y() {
      return this.__data[1];
    }
    set y(A3) {
      this.__data[1] = A3;
    }
    get z() {
      return this.__data[2];
    }
    set z(A3) {
      this.__data[2] = A3;
    }
    get xy() {
      return new B(this.__data[0], this.__data[1]);
    }
    get yz() {
      return new B(this.__data[1], this.__data[2]);
    }
    set(A3, g3, I3) {
      this.x = A3, this.y = g3 !== void 0 ? g3 : A3, this.z = I3 !== void 0 ? I3 : A3;
    }
    setDataArray(A3) {
      this.__data = A3;
    }
    setFromOther(A3) {
      this.x = A3.x, this.y = A3.y, this.z = A3.z;
    }
    isNull() {
      return Math.abs(this.x) < Number.EPSILON && Math.abs(this.y) < Number.EPSILON && Math.abs(this.z) < Number.EPSILON;
    }
    is111() {
      return Math.abs(1 - this.x) < Number.EPSILON && Math.abs(1 - this.y) < Number.EPSILON && Math.abs(1 - this.z) < Number.EPSILON;
    }
    isEqual(A3) {
      return this.x == A3.x && this.y == A3.y && this.z == A3.z;
    }
    notEqual(A3) {
      return this.x != A3.x && this.y != A3.y && this.z != A3.z;
    }
    approxEqual(A3, g3 = Number.EPSILON) {
      return Math.abs(this.x - A3.x) < g3 && Math.abs(this.y - A3.y) < g3 && Math.abs(this.z - A3.z) < g3;
    }
    add(A3) {
      return new o(this.x + A3.x, this.y + A3.y, this.z + A3.z);
    }
    addInPlace(A3) {
      this.x += A3.x, this.y += A3.y, this.z += A3.z;
    }
    subtract(A3) {
      return new o(this.x - A3.x, this.y - A3.y, this.z - A3.z);
    }
    subtractInPlace(A3) {
      this.x -= A3.x, this.y -= A3.y, this.z -= A3.z;
    }
    multiply(A3) {
      return new o(this.x * A3.x, this.y * A3.y, this.z * A3.z);
    }
    multiplyInPlace(A3) {
      this.x *= A3.x, this.y *= A3.y, this.z *= A3.z;
    }
    divide(A3) {
      return new o(this.x / A3.x, this.y / A3.y, this.z / A3.z);
    }
    divideInPlace(A3) {
      this.x /= A3.x, this.y /= A3.y, this.z /= A3.z;
    }
    scale(A3) {
      return new o(this.x * A3, this.y * A3, this.z * A3);
    }
    scaleInPlace(A3) {
      this.x *= A3, this.y *= A3, this.z *= A3;
    }
    negate() {
      return new o(-this.x, -this.y, -this.z);
    }
    inverse() {
      return new o(1 / this.x, 1 / this.y, 1 / this.z);
    }
    lengthSquared() {
      const A3 = this.__data[0], g3 = this.__data[1], I3 = this.__data[2];
      return A3 * A3 + g3 * g3 + I3 * I3;
    }
    length() {
      return Math.sqrt(this.lengthSquared());
    }
    distanceTo(A3) {
      const g3 = this.__data[0] - A3.x, I3 = this.__data[1] - A3.y, C3 = this.__data[2] - A3.z;
      return Math.sqrt(g3 * g3 + I3 * I3 + C3 * C3);
    }
    normalize() {
      let A3 = this.__data[0] * this.__data[0] + this.__data[1] * this.__data[1] + this.__data[2] * this.__data[2];
      return A3 < Number.EPSILON ? new o() : (A3 = 1 / Math.sqrt(A3), new o(this.__data[0] * A3, this.__data[1] * A3, this.__data[2] * A3));
    }
    normalizeInPlace() {
      let A3 = this.__data[0] * this.__data[0] + this.__data[1] * this.__data[1] + this.__data[2] * this.__data[2];
      if (A3 < Number.EPSILON)
        return;
      A3 = Math.sqrt(A3);
      const g3 = 1 / A3;
      return this.__data[0] *= g3, this.__data[1] *= g3, this.__data[2] *= g3, A3;
    }
    resize(A3) {
      const g3 = this.__data[0] * this.__data[0] + this.__data[1] * this.__data[1] + this.__data[2] * this.__data[2];
      if (g3 < Number.EPSILON)
        return;
      const I3 = A3 / Math.sqrt(g3);
      return new o(this.__data[0] * I3, this.__data[1] * I3, this.__data[2] * I3);
    }
    resizeInPlace(A3) {
      const g3 = this.__data[0] * this.__data[0] + this.__data[1] * this.__data[1] + this.__data[2] * this.__data[2];
      if (g3 < Number.EPSILON)
        return;
      const I3 = A3 / Math.sqrt(g3);
      this.__data[0] *= I3, this.__data[1] *= I3, this.__data[2] *= I3;
    }
    dot(A3) {
      return this.x * A3.x + this.y * A3.y + this.z * A3.z;
    }
    cross(A3) {
      const g3 = this.x, I3 = this.y, C3 = this.z, i3 = A3.x, e3 = A3.y, t3 = A3.z;
      return new o(I3 * t3 - C3 * e3, C3 * i3 - g3 * t3, g3 * e3 - I3 * i3);
    }
    angleTo(A3) {
      const g3 = this.dot(A3);
      return g3 > 1 ? 0 : Math.acos(g3);
    }
    lerp(A3, g3) {
      const I3 = this.x, C3 = this.y, i3 = this.z;
      return new o(I3 + g3 * (A3.x - I3), C3 + g3 * (A3.y - C3), i3 + g3 * (A3.z - i3));
    }
    abs() {
      return new o(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z));
    }
    setRandomDir(A3 = 1) {
      const g3 = 2 * Math.random() * Math.PI, I3 = 2 * Math.random() - 1, C3 = Math.sqrt(1 - I3 * I3) * A3;
      return this.__data[0] = Math.cos(g3) * C3, this.__data[1] = Math.sin(g3) * C3, this.__data[2] = I3 * A3, this;
    }
    setRandom(A3 = 1) {
      return this.__data[0] = (Math.random() - 0.5) * A3, this.__data[1] = (Math.random() - 0.5) * A3, this.__data[2] = (Math.random() - 0.5) * A3, this;
    }
    clone() {
      return new o(this.__data[0], this.__data[1], this.__data[2]);
    }
    asArray() {
      return this.__data;
    }
    toString() {
      return t.stringifyJSONWithFixedPrecision(this.toJSON());
    }
    toJSON() {
      return {x: this.x, y: this.y, z: this.z};
    }
    fromJSON(A3) {
      this.x = A3.x, this.y = A3.y, this.z = A3.z;
    }
    readBinary(A3) {
      this.x = A3.loadFloat32(), this.y = A3.loadFloat32(), this.z = A3.loadFloat32();
    }
    isValid() {
      for (const A3 of this.__data)
        if (A3 == 1 / 0 || isNaN(A3))
          return false;
      return true;
    }
  };
  var s = class {
    constructor(A3 = 0, g3 = 0, I3 = 0, C3 = 0) {
      if (A3 instanceof Float32Array || A3 instanceof Uint32Array)
        this.__data = A3;
      else if (A3 instanceof ArrayBuffer) {
        console.warn("deprecated, please use new Vec4(new Float32Array(buffer, byteOffset, 4))");
        const I4 = A3, C4 = g3;
        this.__data = new Float32Array(I4, C4, 4);
      } else
        typeof A3 == "number" && typeof g3 == "number" && typeof I3 == "number" && typeof C3 == "number" ? (this.__data = new Float32Array(4), this.__data[0] = A3, this.__data[1] = g3, this.__data[2] = I3, this.__data[3] = C3) : A3 != null && typeof A3 == "object" ? (this.__data = new Float32Array(4), this.fromJSON(A3)) : this.__data = new Float32Array(4);
    }
    get x() {
      return this.__data[0];
    }
    set x(A3) {
      this.__data[0] = A3;
    }
    get y() {
      return this.__data[1];
    }
    set y(A3) {
      this.__data[1] = A3;
    }
    get z() {
      return this.__data[2];
    }
    set z(A3) {
      this.__data[2] = A3;
    }
    get t() {
      return this.__data[3];
    }
    set t(A3) {
      this.__data[3] = A3;
    }
    get w() {
      return this.__data[3];
    }
    set w(A3) {
      this.__data[3] = A3;
    }
    get xyz() {
      return new o(this.__data[0], this.__data[1], this.__data[2]);
    }
    set(A3, g3, I3, C3) {
      this.x = A3, this.y = g3, this.z = I3, this.t = C3;
    }
    setFromOther(A3) {
      this.x = A3.x, this.y = A3.y, this.z = A3.z, this.t = A3.t;
    }
    isEqual(A3) {
      return this.x == A3.x && this.y == A3.y && this.z == A3.z && this.t == A3.t;
    }
    notEqual(A3) {
      return this.x != A3.x && this.y != A3.y && this.z != A3.z && this.t != A3.t;
    }
    approxEqual(A3, g3 = Number.EPSILON) {
      return Math.abs(this.x - A3.x) < g3 && Math.abs(this.y - A3.y) < g3 && Math.abs(this.z - A3.z) < g3 && Math.abs(this.t - A3.t) < g3;
    }
    add(A3) {
      return new s(this.x + A3.x, this.y + A3.y, this.z + A3.z, this.t + A3.t);
    }
    addInPlace(A3) {
      this.x += A3.x, this.y += A3.y, this.z += A3.z, this.t += A3.t;
    }
    subtract(A3) {
      return new s(this.x - A3.x, this.y - A3.y, this.z - A3.z, this.t - A3.t);
    }
    subtractInPlace(A3) {
      this.x -= A3.x, this.y -= A3.y, this.z -= A3.z, this.t -= A3.t;
    }
    multiply(A3) {
      return new s(this.x * A3.x, this.y * A3.y, this.z * A3.z, this.t * A3.t);
    }
    multiplyInPlace(A3) {
      this.x *= A3.x, this.y *= A3.y, this.z *= A3.z, this.t *= A3.t;
    }
    divide(A3) {
      return new s(this.x / A3.x, this.y / A3.y, this.z / A3.z, this.t / A3.t);
    }
    divideInPlace(A3) {
      this.x /= A3.x, this.y /= A3.y, this.z /= A3.z, this.t /= A3.t;
    }
    scale(A3) {
      return new s(this.x * A3, this.y * A3, this.z * A3, this.t * A3);
    }
    scaleInPlace(A3) {
      this.set(this.x * A3, this.y * A3, this.z * A3, this.t * A3);
    }
    length() {
      const A3 = this.__data[0], g3 = this.__data[1], I3 = this.__data[2], C3 = this.__data[2];
      return Math.sqrt(A3 * A3 + g3 * g3 + I3 * I3 + C3 * C3);
    }
    lengthSquared() {
      const A3 = this.__data[0], g3 = this.__data[1], I3 = this.__data[2], C3 = this.__data[3];
      return A3 * A3 + g3 * g3 + I3 * I3 + C3 * C3;
    }
    normalize() {
      const A3 = this.__data[0], g3 = this.__data[1], I3 = this.__data[2], C3 = this.__data[3];
      let i3 = A3 * A3 + g3 * g3 + I3 * I3 + C3 * C3;
      return i3 < Number.EPSILON ? new s() : (i3 = 1 / Math.sqrt(i3), new s(A3 * i3, g3 * i3, I3 * i3));
    }
    normalizeInPlace() {
      const A3 = this.__data[0], g3 = this.__data[1], I3 = this.__data[2], C3 = this.__data[3];
      let i3 = A3 * A3 + g3 * g3 + I3 * I3 + C3 * C3;
      i3 < Number.EPSILON || (i3 = 1 / Math.sqrt(i3), this.set(A3 * i3, g3 * i3, I3 * i3, C3 * i3));
    }
    dot(A3) {
      return this.x * A3.x + this.y * A3.y + this.z * A3.z + this.t * A3.t;
    }
    cross(A3) {
      const g3 = this.x, I3 = this.y, C3 = this.z, i3 = this.t, e3 = A3.x, t3 = A3.y, B3 = A3.z, o3 = A3.t;
      return new s(I3 * B3 - C3 * t3, C3 * o3 - i3 * B3, i3 * e3 - g3 * o3, g3 * t3 - I3 * e3);
    }
    angleTo(A3) {
      const g3 = this.normalize(), I3 = A3.normalize(), C3 = g3.dot(I3);
      return C3 > 1 ? 0 : Math.acos(C3);
    }
    lerp(A3, g3) {
      const I3 = this.x, C3 = this.y, i3 = this.z, e3 = this.t;
      return new s(I3 + g3 * (A3.x - I3), C3 + g3 * (A3.y - C3), i3 + g3 * (A3.z - i3), e3 + g3 * (A3.t - e3));
    }
    clone() {
      return new s(this.__data[0], this.__data[1], this.__data[2], this.__data[3]);
    }
    toVec3() {
      return new o(this.__data[0], this.__data[1], this.__data[2]);
    }
    asArray() {
      return this.__data;
    }
    toString() {
      return t.stringifyJSONWithFixedPrecision(this.toJSON());
    }
    toJSON() {
      return {x: this.x, y: this.y, z: this.z, t: this.t};
    }
    fromJSON(A3) {
      this.x = A3.x, this.y = A3.y, this.z = A3.z, this.t = A3.t;
    }
    readBinary(A3) {
      this.x = A3.loadFloat32(), this.y = A3.loadFloat32(), this.z = A3.loadFloat32(), this.t = A3.loadFloat32();
    }
    isValid() {
      for (const A3 of this.__data)
        if (A3 == 1 / 0 || isNaN(A3))
          return false;
      return true;
    }
  };
  var a = class {
    constructor(A3 = 0, g3 = 0, I3 = 0, C3 = 255) {
      if (A3 instanceof Uint8Array)
        this.__data = A3;
      else if (A3 instanceof ArrayBuffer) {
        const I4 = A3, C4 = g3;
        this.__data = new Uint8Array(I4, C4, 4);
      } else
        this.__data = new Uint8Array(4), typeof A3 == "string" ? A3.startsWith("#") ? this.setFromHex(A3) : this.setFromCSSColorName(A3) : (this.__data[0] = A3, this.__data[1] = g3, this.__data[2] = I3, this.__data[3] = C3);
    }
    get r() {
      return this.__data[0];
    }
    set r(A3) {
      this.__data[0] = A3;
    }
    get g() {
      return this.__data[1];
    }
    set g(A3) {
      this.__data[1] = A3;
    }
    get b() {
      return this.__data[2];
    }
    set b(A3) {
      this.__data[2] = A3;
    }
    get a() {
      return this.__data[3];
    }
    set a(A3) {
      this.__data[3] = A3;
    }
    set(A3, g3, I3, C3 = 255) {
      this.r = A3, this.g = g3, this.b = I3, this.a = C3;
    }
    setFromOther(A3) {
      this.r = A3.r, this.g = A3.g, this.b = A3.b, this.a = A3.a;
    }
    setFromArray(A3) {
      this.r = A3[0], this.g = A3[1], this.b = A3[2], this.a = A3.length == 4 ? A3[3] : 1;
    }
    setFromHex(A3) {
      const g3 = function(A4) {
        const g4 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(A4);
        return g4 ? {r: parseInt(g4[1], 16), g: parseInt(g4[2], 16), b: parseInt(g4[3], 16)} : null;
      }(A3);
      g3 ? this.set(g3.r, g3.g, g3.b) : console.warn("Invalid hex code:" + A3);
    }
    setFromCSSColorName(A3) {
      if (A3.startsWith("#"))
        this.setFromHex(A3);
      else {
        const g3 = {aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gray: "#808080", green: "#008000", greenyellow: "#adff2f", honeydew: "#f0fff0", hotpink: "#ff69b4", "indianred ": "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgrey: "#d3d3d3", lightgreen: "#90ee90", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370d8", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#d87093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", rebeccapurple: "#663399", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32"}[A3.toLowerCase()];
        g3 && this.setFromHex(g3);
      }
    }
    toHex() {
      function A3(A4) {
        const g3 = A4.toString(16);
        return g3.length == 1 ? "0" + g3 : g3;
      }
      return "#" + A3(this.r) + A3(this.g) + A3(this.b);
    }
    equal(A3) {
      return this.r == A3.r && this.g == A3.g && this.b == A3.b && this.a == A3.a;
    }
    notEquals(A3) {
      return this.r != A3.r && this.g != A3.g && this.b != A3.b && this.a != A3.a;
    }
    approxEqual(A3, g3 = Number.EPSILON) {
      return Math.abs(this.r - A3.r) < g3 && Math.abs(this.g - A3.g) < g3 && Math.abs(this.b - A3.b) < g3 && Math.abs(this.a - A3.a) < g3;
    }
    add(A3) {
      return new a(this.r + A3.r, this.g + A3.g, this.b + A3.b, this.a + A3.a);
    }
    subtract(A3) {
      return new a(this.r - A3.r, this.g - A3.g, this.b - A3.b, this.a - A3.a);
    }
    scale(A3) {
      return new a(this.r * A3, this.g * A3, this.b * A3, this.a * A3);
    }
    scaleInPlace(A3) {
      this.r *= A3, this.g *= A3, this.b *= A3, this.a *= A3;
    }
    applyGamma(A3) {
      this.set(Math.pow(this.r, A3), Math.pow(this.g, A3), Math.pow(this.b, A3), this.a);
    }
    toLinear(A3 = 2.2) {
      return new a(Math.pow(this.r, A3), Math.pow(this.g, A3), Math.pow(this.b, A3), this.a);
    }
    toGamma(A3 = 2.2) {
      return new a(Math.pow(this.r, 1 / A3), Math.pow(this.g, 1 / A3), Math.pow(this.b, 1 / A3), this.a);
    }
    luminance() {
      return 0.2126 * this.r + 0.7152 * this.g + 0.0722 * this.b;
    }
    lerp(A3, g3) {
      const I3 = this.r, C3 = this.g, i3 = this.b, e3 = this.a;
      return new a(I3 + g3 * (A3.r - I3), C3 + g3 * (A3.g - C3), i3 + g3 * (A3.b - i3), e3 + g3 * (A3.a - e3));
    }
    static random(A3 = 0, g3 = false) {
      return A3 > 0 ? new a(A3 + Math.random() * (1 - A3), A3 + Math.random() * (1 - A3), A3 + Math.random() * (1 - A3), g3 ? A3 + Math.random() * (1 - A3) : 1) : A3 < 0 ? new a(Math.random() * (1 + A3), Math.random() * (1 + A3), Math.random() * (1 + A3), g3 ? Math.random() * (1 + A3) : 1) : new a(Math.random(), Math.random(), Math.random(), g3 ? Math.random() : 1);
    }
    clone() {
      return new a(this.__data[0], this.__data[1], this.__data[2], this.__data[3]);
    }
    asArray() {
      return this.__data;
    }
    as3ComponentArray() {
      return [this.__data[0], this.__data[1], this.__data[2]];
    }
    toJSON() {
      return {r: this.r, g: this.g, b: this.b, a: this.a};
    }
    fromJSON(A3) {
      this.r = A3.r, this.g = A3.g, this.b = A3.b, this.a = A3.a;
    }
    toCSSString() {
      return "rgba(" + Math.round(255 * this.r) + ", " + Math.round(255 * this.g) + ", " + Math.round(255 * this.b) + ", " + this.a + ")";
    }
  };
  var l = class {
    constructor(A3 = 0, g3 = 0, I3 = 0, C3 = 1) {
      if (A3 instanceof Float32Array)
        this.__data = A3;
      else if (A3 instanceof ArrayBuffer) {
        console.warn("deprecated, please use new Vec4(new Float32Array(buffer, byteOffset, 4))");
        const I4 = A3, C4 = g3;
        this.__data = new Float32Array(I4, C4, 4);
      } else
        this.__data = new Float32Array(4), typeof A3 == "string" ? A3.startsWith("#") ? this.setFromHex(A3) : this.setFromCSSColorName(A3) : (this.__data[0] = A3, this.__data[1] = g3, this.__data[2] = I3, this.__data[3] = C3);
    }
    get r() {
      return this.__data[0];
    }
    set r(A3) {
      this.__data[0] = A3;
    }
    get g() {
      return this.__data[1];
    }
    set g(A3) {
      this.__data[1] = A3;
    }
    get b() {
      return this.__data[2];
    }
    set b(A3) {
      this.__data[2] = A3;
    }
    get a() {
      return this.__data[3];
    }
    set a(A3) {
      this.__data[3] = A3;
    }
    set(A3, g3, I3, C3 = 1) {
      this.r = A3, this.g = g3, this.b = I3, this.a = C3;
    }
    setFromOther(A3) {
      this.r = A3.r, this.g = A3.g, this.b = A3.b, this.a = A3.a;
    }
    setFromScalarArray(A3) {
      this.r = A3[0], this.g = A3[1], this.b = A3[2], this.a = A3.length == 4 ? A3[3] : 1;
    }
    getAsRGBArray() {
      return [255 * this.r, 255 * this.g, 255 * this.b];
    }
    getAsRGBDict() {
      return {r: 255 * this.r, g: 255 * this.g, b: 255 * this.b};
    }
    setFromRGB(A3, g3, I3, C3) {
      this.r = A3 / 255, this.g = g3 / 255, this.b = I3 / 255, this.a = C3 ? C3 / 255 : 1;
    }
    setFromRGBArray(A3) {
      this.r = A3[0] / 255, this.g = A3[1] / 255, this.b = A3[2] / 255, this.a = A3.length == 4 ? A3[3] / 255 : 1;
    }
    setFromRGBDict(A3) {
      this.r = A3.r / 255, this.g = A3.g / 255, this.b = A3.b / 255, this.a = A3.a == 4 ? A3.a / 255 : 1;
    }
    setFromHex(A3) {
      const g3 = function(A4) {
        const g4 = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(A4);
        return g4 ? {r: parseInt(g4[1], 16), g: parseInt(g4[2], 16), b: parseInt(g4[3], 16)} : null;
      }(A3);
      g3 ? this.setFromRGB(g3.r, g3.g, g3.b) : console.warn("Invalid hex code:" + A3);
    }
    setFromCSSColorName(A3) {
      if (A3.startsWith("#"))
        this.setFromHex(A3);
      else {
        const g3 = {aliceblue: "#f0f8ff", antiquewhite: "#faebd7", aqua: "#00ffff", aquamarine: "#7fffd4", azure: "#f0ffff", beige: "#f5f5dc", bisque: "#ffe4c4", black: "#000000", blanchedalmond: "#ffebcd", blue: "#0000ff", blueviolet: "#8a2be2", brown: "#a52a2a", burlywood: "#deb887", cadetblue: "#5f9ea0", chartreuse: "#7fff00", chocolate: "#d2691e", coral: "#ff7f50", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cyan: "#00ffff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", darkgreen: "#006400", darkkhaki: "#bdb76b", darkmagenta: "#8b008b", darkolivegreen: "#556b2f", darkorange: "#ff8c00", darkorchid: "#9932cc", darkred: "#8b0000", darksalmon: "#e9967a", darkseagreen: "#8fbc8f", darkslateblue: "#483d8b", darkslategray: "#2f4f4f", darkturquoise: "#00ced1", darkviolet: "#9400d3", deeppink: "#ff1493", deepskyblue: "#00bfff", dimgray: "#696969", dodgerblue: "#1e90ff", firebrick: "#b22222", floralwhite: "#fffaf0", forestgreen: "#228b22", fuchsia: "#ff00ff", gainsboro: "#dcdcdc", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gray: "#808080", green: "#008000", greenyellow: "#adff2f", honeydew: "#f0fff0", hotpink: "#ff69b4", "indianred ": "#cd5c5c", indigo: "#4b0082", ivory: "#fffff0", khaki: "#f0e68c", lavender: "#e6e6fa", lavenderblush: "#fff0f5", lawngreen: "#7cfc00", lemonchiffon: "#fffacd", lightblue: "#add8e6", lightcoral: "#f08080", lightcyan: "#e0ffff", lightgoldenrodyellow: "#fafad2", lightgrey: "#d3d3d3", lightgreen: "#90ee90", lightpink: "#ffb6c1", lightsalmon: "#ffa07a", lightseagreen: "#20b2aa", lightskyblue: "#87cefa", lightslategray: "#778899", lightsteelblue: "#b0c4de", lightyellow: "#ffffe0", lime: "#00ff00", limegreen: "#32cd32", linen: "#faf0e6", magenta: "#ff00ff", maroon: "#800000", mediumaquamarine: "#66cdaa", mediumblue: "#0000cd", mediumorchid: "#ba55d3", mediumpurple: "#9370d8", mediumseagreen: "#3cb371", mediumslateblue: "#7b68ee", mediumspringgreen: "#00fa9a", mediumturquoise: "#48d1cc", mediumvioletred: "#c71585", midnightblue: "#191970", mintcream: "#f5fffa", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", navajowhite: "#ffdead", navy: "#000080", oldlace: "#fdf5e6", olive: "#808000", olivedrab: "#6b8e23", orange: "#ffa500", orangered: "#ff4500", orchid: "#da70d6", palegoldenrod: "#eee8aa", palegreen: "#98fb98", paleturquoise: "#afeeee", palevioletred: "#d87093", papayawhip: "#ffefd5", peachpuff: "#ffdab9", peru: "#cd853f", pink: "#ffc0cb", plum: "#dda0dd", powderblue: "#b0e0e6", purple: "#800080", rebeccapurple: "#663399", red: "#ff0000", rosybrown: "#bc8f8f", royalblue: "#4169e1", saddlebrown: "#8b4513", salmon: "#fa8072", sandybrown: "#f4a460", seagreen: "#2e8b57", seashell: "#fff5ee", sienna: "#a0522d", silver: "#c0c0c0", skyblue: "#87ceeb", slateblue: "#6a5acd", slategray: "#708090", snow: "#fffafa", springgreen: "#00ff7f", steelblue: "#4682b4", tan: "#d2b48c", teal: "#008080", thistle: "#d8bfd8", tomato: "#ff6347", turquoise: "#40e0d0", violet: "#ee82ee", wheat: "#f5deb3", white: "#ffffff", whitesmoke: "#f5f5f5", yellow: "#ffff00", yellowgreen: "#9acd32"}[A3.toLowerCase()];
        g3 && this.setFromHex(g3);
      }
    }
    toHex() {
      function A3(A4) {
        const g3 = Math.round(255 * A4).toString(16);
        return g3.length == 1 ? "0" + g3 : g3;
      }
      return "#" + A3(this.r) + A3(this.g) + A3(this.b);
    }
    isEqual(A3) {
      return this.r == A3.r && this.g == A3.g && this.b == A3.b && this.a == A3.a;
    }
    notEquals(A3) {
      return this.r != A3.r && this.g != A3.g && this.b != A3.b && this.a != A3.a;
    }
    approxEqual(A3, g3 = Number.EPSILON) {
      return Math.abs(this.r - A3.r) < g3 && Math.abs(this.g - A3.g) < g3 && Math.abs(this.b - A3.b) < g3 && Math.abs(this.a - A3.a) < g3;
    }
    add(A3) {
      return new l(this.r + A3.r, this.g + A3.g, this.b + A3.b, this.a + A3.a);
    }
    addInPlace(A3) {
      this.r += A3.r, this.g += A3.g, this.b += A3.b, this.a += A3.a;
    }
    subtract(A3) {
      return new l(this.r - A3.r, this.g - A3.g, this.b - A3.b, this.a - A3.a);
    }
    scale(A3) {
      return new l(this.r * A3, this.g * A3, this.b * A3, this.a * A3);
    }
    scaleInPlace(A3) {
      this.r *= A3, this.g *= A3, this.b *= A3, this.a *= A3;
    }
    applyGamma(A3) {
      this.set(Math.pow(this.r, A3), Math.pow(this.g, A3), Math.pow(this.b, A3), this.a);
    }
    toLinear(A3 = 2.2) {
      return new l(Math.pow(this.r, A3), Math.pow(this.g, A3), Math.pow(this.b, A3), this.a);
    }
    toGamma(A3 = 2.2) {
      return new l(Math.pow(this.r, 1 / A3), Math.pow(this.g, 1 / A3), Math.pow(this.b, 1 / A3), this.a);
    }
    luminance() {
      return 0.2126 * this.r + 0.7152 * this.g + 0.0722 * this.b;
    }
    lerp(A3, g3) {
      const I3 = this.r, C3 = this.g, i3 = this.b, e3 = this.a;
      return new l(I3 + g3 * (A3.r - I3), C3 + g3 * (A3.g - C3), i3 + g3 * (A3.b - i3), e3 + g3 * (A3.a - e3));
    }
    static random(A3 = 0, g3 = false) {
      return A3 > 0 ? new l(A3 + Math.random() * (1 - A3), A3 + Math.random() * (1 - A3), A3 + Math.random() * (1 - A3), g3 ? A3 + Math.random() * (1 - A3) : 1) : A3 < 0 ? new l(Math.random() * (1 + A3), Math.random() * (1 + A3), Math.random() * (1 + A3), g3 ? Math.random() * (1 + A3) : 1) : new l(Math.random(), Math.random(), Math.random(), g3 ? Math.random() : 1);
    }
    clone() {
      return new l(this.__data[0], this.__data[1], this.__data[2], this.__data[3]);
    }
    asArray() {
      return this.__data;
    }
    as3ComponentArray() {
      return [this.__data[0], this.__data[1], this.__data[2]];
    }
    toJSON() {
      return {r: this.r, g: this.g, b: this.b, a: this.a};
    }
    fromJSON(A3) {
      this.r = A3.r, this.g = A3.g, this.b = A3.b, this.a = A3.a;
    }
    readBinary(A3) {
      this.r = A3.loadFloat32(), this.g = A3.loadFloat32(), this.b = A3.loadFloat32(), this.a = A3.loadFloat32();
    }
    toCSSString() {
      return "rgba(" + Math.round(255 * this.r) + ", " + Math.round(255 * this.g) + ", " + Math.round(255 * this.b) + ", " + this.a + ")";
    }
  };
  var n = class {
    constructor(A3 = 0, g3 = 0, I3 = 0, C3 = 0) {
      if (typeof C3 != "number" || isNaN(C3))
        switch (C3) {
          case "XYZ":
            this.order = 0;
            break;
          case "YZX":
            this.order = 1;
            break;
          case "ZXY":
            this.order = 2;
            break;
          case "XZY":
            this.order = 3;
            break;
          case "ZYX":
            this.order = 4;
            break;
          case "YXZ":
            this.order = 5;
            break;
          default:
            throw new Error("Invalid Euler Angles Order:" + C3);
        }
      else
        this.order = C3;
      if (A3 instanceof ArrayBuffer) {
        const I4 = A3, C4 = g3;
        this.__data = new Float32Array(I4, C4, 4);
      } else
        this.__data = new Float32Array(3), this.__data[0] = A3, this.__data[1] = g3, this.__data[2] = I3;
    }
    get x() {
      return this.__data[0];
    }
    set x(A3) {
      this.__data[0] = A3;
    }
    get y() {
      return this.__data[1];
    }
    set y(A3) {
      this.__data[1] = A3;
    }
    get z() {
      return this.__data[2];
    }
    set z(A3) {
      this.__data[2] = A3;
    }
    set(A3, g3, I3) {
      this.__data[0] = A3, this.__data[1] = g3, this.__data[2] = I3;
    }
    toString() {
      return t.stringifyJSONWithFixedPrecision(this.toJSON());
    }
    toJSON() {
      return {x: this.__data[0], y: this.__data[1], z: this.__data[2], order: this.order};
    }
    fromJSON(A3) {
      this.__data[0] = A3.x, this.__data[1] = A3.y, this.__data[2] = A3.z, this.order = A3.order;
    }
  };
  var d = class {
    constructor(A3 = 1, g3 = 0, I3 = 0, C3 = 0, i3 = 1, e3 = 0, t3 = 0, B3 = 0, s3 = 1) {
      if (A3 instanceof o && g3 instanceof o && I3 instanceof o)
        this.__data = new Float32Array(9), this.set(A3.x, A3.y, A3.z, g3.x, g3.y, g3.z, I3.x, I3.y, I3.z);
      else if (A3 instanceof Float32Array)
        this.__data = A3;
      else if (A3 instanceof ArrayBuffer) {
        console.warn("Deprecated, please use new Vec3(new Float32Array(buffer, byteOffset, 9))");
        const I4 = A3, C4 = g3;
        this.__data = new Float32Array(I4, C4, 9);
      } else
        this.__data = new Float32Array(9), this.set(A3, g3, I3, C3, i3, e3, t3, B3, s3);
    }
    get m00() {
      return this.__data[0];
    }
    set m00(A3) {
      this.__data[0] = A3;
    }
    get m01() {
      return this.__data[1];
    }
    set m01(A3) {
      this.__data[1] = A3;
    }
    get m02() {
      return this.__data[2];
    }
    set m02(A3) {
      this.__data[2] = A3;
    }
    get m10() {
      return this.__data[3];
    }
    set m10(A3) {
      this.__data[3] = A3;
    }
    get m11() {
      return this.__data[4];
    }
    set m11(A3) {
      this.__data[4] = A3;
    }
    get m12() {
      return this.__data[5];
    }
    set m12(A3) {
      this.__data[5] = A3;
    }
    get m20() {
      return this.__data[6];
    }
    set m20(A3) {
      this.__data[6] = A3;
    }
    get m21() {
      return this.__data[7];
    }
    set m21(A3) {
      this.__data[7] = A3;
    }
    get m22() {
      return this.__data[8];
    }
    set m22(A3) {
      this.__data[8] = A3;
    }
    get xAxis() {
      return new o(new Float32Array(this.__data.buffer, 0, 3));
    }
    set xAxis(A3) {
      this.xAxis.set(A3.x, A3.y, A3.z);
    }
    get yAxis() {
      return new o(new Float32Array(this.__data.buffer, 12, 3));
    }
    set yAxis(A3) {
      this.yAxis.set(A3.x, A3.y, A3.z);
    }
    get zAxis() {
      return new o(new Float32Array(this.__data.buffer, 24, 3));
    }
    set zAxis(A3) {
      this.zAxis.set(A3.x, A3.y, A3.z);
    }
    set(A3 = 1, g3 = 0, I3 = 0, C3 = 0, i3 = 1, e3 = 0, t3 = 0, B3 = 0, o3 = 1) {
      this.__data[0] = A3, this.__data[1] = g3, this.__data[2] = I3, this.__data[3] = C3, this.__data[4] = i3, this.__data[5] = e3, this.__data[6] = t3, this.__data[7] = B3, this.__data[8] = o3;
    }
    setIdentity() {
      this.set();
    }
    setFromMat(A3) {
      this.__data[0] = A3.m00, this.__data[1] = A3.m01, this.__data[2] = A3.m02, this.__data[3] = A3.m10, this.__data[4] = A3.m11, this.__data[5] = A3.m12, this.__data[6] = A3.m20, this.__data[7] = A3.m21, this.__data[8] = A3.m22;
    }
    setFromDirectionAndUpvector(A3, g3) {
      const I3 = A3, C3 = I3.length();
      if (C3 < Number.EPSILON)
        return void this.setIdentity();
      I3.scaleInPlace(1 / C3);
      const i3 = g3.cross(I3), e3 = i3.length();
      e3 > Number.EPSILON && i3.scaleInPlace(1 / e3);
      const t3 = I3.cross(i3), B3 = t3.length();
      B3 > Number.EPSILON && t3.scaleInPlace(1 / B3), this.set(i3.x, i3.y, i3.z, t3.x, t3.y, t3.z, I3.x, I3.y, I3.z);
    }
    inverse() {
      const A3 = this.__data[0], g3 = this.__data[1], I3 = this.__data[2], C3 = this.__data[3], i3 = this.__data[4], e3 = this.__data[5], t3 = this.__data[6], B3 = this.__data[7], o3 = this.__data[8], s3 = o3 * i3 - e3 * B3, a3 = -o3 * C3 + e3 * t3, l3 = B3 * C3 - i3 * t3;
      let n3 = A3 * s3 + g3 * a3 + I3 * l3;
      return n3 ? (n3 = 1 / n3, new d(s3 * n3, (-o3 * g3 + I3 * B3) * n3, (e3 * g3 - I3 * i3) * n3, a3 * n3, (o3 * A3 - I3 * t3) * n3, (-e3 * A3 + I3 * C3) * n3, l3 * n3, (-B3 * A3 + g3 * t3) * n3, (i3 * A3 - g3 * C3) * n3)) : (console.warn("Unable to invert Mat3"), new d());
    }
    invertInPlace() {
      const A3 = this.__data[0], g3 = this.__data[1], I3 = this.__data[2], C3 = this.__data[3], i3 = this.__data[4], e3 = this.__data[5], t3 = this.__data[6], B3 = this.__data[7], o3 = this.__data[8], s3 = o3 * i3 - e3 * B3, a3 = -o3 * C3 + e3 * t3, l3 = B3 * C3 - i3 * t3;
      let n3 = A3 * s3 + g3 * a3 + I3 * l3;
      return n3 ? (n3 = 1 / n3, this.set(s3 * n3, (-o3 * g3 + I3 * B3) * n3, (e3 * g3 - I3 * i3) * n3, a3 * n3, (o3 * A3 - I3 * t3) * n3, (-e3 * A3 + I3 * C3) * n3, l3 * n3, (-B3 * A3 + g3 * t3) * n3, (i3 * A3 - g3 * C3) * n3), true) : (console.warn("Unable to invert Mat3"), false);
    }
    transpose() {
      return new d(this.__data[0], this.__data[3], this.__data[6], this.__data[1], this.__data[4], this.__data[7], this.__data[2], this.__data[5], this.__data[8]);
    }
    transposeInPlace() {
      const A3 = this.__data[1], g3 = this.__data[2], I3 = this.__data[5];
      this.__data[1] = this.__data[3], this.__data[2] = this.__data[6], this.__data[3] = A3, this.__data[5] = this.__data[7], this.__data[6] = g3, this.__data[7] = I3;
    }
    transformVec3(A3) {
      return new o(this.__data[0] * A3.x + this.__data[1] * A3.y + this.__data[2] * A3.z, this.__data[3] * A3.x + this.__data[4] * A3.y + this.__data[5] * A3.z, this.__data[6] * A3.x + this.__data[7] * A3.y + this.__data[8] * A3.z);
    }
    clone() {
      return new d(this.__data[0], this.__data[1], this.__data[2], this.__data[3], this.__data[4], this.__data[5], this.__data[6], this.__data[7], this.__data[8]);
    }
    readBinary(A3) {
      this.__data = A3.loadFloat32Array(9);
    }
    toJSON() {
      return this.__data;
    }
    fromJSON(A3) {
      this.__data = new Float32Array(A3);
    }
    toString() {
      return t.stringifyJSONWithFixedPrecision(this.toJSON());
    }
    asArray() {
      return this.__data;
    }
  };
  var h = class {
    constructor(A3 = 1, g3 = 0, I3 = 0, C3 = 0, i3 = 0, e3 = 1, t3 = 0, B3 = 0, o3 = 0, s3 = 0, a3 = 1, l3 = 0, n3 = 0, d3 = 0, h3 = 0, c3 = 1) {
      if (A3 instanceof Float32Array)
        this.__data = A3;
      else if (A3 instanceof ArrayBuffer) {
        const I4 = A3, C4 = g3;
        this.__data = new Float32Array(I4, C4, 16);
      } else
        this.__data = new Float32Array(16), this.set(A3, g3, I3, C3, i3, e3, t3, B3, o3, s3, a3, l3, n3, d3, h3, c3);
    }
    get m00() {
      return this.__data[0];
    }
    set m00(A3) {
      this.__data[0] = A3;
    }
    get m01() {
      return this.__data[1];
    }
    set m01(A3) {
      this.__data[1] = A3;
    }
    get m02() {
      return this.__data[2];
    }
    set m02(A3) {
      this.__data[2] = A3;
    }
    get m03() {
      return this.__data[3];
    }
    set m03(A3) {
      this.__data[3] = A3;
    }
    get m10() {
      return this.__data[4];
    }
    set m10(A3) {
      this.__data[4] = A3;
    }
    get m11() {
      return this.__data[5];
    }
    set m11(A3) {
      this.__data[5] = A3;
    }
    get m12() {
      return this.__data[6];
    }
    set m12(A3) {
      this.__data[6] = A3;
    }
    get m13() {
      return this.__data[7];
    }
    set m13(A3) {
      this.__data[7] = A3;
    }
    get m20() {
      return this.__data[8];
    }
    set m20(A3) {
      this.__data[8] = A3;
    }
    get m21() {
      return this.__data[9];
    }
    set m21(A3) {
      this.__data[9] = A3;
    }
    get m22() {
      return this.__data[10];
    }
    set m22(A3) {
      this.__data[10] = A3;
    }
    get m23() {
      return this.__data[11];
    }
    set m23(A3) {
      this.__data[11] = A3;
    }
    get m30() {
      return this.__data[12];
    }
    set m30(A3) {
      this.__data[12] = A3;
    }
    get m31() {
      return this.__data[13];
    }
    set m31(A3) {
      this.__data[13] = A3;
    }
    get m32() {
      return this.__data[14];
    }
    set m32(A3) {
      this.__data[14] = A3;
    }
    get m33() {
      return this.__data[15];
    }
    set m33(A3) {
      this.__data[15] = A3;
    }
    get xAxis() {
      return new o(new Float32Array(this.__data.buffer, 0, 3));
    }
    set xAxis(A3) {
      this.xAxis.set(A3.x, A3.y, A3.z);
    }
    get yAxis() {
      return new o(new Float32Array(this.__data.buffer, 16, 3));
    }
    set yAxis(A3) {
      this.yAxis.set(A3.x, A3.y, A3.z);
    }
    get zAxis() {
      return new o(new Float32Array(this.__data.buffer, 32, 3));
    }
    set zAxis(A3) {
      this.zAxis.set(A3.x, A3.y, A3.z);
    }
    get translation() {
      return new o(new Float32Array(this.__data.buffer, 48, 3));
    }
    set translation(A3) {
      this.translation.set(A3.x, A3.y, A3.z);
    }
    set(A3 = 1, g3 = 0, I3 = 0, C3 = 0, i3 = 0, e3 = 1, t3 = 0, B3 = 0, o3 = 0, s3 = 0, a3 = 1, l3 = 0, n3 = 0, d3 = 0, h3 = 0, c3 = 1) {
      this.__data[0] = A3, this.__data[1] = g3, this.__data[2] = I3, this.__data[3] = C3, this.__data[4] = i3, this.__data[5] = e3, this.__data[6] = t3, this.__data[7] = B3, this.__data[8] = o3, this.__data[9] = s3, this.__data[10] = a3, this.__data[11] = l3, this.__data[12] = n3, this.__data[13] = d3, this.__data[14] = h3, this.__data[15] = c3;
    }
    setIdentity() {
      this.set();
    }
    setDataArray(A3) {
      this.__data = A3;
    }
    setFromMat4(A3) {
      this.__data[0] = A3.m00, this.__data[1] = A3.m01, this.__data[2] = A3.m02, this.__data[3] = A3.m03, this.__data[4] = A3.m10, this.__data[5] = A3.m11, this.__data[6] = A3.m12, this.__data[7] = A3.m13, this.__data[8] = A3.m20, this.__data[9] = A3.m21, this.__data[10] = A3.m22, this.__data[11] = A3.m23, this.__data[12] = A3.m30, this.__data[13] = A3.m31, this.__data[14] = A3.m32, this.__data[15] = A3.m33;
    }
    toMat3() {
      return new d(this.__data[0], this.__data[1], this.__data[2], this.__data[4], this.__data[5], this.__data[6], this.__data[8], this.__data[9], this.__data[10]);
    }
    transposeInPlace() {
      const A3 = this.__data[1], g3 = this.__data[2], I3 = this.__data[3], C3 = this.__data[6], i3 = this.__data[7], e3 = this.__data[11];
      this.__data[1] = this.__data[4], this.__data[2] = this.__data[8], this.__data[3] = this.__data[12], this.__data[4] = A3, this.__data[6] = this.__data[9], this.__data[7] = this.__data[13], this.__data[8] = g3, this.__data[9] = C3, this.__data[11] = this.__data[14], this.__data[12] = I3, this.__data[13] = i3, this.__data[14] = e3;
    }
    transpose() {
      return new h(this.__data[0], this.__data[4], this.__data[8], this.__data[12], this.__data[1], this.__data[5], this.__data[9], this.__data[13], this.__data[2], this.__data[6], this.__data[10], this.__data[14], this.__data[3], this.__data[7], this.__data[11], this.__data[15]);
    }
    inverse() {
      const A3 = this.__data[0], g3 = this.__data[1], I3 = this.__data[2], C3 = this.__data[3], i3 = this.__data[4], e3 = this.__data[5], t3 = this.__data[6], B3 = this.__data[7], o3 = this.__data[8], s3 = this.__data[9], a3 = this.__data[10], l3 = this.__data[11], n3 = this.__data[12], d3 = this.__data[13], c3 = this.__data[14], r3 = this.__data[15], G3 = A3 * e3 - g3 * i3, m3 = A3 * t3 - I3 * i3, Q3 = A3 * B3 - C3 * i3, E3 = g3 * t3 - I3 * e3, b3 = g3 * B3 - C3 * e3, Z3 = I3 * B3 - C3 * t3, y3 = o3 * d3 - s3 * n3, u3 = o3 * c3 - a3 * n3, R3 = o3 * r3 - l3 * n3, V3 = s3 * c3 - a3 * d3, F3 = s3 * r3 - l3 * d3, S3 = a3 * r3 - l3 * c3;
      let w3 = G3 * S3 - m3 * F3 + Q3 * V3 + E3 * R3 - b3 * u3 + Z3 * y3;
      return w3 ? (w3 = 1 / w3, new h((e3 * S3 - t3 * F3 + B3 * V3) * w3, (I3 * F3 - g3 * S3 - C3 * V3) * w3, (d3 * Z3 - c3 * b3 + r3 * E3) * w3, (a3 * b3 - s3 * Z3 - l3 * E3) * w3, (t3 * R3 - i3 * S3 - B3 * u3) * w3, (A3 * S3 - I3 * R3 + C3 * u3) * w3, (c3 * Q3 - n3 * Z3 - r3 * m3) * w3, (o3 * Z3 - a3 * Q3 + l3 * m3) * w3, (i3 * F3 - e3 * R3 + B3 * y3) * w3, (g3 * R3 - A3 * F3 - C3 * y3) * w3, (n3 * b3 - d3 * Q3 + r3 * G3) * w3, (s3 * Q3 - o3 * b3 - l3 * G3) * w3, (e3 * u3 - i3 * V3 - t3 * y3) * w3, (A3 * V3 - g3 * u3 + I3 * y3) * w3, (d3 * m3 - n3 * E3 - c3 * G3) * w3, (o3 * E3 - s3 * m3 + a3 * G3) * w3)) : (console.warn("Unable to invert Mat4"), this);
    }
    invertInPlace() {
      const A3 = this.__data[0], g3 = this.__data[1], I3 = this.__data[2], C3 = this.__data[3], i3 = this.__data[4], e3 = this.__data[5], t3 = this.__data[6], B3 = this.__data[7], o3 = this.__data[8], s3 = this.__data[9], a3 = this.__data[10], l3 = this.__data[11], n3 = this.__data[12], d3 = this.__data[13], h3 = this.__data[14], c3 = this.__data[15], r3 = A3 * e3 - g3 * i3, G3 = A3 * t3 - I3 * i3, m3 = A3 * B3 - C3 * i3, Q3 = g3 * t3 - I3 * e3, E3 = g3 * B3 - C3 * e3, b3 = I3 * B3 - C3 * t3, Z3 = o3 * d3 - s3 * n3, y3 = o3 * h3 - a3 * n3, u3 = o3 * c3 - l3 * n3, R3 = s3 * h3 - a3 * d3, V3 = s3 * c3 - l3 * d3, F3 = a3 * c3 - l3 * h3;
      let S3 = r3 * F3 - G3 * V3 + m3 * R3 + Q3 * u3 - E3 * y3 + b3 * Z3;
      return S3 ? (S3 = 1 / S3, this.set((e3 * F3 - t3 * V3 + B3 * R3) * S3, (I3 * V3 - g3 * F3 - C3 * R3) * S3, (d3 * b3 - h3 * E3 + c3 * Q3) * S3, (a3 * E3 - s3 * b3 - l3 * Q3) * S3, (t3 * u3 - i3 * F3 - B3 * y3) * S3, (A3 * F3 - I3 * u3 + C3 * y3) * S3, (h3 * m3 - n3 * b3 - c3 * G3) * S3, (o3 * b3 - a3 * m3 + l3 * G3) * S3, (i3 * V3 - e3 * u3 + B3 * Z3) * S3, (g3 * u3 - A3 * V3 - C3 * Z3) * S3, (n3 * E3 - d3 * m3 + c3 * r3) * S3, (s3 * m3 - o3 * E3 - l3 * r3) * S3, (e3 * y3 - i3 * R3 - t3 * Z3) * S3, (A3 * R3 - g3 * y3 + I3 * Z3) * S3, (d3 * G3 - n3 * Q3 - h3 * r3) * S3, (o3 * Q3 - s3 * G3 + a3 * r3) * S3), true) : (console.warn("Unable to invert Mat4"), false);
    }
    setInverse(A3) {
      const g3 = A3.__data[0], I3 = A3.__data[1], C3 = A3.__data[2], i3 = A3.__data[3], e3 = A3.__data[4], t3 = A3.__data[5], B3 = A3.__data[6], o3 = A3.__data[7], s3 = A3.__data[8], a3 = A3.__data[9], l3 = A3.__data[10], n3 = A3.__data[11], d3 = A3.__data[12], h3 = A3.__data[13], c3 = A3.__data[14], r3 = A3.__data[15], G3 = g3 * t3 - I3 * e3, m3 = g3 * B3 - C3 * e3, Q3 = g3 * o3 - i3 * e3, E3 = I3 * B3 - C3 * t3, b3 = I3 * o3 - i3 * t3, Z3 = C3 * o3 - i3 * B3, y3 = s3 * h3 - a3 * d3, u3 = s3 * c3 - l3 * d3, R3 = s3 * r3 - n3 * d3, V3 = a3 * c3 - l3 * h3, F3 = a3 * r3 - n3 * h3, S3 = l3 * r3 - n3 * c3;
      let w3 = G3 * S3 - m3 * F3 + Q3 * V3 + E3 * R3 - b3 * u3 + Z3 * y3;
      if (!w3)
        throw new Error("Unable to invert Mat4");
      w3 = 1 / w3, this.set((t3 * S3 - B3 * F3 + o3 * V3) * w3, (C3 * F3 - I3 * S3 - i3 * V3) * w3, (h3 * Z3 - c3 * b3 + r3 * E3) * w3, (l3 * b3 - a3 * Z3 - n3 * E3) * w3, (B3 * R3 - e3 * S3 - o3 * u3) * w3, (g3 * S3 - C3 * R3 + i3 * u3) * w3, (c3 * Q3 - d3 * Z3 - r3 * m3) * w3, (s3 * Z3 - l3 * Q3 + n3 * m3) * w3, (e3 * F3 - t3 * R3 + o3 * y3) * w3, (I3 * R3 - g3 * F3 - i3 * y3) * w3, (d3 * b3 - h3 * Q3 + r3 * G3) * w3, (a3 * Q3 - s3 * b3 - n3 * G3) * w3, (t3 * u3 - e3 * V3 - B3 * y3) * w3, (g3 * V3 - I3 * u3 + C3 * y3) * w3, (h3 * m3 - d3 * E3 - c3 * G3) * w3, (s3 * E3 - a3 * m3 + l3 * G3) * w3);
    }
    multiply(A3) {
      const g3 = this.__data[0], I3 = this.__data[1], C3 = this.__data[2], i3 = this.__data[3], e3 = this.__data[4], t3 = this.__data[5], B3 = this.__data[6], o3 = this.__data[7], s3 = this.__data[8], a3 = this.__data[9], l3 = this.__data[10], n3 = this.__data[11], d3 = this.__data[12], c3 = this.__data[13], r3 = this.__data[14], G3 = this.__data[15], m3 = A3.asArray();
      let Q3 = m3[0], E3 = m3[1], b3 = m3[2], Z3 = m3[3];
      const y3 = new h();
      return y3.m00 = Q3 * g3 + E3 * e3 + b3 * s3 + Z3 * d3, y3.m01 = Q3 * I3 + E3 * t3 + b3 * a3 + Z3 * c3, y3.m02 = Q3 * C3 + E3 * B3 + b3 * l3 + Z3 * r3, y3.m03 = Q3 * i3 + E3 * o3 + b3 * n3 + Z3 * G3, Q3 = m3[4], E3 = m3[5], b3 = m3[6], Z3 = m3[7], y3.m10 = Q3 * g3 + E3 * e3 + b3 * s3 + Z3 * d3, y3.m11 = Q3 * I3 + E3 * t3 + b3 * a3 + Z3 * c3, y3.m12 = Q3 * C3 + E3 * B3 + b3 * l3 + Z3 * r3, y3.m13 = Q3 * i3 + E3 * o3 + b3 * n3 + Z3 * G3, Q3 = m3[8], E3 = m3[9], b3 = m3[10], Z3 = m3[11], y3.m20 = Q3 * g3 + E3 * e3 + b3 * s3 + Z3 * d3, y3.m21 = Q3 * I3 + E3 * t3 + b3 * a3 + Z3 * c3, y3.m22 = Q3 * C3 + E3 * B3 + b3 * l3 + Z3 * r3, y3.m23 = Q3 * i3 + E3 * o3 + b3 * n3 + Z3 * G3, Q3 = m3[12], E3 = m3[13], b3 = m3[14], Z3 = m3[15], y3.m30 = Q3 * g3 + E3 * e3 + b3 * s3 + Z3 * d3, y3.m31 = Q3 * I3 + E3 * t3 + b3 * a3 + Z3 * c3, y3.m32 = Q3 * C3 + E3 * B3 + b3 * l3 + Z3 * r3, y3.m33 = Q3 * i3 + E3 * o3 + b3 * n3 + Z3 * G3, y3;
    }
    multiplyInPlace(A3) {
      const g3 = this.asArray(), I3 = g3[0], C3 = g3[1], i3 = g3[2], e3 = g3[3], t3 = g3[4], B3 = g3[5], o3 = g3[6], s3 = g3[7], a3 = g3[8], l3 = g3[9], n3 = g3[10], d3 = g3[11], h3 = g3[12], c3 = g3[13], r3 = g3[14], G3 = g3[15], m3 = A3.asArray();
      let Q3 = m3[0], E3 = m3[1], b3 = m3[2], Z3 = m3[3];
      return this.m00 = Q3 * I3 + E3 * t3 + b3 * a3 + Z3 * h3, this.m01 = Q3 * C3 + E3 * B3 + b3 * l3 + Z3 * c3, this.m02 = Q3 * i3 + E3 * o3 + b3 * n3 + Z3 * r3, this.m03 = Q3 * e3 + E3 * s3 + b3 * d3 + Z3 * G3, Q3 = m3[4], E3 = m3[5], b3 = m3[6], Z3 = m3[7], this.m10 = Q3 * I3 + E3 * t3 + b3 * a3 + Z3 * h3, this.m11 = Q3 * C3 + E3 * B3 + b3 * l3 + Z3 * c3, this.m12 = Q3 * i3 + E3 * o3 + b3 * n3 + Z3 * r3, this.m13 = Q3 * e3 + E3 * s3 + b3 * d3 + Z3 * G3, Q3 = m3[8], E3 = m3[9], b3 = m3[10], Z3 = m3[11], this.m20 = Q3 * I3 + E3 * t3 + b3 * a3 + Z3 * h3, this.m21 = Q3 * C3 + E3 * B3 + b3 * l3 + Z3 * c3, this.m22 = Q3 * i3 + E3 * o3 + b3 * n3 + Z3 * r3, this.m23 = Q3 * e3 + E3 * s3 + b3 * d3 + Z3 * G3, Q3 = m3[12], E3 = m3[13], b3 = m3[14], Z3 = m3[15], this.m30 = Q3 * I3 + E3 * t3 + b3 * a3 + Z3 * h3, this.m31 = Q3 * C3 + E3 * B3 + b3 * l3 + Z3 * c3, this.m32 = Q3 * i3 + E3 * o3 + b3 * n3 + Z3 * r3, this.m33 = Q3 * e3 + E3 * s3 + b3 * d3 + Z3 * G3, this;
    }
    postMultiplyInPlace(A3) {
      const g3 = A3.asArray(), I3 = g3[0], C3 = g3[1], i3 = g3[2], e3 = g3[3], t3 = g3[4], B3 = g3[5], o3 = g3[6], s3 = g3[7], a3 = g3[8], l3 = g3[9], n3 = g3[10], d3 = g3[11], h3 = g3[12], c3 = g3[13], r3 = g3[14], G3 = g3[15], m3 = this.asArray();
      let Q3 = m3[0], E3 = m3[1], b3 = m3[2], Z3 = m3[3];
      return this.m00 = Q3 * I3 + E3 * t3 + b3 * a3 + Z3 * h3, this.m01 = Q3 * C3 + E3 * B3 + b3 * l3 + Z3 * c3, this.m02 = Q3 * i3 + E3 * o3 + b3 * n3 + Z3 * r3, this.m03 = Q3 * e3 + E3 * s3 + b3 * d3 + Z3 * G3, Q3 = m3[4], E3 = m3[5], b3 = m3[6], Z3 = m3[7], this.m10 = Q3 * I3 + E3 * t3 + b3 * a3 + Z3 * h3, this.m11 = Q3 * C3 + E3 * B3 + b3 * l3 + Z3 * c3, this.m12 = Q3 * i3 + E3 * o3 + b3 * n3 + Z3 * r3, this.m13 = Q3 * e3 + E3 * s3 + b3 * d3 + Z3 * G3, Q3 = m3[8], E3 = m3[9], b3 = m3[10], Z3 = m3[11], this.m20 = Q3 * I3 + E3 * t3 + b3 * a3 + Z3 * h3, this.m21 = Q3 * C3 + E3 * B3 + b3 * l3 + Z3 * c3, this.m22 = Q3 * i3 + E3 * o3 + b3 * n3 + Z3 * r3, this.m23 = Q3 * e3 + E3 * s3 + b3 * d3 + Z3 * G3, Q3 = m3[12], E3 = m3[13], b3 = m3[14], Z3 = m3[15], this.m30 = Q3 * I3 + E3 * t3 + b3 * a3 + Z3 * h3, this.m31 = Q3 * C3 + E3 * B3 + b3 * l3 + Z3 * c3, this.m32 = Q3 * i3 + E3 * o3 + b3 * n3 + Z3 * r3, this.m33 = Q3 * e3 + E3 * s3 + b3 * d3 + Z3 * G3, this;
    }
    translateInPlace(A3) {
      const g3 = this.__data, I3 = A3.x, C3 = A3.y, i3 = A3.z;
      return g3[12] = g3[0] * I3 + g3[4] * C3 + g3[8] * i3 + g3[12], g3[13] = g3[1] * I3 + g3[5] * C3 + g3[9] * i3 + g3[13], g3[14] = g3[2] * I3 + g3[6] * C3 + g3[10] * i3 + g3[14], g3[15] = g3[3] * I3 + g3[7] * C3 + g3[11] * i3 + g3[15], this;
    }
    setLookAt(A3, g3, I3) {
      const C3 = A3.subtract(g3), i3 = C3.length();
      if (i3 < Number.EPSILON)
        return void this.setIdentity();
      C3.scaleInPlace(1 / i3);
      const e3 = I3.cross(C3), t3 = e3.length();
      t3 > Number.EPSILON && e3.scaleInPlace(1 / t3);
      const B3 = C3.cross(e3), o3 = B3.length();
      o3 > Number.EPSILON && B3.scaleInPlace(1 / o3), this.set(e3.x, e3.y, e3.z, 0, B3.x, B3.y, B3.z, 0, C3.x, C3.y, C3.z, 0, A3.x, A3.y, A3.z, 1);
    }
    setRotation(A3, g3) {
      const I3 = A3.length();
      if (Math.abs(I3) < Number.EPSILON)
        return null;
      const C3 = A3.x / I3, i3 = A3.y / I3, e3 = A3.z / I3, t3 = Math.sin(g3), B3 = Math.cos(g3), o3 = 1 - B3, s3 = this.__data;
      return s3[0] = C3 * C3 * o3 + B3, s3[1] = i3 * C3 * o3 + e3 * t3, s3[2] = e3 * C3 * o3 - i3 * t3, s3[3] = 0, s3[4] = C3 * i3 * o3 - e3 * t3, s3[5] = i3 * i3 * o3 + B3, s3[6] = e3 * i3 * o3 + C3 * t3, s3[7] = 0, s3[8] = C3 * e3 * o3 + i3 * t3, s3[9] = i3 * e3 * o3 - C3 * t3, s3[10] = e3 * e3 * o3 + B3, s3[11] = 0, s3[12] = 0, s3[13] = 0, s3[14] = 0, s3[15] = 1, this;
    }
    setXRotation(A3) {
      const g3 = Math.sin(A3), I3 = Math.cos(A3), C3 = this.__data;
      return C3[0] = 1, C3[1] = 0, C3[2] = 0, C3[3] = 0, C3[4] = 0, C3[5] = I3, C3[6] = g3, C3[7] = 0, C3[8] = 0, C3[9] = -g3, C3[10] = I3, C3[11] = 0, C3[12] = 0, C3[13] = 0, C3[14] = 0, C3[15] = 1, this;
    }
    setYRotation(A3) {
      const g3 = Math.sin(A3), I3 = Math.cos(A3), C3 = this.__data;
      return C3[0] = I3, C3[1] = 0, C3[2] = -g3, C3[3] = 0, C3[4] = 0, C3[5] = 1, C3[6] = 0, C3[7] = 0, C3[8] = g3, C3[9] = 0, C3[10] = I3, C3[11] = 0, C3[12] = 0, C3[13] = 0, C3[14] = 0, C3[15] = 1, this;
    }
    setZRotation(A3) {
      const g3 = Math.sin(A3), I3 = Math.cos(A3), C3 = this.__data;
      return C3[0] = I3, C3[1] = g3, C3[2] = 0, C3[3] = 0, C3[4] = -g3, C3[5] = I3, C3[6] = 0, C3[7] = 0, C3[8] = 0, C3[9] = 0, C3[10] = 1, C3[11] = 0, C3[12] = 0, C3[13] = 0, C3[14] = 0, C3[15] = 1, this;
    }
    transformVec4(A3) {
      const g3 = this.__data, I3 = A3.x, C3 = A3.y, i3 = A3.z, e3 = A3.t;
      return new s(g3[0] * I3 + g3[4] * C3 + g3[8] * i3 + g3[12] * e3, g3[1] * I3 + g3[5] * C3 + g3[9] * i3 + g3[13] * e3, g3[2] * I3 + g3[6] * C3 + g3[10] * i3 + g3[14] * e3, g3[3] * I3 + g3[7] * C3 + g3[11] * i3 + g3[15] * e3);
    }
    transformVec3(A3) {
      const g3 = this.__data, I3 = A3.x, C3 = A3.y, i3 = A3.z;
      return new o(g3[0] * I3 + g3[4] * C3 + g3[8] * i3 + g3[12], g3[1] * I3 + g3[5] * C3 + g3[9] * i3 + g3[13], g3[2] * I3 + g3[6] * C3 + g3[10] * i3 + g3[14]);
    }
    rotateVec3(A3) {
      const g3 = this.__data, I3 = A3.x, C3 = A3.y, i3 = A3.z;
      return new o(g3[0] * I3 + g3[4] * C3 + g3[8] * i3, g3[1] * I3 + g3[5] * C3 + g3[9] * i3, g3[2] * I3 + g3[6] * C3 + g3[10] * i3);
    }
    setPerspectiveMatrix(A3, g3, I3, C3) {
      const i3 = Math.tan(0.5 * Math.PI - 0.5 * A3), e3 = 1 / (I3 - C3);
      this.set(i3 / g3, 0, 0, 0, 0, i3, 0, 0, 0, 0, (I3 + C3) * e3, -1, 0, 0, I3 * C3 * e3 * 2, 0);
    }
    setOrthographicMatrix(A3, g3, I3, C3, i3, e3) {
      const t3 = 1 / (A3 - g3), B3 = 1 / (I3 - C3), o3 = 1 / (i3 - e3);
      this.set(-2 * t3, 0, 0, 0, 0, -2 * B3, 0, 0, 0, 0, 2 * o3, 0, (A3 + g3) * t3, (C3 + I3) * B3, (e3 + i3) * o3, 1);
    }
    setScale(A3, g3, I3) {
      A3 instanceof o ? this.set(A3.x, 0, 0, 0, 0, A3.y, 0, 0, 0, 0, A3.z, 0, 0, 0, 0, 1) : this.set(A3, 0, 0, 0, 0, g3, 0, 0, 0, 0, I3, 0, 0, 0, 0, 1);
    }
    setFromMat3x4Array(A3) {
      this.set(A3[0], A3[1], A3[2], 0, A3[3], A3[4], A3[5], 0, A3[6], A3[7], A3[8], 0, A3[9], A3[10], A3[11], 1);
    }
    clone() {
      return new h(this.__data[0], this.__data[1], this.__data[2], this.__data[3], this.__data[4], this.__data[5], this.__data[6], this.__data[7], this.__data[8], this.__data[9], this.__data[10], this.__data[11], this.__data[12], this.__data[13], this.__data[14], this.__data[15]);
    }
    toString() {
      return t.stringifyJSONWithFixedPrecision(this.toJSON());
    }
    toJSON() {
      return this.__data;
    }
    fromJSON(A3) {
      this.__data = new Float32Array(A3);
    }
    readBinary(A3) {
      this.__data = A3.loadFloat32Array(16);
    }
    asArray() {
      return this.__data;
    }
  };
  var c = class {
    constructor(A3 = 0, g3 = 0, I3 = 0, C3 = 1) {
      if (A3 instanceof Float32Array)
        this.__data = A3;
      else if (A3 instanceof ArrayBuffer) {
        console.warn("deprecated, please use new Vec4(new Float32Array(buffer, byteOffset, 4))");
        const I4 = A3, C4 = g3;
        this.__data = new Float32Array(I4, C4, 4);
      } else
        this.__data = new Float32Array(4), typeof A3 == "object" ? (this.__data[0] = 0, this.__data[1] = 0, this.__data[2] = 0, this.__data[3] = 1, this.fromJSON(A3)) : (this.__data[0] = A3, this.__data[1] = g3, this.__data[2] = I3, this.__data[3] = C3);
    }
    get x() {
      return this.__data[0];
    }
    set x(A3) {
      this.__data[0] = A3;
    }
    get y() {
      return this.__data[1];
    }
    set y(A3) {
      this.__data[1] = A3;
    }
    get z() {
      return this.__data[2];
    }
    set z(A3) {
      this.__data[2] = A3;
    }
    get w() {
      return this.__data[3];
    }
    set w(A3) {
      this.__data[3] = A3;
    }
    set(A3, g3, I3, C3) {
      this.__data[0] = A3, this.__data[1] = g3, this.__data[2] = I3, this.__data[3] = C3;
    }
    setDataArray(A3) {
      this.__data = A3;
    }
    setFromOther(A3) {
      this.__data[0] = A3.x, this.__data[1] = A3.y, this.__data[2] = A3.z, this.__data[3] = A3.w;
    }
    setFromEulerAngles(A3) {
      const g3 = new o();
      switch (A3.order) {
        case 0:
          g3.set(A3.x, -A3.y, A3.z);
          break;
        case 1:
          g3.set(A3.y, -A3.z, A3.x);
          break;
        case 2:
          g3.set(A3.z, -A3.x, A3.y);
          break;
        case 3:
          g3.set(A3.x, A3.z, A3.y);
          break;
        case 4:
          g3.set(A3.z, A3.y, A3.x);
          break;
        case 5:
          g3.set(A3.y, A3.x, A3.z);
          break;
        default:
          throw new Error(`Invalid EulerAngles order: ${A3.order}`);
      }
      const I3 = 0.5 * g3.x, C3 = 0.5 * g3.y, i3 = 0.5 * g3.z, e3 = Math.cos(I3), t3 = Math.cos(C3), B3 = Math.cos(i3), s3 = Math.sin(I3), a3 = Math.sin(C3), l3 = Math.sin(i3), n3 = e3 * B3, d3 = e3 * l3, h3 = s3 * B3, c3 = s3 * l3, r3 = t3 * h3 - a3 * d3, G3 = t3 * c3 + a3 * n3, m3 = t3 * d3 - a3 * h3;
      switch (this.w = t3 * n3 + a3 * c3, A3.order) {
        case 0:
          this.x = r3, this.y = -G3, this.z = m3;
          break;
        case 1:
          this.x = m3, this.y = r3, this.z = -G3;
          break;
        case 2:
          this.x = -G3, this.y = m3, this.z = r3;
          break;
        case 3:
          this.x = r3, this.y = m3, this.z = G3;
          break;
        case 4:
          this.x = m3, this.y = G3, this.z = r3;
          break;
        case 5:
          this.x = G3, this.y = r3, this.z = m3;
          break;
        default:
          throw new Error(`Invalid EulerAngles order: ${A3.order}`);
      }
    }
    toEulerAngles(A3) {
      const g3 = new o();
      switch (A3) {
        case 0:
          g3.set(this.z, this.x, this.y);
          break;
        case 1:
          g3.set(this.x, this.y, this.z);
          break;
        case 2:
          g3.set(this.y, this.z, this.x);
          break;
        case 3:
          g3.set(this.y, -this.x, this.z);
          break;
        case 4:
          g3.set(this.x, -this.z, this.y);
          break;
        case 5:
          g3.set(this.z, -this.y, this.x);
          break;
        default:
          throw new Error("Invalid rotation order:" + A3);
      }
      const I3 = new o(), C3 = g3.x * g3.y + g3.z * this.w;
      if (C3 > 0.49999)
        I3.y = 2 * Math.atan2(g3.x, this.w), I3.z = 0.5 * Math.PI, I3.x = 0;
      else if (C3 < -0.49999)
        I3.y = -2 * Math.atan2(g3.x, this.w), I3.z = -0.5 * Math.PI, I3.x = 0;
      else {
        const A4 = g3.x * g3.x, i3 = g3.y * g3.y, e3 = g3.z * g3.z;
        I3.y = Math.atan2(2 * g3.y * this.w - 2 * g3.x * g3.z, 1 - 2 * i3 - 2 * e3), I3.z = Math.asin(2 * C3), I3.x = Math.atan2(2 * g3.x * this.w - 2 * g3.y * g3.z, 1 - 2 * A4 - 2 * e3);
      }
      switch (A3) {
        case 0:
          return new n(I3.y, I3.z, I3.x, A3);
        case 1:
          return new n(I3.x, I3.y, I3.z, A3);
        case 2:
          return new n(I3.z, I3.x, I3.y, A3);
        case 3:
          return new n(-I3.y, I3.x, I3.z, A3);
        case 4:
          return new n(I3.x, I3.z, -I3.y, A3);
        case 5:
          return new n(I3.z, -I3.y, I3.x, A3);
      }
    }
    setFromAxisAndAngle(A3, g3) {
      const I3 = g3 / 2, C3 = A3.normalize().scale(Math.sin(I3));
      this.set(C3.x, C3.y, C3.z, Math.cos(I3));
    }
    setFromDirectionAndUpvector(A3, g3) {
      const I3 = new d();
      I3.setFromDirectionAndUpvector(A3, g3), this.setFromMat3(I3);
    }
    setFrom2Vectors(A3, g3) {
      const I3 = A3.cross(g3), C3 = A3.dot(g3), i3 = Math.sqrt(2 * (1 + C3));
      this.set(I3.x / i3, I3.y / i3, I3.z / i3, i3 / 2), this.normalizeInPlace();
    }
    setFromMat3(A3) {
      const g3 = A3.asArray(), I3 = g3[0] + g3[4] + g3[8];
      let C3;
      if (I3 > 0)
        C3 = Math.sqrt(I3 + 1), this.__data[3] = 0.5 * C3, C3 = 0.5 / C3, this.__data[0] = (g3[5] - g3[7]) * C3, this.__data[1] = (g3[6] - g3[2]) * C3, this.__data[2] = (g3[1] - g3[3]) * C3;
      else {
        let A4 = 0;
        g3[4] > g3[0] && (A4 = 1), g3[8] > g3[3 * A4 + A4] && (A4 = 2);
        const I4 = (A4 + 1) % 3, i3 = (A4 + 2) % 3;
        C3 = Math.sqrt(g3[3 * A4 + A4] - g3[3 * I4 + I4] - g3[3 * i3 + i3] + 1), this.__data[A4] = 0.5 * C3, C3 = 0.5 / C3, this.__data[3] = (g3[3 * I4 + i3] - g3[3 * i3 + I4]) * C3, this.__data[I4] = (g3[3 * I4 + A4] + g3[3 * A4 + I4]) * C3, this.__data[i3] = (g3[3 * i3 + A4] + g3[3 * A4 + i3]) * C3;
      }
      this.normalizeInPlace();
    }
    setFromMat4(A3) {
      const g3 = A3.asArray(), I3 = g3[0] + g3[5] + g3[10];
      let C3;
      if (I3 > 0)
        C3 = Math.sqrt(I3 + 1), this.__data[3] = 0.5 * C3, C3 = 0.5 / C3, this.__data[0] = (g3[6] - g3[9]) * C3, this.__data[1] = (g3[8] - g3[2]) * C3, this.__data[2] = (g3[1] - g3[4]) * C3;
      else {
        let A4 = 0;
        g3[5] > g3[0] && (A4 = 1), g3[10] > g3[4 * A4 + A4] && (A4 = 2);
        const I4 = (A4 + 1) % 3, i3 = (A4 + 2) % 3;
        C3 = Math.sqrt(g3[4 * A4 + A4] - g3[4 * I4 + I4] - g3[4 * i3 + i3] + 1), this.__data[A4] = 0.5 * C3, C3 = 0.5 / C3, this.__data[3] = (g3[4 * I4 + i3] - g3[4 * i3 + I4]) * C3, this.__data[I4] = (g3[4 * I4 + A4] + g3[4 * A4 + I4]) * C3, this.__data[i3] = (g3[4 * i3 + A4] + g3[4 * A4 + i3]) * C3;
      }
      this.normalizeInPlace();
    }
    isIdentity() {
      return this.getAngle() < Number.EPSILON;
    }
    getAngle() {
      return 2 * Math.acos(this.w);
    }
    isEqual(A3) {
      return this.x == A3.x && this.y == A3.y && this.z == A3.z && this.w == A3.w;
    }
    notEquals(A3) {
      return this.x != A3.x && this.y != A3.y && this.z != A3.z && this.w != A3.w;
    }
    approxEqual(A3, g3 = Number.EPSILON) {
      return Math.abs(this.x - A3.x) < g3 && Math.abs(this.y - A3.y) < g3 && Math.abs(this.z - A3.z) < g3 && Math.abs(this.w - A3.w) < g3;
    }
    add(A3) {
      return new c(this.x + A3.x, this.y + A3.y, this.z + A3.z, this.w + A3.w);
    }
    addInPlace(A3) {
      this.x += A3.x, this.y += A3.y, this.z += A3.z, this.w += A3.w;
    }
    subtract(A3) {
      return new c(this.x - A3.x, this.y - A3.y, this.z - A3.z, this.w - A3.w);
    }
    scale(A3) {
      return new c(this.x * A3, this.y * A3, this.z * A3, this.w * A3);
    }
    scaleInPlace(A3) {
      this.x *= A3, this.y *= A3, this.z *= A3, this.w *= A3;
    }
    length() {
      const A3 = this.__data[0], g3 = this.__data[1], I3 = this.__data[2], C3 = this.__data[3];
      return Math.sqrt(A3 * A3 + g3 * g3 + I3 * I3 + C3 * C3);
    }
    lengthSquared() {
      const A3 = this.__data[0], g3 = this.__data[1], I3 = this.__data[2], C3 = this.__data[3];
      return A3 * A3 + g3 * g3 + I3 * I3 + C3 * C3;
    }
    normalize() {
      const A3 = this.__data[0], g3 = this.__data[1], I3 = this.__data[2], C3 = this.__data[3];
      let i3 = A3 * A3 + g3 * g3 + I3 * I3 + C3 * C3;
      return i3 < Number.EPSILON ? new c() : (i3 = 1 / Math.sqrt(i3), new c(A3 * i3, g3 * i3, I3 * i3, C3 * i3));
    }
    normalizeInPlace() {
      const A3 = this.__data[0], g3 = this.__data[1], I3 = this.__data[2], C3 = this.__data[3];
      let i3 = A3 * A3 + g3 * g3 + I3 * I3 + C3 * C3;
      i3 < Number.EPSILON || (i3 = 1 / Math.sqrt(i3), this.set(A3 * i3, g3 * i3, I3 * i3, C3 * i3));
    }
    dot(A3) {
      return this.x * A3.x + this.y * A3.y + this.z * A3.z + this.w * A3.w;
    }
    cross(A3) {
      const g3 = this.x, I3 = this.y, C3 = this.z, i3 = this.w, e3 = A3.x, t3 = A3.y, B3 = A3.z, o3 = A3.w;
      return new c(I3 * B3 - C3 * t3, C3 * o3 - i3 * B3, i3 * e3 - g3 * o3, g3 * t3 - I3 * e3);
    }
    conjugate() {
      return new c(-this.x, -this.y, -this.z, this.w);
    }
    inverse() {
      return this.conjugate();
    }
    alignWith(A3) {
      this.dot(A3) < 0 && this.set(-this.x, -this.y, -this.z, -this.w);
    }
    multiply(A3) {
      const g3 = this.__data[0], I3 = this.__data[1], C3 = this.__data[2], i3 = this.__data[3], e3 = A3.__data[0], t3 = A3.__data[1], B3 = A3.__data[2], o3 = A3.__data[3];
      return new c(g3 * o3 + i3 * e3 + I3 * B3 - C3 * t3, I3 * o3 + i3 * t3 + C3 * e3 - g3 * B3, C3 * o3 + i3 * B3 + g3 * t3 - I3 * e3, i3 * o3 - g3 * e3 - I3 * t3 - C3 * B3);
    }
    multiplyInPlace(A3) {
      const g3 = this.__data[0], I3 = this.__data[1], C3 = this.__data[2], i3 = this.__data[3], e3 = A3.__data[0], t3 = A3.__data[1], B3 = A3.__data[2], o3 = A3.__data[3];
      this.set(g3 * o3 + i3 * e3 + I3 * B3 - C3 * t3, I3 * o3 + i3 * t3 + C3 * e3 - g3 * B3, C3 * o3 + i3 * B3 + g3 * t3 - I3 * e3, i3 * o3 - g3 * e3 - I3 * t3 - C3 * B3);
    }
    rotateVec3(A3) {
      const g3 = new c(A3.x, A3.y, A3.z, 0), I3 = this.multiply(g3).multiply(this.conjugate());
      return new o(I3.x, I3.y, I3.z);
    }
    rotateX(A3) {
      A3 *= 0.5;
      const g3 = this.x, I3 = this.y, C3 = this.z, i3 = this.w, e3 = Math.sin(A3), t3 = Math.cos(A3);
      this.x = g3 * t3 + i3 * e3, this.y = I3 * t3 + C3 * e3, this.z = C3 * t3 - I3 * e3, this.w = i3 * t3 - g3 * e3;
    }
    rotateY(A3) {
      A3 *= 0.5;
      const g3 = this.x, I3 = this.y, C3 = this.z, i3 = this.w, e3 = Math.sin(A3), t3 = Math.cos(A3);
      this.x = g3 * t3 - C3 * e3, this.y = I3 * t3 + i3 * e3, this.z = C3 * t3 + g3 * e3, this.w = i3 * t3 - I3 * e3;
    }
    rotateZ(A3) {
      A3 *= 0.5;
      const g3 = this.x, I3 = this.y, C3 = this.z, i3 = this.w, e3 = Math.sin(A3), t3 = Math.cos(A3);
      this.x = g3 * t3 + I3 * e3, this.y = I3 * t3 - g3 * e3, this.z = C3 * t3 + i3 * e3, this.w = i3 * t3 - C3 * e3;
    }
    toMat3() {
      const A3 = this.x, g3 = this.y, I3 = this.z, C3 = this.w, i3 = A3 + A3, e3 = g3 + g3, t3 = I3 + I3, B3 = A3 * i3, o3 = g3 * i3, s3 = g3 * e3, a3 = I3 * i3, l3 = I3 * e3, n3 = I3 * t3, h3 = C3 * i3, c3 = C3 * e3, r3 = C3 * t3, G3 = new d();
      return G3.m00 = 1 - s3 - n3, G3.m10 = o3 - r3, G3.m20 = a3 + c3, G3.m01 = o3 + r3, G3.m11 = 1 - B3 - n3, G3.m21 = l3 - h3, G3.m02 = a3 - c3, G3.m12 = l3 + h3, G3.m22 = 1 - B3 - s3, G3;
    }
    getXaxis() {
      const A3 = this.x * this.y, g3 = this.x * this.z, I3 = this.y * this.y, C3 = this.y * this.w, i3 = this.z * this.z, e3 = this.z * this.w;
      return new o(1 - 2 * (i3 + I3), 2 * (A3 + e3), 2 * (g3 - C3));
    }
    getYaxis() {
      const A3 = this.x * this.x, g3 = this.x * this.y, I3 = this.x * this.w, C3 = this.y * this.z, i3 = this.z * this.z, e3 = this.z * this.w;
      return new o(2 * (g3 - e3), 1 - 2 * (i3 + A3), 2 * (C3 + I3));
    }
    getZaxis() {
      const A3 = this.x * this.x, g3 = this.x * this.z, I3 = this.x * this.w, C3 = this.y * this.y, i3 = this.y * this.z, e3 = this.y * this.w;
      return new o(2 * (e3 + g3), 2 * (i3 - I3), 1 - 2 * (C3 + A3));
    }
    mirror(A3) {
      switch (A3) {
        case 0:
        case 0:
        default:
          return new c(this.z, this.w, this.x, this.y);
        case 1:
          return new c(-this.w, this.z, this.y, -this.x);
        case 2:
          return new c(this.x, this.y, this.z, -this.w);
      }
    }
    toMat4() {
      const A3 = this.x, g3 = this.y, I3 = this.z, C3 = this.w, i3 = A3 + A3, e3 = g3 + g3, t3 = I3 + I3, B3 = A3 * i3, o3 = g3 * i3, s3 = g3 * e3, a3 = I3 * i3, l3 = I3 * e3, n3 = I3 * t3, d3 = C3 * i3, c3 = C3 * e3, r3 = C3 * t3, G3 = new h();
      return G3.m00 = 1 - s3 - n3, G3.m10 = o3 - r3, G3.m20 = a3 + c3, G3.m01 = o3 + r3, G3.m11 = 1 - B3 - n3, G3.m21 = l3 - d3, G3.m02 = a3 - c3, G3.m12 = l3 + d3, G3.m22 = 1 - B3 - s3, G3;
    }
    lerp(A3, g3) {
      const I3 = new c(this.x + g3 * (A3.x - this.x), this.y + g3 * (A3.y - this.y), this.z + g3 * (A3.z - this.z), this.w + g3 * (A3.w - this.w));
      return I3.normalizeInPlace(), I3;
    }
    slerp(A3, g3) {
      const I3 = this.dot(A3);
      if (I3 > 0.999)
        return this;
      const C3 = Math.acos(I3), i3 = Math.sin(C3), e3 = Math.sin(g3 * C3), t3 = Math.sin((1 - g3) * C3) / i3, B3 = e3 / i3, o3 = new c(t3 * this.x + B3 * A3.x, t3 * this.y + B3 * A3.y, t3 * this.z + B3 * A3.z, t3 * this.w + B3 * A3.w);
      return o3.normalizeInPlace(), o3;
    }
    clone() {
      return new c(this.__data[0], this.__data[1], this.__data[2], this.__data[3]);
    }
    asArray() {
      return this.__data;
    }
    toString() {
      return t.stringifyJSONWithFixedPrecision(this.toJSON());
    }
    toJSON() {
      return {x: this.x, y: this.y, z: this.z, w: this.w};
    }
    fromJSON(A3) {
      this.__data[0] = A3.x, this.__data[1] = A3.y, this.__data[2] = A3.z, this.__data[3] = A3.w, this.normalizeInPlace();
    }
    readBinary(A3) {
      this.x = A3.loadFloat32(), this.y = A3.loadFloat32(), this.z = A3.loadFloat32(), this.w = A3.loadFloat32();
    }
  };
  var r = class {
    static radToDeg(A3) {
      return A3 / (Math.PI / 180);
    }
    static degToRad(A3) {
      return A3 * (Math.PI / 180);
    }
    static isNumeric(A3) {
      return !isNaN(parseFloat(A3)) && isFinite(A3);
    }
    static randomInt(A3, g3) {
      return A3 = Math.ceil(A3), g3 = Math.floor(g3), Math.floor(Math.random() * (g3 - A3)) + A3;
    }
    static lerp(A3, g3, I3) {
      return A3 + I3 * (g3 - A3);
    }
    static clamp(A3, g3, I3) {
      return Math.min(Math.max(A3, g3), I3);
    }
    static nearestPow2(A3) {
      return Math.pow(2, Math.round(Math.log(A3) / Math.log(2)));
    }
    static nearestPow10(A3) {
      return Math.pow(10, Math.round(Math.log10(A3) / Math.log10(10)));
    }
    static nextPow2(A3) {
      if (this.fract(Math.log2(A3)) == 0)
        return A3;
      let g3 = 0;
      for (; A3 > 0; )
        g3++, A3 >>= 1;
      return 1 << g3;
    }
    static fract(A3) {
      return A3 == 0 ? 0 : A3 < 0 ? A3 > -1 ? -A3 : -A3 % Math.floor(-A3) : A3 < 1 ? A3 : A3 % Math.floor(A3);
    }
    static remap(A3, g3, I3, C3, i3) {
      return C3 + (A3 - g3) / (I3 - g3) * (i3 - C3);
    }
    static smoothStep(A3, g3, I3) {
      const C3 = this.clamp((I3 - A3) / (g3 - A3), 0, 1);
      return C3 * C3 * (3 - 2 * C3);
    }
    static linStep(A3, g3, I3) {
      return this.clamp((I3 - A3) / (g3 - A3), 0, 1);
    }
    static decode16BitFloatFrom2xUInt8(A3) {
      const g3 = A3[0], I3 = (120 & g3) >> 3;
      let C3 = I3 == 0 ? 0 : 2048;
      const i3 = C3 + ((7 & g3) << 8) + A3[1];
      C3 = I3 == 0 ? 1 : 0;
      return (128 & g3 ? 1 : -1) * i3 * Math.pow(2, I3 + C3 - 16);
    }
    static encode16BitFloatInto2xUInt8(A3) {
      const g3 = new Uint8Array(2), I3 = A3 >= 0 ? 128 : 0;
      A3 = Math.abs(A3);
      let C3, i3 = 15, e3 = 1024;
      for (let g4 = 15; g4 > 0; g4--)
        A3 < e3 && (e3 /= 2, i3--);
      C3 = i3 == 0 ? A3 / e3 / 2 : (A3 - e3) / e3;
      const t3 = Math.round(2048 * C3), B3 = t3 / 256, o3 = t3 - 256 * B3;
      return g3[0] = I3 + 8 * i3 + B3, g3[1] = o3, A3 >= 2048 && (g3[0] = 255), g3;
    }
    static encode16BitFloat(A3) {
      const g3 = new Float32Array(1);
      g3[0] = A3;
      return ((A4) => {
        let g4 = A4 >> 16 & 32768, I3 = A4 >> 12 & 2047;
        const C3 = A4 >> 23 & 255;
        return C3 < 103 ? g4 : C3 > 142 ? (g4 |= 31744, g4 |= (C3 == 255 ? 0 : 1) && 8388607 & A4, g4) : C3 < 113 ? (I3 |= 2048, g4 |= (I3 >> 114 - C3) + (I3 >> 113 - C3 & 1), g4) : (g4 |= C3 - 112 << 10 | I3 >> 1, g4 += 1 & I3, g4);
      })(new Int32Array(g3.buffer)[0]);
    }
    static decode16BitFloat(A3) {
      const g3 = (32768 & A3) >> 15, I3 = (31744 & A3) >> 10, C3 = 1023 & A3;
      return I3 == 0 ? (g3 ? -1 : 1) * Math.pow(2, -14) * (C3 / Math.pow(2, 10)) : I3 == 31 ? C3 ? NaN : 1 / 0 * (g3 ? -1 : 1) : (g3 ? -1 : 1) * Math.pow(2, I3 - 15) * (1 + C3 / Math.pow(2, 10));
    }
    static convertFloat32ArrayToUInt16Array(A3) {
      const g3 = new Uint16Array(A3.length), I3 = new Int32Array(A3.buffer), C3 = (A4) => {
        let g4 = A4 >> 16 & 32768, I4 = A4 >> 12 & 2047;
        const C4 = A4 >> 23 & 255;
        return C4 < 103 ? g4 : C4 > 142 ? (g4 |= 31744, g4 |= (C4 == 255 ? 0 : 1) && 8388607 & A4, g4) : C4 < 113 ? (I4 |= 2048, g4 |= (I4 >> 114 - C4) + (I4 >> 113 - C4 & 1), g4) : (g4 |= C4 - 112 << 10 | I4 >> 1, g4 += 1 & I4, g4);
      };
      for (let i3 = 0; i3 < A3.length; i3++)
        g3[i3] = C3(I3[i3]);
      return g3;
    }
  };
  var G = class {
    constructor(A3, g3) {
      this.start = A3 instanceof o ? A3 : new o(), this.dir = g3 instanceof o ? g3 : new o();
    }
    closestPoint(A3) {
      const g3 = A3.subtract(this.start).dot(this.dir);
      if (g3 < Number.EPSILON)
        return 0;
      const I3 = this.dir.dot(this.dir);
      return I3 < Number.EPSILON ? 0 : g3 / I3;
    }
    closestPointOnLineSegment(A3, g3) {
      const I3 = this.dir, C3 = g3.subtract(A3), i3 = C3.length();
      C3.normalizeInPlace();
      const e3 = this.start.subtract(A3), t3 = I3.dot(I3), B3 = I3.dot(C3), o3 = C3.dot(C3), s3 = I3.dot(e3), a3 = C3.dot(e3);
      if (t3 == 0 && o3 == 0)
        return [this.start.distanceTo(A3), 0];
      if (t3 == 0)
        return [0, 0];
      if (o3 == 0)
        return [this.closestPoint(A3), 0];
      const l3 = t3 * o3 - B3 * B3;
      let n3, d3;
      return l3 < 1e-3 ? (n3 = 0, d3 = B3 > o3 ? s3 / B3 : a3 / o3) : (n3 = (B3 * a3 - o3 * s3) / l3, d3 = (t3 * a3 - B3 * s3) / l3), [n3, r.clamp(d3 / i3, 0, 1)];
    }
    pointAtDist(A3) {
      return this.start.add(this.dir.scale(A3));
    }
    intersectRayVector(A3) {
      const g3 = this.dir, I3 = A3.dir, C3 = this.start.subtract(A3.start), i3 = g3.dot(g3), e3 = g3.dot(I3), t3 = I3.dot(I3), B3 = g3.dot(C3), o3 = I3.dot(C3);
      if (i3 == 0 && t3 == 0)
        return this.start.distanceTo(A3.start);
      if (i3 == 0)
        return A3.closestPoint(this.start);
      if (t3 == 0)
        return this.closestPoint(A3.start);
      const s3 = i3 * t3 - e3 * e3;
      let a3, l3;
      return s3 < 1e-3 ? (a3 = 0, l3 = e3 > t3 ? B3 / e3 : o3 / t3) : (a3 = (e3 * o3 - t3 * B3) / s3, l3 = (i3 * o3 - e3 * B3) / s3), [a3, l3];
    }
    intersectRayPlane(A3) {
      const g3 = this.start.subtract(A3.start), I3 = A3.dir.dot(this.dir), C3 = -A3.dir.dot(g3);
      if (Math.abs(I3) < Number.PRECISION)
        return -1;
      const i3 = C3 / I3;
      return i3 < -Number.PRECISION ? -1 : i3;
    }
    intersectRayBox3(A3, g3 = 0) {
      const I3 = new o(1 / this.dir.x, 1 / this.dir.y, 1 / this.dir.z), C3 = [];
      C3[0] = I3.x < 0 ? 1 : 0, C3[1] = I3.y < 0 ? 1 : 0, C3[2] = I3.z < 0 ? 1 : 0;
      const i3 = [];
      if (g3 > 0) {
        const I4 = A3.diagonal();
        I4.normalizeInPlace(), I4.scaleInPlace(g3), i3[0] = A3.p0.subtract(I4), i3[1] = A3.p1.add(I4);
      } else
        i3[0] = A3.p0, i3[1] = A3.p1;
      let e3 = (i3[C3[0]].x - this.start.x) * I3.x, t3 = (i3[1 - C3[0]].x - this.start.x) * I3.x;
      const B3 = (i3[C3[1]].y - this.start.y) * I3.y, s3 = (i3[1 - C3[1]].y - this.start.y) * I3.y;
      if (e3 > s3 || B3 > t3)
        return false;
      B3 > e3 && (e3 = B3), s3 < t3 && (t3 = s3);
      const a3 = (i3[C3[2]].z - this.start.z) * I3.z, l3 = (i3[1 - C3[2]].z - this.start.z) * I3.z;
      return !(e3 > l3 || a3 > t3) && (a3 > e3 && (e3 = a3), l3 < t3 && (t3 = l3), true);
    }
    clone() {
      return new G(this.start.clone(), this.dir.clone());
    }
    toJSON() {
      return {start: this.start.toJSON(), dir: this.dir.toJSON()};
    }
    fromJSON(A3) {
      this.start.fromJSON(A3.start), this.dir.fromJSON(A3.dir);
    }
    toString() {
      return t.stringifyJSONWithFixedPrecision(this.toJSON());
    }
  };
  var m = class {
    constructor(A3, g3, I3) {
      if (A3 instanceof Float32Array)
        this.setFromFloat32Array(A3);
      else {
        if (A3 instanceof o)
          this.tr = A3;
        else {
          if (A3 instanceof c && g3 == null && I3 == null)
            return this.tr = new o(), this.ori = A3, void (this.sc = new o(1, 1, 1));
          this.tr = new o();
        }
        this.ori = g3 instanceof c ? g3 : new c(), this.sc = I3 instanceof o ? I3 : new o(1, 1, 1);
      }
    }
    set(A3, g3, I3) {
      this.tr = A3, this.ori = g3, I3 instanceof o && (this.sc = I3);
    }
    setFromOther(A3) {
      this.tr = A3.tr, this.ori = A3.ori, this.sc = A3.sc;
    }
    isIdentity() {
      return this.tr.isNull() && this.ori.isIdentity() && this.sc.is111();
    }
    isEqual(A3) {
      return this.tr.isEqual(A3.tr) && this.ori.isEqual(A3.ori) && this.sc.isEqual(A3.sc);
    }
    approxEqual(A3, g3 = Number.EPSILON) {
      return (!A3.tr || this.tr.approxEqual(A3.tr, g3)) && (!A3.ori || this.ori.approxEqual(A3.ori, g3)) && (!A3.sc || this.sc.approxEqual(A3.sc, g3));
    }
    setLookAt(A3, g3, I3) {
      const C3 = A3.subtract(g3);
      if (C3.length() < Number.EPSILON)
        throw new Error("Invalid dir");
      this.ori.setFromDirectionAndUpvector(C3, I3), this.tr = A3;
    }
    multiply(A3) {
      let g3 = this.sc;
      if (Math.abs(this.sc.y - this.sc.x) > 1e-3 || Math.abs(this.sc.z - this.sc.x) > 1e-3 || Math.abs(this.sc.z - this.sc.y) > 1e-3) {
        const A4 = this.ori.toMat4(), I3 = new h(this.sc.x, 0, 0, 0, 0, this.sc.y, 0, 0, 0, 0, this.sc.z, 0, 0, 0, 0, 1).multiply(A4);
        g3 = new o(I3.xAxis.length(), I3.yAxis.length(), I3.zAxis.length());
      }
      return new m(this.tr.add(this.ori.rotateVec3(this.sc.multiply(A3.tr))), this.ori.multiply(A3.ori), g3.multiply(A3.sc));
    }
    inverse() {
      const A3 = new m();
      if (A3.ori = this.ori.inverse(), Math.abs(this.sc.y - this.sc.x) > 1e-3 || Math.abs(this.sc.z - this.sc.x) > 1e-3 || Math.abs(this.sc.z - this.sc.y) > 1e-3) {
        const g3 = A3.ori.toMat4(), I3 = new h(this.sc.x, 0, 0, 0, 0, this.sc.y, 0, 0, 0, 0, this.sc.z, 0, 0, 0, 0, 1).multiply(g3);
        A3.sc = new o(1 / I3.xAxis.length(), 1 / I3.yAxis.length(), 1 / I3.zAxis.length());
      } else
        A3.sc = this.sc.inverse();
      return A3.tr = A3.ori.rotateVec3(this.tr.negate().multiply(A3.sc)), A3;
    }
    transformVec3(A3) {
      return this.tr.add(this.ori.rotateVec3(this.sc.multiply(A3)));
    }
    toMat4() {
      const A3 = new h(this.sc.x, 0, 0, 0, 0, this.sc.y, 0, 0, 0, 0, this.sc.z, 0, 0, 0, 0, 1), g3 = this.ori.toMat4(), I3 = new h();
      return I3.translation = this.tr, I3.multiply(g3).multiply(A3);
    }
    setFromMat4(A3) {
      this.tr = A3.translation, this.ori.setFromMat4(A3);
    }
    setFromFloat32Array(A3) {
      if (A3.length == 7)
        return this.tr = new o(new Float32Array(A3.buffer, A3.byteOffset, 3)), this.ori = new c(new Float32Array(A3.buffer, A3.byteOffset + 12, 4)), void (this.sc = new o(1, 1, 1));
      if (A3.length != 8) {
        if (A3.length == 10)
          return this.tr = new o(new Float32Array(A3.buffer, A3.byteOffset, 3)), this.ori = new c(new Float32Array(A3.buffer, A3.byteOffset + 12, 4)), void (this.sc = new o(new Float32Array(A3.buffer, A3.byteOffset + 21, 3)));
        console.warn("unitialized: float32array.length == ", A3.length);
      } else {
        this.tr = new o(new Float32Array(A3.buffer, A3.byteOffset, 3)), this.ori = new c(new Float32Array(A3.buffer, A3.byteOffset + 12, 4));
        const g3 = A3[7];
        this.sc = new o(g3, g3, g3);
      }
    }
    clone() {
      return new m(this.tr.clone(), this.ori.clone(), this.sc.clone());
    }
    toJSON() {
      return {tr: this.tr.toJSON(), ori: this.ori.toJSON(), sc: this.sc.toJSON()};
    }
    fromJSON(A3) {
      this.tr.fromJSON(A3.tr), this.ori.fromJSON(A3.ori), A3.sc && this.sc.fromJSON(A3.sc);
    }
    readBinary(A3) {
      this.tr.readBinary(A3), this.ori.readBinary(A3), this.sc.readBinary(A3);
    }
    toString() {
      return t.stringifyJSONWithFixedPrecision(this.toJSON());
    }
  };
  var Q = class {
    constructor(A3, g3) {
      this.p0 = A3 instanceof B ? A3 : new B(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), this.p1 = g3 instanceof B ? g3 : new B(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
    }
    set(A3, g3) {
      this.p0 = A3, this.p1 = g3;
    }
    reset() {
      this.p0.x = Number.POSITIVE_INFINITY, this.p1.x = Number.NEGATIVE_INFINITY, this.p0.y = Number.POSITIVE_INFINITY, this.p1.y = Number.NEGATIVE_INFINITY;
    }
    isValid() {
      return this.p0.x != Number.POSITIVE_INFINITY && this.p1.x != Number.NEGATIVE_INFINITY && this.p0.y != Number.POSITIVE_INFINITY && this.p1.y != Number.NEGATIVE_INFINITY;
    }
    addPoint(A3) {
      (this.p0.x == Number.POSITIVE_INFINITY || A3.x < this.p0.x) && (this.p0.x = A3.x), (this.p0.y == Number.POSITIVE_INFINITY || A3.y < this.p0.y) && (this.p0.y = A3.y), (this.p1.y == Number.NEGATIVE_INFINITY || A3.x > this.p1.x) && (this.p1.x = A3.x), (this.p1.y == Number.NEGATIVE_INFINITY || A3.y > this.p1.y) && (this.p1.y = A3.y);
    }
    size() {
      return this.p1.distanceTo(this.p0);
    }
    diagonal() {
      return this.p1.subtract(this.p0);
    }
    center() {
      const A3 = this.p1.subtract(this.p0);
      return A3.scaleInPlace(0.5), A3.addInPlace(this.p0), A3;
    }
    clone() {
      return new Q(this.p0.clone(), this.p1.clone());
    }
    toJSON() {
      return {p0: this.p0.toJSON(), p1: this.p1.toJSON()};
    }
    toString() {
      return t.stringifyJSONWithFixedPrecision(this.toJSON());
    }
  };
  var E = class {
    constructor(A3 = new o(), g3 = 0) {
      this.pos = A3 instanceof o ? A3 : new o(), this.radius = g3;
    }
    clone() {
      return new E(this.pos.clone(), this.radius);
    }
    intersectsBox(A3) {
      return A3.intersectsSphere(this);
    }
    toJSON() {
      return {pos: this.pos.toJSON(), radius: this.radius};
    }
    toString() {
      return t.stringifyJSONWithFixedPrecision(this.toJSON());
    }
  };
  var b = class {
    constructor(A3, g3) {
      A3 instanceof Float32Array ? (this.p0 = new o(new Float32Array(A3.buffer, A3.byteOffset, 3)), this.p1 = new o(new Float32Array(A3.buffer, A3.byteOffset + 12, 3))) : (this.p0 = A3 instanceof o ? A3 : new o(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), this.p1 = g3 instanceof o ? g3 : new o(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY));
    }
    get min() {
      return this.p0;
    }
    get max() {
      return this.p1;
    }
    set(A3, g3) {
      this.p0 = A3, this.p1 = g3;
    }
    reset() {
      this.p0.x = Number.POSITIVE_INFINITY, this.p0.y = Number.POSITIVE_INFINITY, this.p0.z = Number.POSITIVE_INFINITY, this.p1.x = Number.NEGATIVE_INFINITY, this.p1.y = Number.NEGATIVE_INFINITY, this.p1.z = Number.NEGATIVE_INFINITY;
    }
    isValid() {
      return this.p0.x != Number.POSITIVE_INFINITY && this.p1.x != Number.NEGATIVE_INFINITY && this.p0.y != Number.POSITIVE_INFINITY && this.p1.y != Number.NEGATIVE_INFINITY && this.p0.z != Number.POSITIVE_INFINITY && this.p1.z != Number.NEGATIVE_INFINITY;
    }
    addPoint(A3) {
      A3.x != Number.POSITIVE_INFINITY && A3.x != Number.NEGATIVE_INFINITY && (A3.x < this.p0.x && (this.p0.x = A3.x), A3.x > this.p1.x && (this.p1.x = A3.x)), A3.y != Number.POSITIVE_INFINITY && A3.y != Number.NEGATIVE_INFINITY && (A3.y < this.p0.y && (this.p0.y = A3.y), A3.y > this.p1.y && (this.p1.y = A3.y)), A3.z != Number.POSITIVE_INFINITY && A3.z != Number.NEGATIVE_INFINITY && (A3.z < this.p0.z && (this.p0.z = A3.z), A3.z > this.p1.z && (this.p1.z = A3.z));
    }
    addBox3(A3, g3) {
      g3 ? (this.addPoint(g3.transformVec3(A3.p0)), this.addPoint(g3.transformVec3(new o(A3.p0.x, A3.p0.y, A3.p1.z))), this.addPoint(g3.transformVec3(new o(A3.p0.x, A3.p1.y, A3.p0.z))), this.addPoint(g3.transformVec3(new o(A3.p1.x, A3.p0.y, A3.p0.z))), this.addPoint(g3.transformVec3(new o(A3.p0.x, A3.p1.y, A3.p1.z))), this.addPoint(g3.transformVec3(new o(A3.p1.x, A3.p0.y, A3.p1.z))), this.addPoint(g3.transformVec3(new o(A3.p1.x, A3.p1.y, A3.p0.z))), this.addPoint(g3.transformVec3(A3.p1))) : (this.addPoint(A3.p0), this.addPoint(A3.p1));
    }
    size() {
      return this.p1.distanceTo(this.p0);
    }
    diagonal() {
      return this.p1.subtract(this.p0);
    }
    center() {
      const A3 = this.p1.subtract(this.p0);
      return A3.scaleInPlace(0.5), A3.addInPlace(this.p0), A3;
    }
    toMat4() {
      const A3 = this.p1.x - this.p0.x, g3 = this.p1.y - this.p0.y, I3 = this.p1.z - this.p0.z;
      return new h(A3, 0, 0, 0, 0, g3, 0, 0, 0, 0, I3, 0, this.p0.x, this.p0.y, this.p0.z, 1);
    }
    getBoundingSphere() {
      return new E(this.center(), 0.5 * this.diagonal().length());
    }
    intersectsBox(A3) {
      return !(A3.max.x < this.min.x || A3.min.x > this.max.x || A3.max.y < this.min.y || A3.min.y > this.max.y || A3.max.z < this.min.z || A3.min.z > this.max.z);
    }
    intersectsSphere(A3) {
      return new o().distanceTo(A3.pos) <= A3.radius * A3.radius;
    }
    intersectsPlane(A3) {
      let g3, I3;
      return A3.normal.x > 0 ? (g3 = A3.normal.x * this.min.x, I3 = A3.normal.x * this.max.x) : (g3 = A3.normal.x * this.max.x, I3 = A3.normal.x * this.min.x), A3.normal.y > 0 ? (g3 += A3.normal.y * this.min.y, I3 += A3.normal.y * this.max.y) : (g3 += A3.normal.y * this.max.y, I3 += A3.normal.y * this.min.y), A3.normal.z > 0 ? (g3 += A3.normal.z * this.min.z, I3 += A3.normal.z * this.max.z) : (g3 += A3.normal.z * this.max.z, I3 += A3.normal.z * this.min.z), g3 <= -A3.w && I3 >= -A3.w;
    }
    clone() {
      return new b(this.p0.clone(), this.p1.clone());
    }
    toJSON() {
      return {p0: this.p0.toJSON(), p1: this.p1.toJSON()};
    }
    fromJSON(A3) {
      const g3 = {x: r.isNumeric(A3.p0.x) ? A3.p0.x : Number.POSITIVE_INFINITY, y: r.isNumeric(A3.p0.y) ? A3.p0.y : Number.POSITIVE_INFINITY, z: r.isNumeric(A3.p0.z) ? A3.p0.z : Number.POSITIVE_INFINITY}, I3 = {x: r.isNumeric(A3.p1.x) ? A3.p1.x : Number.NEGATIVE_INFINITY, y: r.isNumeric(A3.p1.y) ? A3.p1.y : Number.NEGATIVE_INFINITY, z: r.isNumeric(A3.p1.z) ? A3.p1.z : Number.NEGATIVE_INFINITY};
      this.p0.fromJSON(g3), this.p1.fromJSON(I3);
    }
    setFromFloat32Array(A3) {
      this.p0 = new o(A3.buffer, A3.byteOffset), this.p1 = new o(A3.buffer, A3.byteOffset + 12);
    }
    toString() {
      return t.stringifyJSONWithFixedPrecision(this.toJSON());
    }
  };
  var Z = class {
    constructor(A3, g3 = 0) {
      this.normal = A3 instanceof o ? A3 : new o(), this.w = g3;
    }
    set(A3, g3, I3, C3) {
      this.normal.set(A3, g3, I3), this.w = C3;
    }
    divideScalar(A3) {
      this.normal.scaleInPlace(1 / A3), this.w /= A3;
    }
    distanceToPoint(A3) {
      return A3.dot(this.normal) + this.w;
    }
    normalizeInPlace() {
      const A3 = 1 / this.normal.length();
      this.normal.scaleInPlace(A3), this.w *= A3;
    }
    clone() {
      return new Z(this.normal.clone(), this.w);
    }
    toJSON() {
      return {normal: this.normal.toJSON(), w: this.w};
    }
    fromJSON(A3) {
      this.normal.fromJSON(A3.normal), this.w = A3.w;
    }
    toString() {
      return t.stringifyJSONWithFixedPrecision(this.toJSON());
    }
  };
  var y = 0;
  var u = class {
    constructor() {
      this.__id = ++y;
    }
    getId() {
      return this.__id;
    }
    getClassName() {
      return e.getClassName(Object.getPrototypeOf(this).constructor);
    }
  };
  var R = class {
    constructor() {
    }
  };
  var V = class extends u {
    constructor() {
      super(), this.listeners = {};
    }
    on(A3, g3) {
      if (!g3)
        throw new Error("Missing listener.");
      this.listeners[A3] || (this.listeners[A3] = []);
      const I3 = this.listeners[A3];
      if (I3.includes(g3))
        throw new Error(`Listener "${g3.name}" already connected to event "${A3}".`);
      const C3 = I3.length;
      return I3[C3] = g3, C3;
    }
    once(A3, g3) {
      const I3 = (C3) => {
        g3(C3), this.off(A3, I3);
      };
      return this.on(A3, I3);
    }
    off(A3, g3) {
      if (!g3)
        throw new Error("Missing callback function (listener).");
      if (typeof g3 == "number")
        return console.warn("Deprecated. Un-register using the original listener instead."), void this.removeListenerById(A3, g3);
      const I3 = this.listeners[A3] || [], C3 = [];
      if (I3.forEach((A4, I4) => {
        A4 === g3 && C3.push(I4);
      }), C3.length == 0)
        throw new Error(`Listener "${g3.name}" is not connected to "${A3}" event`);
      for (const A4 of C3)
        I3[A4] = null;
    }
    removeListenerById(A3, g3) {
      const I3 = this.listeners[A3];
      if (I3) {
        if (!I3[g3])
          throw new Error("Invalid ID");
        I3[g3] = null;
      } else
        console.warn("callback :" + g3 + " was not connected to this event:" + A3);
    }
    emit(A3, g3 = new R()) {
      (this.listeners[A3] || []).forEach((A4) => {
        A4 && A4(g3);
      });
    }
  };
  var F = class extends R {
    constructor(A3, g3) {
      super(), this.width = A3, this.height = g3;
    }
  };
  var S = class extends V {
    constructor(A3 = 0, g3 = 0) {
      super(), this.root = {x: 0, y: 0, w: A3, h: g3};
    }
    fit(A3) {
      if (A3.length == 0)
        return;
      let g3 = false;
      if (this.root.w < A3[0].w && (this.root.w = A3[0].w, g3 = true), this.root.h < A3[0].h && (this.root.h = A3[0].h, g3 = true), g3) {
        const A4 = new F(this.root.w, this.root.h);
        this.emit("resized", A4);
      }
      A3.forEach((A4) => {
        A4.fit = this.__addBlock(A4);
      });
    }
    __addBlock(A3) {
      const g3 = this.findNode(this.root, A3.w, A3.h);
      return g3 ? this.splitNode(g3, A3.w, A3.h) : this.growNode(A3.w, A3.h);
    }
    addBlock(A3) {
      let g3 = false;
      if (this.root.w < A3.w && (this.root.w = A3.w, g3 = true), this.root.h < A3.h && (this.root.h = A3.h, g3 = true), g3) {
        const A4 = new F(this.root.w, this.root.h);
        this.emit("resized", A4);
      }
      const I3 = this.findNode(this.root, A3.w, A3.h);
      return I3 ? this.splitNode(I3, A3.w, A3.h) : this.growNode(A3.w, A3.h);
    }
    findNode(A3, g3, I3) {
      return A3.used ? this.findNode(A3.right, g3, I3) || this.findNode(A3.down, g3, I3) : g3 <= A3.w && I3 <= A3.h ? A3 : null;
    }
    splitNode(A3, g3, I3) {
      return A3.used = true, A3.down = {x: A3.x, y: A3.y + I3, w: A3.w, h: A3.h - I3}, A3.right = {x: A3.x + g3, y: A3.y, w: A3.w - g3, h: I3}, A3;
    }
    growNode(A3, g3) {
      const I3 = A3 <= this.root.w, C3 = g3 <= this.root.h, i3 = C3 && this.root.h >= this.root.w + A3, e3 = I3 && this.root.w >= this.root.h + g3;
      return i3 ? this.growRight(A3, g3) : e3 ? this.growDown(A3, g3) : C3 ? this.growRight(A3, g3) : I3 ? this.growDown(A3, g3) : null;
    }
    growRight(A3, g3) {
      this.root = {used: true, x: 0, y: 0, w: this.root.w + A3, h: this.root.h, down: this.root, right: {x: this.root.w, y: 0, w: A3, h: this.root.h}};
      const I3 = this.findNode(this.root, A3, g3);
      let C3;
      I3 && (C3 = this.splitNode(I3, A3, g3));
      const i3 = new F(this.root.w, this.root.h);
      return this.emit("resized", i3), C3;
    }
    growDown(A3, g3) {
      this.root = {used: true, x: 0, y: 0, w: this.root.w, h: this.root.h + g3, down: {x: 0, y: this.root.h, w: this.root.w, h: g3}, right: this.root};
      const I3 = this.findNode(this.root, A3, g3);
      let C3;
      I3 && (C3 = this.splitNode(I3, A3, g3));
      const i3 = new F(this.root.w, this.root.h);
      return this.emit("resized", i3), C3;
    }
  };
  var w = class {
    constructor(A3 = 0, g3 = 0) {
      this.start = A3, this.size = g3;
    }
  };
  var X = class extends V {
    constructor() {
      super(), this.freeList = [], this.allocations = [], this.allocationsMap = {}, this.allocatedSpace = 0, this.reservedSpace = 0, this.freeSpace = 0;
    }
    getAllocation(A3) {
      return this.allocations[this.allocationsMap[A3]];
    }
    allocate(A3, g3) {
      if (this.allocationsMap[A3] != null) {
        const I4 = this.allocationsMap[A3], C3 = this.allocations[I4];
        if (g3 == C3.size)
          return C3;
        if (g3 < C3.size) {
          const A4 = C3.size - g3;
          return this.addBlock(I4 + 1, new w(C3.start + g3, A4)), this.freeBlock(I4 + 1), C3.size = g3, C3;
        }
        {
          const i3 = I4 + 1;
          if (this.freeList.includes(i3) && C3.size + this.allocations[i3].size >= g3) {
            const A4 = this.allocations[i3];
            if (C3.size + A4.size == g3)
              return C3.size += A4.size, this.freeSpace -= A4.size, this.freeList.splice(this.freeList.indexOf(i3), 1), this.removeBlock(i3), C3;
            {
              const I5 = g3 - C3.size;
              return C3.size += I5, this.freeSpace -= I5, A4.start += I5, A4.size -= I5, C3;
            }
          }
          delete this.allocationsMap[A3], C3.start + C3.size == this.allocatedSpace ? (this.removeBlock(I4), this.allocatedSpace -= C3.size) : this.freeBlock(I4);
        }
      }
      let I3 = -1;
      for (let A4 = 0; A4 < this.freeList.length; A4++) {
        const C3 = this.freeList[A4], i3 = this.allocations[C3];
        if (i3.size == g3) {
          I3 = C3;
          break;
        }
        i3.size > g3 && (I3 = C3);
      }
      if (I3 != -1) {
        const C3 = this.allocations[I3];
        if (this.freeSpace -= C3.size, this.freeList.splice(this.freeList.indexOf(I3), 1), C3.size > g3) {
          const A4 = C3.size - g3;
          this.addBlock(I3 + 1, new w(C3.start + g3, A4)), this.freeBlock(I3 + 1), this.freeList.sort((A5, g4) => this.allocations[g4].size - this.allocations[A5].size), this.allocations[I3].size = g3;
        }
        this.allocationsMap[A3] = I3;
      } else {
        const I4 = this.allocatedSpace, C3 = this.allocations.length;
        this.allocatedSpace += g3;
        const i3 = r.nextPow2(this.allocatedSpace);
        i3 > this.reservedSpace && (this.reservedSpace = i3, this.emit("resized", {reservedSpace: this.reservedSpace})), this.allocations.push(new w(I4, g3)), this.allocationsMap[A3] = C3;
      }
      return this.allocations[this.allocationsMap[A3]];
    }
    addBlock(A3, g3) {
      this.allocations.splice(A3, 0, g3);
      for (const g4 in this.allocationsMap)
        this.allocationsMap[g4] >= A3 && this.allocationsMap[g4]++;
      for (let g4 = 0; g4 < this.freeList.length; g4++)
        this.freeList[g4] >= A3 && this.freeList[g4]++;
    }
    removeBlock(A3) {
      this.allocations.splice(A3, 1);
      for (const g3 in this.allocationsMap)
        this.allocationsMap[g3] > A3 && this.allocationsMap[g3]--;
      for (let g3 = 0; g3 < this.freeList.length; g3++)
        this.freeList[g3] > A3 && this.freeList[g3]--;
    }
    freeBlock(A3) {
      const g3 = this.allocations[A3];
      this.freeSpace += g3.size;
      const I3 = A3 - 1;
      if (this.freeList.includes(I3)) {
        return this.allocations[I3].size += g3.size, void this.removeBlock(A3);
      }
      const C3 = A3 + 1;
      if (this.freeList.includes(C3)) {
        const I4 = this.allocations[C3];
        return I4.start -= g3.size, I4.size += g3.size, void this.removeBlock(A3);
      }
      this.freeList.push(A3);
    }
    deallocate(A3) {
      const g3 = this.allocationsMap[A3];
      if (g3 == null)
        throw new Error(`allocation ${A3} does not exist.`);
      this.freeBlock(g3), delete this.allocationsMap[A3];
    }
    getFragmentation() {
      return this.freeSpace / this.allocatedSpace;
    }
    defragment() {
    }
    verifyConsistency() {
      if (Object.keys(this.allocationsMap).length + this.freeList.length != this.allocations.length)
        throw new Error("number of blocks does not match the number of allocations");
      for (const A4 in this.allocationsMap) {
        const g3 = this.allocationsMap[A4];
        if (this.freeList.includes(g3))
          throw new Error("block of used memory is also on the free list");
      }
      let A3 = 0;
      for (let g3 = 0; g3 < this.allocations.length; g3++) {
        const I3 = this.allocations[g3];
        if (I3.start != A3)
          throw "blocks of memory are not sequential";
        A3 += I3.size;
      }
      if (A3 != this.allocatedSpace)
        throw `allocated size: ${this.allocatedSpace}  does not match allocated blocks: ${A3}`;
      if (this.reservedSpace < this.allocatedSpace)
        throw `reserved space: ${this.reservedSpace} is less than allocated space: ${this.allocatedSpace}`;
    }
  };
  var H = class {
    constructor(A3, g3, I3, C3, i3) {
      this.screenPos = A3, this.pointerRay = g3, this.intersectionPos = I3, this.geomData = C3, this.geomItem = i3.geomItem, this.componentId = i3.componentId, this.dist = i3.dist;
    }
  };
  var W = class extends R {
    constructor(A3) {
      super(), this.controller = A3;
    }
  };
  var Y = class extends R {
    constructor(A3, g3) {
      super(), this.change = A3, this.count = g3;
    }
  };
  var K = class extends R {
    constructor(A3) {
      super(), this.envMap = A3;
    }
  };
  var p = class extends R {
    constructor(A3) {
      super(), this.index = A3;
    }
  };
  var N = class extends R {
    constructor() {
      super(), this.propagating = true;
    }
  };
  var J = class extends N {
    constructor(A3) {
      super(), this.propagating = true, this.sourceEvent = A3, this.altKey = A3.altKey, this.code = A3.code, this.ctrlKey = A3.ctrlKey, this.isComposing = A3.isComposing, this.key = A3.key, this.location = A3.location, this.metaKey = A3.metaKey, this.repeat = A3.repeat, this.shiftKey = A3.shiftKey, this.which = A3.which;
    }
    stopPropagation() {
      this.propagating = false, this.sourceEvent && this.sourceEvent.stopPropagation();
    }
    preventDefault() {
      this.sourceEvent && this.sourceEvent.preventDefault();
    }
  };
  var D = class extends R {
    constructor(A3) {
      super(), this.name = A3;
    }
  };
  var f = class extends R {
    constructor(A3) {
      super(), this.name = A3;
    }
  };
  var M = class extends R {
    constructor(A3) {
      super(), this.range = A3;
    }
  };
  var L = class extends R {
    constructor(A3) {
      super(), this.scene = A3;
    }
  };
  var U = class extends R {
    constructor(A3) {
      super(), this.value = A3;
    }
  };
  var v = class extends R {
    constructor(A3) {
      super(), this.selected = A3;
    }
  };
  var k = class extends R {
    constructor(A3) {
      super(), this.shaderName = A3;
    }
  };
  var x = class extends R {
    constructor(A3) {
      super(), this.state = A3;
    }
  };
  var z = class extends R {
    constructor(A3, g3) {
      super(), this.geomFileID = A3, this.geomCount = g3;
    }
  };
  var T = class extends R {
    constructor(A3, g3) {
      super(), this.isTextured = A3, this.param = g3;
    }
  };
  var _ = class extends R {
    constructor(A3, g3) {
      super(), this.isOpaque = A3, this.isOpaqueStateChanged = g3;
    }
  };
  var P = class extends R {
    constructor(A3, g3) {
      super(), this.interfaceType = A3, this.viewXfo = g3;
    }
  };
  var O = class extends R {
    constructor(A3) {
      super(), this.visible = A3;
    }
  };
  var j = class extends P {
    constructor(A3) {
      super("VR", A3), this.hmd = "", this.controllers = [];
    }
  };
  var q = {mouse: "mouse", touch: "touch", xr: "xr"};
  var $ = null;
  var AA = class extends N {
    constructor(A3) {
      super(), this.pointerType = A3;
    }
    stopPropagation() {
      this.propagating = false;
    }
    setCapture(A3) {
      $ = A3;
    }
    getCapture() {
      return $;
    }
    releaseCapture() {
      $ = null;
    }
  };
  var gA = class extends AA {
    constructor(A3, g3, I3, C3) {
      super(q.xr), this.buttonPressed = 0, this.viewport = A3, this.controller = g3, this.button = I3, this.buttonPressed = C3;
    }
    stopPropagation() {
      this.propagating = false;
    }
    setCapture(A3) {
      this.controller.capturedItem = A3;
    }
    getCapture() {
      return this.controller.capturedItem;
    }
    releaseCapture() {
      this.controller.capturedItem = null;
    }
  };
  var IA = class extends AA {
    constructor(A3, g3, I3) {
      super(q.xr), this.controllers = [], this.viewport = A3, this.viewXfo = g3, I3.forEach((A4) => {
        this.controllers.push(A4);
      });
    }
  };
  var CA = class extends R {
    constructor(A3) {
      super(), this.xrViewport = A3;
    }
  };
  var iA = class extends AA {
    constructor(A3, g3) {
      super(q.mouse), this.sourceEvent = A3, this.button = A3.button, this.clientX = A3.clientX, this.clientY = A3.clientY;
      this.rendererX = 1 * (this.clientX - g3.left), this.rendererY = 1 * (this.clientY - g3.top), this.altKey = A3.altKey, this.metaKey = A3.metaKey, this.ctrlKey = A3.ctrlKey, this.shiftKey = A3.shiftKey;
    }
    stopPropagation() {
      super.stopPropagation(), this.sourceEvent && this.sourceEvent.stopPropagation();
    }
    preventDefault() {
      this.sourceEvent && this.sourceEvent.preventDefault();
    }
  };
  var eA = class {
    constructor(A3, g3) {
      this.clientX = 0, this.clientY = 0, this.screenX = 0, this.screenY = 0, this.pageX = 0, this.pageY = 0, this.radiusX = 0, this.radiusY = 0, this.rotationAngle = 0, this.force = 0, this.altitudeAngle = 0, this.azimuthAngle = 0, this.touchType = "direct", this.identifier = A3.identifier, this.clientX = A3.clientX, this.clientY = A3.clientY, this.screenX = A3.screenX, this.screenY = A3.screenY, this.pageX = A3.pageX, this.pageY = A3.pageY, this.radiusX = A3.radiusX, this.radiusY = A3.radiusY, this.rotationAngle = A3.rotationAngle, this.force = A3.force;
      this.rendererX = 1 * (this.clientX - g3.left), this.rendererY = 1 * (this.clientY - g3.top), this.touchPos = new B(), this.touchRay = new G();
    }
  };
  var tA = class extends AA {
    constructor(A3, g3) {
      super(q.touch), this.touches = [], this.changedTouches = [], this.targetTouches = [], this.altKey = false, this.metaKey = false, this.ctrlKey = false, this.shiftKey = false, this.sourceEvent = A3, this.sourceEvent.stopPropagation(), this.altKey = A3.altKey, this.metaKey = A3.metaKey, this.ctrlKey = A3.ctrlKey, this.shiftKey = A3.shiftKey;
      for (let I3 = 0; I3 < A3.touches.length; I3++)
        this.touches.push(new eA(A3.touches[I3], g3));
      if (A3.changedTouches)
        for (let I3 = 0; I3 < A3.changedTouches.length; I3++)
          this.changedTouches.push(new eA(A3.changedTouches[I3], g3));
      if (A3.targetTouches)
        for (let I3 = 0; I3 < A3.targetTouches.length; I3++)
          this.targetTouches.push(new eA(A3.targetTouches[I3], g3));
    }
    stopPropagation() {
      super.stopPropagation(), this.sourceEvent && this.sourceEvent.stopPropagation();
    }
    preventDefault() {
    }
  };
  var BA = class extends iA {
    constructor(A3, g3) {
      super(A3, g3), this.wheelDelta = A3.wheelDelta, this.deltaMode = A3.deltaMode, this.deltaX = A3.deltaX, this.deltaY = A3.deltaY, this.deltaZ = A3.deltaZ;
    }
  };
  var oA = class extends R {
    constructor(A3, g3) {
      super(), this.index = A3, this.childItem = g3;
    }
  };
  var sA = class extends R {
    constructor(A3, g3) {
      super(), this.oldName = A3, this.newName = g3;
    }
  };
  var aA = 0;
  var lA = class extends V {
    constructor() {
      if (super(), this.constructor.name == "RefCounted")
        throw new Error("RefCounted should not be instantiated directly.");
      this.__id = ++aA, this.__refs = [], this.__destroyed = false;
    }
    getId() {
      return this.__id;
    }
    numRefs() {
      return this.__refs.length;
    }
    addRef(A3) {
      if (!A3)
        throw new Error("Error in RefCounted.addRef: Must provide a referer");
      return this.__refs.push(A3), true;
    }
    removeRef(A3) {
      if (!A3)
        throw new Error("Error in RefCounted.removeRef: Must provide a referer");
      const g3 = this.__refs.indexOf(A3);
      if (g3 == -1)
        throw new Error("Error in RefCounted.removeRef: referer not found in refs list.");
      this.__refs.splice(g3, 1), this.__refs.length == 0 && this.destroy();
    }
    getRefer(A3) {
      return this.__refs[A3];
    }
    getRefIndex(A3) {
      return this.__refs.indexOf(A3);
    }
    isDestroyed() {
      return this.__destroyed;
    }
    destroy() {
      this.__destroyed = true, this.emit("destructing");
    }
  };
  var nA = class extends V {
    constructor() {
      super(), this.paramEventListenerIDs = {}, this.paramMapping = {}, this.params = [], this.deprecatedParamMapping = {};
    }
    getNumParameters() {
      return this.params.length;
    }
    getParameters() {
      return this.params;
    }
    getParameterIndex(A3) {
      return this.paramMapping[A3];
    }
    getParameterByIndex(A3) {
      return this.params[A3];
    }
    hasParameter(A3) {
      return A3 in this.paramMapping;
    }
    addParameterDeprecationMapping(A3, g3) {
      this.deprecatedParamMapping[A3] = g3;
    }
    getParameter(A3) {
      let g3 = this.paramMapping[A3];
      if (g3 == null) {
        const I3 = this.deprecatedParamMapping[A3];
        if (!I3)
          return null;
        console.warn(`Parameter name ${A3} is now deprecated. Please use ${I3} instead.`), g3 = this.paramMapping[I3];
      }
      return this.params[g3];
    }
    parameterValueChanged(A3) {
      this.emit("parameterValueChanged", A3);
    }
    addParameter(A3) {
      return this.insertParameter(A3, this.params.length);
    }
    insertParameter(A3, g3) {
      const I3 = A3.getName();
      this.paramMapping[I3] != null && (console.warn("Replacing Parameter:" + I3), this.removeParameter(I3)), A3.setOwner(this), this.paramEventListenerIDs[I3] = A3.on("valueChanged", (g4) => {
        const I4 = {param: A3};
        for (const A4 in g4)
          I4[A4] = g4[A4];
        this.parameterValueChanged(I4);
      }), this.params.splice(g3, 0, A3);
      for (let A4 = g3; A4 < this.params.length; A4++)
        this.paramMapping[this.params[A4].getName()] = A4;
      const C3 = new D(I3);
      return this.emit("parameterAdded", C3), A3;
    }
    removeParameter(A3) {
      if (this.paramMapping[A3] == null)
        throw new Error("Unable to remove Parameter:" + A3);
      const g3 = this.paramMapping[A3];
      this.params[this.paramMapping[A3]].removeListenerById("valueChanged", this.paramEventListenerIDs[A3]), this.params.splice(g3, 1), delete this.paramMapping[A3];
      for (let A4 = g3; A4 < this.params.length; A4++)
        this.paramMapping[this.params[A4].getName()] = A4;
      const I3 = new f(A3);
      this.emit("parameterRemoved", I3);
    }
    replaceParameter(A3) {
      const g3 = A3.getName();
      if (this.paramMapping[g3] == null)
        throw new Error("Unable to replace Parameter:" + g3);
      const I3 = this.paramMapping[g3];
      return this.removeParameter(g3), this.insertParameter(A3, I3), A3;
    }
    toJSON(A3) {
      const g3 = {type: this.getClassName()}, I3 = {};
      let C3 = 0;
      for (const g4 of this.params) {
        const i3 = g4.toJSON(A3);
        i3 && (I3[g4.getName()] = i3, C3++);
      }
      return C3 > 0 && (g3.params = I3), g3;
    }
    fromJSON(A3, g3) {
      if (A3.params)
        for (const I3 in A3.params) {
          const C3 = A3.params[I3], i3 = this.getParameter(I3);
          i3 ? C3.paramPath ? g3 == null || g3.resolvePath(C3.paramPath, (A4) => {
            this.replaceParameter(A4);
          }, () => {
            console.warn("Unable to resolve shared parameter:" + C3.paramPath);
          }) : i3.fromJSON(C3, g3) : console.warn("Param not found:" + I3);
        }
    }
    readBinary(A3, g3) {
      if ((g3 == null ? void 0 : g3.versions["zea-engine"].compare([0, 0, 3])) >= 0) {
        const I3 = A3.loadUInt32();
        for (let C3 = 0; C3 < I3; C3++) {
          const I4 = A3.loadStr(), C4 = A3.loadStr();
          let i3 = this.getParameter(C4);
          if (!i3) {
            if (i3 = e.constructClass(I4), !i3) {
              console.error("Unable to construct prop:" + C4 + " of type:" + I4);
              continue;
            }
            i3.setName(C4), this.addParameter(i3);
          }
          i3.readBinary(A3, g3);
        }
      }
    }
    toString(A3) {
      return JSON.stringify(this.toJSON(), null, 2);
    }
    copyFrom(A3, g3) {
      let I3 = A3.getNumParameters();
      for (; I3--; ) {
        const g4 = A3.getParameterByIndex(I3), C3 = this.getParameter(g4.getName());
        C3 ? C3.copyFrom(g4) : this.addParameter(g4.clone());
      }
    }
  };
  var dA = 0;
  var hA = class extends nA {
    constructor(A3 = "") {
      super(), this.__ownerItem = void 0, this.__selectable = true, this.__selected = false, this.__metaData = {}, this.__name = A3, this.__path = [this.__name], dA++;
    }
    static getNumBaseItems() {
      return dA;
    }
    getName() {
      return this.__name;
    }
    setName(A3) {
      if (this.__name != A3) {
        const g3 = this.__name;
        this.__name = A3, this.updatePath();
        const I3 = new sA(g3, A3);
        this.emit("nameChanged", I3);
      }
    }
    get name() {
      return this.getName();
    }
    set name(A3) {
      this.setName(A3);
    }
    updatePath() {
      this.__ownerItem == null ? this.__path = [this.__name] : (this.__path = this.__ownerItem.getPath().slice(), this.__path.push(this.__name));
    }
    getPath() {
      return this.__path;
    }
    resolvePath(A3, g3 = 0) {
      if (g3 == 0 && (A3[0] != "." && A3[0] != this.__name || g3++), g3 == A3.length)
        return this;
      if (A3[g3] == ">" && g3 == A3.length - 1)
        return this.getParameter(A3[g3 + 1]);
      const I3 = this.getParameter(A3[g3]);
      if (I3)
        return I3;
      throw new Error("Invalid path:" + A3 + "[" + g3 + "] member not found");
    }
    getOwner() {
      return this.__ownerItem;
    }
    setOwner(A3) {
      this.__ownerItem !== A3 ? this.__ownerItem = A3 : A3 || (this.__ownerItem = void 0), this.updatePath();
    }
    isSelectable() {
      return this.__selectable;
    }
    setSelectable(A3) {
      if (this.__selectable != A3) {
        this.__selectable = A3;
        let g3 = new U(this.__selectable);
        return this.emit("selectabilityChanged", g3), true;
      }
      return false;
    }
    isSelected() {
      return this.__selected;
    }
    setSelected(A3) {
      this.__selected = A3;
      let g3 = new v(this.__selected);
      this.emit("selectedChanged", g3);
    }
    getMetadata(A3) {
      return this.__metaData[A3];
    }
    hasMetadata(A3) {
      return A3 in this.__metaData;
    }
    setMetadata(A3, g3) {
      this.__metaData[A3] = g3;
    }
    deleteMetadata(A3) {
      delete this.__metaData[A3];
    }
    toJSON(A3) {
      const g3 = super.toJSON(A3);
      return g3.name = this.__name, g3;
    }
    fromJSON(A3, g3) {
      A3.name && (this.__name = A3.name), super.fromJSON(A3, g3);
    }
    readBinary(A3, g3) {
      A3.loadStr(), this.setName(A3.loadStr()), super.readBinary(A3, g3);
    }
    clone(A3) {
      throw new Error(this.constructor.name + " does not implement its clone method");
    }
    copyFrom(A3, g3) {
      super.copyFrom(A3, g3), this.setName(A3.getName()), this.setSelectable(A3.isSelectable());
    }
  };
  var cA = function(A3, g3, I3, C3, i3) {
    try {
      const e3 = new XMLHttpRequest();
      e3.responseType = g3, e3.addEventListener("timeout", (g4) => {
        throw new Error("The request for " + A3 + " timed out.");
      }), e3.addEventListener("error", (g4) => {
        throw new Error("The request for " + A3 + ": xhr.readyState:" + e3.readyState);
      }), e3.addEventListener("abort", (g4) => {
        throw new Error("The request for " + A3 + ": xhr.readyState:" + e3.readyState);
      }), e3.addEventListener("progress", (A4) => {
        i3 && i3(A4.total, A4.loaded);
      }), e3.addEventListener("loadend", (A4) => {
        e3.status == 200 ? I3(e3) : C3(e3.statusText);
      }), e3.open("GET", A3, true), e3.send();
    } catch (A4) {
      C3(A4);
    }
  };
  var rA = function(A3, g3, I3, C3) {
    cA(A3, "text", (A4) => {
      g3(A4.responseText);
    }, (g4) => {
      if (I3 == null)
        throw new Error("Unable to XHR File:" + A3);
      I3(g4);
    }, C3);
  };
  var GA = function(A3, g3, I3, C3) {
    cA(A3, "arraybuffer", (A4) => {
      g3(A4.response);
    }, (g4) => {
      if (I3 == null)
        throw new Error("Unable to XHR File:" + A3);
      I3(g4);
    }, C3);
  };
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  function mA(A3, g3, I3, C3) {
    return new (I3 || (I3 = Promise))(function(i3, e3) {
      function t3(A4) {
        try {
          o3(C3.next(A4));
        } catch (A5) {
          e3(A5);
        }
      }
      function B3(A4) {
        try {
          o3(C3.throw(A4));
        } catch (A5) {
          e3(A5);
        }
      }
      function o3(A4) {
        var g4;
        A4.done ? i3(A4.value) : (g4 = A4.value, g4 instanceof I3 ? g4 : new I3(function(A5) {
          A5(g4);
        })).then(t3, B3);
      }
      o3((C3 = C3.apply(A3, g3 || [])).next());
    });
  }
  var QA = 0;
  var EA = class extends V {
    constructor(A3) {
      super(), this.poolSize = Math.max(1, g.hardwareConcurrency - 1), this.workers = [], this.workerTaskCount = [], this.taskPromiseResolves = {}, this.taskQueue = [], this.availableWorkers = [], this.terminationTimeouts = [], this.terminateWorkersWhenFree = true, this.terminationLatency = 2e3, this.terminateWorkersWhenFree = A3;
    }
    addTask(A3, g3) {
      return this.addTaskCallback(() => ({taskData: A3, transferables: g3}));
    }
    addTaskCallback(A3) {
      QA++;
      const g3 = QA;
      return new Promise((I3) => mA(this, void 0, void 0, function* () {
        this.taskPromiseResolves[g3] = I3, this.taskQueue.push({taskId: g3, dataFactory: A3}), this.availableWorkers.length > 0 ? this.consumeTask() : this.workers.length < this.poolSize && (yield this.addWorker(), this.consumeTask());
      }));
    }
    consumeTask() {
      return mA(this, void 0, void 0, function* () {
        const A3 = this.availableWorkers.pop();
        if (this.workerTaskCount[A3] > 0)
          return;
        if (this.taskQueue.length == 0)
          return void (this.terminateWorkersWhenFree && this.scheduleWorkerTermination(A3));
        if (this.terminationTimeouts[A3] != -1 ? (clearTimeout(this.terminationTimeouts[A3]), this.terminationTimeouts[A3] = -1) : this.workers[A3] || (yield this.allocWorker(A3)), this.taskQueue.length == 0)
          return void (this.terminateWorkersWhenFree && this.scheduleWorkerTermination(A3));
        const g3 = this.taskQueue.pop(), {taskData: I3, transferables: C3} = g3.dataFactory(A3);
        I3.taskId = g3.taskId, this.workerTaskCount[A3]++, this.workers[A3].postMessage(I3, C3);
      });
    }
    addWorker() {
      const A3 = this.workers.length;
      return this.workers.push(null), this.allocWorker(A3);
    }
    allocWorker(A3) {
      return new Promise((g3) => {
        this.constructWorker().then((I3) => {
          I3.onmessage = (g4) => {
            if (g4.data.taskId in this.taskPromiseResolves) {
              const I4 = g4.data.taskId;
              if (delete g4.data.taskId, this.taskPromiseResolves[I4](g4.data), delete this.taskPromiseResolves[I4], this.workerTaskCount[A3]--, this.workerTaskCount[A3] > 0)
                return;
              this.availableWorkers.indexOf(A3) == -1 && this.availableWorkers.push(A3), this.taskQueue.length > 0 ? this.consumeTask() : this.terminateWorkersWhenFree && this.scheduleWorkerTermination(A3);
            } else
              g4.data.eventName && (g4.data.workerId = A3, this.emit(g4.data.eventName, g4.data));
          }, this.workers[A3] = I3, this.terminationTimeouts[A3] = -1, this.workerTaskCount[A3] = 0, this.availableWorkers.push(A3), g3();
        });
      });
    }
    scheduleWorkerTermination(A3) {
      this.terminationTimeouts[A3] = setTimeout(() => {
        this.terminateWorker(A3), this.terminationTimeouts[A3] = -1;
      }, this.terminationLatency);
    }
    terminateWorker(A3) {
      this.workers[A3].terminate(), this.workers[A3] = null;
    }
    messageWorker(A3, g3) {
      QA++;
      const I3 = QA;
      return new Promise((C3) => {
        this.taskPromiseResolves[I3] = C3, g3.taskId = I3, this.workers[A3].postMessage(g3);
      });
    }
  };
  function bA(A3, g3, I3) {
    var C3 = g3 === void 0 ? null : g3, i3 = function(A4, g4) {
      var I4 = atob(A4);
      if (g4) {
        for (var C4 = new Uint8Array(I4.length), i4 = 0, e4 = I4.length; i4 < e4; ++i4)
          C4[i4] = I4.charCodeAt(i4);
        return String.fromCharCode.apply(null, new Uint16Array(C4.buffer));
      }
      return I4;
    }(A3, I3 !== void 0 && I3), e3 = i3.indexOf("\n", 10) + 1, t3 = i3.substring(e3) + (C3 ? "//# sourceMappingURL=" + C3 : ""), B3 = new Blob([t3], {type: "application/javascript"});
    return URL.createObjectURL(B3);
  }
  function ZA(A3, g3, I3) {
    var C3;
    return function(i3) {
      return C3 = C3 || bA(A3, g3, I3), new Worker(C3, i3);
    };
  }
  var yA = ZA("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICd1c2Ugc3RyaWN0JzsKCiAgLy8gPCEtLSBwcmV0dGllci1pZ25vcmUtc3RhcnQgLS0+CiAgLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1qc2RvYyAqLwoKICBjb25zdCBNb2R1bGUgPSB7fTsKCiAgY29uc3QgV29ya2VyU2NvcGUgPSB7fTsKCiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLXVucGFja0JyaWRnZS5qcy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAhKGZ1bmN0aW9uICh0LCBlKSB7CiAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgaGFzIGJlZW4gX2NhcmVmdWxseV8gbW9kaWZpZWQgYnkgaGFuZC4KICAgIC8vIFRoZXJlIHdlcmUgdmFyaW91cyBjYXNlcyBmb3IgaW4gd2hhdCBjb250ZXh0IHRoZSBjb2RlIG1pZ2h0CiAgICAvLyBiZSBydW4sIGFuZCBJIHJlbW92ZWQgYWxsIGJ1dCB0aGUgd2Vid29ya2VyIGNhc2UuCiAgICAvLyBUaGVyZSB3YXMgY29kZSB0byBoYW5kbGUgbG9hZGluZyBpbiBhIG5vZGVKUyBjb250ZXh0LCB0aGF0IHRyaWVkIHRvIGltcG9ydCgiZnMiKQogICAgLy8gV2ViUGFjayBrZXB0cyB0cmlwcGluZyB1cCBvbiB0aGF0IGNvZGUgaW4gaXRzIHN0YXRpYyBhbmFseXNpcyBvZiB0aGUgY29kZSwgc28KICAgIC8vIEkgY2FyZWZ1bGx5IHJlbW92ZWQgaXQuCiAgICB0LnVucGFja0JyaWRnZSA9IGUodC5mcyk7CiAgfSkoV29ya2VyU2NvcGUsIGZ1bmN0aW9uICh0KSB7CiAgICByZXR1cm4gKGZ1bmN0aW9uICh0KSB7CiAgICAgIHZhciBlID0ge307CiAgICAgIGZ1bmN0aW9uIHIobikgewogICAgICAgIGlmIChlW25dKSByZXR1cm4gZVtuXS5leHBvcnRzCiAgICAgICAgdmFyIGkgPSAoZVtuXSA9IHsgaTogbiwgbDogITEsIGV4cG9ydHM6IHt9IH0pOwogICAgICAgIHJldHVybiB0W25dLmNhbGwoaS5leHBvcnRzLCBpLCBpLmV4cG9ydHMsIHIpLCAoaS5sID0gITApLCBpLmV4cG9ydHMKICAgICAgfQogICAgICByZXR1cm4gKAogICAgICAgIChyLm0gPSB0KSwKICAgICAgICAoci5jID0gZSksCiAgICAgICAgKHIuZCA9IGZ1bmN0aW9uICh0LCBlLCBuKSB7CiAgICAgICAgICByLm8odCwgZSkgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIGUsIHsgZW51bWVyYWJsZTogITAsIGdldDogbiB9KTsKICAgICAgICB9KSwKICAgICAgICAoci5yID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICd1bmRlZmluZWQnICE9IHR5cGVvZiBTeW1ib2wgJiYKICAgICAgICAgICAgU3ltYm9sLnRvU3RyaW5nVGFnICYmCiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pLAogICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiAhMCB9KTsKICAgICAgICB9KSwKICAgICAgICAoci50ID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgIGlmICgoMSAmIGUgJiYgKHQgPSByKHQpKSwgOCAmIGUpKSByZXR1cm4gdAogICAgICAgICAgaWYgKDQgJiBlICYmICdvYmplY3QnID09IHR5cGVvZiB0ICYmIHQgJiYgdC5fX2VzTW9kdWxlKSByZXR1cm4gdAogICAgICAgICAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpOwogICAgICAgICAgaWYgKChyLnIobiksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogITAsIHZhbHVlOiB0IH0pLCAyICYgZSAmJiAnc3RyaW5nJyAhPSB0eXBlb2YgdCkpCiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gdCkKICAgICAgICAgICAgICByLmQoCiAgICAgICAgICAgICAgICBuLAogICAgICAgICAgICAgICAgaSwKICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0W2VdCiAgICAgICAgICAgICAgICB9LmJpbmQobnVsbCwgaSkKICAgICAgICAgICAgICApOwogICAgICAgICAgcmV0dXJuIG4KICAgICAgICB9KSwKICAgICAgICAoci5uID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgIHZhciBlID0KICAgICAgICAgICAgdCAmJiB0Ll9fZXNNb2R1bGUKICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHQuZGVmYXVsdAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gdAogICAgICAgICAgICAgICAgfTsKICAgICAgICAgIHJldHVybiByLmQoZSwgJ2EnLCBlKSwgZQogICAgICAgIH0pLAogICAgICAgIChyLm8gPSBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LCBlKQogICAgICAgIH0pLAogICAgICAgIChyLnAgPSAnJyksCiAgICAgICAgcigoci5zID0gMikpCiAgICAgICkKICAgIH0pKFsKICAgICAgZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiAhMCB9KTsKICAgICAgICBjb25zdCBuID0gcigxKSwKICAgICAgICAgIGkgPSB7CiAgICAgICAgICAgIDA6ICdFUkFSX1NVQ0NFU1MnLAogICAgICAgICAgICAxMDogJ0VSQVJfRU5EX0FSQ0hJVkUnLAogICAgICAgICAgICAxMTogJ0VSQVJfTk9fTUVNT1JZJywKICAgICAgICAgICAgMTI6ICdFUkFSX0JBRF9EQVRBJywKICAgICAgICAgICAgMTM6ICdFUkFSX0JBRF9BUkNISVZFJywKICAgICAgICAgICAgMTQ6ICdFUkFSX1VOS05PV05fRk9STUFUJywKICAgICAgICAgICAgMTU6ICdFUkFSX0VPUEVOJywKICAgICAgICAgICAgMTY6ICdFUkFSX0VDUkVBVEUnLAogICAgICAgICAgICAxNzogJ0VSQVJfRUNMT1NFJywKICAgICAgICAgICAgMTg6ICdFUkFSX0VSRUFEJywKICAgICAgICAgICAgMTk6ICdFUkFSX0VXUklURScsCiAgICAgICAgICAgIDIwOiAnRVJBUl9TTUFMTF9CVUYnLAogICAgICAgICAgICAyMTogJ0VSQVJfVU5LTk9XTicsCiAgICAgICAgICAgIDIyOiAnRVJBUl9NSVNTSU5HX1BBU1NXT1JEJywKICAgICAgICAgICAgMjM6ICdFUkFSX0VSRUZFUkVOQ0UnLAogICAgICAgICAgICAyNDogJ0VSQVJfQkFEX1BBU1NXT1JEJywKICAgICAgICAgIH0sCiAgICAgICAgICBvID0gewogICAgICAgICAgICAwOiAnU3VjY2VzcycsCiAgICAgICAgICAgIDExOiAnTm90IGVub3VnaCBtZW1vcnknLAogICAgICAgICAgICAxMjogJ0FyY2hpdmUgaGVhZGVyIG9yIGRhdGEgYXJlIGRhbWFnZWQnLAogICAgICAgICAgICAxMzogJ0ZpbGUgaXMgbm90IFJBUiBhcmNoaXZlJywKICAgICAgICAgICAgMTQ6ICdVbmtub3duIGFyY2hpdmUgZm9ybWF0JywKICAgICAgICAgICAgMTU6ICdGaWxlIG9wZW4gZXJyb3InLAogICAgICAgICAgICAxNjogJ0ZpbGUgY3JlYXRlIGVycm9yJywKICAgICAgICAgICAgMTc6ICdGaWxlIGNsb3NlIGVycm9yJywKICAgICAgICAgICAgMTg6ICdGaWxlIHJlYWQgZXJyb3InLAogICAgICAgICAgICAxOTogJ0ZpbGUgd3JpdGUgZXJyb3InLAogICAgICAgICAgICAyMDogJ0J1ZmZlciBmb3IgYXJjaGl2ZSBjb21tZW50IGlzIHRvbyBzbWFsbCwgY29tbWVudCB0cnVuY2F0ZWQnLAogICAgICAgICAgICAyMTogJ1Vua25vd24gZXJyb3InLAogICAgICAgICAgICAyMjogJ1Bhc3N3b3JkIGZvciBlbmNyeXB0ZWQgZmlsZSBvciBoZWFkZXIgaXMgbm90IHNwZWNpZmllZCcsCiAgICAgICAgICAgIDIzOiAnQ2Fubm90IG9wZW4gZmlsZSBzb3VyY2UgZm9yIHJlZmVyZW5jZSByZWNvcmQnLAogICAgICAgICAgICAyNDogJ1dyb25nIHBhc3N3b3JkIGlzIHNwZWNpZmllZCcsCiAgICAgICAgICB9OwogICAgICAgIGNsYXNzIHMgewogICAgICAgICAgY29uc3RydWN0b3IodCA9ICcnKSB7CiAgKHRoaXMuX3Bhc3N3b3JkID0gdCksICh0aGlzLl9hcmNoaXZlID0gbnVsbCk7CiAgICAgICAgICB9CiAgICAgICAgICBnZXRGaWxlTGlzdCgpIHsKICAgICAgICAgICAgbGV0IHQsCiAgICAgICAgICAgICAgW2UsIHJdID0gdGhpcy5vcGVuQXJjKCEwKTsKICAgICAgICAgICAgaWYgKCdTVUNDRVNTJyAhPT0gZS5zdGF0ZSkgdCA9IFtlLCBudWxsXTsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgbGV0IGUsCiAgICAgICAgICAgICAgICBuLAogICAgICAgICAgICAgICAgaSA9IFtdOwogICAgICAgICAgICAgIGZvciAoOyAoW2UsIG5dID0gdGhpcy5wcm9jZXNzTmV4dEZpbGUoKCkgPT4gITApKSwgJ1NVQ0NFU1MnID09PSBlLnN0YXRlOyApIGkucHVzaChuLmZpbGVIZWFkZXIpOwogICAgICAgICAgICAgIHQgPSAnRVJBUl9FTkRfQVJDSElWRScgIT09IGUucmVhc29uID8gW2UsIG51bGxdIDogW3sgc3RhdGU6ICdTVUNDRVNTJyB9LCB7IGFyY0hlYWRlcjogciwgZmlsZUhlYWRlcnM6IGkgfV07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2VBcmMoKSwgdAogICAgICAgICAgfQogICAgICAgICAgZXh0cmFjdEFsbCgpIHsKICAgICAgICAgICAgbGV0IHQsCiAgICAgICAgICAgICAgW2UsIHJdID0gdGhpcy5vcGVuQXJjKCExKTsKICAgICAgICAgICAgaWYgKCdTVUNDRVNTJyAhPT0gZS5zdGF0ZSkgdCA9IFtlLCBudWxsXTsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgbGV0IGUsCiAgICAgICAgICAgICAgICBuLAogICAgICAgICAgICAgICAgaSA9IFtdOwogICAgICAgICAgICAgIGZvciAoOyAoW2UsIG5dID0gdGhpcy5wcm9jZXNzTmV4dEZpbGUoKCkgPT4gITEpKSwgJ1NVQ0NFU1MnID09PSBlLnN0YXRlOyApIGkucHVzaChuKTsKICAgICAgICAgICAgICB0ID0gJ0VSQVJfRU5EX0FSQ0hJVkUnICE9PSBlLnJlYXNvbiA/IFtlLCBudWxsXSA6IFt7IHN0YXRlOiAnU1VDQ0VTUycgfSwgeyBhcmNIZWFkZXI6IHIsIGZpbGVzOiBpIH1dOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb3NlQXJjKCksIHQKICAgICAgICAgIH0KICAgICAgICAgIGV4dHJhY3RGaWxlcyh0LCBlKSB7CiAgICAgICAgICAgIGxldCByLAogICAgICAgICAgICAgIFtuLCBpXSA9IHRoaXMub3BlbkFyYyghMSwgZSksCiAgICAgICAgICAgICAgbyA9IHt9OwogICAgICAgICAgICBmb3IgKGxldCBlID0gMDsgZSA8IHQubGVuZ3RoOyArK2UpIG9bdFtlXV0gPSBlOwogICAgICAgICAgICBpZiAoJ1NVQ0NFU1MnICE9PSBuLnN0YXRlKSByID0gW24sIG51bGxdOwogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICBsZXQgZSwKICAgICAgICAgICAgICAgIG4sCiAgICAgICAgICAgICAgICBzID0gQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCksCiAgICAgICAgICAgICAgICB1ID0gMDsKICAgICAgICAgICAgICBmb3IgKDs7KSB7CiAgICAgICAgICAgICAgICBsZXQgciA9ICExLAogICAgICAgICAgICAgICAgICBpID0gbnVsbDsKICAgICAgICAgICAgICAgIGlmICgKICAgICAgICAgICAgICAgICAgKChbZSwgbl0gPSB0aGlzLnByb2Nlc3NOZXh0RmlsZSgodCkgPT4gKHQgaW4gbyA/ICgoaSA9IG9bdF0pLCAhMSkgOiAoKHIgPSAhMCksICEwKSkpKSwKICAgICAgICAgICAgICAgICAgJ1NVQ0NFU1MnICE9PSBlLnN0YXRlKQogICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgaWYgKCFyICYmICgoc1tpXSA9IG4pLCArK3UgPT09IHQubGVuZ3RoKSkgewogICAgICAgICAgICAgICAgICBlLnJlYXNvbiA9ICdFUkFSX0VORF9BUkNISVZFJzsKICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgciA9ICdFUkFSX0VORF9BUkNISVZFJyAhPT0gZS5yZWFzb24gPyBbZSwgbnVsbF0gOiBbeyBzdGF0ZTogJ1NVQ0NFU1MnIH0sIHsgYXJjSGVhZGVyOiBpLCBmaWxlczogcyB9XTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9zZUFyYygpLCByCiAgICAgICAgICB9CiAgICAgICAgICBmaWxlQ3JlYXRlZCh0KSB7fQogICAgICAgICAgY2xvc2UodCkgewogICAgICAgICAgICB0aGlzLl9sYXN0RmlsZUNvbnRlbnQgPSB0aGlzLmNsb3NlRmlsZSh0KTsKICAgICAgICAgIH0KICAgICAgICAgIG9wZW5BcmModCwgZSkgewogIChuLkV4dC5jdXJyZW50ID0gdGhpcyksICh0aGlzLl9hcmNoaXZlID0gbmV3IHVucGFjay5SYXJBcmNoaXZlKCkpOwogICAgICAgICAgICBsZXQgciwKICAgICAgICAgICAgICBpID0gdGhpcy5fYXJjaGl2ZS5vcGVuKHRoaXMuX2ZpbGVQYXRoLCBlIHx8IHRoaXMuX3Bhc3N3b3JkLCB0KTsKICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAociA9CiAgICAgICAgICAgICAgICAwICE9PSBpLnN0YXRlLmVyckNvZGUKICAgICAgICAgICAgICAgICAgPyBbdGhpcy5nZXRGYWlsSW5mbyhpLnN0YXRlLmVyckNvZGUsIGkuc3RhdGUuZXJyVHlwZSksIG51bGxdCiAgICAgICAgICAgICAgICAgIDogWwogICAgICAgICAgICAgICAgICAgICAgeyBzdGF0ZTogJ1NVQ0NFU1MnIH0sCiAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1lbnQ6IGkuY29tbWVudCwKICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICB2b2x1bWU6IDAgIT0gKDEgJiBpLmZsYWdzKSwKICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NrOiAwICE9ICg0ICYgaS5mbGFncyksCiAgICAgICAgICAgICAgICAgICAgICAgICAgc29saWQ6IDAgIT0gKDggJiBpLmZsYWdzKSwKICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRoSW5mbzogMCAhPSAoMzIgJiBpLmZsYWdzKSwKICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvdmVyeVJlY29yZDogMCAhPSAoNjQgJiBpLmZsYWdzKSwKICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJFbmNyeXB0ZWQ6IDAgIT0gKDEyOCAmIGkuZmxhZ3MpLAogICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICBdKSwKICAgICAgICAgICAgICAobi5FeHQuY3VycmVudCA9IG51bGwpLAogICAgICAgICAgICAgIHIKICAgICAgICAgICAgKQogICAgICAgICAgfQogICAgICAgICAgcHJvY2Vzc05leHRGaWxlKHQpIHsKICAgICAgICAgICAgbGV0IGU7CiAgICAgICAgICAgIG4uRXh0LmN1cnJlbnQgPSB0aGlzOwogICAgICAgICAgICBsZXQgciA9IHRoaXMuX2FyY2hpdmUuZ2V0RmlsZUhlYWRlcigpLAogICAgICAgICAgICAgIGkgPSBbeyBzdGF0ZTogJ1NVQ0NFU1MnIH0sIG51bGxdOwogICAgICAgICAgICBpZiAoMCA9PT0gci5zdGF0ZS5lcnJDb2RlKSB7CiAgICAgICAgICAgICAgbGV0IGUgPSB0KHIubmFtZSk7CiAgICAgICAgICAgICAgdGhpcy5fbGFzdEZpbGVDb250ZW50ID0gbnVsbDsKICAgICAgICAgICAgICBsZXQgbiA9IHRoaXMuX2FyY2hpdmUucmVhZEZpbGUoZSk7CiAgICAgICAgICAgICAgMCA9PT0gbi5lcnJDb2RlIHx8CiAgICAgICAgICAgICAgICBlIHx8CiAgICAgICAgICAgICAgICAoKGlbMF0gPSB0aGlzLmdldEZhaWxJbmZvKG4uZXJyQ29kZSwgbi5lcnJUeXBlKSksCiAgICAgICAgICAgICAgICAyMiA9PT0gbi5lcnJDb2RlID8gKG4gPSB0aGlzLl9hcmNoaXZlLnJlYWRGaWxlKCEwKSkgOiAobi5lcnJDb2RlID0gMCkpLAogICAgICAgICAgICAgICAgMCA9PT0gbi5lcnJDb2RlCiAgICAgICAgICAgICAgICAgID8gKGlbMV0gPSB0aGlzLl9sYXN0RmlsZUNvbnRlbnQpCiAgICAgICAgICAgICAgICAgIDogKChyLnN0YXRlLmVyckNvZGUgPSBuLmVyckNvZGUpLCAoci5zdGF0ZS5lcnJUeXBlID0gbi5lcnJUeXBlKSksCiAgICAgICAgICAgICAgICAodGhpcy5fbGFzdEZpbGVDb250ZW50ID0gbnVsbCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAoZSA9CiAgICAgICAgICAgICAgICAwICE9PSByLnN0YXRlLmVyckNvZGUKICAgICAgICAgICAgICAgICAgPyBbdGhpcy5nZXRGYWlsSW5mbyhyLnN0YXRlLmVyckNvZGUsIHIuc3RhdGUuZXJyVHlwZSksIG51bGxdCiAgICAgICAgICAgICAgICAgIDogWwogICAgICAgICAgICAgICAgICAgICAgeyBzdGF0ZTogJ1NVQ0NFU1MnIH0sCiAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVIZWFkZXI6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiByLm5hbWUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuY3J5cHRlZDogMCAhPSAoNCAmIHIuZmxhZ3MpLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgc29saWQ6IDAgIT0gKDE2ICYgci5mbGFncyksCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3Rvcnk6IDAgIT0gKDMyICYgci5mbGFncyksCiAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgICBwYWNrU2l6ZTogci5wYWNrU2l6ZSwKICAgICAgICAgICAgICAgICAgICAgICAgICB1bnBTaXplOiByLnVucFNpemUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgY3JjOiByLmNyYywKICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lOiAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSBbNSwgNiwgNSwgNSwgNCwgN107CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgciA9IFtdOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgbiBvZiBlKSByLnB1c2godCAmICgoMSA8PCBuKSAtIDEpKSwgKHQgPj49IG4pOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG4gPSAodCkgPT4gKHQgPCAxMCA/ICcwJyArIHQgOiAnJyArIHQpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7MTk4MCArIChyID0gci5yZXZlcnNlKCkpWzBdfS0ke24oclsxXSl9LSR7bihyWzJdKX1gICsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYFQke24oclszXSl9OiR7bihyWzRdKX06JHtuKDIgKiByWzVdKX0uMDAwYAogICAgICAgICAgICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgICAgICAgICAgIH0pKHIudGltZSksCiAgICAgICAgICAgICAgICAgICAgICAgICAgdW5wVmVyOiBgJHtNYXRoLmZsb29yKHIudW5wVmVyIC8gMTApfS4ke3IudW5wVmVyICUgMTB9YCwKICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IChmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyA0ODogJ1N0b3JpbmcnLCA0OTogJ0Zhc3Rlc3QnLCA1MDogJ0Zhc3QnLCA1MTogJ05vcm1hbCcsIDUyOiAnR29vZCcsIDUzOiAnQmVzdCcgfVt0XSB8fAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVW5rbm93bicKICAgICAgICAgICAgICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICAgICAgICAgICAgICB9KShyLm1ldGhvZCksCiAgICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhY3Q6IGksCiAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIF0pLAogICAgICAgICAgICAgIChuLkV4dC5jdXJyZW50ID0gbnVsbCksCiAgICAgICAgICAgICAgZQogICAgICAgICAgICApCiAgICAgICAgICB9CiAgICAgICAgICBjbG9zZUFyYygpIHsKICAobi5FeHQuY3VycmVudCA9IHRoaXMpLCB0aGlzLl9hcmNoaXZlLmRlbGV0ZSgpLCAobi5FeHQuY3VycmVudCA9IG51bGwpLCAodGhpcy5fYXJjaGl2ZSA9IG51bGwpOwogICAgICAgICAgfQogICAgICAgICAgZ2V0RmFpbEluZm8odCwgZSkgewogICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogJ0ZBSUwnLCByZWFzb246IGlbdF0sIG1zZzogb1t0XSB9CiAgICAgICAgICB9CiAgICAgICAgfQogIChzLl9jdXJyZW50ID0gbnVsbCksIChlLkV4dHJhY3RvciA9IHMpOwogICAgICB9LAogICAgICBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnX19lc01vZHVsZScsIHsgdmFsdWU6ICEwIH0pLCAoZS5FeHQgPSB7IGN1cnJlbnQ6IG51bGwgfSk7CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogITAgfSksCiAgICAgICAgICAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgZm9yICh2YXIgciBpbiB0KSBlLmhhc093blByb3BlcnR5KHIpIHx8IChlW3JdID0gdFtyXSk7CiAgICAgICAgICB9KShyKDMpKTsKICAgICAgICB2YXIgbiA9IHIoMSk7CiAgICAgICAgZS5FeHQgPSBuLkV4dDsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiAhMCB9KTsKICAgICAgICBjb25zdCBuID0gcig0KSwKICAgICAgICAgIGkgPSByKDYpCiAgICAgICAgOyhlLmNyZWF0ZUV4dHJhY3RvckZyb21EYXRhID0gZnVuY3Rpb24gKHQsIGUgPSAnJykgewogICAgICAgICAgcmV0dXJuIG5ldyBuLkRhdGFFeHRyYWN0b3IodCwgZSkKICAgICAgICB9KSwKICAgICAgICAgIChlLmNyZWF0ZUV4dHJhY3RvckZyb21GaWxlID0gZnVuY3Rpb24gKHQsIGUgPSAnJywgciA9ICcnKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgaS5GaWxlRXh0cmFjdG9yKHQsIGUsIHIpCiAgICAgICAgICB9KTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiAhMCB9KTsKICAgICAgICBjb25zdCBuID0gcig1KSwKICAgICAgICAgIGkgPSByKDApOwogICAgICAgIGUuRGF0YUV4dHJhY3RvciA9IGNsYXNzIGV4dGVuZHMgaS5FeHRyYWN0b3IgewogICAgICAgICAgY29uc3RydWN0b3IodCwgZSkgewogICAgICAgICAgICBzdXBlcihlKSwgKHRoaXMuZGF0YUZpbGVzID0ge30pLCAodGhpcy5kYXRhRmlsZU1hcCA9IHt9KSwgKHRoaXMuY3VycmVudEZkID0gMSk7CiAgICAgICAgICAgIGxldCByID0geyBmaWxlOiBuZXcgbi5EYXRhRmlsZShuZXcgVWludDhBcnJheSh0KSksIGZkOiB0aGlzLmN1cnJlbnRGZCsrIH0KICAgICAgICAgICAgOyh0aGlzLl9maWxlUGF0aCA9ICdfZGVmYXVsdFVucmFySlNfLnJhcicpLAogICAgICAgICAgICAgICh0aGlzLmRhdGFGaWxlc1t0aGlzLl9maWxlUGF0aF0gPSByKSwKICAgICAgICAgICAgICAodGhpcy5kYXRhRmlsZU1hcFtyLmZkXSA9IHRoaXMuX2ZpbGVQYXRoKTsKICAgICAgICAgIH0KICAgICAgICAgIG9wZW4odCkgewogICAgICAgICAgICBsZXQgZSA9IHRoaXMuZGF0YUZpbGVzW3RdOwogICAgICAgICAgICByZXR1cm4gZSA/IGUuZmQgOiAwCiAgICAgICAgICB9CiAgICAgICAgICBjcmVhdGUodCkgewogICAgICAgICAgICBsZXQgZSA9IHRoaXMuY3VycmVudEZkKys7CiAgICAgICAgICAgIHJldHVybiAodGhpcy5kYXRhRmlsZXNbdF0gPSB7IGZpbGU6IG5ldyBuLkRhdGFGaWxlKCksIGZkOiB0aGlzLmN1cnJlbnRGZCsrIH0pLCAodGhpcy5kYXRhRmlsZU1hcFtlXSA9IHQpLCBlCiAgICAgICAgICB9CiAgICAgICAgICBjbG9zZUZpbGUodCkgewogICAgICAgICAgICBsZXQgZSA9IHRoaXMuZGF0YUZpbGVzW3RoaXMuZGF0YUZpbGVNYXBbdF1dOwogICAgICAgICAgICBpZiAoIWUpIHJldHVybiBudWxsCiAgICAgICAgICAgIGxldCByID0gZS5maWxlLnJlYWRBbGwoKTsKICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAxICE9PSB0ID8gKGRlbGV0ZSB0aGlzLmRhdGFGaWxlc1t0aGlzLmRhdGFGaWxlTWFwW3RdXSwgZGVsZXRlIHRoaXMuZGF0YUZpbGVNYXBbdF0pIDogZS5maWxlLnNlZWsoMCwgJ1NFVCcpLAogICAgICAgICAgICAgIHIKICAgICAgICAgICAgKQogICAgICAgICAgfQogICAgICAgICAgcmVhZCh0LCBlLCByKSB7CiAgICAgICAgICAgIGxldCBuID0gdGhpcy5kYXRhRmlsZXNbdGhpcy5kYXRhRmlsZU1hcFt0XV07CiAgICAgICAgICAgIGlmICghbikgcmV0dXJuIC0xCiAgICAgICAgICAgIGxldCBpID0gbi5maWxlLnJlYWQocik7CiAgICAgICAgICAgIHJldHVybiBudWxsID09PSBpID8gLTEgOiAodW5wYWNrLkhFQVBVOC5zZXQoaSwgZSksIGkuYnl0ZUxlbmd0aCkKICAgICAgICAgIH0KICAgICAgICAgIHdyaXRlKHQsIGUsIHIpIHsKICAgICAgICAgICAgbGV0IG4gPSB0aGlzLmRhdGFGaWxlc1t0aGlzLmRhdGFGaWxlTWFwW3RdXTsKICAgICAgICAgICAgcmV0dXJuICEhbiAmJiAobi5maWxlLndyaXRlKHVucGFjay5IRUFQVTguc2xpY2UoZSwgZSArIHIpKSwgITApCiAgICAgICAgICB9CiAgICAgICAgICB0ZWxsKHQpIHsKICAgICAgICAgICAgbGV0IGUgPSB0aGlzLmRhdGFGaWxlc1t0aGlzLmRhdGFGaWxlTWFwW3RdXTsKICAgICAgICAgICAgcmV0dXJuIGUgPyBlLmZpbGUudGVsbCgpIDogLTEKICAgICAgICAgIH0KICAgICAgICAgIHNlZWsodCwgZSwgcikgewogICAgICAgICAgICBsZXQgbiA9IHRoaXMuZGF0YUZpbGVzW3RoaXMuZGF0YUZpbGVNYXBbdF1dOwogICAgICAgICAgICByZXR1cm4gISFuICYmIG4uZmlsZS5zZWVrKGUsIHIpCiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiAhMCB9KTsKICAgICAgICBlLkRhdGFGaWxlID0gY2xhc3MgewogICAgICAgICAgY29uc3RydWN0b3IodCkgewogICh0aGlzLmJ1ZmZlcnMgPSBbXSksCiAgICAgICAgICAgICAgKHRoaXMucG9zID0gMCksCiAgICAgICAgICAgICAgKHRoaXMuc2l6ZSA9IDApLAogICAgICAgICAgICAgIHQgJiYgKHRoaXMuYnVmZmVycy5wdXNoKHQpLCAodGhpcy5zaXplID0gdC5ieXRlTGVuZ3RoKSwgKHRoaXMucG9zID0gMCkpOwogICAgICAgICAgfQogICAgICAgICAgcmVhZCh0KSB7CiAgICAgICAgICAgIGlmICgodGhpcy5mbGF0dGVuKCksIHQgKyB0aGlzLnBvcyA+IHRoaXMuc2l6ZSkpIHJldHVybiBudWxsCiAgICAgICAgICAgIGxldCBlID0gdGhpcy5wb3M7CiAgICAgICAgICAgIHJldHVybiAodGhpcy5wb3MgKz0gdCksIHRoaXMuYnVmZmVyc1swXS5zbGljZShlLCB0aGlzLnBvcykKICAgICAgICAgIH0KICAgICAgICAgIHJlYWRBbGwoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKSwgdGhpcy5idWZmZXJzWzBdCiAgICAgICAgICB9CiAgICAgICAgICB3cml0ZSh0KSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlcnMucHVzaCh0KSwgKHRoaXMuc2l6ZSArPSB0LmJ5dGVMZW5ndGgpLCAodGhpcy5wb3MgKz0gdC5ieXRlTGVuZ3RoKSwgITAKICAgICAgICAgIH0KICAgICAgICAgIHRlbGwoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcwogICAgICAgICAgfQogICAgICAgICAgc2Vlayh0LCBlKSB7CiAgICAgICAgICAgIGxldCByID0gdGhpcy5wb3M7CiAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgJ1NFVCcgPT09IGUgPyAociA9IHQpIDogJ0NVUicgPT09IGUgPyAociArPSB0KSA6IChyID0gdGhpcy5zaXplIC0gdCksCiAgICAgICAgICAgICAgIShyIDwgMCB8fCByID4gdGhpcy5zaXplIHx8ICgodGhpcy5wb3MgPSByKSwgMCkpCiAgICAgICAgICAgICkKICAgICAgICAgIH0KICAgICAgICAgIGZsYXR0ZW4oKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoIDw9IDEpIHJldHVybgogICAgICAgICAgICBsZXQgdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuc2l6ZSksCiAgICAgICAgICAgICAgZSA9IDA7CiAgICAgICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5idWZmZXJzKSB0LnNldChyLCBlKSwgKGUgKz0gci5ieXRlTGVuZ3RoKTsKICAgICAgICAgICAgdGhpcy5idWZmZXJzID0gW3RdOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiAhMCB9KTsKICAgICAgICAgIGNvbnN0IG4gPSByKDEyKSwKICAgICAgICAgICAgaSA9IHIoMTMpLAogICAgICAgICAgICBvID0gcigwKTsKICAgICAgICAgIGUuRmlsZUV4dHJhY3RvciA9IGNsYXNzIGV4dGVuZHMgby5FeHRyYWN0b3IgewogICAgICAgICAgICBjb25zdHJ1Y3Rvcih0LCBlLCByKSB7CiAgICAgICAgICAgICAgc3VwZXIociksICh0aGlzLl9maWxlUGF0aCA9IHQpLCAodGhpcy5maWxlTWFwID0ge30pLCAodGhpcy5fdGFyZ2V0ID0gZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgb3Blbih0KSB7CiAgICAgICAgICAgICAgbGV0IGUgPSBuLm9wZW5TeW5jKHQsICdyJyk7CiAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmZpbGVNYXBbZV0gPSB7IHNpemU6IG4uZnN0YXRTeW5jKGUpLnNpemUsIHBvczogMCwgbmFtZTogdCB9KSwgZQogICAgICAgICAgICB9CiAgICAgICAgICAgIGNyZWF0ZSh0KSB7CiAgICAgICAgICAgICAgbGV0IGUgPSBpLmpvaW4odGhpcy5fdGFyZ2V0LCB0KTsKICAgICAgICAgICAgICBpLnBhcnNlKGUpCiAgICAgICAgICAgICAgICAuZGlyLnNwbGl0KCcvJykKICAgICAgICAgICAgICAgIC5yZWR1Y2UoKHQsIGUpID0+ICgodCArPSBlICsgJy8nKSwgbi5leGlzdHNTeW5jKHQpIHx8IG4ubWtkaXJTeW5jKHQpLCB0KSwgJycpOwogICAgICAgICAgICAgIGxldCByID0gbi5vcGVuU3luYyhlLCAndycpOwogICAgICAgICAgICAgIHJldHVybiAodGhpcy5maWxlTWFwW3JdID0geyBzaXplOiAwLCBwb3M6IDAsIG5hbWU6IHQgfSksIHIKICAgICAgICAgICAgfQogICAgICAgICAgICBjbG9zZUZpbGUodCkgewogICAgICAgICAgICAgIHJldHVybiBkZWxldGUgdGhpcy5maWxlTWFwW3RdLCBuLmNsb3NlU3luYyh0KSwgbnVsbAogICAgICAgICAgICB9CiAgICAgICAgICAgIHJlYWQoZSwgciwgaSkgewogICAgICAgICAgICAgIGxldCBvID0gdGhpcy5maWxlTWFwW2VdLAogICAgICAgICAgICAgICAgcyA9IG5ldyB0KGkpLAogICAgICAgICAgICAgICAgdSA9IG4ucmVhZFN5bmMoZSwgcywgMCwgaSwgby5wb3MpOwogICAgICAgICAgICAgIHJldHVybiB1bnBhY2suSEVBUFU4LnNldChzLCByKSwgKG8ucG9zICs9IHUpLCB1CiAgICAgICAgICAgIH0KICAgICAgICAgICAgd3JpdGUoZSwgciwgaSkgewogICAgICAgICAgICAgIGxldCBvID0gdGhpcy5maWxlTWFwW2VdLAogICAgICAgICAgICAgICAgcyA9IG4ud3JpdGVTeW5jKGUsIG5ldyB0KHVucGFjay5IRUFQVTguc3ViYXJyYXkociwgciArIGkpKSwgMCwgaSk7CiAgICAgICAgICAgICAgcmV0dXJuIChvLnBvcyArPSBzKSwgKG8uc2l6ZSArPSBzKSwgcyA9PT0gaQogICAgICAgICAgICB9CiAgICAgICAgICAgIHRlbGwodCkgewogICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVNYXBbdF0ucG9zCiAgICAgICAgICAgIH0KICAgICAgICAgICAgc2Vlayh0LCBlLCByKSB7CiAgICAgICAgICAgICAgbGV0IG4gPSB0aGlzLmZpbGVNYXBbdF0sCiAgICAgICAgICAgICAgICBpID0gbi5wb3M7CiAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgICdTRVQnID09PSByID8gKGkgPSAwKSA6ICdFTkQnID09PSByICYmIChpID0gbi5zaXplKSwgISgoaSArPSBlKSA8IDAgfHwgaSA+IG4uc2l6ZSB8fCAoKG4ucG9zID0gaSksIDApKQogICAgICAgICAgICAgICkKICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICB9LmNhbGwodGhpcywgcig3KS5CdWZmZXIpKTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAgIC8qIQogICAgICAgICAgICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuCiAgICAgICAgICAgKgogICAgICAgICAgICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+CiAgICAgICAgICAgKiBAbGljZW5zZSAgTUlUCiAgICAgICAgICAgKi8KICAgICAgICAgIHZhciBuID0gcig5KSwKICAgICAgICAgICAgaSA9IHIoMTApLAogICAgICAgICAgICBvID0gcigxMSk7CiAgICAgICAgICBmdW5jdGlvbiBzKCkgewogICAgICAgICAgICByZXR1cm4gYS5UWVBFRF9BUlJBWV9TVVBQT1JUID8gMjE0NzQ4MzY0NyA6IDEwNzM3NDE4MjMKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHUodCwgZSkgewogICAgICAgICAgICBpZiAocygpIDwgZSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJykKICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICBhLlRZUEVEX0FSUkFZX1NVUFBPUlQKICAgICAgICAgICAgICAgID8gKCh0ID0gbmV3IFVpbnQ4QXJyYXkoZSkpLl9fcHJvdG9fXyA9IGEucHJvdG90eXBlKQogICAgICAgICAgICAgICAgOiAobnVsbCA9PT0gdCAmJiAodCA9IG5ldyBhKGUpKSwgKHQubGVuZ3RoID0gZSkpLAogICAgICAgICAgICAgIHQKICAgICAgICAgICAgKQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gYSh0LCBlLCByKSB7CiAgICAgICAgICAgIGlmICghKGEuVFlQRURfQVJSQVlfU1VQUE9SVCB8fCB0aGlzIGluc3RhbmNlb2YgYSkpIHJldHVybiBuZXcgYSh0LCBlLCByKQogICAgICAgICAgICBpZiAoJ251bWJlcicgPT0gdHlwZW9mIHQpIHsKICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGUpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJykKICAgICAgICAgICAgICByZXR1cm4gbCh0aGlzLCB0KQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBmKHRoaXMsIHQsIGUsIHIpCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBmKHQsIGUsIHIsIG4pIHsKICAgICAgICAgICAgaWYgKCdudW1iZXInID09IHR5cGVvZiBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCcidmFsdWUiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJykKICAgICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnICE9IHR5cGVvZiBBcnJheUJ1ZmZlciAmJiBlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIKICAgICAgICAgICAgICA/IChmdW5jdGlvbiAodCwgZSwgciwgbikgewogICAgICAgICAgICAgICAgICBpZiAoKGUuYnl0ZUxlbmd0aCwgciA8IDAgfHwgZS5ieXRlTGVuZ3RoIDwgcikpIHRocm93IG5ldyBSYW5nZUVycm9yKCInb2Zmc2V0JyBpcyBvdXQgb2YgYm91bmRzIikKICAgICAgICAgICAgICAgICAgaWYgKGUuYnl0ZUxlbmd0aCA8IHIgKyAobiB8fCAwKSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoIidsZW5ndGgnIGlzIG91dCBvZiBib3VuZHMiKQogICAgICAgICAgICAgICAgICBlID0KICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHIgJiYgdm9pZCAwID09PSBuCiAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBVaW50OEFycmF5KGUpCiAgICAgICAgICAgICAgICAgICAgICA6IHZvaWQgMCA9PT0gbgogICAgICAgICAgICAgICAgICAgICAgPyBuZXcgVWludDhBcnJheShlLCByKQogICAgICAgICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheShlLCByLCBuKTsKICAgICAgICAgICAgICAgICAgYS5UWVBFRF9BUlJBWV9TVVBQT1JUID8gKCh0ID0gZSkuX19wcm90b19fID0gYS5wcm90b3R5cGUpIDogKHQgPSBjKHQsIGUpKTsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHQKICAgICAgICAgICAgICAgIH0pKHQsIGUsIHIsIG4pCiAgICAgICAgICAgICAgOiAnc3RyaW5nJyA9PSB0eXBlb2YgZQogICAgICAgICAgICAgID8gKGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgKCdzdHJpbmcnID09IHR5cGVvZiByICYmICcnICE9PSByKSB8fCAociA9ICd1dGY4Jyk7CiAgICAgICAgICAgICAgICAgIGlmICghYS5pc0VuY29kaW5nKHIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCciZW5jb2RpbmciIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKQogICAgICAgICAgICAgICAgICB2YXIgbiA9IDAgfCBnKGUsIHIpLAogICAgICAgICAgICAgICAgICAgIGkgPSAodCA9IHUodCwgbikpLndyaXRlKGUsIHIpOwogICAgICAgICAgICAgICAgICBpICE9PSBuICYmICh0ID0gdC5zbGljZSgwLCBpKSk7CiAgICAgICAgICAgICAgICAgIHJldHVybiB0CiAgICAgICAgICAgICAgICB9KSh0LCBlLCByKQogICAgICAgICAgICAgIDogKGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgICAgIGlmIChhLmlzQnVmZmVyKGUpKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIHIgPSAwIHwgcChlLmxlbmd0aCk7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAgPT09ICh0ID0gdSh0LCByKSkubGVuZ3RoID8gdCA6IChlLmNvcHkodCwgMCwgMCwgciksIHQpCiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgaWYgKGUpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoKCd1bmRlZmluZWQnICE9IHR5cGVvZiBBcnJheUJ1ZmZlciAmJiBlLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBlKQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdudW1iZXInICE9IHR5cGVvZiBlLmxlbmd0aCB8fAogICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdCAhPSB0CiAgICAgICAgICAgICAgICAgICAgICAgIH0pKGUubGVuZ3RoKQogICAgICAgICAgICAgICAgICAgICAgICA/IHUodCwgMCkKICAgICAgICAgICAgICAgICAgICAgICAgOiBjKHQsIGUpCiAgICAgICAgICAgICAgICAgICAgaWYgKCdCdWZmZXInID09PSBlLnR5cGUgJiYgbyhlLmRhdGEpKSByZXR1cm4gYyh0LCBlLmRhdGEpCiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigKICAgICAgICAgICAgICAgICAgICAnRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicKICAgICAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgfSkodCwgZSkKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGgodCkgewogICAgICAgICAgICBpZiAoJ251bWJlcicgIT0gdHlwZW9mIHQpIHRocm93IG5ldyBUeXBlRXJyb3IoJyJzaXplIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJykKICAgICAgICAgICAgaWYgKHQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignInNpemUiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJykKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGwodCwgZSkgewogICAgICAgICAgICBpZiAoKGgoZSksICh0ID0gdSh0LCBlIDwgMCA/IDAgOiAwIHwgcChlKSkpLCAhYS5UWVBFRF9BUlJBWV9TVVBQT1JUKSkgZm9yICh2YXIgciA9IDA7IHIgPCBlOyArK3IpIHRbcl0gPSAwOwogICAgICAgICAgICByZXR1cm4gdAogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gYyh0LCBlKSB7CiAgICAgICAgICAgIHZhciByID0gZS5sZW5ndGggPCAwID8gMCA6IDAgfCBwKGUubGVuZ3RoKTsKICAgICAgICAgICAgdCA9IHUodCwgcik7CiAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgcjsgbiArPSAxKSB0W25dID0gMjU1ICYgZVtuXTsKICAgICAgICAgICAgcmV0dXJuIHQKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHAodCkgewogICAgICAgICAgICBpZiAodCA+PSBzKCkpCiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoCiAgICAgICAgICAgICAgICAnQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplOiAweCcgKyBzKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycKICAgICAgICAgICAgICApCiAgICAgICAgICAgIHJldHVybiAwIHwgdAogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gZyh0LCBlKSB7CiAgICAgICAgICAgIGlmIChhLmlzQnVmZmVyKHQpKSByZXR1cm4gdC5sZW5ndGgKICAgICAgICAgICAgaWYgKAogICAgICAgICAgICAgICd1bmRlZmluZWQnICE9IHR5cGVvZiBBcnJheUJ1ZmZlciAmJgogICAgICAgICAgICAgICdmdW5jdGlvbicgPT0gdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyAmJgogICAgICAgICAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcodCkgfHwgdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKQogICAgICAgICAgICApCiAgICAgICAgICAgICAgcmV0dXJuIHQuYnl0ZUxlbmd0aAogICAgICAgICAgICAnc3RyaW5nJyAhPSB0eXBlb2YgdCAmJiAodCA9ICcnICsgdCk7CiAgICAgICAgICAgIHZhciByID0gdC5sZW5ndGg7CiAgICAgICAgICAgIGlmICgwID09PSByKSByZXR1cm4gMAogICAgICAgICAgICBmb3IgKHZhciBuID0gITE7IDsgKQogICAgICAgICAgICAgIHN3aXRjaCAoZSkgewogICAgICAgICAgICAgICAgY2FzZSAnYXNjaWknOgogICAgICAgICAgICAgICAgY2FzZSAnbGF0aW4xJzoKICAgICAgICAgICAgICAgIGNhc2UgJ2JpbmFyeSc6CiAgICAgICAgICAgICAgICAgIHJldHVybiByCiAgICAgICAgICAgICAgICBjYXNlICd1dGY4JzoKICAgICAgICAgICAgICAgIGNhc2UgJ3V0Zi04JzoKICAgICAgICAgICAgICAgIGNhc2Ugdm9pZCAwOgogICAgICAgICAgICAgICAgICByZXR1cm4gayh0KS5sZW5ndGgKICAgICAgICAgICAgICAgIGNhc2UgJ3VjczInOgogICAgICAgICAgICAgICAgY2FzZSAndWNzLTInOgogICAgICAgICAgICAgICAgY2FzZSAndXRmMTZsZSc6CiAgICAgICAgICAgICAgICBjYXNlICd1dGYtMTZsZSc6CiAgICAgICAgICAgICAgICAgIHJldHVybiAyICogcgogICAgICAgICAgICAgICAgY2FzZSAnaGV4JzoKICAgICAgICAgICAgICAgICAgcmV0dXJuIHIgPj4+IDEKICAgICAgICAgICAgICAgIGNhc2UgJ2Jhc2U2NCc6CiAgICAgICAgICAgICAgICAgIHJldHVybiBqKHQpLmxlbmd0aAogICAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgICAgaWYgKG4pIHJldHVybiBrKHQpLmxlbmd0aAogICAgICAgICAgICAgICAgICA7KGUgPSAoJycgKyBlKS50b0xvd2VyQ2FzZSgpKSwgKG4gPSAhMCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gZCh0LCBlLCByKSB7CiAgICAgICAgICAgIHZhciBuID0gdFtlXQogICAgICAgICAgICA7KHRbZV0gPSB0W3JdKSwgKHRbcl0gPSBuKTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHkodCwgZSwgciwgbiwgaSkgewogICAgICAgICAgICBpZiAoMCA9PT0gdC5sZW5ndGgpIHJldHVybiAtMQogICAgICAgICAgICBpZiAoCiAgICAgICAgICAgICAgKCdzdHJpbmcnID09IHR5cGVvZiByCiAgICAgICAgICAgICAgICA/ICgobiA9IHIpLCAociA9IDApKQogICAgICAgICAgICAgICAgOiByID4gMjE0NzQ4MzY0NwogICAgICAgICAgICAgICAgPyAociA9IDIxNDc0ODM2NDcpCiAgICAgICAgICAgICAgICA6IHIgPCAtMjE0NzQ4MzY0OCAmJiAociA9IC0yMTQ3NDgzNjQ4KSwKICAgICAgICAgICAgICAociA9ICtyKSwKICAgICAgICAgICAgICBpc05hTihyKSAmJiAociA9IGkgPyAwIDogdC5sZW5ndGggLSAxKSwKICAgICAgICAgICAgICByIDwgMCAmJiAociA9IHQubGVuZ3RoICsgciksCiAgICAgICAgICAgICAgciA+PSB0Lmxlbmd0aCkKICAgICAgICAgICAgKSB7CiAgICAgICAgICAgICAgaWYgKGkpIHJldHVybiAtMQogICAgICAgICAgICAgIHIgPSB0Lmxlbmd0aCAtIDE7CiAgICAgICAgICAgIH0gZWxzZSBpZiAociA8IDApIHsKICAgICAgICAgICAgICBpZiAoIWkpIHJldHVybiAtMQogICAgICAgICAgICAgIHIgPSAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICgoJ3N0cmluZycgPT0gdHlwZW9mIGUgJiYgKGUgPSBhLmZyb20oZSwgbikpLCBhLmlzQnVmZmVyKGUpKSkgcmV0dXJuIDAgPT09IGUubGVuZ3RoID8gLTEgOiB3KHQsIGUsIHIsIG4sIGkpCiAgICAgICAgICAgIGlmICgnbnVtYmVyJyA9PSB0eXBlb2YgZSkKICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgKGUgJj0gMjU1KSwKICAgICAgICAgICAgICAgIGEuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mCiAgICAgICAgICAgICAgICAgID8gaQogICAgICAgICAgICAgICAgICAgID8gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHQsIGUsIHIpCiAgICAgICAgICAgICAgICAgICAgOiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKHQsIGUsIHIpCiAgICAgICAgICAgICAgICAgIDogdyh0LCBbZV0sIHIsIG4sIGkpCiAgICAgICAgICAgICAgKQogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gdyh0LCBlLCByLCBuLCBpKSB7CiAgICAgICAgICAgIHZhciBvLAogICAgICAgICAgICAgIHMgPSAxLAogICAgICAgICAgICAgIHUgPSB0Lmxlbmd0aCwKICAgICAgICAgICAgICBhID0gZS5sZW5ndGg7CiAgICAgICAgICAgIGlmICgKICAgICAgICAgICAgICB2b2lkIDAgIT09IG4gJiYKICAgICAgICAgICAgICAoJ3VjczInID09PSAobiA9IFN0cmluZyhuKS50b0xvd2VyQ2FzZSgpKSB8fCAndWNzLTInID09PSBuIHx8ICd1dGYxNmxlJyA9PT0gbiB8fCAndXRmLTE2bGUnID09PSBuKQogICAgICAgICAgICApIHsKICAgICAgICAgICAgICBpZiAodC5sZW5ndGggPCAyIHx8IGUubGVuZ3RoIDwgMikgcmV0dXJuIC0xCiAgICAgICAgICAgICAgOyhzID0gMiksICh1IC89IDIpLCAoYSAvPSAyKSwgKHIgLz0gMik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZnVuY3Rpb24gZih0LCBlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIDEgPT09IHMgPyB0W2VdIDogdC5yZWFkVUludDE2QkUoZSAqIHMpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGkpIHsKICAgICAgICAgICAgICB2YXIgaCA9IC0xOwogICAgICAgICAgICAgIGZvciAobyA9IHI7IG8gPCB1OyBvKyspCiAgICAgICAgICAgICAgICBpZiAoZih0LCBvKSA9PT0gZihlLCAtMSA9PT0gaCA/IDAgOiBvIC0gaCkpIHsKICAgICAgICAgICAgICAgICAgaWYgKCgtMSA9PT0gaCAmJiAoaCA9IG8pLCBvIC0gaCArIDEgPT09IGEpKSByZXR1cm4gaCAqIHMKICAgICAgICAgICAgICAgIH0gZWxzZSAtMSAhPT0gaCAmJiAobyAtPSBvIC0gaCksIChoID0gLTEpOwogICAgICAgICAgICB9IGVsc2UKICAgICAgICAgICAgICBmb3IgKHIgKyBhID4gdSAmJiAociA9IHUgLSBhKSwgbyA9IHI7IG8gPj0gMDsgby0tKSB7CiAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gITAsIGMgPSAwOyBjIDwgYTsgYysrKQogICAgICAgICAgICAgICAgICBpZiAoZih0LCBvICsgYykgIT09IGYoZSwgYykpIHsKICAgICAgICAgICAgICAgICAgICBsID0gITE7CiAgICAgICAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKGwpIHJldHVybiBvCiAgICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gLTEKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIEUodCwgZSwgciwgbikgewogICAgICAgICAgICByID0gTnVtYmVyKHIpIHx8IDA7CiAgICAgICAgICAgIHZhciBpID0gdC5sZW5ndGggLSByOwogICAgICAgICAgICBuID8gKG4gPSBOdW1iZXIobikpID4gaSAmJiAobiA9IGkpIDogKG4gPSBpKTsKICAgICAgICAgICAgdmFyIG8gPSBlLmxlbmd0aDsKICAgICAgICAgICAgaWYgKG8gJSAyICE9IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpCiAgICAgICAgICAgIG4gPiBvIC8gMiAmJiAobiA9IG8gLyAyKTsKICAgICAgICAgICAgZm9yICh2YXIgcyA9IDA7IHMgPCBuOyArK3MpIHsKICAgICAgICAgICAgICB2YXIgdSA9IHBhcnNlSW50KGUuc3Vic3RyKDIgKiBzLCAyKSwgMTYpOwogICAgICAgICAgICAgIGlmIChpc05hTih1KSkgcmV0dXJuIHMKICAgICAgICAgICAgICB0W3IgKyBzXSA9IHU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHMKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHYodCwgZSwgciwgbikgewogICAgICAgICAgICByZXR1cm4geihrKGUsIHQubGVuZ3RoIC0gciksIHQsIHIsIG4pCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBBKHQsIGUsIHIsIG4pIHsKICAgICAgICAgICAgcmV0dXJuIHooCiAgICAgICAgICAgICAgKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICBmb3IgKHZhciBlID0gW10sIHIgPSAwOyByIDwgdC5sZW5ndGg7ICsrcikgZS5wdXNoKDI1NSAmIHQuY2hhckNvZGVBdChyKSk7CiAgICAgICAgICAgICAgICByZXR1cm4gZQogICAgICAgICAgICAgIH0pKGUpLAogICAgICAgICAgICAgIHQsCiAgICAgICAgICAgICAgciwKICAgICAgICAgICAgICBuCiAgICAgICAgICAgICkKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIF8odCwgZSwgciwgbikgewogICAgICAgICAgICByZXR1cm4gQSh0LCBlLCByLCBuKQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gYih0LCBlLCByLCBuKSB7CiAgICAgICAgICAgIHJldHVybiB6KGooZSksIHQsIHIsIG4pCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBtKHQsIGUsIHIsIG4pIHsKICAgICAgICAgICAgcmV0dXJuIHooCiAgICAgICAgICAgICAgKGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgICBmb3IgKHZhciByLCBuLCBpLCBvID0gW10sIHMgPSAwOyBzIDwgdC5sZW5ndGggJiYgISgoZSAtPSAyKSA8IDApOyArK3MpCiAgICAgICAgICAgICAgICAgIChyID0gdC5jaGFyQ29kZUF0KHMpKSwgKG4gPSByID4+IDgpLCAoaSA9IHIgJSAyNTYpLCBvLnB1c2goaSksIG8ucHVzaChuKTsKICAgICAgICAgICAgICAgIHJldHVybiBvCiAgICAgICAgICAgICAgfSkoZSwgdC5sZW5ndGggLSByKSwKICAgICAgICAgICAgICB0LAogICAgICAgICAgICAgIHIsCiAgICAgICAgICAgICAgbgogICAgICAgICAgICApCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBSKHQsIGUsIHIpIHsKICAgICAgICAgICAgcmV0dXJuIDAgPT09IGUgJiYgciA9PT0gdC5sZW5ndGggPyBuLmZyb21CeXRlQXJyYXkodCkgOiBuLmZyb21CeXRlQXJyYXkodC5zbGljZShlLCByKSkKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIFModCwgZSwgcikgewogICAgICAgICAgICByID0gTWF0aC5taW4odC5sZW5ndGgsIHIpOwogICAgICAgICAgICBmb3IgKHZhciBuID0gW10sIGkgPSBlOyBpIDwgcjsgKSB7CiAgICAgICAgICAgICAgdmFyIG8sCiAgICAgICAgICAgICAgICBzLAogICAgICAgICAgICAgICAgdSwKICAgICAgICAgICAgICAgIGEsCiAgICAgICAgICAgICAgICBmID0gdFtpXSwKICAgICAgICAgICAgICAgIGggPSBudWxsLAogICAgICAgICAgICAgICAgbCA9IGYgPiAyMzkgPyA0IDogZiA+IDIyMyA/IDMgOiBmID4gMTkxID8gMiA6IDE7CiAgICAgICAgICAgICAgaWYgKGkgKyBsIDw9IHIpCiAgICAgICAgICAgICAgICBzd2l0Y2ggKGwpIHsKICAgICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgIGYgPCAxMjggJiYgKGggPSBmKTsKICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgICAgICAgMTI4ID09ICgxOTIgJiAobyA9IHRbaSArIDFdKSkgJiYgKGEgPSAoKDMxICYgZikgPDwgNikgfCAoNjMgJiBvKSkgPiAxMjcgJiYgKGggPSBhKTsKICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgICBjYXNlIDM6CiAgKG8gPSB0W2kgKyAxXSksCiAgICAgICAgICAgICAgICAgICAgICAocyA9IHRbaSArIDJdKSwKICAgICAgICAgICAgICAgICAgICAgIDEyOCA9PSAoMTkyICYgbykgJiYKICAgICAgICAgICAgICAgICAgICAgICAgMTI4ID09ICgxOTIgJiBzKSAmJgogICAgICAgICAgICAgICAgICAgICAgICAoYSA9ICgoMTUgJiBmKSA8PCAxMikgfCAoKDYzICYgbykgPDwgNikgfCAoNjMgJiBzKSkgPiAyMDQ3ICYmCiAgICAgICAgICAgICAgICAgICAgICAgIChhIDwgNTUyOTYgfHwgYSA+IDU3MzQzKSAmJgogICAgICAgICAgICAgICAgICAgICAgICAoaCA9IGEpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICAgIGNhc2UgNDoKICAobyA9IHRbaSArIDFdKSwKICAgICAgICAgICAgICAgICAgICAgIChzID0gdFtpICsgMl0pLAogICAgICAgICAgICAgICAgICAgICAgKHUgPSB0W2kgKyAzXSksCiAgICAgICAgICAgICAgICAgICAgICAxMjggPT0gKDE5MiAmIG8pICYmCiAgICAgICAgICAgICAgICAgICAgICAgIDEyOCA9PSAoMTkyICYgcykgJiYKICAgICAgICAgICAgICAgICAgICAgICAgMTI4ID09ICgxOTIgJiB1KSAmJgogICAgICAgICAgICAgICAgICAgICAgICAoYSA9ICgoMTUgJiBmKSA8PCAxOCkgfCAoKDYzICYgbykgPDwgMTIpIHwgKCg2MyAmIHMpIDw8IDYpIHwgKDYzICYgdSkpID4gNjU1MzUgJiYKICAgICAgICAgICAgICAgICAgICAgICAgYSA8IDExMTQxMTIgJiYKICAgICAgICAgICAgICAgICAgICAgICAgKGggPSBhKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBudWxsID09PSBoCiAgICAgICAgICAgICAgICA/ICgoaCA9IDY1NTMzKSwgKGwgPSAxKSkKICAgICAgICAgICAgICAgIDogaCA+IDY1NTM1ICYmICgoaCAtPSA2NTUzNiksIG4ucHVzaCgoKGggPj4+IDEwKSAmIDEwMjMpIHwgNTUyOTYpLCAoaCA9IDU2MzIwIHwgKDEwMjMgJiBoKSkpLAogICAgICAgICAgICAgICAgbi5wdXNoKGgpLAogICAgICAgICAgICAgICAgKGkgKz0gbCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgIHZhciBlID0gdC5sZW5ndGg7CiAgICAgICAgICAgICAgaWYgKGUgPD0gVCkgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCB0KQogICAgICAgICAgICAgIHZhciByID0gJycsCiAgICAgICAgICAgICAgICBuID0gMDsKICAgICAgICAgICAgICBmb3IgKDsgbiA8IGU7ICkgciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgdC5zbGljZShuLCAobiArPSBUKSkpOwogICAgICAgICAgICAgIHJldHVybiByCiAgICAgICAgICAgIH0pKG4pCiAgICAgICAgICB9CiAgKGUuQnVmZmVyID0gYSksCiAgICAgICAgICAgIChlLlNsb3dCdWZmZXIgPSBmdW5jdGlvbiAodCkgewogICt0ICE9IHQgJiYgKHQgPSAwKTsKICAgICAgICAgICAgICByZXR1cm4gYS5hbGxvYygrdCkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChlLklOU1BFQ1RfTUFYX0JZVEVTID0gNTApLAogICAgICAgICAgICAoYS5UWVBFRF9BUlJBWV9TVVBQT1JUID0KICAgICAgICAgICAgICB2b2lkIDAgIT09IHQuVFlQRURfQVJSQVlfU1VQUE9SVAogICAgICAgICAgICAgICAgPyB0LlRZUEVEX0FSUkFZX1NVUFBPUlQKICAgICAgICAgICAgICAgIDogKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBuZXcgVWludDhBcnJheSgxKTsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICAgICAgICAgICh0Ll9fcHJvdG9fXyA9IHsKICAgICAgICAgICAgICAgICAgICAgICAgICBfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLAogICAgICAgICAgICAgICAgICAgICAgICAgIGZvbzogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDQyCiAgICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgfSksCiAgICAgICAgICAgICAgICAgICAgICAgIDQyID09PSB0LmZvbygpICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIHQuc3ViYXJyYXkgJiYgMCA9PT0gdC5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoCiAgICAgICAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAodCkgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICExCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9KSgpKSwKICAgICAgICAgICAgKGUua01heExlbmd0aCA9IHMoKSksCiAgICAgICAgICAgIChhLnBvb2xTaXplID0gODE5MiksCiAgICAgICAgICAgIChhLl9hdWdtZW50ID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICByZXR1cm4gKHQuX19wcm90b19fID0gYS5wcm90b3R5cGUpLCB0CiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5mcm9tID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICAgICAgICByZXR1cm4gZihudWxsLCB0LCBlLCByKQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgYS5UWVBFRF9BUlJBWV9TVVBQT1JUICYmCiAgICAgICAgICAgICAgKChhLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZSksCiAgICAgICAgICAgICAgKGEuX19wcm90b19fID0gVWludDhBcnJheSksCiAgICAgICAgICAgICAgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFN5bWJvbCAmJgogICAgICAgICAgICAgICAgU3ltYm9sLnNwZWNpZXMgJiYKICAgICAgICAgICAgICAgIGFbU3ltYm9sLnNwZWNpZXNdID09PSBhICYmCiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgU3ltYm9sLnNwZWNpZXMsIHsgdmFsdWU6IG51bGwsIGNvbmZpZ3VyYWJsZTogITAgfSkpLAogICAgICAgICAgICAoYS5hbGxvYyA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAodCwgZSwgciwgbikgewogICAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgICAgaChlKSwKICAgICAgICAgICAgICAgICAgZSA8PSAwCiAgICAgICAgICAgICAgICAgICAgPyB1KHQsIGUpCiAgICAgICAgICAgICAgICAgICAgOiB2b2lkIDAgIT09IHIKICAgICAgICAgICAgICAgICAgICA/ICdzdHJpbmcnID09IHR5cGVvZiBuCiAgICAgICAgICAgICAgICAgICAgICA/IHUodCwgZSkuZmlsbChyLCBuKQogICAgICAgICAgICAgICAgICAgICAgOiB1KHQsIGUpLmZpbGwocikKICAgICAgICAgICAgICAgICAgICA6IHUodCwgZSkKICAgICAgICAgICAgICAgICkKICAgICAgICAgICAgICB9KShudWxsLCB0LCBlLCByKQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgIHJldHVybiBsKG51bGwsIHQpCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgIHJldHVybiBsKG51bGwsIHQpCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5pc0J1ZmZlciA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgcmV0dXJuICEobnVsbCA9PSB0IHx8ICF0Ll9pc0J1ZmZlcikKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLmNvbXBhcmUgPSBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgIGlmICghYS5pc0J1ZmZlcih0KSB8fCAhYS5pc0J1ZmZlcihlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpCiAgICAgICAgICAgICAgaWYgKHQgPT09IGUpIHJldHVybiAwCiAgICAgICAgICAgICAgZm9yICh2YXIgciA9IHQubGVuZ3RoLCBuID0gZS5sZW5ndGgsIGkgPSAwLCBvID0gTWF0aC5taW4ociwgbik7IGkgPCBvOyArK2kpCiAgICAgICAgICAgICAgICBpZiAodFtpXSAhPT0gZVtpXSkgewogIChyID0gdFtpXSksIChuID0gZVtpXSk7CiAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIHIgPCBuID8gLTEgOiBuIDwgciA/IDEgOiAwCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5pc0VuY29kaW5nID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICBzd2l0Y2ggKFN0cmluZyh0KS50b0xvd2VyQ2FzZSgpKSB7CiAgICAgICAgICAgICAgICBjYXNlICdoZXgnOgogICAgICAgICAgICAgICAgY2FzZSAndXRmOCc6CiAgICAgICAgICAgICAgICBjYXNlICd1dGYtOCc6CiAgICAgICAgICAgICAgICBjYXNlICdhc2NpaSc6CiAgICAgICAgICAgICAgICBjYXNlICdsYXRpbjEnOgogICAgICAgICAgICAgICAgY2FzZSAnYmluYXJ5JzoKICAgICAgICAgICAgICAgIGNhc2UgJ2Jhc2U2NCc6CiAgICAgICAgICAgICAgICBjYXNlICd1Y3MyJzoKICAgICAgICAgICAgICAgIGNhc2UgJ3Vjcy0yJzoKICAgICAgICAgICAgICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICAgICAgICAgICAgY2FzZSAndXRmLTE2bGUnOgogICAgICAgICAgICAgICAgICByZXR1cm4gITAKICAgICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICAgIHJldHVybiAhMQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLmNvbmNhdCA9IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgaWYgKCFvKHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCcibGlzdCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJykKICAgICAgICAgICAgICBpZiAoMCA9PT0gdC5sZW5ndGgpIHJldHVybiBhLmFsbG9jKDApCiAgICAgICAgICAgICAgdmFyIHI7CiAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gZSkgZm9yIChlID0gMCwgciA9IDA7IHIgPCB0Lmxlbmd0aDsgKytyKSBlICs9IHRbcl0ubGVuZ3RoOwogICAgICAgICAgICAgIHZhciBuID0gYS5hbGxvY1Vuc2FmZShlKSwKICAgICAgICAgICAgICAgIGkgPSAwOwogICAgICAgICAgICAgIGZvciAociA9IDA7IHIgPCB0Lmxlbmd0aDsgKytyKSB7CiAgICAgICAgICAgICAgICB2YXIgcyA9IHRbcl07CiAgICAgICAgICAgICAgICBpZiAoIWEuaXNCdWZmZXIocykpIHRocm93IG5ldyBUeXBlRXJyb3IoJyJsaXN0IiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKQogICAgICAgICAgICAgICAgcy5jb3B5KG4sIGkpLCAoaSArPSBzLmxlbmd0aCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiBuCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5ieXRlTGVuZ3RoID0gZyksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5faXNCdWZmZXIgPSAhMCksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmxlbmd0aDsKICAgICAgICAgICAgICBpZiAodCAlIDIgIT0gMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJykKICAgICAgICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHQ7IGUgKz0gMikgZCh0aGlzLCBlLCBlICsgMSk7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmxlbmd0aDsKICAgICAgICAgICAgICBpZiAodCAlIDQgIT0gMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJykKICAgICAgICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IHQ7IGUgKz0gNCkgZCh0aGlzLCBlLCBlICsgMyksIGQodGhpcywgZSArIDEsIGUgKyAyKTsKICAgICAgICAgICAgICByZXR1cm4gdGhpcwogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMubGVuZ3RoOwogICAgICAgICAgICAgIGlmICh0ICUgOCAhPSAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKQogICAgICAgICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdDsgZSArPSA4KQogICAgICAgICAgICAgICAgZCh0aGlzLCBlLCBlICsgNyksIGQodGhpcywgZSArIDEsIGUgKyA2KSwgZCh0aGlzLCBlICsgMiwgZSArIDUpLCBkKHRoaXMsIGUgKyAzLCBlICsgNCk7CiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICB2YXIgdCA9IDAgfCB0aGlzLmxlbmd0aDsKICAgICAgICAgICAgICByZXR1cm4gMCA9PT0gdAogICAgICAgICAgICAgICAgPyAnJwogICAgICAgICAgICAgICAgOiAwID09PSBhcmd1bWVudHMubGVuZ3RoCiAgICAgICAgICAgICAgICA/IFModGhpcywgMCwgdCkKICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICAgICAgICAgICAgICB2YXIgbiA9ICExOwogICAgICAgICAgICAgICAgICAgIGlmICgoKHZvaWQgMCA9PT0gZSB8fCBlIDwgMCkgJiYgKGUgPSAwKSwgZSA+IHRoaXMubGVuZ3RoKSkgcmV0dXJuICcnCiAgICAgICAgICAgICAgICAgICAgaWYgKCgodm9pZCAwID09PSByIHx8IHIgPiB0aGlzLmxlbmd0aCkgJiYgKHIgPSB0aGlzLmxlbmd0aCksIHIgPD0gMCkpIHJldHVybiAnJwogICAgICAgICAgICAgICAgICAgIGlmICgociA+Pj49IDApIDw9IChlID4+Pj0gMCkpIHJldHVybiAnJwogICAgICAgICAgICAgICAgICAgIGZvciAodCB8fCAodCA9ICd1dGY4Jyk7IDsgKQogICAgICAgICAgICAgICAgICAgICAgc3dpdGNoICh0KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hleCc6CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFUodGhpcywgZSwgcikKICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXRmOCc6CiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3V0Zi04JzoKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUyh0aGlzLCBlLCByKQogICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhc2NpaSc6CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFAodGhpcywgZSwgcikKICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGF0aW4xJzoKICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYmluYXJ5JzoKICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQyh0aGlzLCBlLCByKQogICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdiYXNlNjQnOgogICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBSKHRoaXMsIGUsIHIpCiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VjczInOgogICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1Y3MtMic6CiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd1dGYtMTZsZSc6CiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEIodGhpcywgZSwgcikKICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobikgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIHQpCiAgICAgICAgICAgICAgICAgICAgICAgICAgOyh0ID0gKHQgKyAnJykudG9Mb3dlckNhc2UoKSksIChuID0gITApOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgIGlmICghYS5pc0J1ZmZlcih0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpCiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMgPT09IHQgfHwgMCA9PT0gYS5jb21wYXJlKHRoaXMsIHQpCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICB2YXIgdCA9ICcnLAogICAgICAgICAgICAgICAgciA9IGUuSU5TUEVDVF9NQVhfQllURVM7CiAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoID4gMCAmJgogICAgICAgICAgICAgICAgICAoKHQgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCByKS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJykpLCB0aGlzLmxlbmd0aCA+IHIgJiYgKHQgKz0gJyAuLi4gJykpLAogICAgICAgICAgICAgICAgJzxCdWZmZXIgJyArIHQgKyAnPicKICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpKSB7CiAgICAgICAgICAgICAgaWYgKCFhLmlzQnVmZmVyKHQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJykKICAgICAgICAgICAgICBpZiAoCiAgICAgICAgICAgICAgICAodm9pZCAwID09PSBlICYmIChlID0gMCksCiAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHIgJiYgKHIgPSB0ID8gdC5sZW5ndGggOiAwKSwKICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gbiAmJiAobiA9IDApLAogICAgICAgICAgICAgICAgdm9pZCAwID09PSBpICYmIChpID0gdGhpcy5sZW5ndGgpLAogICAgICAgICAgICAgICAgZSA8IDAgfHwgciA+IHQubGVuZ3RoIHx8IG4gPCAwIHx8IGkgPiB0aGlzLmxlbmd0aCkKICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JykKICAgICAgICAgICAgICBpZiAobiA+PSBpICYmIGUgPj0gcikgcmV0dXJuIDAKICAgICAgICAgICAgICBpZiAobiA+PSBpKSByZXR1cm4gLTEKICAgICAgICAgICAgICBpZiAoZSA+PSByKSByZXR1cm4gMQogICAgICAgICAgICAgIGlmICgoKGUgPj4+PSAwKSwgKHIgPj4+PSAwKSwgKG4gPj4+PSAwKSwgKGkgPj4+PSAwKSwgdGhpcyA9PT0gdCkpIHJldHVybiAwCiAgICAgICAgICAgICAgZm9yICgKICAgICAgICAgICAgICAgIHZhciBvID0gaSAtIG4sIHMgPSByIC0gZSwgdSA9IE1hdGgubWluKG8sIHMpLCBmID0gdGhpcy5zbGljZShuLCBpKSwgaCA9IHQuc2xpY2UoZSwgciksIGwgPSAwOwogICAgICAgICAgICAgICAgbCA8IHU7CiAgICAgICAgICAgICAgICArK2wKICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICBpZiAoZltsXSAhPT0gaFtsXSkgewogIChvID0gZltsXSksIChzID0gaFtsXSk7CiAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIG8gPCBzID8gLTEgOiBzIDwgbyA/IDEgOiAwCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgIHJldHVybiAtMSAhPT0gdGhpcy5pbmRleE9mKHQsIGUsIHIpCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgcmV0dXJuIHkodGhpcywgdCwgZSwgciwgITApCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgIHJldHVybiB5KHRoaXMsIHQsIGUsIHIsICExKQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHsKICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSBlKSAobiA9ICd1dGY4JyksIChyID0gdGhpcy5sZW5ndGgpLCAoZSA9IDApOwogICAgICAgICAgICAgIGVsc2UgaWYgKHZvaWQgMCA9PT0gciAmJiAnc3RyaW5nJyA9PSB0eXBlb2YgZSkgKG4gPSBlKSwgKHIgPSB0aGlzLmxlbmd0aCksIChlID0gMCk7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGUpKQogICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJykKICAgICAgICAgICAgICAgIDsoZSB8PSAwKSwgaXNGaW5pdGUocikgPyAoKHIgfD0gMCksIHZvaWQgMCA9PT0gbiAmJiAobiA9ICd1dGY4JykpIDogKChuID0gciksIChyID0gdm9pZCAwKSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciBpID0gdGhpcy5sZW5ndGggLSBlOwogICAgICAgICAgICAgIGlmICgoKHZvaWQgMCA9PT0gciB8fCByID4gaSkgJiYgKHIgPSBpKSwgKHQubGVuZ3RoID4gMCAmJiAociA8IDAgfHwgZSA8IDApKSB8fCBlID4gdGhpcy5sZW5ndGgpKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJykKICAgICAgICAgICAgICBuIHx8IChuID0gJ3V0ZjgnKTsKICAgICAgICAgICAgICBmb3IgKHZhciBvID0gITE7IDsgKQogICAgICAgICAgICAgICAgc3dpdGNoIChuKSB7CiAgICAgICAgICAgICAgICAgIGNhc2UgJ2hleCc6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEUodGhpcywgdCwgZSwgcikKICAgICAgICAgICAgICAgICAgY2FzZSAndXRmOCc6CiAgICAgICAgICAgICAgICAgIGNhc2UgJ3V0Zi04JzoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdih0aGlzLCB0LCBlLCByKQogICAgICAgICAgICAgICAgICBjYXNlICdhc2NpaSc6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEEodGhpcywgdCwgZSwgcikKICAgICAgICAgICAgICAgICAgY2FzZSAnbGF0aW4xJzoKICAgICAgICAgICAgICAgICAgY2FzZSAnYmluYXJ5JzoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gXyh0aGlzLCB0LCBlLCByKQogICAgICAgICAgICAgICAgICBjYXNlICdiYXNlNjQnOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBiKHRoaXMsIHQsIGUsIHIpCiAgICAgICAgICAgICAgICAgIGNhc2UgJ3VjczInOgogICAgICAgICAgICAgICAgICBjYXNlICd1Y3MtMic6CiAgICAgICAgICAgICAgICAgIGNhc2UgJ3V0ZjE2bGUnOgogICAgICAgICAgICAgICAgICBjYXNlICd1dGYtMTZsZSc6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG0odGhpcywgdCwgZSwgcikKICAgICAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgICAgICBpZiAobykgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIG4pCiAgICAgICAgICAgICAgICAgICAgOyhuID0gKCcnICsgbikudG9Mb3dlckNhc2UoKSksIChvID0gITApOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiAnQnVmZmVyJywgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgICB2YXIgVCA9IDQwOTY7CiAgICAgICAgICBmdW5jdGlvbiBQKHQsIGUsIHIpIHsKICAgICAgICAgICAgdmFyIG4gPSAnJzsKICAgICAgICAgICAgciA9IE1hdGgubWluKHQubGVuZ3RoLCByKTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IGU7IGkgPCByOyArK2kpIG4gKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgxMjcgJiB0W2ldKTsKICAgICAgICAgICAgcmV0dXJuIG4KICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIEModCwgZSwgcikgewogICAgICAgICAgICB2YXIgbiA9ICcnOwogICAgICAgICAgICByID0gTWF0aC5taW4odC5sZW5ndGgsIHIpOwogICAgICAgICAgICBmb3IgKHZhciBpID0gZTsgaSA8IHI7ICsraSkgbiArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHRbaV0pOwogICAgICAgICAgICByZXR1cm4gbgogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gVSh0LCBlLCByKSB7CiAgICAgICAgICAgIHZhciBuID0gdC5sZW5ndGgKICAgICAgICAgICAgOyghZSB8fCBlIDwgMCkgJiYgKGUgPSAwKSwgKCFyIHx8IHIgPCAwIHx8IHIgPiBuKSAmJiAociA9IG4pOwogICAgICAgICAgICBmb3IgKHZhciBpID0gJycsIG8gPSBlOyBvIDwgcjsgKytvKSBpICs9IE4odFtvXSk7CiAgICAgICAgICAgIHJldHVybiBpCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBCKHQsIGUsIHIpIHsKICAgICAgICAgICAgZm9yICh2YXIgbiA9IHQuc2xpY2UoZSwgciksIGkgPSAnJywgbyA9IDA7IG8gPCBuLmxlbmd0aDsgbyArPSAyKQogICAgICAgICAgICAgIGkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShuW29dICsgMjU2ICogbltvICsgMV0pOwogICAgICAgICAgICByZXR1cm4gaQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gRih0LCBlLCByKSB7CiAgICAgICAgICAgIGlmICh0ICUgMSAhPSAwIHx8IHQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JykKICAgICAgICAgICAgaWYgKHQgKyBlID4gcikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gTSh0LCBlLCByLCBuLCBpLCBvKSB7CiAgICAgICAgICAgIGlmICghYS5pc0J1ZmZlcih0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignImJ1ZmZlciIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpCiAgICAgICAgICAgIGlmIChlID4gaSB8fCBlIDwgbykgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJyJ2YWx1ZSIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpCiAgICAgICAgICAgIGlmIChyICsgbiA+IHQubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJykKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIHgodCwgZSwgciwgbikgewogICAgICAgICAgICBlIDwgMCAmJiAoZSA9IDY1NTM1ICsgZSArIDEpOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbyA9IE1hdGgubWluKHQubGVuZ3RoIC0gciwgMik7IGkgPCBvOyArK2kpCiAgICAgICAgICAgICAgdFtyICsgaV0gPSAoZSAmICgyNTUgPDwgKDggKiAobiA/IGkgOiAxIC0gaSkpKSkgPj4+ICg4ICogKG4gPyBpIDogMSAtIGkpKTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIEkodCwgZSwgciwgbikgewogICAgICAgICAgICBlIDwgMCAmJiAoZSA9IDQyOTQ5NjcyOTUgKyBlICsgMSk7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBvID0gTWF0aC5taW4odC5sZW5ndGggLSByLCA0KTsgaSA8IG87ICsraSkgdFtyICsgaV0gPSAoZSA+Pj4gKDggKiAobiA/IGkgOiAzIC0gaSkpKSAmIDI1NTsKICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIE8odCwgZSwgciwgbiwgaSwgbykgewogICAgICAgICAgICBpZiAociArIG4gPiB0Lmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpCiAgICAgICAgICAgIGlmIChyIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBZKHQsIGUsIHIsIG4sIG8pIHsKICAgICAgICAgICAgcmV0dXJuIG8gfHwgTyh0LCAwLCByLCA0KSwgaS53cml0ZSh0LCBlLCByLCBuLCAyMywgNCksIHIgKyA0CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBMKHQsIGUsIHIsIG4sIG8pIHsKICAgICAgICAgICAgcmV0dXJuIG8gfHwgTyh0LCAwLCByLCA4KSwgaS53cml0ZSh0LCBlLCByLCBuLCA1MiwgOCksIHIgKyA4CiAgICAgICAgICB9CiAgKGEucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgdmFyIHIsCiAgICAgICAgICAgICAgbiA9IHRoaXMubGVuZ3RoOwogICAgICAgICAgICBpZiAoCiAgICAgICAgICAgICAgKCh0ID0gfn50KSwKICAgICAgICAgICAgICAoZSA9IHZvaWQgMCA9PT0gZSA/IG4gOiB+fmUpLAogICAgICAgICAgICAgIHQgPCAwID8gKHQgKz0gbikgPCAwICYmICh0ID0gMCkgOiB0ID4gbiAmJiAodCA9IG4pLAogICAgICAgICAgICAgIGUgPCAwID8gKGUgKz0gbikgPCAwICYmIChlID0gMCkgOiBlID4gbiAmJiAoZSA9IG4pLAogICAgICAgICAgICAgIGUgPCB0ICYmIChlID0gdCksCiAgICAgICAgICAgICAgYS5UWVBFRF9BUlJBWV9TVVBQT1JUKQogICAgICAgICAgICApCiAgICAgICAgICAgICAgKHIgPSB0aGlzLnN1YmFycmF5KHQsIGUpKS5fX3Byb3RvX18gPSBhLnByb3RvdHlwZTsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgdmFyIGkgPSBlIC0gdDsKICAgICAgICAgICAgICByID0gbmV3IGEoaSwgdm9pZCAwKTsKICAgICAgICAgICAgICBmb3IgKHZhciBvID0gMDsgbyA8IGk7ICsrbykgcltvXSA9IHRoaXNbbyArIHRdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiByCiAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiAodCwgZSwgcikgewogICh0IHw9IDApLCAoZSB8PSAwKSwgciB8fCBGKHQsIGUsIHRoaXMubGVuZ3RoKTsKICAgICAgICAgICAgICBmb3IgKHZhciBuID0gdGhpc1t0XSwgaSA9IDEsIG8gPSAwOyArK28gPCBlICYmIChpICo9IDI1Nik7ICkgbiArPSB0aGlzW3QgKyBvXSAqIGk7CiAgICAgICAgICAgICAgcmV0dXJuIG4KICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAodCB8PSAwKSwgKGUgfD0gMCksIHIgfHwgRih0LCBlLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IHRoaXNbdCArIC0tZV0sIGkgPSAxOyBlID4gMCAmJiAoaSAqPSAyNTYpOyApIG4gKz0gdGhpc1t0ICsgLS1lXSAqIGk7CiAgICAgICAgICAgICAgcmV0dXJuIG4KICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgIHJldHVybiBlIHx8IEYodCwgMSwgdGhpcy5sZW5ndGgpLCB0aGlzW3RdCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICByZXR1cm4gZSB8fCBGKHQsIDIsIHRoaXMubGVuZ3RoKSwgdGhpc1t0XSB8ICh0aGlzW3QgKyAxXSA8PCA4KQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGUgfHwgRih0LCAyLCB0aGlzLmxlbmd0aCksICh0aGlzW3RdIDw8IDgpIHwgdGhpc1t0ICsgMV0KICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICBlIHx8IEYodCwgNCwgdGhpcy5sZW5ndGgpLCAodGhpc1t0XSB8ICh0aGlzW3QgKyAxXSA8PCA4KSB8ICh0aGlzW3QgKyAyXSA8PCAxNikpICsgMTY3NzcyMTYgKiB0aGlzW3QgKyAzXQogICAgICAgICAgICAgICkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICBlIHx8IEYodCwgNCwgdGhpcy5sZW5ndGgpLCAxNjc3NzIxNiAqIHRoaXNbdF0gKyAoKHRoaXNbdCArIDFdIDw8IDE2KSB8ICh0aGlzW3QgKyAyXSA8PCA4KSB8IHRoaXNbdCArIDNdKQogICAgICAgICAgICAgICkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiAodCwgZSwgcikgewogICh0IHw9IDApLCAoZSB8PSAwKSwgciB8fCBGKHQsIGUsIHRoaXMubGVuZ3RoKTsKICAgICAgICAgICAgICBmb3IgKHZhciBuID0gdGhpc1t0XSwgaSA9IDEsIG8gPSAwOyArK28gPCBlICYmIChpICo9IDI1Nik7ICkgbiArPSB0aGlzW3QgKyBvXSAqIGk7CiAgICAgICAgICAgICAgcmV0dXJuIG4gPj0gKGkgKj0gMTI4KSAmJiAobiAtPSBNYXRoLnBvdygyLCA4ICogZSkpLCBuCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAodCB8PSAwKSwgKGUgfD0gMCksIHIgfHwgRih0LCBlLCB0aGlzLmxlbmd0aCk7CiAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IGUsIGkgPSAxLCBvID0gdGhpc1t0ICsgLS1uXTsgbiA+IDAgJiYgKGkgKj0gMjU2KTsgKSBvICs9IHRoaXNbdCArIC0tbl0gKiBpOwogICAgICAgICAgICAgIHJldHVybiBvID49IChpICo9IDEyOCkgJiYgKG8gLT0gTWF0aC5wb3coMiwgOCAqIGUpKSwgbwogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICByZXR1cm4gZSB8fCBGKHQsIDEsIHRoaXMubGVuZ3RoKSwgMTI4ICYgdGhpc1t0XSA/IC0xICogKDI1NSAtIHRoaXNbdF0gKyAxKSA6IHRoaXNbdF0KICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgZSB8fCBGKHQsIDIsIHRoaXMubGVuZ3RoKTsKICAgICAgICAgICAgICB2YXIgciA9IHRoaXNbdF0gfCAodGhpc1t0ICsgMV0gPDwgOCk7CiAgICAgICAgICAgICAgcmV0dXJuIDMyNzY4ICYgciA/IDQyOTQ5MDE3NjAgfCByIDogcgogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICBlIHx8IEYodCwgMiwgdGhpcy5sZW5ndGgpOwogICAgICAgICAgICAgIHZhciByID0gdGhpc1t0ICsgMV0gfCAodGhpc1t0XSA8PCA4KTsKICAgICAgICAgICAgICByZXR1cm4gMzI3NjggJiByID8gNDI5NDkwMTc2MCB8IHIgOiByCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgIHJldHVybiBlIHx8IEYodCwgNCwgdGhpcy5sZW5ndGgpLCB0aGlzW3RdIHwgKHRoaXNbdCArIDFdIDw8IDgpIHwgKHRoaXNbdCArIDJdIDw8IDE2KSB8ICh0aGlzW3QgKyAzXSA8PCAyNCkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGUgfHwgRih0LCA0LCB0aGlzLmxlbmd0aCksICh0aGlzW3RdIDw8IDI0KSB8ICh0aGlzW3QgKyAxXSA8PCAxNikgfCAodGhpc1t0ICsgMl0gPDwgOCkgfCB0aGlzW3QgKyAzXQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICByZXR1cm4gZSB8fCBGKHQsIDQsIHRoaXMubGVuZ3RoKSwgaS5yZWFkKHRoaXMsIHQsICEwLCAyMywgNCkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGUgfHwgRih0LCA0LCB0aGlzLmxlbmd0aCksIGkucmVhZCh0aGlzLCB0LCAhMSwgMjMsIDQpCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gKHQsIGUpIHsKICAgICAgICAgICAgICByZXR1cm4gZSB8fCBGKHQsIDgsIHRoaXMubGVuZ3RoKSwgaS5yZWFkKHRoaXMsIHQsICEwLCA1MiwgOCkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgIHJldHVybiBlIHx8IEYodCwgOCwgdGhpcy5sZW5ndGgpLCBpLnJlYWQodGhpcywgdCwgITEsIDUyLCA4KQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHsKICAoKHQgPSArdCksIChlIHw9IDApLCAociB8PSAwKSwgbikgfHwgTSh0aGlzLCB0LCBlLCByLCBNYXRoLnBvdygyLCA4ICogcikgLSAxLCAwKTsKICAgICAgICAgICAgICB2YXIgaSA9IDEsCiAgICAgICAgICAgICAgICBvID0gMDsKICAgICAgICAgICAgICBmb3IgKHRoaXNbZV0gPSAyNTUgJiB0OyArK28gPCByICYmIChpICo9IDI1Nik7ICkgdGhpc1tlICsgb10gPSAodCAvIGkpICYgMjU1OwogICAgICAgICAgICAgIHJldHVybiBlICsgcgogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHsKICAoKHQgPSArdCksIChlIHw9IDApLCAociB8PSAwKSwgbikgfHwgTSh0aGlzLCB0LCBlLCByLCBNYXRoLnBvdygyLCA4ICogcikgLSAxLCAwKTsKICAgICAgICAgICAgICB2YXIgaSA9IHIgLSAxLAogICAgICAgICAgICAgICAgbyA9IDE7CiAgICAgICAgICAgICAgZm9yICh0aGlzW2UgKyBpXSA9IDI1NSAmIHQ7IC0taSA+PSAwICYmIChvICo9IDI1Nik7ICkgdGhpc1tlICsgaV0gPSAodCAvIG8pICYgMjU1OwogICAgICAgICAgICAgIHJldHVybiBlICsgcgogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICAodCA9ICt0KSwKICAgICAgICAgICAgICAgIChlIHw9IDApLAogICAgICAgICAgICAgICAgciB8fCBNKHRoaXMsIHQsIGUsIDEsIDI1NSwgMCksCiAgICAgICAgICAgICAgICBhLlRZUEVEX0FSUkFZX1NVUFBPUlQgfHwgKHQgPSBNYXRoLmZsb29yKHQpKSwKICAgICAgICAgICAgICAgICh0aGlzW2VdID0gMjU1ICYgdCksCiAgICAgICAgICAgICAgICBlICsgMQogICAgICAgICAgICAgICkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgKHQgPSArdCksCiAgICAgICAgICAgICAgICAoZSB8PSAwKSwKICAgICAgICAgICAgICAgIHIgfHwgTSh0aGlzLCB0LCBlLCAyLCA2NTUzNSwgMCksCiAgICAgICAgICAgICAgICBhLlRZUEVEX0FSUkFZX1NVUFBPUlQgPyAoKHRoaXNbZV0gPSAyNTUgJiB0KSwgKHRoaXNbZSArIDFdID0gdCA+Pj4gOCkpIDogeCh0aGlzLCB0LCBlLCAhMCksCiAgICAgICAgICAgICAgICBlICsgMgogICAgICAgICAgICAgICkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgKHQgPSArdCksCiAgICAgICAgICAgICAgICAoZSB8PSAwKSwKICAgICAgICAgICAgICAgIHIgfHwgTSh0aGlzLCB0LCBlLCAyLCA2NTUzNSwgMCksCiAgICAgICAgICAgICAgICBhLlRZUEVEX0FSUkFZX1NVUFBPUlQgPyAoKHRoaXNbZV0gPSB0ID4+PiA4KSwgKHRoaXNbZSArIDFdID0gMjU1ICYgdCkpIDogeCh0aGlzLCB0LCBlLCAhMSksCiAgICAgICAgICAgICAgICBlICsgMgogICAgICAgICAgICAgICkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgKHQgPSArdCksCiAgICAgICAgICAgICAgICAoZSB8PSAwKSwKICAgICAgICAgICAgICAgIHIgfHwgTSh0aGlzLCB0LCBlLCA0LCA0Mjk0OTY3Mjk1LCAwKSwKICAgICAgICAgICAgICAgIGEuVFlQRURfQVJSQVlfU1VQUE9SVAogICAgICAgICAgICAgICAgICA/ICgodGhpc1tlICsgM10gPSB0ID4+PiAyNCksICh0aGlzW2UgKyAyXSA9IHQgPj4+IDE2KSwgKHRoaXNbZSArIDFdID0gdCA+Pj4gOCksICh0aGlzW2VdID0gMjU1ICYgdCkpCiAgICAgICAgICAgICAgICAgIDogSSh0aGlzLCB0LCBlLCAhMCksCiAgICAgICAgICAgICAgICBlICsgNAogICAgICAgICAgICAgICkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgKHQgPSArdCksCiAgICAgICAgICAgICAgICAoZSB8PSAwKSwKICAgICAgICAgICAgICAgIHIgfHwgTSh0aGlzLCB0LCBlLCA0LCA0Mjk0OTY3Mjk1LCAwKSwKICAgICAgICAgICAgICAgIGEuVFlQRURfQVJSQVlfU1VQUE9SVAogICAgICAgICAgICAgICAgICA/ICgodGhpc1tlXSA9IHQgPj4+IDI0KSwgKHRoaXNbZSArIDFdID0gdCA+Pj4gMTYpLCAodGhpc1tlICsgMl0gPSB0ID4+PiA4KSwgKHRoaXNbZSArIDNdID0gMjU1ICYgdCkpCiAgICAgICAgICAgICAgICAgIDogSSh0aGlzLCB0LCBlLCAhMSksCiAgICAgICAgICAgICAgICBlICsgNAogICAgICAgICAgICAgICkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHsKICAgICAgICAgICAgICBpZiAoKCh0ID0gK3QpLCAoZSB8PSAwKSwgIW4pKSB7CiAgICAgICAgICAgICAgICB2YXIgaSA9IE1hdGgucG93KDIsIDggKiByIC0gMSk7CiAgICAgICAgICAgICAgICBNKHRoaXMsIHQsIGUsIHIsIGkgLSAxLCAtaSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHZhciBvID0gMCwKICAgICAgICAgICAgICAgIHMgPSAxLAogICAgICAgICAgICAgICAgdSA9IDA7CiAgICAgICAgICAgICAgZm9yICh0aGlzW2VdID0gMjU1ICYgdDsgKytvIDwgciAmJiAocyAqPSAyNTYpOyApCiAgICAgICAgICAgICAgICB0IDwgMCAmJiAwID09PSB1ICYmIDAgIT09IHRoaXNbZSArIG8gLSAxXSAmJiAodSA9IDEpLCAodGhpc1tlICsgb10gPSAoKCh0IC8gcykgPj4gMCkgLSB1KSAmIDI1NSk7CiAgICAgICAgICAgICAgcmV0dXJuIGUgKyByCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7CiAgICAgICAgICAgICAgaWYgKCgodCA9ICt0KSwgKGUgfD0gMCksICFuKSkgewogICAgICAgICAgICAgICAgdmFyIGkgPSBNYXRoLnBvdygyLCA4ICogciAtIDEpOwogICAgICAgICAgICAgICAgTSh0aGlzLCB0LCBlLCByLCBpIC0gMSwgLWkpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB2YXIgbyA9IHIgLSAxLAogICAgICAgICAgICAgICAgcyA9IDEsCiAgICAgICAgICAgICAgICB1ID0gMDsKICAgICAgICAgICAgICBmb3IgKHRoaXNbZSArIG9dID0gMjU1ICYgdDsgLS1vID49IDAgJiYgKHMgKj0gMjU2KTsgKQogICAgICAgICAgICAgICAgdCA8IDAgJiYgMCA9PT0gdSAmJiAwICE9PSB0aGlzW2UgKyBvICsgMV0gJiYgKHUgPSAxKSwgKHRoaXNbZSArIG9dID0gKCgodCAvIHMpID4+IDApIC0gdSkgJiAyNTUpOwogICAgICAgICAgICAgIHJldHVybiBlICsgcgogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgICh0ID0gK3QpLAogICAgICAgICAgICAgICAgKGUgfD0gMCksCiAgICAgICAgICAgICAgICByIHx8IE0odGhpcywgdCwgZSwgMSwgMTI3LCAtMTI4KSwKICAgICAgICAgICAgICAgIGEuVFlQRURfQVJSQVlfU1VQUE9SVCB8fCAodCA9IE1hdGguZmxvb3IodCkpLAogICAgICAgICAgICAgICAgdCA8IDAgJiYgKHQgPSAyNTUgKyB0ICsgMSksCiAgICAgICAgICAgICAgICAodGhpc1tlXSA9IDI1NSAmIHQpLAogICAgICAgICAgICAgICAgZSArIDEKICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gKHQsIGUsIHIpIHsKICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgKHQgPSArdCksCiAgICAgICAgICAgICAgICAoZSB8PSAwKSwKICAgICAgICAgICAgICAgIHIgfHwgTSh0aGlzLCB0LCBlLCAyLCAzMjc2NywgLTMyNzY4KSwKICAgICAgICAgICAgICAgIGEuVFlQRURfQVJSQVlfU1VQUE9SVCA/ICgodGhpc1tlXSA9IDI1NSAmIHQpLCAodGhpc1tlICsgMV0gPSB0ID4+PiA4KSkgOiB4KHRoaXMsIHQsIGUsICEwKSwKICAgICAgICAgICAgICAgIGUgKyAyCiAgICAgICAgICAgICAgKQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgcmV0dXJuICgKICAgICAgICAgICAgICAgICh0ID0gK3QpLAogICAgICAgICAgICAgICAgKGUgfD0gMCksCiAgICAgICAgICAgICAgICByIHx8IE0odGhpcywgdCwgZSwgMiwgMzI3NjcsIC0zMjc2OCksCiAgICAgICAgICAgICAgICBhLlRZUEVEX0FSUkFZX1NVUFBPUlQgPyAoKHRoaXNbZV0gPSB0ID4+PiA4KSwgKHRoaXNbZSArIDFdID0gMjU1ICYgdCkpIDogeCh0aGlzLCB0LCBlLCAhMSksCiAgICAgICAgICAgICAgICBlICsgMgogICAgICAgICAgICAgICkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICAodCA9ICt0KSwKICAgICAgICAgICAgICAgIChlIHw9IDApLAogICAgICAgICAgICAgICAgciB8fCBNKHRoaXMsIHQsIGUsIDQsIDIxNDc0ODM2NDcsIC0yMTQ3NDgzNjQ4KSwKICAgICAgICAgICAgICAgIGEuVFlQRURfQVJSQVlfU1VQUE9SVAogICAgICAgICAgICAgICAgICA/ICgodGhpc1tlXSA9IDI1NSAmIHQpLCAodGhpc1tlICsgMV0gPSB0ID4+PiA4KSwgKHRoaXNbZSArIDJdID0gdCA+Pj4gMTYpLCAodGhpc1tlICsgM10gPSB0ID4+PiAyNCkpCiAgICAgICAgICAgICAgICAgIDogSSh0aGlzLCB0LCBlLCAhMCksCiAgICAgICAgICAgICAgICBlICsgNAogICAgICAgICAgICAgICkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgIHJldHVybiAoCiAgICAgICAgICAgICAgICAodCA9ICt0KSwKICAgICAgICAgICAgICAgIChlIHw9IDApLAogICAgICAgICAgICAgICAgciB8fCBNKHRoaXMsIHQsIGUsIDQsIDIxNDc0ODM2NDcsIC0yMTQ3NDgzNjQ4KSwKICAgICAgICAgICAgICAgIHQgPCAwICYmICh0ID0gNDI5NDk2NzI5NSArIHQgKyAxKSwKICAgICAgICAgICAgICAgIGEuVFlQRURfQVJSQVlfU1VQUE9SVAogICAgICAgICAgICAgICAgICA/ICgodGhpc1tlXSA9IHQgPj4+IDI0KSwgKHRoaXNbZSArIDFdID0gdCA+Pj4gMTYpLCAodGhpc1tlICsgMl0gPSB0ID4+PiA4KSwgKHRoaXNbZSArIDNdID0gMjU1ICYgdCkpCiAgICAgICAgICAgICAgICAgIDogSSh0aGlzLCB0LCBlLCAhMSksCiAgICAgICAgICAgICAgICBlICsgNAogICAgICAgICAgICAgICkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgIHJldHVybiBZKHRoaXMsIHQsIGUsICEwLCByKQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGEucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgcmV0dXJuIFkodGhpcywgdCwgZSwgITEsIHIpCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEwodGhpcywgdCwgZSwgITAsIHIpCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgcmV0dXJuIEwodGhpcywgdCwgZSwgITEsIHIpCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoYS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuKSB7CiAgICAgICAgICAgICAgaWYgKAogICAgICAgICAgICAgICAgKHIgfHwgKHIgPSAwKSwKICAgICAgICAgICAgICAgIG4gfHwgMCA9PT0gbiB8fCAobiA9IHRoaXMubGVuZ3RoKSwKICAgICAgICAgICAgICAgIGUgPj0gdC5sZW5ndGggJiYgKGUgPSB0Lmxlbmd0aCksCiAgICAgICAgICAgICAgICBlIHx8IChlID0gMCksCiAgICAgICAgICAgICAgICBuID4gMCAmJiBuIDwgciAmJiAobiA9IHIpLAogICAgICAgICAgICAgICAgbiA9PT0gcikKICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICByZXR1cm4gMAogICAgICAgICAgICAgIGlmICgwID09PSB0Lmxlbmd0aCB8fCAwID09PSB0aGlzLmxlbmd0aCkgcmV0dXJuIDAKICAgICAgICAgICAgICBpZiAoZSA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJykKICAgICAgICAgICAgICBpZiAociA8IDAgfHwgciA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKQogICAgICAgICAgICAgIGlmIChuIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJykKICAgICAgICAgICAgICBuID4gdGhpcy5sZW5ndGggJiYgKG4gPSB0aGlzLmxlbmd0aCksIHQubGVuZ3RoIC0gZSA8IG4gLSByICYmIChuID0gdC5sZW5ndGggLSBlICsgcik7CiAgICAgICAgICAgICAgdmFyIGksCiAgICAgICAgICAgICAgICBvID0gbiAtIHI7CiAgICAgICAgICAgICAgaWYgKHRoaXMgPT09IHQgJiYgciA8IGUgJiYgZSA8IG4pIGZvciAoaSA9IG8gLSAxOyBpID49IDA7IC0taSkgdFtpICsgZV0gPSB0aGlzW2kgKyByXTsKICAgICAgICAgICAgICBlbHNlIGlmIChvIDwgMWUzIHx8ICFhLlRZUEVEX0FSUkFZX1NVUFBPUlQpIGZvciAoaSA9IDA7IGkgPCBvOyArK2kpIHRbaSArIGVdID0gdGhpc1tpICsgcl07CiAgICAgICAgICAgICAgZWxzZSBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbCh0LCB0aGlzLnN1YmFycmF5KHIsIHIgKyBvKSwgZSk7CiAgICAgICAgICAgICAgcmV0dXJuIG8KICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChhLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHQsIGUsIHIsIG4pIHsKICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHQpIHsKICAgICAgICAgICAgICAgIGlmICgKICAgICAgICAgICAgICAgICAgKCdzdHJpbmcnID09IHR5cGVvZiBlCiAgICAgICAgICAgICAgICAgICAgPyAoKG4gPSBlKSwgKGUgPSAwKSwgKHIgPSB0aGlzLmxlbmd0aCkpCiAgICAgICAgICAgICAgICAgICAgOiAnc3RyaW5nJyA9PSB0eXBlb2YgciAmJiAoKG4gPSByKSwgKHIgPSB0aGlzLmxlbmd0aCkpLAogICAgICAgICAgICAgICAgICAxID09PSB0Lmxlbmd0aCkKICAgICAgICAgICAgICAgICkgewogICAgICAgICAgICAgICAgICB2YXIgaSA9IHQuY2hhckNvZGVBdCgwKTsKICAgICAgICAgICAgICAgICAgaSA8IDI1NiAmJiAodCA9IGkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHZvaWQgMCAhPT0gbiAmJiAnc3RyaW5nJyAhPSB0eXBlb2YgbikgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpCiAgICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIG4gJiYgIWEuaXNFbmNvZGluZyhuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIG4pCiAgICAgICAgICAgICAgfSBlbHNlICdudW1iZXInID09IHR5cGVvZiB0ICYmICh0ICY9IDI1NSk7CiAgICAgICAgICAgICAgaWYgKGUgPCAwIHx8IHRoaXMubGVuZ3RoIDwgZSB8fCB0aGlzLmxlbmd0aCA8IHIpIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKQogICAgICAgICAgICAgIGlmIChyIDw9IGUpIHJldHVybiB0aGlzCiAgICAgICAgICAgICAgdmFyIG87CiAgICAgICAgICAgICAgaWYgKCgoZSA+Pj49IDApLCAociA9IHZvaWQgMCA9PT0gciA/IHRoaXMubGVuZ3RoIDogciA+Pj4gMCksIHQgfHwgKHQgPSAwKSwgJ251bWJlcicgPT0gdHlwZW9mIHQpKQogICAgICAgICAgICAgICAgZm9yIChvID0gZTsgbyA8IHI7ICsrbykgdGhpc1tvXSA9IHQ7CiAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICB2YXIgcyA9IGEuaXNCdWZmZXIodCkgPyB0IDogayhuZXcgYSh0LCBuKS50b1N0cmluZygpKSwKICAgICAgICAgICAgICAgICAgdSA9IHMubGVuZ3RoOwogICAgICAgICAgICAgICAgZm9yIChvID0gMDsgbyA8IHIgLSBlOyArK28pIHRoaXNbbyArIGVdID0gc1tvICUgdV07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiB0aGlzCiAgICAgICAgICAgIH0pOwogICAgICAgICAgdmFyIEQgPSAvW14rXC8wLTlBLVphLXotX10vZzsKICAgICAgICAgIGZ1bmN0aW9uIE4odCkgewogICAgICAgICAgICByZXR1cm4gdCA8IDE2ID8gJzAnICsgdC50b1N0cmluZygxNikgOiB0LnRvU3RyaW5nKDE2KQogICAgICAgICAgfQogICAgICAgICAgZnVuY3Rpb24gayh0LCBlKSB7CiAgICAgICAgICAgIHZhciByOwogICAgICAgICAgICBlID0gZSB8fCAxIC8gMDsKICAgICAgICAgICAgZm9yICh2YXIgbiA9IHQubGVuZ3RoLCBpID0gbnVsbCwgbyA9IFtdLCBzID0gMDsgcyA8IG47ICsrcykgewogICAgICAgICAgICAgIGlmICgociA9IHQuY2hhckNvZGVBdChzKSkgPiA1NTI5NSAmJiByIDwgNTczNDQpIHsKICAgICAgICAgICAgICAgIGlmICghaSkgewogICAgICAgICAgICAgICAgICBpZiAociA+IDU2MzE5KSB7CiAgKGUgLT0gMykgPiAtMSAmJiBvLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICAgICAgICAgICAgY29udGludWUKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAocyArIDEgPT09IG4pIHsKICAoZSAtPSAzKSA+IC0xICYmIG8ucHVzaCgyMzksIDE5MSwgMTg5KTsKICAgICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIGkgPSByOwogICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHIgPCA1NjMyMCkgewogIChlIC09IDMpID4gLTEgJiYgby5wdXNoKDIzOSwgMTkxLCAxODkpLCAoaSA9IHIpOwogICAgICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgciA9IDY1NTM2ICsgKCgoaSAtIDU1Mjk2KSA8PCAxMCkgfCAociAtIDU2MzIwKSk7CiAgICAgICAgICAgICAgfSBlbHNlIGkgJiYgKGUgLT0gMykgPiAtMSAmJiBvLnB1c2goMjM5LCAxOTEsIDE4OSk7CiAgICAgICAgICAgICAgaWYgKCgoaSA9IG51bGwpLCByIDwgMTI4KSkgewogICAgICAgICAgICAgICAgaWYgKChlIC09IDEpIDwgMCkgYnJlYWsKICAgICAgICAgICAgICAgIG8ucHVzaChyKTsKICAgICAgICAgICAgICB9IGVsc2UgaWYgKHIgPCAyMDQ4KSB7CiAgICAgICAgICAgICAgICBpZiAoKGUgLT0gMikgPCAwKSBicmVhawogICAgICAgICAgICAgICAgby5wdXNoKChyID4+IDYpIHwgMTkyLCAoNjMgJiByKSB8IDEyOCk7CiAgICAgICAgICAgICAgfSBlbHNlIGlmIChyIDwgNjU1MzYpIHsKICAgICAgICAgICAgICAgIGlmICgoZSAtPSAzKSA8IDApIGJyZWFrCiAgICAgICAgICAgICAgICBvLnB1c2goKHIgPj4gMTIpIHwgMjI0LCAoKHIgPj4gNikgJiA2MykgfCAxMjgsICg2MyAmIHIpIHwgMTI4KTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgaWYgKCEociA8IDExMTQxMTIpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpCiAgICAgICAgICAgICAgICBpZiAoKGUgLT0gNCkgPCAwKSBicmVhawogICAgICAgICAgICAgICAgby5wdXNoKChyID4+IDE4KSB8IDI0MCwgKChyID4+IDEyKSAmIDYzKSB8IDEyOCwgKChyID4+IDYpICYgNjMpIHwgMTI4LCAoNjMgJiByKSB8IDEyOCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBvCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBqKHQpIHsKICAgICAgICAgICAgcmV0dXJuIG4udG9CeXRlQXJyYXkoCiAgICAgICAgICAgICAgKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICBpZiAoCiAgICAgICAgICAgICAgICAgICh0ID0gKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQudHJpbSA/IHQudHJpbSgpIDogdC5yZXBsYWNlKC9eXHMrfFxzKyQvZywgJycpCiAgICAgICAgICAgICAgICAgIH0pKHQpLnJlcGxhY2UoRCwgJycpKS5sZW5ndGggPCAyCiAgICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgICAgIHJldHVybiAnJwogICAgICAgICAgICAgICAgZm9yICg7IHQubGVuZ3RoICUgNCAhPSAwOyApIHQgKz0gJz0nOwogICAgICAgICAgICAgICAgcmV0dXJuIHQKICAgICAgICAgICAgICB9KSh0KQogICAgICAgICAgICApCiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiB6KHQsIGUsIHIsIG4pIHsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuICYmICEoaSArIHIgPj0gZS5sZW5ndGggfHwgaSA+PSB0Lmxlbmd0aCk7ICsraSkgZVtpICsgcl0gPSB0W2ldOwogICAgICAgICAgICByZXR1cm4gaQogICAgICAgICAgfQogICAgICAgIH0uY2FsbCh0aGlzLCByKDgpKSk7CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uICh0LCBlKSB7CiAgICAgICAgdmFyIHI7CiAgICAgICAgciA9IChmdW5jdGlvbiAoKSB7CiAgICAgICAgICByZXR1cm4gdGhpcwogICAgICAgIH0pKCk7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHIgPSByIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCkgfHwgKDAsIGV2YWwpKCd0aGlzJyk7CiAgICAgICAgfSBjYXRjaCAodCkgewogICAgICAgICAgJ29iamVjdCcgPT0gdHlwZW9mIHdpbmRvdyAmJiAociA9IHdpbmRvdyk7CiAgICAgICAgfQogICAgICAgIHQuZXhwb3J0cyA9IHI7CiAgICAgIH0sCiAgICAgIGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgKGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICB2YXIgZSA9IGYodCksCiAgICAgICAgICAgIHIgPSBlWzBdLAogICAgICAgICAgICBuID0gZVsxXTsKICAgICAgICAgIHJldHVybiAoMyAqIChyICsgbikpIC8gNCAtIG4KICAgICAgICB9KSwKICAgICAgICAgIChlLnRvQnl0ZUFycmF5ID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgZm9yICgKICAgICAgICAgICAgICB2YXIgZSwKICAgICAgICAgICAgICAgIHIgPSBmKHQpLAogICAgICAgICAgICAgICAgbiA9IHJbMF0sCiAgICAgICAgICAgICAgICBzID0gclsxXSwKICAgICAgICAgICAgICAgIHUgPSBuZXcgbygKICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgzICogKGUgKyByKSkgLyA0IC0gcgogICAgICAgICAgICAgICAgICB9KSgwLCBuLCBzKQogICAgICAgICAgICAgICAgKSwKICAgICAgICAgICAgICAgIGEgPSAwLAogICAgICAgICAgICAgICAgaCA9IHMgPiAwID8gbiAtIDQgOiBuLAogICAgICAgICAgICAgICAgbCA9IDA7CiAgICAgICAgICAgICAgbCA8IGg7CiAgICAgICAgICAgICAgbCArPSA0CiAgICAgICAgICAgICkKICAgICAgICAgICAgICAoZSA9CiAgICAgICAgICAgICAgICAoaVt0LmNoYXJDb2RlQXQobCldIDw8IDE4KSB8CiAgICAgICAgICAgICAgICAoaVt0LmNoYXJDb2RlQXQobCArIDEpXSA8PCAxMikgfAogICAgICAgICAgICAgICAgKGlbdC5jaGFyQ29kZUF0KGwgKyAyKV0gPDwgNikgfAogICAgICAgICAgICAgICAgaVt0LmNoYXJDb2RlQXQobCArIDMpXSksCiAgICAgICAgICAgICAgICAodVthKytdID0gKGUgPj4gMTYpICYgMjU1KSwKICAgICAgICAgICAgICAgICh1W2ErK10gPSAoZSA+PiA4KSAmIDI1NSksCiAgICAgICAgICAgICAgICAodVthKytdID0gMjU1ICYgZSk7CiAgICAgICAgICAgIDIgPT09IHMgJiYgKChlID0gKGlbdC5jaGFyQ29kZUF0KGwpXSA8PCAyKSB8IChpW3QuY2hhckNvZGVBdChsICsgMSldID4+IDQpKSwgKHVbYSsrXSA9IDI1NSAmIGUpKTsKICAgICAgICAgICAgMSA9PT0gcyAmJgogICAgICAgICAgICAgICgoZSA9IChpW3QuY2hhckNvZGVBdChsKV0gPDwgMTApIHwgKGlbdC5jaGFyQ29kZUF0KGwgKyAxKV0gPDwgNCkgfCAoaVt0LmNoYXJDb2RlQXQobCArIDIpXSA+PiAyKSksCiAgICAgICAgICAgICAgKHVbYSsrXSA9IChlID4+IDgpICYgMjU1KSwKICAgICAgICAgICAgICAodVthKytdID0gMjU1ICYgZSkpOwogICAgICAgICAgICByZXR1cm4gdQogICAgICAgICAgfSksCiAgICAgICAgICAoZS5mcm9tQnl0ZUFycmF5ID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgZm9yICh2YXIgZSwgciA9IHQubGVuZ3RoLCBpID0gciAlIDMsIG8gPSBbXSwgcyA9IDAsIHUgPSByIC0gaTsgcyA8IHU7IHMgKz0gMTYzODMpCiAgICAgICAgICAgICAgby5wdXNoKGwodCwgcywgcyArIDE2MzgzID4gdSA/IHUgOiBzICsgMTYzODMpKTsKICAgICAgICAgICAgMSA9PT0gaQogICAgICAgICAgICAgID8gKChlID0gdFtyIC0gMV0pLCBvLnB1c2gobltlID4+IDJdICsgblsoZSA8PCA0KSAmIDYzXSArICc9PScpKQogICAgICAgICAgICAgIDogMiA9PT0gaSAmJgogICAgICAgICAgICAgICAgKChlID0gKHRbciAtIDJdIDw8IDgpICsgdFtyIC0gMV0pLCBvLnB1c2gobltlID4+IDEwXSArIG5bKGUgPj4gNCkgJiA2M10gKyBuWyhlIDw8IDIpICYgNjNdICsgJz0nKSk7CiAgICAgICAgICAgIHJldHVybiBvLmpvaW4oJycpCiAgICAgICAgICB9KTsKICAgICAgICBmb3IgKAogICAgICAgICAgdmFyIG4gPSBbXSwKICAgICAgICAgICAgaSA9IFtdLAogICAgICAgICAgICBvID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFVpbnQ4QXJyYXkgPyBVaW50OEFycmF5IDogQXJyYXksCiAgICAgICAgICAgIHMgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLycsCiAgICAgICAgICAgIHUgPSAwLAogICAgICAgICAgICBhID0gcy5sZW5ndGg7CiAgICAgICAgICB1IDwgYTsKICAgICAgICAgICsrdQogICAgICAgICkKICAgICAgICAgIChuW3VdID0gc1t1XSksIChpW3MuY2hhckNvZGVBdCh1KV0gPSB1KTsKICAgICAgICBmdW5jdGlvbiBmKHQpIHsKICAgICAgICAgIHZhciBlID0gdC5sZW5ndGg7CiAgICAgICAgICBpZiAoZSAlIDQgPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKQogICAgICAgICAgdmFyIHIgPSB0LmluZGV4T2YoJz0nKTsKICAgICAgICAgIHJldHVybiAtMSA9PT0gciAmJiAociA9IGUpLCBbciwgciA9PT0gZSA/IDAgOiA0IC0gKHIgJSA0KV0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gaCh0KSB7CiAgICAgICAgICByZXR1cm4gblsodCA+PiAxOCkgJiA2M10gKyBuWyh0ID4+IDEyKSAmIDYzXSArIG5bKHQgPj4gNikgJiA2M10gKyBuWzYzICYgdF0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gbCh0LCBlLCByKSB7CiAgICAgICAgICBmb3IgKHZhciBuLCBpID0gW10sIG8gPSBlOyBvIDwgcjsgbyArPSAzKQogICAgICAgICAgICAobiA9ICgodFtvXSA8PCAxNikgJiAxNjcxMTY4MCkgKyAoKHRbbyArIDFdIDw8IDgpICYgNjUyODApICsgKDI1NSAmIHRbbyArIDJdKSksIGkucHVzaChoKG4pKTsKICAgICAgICAgIHJldHVybiBpLmpvaW4oJycpCiAgICAgICAgfQogIChpWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyKSwgKGlbJ18nLmNoYXJDb2RlQXQoMCldID0gNjMpOwogICAgICB9LAogICAgICBmdW5jdGlvbiAodCwgZSkgewogIChlLnJlYWQgPSBmdW5jdGlvbiAodCwgZSwgciwgbiwgaSkgewogICAgICAgICAgdmFyIG8sCiAgICAgICAgICAgIHMsCiAgICAgICAgICAgIHUgPSA4ICogaSAtIG4gLSAxLAogICAgICAgICAgICBhID0gKDEgPDwgdSkgLSAxLAogICAgICAgICAgICBmID0gYSA+PiAxLAogICAgICAgICAgICBoID0gLTcsCiAgICAgICAgICAgIGwgPSByID8gaSAtIDEgOiAwLAogICAgICAgICAgICBjID0gciA/IC0xIDogMSwKICAgICAgICAgICAgcCA9IHRbZSArIGxdOwogICAgICAgICAgZm9yIChsICs9IGMsIG8gPSBwICYgKCgxIDw8IC1oKSAtIDEpLCBwID4+PSAtaCwgaCArPSB1OyBoID4gMDsgbyA9IDI1NiAqIG8gKyB0W2UgKyBsXSwgbCArPSBjLCBoIC09IDgpOwogICAgICAgICAgZm9yIChzID0gbyAmICgoMSA8PCAtaCkgLSAxKSwgbyA+Pj0gLWgsIGggKz0gbjsgaCA+IDA7IHMgPSAyNTYgKiBzICsgdFtlICsgbF0sIGwgKz0gYywgaCAtPSA4KTsKICAgICAgICAgIGlmICgwID09PSBvKSBvID0gMSAtIGY7CiAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgaWYgKG8gPT09IGEpIHJldHVybiBzID8gTmFOIDogKDEgLyAwKSAqIChwID8gLTEgOiAxKQogICAgICAgICAgICA7KHMgKz0gTWF0aC5wb3coMiwgbikpLCAobyAtPSBmKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiAocCA/IC0xIDogMSkgKiBzICogTWF0aC5wb3coMiwgbyAtIG4pCiAgICAgICAgfSksCiAgICAgICAgICAoZS53cml0ZSA9IGZ1bmN0aW9uICh0LCBlLCByLCBuLCBpLCBvKSB7CiAgICAgICAgICAgIHZhciBzLAogICAgICAgICAgICAgIHUsCiAgICAgICAgICAgICAgYSwKICAgICAgICAgICAgICBmID0gOCAqIG8gLSBpIC0gMSwKICAgICAgICAgICAgICBoID0gKDEgPDwgZikgLSAxLAogICAgICAgICAgICAgIGwgPSBoID4+IDEsCiAgICAgICAgICAgICAgYyA9IDIzID09PSBpID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwLAogICAgICAgICAgICAgIHAgPSBuID8gMCA6IG8gLSAxLAogICAgICAgICAgICAgIGcgPSBuID8gMSA6IC0xLAogICAgICAgICAgICAgIGQgPSBlIDwgMCB8fCAoMCA9PT0gZSAmJiAxIC8gZSA8IDApID8gMSA6IDA7CiAgICAgICAgICAgIGZvciAoCiAgICAgICAgICAgICAgZSA9IE1hdGguYWJzKGUpLAogICAgICAgICAgICAgICAgaXNOYU4oZSkgfHwgZSA9PT0gMSAvIDAKICAgICAgICAgICAgICAgICAgPyAoKHUgPSBpc05hTihlKSA/IDEgOiAwKSwgKHMgPSBoKSkKICAgICAgICAgICAgICAgICAgOiAoKHMgPSBNYXRoLmZsb29yKE1hdGgubG9nKGUpIC8gTWF0aC5MTjIpKSwKICAgICAgICAgICAgICAgICAgICBlICogKGEgPSBNYXRoLnBvdygyLCAtcykpIDwgMSAmJiAocy0tLCAoYSAqPSAyKSksCiAgICAgICAgICAgICAgICAgICAgKGUgKz0gcyArIGwgPj0gMSA/IGMgLyBhIDogYyAqIE1hdGgucG93KDIsIDEgLSBsKSkgKiBhID49IDIgJiYgKHMrKywgKGEgLz0gMikpLAogICAgICAgICAgICAgICAgICAgIHMgKyBsID49IGgKICAgICAgICAgICAgICAgICAgICAgID8gKCh1ID0gMCksIChzID0gaCkpCiAgICAgICAgICAgICAgICAgICAgICA6IHMgKyBsID49IDEKICAgICAgICAgICAgICAgICAgICAgID8gKCh1ID0gKGUgKiBhIC0gMSkgKiBNYXRoLnBvdygyLCBpKSksIChzICs9IGwpKQogICAgICAgICAgICAgICAgICAgICAgOiAoKHUgPSBlICogTWF0aC5wb3coMiwgbCAtIDEpICogTWF0aC5wb3coMiwgaSkpLCAocyA9IDApKSk7CiAgICAgICAgICAgICAgaSA+PSA4OwogICAgICAgICAgICAgIHRbciArIHBdID0gMjU1ICYgdSwgcCArPSBnLCB1IC89IDI1NiwgaSAtPSA4CiAgICAgICAgICAgICk7CiAgICAgICAgICAgIGZvciAocyA9IChzIDw8IGkpIHwgdSwgZiArPSBpOyBmID4gMDsgdFtyICsgcF0gPSAyNTUgJiBzLCBwICs9IGcsIHMgLz0gMjU2LCBmIC09IDgpOwogICAgICAgICAgICB0W3IgKyBwIC0gZ10gfD0gMTI4ICogZDsKICAgICAgICAgIH0pOwogICAgICB9LAogICAgICBmdW5jdGlvbiAodCwgZSkgewogICAgICAgIHZhciByID0ge30udG9TdHJpbmc7CiAgICAgICAgdC5leHBvcnRzID0KICAgICAgICAgIEFycmF5LmlzQXJyYXkgfHwKICAgICAgICAgIGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgIHJldHVybiAnW29iamVjdCBBcnJheV0nID09IHIuY2FsbCh0KQogICAgICAgICAgfTsKICAgICAgfSwKICAgICAgZnVuY3Rpb24gKGUsIHIpIHsKICAgICAgICBlLmV4cG9ydHMgPSB0OwogICAgICB9LAogICAgICBmdW5jdGlvbiAodCwgZSwgcikgewogIChmdW5jdGlvbiAodCkgewogICAgICAgICAgZnVuY3Rpb24gcih0LCBlKSB7CiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwLCBuID0gdC5sZW5ndGggLSAxOyBuID49IDA7IG4tLSkgewogICAgICAgICAgICAgIHZhciBpID0gdFtuXTsKICAgICAgICAgICAgICAnLicgPT09IGkgPyB0LnNwbGljZShuLCAxKSA6ICcuLicgPT09IGkgPyAodC5zcGxpY2UobiwgMSksIHIrKykgOiByICYmICh0LnNwbGljZShuLCAxKSwgci0tKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZSkgZm9yICg7IHItLTsgcikgdC51bnNoaWZ0KCcuLicpOwogICAgICAgICAgICByZXR1cm4gdAogICAgICAgICAgfQogICAgICAgICAgdmFyIG4gPSAvXihcLz98KShbXHNcU10qPykoKD86XC57MSwyfXxbXlwvXSs/fCkoXC5bXi5cL10qfCkpKD86W1wvXSopJC8sCiAgICAgICAgICAgIGkgPSBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgIHJldHVybiBuLmV4ZWModCkuc2xpY2UoMSkKICAgICAgICAgICAgfTsKICAgICAgICAgIGZ1bmN0aW9uIG8odCwgZSkgewogICAgICAgICAgICBpZiAodC5maWx0ZXIpIHJldHVybiB0LmZpbHRlcihlKQogICAgICAgICAgICBmb3IgKHZhciByID0gW10sIG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykgZSh0W25dLCBuLCB0KSAmJiByLnB1c2godFtuXSk7CiAgICAgICAgICAgIHJldHVybiByCiAgICAgICAgICB9CiAgKGUucmVzb2x2ZSA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgZm9yICh2YXIgZSA9ICcnLCBuID0gITEsIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhbjsgaS0tKSB7CiAgICAgICAgICAgICAgdmFyIHMgPSBpID49IDAgPyBhcmd1bWVudHNbaV0gOiB0LmN3ZCgpOwogICAgICAgICAgICAgIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgcykgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKQogICAgICAgICAgICAgIHMgJiYgKChlID0gcyArICcvJyArIGUpLCAobiA9ICcvJyA9PT0gcy5jaGFyQXQoMCkpKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgIChlID0gcigKICAgICAgICAgICAgICAgIG8oZS5zcGxpdCgnLycpLCBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gISF0CiAgICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgICAgICFuCiAgICAgICAgICAgICAgKS5qb2luKCcvJykpLAogICAgICAgICAgICAgIChuID8gJy8nIDogJycpICsgZSB8fCAnLicKICAgICAgICAgICAgKQogICAgICAgICAgfSksCiAgICAgICAgICAgIChlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgdmFyIG4gPSBlLmlzQWJzb2x1dGUodCksCiAgICAgICAgICAgICAgICBpID0gJy8nID09PSBzKHQsIC0xKTsKICAgICAgICAgICAgICByZXR1cm4gKAogICAgICAgICAgICAgICAgKHQgPSByKAogICAgICAgICAgICAgICAgICBvKHQuc3BsaXQoJy8nKSwgZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gISF0CiAgICAgICAgICAgICAgICAgIH0pLAogICAgICAgICAgICAgICAgICAhbgogICAgICAgICAgICAgICAgKS5qb2luKCcvJykpIHx8CiAgICAgICAgICAgICAgICAgIG4gfHwKICAgICAgICAgICAgICAgICAgKHQgPSAnLicpLAogICAgICAgICAgICAgICAgdCAmJiBpICYmICh0ICs9ICcvJyksCiAgICAgICAgICAgICAgICAobiA/ICcvJyA6ICcnKSArIHQKICAgICAgICAgICAgICApCiAgICAgICAgICAgIH0pLAogICAgICAgICAgICAoZS5pc0Fic29sdXRlID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgICByZXR1cm4gJy8nID09PSB0LmNoYXJBdCgwKQogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGUuam9pbiA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICB2YXIgdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7CiAgICAgICAgICAgICAgcmV0dXJuIGUubm9ybWFsaXplKAogICAgICAgICAgICAgICAgbyh0LCBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIHQpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJykKICAgICAgICAgICAgICAgICAgcmV0dXJuIHQKICAgICAgICAgICAgICAgIH0pLmpvaW4oJy8nKQogICAgICAgICAgICAgICkKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChlLnJlbGF0aXZlID0gZnVuY3Rpb24gKHQsIHIpIHsKICAgICAgICAgICAgICBmdW5jdGlvbiBuKHQpIHsKICAgICAgICAgICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgdC5sZW5ndGggJiYgJycgPT09IHRbZV07IGUrKyk7CiAgICAgICAgICAgICAgICBmb3IgKHZhciByID0gdC5sZW5ndGggLSAxOyByID49IDAgJiYgJycgPT09IHRbcl07IHItLSk7CiAgICAgICAgICAgICAgICByZXR1cm4gZSA+IHIgPyBbXSA6IHQuc2xpY2UoZSwgciAtIGUgKyAxKQogICAgICAgICAgICAgIH0KICAodCA9IGUucmVzb2x2ZSh0KS5zdWJzdHIoMSkpLCAociA9IGUucmVzb2x2ZShyKS5zdWJzdHIoMSkpOwogICAgICAgICAgICAgIGZvciAoCiAgICAgICAgICAgICAgICB2YXIgaSA9IG4odC5zcGxpdCgnLycpKSwgbyA9IG4oci5zcGxpdCgnLycpKSwgcyA9IE1hdGgubWluKGkubGVuZ3RoLCBvLmxlbmd0aCksIHUgPSBzLCBhID0gMDsKICAgICAgICAgICAgICAgIGEgPCBzOwogICAgICAgICAgICAgICAgYSsrCiAgICAgICAgICAgICAgKQogICAgICAgICAgICAgICAgaWYgKGlbYV0gIT09IG9bYV0pIHsKICAgICAgICAgICAgICAgICAgdSA9IGE7CiAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdmFyIGYgPSBbXTsKICAgICAgICAgICAgICBmb3IgKGEgPSB1OyBhIDwgaS5sZW5ndGg7IGErKykgZi5wdXNoKCcuLicpOwogICAgICAgICAgICAgIHJldHVybiAoZiA9IGYuY29uY2F0KG8uc2xpY2UodSkpKS5qb2luKCcvJykKICAgICAgICAgICAgfSksCiAgICAgICAgICAgIChlLnNlcCA9ICcvJyksCiAgICAgICAgICAgIChlLmRlbGltaXRlciA9ICc6JyksCiAgICAgICAgICAgIChlLmRpcm5hbWUgPSBmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgIHZhciBlID0gaSh0KSwKICAgICAgICAgICAgICAgIHIgPSBlWzBdLAogICAgICAgICAgICAgICAgbiA9IGVbMV07CiAgICAgICAgICAgICAgcmV0dXJuIHIgfHwgbiA/IChuICYmIChuID0gbi5zdWJzdHIoMCwgbi5sZW5ndGggLSAxKSksIHIgKyBuKSA6ICcuJwogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGUuYmFzZW5hbWUgPSBmdW5jdGlvbiAodCwgZSkgewogICAgICAgICAgICAgIHZhciByID0gaSh0KVsyXTsKICAgICAgICAgICAgICByZXR1cm4gZSAmJiByLnN1YnN0cigtMSAqIGUubGVuZ3RoKSA9PT0gZSAmJiAociA9IHIuc3Vic3RyKDAsIHIubGVuZ3RoIC0gZS5sZW5ndGgpKSwgcgogICAgICAgICAgICB9KSwKICAgICAgICAgICAgKGUuZXh0bmFtZSA9IGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIGkodClbM10KICAgICAgICAgICAgfSk7CiAgICAgICAgICB2YXIgcyA9CiAgICAgICAgICAgICdiJyA9PT0gJ2FiJy5zdWJzdHIoLTEpCiAgICAgICAgICAgICAgPyBmdW5jdGlvbiAodCwgZSwgcikgewogICAgICAgICAgICAgICAgICByZXR1cm4gdC5zdWJzdHIoZSwgcikKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICA6IGZ1bmN0aW9uICh0LCBlLCByKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBlIDwgMCAmJiAoZSA9IHQubGVuZ3RoICsgZSksIHQuc3Vic3RyKGUsIHIpCiAgICAgICAgICAgICAgICB9OwogICAgICAgIH0uY2FsbCh0aGlzLCByKDE0KSkpOwogICAgICB9LAogICAgICBmdW5jdGlvbiAodCwgZSkgewogICAgICAgIHZhciByLAogICAgICAgICAgbiwKICAgICAgICAgIGkgPSAodC5leHBvcnRzID0ge30pOwogICAgICAgIGZ1bmN0aW9uIG8oKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKQogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBzKCkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKQogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB1KHQpIHsKICAgICAgICAgIGlmIChyID09PSBzZXRUaW1lb3V0KSByZXR1cm4gc2V0VGltZW91dCh0LCAwKQogICAgICAgICAgaWYgKChyID09PSBvIHx8ICFyKSAmJiBzZXRUaW1lb3V0KSByZXR1cm4gKHIgPSBzZXRUaW1lb3V0KSwgc2V0VGltZW91dCh0LCAwKQogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgcmV0dXJuIHIodCwgMCkKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICByZXR1cm4gci5jYWxsKG51bGwsIHQsIDApCiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICByZXR1cm4gci5jYWxsKHRoaXMsIHQsIDApCiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgIShmdW5jdGlvbiAoKSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICByID0gJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc2V0VGltZW91dCA/IHNldFRpbWVvdXQgOiBvOwogICAgICAgICAgfSBjYXRjaCAodCkgewogICAgICAgICAgICByID0gbzsKICAgICAgICAgIH0KICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIG4gPSAnZnVuY3Rpb24nID09IHR5cGVvZiBjbGVhclRpbWVvdXQgPyBjbGVhclRpbWVvdXQgOiBzOwogICAgICAgICAgfSBjYXRjaCAodCkgewogICAgICAgICAgICBuID0gczsKICAgICAgICAgIH0KICAgICAgICB9KSgpOwogICAgICAgIHZhciBhLAogICAgICAgICAgZiA9IFtdLAogICAgICAgICAgaCA9ICExLAogICAgICAgICAgbCA9IC0xOwogICAgICAgIGZ1bmN0aW9uIGMoKSB7CiAgICAgICAgICBoICYmIGEgJiYgKChoID0gITEpLCBhLmxlbmd0aCA/IChmID0gYS5jb25jYXQoZikpIDogKGwgPSAtMSksIGYubGVuZ3RoICYmIHAoKSk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIHAoKSB7CiAgICAgICAgICBpZiAoIWgpIHsKICAgICAgICAgICAgdmFyIHQgPSB1KGMpOwogICAgICAgICAgICBoID0gITA7CiAgICAgICAgICAgIGZvciAodmFyIGUgPSBmLmxlbmd0aDsgZTsgKSB7CiAgICAgICAgICAgICAgZm9yIChhID0gZiwgZiA9IFtdOyArK2wgPCBlOyApIGEgJiYgYVtsXS5ydW4oKQogICAgICAgICAgICAgIDsobCA9IC0xKSwgKGUgPSBmLmxlbmd0aCk7CiAgICAgICAgICAgIH0KICAoYSA9IG51bGwpLAogICAgICAgICAgICAgIChoID0gITEpLAogICAgICAgICAgICAgIChmdW5jdGlvbiAodCkgewogICAgICAgICAgICAgICAgaWYgKG4gPT09IGNsZWFyVGltZW91dCkgcmV0dXJuIGNsZWFyVGltZW91dCh0KQogICAgICAgICAgICAgICAgaWYgKChuID09PSBzIHx8ICFuKSAmJiBjbGVhclRpbWVvdXQpIHJldHVybiAobiA9IGNsZWFyVGltZW91dCksIGNsZWFyVGltZW91dCh0KQogICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgbih0KTsKICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5jYWxsKG51bGwsIHQpCiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5jYWxsKHRoaXMsIHQpCiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9KSh0KTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gZyh0LCBlKSB7CiAgKHRoaXMuZnVuID0gdCksICh0aGlzLmFycmF5ID0gZSk7CiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGQoKSB7fQogIChpLm5leHRUaWNrID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgIHZhciBlID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTsKICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIGVbciAtIDFdID0gYXJndW1lbnRzW3JdOwogICAgICAgICAgZi5wdXNoKG5ldyBnKHQsIGUpKSwgMSAhPT0gZi5sZW5ndGggfHwgaCB8fCB1KHApOwogICAgICAgIH0pLAogICAgICAgICAgKGcucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7CiAgICAgICAgICB9KSwKICAgICAgICAgIChpLnRpdGxlID0gJ2Jyb3dzZXInKSwKICAgICAgICAgIChpLmJyb3dzZXIgPSAhMCksCiAgICAgICAgICAoaS5lbnYgPSB7fSksCiAgICAgICAgICAoaS5hcmd2ID0gW10pLAogICAgICAgICAgKGkudmVyc2lvbiA9ICcnKSwKICAgICAgICAgIChpLnZlcnNpb25zID0ge30pLAogICAgICAgICAgKGkub24gPSBkKSwKICAgICAgICAgIChpLmFkZExpc3RlbmVyID0gZCksCiAgICAgICAgICAoaS5vbmNlID0gZCksCiAgICAgICAgICAoaS5vZmYgPSBkKSwKICAgICAgICAgIChpLnJlbW92ZUxpc3RlbmVyID0gZCksCiAgICAgICAgICAoaS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBkKSwKICAgICAgICAgIChpLmVtaXQgPSBkKSwKICAgICAgICAgIChpLnByZXBlbmRMaXN0ZW5lciA9IGQpLAogICAgICAgICAgKGkucHJlcGVuZE9uY2VMaXN0ZW5lciA9IGQpLAogICAgICAgICAgKGkubGlzdGVuZXJzID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgcmV0dXJuIFtdCiAgICAgICAgICB9KSwKICAgICAgICAgIChpLmJpbmRpbmcgPSBmdW5jdGlvbiAodCkgewogICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJykKICAgICAgICAgIH0pLAogICAgICAgICAgKGkuY3dkID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgICByZXR1cm4gJy8nCiAgICAgICAgICB9KSwKICAgICAgICAgIChpLmNoZGlyID0gZnVuY3Rpb24gKHQpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKQogICAgICAgICAgfSksCiAgICAgICAgICAoaS51bWFzayA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgcmV0dXJuIDAKICAgICAgICAgIH0pOwogICAgICB9LAogICAgXSkKICB9KTsKICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiAgY29uc3QgdW5wYWNrQnJpZGdlID0gV29ya2VyU2NvcGUudW5wYWNrQnJpZGdlOwoKICBsZXQgdW5wYWNrOwoKICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS11bnBhY2stLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogIHZhciBpbml0dW5wYWNrID0gZnVuY3Rpb24gKGJ1ZmZlcikgewogICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGhhcyBiZWVuIF9jYXJlZnVsbHlfIG1vZGlmaWVkIGJ5IGhhbmQuCiAgICAvLyBEdWUgdG8gV2ViUGFjayBlbWJlZGRpbmcgdGhpcyBzY3JpcHQgaW50byB0aGUgWmVhIGVuZ2luZQogICAgLy8gYnVpbGQsIGNlcnRhaW4gZmVhdHVyZXMgYnJva2UuCiAgICAvLyBUaGVyZSB3YXMgY29kZSB0byBoYW5kbGUgbG9hZGluZyBpbiBhIG5vZGVKUyBjb250ZXh0LCB0aGF0IHRyaWVkIHRvIGltcG9ydCgiZnMiKQogICAgLy8gV2ViUGFjayBrZXB0cyB0cmlwcGluZyB1cCBvbiB0aGF0IGNvZGUgaW4gaXRzIHN0YXRpYyBhbmFseXNpcyBvZiB0aGUgY29kZSwgc28KICAgIC8vIEkgY2FyZWZ1bGx5IHJlbW92ZWQgaXQuCiAgICAvLyBUaGUgZ2xvYmFsIHNjb3BlIG9mIHRoZSBzY3JpcHQgc2VlbXMgdG8gYmUgZGlmZmVyZW50LCBzbyB1bnBhY2tCcmlkZ2Ugd2FzIG5vdCBhdmFpbGFibGUuCiAgICAvLyBUaGUgdW5wYWNrQnJpZGdlIGNvZGUgYXNzaWducyB1bnBhY2tCcmlkZ2UgdG8gdGhlIHBhc3NlZCBpbiBzY29wZSwgd2hpY2ggaXMgJ3RoaXMnLCBidXQgdGhhdAogICAgLy8gc2NvcGUgaXNuJ3QgYXZhaWxhYmxlIGluc2lkZSB0aGlzICd1bnBhY2snIGZ1bmN0aW9uLgogICAgY29uc3QgdW5wYWNrID0gTW9kdWxlOwoKICAgIC8vIE5vdGU6IHRoZSBmb2xsb3dpbmcgaXMgdGhlIFVSTCBvZiB0aGUgdW5wYWNrLndhc20gZmlsZSBpbiBvdXIgWmVhRW5naW5lIHByb2plY3Qgb24gb3VyCiAgICAvLyBzZXJ2ZXIuIElkZWFsbHkgd2UgY291bGQgdXNlIGEgcmVsYXRpdmUgcGF0aCBmcm9tIHRoZSBaZWFFbmdpbmUgZmlsZSwgYnV0CiAgICAvLyB0aGF0IGlzbid0IHBvc3NpYmxlIHlldC4gKFRPRE86IEFzayBNYXVybyBhYm91dCB0aGlzKQogICAgY29uc3QgY3JlZGVudGlhbHMgPSAnb21pdCc7CgogICAgdmFyIEV4dCA9IHVucGFja0JyaWRnZS5FeHQ7CiAgICB2YXIganNBUEkgPSB7CiAgICAgIG9wZW46IGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gRXh0LmN1cnJlbnQub3Blbi5hcHBseShFeHQuY3VycmVudCwgYXJndW1lbnRzKQogICAgICB9LAogICAgICBjbG9zZTogZnVuY3Rpb24gKCkgewogICAgICAgIHJldHVybiBFeHQuY3VycmVudC5jbG9zZS5hcHBseShFeHQuY3VycmVudCwgYXJndW1lbnRzKQogICAgICB9LAogICAgICByZWFkOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgcmV0dXJuIEV4dC5jdXJyZW50LnJlYWQuYXBwbHkoRXh0LmN1cnJlbnQsIGFyZ3VtZW50cykKICAgICAgfSwKICAgICAgd3JpdGU6IGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gRXh0LmN1cnJlbnQud3JpdGUuYXBwbHkoRXh0LmN1cnJlbnQsIGFyZ3VtZW50cykKICAgICAgfSwKICAgICAgdGVsbDogZnVuY3Rpb24gKCkgewogICAgICAgIHJldHVybiBFeHQuY3VycmVudC50ZWxsLmFwcGx5KEV4dC5jdXJyZW50LCBhcmd1bWVudHMpCiAgICAgIH0sCiAgICAgIHNlZWs6IGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gRXh0LmN1cnJlbnQuc2Vlay5hcHBseShFeHQuY3VycmVudCwgYXJndW1lbnRzKQogICAgICB9LAogICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gRXh0LmN1cnJlbnQuY3JlYXRlLmFwcGx5KEV4dC5jdXJyZW50LCBhcmd1bWVudHMpCiAgICAgIH0sCiAgICB9OwogICAgdmFyIG1vZHVsZU92ZXJyaWRlcyA9IHt9OwogICAgdmFyIGtleTsKICAgIGZvciAoa2V5IGluIE1vZHVsZSkgewogICAgICBpZiAoTW9kdWxlLmhhc093blByb3BlcnR5KGtleSkpIHsKICAgICAgICBtb2R1bGVPdmVycmlkZXNba2V5XSA9IE1vZHVsZVtrZXldOwogICAgICB9CiAgICB9CiAgICBNb2R1bGVbJ3dhc21CaW5hcnknXSA9IGJ1ZmZlcjsKICAgIE1vZHVsZVsnYXJndW1lbnRzJ10gPSBbXTsKICAgIE1vZHVsZVsndGhpc1Byb2dyYW0nXSA9ICcuL3RoaXMucHJvZ3JhbSc7CiAgICBNb2R1bGVbJ3F1aXQnXSA9IGZ1bmN0aW9uIChzdGF0dXMsIHRvVGhyb3cpIHsKICAgICAgdGhyb3cgdG9UaHJvdwogICAgfTsKICAgIE1vZHVsZVsncHJlUnVuJ10gPSBbXTsKICAgIE1vZHVsZVsncG9zdFJ1biddID0gW107CiAgICB2YXIgRU5WSVJPTk1FTlRfSVNfV0VCID0gZmFsc2U7CiAgICB2YXIgRU5WSVJPTk1FTlRfSVNfV09SS0VSID0gZmFsc2U7CiAgICB2YXIgRU5WSVJPTk1FTlRfSVNfTk9ERSA9IGZhbHNlOwogICAgaWYgKE1vZHVsZVsnRU5WSVJPTk1FTlQnXSkgewogICAgICBpZiAoTW9kdWxlWydFTlZJUk9OTUVOVCddID09PSAnV0VCJykgewogICAgICAgIEVOVklST05NRU5UX0lTX1dFQiA9IHRydWU7CiAgICAgIH0gZWxzZSBpZiAoTW9kdWxlWydFTlZJUk9OTUVOVCddID09PSAnV09SS0VSJykgewogICAgICAgIEVOVklST05NRU5UX0lTX1dPUktFUiA9IHRydWU7CiAgICAgIH0gZWxzZSBpZiAoTW9kdWxlWydFTlZJUk9OTUVOVCddID09PSAnTk9ERScpIHsKICAgICAgICBFTlZJUk9OTUVOVF9JU19OT0RFID0gdHJ1ZTsKICAgICAgfSBlbHNlIGlmIChNb2R1bGVbJ0VOVklST05NRU5UJ10gPT09ICdTSEVMTCcpIDsgZWxzZSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJNb2R1bGVbJ0VOVklST05NRU5UJ10gdmFsdWUgaXMgbm90IHZhbGlkLiBtdXN0IGJlIG9uZSBvZjogV0VCfFdPUktFUnxOT0RFfFNIRUxMLiIpCiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIEVOVklST05NRU5UX0lTX1dFQiA9IHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnOwogICAgICBFTlZJUk9OTUVOVF9JU19XT1JLRVIgPSB0eXBlb2YgaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJzsKICAgICAgRU5WSVJPTk1FTlRfSVNfTk9ERSA9CiAgICAgICAgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiByZXF1aXJlID09PSAnZnVuY3Rpb24nICYmICFFTlZJUk9OTUVOVF9JU19XRUIgJiYgIUVOVklST05NRU5UX0lTX1dPUktFUjsKICAgIH0KICAgIGlmIChFTlZJUk9OTUVOVF9JU19XRUIgfHwgRU5WSVJPTk1FTlRfSVNfV09SS0VSKSB7CiAgICAgIE1vZHVsZVsncmVhZCddID0gZnVuY3Rpb24gc2hlbGxfcmVhZCh1cmwpIHsKICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7CiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UpOwogICAgICAgIHhoci5zZW5kKG51bGwpOwogICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0CiAgICAgIH07CiAgICAgIGlmIChFTlZJUk9OTUVOVF9JU19XT1JLRVIpIHsKICAgICAgICBNb2R1bGVbJ3JlYWRCaW5hcnknXSA9IGZ1bmN0aW9uIHJlYWRCaW5hcnkodXJsKSB7CiAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7CiAgICAgICAgICB4aHIub3BlbignR0VUJywgdXJsLCBmYWxzZSk7CiAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJzsKICAgICAgICAgIHhoci5zZW5kKG51bGwpOwogICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSkKICAgICAgICB9OwogICAgICB9CiAgICAgIE1vZHVsZVsncmVhZEFzeW5jJ10gPSBmdW5jdGlvbiByZWFkQXN5bmModXJsLCBvbmxvYWQsIG9uZXJyb3IpIHsKICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7CiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSk7CiAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7CiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIHhocl9vbmxvYWQoKSB7CiAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDAgfHwgKHhoci5zdGF0dXMgPT0gMCAmJiB4aHIucmVzcG9uc2UpKSB7CiAgICAgICAgICAgIG9ubG9hZCh4aHIucmVzcG9uc2UpOwogICAgICAgICAgICByZXR1cm4KICAgICAgICAgIH0KICAgICAgICAgIG9uZXJyb3IoKTsKICAgICAgICB9OwogICAgICAgIHhoci5vbmVycm9yID0gb25lcnJvcjsKICAgICAgICB4aHIuc2VuZChudWxsKTsKICAgICAgfTsKICAgICAgTW9kdWxlWydzZXRXaW5kb3dUaXRsZSddID0gZnVuY3Rpb24gKHRpdGxlKSB7CiAgICAgICAgZG9jdW1lbnQudGl0bGUgPSB0aXRsZTsKICAgICAgfTsKICAgIH0KICAgIE1vZHVsZVsncHJpbnQnXSA9CiAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyA/IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSkgOiB0eXBlb2YgcHJpbnQgIT09ICd1bmRlZmluZWQnID8gcHJpbnQgOiBudWxsOwogICAgTW9kdWxlWydwcmludEVyciddID0KICAgICAgdHlwZW9mIHByaW50RXJyICE9PSAndW5kZWZpbmVkJwogICAgICAgID8gcHJpbnRFcnIKICAgICAgICA6ICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uc29sZS53YXJuLmJpbmQoY29uc29sZSkpIHx8IE1vZHVsZVsncHJpbnQnXTsKICAgIE1vZHVsZS5wcmludCA9IE1vZHVsZVsncHJpbnQnXTsKICAgIE1vZHVsZS5wcmludEVyciA9IE1vZHVsZVsncHJpbnRFcnInXTsKICAgIGZvciAoa2V5IGluIG1vZHVsZU92ZXJyaWRlcykgewogICAgICBpZiAobW9kdWxlT3ZlcnJpZGVzLmhhc093blByb3BlcnR5KGtleSkpIHsKICAgICAgICBNb2R1bGVba2V5XSA9IG1vZHVsZU92ZXJyaWRlc1trZXldOwogICAgICB9CiAgICB9CiAgICBtb2R1bGVPdmVycmlkZXMgPSB1bmRlZmluZWQ7CiAgICB2YXIgU1RBQ0tfQUxJR04gPSAxNjsKICAgIGZ1bmN0aW9uIHN0YXRpY0FsbG9jKHNpemUpIHsKICAgICAgYXNzZXJ0KCFzdGF0aWNTZWFsZWQpOwogICAgICB2YXIgcmV0ID0gU1RBVElDVE9QOwogICAgICBTVEFUSUNUT1AgPSAoU1RBVElDVE9QICsgc2l6ZSArIDE1KSAmIC0xNjsKICAgICAgcmV0dXJuIHJldAogICAgfQogICAgZnVuY3Rpb24gZHluYW1pY0FsbG9jKHNpemUpIHsKICAgICAgYXNzZXJ0KERZTkFNSUNUT1BfUFRSKTsKICAgICAgdmFyIHJldCA9IEhFQVAzMltEWU5BTUlDVE9QX1BUUiA+PiAyXTsKICAgICAgdmFyIGVuZCA9IChyZXQgKyBzaXplICsgMTUpICYgLTE2OwogICAgICBIRUFQMzJbRFlOQU1JQ1RPUF9QVFIgPj4gMl0gPSBlbmQ7CiAgICAgIGlmIChlbmQgPj0gVE9UQUxfTUVNT1JZKSB7CiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBlbmxhcmdlTWVtb3J5KCk7CiAgICAgICAgaWYgKCFzdWNjZXNzKSB7CiAgICAgICAgICBIRUFQMzJbRFlOQU1JQ1RPUF9QVFIgPj4gMl0gPSByZXQ7CiAgICAgICAgICByZXR1cm4gMAogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gcmV0CiAgICB9CiAgICBmdW5jdGlvbiBhbGlnbk1lbW9yeShzaXplLCBmYWN0b3IpIHsKICAgICAgaWYgKCFmYWN0b3IpIGZhY3RvciA9IFNUQUNLX0FMSUdOOwogICAgICB2YXIgcmV0ID0gKHNpemUgPSBNYXRoLmNlaWwoc2l6ZSAvIGZhY3RvcikgKiBmYWN0b3IpOwogICAgICByZXR1cm4gcmV0CiAgICB9CiAgICBmdW5jdGlvbiBnZXROYXRpdmVUeXBlU2l6ZSh0eXBlKSB7CiAgICAgIHN3aXRjaCAodHlwZSkgewogICAgICAgIGNhc2UgJ2kxJzoKICAgICAgICBjYXNlICdpOCc6CiAgICAgICAgICByZXR1cm4gMQogICAgICAgIGNhc2UgJ2kxNic6CiAgICAgICAgICByZXR1cm4gMgogICAgICAgIGNhc2UgJ2kzMic6CiAgICAgICAgICByZXR1cm4gNAogICAgICAgIGNhc2UgJ2k2NCc6CiAgICAgICAgICByZXR1cm4gOAogICAgICAgIGNhc2UgJ2Zsb2F0JzoKICAgICAgICAgIHJldHVybiA0CiAgICAgICAgY2FzZSAnZG91YmxlJzoKICAgICAgICAgIHJldHVybiA4CiAgICAgICAgZGVmYXVsdDogewogICAgICAgICAgaWYgKHR5cGVbdHlwZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7CiAgICAgICAgICAgIHJldHVybiA0CiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVbMF0gPT09ICdpJykgewogICAgICAgICAgICB2YXIgYml0cyA9IHBhcnNlSW50KHR5cGUuc3Vic3RyKDEpKTsKICAgICAgICAgICAgYXNzZXJ0KGJpdHMgJSA4ID09PSAwKTsKICAgICAgICAgICAgcmV0dXJuIGJpdHMgLyA4CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICByZXR1cm4gMAogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfQogICAgbmV3IEFycmF5KDApOwogICAgdmFyIEdMT0JBTF9CQVNFID0gMTAyNDsKICAgIHZhciBBQk9SVCA9IDA7CiAgICBmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCB0ZXh0KSB7CiAgICAgIGlmICghY29uZGl0aW9uKSB7CiAgICAgICAgYWJvcnQoJ0Fzc2VydGlvbiBmYWlsZWQ6ICcgKyB0ZXh0KTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gc2V0VmFsdWUocHRyLCB2YWx1ZSwgdHlwZSwgbm9TYWZlKSB7CiAgICAgIHR5cGUgPSB0eXBlIHx8ICdpOCc7CiAgICAgIGlmICh0eXBlLmNoYXJBdCh0eXBlLmxlbmd0aCAtIDEpID09PSAnKicpIHR5cGUgPSAnaTMyJzsKICAgICAgc3dpdGNoICh0eXBlKSB7CiAgICAgICAgY2FzZSAnaTEnOgogICAgICAgICAgSEVBUDhbcHRyID4+IDBdID0gdmFsdWU7CiAgICAgICAgICBicmVhawogICAgICAgIGNhc2UgJ2k4JzoKICAgICAgICAgIEhFQVA4W3B0ciA+PiAwXSA9IHZhbHVlOwogICAgICAgICAgYnJlYWsKICAgICAgICBjYXNlICdpMTYnOgogICAgICAgICAgSEVBUDE2W3B0ciA+PiAxXSA9IHZhbHVlOwogICAgICAgICAgYnJlYWsKICAgICAgICBjYXNlICdpMzInOgogICAgICAgICAgSEVBUDMyW3B0ciA+PiAyXSA9IHZhbHVlOwogICAgICAgICAgYnJlYWsKICAgICAgICBjYXNlICdpNjQnOgogICh0ZW1wSTY0ID0gWwogICAgICAgICAgICB2YWx1ZSA+Pj4gMCwKICAgICAgICAgICAgKCh0ZW1wRG91YmxlID0gdmFsdWUpLAogICAgICAgICAgICArTWF0aF9hYnModGVtcERvdWJsZSkgPj0gMQogICAgICAgICAgICAgID8gdGVtcERvdWJsZSA+IDAKICAgICAgICAgICAgICAgID8gKE1hdGhfbWluKCtNYXRoX2Zsb29yKHRlbXBEb3VibGUgLyA0Mjk0OTY3Mjk2KSwgNDI5NDk2NzI5NSkgfCAwKSA+Pj4gMAogICAgICAgICAgICAgICAgOiB+fitNYXRoX2NlaWwoKHRlbXBEb3VibGUgLSArKH5+dGVtcERvdWJsZSA+Pj4gMCkpIC8gNDI5NDk2NzI5NikgPj4+IDAKICAgICAgICAgICAgICA6IDApLAogICAgICAgICAgXSksCiAgICAgICAgICAgIChIRUFQMzJbcHRyID4+IDJdID0gdGVtcEk2NFswXSksCiAgICAgICAgICAgIChIRUFQMzJbKHB0ciArIDQpID4+IDJdID0gdGVtcEk2NFsxXSk7CiAgICAgICAgICBicmVhawogICAgICAgIGNhc2UgJ2Zsb2F0JzoKICAgICAgICAgIEhFQVBGMzJbcHRyID4+IDJdID0gdmFsdWU7CiAgICAgICAgICBicmVhawogICAgICAgIGNhc2UgJ2RvdWJsZSc6CiAgICAgICAgICBIRUFQRjY0W3B0ciA+PiAzXSA9IHZhbHVlOwogICAgICAgICAgYnJlYWsKICAgICAgICBkZWZhdWx0OgogICAgICAgICAgYWJvcnQoJ2ludmFsaWQgdHlwZSBmb3Igc2V0VmFsdWU6ICcgKyB0eXBlKTsKICAgICAgfQogICAgfQogICAgdmFyIEFMTE9DX05PUk1BTCA9IDA7CiAgICB2YXIgQUxMT0NfU1RBVElDID0gMjsKICAgIHZhciBBTExPQ19OT05FID0gNDsKICAgIGZ1bmN0aW9uIGFsbG9jYXRlKHNsYWIsIHR5cGVzLCBhbGxvY2F0b3IsIHB0cikgewogICAgICB2YXIgemVyb2luaXQsIHNpemU7CiAgICAgIGlmICh0eXBlb2Ygc2xhYiA9PT0gJ251bWJlcicpIHsKICAgICAgICB6ZXJvaW5pdCA9IHRydWU7CiAgICAgICAgc2l6ZSA9IHNsYWI7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgemVyb2luaXQgPSBmYWxzZTsKICAgICAgICBzaXplID0gc2xhYi5sZW5ndGg7CiAgICAgIH0KICAgICAgdmFyIHNpbmdsZVR5cGUgPSB0eXBlb2YgdHlwZXMgPT09ICdzdHJpbmcnID8gdHlwZXMgOiBudWxsOwogICAgICB2YXIgcmV0OwogICAgICBpZiAoYWxsb2NhdG9yID09IEFMTE9DX05PTkUpIHsKICAgICAgICByZXQgPSBwdHI7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0ID0gW3R5cGVvZiBfbWFsbG9jID09PSAnZnVuY3Rpb24nID8gX21hbGxvYyA6IHN0YXRpY0FsbG9jLCBzdGFja0FsbG9jLCBzdGF0aWNBbGxvYywgZHluYW1pY0FsbG9jXVsKICAgICAgICAgIGFsbG9jYXRvciA9PT0gdW5kZWZpbmVkID8gQUxMT0NfU1RBVElDIDogYWxsb2NhdG9yCiAgICAgICAgXShNYXRoLm1heChzaXplLCBzaW5nbGVUeXBlID8gMSA6IHR5cGVzLmxlbmd0aCkpOwogICAgICB9CiAgICAgIGlmICh6ZXJvaW5pdCkgewogICAgICAgIHZhciBzdG9wOwogICAgICAgIHB0ciA9IHJldDsKICAgICAgICBhc3NlcnQoKHJldCAmIDMpID09IDApOwogICAgICAgIHN0b3AgPSByZXQgKyAoc2l6ZSAmIH4zKTsKICAgICAgICBmb3IgKDsgcHRyIDwgc3RvcDsgcHRyICs9IDQpIHsKICAgICAgICAgIEhFQVAzMltwdHIgPj4gMl0gPSAwOwogICAgICAgIH0KICAgICAgICBzdG9wID0gcmV0ICsgc2l6ZTsKICAgICAgICB3aGlsZSAocHRyIDwgc3RvcCkgewogICAgICAgICAgSEVBUDhbcHRyKysgPj4gMF0gPSAwOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0CiAgICAgIH0KICAgICAgaWYgKHNpbmdsZVR5cGUgPT09ICdpOCcpIHsKICAgICAgICBpZiAoc2xhYi5zdWJhcnJheSB8fCBzbGFiLnNsaWNlKSB7CiAgICAgICAgICBIRUFQVTguc2V0KHNsYWIsIHJldCk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIEhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoc2xhYiksIHJldCk7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQKICAgICAgfQogICAgICB2YXIgaSA9IDAsCiAgICAgICAgdHlwZSwKICAgICAgICB0eXBlU2l6ZSwKICAgICAgICBwcmV2aW91c1R5cGU7CiAgICAgIHdoaWxlIChpIDwgc2l6ZSkgewogICAgICAgIHZhciBjdXJyID0gc2xhYltpXTsKICAgICAgICB0eXBlID0gc2luZ2xlVHlwZSB8fCB0eXBlc1tpXTsKICAgICAgICBpZiAodHlwZSA9PT0gMCkgewogICAgICAgICAgaSsrOwogICAgICAgICAgY29udGludWUKICAgICAgICB9CiAgICAgICAgaWYgKHR5cGUgPT0gJ2k2NCcpIHR5cGUgPSAnaTMyJzsKICAgICAgICBzZXRWYWx1ZShyZXQgKyBpLCBjdXJyLCB0eXBlKTsKICAgICAgICBpZiAocHJldmlvdXNUeXBlICE9PSB0eXBlKSB7CiAgICAgICAgICB0eXBlU2l6ZSA9IGdldE5hdGl2ZVR5cGVTaXplKHR5cGUpOwogICAgICAgICAgcHJldmlvdXNUeXBlID0gdHlwZTsKICAgICAgICB9CiAgICAgICAgaSArPSB0eXBlU2l6ZTsKICAgICAgfQogICAgICByZXR1cm4gcmV0CiAgICB9CiAgICBmdW5jdGlvbiBQb2ludGVyX3N0cmluZ2lmeShwdHIsIGxlbmd0aCkgewogICAgICBpZiAobGVuZ3RoID09PSAwIHx8ICFwdHIpIHJldHVybiAnJwogICAgICB2YXIgaGFzVXRmID0gMDsKICAgICAgdmFyIHQ7CiAgICAgIHZhciBpID0gMDsKICAgICAgd2hpbGUgKDEpIHsKICAgICAgICB0ID0gSEVBUFU4WyhwdHIgKyBpKSA+PiAwXTsKICAgICAgICBoYXNVdGYgfD0gdDsKICAgICAgICBpZiAodCA9PSAwICYmICFsZW5ndGgpIGJyZWFrCiAgICAgICAgaSsrOwogICAgICAgIGlmIChsZW5ndGggJiYgaSA9PSBsZW5ndGgpIGJyZWFrCiAgICAgIH0KICAgICAgaWYgKCFsZW5ndGgpIGxlbmd0aCA9IGk7CiAgICAgIHZhciByZXQgPSAnJzsKICAgICAgaWYgKGhhc1V0ZiA8IDEyOCkgewogICAgICAgIHZhciBNQVhfQ0hVTksgPSAxMDI0OwogICAgICAgIHZhciBjdXJyOwogICAgICAgIHdoaWxlIChsZW5ndGggPiAwKSB7CiAgICAgICAgICBjdXJyID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIEhFQVBVOC5zdWJhcnJheShwdHIsIHB0ciArIE1hdGgubWluKGxlbmd0aCwgTUFYX0NIVU5LKSkpOwogICAgICAgICAgcmV0ID0gcmV0ID8gcmV0ICsgY3VyciA6IGN1cnI7CiAgICAgICAgICBwdHIgKz0gTUFYX0NIVU5LOwogICAgICAgICAgbGVuZ3RoIC09IE1BWF9DSFVOSzsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldAogICAgICB9CiAgICAgIHJldHVybiBVVEY4VG9TdHJpbmcocHRyKQogICAgfQogICAgdmFyIFVURjhEZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpIDogdW5kZWZpbmVkOwogICAgZnVuY3Rpb24gVVRGOEFycmF5VG9TdHJpbmcodThBcnJheSwgaWR4KSB7CiAgICAgIHZhciBlbmRQdHIgPSBpZHg7CiAgICAgIHdoaWxlICh1OEFycmF5W2VuZFB0cl0pICsrZW5kUHRyOwogICAgICBpZiAoZW5kUHRyIC0gaWR4ID4gMTYgJiYgdThBcnJheS5zdWJhcnJheSAmJiBVVEY4RGVjb2RlcikgewogICAgICAgIHJldHVybiBVVEY4RGVjb2Rlci5kZWNvZGUodThBcnJheS5zdWJhcnJheShpZHgsIGVuZFB0cikpCiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmFyIHUwLCB1MSwgdTIsIHUzLCB1NCwgdTU7CiAgICAgICAgdmFyIHN0ciA9ICcnOwogICAgICAgIHdoaWxlICgxKSB7CiAgICAgICAgICB1MCA9IHU4QXJyYXlbaWR4KytdOwogICAgICAgICAgaWYgKCF1MCkgcmV0dXJuIHN0cgogICAgICAgICAgaWYgKCEodTAgJiAxMjgpKSB7CiAgICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHUwKTsKICAgICAgICAgICAgY29udGludWUKICAgICAgICAgIH0KICAgICAgICAgIHUxID0gdThBcnJheVtpZHgrK10gJiA2MzsKICAgICAgICAgIGlmICgodTAgJiAyMjQpID09IDE5MikgewogICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKHUwICYgMzEpIDw8IDYpIHwgdTEpOwogICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgfQogICAgICAgICAgdTIgPSB1OEFycmF5W2lkeCsrXSAmIDYzOwogICAgICAgICAgaWYgKCh1MCAmIDI0MCkgPT0gMjI0KSB7CiAgICAgICAgICAgIHUwID0gKCh1MCAmIDE1KSA8PCAxMikgfCAodTEgPDwgNikgfCB1MjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHUzID0gdThBcnJheVtpZHgrK10gJiA2MzsKICAgICAgICAgICAgaWYgKCh1MCAmIDI0OCkgPT0gMjQwKSB7CiAgICAgICAgICAgICAgdTAgPSAoKHUwICYgNykgPDwgMTgpIHwgKHUxIDw8IDEyKSB8ICh1MiA8PCA2KSB8IHUzOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHU0ID0gdThBcnJheVtpZHgrK10gJiA2MzsKICAgICAgICAgICAgICBpZiAoKHUwICYgMjUyKSA9PSAyNDgpIHsKICAgICAgICAgICAgICAgIHUwID0gKCh1MCAmIDMpIDw8IDI0KSB8ICh1MSA8PCAxOCkgfCAodTIgPDwgMTIpIHwgKHUzIDw8IDYpIHwgdTQ7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHU1ID0gdThBcnJheVtpZHgrK10gJiA2MzsKICAgICAgICAgICAgICAgIHUwID0gKCh1MCAmIDEpIDw8IDMwKSB8ICh1MSA8PCAyNCkgfCAodTIgPDwgMTgpIHwgKHUzIDw8IDEyKSB8ICh1NCA8PCA2KSB8IHU1OwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKHUwIDwgNjU1MzYpIHsKICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodTApOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIGNoID0gdTAgLSA2NTUzNjsKICAgICAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTYgfCAoY2ggPj4gMTApLCA1NjMyMCB8IChjaCAmIDEwMjMpKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIFVURjhUb1N0cmluZyhwdHIpIHsKICAgICAgcmV0dXJuIFVURjhBcnJheVRvU3RyaW5nKEhFQVBVOCwgcHRyKQogICAgfQogICAgZnVuY3Rpb24gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBvdXRVOEFycmF5LCBvdXRJZHgsIG1heEJ5dGVzVG9Xcml0ZSkgewogICAgICBpZiAoIShtYXhCeXRlc1RvV3JpdGUgPiAwKSkgcmV0dXJuIDAKICAgICAgdmFyIHN0YXJ0SWR4ID0gb3V0SWR4OwogICAgICB2YXIgZW5kSWR4ID0gb3V0SWR4ICsgbWF4Qnl0ZXNUb1dyaXRlIC0gMTsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHsKICAgICAgICB2YXIgdSA9IHN0ci5jaGFyQ29kZUF0KGkpOwogICAgICAgIGlmICh1ID49IDU1Mjk2ICYmIHUgPD0gNTczNDMpIHUgPSAoNjU1MzYgKyAoKHUgJiAxMDIzKSA8PCAxMCkpIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAxMDIzKTsKICAgICAgICBpZiAodSA8PSAxMjcpIHsKICAgICAgICAgIGlmIChvdXRJZHggPj0gZW5kSWR4KSBicmVhawogICAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSB1OwogICAgICAgIH0gZWxzZSBpZiAodSA8PSAyMDQ3KSB7CiAgICAgICAgICBpZiAob3V0SWR4ICsgMSA+PSBlbmRJZHgpIGJyZWFrCiAgICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDE5MiB8ICh1ID4+IDYpOwogICAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAxMjggfCAodSAmIDYzKTsKICAgICAgICB9IGVsc2UgaWYgKHUgPD0gNjU1MzUpIHsKICAgICAgICAgIGlmIChvdXRJZHggKyAyID49IGVuZElkeCkgYnJlYWsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMjI0IHwgKHUgPj4gMTIpOwogICAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAxMjggfCAoKHUgPj4gNikgJiA2Myk7CiAgICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDEyOCB8ICh1ICYgNjMpOwogICAgICAgIH0gZWxzZSBpZiAodSA8PSAyMDk3MTUxKSB7CiAgICAgICAgICBpZiAob3V0SWR4ICsgMyA+PSBlbmRJZHgpIGJyZWFrCiAgICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDI0MCB8ICh1ID4+IDE4KTsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMTI4IHwgKCh1ID4+IDEyKSAmIDYzKTsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMTI4IHwgKCh1ID4+IDYpICYgNjMpOwogICAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAxMjggfCAodSAmIDYzKTsKICAgICAgICB9IGVsc2UgaWYgKHUgPD0gNjcxMDg4NjMpIHsKICAgICAgICAgIGlmIChvdXRJZHggKyA0ID49IGVuZElkeCkgYnJlYWsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMjQ4IHwgKHUgPj4gMjQpOwogICAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAxMjggfCAoKHUgPj4gMTgpICYgNjMpOwogICAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAxMjggfCAoKHUgPj4gMTIpICYgNjMpOwogICAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAxMjggfCAoKHUgPj4gNikgJiA2Myk7CiAgICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDEyOCB8ICh1ICYgNjMpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAob3V0SWR4ICsgNSA+PSBlbmRJZHgpIGJyZWFrCiAgICAgICAgICBvdXRVOEFycmF5W291dElkeCsrXSA9IDI1MiB8ICh1ID4+IDMwKTsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMTI4IHwgKCh1ID4+IDI0KSAmIDYzKTsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMTI4IHwgKCh1ID4+IDE4KSAmIDYzKTsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMTI4IHwgKCh1ID4+IDEyKSAmIDYzKTsKICAgICAgICAgIG91dFU4QXJyYXlbb3V0SWR4KytdID0gMTI4IHwgKCh1ID4+IDYpICYgNjMpOwogICAgICAgICAgb3V0VThBcnJheVtvdXRJZHgrK10gPSAxMjggfCAodSAmIDYzKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgb3V0VThBcnJheVtvdXRJZHhdID0gMDsKICAgICAgcmV0dXJuIG91dElkeCAtIHN0YXJ0SWR4CiAgICB9CiAgICBmdW5jdGlvbiBzdHJpbmdUb1VURjgoc3RyLCBvdXRQdHIsIG1heEJ5dGVzVG9Xcml0ZSkgewogICAgICByZXR1cm4gc3RyaW5nVG9VVEY4QXJyYXkoc3RyLCBIRUFQVTgsIG91dFB0ciwgbWF4Qnl0ZXNUb1dyaXRlKQogICAgfQogICAgZnVuY3Rpb24gbGVuZ3RoQnl0ZXNVVEY4KHN0cikgewogICAgICB2YXIgbGVuID0gMDsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHsKICAgICAgICB2YXIgdSA9IHN0ci5jaGFyQ29kZUF0KGkpOwogICAgICAgIGlmICh1ID49IDU1Mjk2ICYmIHUgPD0gNTczNDMpIHUgPSAoNjU1MzYgKyAoKHUgJiAxMDIzKSA8PCAxMCkpIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAxMDIzKTsKICAgICAgICBpZiAodSA8PSAxMjcpIHsKICAgICAgICAgICsrbGVuOwogICAgICAgIH0gZWxzZSBpZiAodSA8PSAyMDQ3KSB7CiAgICAgICAgICBsZW4gKz0gMjsKICAgICAgICB9IGVsc2UgaWYgKHUgPD0gNjU1MzUpIHsKICAgICAgICAgIGxlbiArPSAzOwogICAgICAgIH0gZWxzZSBpZiAodSA8PSAyMDk3MTUxKSB7CiAgICAgICAgICBsZW4gKz0gNDsKICAgICAgICB9IGVsc2UgaWYgKHUgPD0gNjcxMDg4NjMpIHsKICAgICAgICAgIGxlbiArPSA1OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBsZW4gKz0gNjsKICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIGxlbgogICAgfQogICAgdHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RGVjb2RlcigndXRmLTE2bGUnKSA6IHVuZGVmaW5lZDsKICAgIGZ1bmN0aW9uIFVURjMyVG9TdHJpbmcocHRyKSB7CiAgICAgIHZhciBpID0gMDsKICAgICAgdmFyIHN0ciA9ICcnOwogICAgICB3aGlsZSAoMSkgewogICAgICAgIHZhciB1dGYzMiA9IEhFQVAzMlsocHRyICsgaSAqIDQpID4+IDJdOwogICAgICAgIGlmICh1dGYzMiA9PSAwKSByZXR1cm4gc3RyCiAgICAgICAgKytpOwogICAgICAgIGlmICh1dGYzMiA+PSA2NTUzNikgewogICAgICAgICAgdmFyIGNoID0gdXRmMzIgLSA2NTUzNjsKICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDU1Mjk2IHwgKGNoID4+IDEwKSwgNTYzMjAgfCAoY2ggJiAxMDIzKSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHV0ZjMyKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGFsbG9jYXRlVVRGOChzdHIpIHsKICAgICAgdmFyIHNpemUgPSBsZW5ndGhCeXRlc1VURjgoc3RyKSArIDE7CiAgICAgIHZhciByZXQgPSBfbWFsbG9jKHNpemUpOwogICAgICBpZiAocmV0KSBzdHJpbmdUb1VURjhBcnJheShzdHIsIEhFQVA4LCByZXQsIHNpemUpOwogICAgICByZXR1cm4gcmV0CiAgICB9CiAgICBmdW5jdGlvbiBkZW1hbmdsZShmdW5jKSB7CiAgICAgIHJldHVybiBmdW5jCiAgICB9CiAgICBmdW5jdGlvbiBkZW1hbmdsZUFsbCh0ZXh0KSB7CiAgICAgIHZhciByZWdleCA9IC9fX1pbXHdcZF9dKy9nOwogICAgICByZXR1cm4gdGV4dC5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbiAoeCkgewogICAgICAgIHZhciB5ID0gZGVtYW5nbGUoeCk7CiAgICAgICAgcmV0dXJuIHggPT09IHkgPyB4IDogeCArICcgWycgKyB5ICsgJ10nCiAgICAgIH0pCiAgICB9CiAgICBmdW5jdGlvbiBqc1N0YWNrVHJhY2UoKSB7CiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTsKICAgICAgaWYgKCFlcnIuc3RhY2spIHsKICAgICAgICB0cnkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKDApCiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgZXJyID0gZTsKICAgICAgICB9CiAgICAgICAgaWYgKCFlcnIuc3RhY2spIHsKICAgICAgICAgIHJldHVybiAnKG5vIHN0YWNrIHRyYWNlIGF2YWlsYWJsZSknCiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBlcnIuc3RhY2sudG9TdHJpbmcoKQogICAgfQogICAgZnVuY3Rpb24gc3RhY2tUcmFjZSgpIHsKICAgICAgdmFyIGpzID0ganNTdGFja1RyYWNlKCk7CiAgICAgIGlmIChNb2R1bGVbJ2V4dHJhU3RhY2tUcmFjZSddKSBqcyArPSAnXG4nICsgTW9kdWxlWydleHRyYVN0YWNrVHJhY2UnXSgpOwogICAgICByZXR1cm4gZGVtYW5nbGVBbGwoanMpCiAgICB9CiAgICB2YXIgV0FTTV9QQUdFX1NJWkUgPSA2NTUzNjsKICAgIHZhciBBU01KU19QQUdFX1NJWkUgPSAxNjc3NzIxNjsKICAgIHZhciBNSU5fVE9UQUxfTUVNT1JZID0gMTY3NzcyMTY7CiAgICBmdW5jdGlvbiBhbGlnblVwKHgsIG11bHRpcGxlKSB7CiAgICAgIGlmICh4ICUgbXVsdGlwbGUgPiAwKSB7CiAgICAgICAgeCArPSBtdWx0aXBsZSAtICh4ICUgbXVsdGlwbGUpOwogICAgICB9CiAgICAgIHJldHVybiB4CiAgICB9CiAgICB2YXIgYnVmZmVyLCBIRUFQOCwgSEVBUFU4LCBIRUFQMTYsIEhFQVBVMTYsIEhFQVAzMiwgSEVBUFUzMiwgSEVBUEYzMiwgSEVBUEY2NDsKICAgIGZ1bmN0aW9uIHVwZGF0ZUdsb2JhbEJ1ZmZlcihidWYpIHsKICAgICAgTW9kdWxlWydidWZmZXInXSA9IGJ1ZmZlciA9IGJ1ZjsKICAgIH0KICAgIGZ1bmN0aW9uIHVwZGF0ZUdsb2JhbEJ1ZmZlclZpZXdzKCkgewogICAgICBNb2R1bGVbJ0hFQVA4J10gPSBIRUFQOCA9IG5ldyBJbnQ4QXJyYXkoYnVmZmVyKTsKICAgICAgTW9kdWxlWydIRUFQMTYnXSA9IEhFQVAxNiA9IG5ldyBJbnQxNkFycmF5KGJ1ZmZlcik7CiAgICAgIE1vZHVsZVsnSEVBUDMyJ10gPSBIRUFQMzIgPSBuZXcgSW50MzJBcnJheShidWZmZXIpOwogICAgICBNb2R1bGVbJ0hFQVBVOCddID0gSEVBUFU4ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTsKICAgICAgTW9kdWxlWydIRUFQVTE2J10gPSBIRUFQVTE2ID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlcik7CiAgICAgIE1vZHVsZVsnSEVBUFUzMiddID0gSEVBUFUzMiA9IG5ldyBVaW50MzJBcnJheShidWZmZXIpOwogICAgICBNb2R1bGVbJ0hFQVBGMzInXSA9IEhFQVBGMzIgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlcik7CiAgICAgIE1vZHVsZVsnSEVBUEY2NCddID0gSEVBUEY2NCA9IG5ldyBGbG9hdDY0QXJyYXkoYnVmZmVyKTsKICAgIH0KICAgIHZhciBTVEFUSUNfQkFTRSwgU1RBVElDVE9QLCBzdGF0aWNTZWFsZWQ7CiAgICB2YXIgU1RBQ0tfQkFTRSwgU1RBQ0tUT1AsIFNUQUNLX01BWDsKICAgIHZhciBEWU5BTUlDX0JBU0UsIERZTkFNSUNUT1BfUFRSOwogICAgU1RBVElDX0JBU0UgPSBTVEFUSUNUT1AgPSBTVEFDS19CQVNFID0gU1RBQ0tUT1AgPSBTVEFDS19NQVggPSBEWU5BTUlDX0JBU0UgPSBEWU5BTUlDVE9QX1BUUiA9IDA7CiAgICBzdGF0aWNTZWFsZWQgPSBmYWxzZTsKICAgIGZ1bmN0aW9uIGFib3J0T25DYW5ub3RHcm93TWVtb3J5KCkgewogICAgICBhYm9ydCgKICAgICAgICAnQ2Fubm90IGVubGFyZ2UgbWVtb3J5IGFycmF5cy4gRWl0aGVyICgxKSBjb21waWxlIHdpdGggIC1zIFRPVEFMX01FTU9SWT1YICB3aXRoIFggaGlnaGVyIHRoYW4gdGhlIGN1cnJlbnQgdmFsdWUgJyArCiAgICAgICAgICBUT1RBTF9NRU1PUlkgKwogICAgICAgICAgJywgKDIpIGNvbXBpbGUgd2l0aCAgLXMgQUxMT1dfTUVNT1JZX0dST1dUSD0xICB3aGljaCBhbGxvd3MgaW5jcmVhc2luZyB0aGUgc2l6ZSBhdCBydW50aW1lLCBvciAoMykgaWYgeW91IHdhbnQgbWFsbG9jIHRvIHJldHVybiBOVUxMICgwKSBpbnN0ZWFkIG9mIHRoaXMgYWJvcnQsIGNvbXBpbGUgd2l0aCAgLXMgQUJPUlRJTkdfTUFMTE9DPTAgJwogICAgICApOwogICAgfQogICAgaWYgKCFNb2R1bGVbJ3JlYWxsb2NCdWZmZXInXSkKICAgICAgTW9kdWxlWydyZWFsbG9jQnVmZmVyJ10gPSBmdW5jdGlvbiAoc2l6ZSkgewogICAgICAgIHZhciByZXQ7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmIChBcnJheUJ1ZmZlci50cmFuc2ZlcikgewogICAgICAgICAgICByZXQgPSBBcnJheUJ1ZmZlci50cmFuc2ZlcihidWZmZXIsIHNpemUpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIG9sZEhFQVA4ID0gSEVBUDg7CiAgICAgICAgICAgIHJldCA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTsKICAgICAgICAgICAgdmFyIHRlbXAgPSBuZXcgSW50OEFycmF5KHJldCk7CiAgICAgICAgICAgIHRlbXAuc2V0KG9sZEhFQVA4KTsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgICB9CiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBfZW1zY3JpcHRlbl9yZXBsYWNlX21lbW9yeShyZXQpOwogICAgICAgIGlmICghc3VjY2VzcykgcmV0dXJuIGZhbHNlCiAgICAgICAgcmV0dXJuIHJldAogICAgICB9OwogICAgZnVuY3Rpb24gZW5sYXJnZU1lbW9yeSgpIHsKICAgICAgdmFyIFBBR0VfTVVMVElQTEUgPSBNb2R1bGVbJ3VzaW5nV2FzbSddID8gV0FTTV9QQUdFX1NJWkUgOiBBU01KU19QQUdFX1NJWkU7CiAgICAgIHZhciBMSU1JVCA9IDIxNDc0ODM2NDggLSBQQUdFX01VTFRJUExFOwogICAgICBpZiAoSEVBUDMyW0RZTkFNSUNUT1BfUFRSID4+IDJdID4gTElNSVQpIHsKICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgfQogICAgICB2YXIgT0xEX1RPVEFMX01FTU9SWSA9IFRPVEFMX01FTU9SWTsKICAgICAgVE9UQUxfTUVNT1JZID0gTWF0aC5tYXgoVE9UQUxfTUVNT1JZLCBNSU5fVE9UQUxfTUVNT1JZKTsKICAgICAgd2hpbGUgKFRPVEFMX01FTU9SWSA8IEhFQVAzMltEWU5BTUlDVE9QX1BUUiA+PiAyXSkgewogICAgICAgIGlmIChUT1RBTF9NRU1PUlkgPD0gNTM2ODcwOTEyKSB7CiAgICAgICAgICBUT1RBTF9NRU1PUlkgPSBhbGlnblVwKDIgKiBUT1RBTF9NRU1PUlksIFBBR0VfTVVMVElQTEUpOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBUT1RBTF9NRU1PUlkgPSBNYXRoLm1pbihhbGlnblVwKCgzICogVE9UQUxfTUVNT1JZICsgMjE0NzQ4MzY0OCkgLyA0LCBQQUdFX01VTFRJUExFKSwgTElNSVQpOwogICAgICAgIH0KICAgICAgfQogICAgICB2YXIgcmVwbGFjZW1lbnQgPSBNb2R1bGVbJ3JlYWxsb2NCdWZmZXInXShUT1RBTF9NRU1PUlkpOwogICAgICBpZiAoIXJlcGxhY2VtZW50IHx8IHJlcGxhY2VtZW50LmJ5dGVMZW5ndGggIT0gVE9UQUxfTUVNT1JZKSB7CiAgICAgICAgVE9UQUxfTUVNT1JZID0gT0xEX1RPVEFMX01FTU9SWTsKICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgfQogICAgICB1cGRhdGVHbG9iYWxCdWZmZXIocmVwbGFjZW1lbnQpOwogICAgICB1cGRhdGVHbG9iYWxCdWZmZXJWaWV3cygpOwogICAgICByZXR1cm4gdHJ1ZQogICAgfQogICAgdmFyIGJ5dGVMZW5ndGg7CiAgICB0cnkgewogICAgICBieXRlTGVuZ3RoID0gRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwuYmluZChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEFycmF5QnVmZmVyLnByb3RvdHlwZSwgJ2J5dGVMZW5ndGgnKS5nZXQpOwogICAgICBieXRlTGVuZ3RoKG5ldyBBcnJheUJ1ZmZlcig0KSk7CiAgICB9IGNhdGNoIChlKSB7CiAgICAgIGJ5dGVMZW5ndGggPSBmdW5jdGlvbiAoYnVmZmVyKSB7CiAgICAgICAgcmV0dXJuIGJ1ZmZlci5ieXRlTGVuZ3RoCiAgICAgIH07CiAgICB9CiAgICB2YXIgVE9UQUxfU1RBQ0sgPSBNb2R1bGVbJ1RPVEFMX1NUQUNLJ10gfHwgNTI0Mjg4MDsKICAgIHZhciBUT1RBTF9NRU1PUlkgPSBNb2R1bGVbJ1RPVEFMX01FTU9SWSddIHx8IDE2Nzc3MjE2OwogICAgaWYgKFRPVEFMX01FTU9SWSA8IFRPVEFMX1NUQUNLKQogICAgICBNb2R1bGUucHJpbnRFcnIoCiAgICAgICAgJ1RPVEFMX01FTU9SWSBzaG91bGQgYmUgbGFyZ2VyIHRoYW4gVE9UQUxfU1RBQ0ssIHdhcyAnICsgVE9UQUxfTUVNT1JZICsgJyEgKFRPVEFMX1NUQUNLPScgKyBUT1RBTF9TVEFDSyArICcpJwogICAgICApOwogICAgaWYgKE1vZHVsZVsnYnVmZmVyJ10pIHsKICAgICAgYnVmZmVyID0gTW9kdWxlWydidWZmZXInXTsKICAgIH0gZWxzZSB7CiAgICAgIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBXZWJBc3NlbWJseS5NZW1vcnkgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICBNb2R1bGVbJ3dhc21NZW1vcnknXSA9IG5ldyBXZWJBc3NlbWJseS5NZW1vcnkoeyBpbml0aWFsOiBUT1RBTF9NRU1PUlkgLyBXQVNNX1BBR0VfU0laRSB9KTsKICAgICAgICBidWZmZXIgPSBNb2R1bGVbJ3dhc21NZW1vcnknXS5idWZmZXI7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKFRPVEFMX01FTU9SWSk7CiAgICAgIH0KICAgICAgTW9kdWxlWydidWZmZXInXSA9IGJ1ZmZlcjsKICAgIH0KICAgIHVwZGF0ZUdsb2JhbEJ1ZmZlclZpZXdzKCk7CiAgICBmdW5jdGlvbiBnZXRUb3RhbE1lbW9yeSgpIHsKICAgICAgcmV0dXJuIFRPVEFMX01FTU9SWQogICAgfQogICAgSEVBUDMyWzBdID0gMTY2ODUwOTAyOTsKICAgIEhFQVAxNlsxXSA9IDI1NDU5OwogICAgaWYgKEhFQVBVOFsyXSAhPT0gMTE1IHx8IEhFQVBVOFszXSAhPT0gOTkpIHRocm93ICdSdW50aW1lIGVycm9yOiBleHBlY3RlZCB0aGUgc3lzdGVtIHRvIGJlIGxpdHRsZS1lbmRpYW4hJwogICAgZnVuY3Rpb24gY2FsbFJ1bnRpbWVDYWxsYmFja3MoY2FsbGJhY2tzKSB7CiAgICAgIHdoaWxlIChjYWxsYmFja3MubGVuZ3RoID4gMCkgewogICAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrcy5zaGlmdCgpOwogICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgY2FsbGJhY2soKTsKICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgfQogICAgICAgIHZhciBmdW5jID0gY2FsbGJhY2suZnVuYzsKICAgICAgICBpZiAodHlwZW9mIGZ1bmMgPT09ICdudW1iZXInKSB7CiAgICAgICAgICBpZiAoY2FsbGJhY2suYXJnID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgTW9kdWxlWydkeW5DYWxsX3YnXShmdW5jKTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIE1vZHVsZVsnZHluQ2FsbF92aSddKGZ1bmMsIGNhbGxiYWNrLmFyZyk7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGZ1bmMoY2FsbGJhY2suYXJnID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2suYXJnKTsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIHZhciBfX0FUUFJFUlVOX18gPSBbXTsKICAgIHZhciBfX0FUSU5JVF9fID0gW107CiAgICB2YXIgX19BVE1BSU5fXyA9IFtdOwogICAgdmFyIF9fQVRFWElUX18gPSBbXTsKICAgIHZhciBfX0FUUE9TVFJVTl9fID0gW107CiAgICB2YXIgcnVudGltZUluaXRpYWxpemVkID0gZmFsc2U7CiAgICBmdW5jdGlvbiBwcmVSdW4oKSB7CiAgICAgIGlmIChNb2R1bGVbJ3ByZVJ1biddKSB7CiAgICAgICAgaWYgKHR5cGVvZiBNb2R1bGVbJ3ByZVJ1biddID09ICdmdW5jdGlvbicpIE1vZHVsZVsncHJlUnVuJ10gPSBbTW9kdWxlWydwcmVSdW4nXV07CiAgICAgICAgd2hpbGUgKE1vZHVsZVsncHJlUnVuJ10ubGVuZ3RoKSB7CiAgICAgICAgICBhZGRPblByZVJ1bihNb2R1bGVbJ3ByZVJ1biddLnNoaWZ0KCkpOwogICAgICAgIH0KICAgICAgfQogICAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pOwogICAgfQogICAgZnVuY3Rpb24gZW5zdXJlSW5pdFJ1bnRpbWUoKSB7CiAgICAgIGlmIChydW50aW1lSW5pdGlhbGl6ZWQpIHJldHVybgogICAgICBydW50aW1lSW5pdGlhbGl6ZWQgPSB0cnVlOwogICAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKTsKICAgIH0KICAgIGZ1bmN0aW9uIHByZU1haW4oKSB7CiAgICAgIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRNQUlOX18pOwogICAgfQogICAgZnVuY3Rpb24gZXhpdFJ1bnRpbWUoKSB7CiAgICAgIGNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRFWElUX18pOwogICAgfQogICAgZnVuY3Rpb24gcG9zdFJ1bigpIHsKICAgICAgaWYgKE1vZHVsZVsncG9zdFJ1biddKSB7CiAgICAgICAgaWYgKHR5cGVvZiBNb2R1bGVbJ3Bvc3RSdW4nXSA9PSAnZnVuY3Rpb24nKSBNb2R1bGVbJ3Bvc3RSdW4nXSA9IFtNb2R1bGVbJ3Bvc3RSdW4nXV07CiAgICAgICAgd2hpbGUgKE1vZHVsZVsncG9zdFJ1biddLmxlbmd0aCkgewogICAgICAgICAgYWRkT25Qb3N0UnVuKE1vZHVsZVsncG9zdFJ1biddLnNoaWZ0KCkpOwogICAgICAgIH0KICAgICAgfQogICAgICBjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUE9TVFJVTl9fKTsKICAgIH0KICAgIGZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKSB7CiAgICAgIF9fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKTsKICAgIH0KICAgIGZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYikgewogICAgICBfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpOwogICAgfQogICAgZnVuY3Rpb24gd3JpdGVBc2NpaVRvTWVtb3J5KHN0ciwgYnVmZmVyLCBkb250QWRkTnVsbCkgewogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkgewogICAgICAgIEhFQVA4W2J1ZmZlcisrID4+IDBdID0gc3RyLmNoYXJDb2RlQXQoaSk7CiAgICAgIH0KICAgICAgaWYgKCFkb250QWRkTnVsbCkgSEVBUDhbYnVmZmVyID4+IDBdID0gMDsKICAgIH0KICAgIHZhciBNYXRoX2FicyA9IE1hdGguYWJzOwogICAgdmFyIE1hdGhfY2VpbCA9IE1hdGguY2VpbDsKICAgIHZhciBNYXRoX2Zsb29yID0gTWF0aC5mbG9vcjsKICAgIHZhciBNYXRoX21pbiA9IE1hdGgubWluOwogICAgdmFyIHJ1bkRlcGVuZGVuY2llcyA9IDA7CiAgICB2YXIgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDsKICAgIGZ1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koaWQpIHsKICAgICAgcnVuRGVwZW5kZW5jaWVzKys7CiAgICAgIGlmIChNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXSkgewogICAgICAgIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKHJ1bkRlcGVuZGVuY2llcyk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpIHsKICAgICAgcnVuRGVwZW5kZW5jaWVzLS07CiAgICAgIGlmIChNb2R1bGVbJ21vbml0b3JSdW5EZXBlbmRlbmNpZXMnXSkgewogICAgICAgIE1vZHVsZVsnbW9uaXRvclJ1bkRlcGVuZGVuY2llcyddKHJ1bkRlcGVuZGVuY2llcyk7CiAgICAgIH0KICAgICAgaWYgKHJ1bkRlcGVuZGVuY2llcyA9PSAwKSB7CiAgICAgICAgaWYgKGRlcGVuZGVuY2llc0Z1bGZpbGxlZCkgewogICAgICAgICAgdmFyIGNhbGxiYWNrID0gZGVwZW5kZW5jaWVzRnVsZmlsbGVkOwogICAgICAgICAgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gbnVsbDsKICAgICAgICAgIGNhbGxiYWNrKCk7CiAgICAgICAgfQogICAgICB9CiAgICB9CiAgICBNb2R1bGVbJ3ByZWxvYWRlZEltYWdlcyddID0ge307CiAgICBNb2R1bGVbJ3ByZWxvYWRlZEF1ZGlvcyddID0ge307CiAgICB2YXIgZGF0YVVSSVByZWZpeCA9ICdkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsJzsKICAgIGZ1bmN0aW9uIGlzRGF0YVVSSShmaWxlbmFtZSkgewogICAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoID8gZmlsZW5hbWUuc3RhcnRzV2l0aChkYXRhVVJJUHJlZml4KSA6IGZpbGVuYW1lLmluZGV4T2YoZGF0YVVSSVByZWZpeCkgPT09IDAKICAgIH0KICAgIGZ1bmN0aW9uIGludGVncmF0ZVdhc21KUygpIHsKICAgICAgdmFyIHdhc21UZXh0RmlsZSA9ICd1bnBhY2sud2FzdCc7CiAgICAgIHZhciBhc21qc0NvZGVGaWxlID0gJ3VucGFjay50ZW1wLmFzbS5qcyc7CiAgICAgIGlmICh0eXBlb2YgTW9kdWxlWydsb2NhdGVGaWxlJ10gPT09ICdmdW5jdGlvbicpIHsKICAgICAgICBpZiAoIWlzRGF0YVVSSSh3YXNtVGV4dEZpbGUpKSB7CiAgICAgICAgICB3YXNtVGV4dEZpbGUgPSBNb2R1bGVbJ2xvY2F0ZUZpbGUnXSh3YXNtVGV4dEZpbGUpOwogICAgICAgIH0KICAgICAgICBpZiAoIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkpIHsKICAgICAgICAgIHdhc21CaW5hcnlGaWxlID0gTW9kdWxlWydsb2NhdGVGaWxlJ10od2FzbUJpbmFyeUZpbGUpOwogICAgICAgIH0KICAgICAgICBpZiAoIWlzRGF0YVVSSShhc21qc0NvZGVGaWxlKSkgewogICAgICAgICAgYXNtanNDb2RlRmlsZSA9IE1vZHVsZVsnbG9jYXRlRmlsZSddKGFzbWpzQ29kZUZpbGUpOwogICAgICAgIH0KICAgICAgfQogICAgICB2YXIgd2FzbVBhZ2VTaXplID0gNjQgKiAxMDI0OwogICAgICB2YXIgaW5mbyA9IHsKICAgICAgICBnbG9iYWw6IG51bGwsCiAgICAgICAgZW52OiBudWxsLAogICAgICAgIGFzbTJ3YXNtOiB7CiAgICAgICAgICAnZjY0LXJlbSc6IGZ1bmN0aW9uICh4LCB5KSB7CiAgICAgICAgICAgIHJldHVybiB4ICUgeQogICAgICAgICAgfSwKICAgICAgICAgIGRlYnVnZ2VyOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIGRlYnVnZ2VyCiAgICAgICAgICB9LAogICAgICAgIH0sCiAgICAgICAgcGFyZW50OiBNb2R1bGUsCiAgICAgIH07CiAgICAgIHZhciBleHBvcnRzID0gbnVsbDsKICAgICAgZnVuY3Rpb24gbWVyZ2VNZW1vcnkobmV3QnVmZmVyKSB7CiAgICAgICAgdmFyIG9sZEJ1ZmZlciA9IE1vZHVsZVsnYnVmZmVyJ107CiAgICAgICAgaWYgKG5ld0J1ZmZlci5ieXRlTGVuZ3RoIDwgb2xkQnVmZmVyLmJ5dGVMZW5ndGgpIHsKICAgICAgICAgIE1vZHVsZVsncHJpbnRFcnInXSgKICAgICAgICAgICAgJ3RoZSBuZXcgYnVmZmVyIGluIG1lcmdlTWVtb3J5IGlzIHNtYWxsZXIgdGhhbiB0aGUgcHJldmlvdXMgb25lLiBpbiBuYXRpdmUgd2FzbSwgd2Ugc2hvdWxkIGdyb3cgbWVtb3J5IGhlcmUnCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgICB2YXIgb2xkVmlldyA9IG5ldyBJbnQ4QXJyYXkob2xkQnVmZmVyKTsKICAgICAgICB2YXIgbmV3VmlldyA9IG5ldyBJbnQ4QXJyYXkobmV3QnVmZmVyKTsKICAgICAgICBuZXdWaWV3LnNldChvbGRWaWV3KTsKICAgICAgICB1cGRhdGVHbG9iYWxCdWZmZXIobmV3QnVmZmVyKTsKICAgICAgICB1cGRhdGVHbG9iYWxCdWZmZXJWaWV3cygpOwogICAgICB9CiAgICAgIGZ1bmN0aW9uIGZpeEltcG9ydHMoaW1wb3J0cykgewogICAgICAgIHJldHVybiBpbXBvcnRzCiAgICAgIH0KICAgICAgZnVuY3Rpb24gZ2V0QmluYXJ5KCkgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoTW9kdWxlWyd3YXNtQmluYXJ5J10pIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KE1vZHVsZVsnd2FzbUJpbmFyeSddKQogICAgICAgICAgfQogICAgICAgICAgaWYgKE1vZHVsZVsncmVhZEJpbmFyeSddKSB7CiAgICAgICAgICAgIHJldHVybiBNb2R1bGVbJ3JlYWRCaW5hcnknXSh3YXNtQmluYXJ5RmlsZSkKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRocm93ICJvbiB0aGUgd2ViLCB3ZSBuZWVkIHRoZSB3YXNtIGJpbmFyeSB0byBiZSBwcmVsb2FkZWQgYW5kIHNldCBvbiBNb2R1bGVbJ3dhc21CaW5hcnknXS4gZW1jYy5weSB3aWxsIGRvIHRoYXQgZm9yIHlvdSB3aGVuIGdlbmVyYXRpbmcgSFRNTCAoYnV0IG5vdCBKUykiCiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZXJyKSB7CiAgICAgICAgICBhYm9ydChlcnIpOwogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBnZXRCaW5hcnlQcm9taXNlKCkgewogICAgICAgIGlmICghTW9kdWxlWyd3YXNtQmluYXJ5J10gJiYgKEVOVklST05NRU5UX0lTX1dFQiB8fCBFTlZJUk9OTUVOVF9JU19XT1JLRVIpICYmIHR5cGVvZiBmZXRjaCA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgcmV0dXJuIGZldGNoKHdhc21CaW5hcnlGaWxlLCB7IGNyZWRlbnRpYWxzIH0pCiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkgewogICAgICAgICAgICAgIGlmICghcmVzcG9uc2VbJ29rJ10pIHsKICAgICAgICAgICAgICAgIHRocm93ICJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICciICsgd2FzbUJpbmFyeUZpbGUgKyAiJyIKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlWydhcnJheUJ1ZmZlciddKCkKICAgICAgICAgICAgfSkKICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICByZXR1cm4gZ2V0QmluYXJ5KCkKICAgICAgICAgICAgfSkKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsKICAgICAgICAgIHJlc29sdmUoZ2V0QmluYXJ5KCkpOwogICAgICAgIH0pCiAgICAgIH0KICAgICAgZnVuY3Rpb24gZG9OYXRpdmVXYXNtKGdsb2JhbCwgZW52LCBwcm92aWRlZEJ1ZmZlcikgewogICAgICAgIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgIT09ICdvYmplY3QnKSB7CiAgICAgICAgICBNb2R1bGVbJ3ByaW50RXJyJ10oJ25vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWQnKTsKICAgICAgICAgIHJldHVybiBmYWxzZQogICAgICAgIH0KICAgICAgICBpZiAoIShNb2R1bGVbJ3dhc21NZW1vcnknXSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1lbW9yeSkpIHsKICAgICAgICAgIE1vZHVsZVsncHJpbnRFcnInXSgnbm8gbmF0aXZlIHdhc20gTWVtb3J5IGluIHVzZScpOwogICAgICAgICAgcmV0dXJuIGZhbHNlCiAgICAgICAgfQogICAgICAgIGVudlsnbWVtb3J5J10gPSBNb2R1bGVbJ3dhc21NZW1vcnknXTsKICAgICAgICBpbmZvWydnbG9iYWwnXSA9IHsgTmFOOiBOYU4sIEluZmluaXR5OiBJbmZpbml0eSB9OwogICAgICAgIGluZm9bJ2dsb2JhbC5NYXRoJ10gPSBNYXRoOwogICAgICAgIGluZm9bJ2VudiddID0gZW52OwogICAgICAgIGZ1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSwgbW9kdWxlKSB7CiAgICAgICAgICBleHBvcnRzID0gaW5zdGFuY2UuZXhwb3J0czsKICAgICAgICAgIGlmIChleHBvcnRzLm1lbW9yeSkgbWVyZ2VNZW1vcnkoZXhwb3J0cy5tZW1vcnkpOwogICAgICAgICAgTW9kdWxlWydhc20nXSA9IGV4cG9ydHM7CiAgICAgICAgICBNb2R1bGVbJ3VzaW5nV2FzbSddID0gdHJ1ZTsKICAgICAgICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koKTsKICAgICAgICB9CiAgICAgICAgYWRkUnVuRGVwZW5kZW5jeSgpOwogICAgICAgIGlmIChNb2R1bGVbJ2luc3RhbnRpYXRlV2FzbSddKSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICByZXR1cm4gTW9kdWxlWydpbnN0YW50aWF0ZVdhc20nXShpbmZvLCByZWNlaXZlSW5zdGFuY2UpCiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIE1vZHVsZVsncHJpbnRFcnInXSgnTW9kdWxlLmluc3RhbnRpYXRlV2FzbSBjYWxsYmFjayBmYWlsZWQgd2l0aCBlcnJvcjogJyArIGUpOwogICAgICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnVuY3Rpb24gcmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZShvdXRwdXQpIHsKICAgICAgICAgIHJlY2VpdmVJbnN0YW5jZShvdXRwdXRbJ2luc3RhbmNlJ10sIG91dHB1dFsnbW9kdWxlJ10pOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKHJlY2VpdmVyKSB7CiAgICAgICAgICBnZXRCaW5hcnlQcm9taXNlKCkKICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKGJpbmFyeSkgewogICAgICAgICAgICAgIHJldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiaW5hcnksIGluZm8pCiAgICAgICAgICAgIH0pCiAgICAgICAgICAgIC50aGVuKHJlY2VpdmVyKQogICAgICAgICAgICAuY2F0Y2goZnVuY3Rpb24gKHJlYXNvbikgewogICAgICAgICAgICAgIE1vZHVsZVsncHJpbnRFcnInXSgnZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJyArIHJlYXNvbik7CiAgICAgICAgICAgICAgYWJvcnQocmVhc29uKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIGlmICgKICAgICAgICAgICFNb2R1bGVbJ3dhc21CaW5hcnknXSAmJgogICAgICAgICAgdHlwZW9mIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nID09PSAnZnVuY3Rpb24nICYmCiAgICAgICAgICAhaXNEYXRhVVJJKHdhc21CaW5hcnlGaWxlKSAmJgogICAgICAgICAgdHlwZW9mIGZldGNoID09PSAnZnVuY3Rpb24nCiAgICAgICAgKSB7CiAgICAgICAgICBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhmZXRjaCh3YXNtQmluYXJ5RmlsZSwgeyBjcmVkZW50aWFscyB9KSwgaW5mbykKICAgICAgICAgICAgLnRoZW4ocmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZSkKICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChyZWFzb24pIHsKICAgICAgICAgICAgICBNb2R1bGVbJ3ByaW50RXJyJ10oJ3dhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAnICsgcmVhc29uKTsKICAgICAgICAgICAgICBNb2R1bGVbJ3ByaW50RXJyJ10oJ2ZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uJyk7CiAgICAgICAgICAgICAgaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihyZWNlaXZlSW5zdGFudGlhdGVkU291cmNlKTsKICAgICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIocmVjZWl2ZUluc3RhbnRpYXRlZFNvdXJjZSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiB7fQogICAgICB9CiAgICAgIE1vZHVsZVsnYXNtUHJlbG9hZCddID0gTW9kdWxlWydhc20nXTsKICAgICAgdmFyIGFzbWpzUmVhbGxvY0J1ZmZlciA9IE1vZHVsZVsncmVhbGxvY0J1ZmZlciddOwogICAgICB2YXIgd2FzbVJlYWxsb2NCdWZmZXIgPSBmdW5jdGlvbiAoc2l6ZSkgewogICAgICAgIHZhciBQQUdFX01VTFRJUExFID0gTW9kdWxlWyd1c2luZ1dhc20nXSA/IFdBU01fUEFHRV9TSVpFIDogQVNNSlNfUEFHRV9TSVpFOwogICAgICAgIHNpemUgPSBhbGlnblVwKHNpemUsIFBBR0VfTVVMVElQTEUpOwogICAgICAgIHZhciBvbGQgPSBNb2R1bGVbJ2J1ZmZlciddOwogICAgICAgIHZhciBvbGRTaXplID0gb2xkLmJ5dGVMZW5ndGg7CiAgICAgICAgaWYgKE1vZHVsZVsndXNpbmdXYXNtJ10pIHsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHZhciByZXN1bHQgPSBNb2R1bGVbJ3dhc21NZW1vcnknXS5ncm93KChzaXplIC0gb2xkU2l6ZSkgLyB3YXNtUGFnZVNpemUpOwogICAgICAgICAgICBpZiAocmVzdWx0ICE9PSAoLTEgfCAwKSkgewogICAgICAgICAgICAgIHJldHVybiAoTW9kdWxlWydidWZmZXInXSA9IE1vZHVsZVsnd2FzbU1lbW9yeSddLmJ1ZmZlcikKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gbnVsbAogICAgICAgICAgICB9CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIHJldHVybiBudWxsCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9OwogICAgICBNb2R1bGVbJ3JlYWxsb2NCdWZmZXInXSA9IGZ1bmN0aW9uIChzaXplKSB7CiAgICAgICAgaWYgKGZpbmFsTWV0aG9kID09PSAnYXNtanMnKSB7CiAgICAgICAgICByZXR1cm4gYXNtanNSZWFsbG9jQnVmZmVyKHNpemUpCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJldHVybiB3YXNtUmVhbGxvY0J1ZmZlcihzaXplKQogICAgICAgIH0KICAgICAgfTsKICAgICAgdmFyIGZpbmFsTWV0aG9kID0gJyc7CiAgICAgIE1vZHVsZVsnYXNtJ10gPSBmdW5jdGlvbiAoZ2xvYmFsLCBlbnYsIHByb3ZpZGVkQnVmZmVyKSB7CiAgICAgICAgZW52ID0gZml4SW1wb3J0cyhlbnYpOwogICAgICAgIGlmICghZW52Wyd0YWJsZSddKSB7CiAgICAgICAgICB2YXIgVEFCTEVfU0laRSA9IE1vZHVsZVsnd2FzbVRhYmxlU2l6ZSddOwogICAgICAgICAgaWYgKFRBQkxFX1NJWkUgPT09IHVuZGVmaW5lZCkgVEFCTEVfU0laRSA9IDEwMjQ7CiAgICAgICAgICB2YXIgTUFYX1RBQkxFX1NJWkUgPSBNb2R1bGVbJ3dhc21NYXhUYWJsZVNpemUnXTsKICAgICAgICAgIGlmICh0eXBlb2YgV2ViQXNzZW1ibHkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBXZWJBc3NlbWJseS5UYWJsZSA9PT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICBpZiAoTUFYX1RBQkxFX1NJWkUgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIGVudlsndGFibGUnXSA9IG5ldyBXZWJBc3NlbWJseS5UYWJsZSh7IGluaXRpYWw6IFRBQkxFX1NJWkUsIG1heGltdW06IE1BWF9UQUJMRV9TSVpFLCBlbGVtZW50OiAnYW55ZnVuYycgfSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgZW52Wyd0YWJsZSddID0gbmV3IFdlYkFzc2VtYmx5LlRhYmxlKHsgaW5pdGlhbDogVEFCTEVfU0laRSwgZWxlbWVudDogJ2FueWZ1bmMnIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBlbnZbJ3RhYmxlJ10gPSBuZXcgQXJyYXkoVEFCTEVfU0laRSk7CiAgICAgICAgICB9CiAgICAgICAgICBNb2R1bGVbJ3dhc21UYWJsZSddID0gZW52Wyd0YWJsZSddOwogICAgICAgIH0KICAgICAgICBpZiAoIWVudlsnbWVtb3J5QmFzZSddKSB7CiAgICAgICAgICBlbnZbJ21lbW9yeUJhc2UnXSA9IE1vZHVsZVsnU1RBVElDX0JBU0UnXTsKICAgICAgICB9CiAgICAgICAgaWYgKCFlbnZbJ3RhYmxlQmFzZSddKSB7CiAgICAgICAgICBlbnZbJ3RhYmxlQmFzZSddID0gMDsKICAgICAgICB9CiAgICAgICAgdmFyIGV4cG9ydHM7CiAgICAgICAgZXhwb3J0cyA9IGRvTmF0aXZlV2FzbShnbG9iYWwsIGVudik7CiAgICAgICAgaWYgKCFleHBvcnRzKQogICAgICAgICAgYWJvcnQoCiAgICAgICAgICAgICdubyBiaW5hcnllbiBtZXRob2Qgc3VjY2VlZGVkLiBjb25zaWRlciBlbmFibGluZyBtb3JlIG9wdGlvbnMsIGxpa2UgaW50ZXJwcmV0aW5nLCBpZiB5b3Ugd2FudCB0aGF0OiBodHRwczovL2dpdGh1Yi5jb20va3JpcGtlbi9lbXNjcmlwdGVuL3dpa2kvV2ViQXNzZW1ibHkjYmluYXJ5ZW4tbWV0aG9kcycKICAgICAgICAgICk7CiAgICAgICAgcmV0dXJuIGV4cG9ydHMKICAgICAgfTsKICAgIH0KICAgIGludGVncmF0ZVdhc21KUygpOwogICAgU1RBVElDX0JBU0UgPSBHTE9CQUxfQkFTRTsKICAgIFNUQVRJQ1RPUCA9IFNUQVRJQ19CQVNFICsgNjY5NjA7CiAgICBfX0FUSU5JVF9fLnB1c2goCiAgICAgIHsKICAgICAgICBmdW5jOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICBfX0dMT0JBTF9fc3ViX0lfZ2xvYmFsX2NwcCgpOwogICAgICAgIH0sCiAgICAgIH0sCiAgICAgIHsKICAgICAgICBmdW5jOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICBfX0dMT0JBTF9fc3ViX0lfY3JjX2NwcCgpOwogICAgICAgIH0sCiAgICAgIH0sCiAgICAgIHsKICAgICAgICBmdW5jOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICBfX0dMT0JBTF9fc3ViX0lfYnJpZGdlX2NwcCgpOwogICAgICAgIH0sCiAgICAgIH0sCiAgICAgIHsKICAgICAgICBmdW5jOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICBfX0dMT0JBTF9fc3ViX0lfYmluZF9jcHAoKTsKICAgICAgICB9LAogICAgICB9CiAgICApOwogICAgdmFyIFNUQVRJQ19CVU1QID0gNjY5NjA7CiAgICBNb2R1bGVbJ1NUQVRJQ19CQVNFJ10gPSBTVEFUSUNfQkFTRTsKICAgIE1vZHVsZVsnU1RBVElDX0JVTVAnXSA9IFNUQVRJQ19CVU1QOwogICAgU1RBVElDVE9QICs9IDE2OwogICAgZnVuY3Rpb24gX19fY3hhX2FsbG9jYXRlX2V4Y2VwdGlvbihzaXplKSB7CiAgICAgIHJldHVybiBfbWFsbG9jKHNpemUpCiAgICB9CiAgICB2YXIgRVhDRVBUSU9OUyA9IHsKICAgICAgbGFzdDogMCwKICAgICAgY2F1Z2h0OiBbXSwKICAgICAgaW5mb3M6IHt9LAogICAgICBkZUFkanVzdDogZnVuY3Rpb24gKGFkanVzdGVkKSB7CiAgICAgICAgaWYgKCFhZGp1c3RlZCB8fCBFWENFUFRJT05TLmluZm9zW2FkanVzdGVkXSkgcmV0dXJuIGFkanVzdGVkCiAgICAgICAgZm9yICh2YXIga2V5IGluIEVYQ0VQVElPTlMuaW5mb3MpIHsKICAgICAgICAgIHZhciBwdHIgPSAra2V5OwogICAgICAgICAgdmFyIGluZm8gPSBFWENFUFRJT05TLmluZm9zW3B0cl07CiAgICAgICAgICBpZiAoaW5mby5hZGp1c3RlZCA9PT0gYWRqdXN0ZWQpIHsKICAgICAgICAgICAgcmV0dXJuIHB0cgogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gYWRqdXN0ZWQKICAgICAgfSwKICAgICAgYWRkUmVmOiBmdW5jdGlvbiAocHRyKSB7CiAgICAgICAgaWYgKCFwdHIpIHJldHVybgogICAgICAgIHZhciBpbmZvID0gRVhDRVBUSU9OUy5pbmZvc1twdHJdOwogICAgICAgIGluZm8ucmVmY291bnQrKzsKICAgICAgfSwKICAgICAgZGVjUmVmOiBmdW5jdGlvbiAocHRyKSB7CiAgICAgICAgaWYgKCFwdHIpIHJldHVybgogICAgICAgIHZhciBpbmZvID0gRVhDRVBUSU9OUy5pbmZvc1twdHJdOwogICAgICAgIGFzc2VydChpbmZvLnJlZmNvdW50ID4gMCk7CiAgICAgICAgaW5mby5yZWZjb3VudC0tOwogICAgICAgIGlmIChpbmZvLnJlZmNvdW50ID09PSAwICYmICFpbmZvLnJldGhyb3duKSB7CiAgICAgICAgICBpZiAoaW5mby5kZXN0cnVjdG9yKSB7CiAgICAgICAgICAgIE1vZHVsZVsnZHluQ2FsbF92aSddKGluZm8uZGVzdHJ1Y3RvciwgcHRyKTsKICAgICAgICAgIH0KICAgICAgICAgIGRlbGV0ZSBFWENFUFRJT05TLmluZm9zW3B0cl07CiAgICAgICAgICBfX19jeGFfZnJlZV9leGNlcHRpb24ocHRyKTsKICAgICAgICB9CiAgICAgIH0sCiAgICAgIGNsZWFyUmVmOiBmdW5jdGlvbiAocHRyKSB7CiAgICAgICAgaWYgKCFwdHIpIHJldHVybgogICAgICAgIHZhciBpbmZvID0gRVhDRVBUSU9OUy5pbmZvc1twdHJdOwogICAgICAgIGluZm8ucmVmY291bnQgPSAwOwogICAgICB9LAogICAgfTsKICAgIGZ1bmN0aW9uIF9fX2N4YV9iZWdpbl9jYXRjaChwdHIpIHsKICAgICAgdmFyIGluZm8gPSBFWENFUFRJT05TLmluZm9zW3B0cl07CiAgICAgIGlmIChpbmZvICYmICFpbmZvLmNhdWdodCkgewogICAgICAgIGluZm8uY2F1Z2h0ID0gdHJ1ZTsKICAgICAgfQogICAgICBpZiAoaW5mbykgaW5mby5yZXRocm93biA9IGZhbHNlOwogICAgICBFWENFUFRJT05TLmNhdWdodC5wdXNoKHB0cik7CiAgICAgIEVYQ0VQVElPTlMuYWRkUmVmKEVYQ0VQVElPTlMuZGVBZGp1c3QocHRyKSk7CiAgICAgIHJldHVybiBwdHIKICAgIH0KICAgIGZ1bmN0aW9uIF9fX2N4YV9mcmVlX2V4Y2VwdGlvbihwdHIpIHsKICAgICAgdHJ5IHsKICAgICAgICByZXR1cm4gX2ZyZWUocHRyKQogICAgICB9IGNhdGNoIChlKSB7fQogICAgfQogICAgZnVuY3Rpb24gX19fY3hhX2VuZF9jYXRjaCgpIHsKICAgICAgTW9kdWxlWydzZXRUaHJldyddKDApOwogICAgICB2YXIgcHRyID0gRVhDRVBUSU9OUy5jYXVnaHQucG9wKCk7CiAgICAgIGlmIChwdHIpIHsKICAgICAgICBFWENFUFRJT05TLmRlY1JlZihFWENFUFRJT05TLmRlQWRqdXN0KHB0cikpOwogICAgICAgIEVYQ0VQVElPTlMubGFzdCA9IDA7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIF9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzIoKSB7CiAgICAgIHJldHVybiBfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaC5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9CiAgICBmdW5jdGlvbiBfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaF8zKCkgewogICAgICByZXR1cm4gX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2guYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfQogICAgZnVuY3Rpb24gX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2hfNCgpIHsKICAgICAgcmV0dXJuIF9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0KICAgIGZ1bmN0aW9uIF9fX3Jlc3VtZUV4Y2VwdGlvbihwdHIpIHsKICAgICAgaWYgKCFFWENFUFRJT05TLmxhc3QpIHsKICAgICAgICBFWENFUFRJT05TLmxhc3QgPSBwdHI7CiAgICAgIH0KICAgICAgdGhyb3cgcHRyCiAgICB9CiAgICBmdW5jdGlvbiBfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaCgpIHsKICAgICAgdmFyIHRocm93biA9IEVYQ0VQVElPTlMubGFzdDsKICAgICAgaWYgKCF0aHJvd24pIHsKICAgICAgICByZXR1cm4gKHNldFRlbXBSZXQwKDApLCAwKSB8IDAKICAgICAgfQogICAgICB2YXIgaW5mbyA9IEVYQ0VQVElPTlMuaW5mb3NbdGhyb3duXTsKICAgICAgdmFyIHRocm93bnR5cGUgPSBpbmZvLnR5cGU7CiAgICAgIGlmICghdGhyb3dudHlwZSkgewogICAgICAgIHJldHVybiAoc2V0VGVtcFJldDAoMCksIHRocm93bikgfCAwCiAgICAgIH0KICAgICAgdmFyIHR5cGVBcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7CiAgICAgIE1vZHVsZVsnX19fY3hhX2lzX3BvaW50ZXJfdHlwZSddKHRocm93bnR5cGUpOwogICAgICBpZiAoIV9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoLmJ1ZmZlcikgX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2guYnVmZmVyID0gX21hbGxvYyg0KTsKICAgICAgSEVBUDMyW19fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoLmJ1ZmZlciA+PiAyXSA9IHRocm93bjsKICAgICAgdGhyb3duID0gX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2guYnVmZmVyOwogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVBcnJheS5sZW5ndGg7IGkrKykgewogICAgICAgIGlmICh0eXBlQXJyYXlbaV0gJiYgTW9kdWxlWydfX19jeGFfY2FuX2NhdGNoJ10odHlwZUFycmF5W2ldLCB0aHJvd250eXBlLCB0aHJvd24pKSB7CiAgICAgICAgICB0aHJvd24gPSBIRUFQMzJbdGhyb3duID4+IDJdOwogICAgICAgICAgaW5mby5hZGp1c3RlZCA9IHRocm93bjsKICAgICAgICAgIHJldHVybiAoc2V0VGVtcFJldDAodHlwZUFycmF5W2ldKSwgdGhyb3duKSB8IDAKICAgICAgICB9CiAgICAgIH0KICAgICAgdGhyb3duID0gSEVBUDMyW3Rocm93biA+PiAyXTsKICAgICAgcmV0dXJuIChzZXRUZW1wUmV0MCh0aHJvd250eXBlKSwgdGhyb3duKSB8IDAKICAgIH0KICAgIGZ1bmN0aW9uIF9fX2N4YV90aHJvdyhwdHIsIHR5cGUsIGRlc3RydWN0b3IpIHsKICAgICAgRVhDRVBUSU9OUy5pbmZvc1twdHJdID0gewogICAgICAgIHB0cjogcHRyLAogICAgICAgIGFkanVzdGVkOiBwdHIsCiAgICAgICAgdHlwZTogdHlwZSwKICAgICAgICBkZXN0cnVjdG9yOiBkZXN0cnVjdG9yLAogICAgICAgIHJlZmNvdW50OiAwLAogICAgICAgIGNhdWdodDogZmFsc2UsCiAgICAgICAgcmV0aHJvd246IGZhbHNlLAogICAgICB9OwogICAgICBFWENFUFRJT05TLmxhc3QgPSBwdHI7CiAgICAgIHRocm93IHB0cgogICAgfQogICAgZnVuY3Rpb24gX19fbG9jaygpIHt9CiAgICB2YXIgRVJSTk9fQ09ERVMgPSB7CiAgICAgIEVQRVJNOiAxLAogICAgICBFTk9FTlQ6IDIsCiAgICAgIEVTUkNIOiAzLAogICAgICBFSU5UUjogNCwKICAgICAgRUlPOiA1LAogICAgICBFTlhJTzogNiwKICAgICAgRTJCSUc6IDcsCiAgICAgIEVOT0VYRUM6IDgsCiAgICAgIEVCQURGOiA5LAogICAgICBFQ0hJTEQ6IDEwLAogICAgICBFQUdBSU46IDExLAogICAgICBFV09VTERCTE9DSzogMTEsCiAgICAgIEVOT01FTTogMTIsCiAgICAgIEVBQ0NFUzogMTMsCiAgICAgIEVGQVVMVDogMTQsCiAgICAgIEVOT1RCTEs6IDE1LAogICAgICBFQlVTWTogMTYsCiAgICAgIEVFWElTVDogMTcsCiAgICAgIEVYREVWOiAxOCwKICAgICAgRU5PREVWOiAxOSwKICAgICAgRU5PVERJUjogMjAsCiAgICAgIEVJU0RJUjogMjEsCiAgICAgIEVJTlZBTDogMjIsCiAgICAgIEVORklMRTogMjMsCiAgICAgIEVNRklMRTogMjQsCiAgICAgIEVOT1RUWTogMjUsCiAgICAgIEVUWFRCU1k6IDI2LAogICAgICBFRkJJRzogMjcsCiAgICAgIEVOT1NQQzogMjgsCiAgICAgIEVTUElQRTogMjksCiAgICAgIEVST0ZTOiAzMCwKICAgICAgRU1MSU5LOiAzMSwKICAgICAgRVBJUEU6IDMyLAogICAgICBFRE9NOiAzMywKICAgICAgRVJBTkdFOiAzNCwKICAgICAgRU5PTVNHOiA0MiwKICAgICAgRUlEUk06IDQzLAogICAgICBFQ0hSTkc6IDQ0LAogICAgICBFTDJOU1lOQzogNDUsCiAgICAgIEVMM0hMVDogNDYsCiAgICAgIEVMM1JTVDogNDcsCiAgICAgIEVMTlJORzogNDgsCiAgICAgIEVVTkFUQ0g6IDQ5LAogICAgICBFTk9DU0k6IDUwLAogICAgICBFTDJITFQ6IDUxLAogICAgICBFREVBRExLOiAzNSwKICAgICAgRU5PTENLOiAzNywKICAgICAgRUJBREU6IDUyLAogICAgICBFQkFEUjogNTMsCiAgICAgIEVYRlVMTDogNTQsCiAgICAgIEVOT0FOTzogNTUsCiAgICAgIEVCQURSUUM6IDU2LAogICAgICBFQkFEU0xUOiA1NywKICAgICAgRURFQURMT0NLOiAzNSwKICAgICAgRUJGT05UOiA1OSwKICAgICAgRU5PU1RSOiA2MCwKICAgICAgRU5PREFUQTogNjEsCiAgICAgIEVUSU1FOiA2MiwKICAgICAgRU5PU1I6IDYzLAogICAgICBFTk9ORVQ6IDY0LAogICAgICBFTk9QS0c6IDY1LAogICAgICBFUkVNT1RFOiA2NiwKICAgICAgRU5PTElOSzogNjcsCiAgICAgIEVBRFY6IDY4LAogICAgICBFU1JNTlQ6IDY5LAogICAgICBFQ09NTTogNzAsCiAgICAgIEVQUk9UTzogNzEsCiAgICAgIEVNVUxUSUhPUDogNzIsCiAgICAgIEVET1RET1Q6IDczLAogICAgICBFQkFETVNHOiA3NCwKICAgICAgRU5PVFVOSVE6IDc2LAogICAgICBFQkFERkQ6IDc3LAogICAgICBFUkVNQ0hHOiA3OCwKICAgICAgRUxJQkFDQzogNzksCiAgICAgIEVMSUJCQUQ6IDgwLAogICAgICBFTElCU0NOOiA4MSwKICAgICAgRUxJQk1BWDogODIsCiAgICAgIEVMSUJFWEVDOiA4MywKICAgICAgRU5PU1lTOiAzOCwKICAgICAgRU5PVEVNUFRZOiAzOSwKICAgICAgRU5BTUVUT09MT05HOiAzNiwKICAgICAgRUxPT1A6IDQwLAogICAgICBFT1BOT1RTVVBQOiA5NSwKICAgICAgRVBGTk9TVVBQT1JUOiA5NiwKICAgICAgRUNPTk5SRVNFVDogMTA0LAogICAgICBFTk9CVUZTOiAxMDUsCiAgICAgIEVBRk5PU1VQUE9SVDogOTcsCiAgICAgIEVQUk9UT1RZUEU6IDkxLAogICAgICBFTk9UU09DSzogODgsCiAgICAgIEVOT1BST1RPT1BUOiA5MiwKICAgICAgRVNIVVRET1dOOiAxMDgsCiAgICAgIEVDT05OUkVGVVNFRDogMTExLAogICAgICBFQUREUklOVVNFOiA5OCwKICAgICAgRUNPTk5BQk9SVEVEOiAxMDMsCiAgICAgIEVORVRVTlJFQUNIOiAxMDEsCiAgICAgIEVORVRET1dOOiAxMDAsCiAgICAgIEVUSU1FRE9VVDogMTEwLAogICAgICBFSE9TVERPV046IDExMiwKICAgICAgRUhPU1RVTlJFQUNIOiAxMTMsCiAgICAgIEVJTlBST0dSRVNTOiAxMTUsCiAgICAgIEVBTFJFQURZOiAxMTQsCiAgICAgIEVERVNUQUREUlJFUTogODksCiAgICAgIEVNU0dTSVpFOiA5MCwKICAgICAgRVBST1RPTk9TVVBQT1JUOiA5MywKICAgICAgRVNPQ0tUTk9TVVBQT1JUOiA5NCwKICAgICAgRUFERFJOT1RBVkFJTDogOTksCiAgICAgIEVORVRSRVNFVDogMTAyLAogICAgICBFSVNDT05OOiAxMDYsCiAgICAgIEVOT1RDT05OOiAxMDcsCiAgICAgIEVUT09NQU5ZUkVGUzogMTA5LAogICAgICBFVVNFUlM6IDg3LAogICAgICBFRFFVT1Q6IDEyMiwKICAgICAgRVNUQUxFOiAxMTYsCiAgICAgIEVOT1RTVVA6IDk1LAogICAgICBFTk9NRURJVU06IDEyMywKICAgICAgRUlMU0VROiA4NCwKICAgICAgRU9WRVJGTE9XOiA3NSwKICAgICAgRUNBTkNFTEVEOiAxMjUsCiAgICAgIEVOT1RSRUNPVkVSQUJMRTogMTMxLAogICAgICBFT1dORVJERUFEOiAxMzAsCiAgICAgIEVTVFJQSVBFOiA4NiwKICAgIH07CiAgICBmdW5jdGlvbiBfX19zZXRFcnJObyh2YWx1ZSkgewogICAgICBpZiAoTW9kdWxlWydfX19lcnJub19sb2NhdGlvbiddKSBIRUFQMzJbTW9kdWxlWydfX19lcnJub19sb2NhdGlvbiddKCkgPj4gMl0gPSB2YWx1ZTsKICAgICAgcmV0dXJuIHZhbHVlCiAgICB9CiAgICBmdW5jdGlvbiBfX19tYXBfZmlsZShwYXRobmFtZSwgc2l6ZSkgewogICAgICBfX19zZXRFcnJObyhFUlJOT19DT0RFUy5FUEVSTSk7CiAgICAgIHJldHVybiAtMQogICAgfQogICAgdmFyIEVSUk5PX01FU1NBR0VTID0gewogICAgICAwOiAnU3VjY2VzcycsCiAgICAgIDE6ICdOb3Qgc3VwZXItdXNlcicsCiAgICAgIDI6ICdObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5JywKICAgICAgMzogJ05vIHN1Y2ggcHJvY2VzcycsCiAgICAgIDQ6ICdJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbCcsCiAgICAgIDU6ICdJL08gZXJyb3InLAogICAgICA2OiAnTm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcycsCiAgICAgIDc6ICdBcmcgbGlzdCB0b28gbG9uZycsCiAgICAgIDg6ICdFeGVjIGZvcm1hdCBlcnJvcicsCiAgICAgIDk6ICdCYWQgZmlsZSBudW1iZXInLAogICAgICAxMDogJ05vIGNoaWxkcmVuJywKICAgICAgMTE6ICdObyBtb3JlIHByb2Nlc3NlcycsCiAgICAgIDEyOiAnTm90IGVub3VnaCBjb3JlJywKICAgICAgMTM6ICdQZXJtaXNzaW9uIGRlbmllZCcsCiAgICAgIDE0OiAnQmFkIGFkZHJlc3MnLAogICAgICAxNTogJ0Jsb2NrIGRldmljZSByZXF1aXJlZCcsCiAgICAgIDE2OiAnTW91bnQgZGV2aWNlIGJ1c3knLAogICAgICAxNzogJ0ZpbGUgZXhpc3RzJywKICAgICAgMTg6ICdDcm9zcy1kZXZpY2UgbGluaycsCiAgICAgIDE5OiAnTm8gc3VjaCBkZXZpY2UnLAogICAgICAyMDogJ05vdCBhIGRpcmVjdG9yeScsCiAgICAgIDIxOiAnSXMgYSBkaXJlY3RvcnknLAogICAgICAyMjogJ0ludmFsaWQgYXJndW1lbnQnLAogICAgICAyMzogJ1RvbyBtYW55IG9wZW4gZmlsZXMgaW4gc3lzdGVtJywKICAgICAgMjQ6ICdUb28gbWFueSBvcGVuIGZpbGVzJywKICAgICAgMjU6ICdOb3QgYSB0eXBld3JpdGVyJywKICAgICAgMjY6ICdUZXh0IGZpbGUgYnVzeScsCiAgICAgIDI3OiAnRmlsZSB0b28gbGFyZ2UnLAogICAgICAyODogJ05vIHNwYWNlIGxlZnQgb24gZGV2aWNlJywKICAgICAgMjk6ICdJbGxlZ2FsIHNlZWsnLAogICAgICAzMDogJ1JlYWQgb25seSBmaWxlIHN5c3RlbScsCiAgICAgIDMxOiAnVG9vIG1hbnkgbGlua3MnLAogICAgICAzMjogJ0Jyb2tlbiBwaXBlJywKICAgICAgMzM6ICdNYXRoIGFyZyBvdXQgb2YgZG9tYWluIG9mIGZ1bmMnLAogICAgICAzNDogJ01hdGggcmVzdWx0IG5vdCByZXByZXNlbnRhYmxlJywKICAgICAgMzU6ICdGaWxlIGxvY2tpbmcgZGVhZGxvY2sgZXJyb3InLAogICAgICAzNjogJ0ZpbGUgb3IgcGF0aCBuYW1lIHRvbyBsb25nJywKICAgICAgMzc6ICdObyByZWNvcmQgbG9ja3MgYXZhaWxhYmxlJywKICAgICAgMzg6ICdGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQnLAogICAgICAzOTogJ0RpcmVjdG9yeSBub3QgZW1wdHknLAogICAgICA0MDogJ1RvbyBtYW55IHN5bWJvbGljIGxpbmtzJywKICAgICAgNDI6ICdObyBtZXNzYWdlIG9mIGRlc2lyZWQgdHlwZScsCiAgICAgIDQzOiAnSWRlbnRpZmllciByZW1vdmVkJywKICAgICAgNDQ6ICdDaGFubmVsIG51bWJlciBvdXQgb2YgcmFuZ2UnLAogICAgICA0NTogJ0xldmVsIDIgbm90IHN5bmNocm9uaXplZCcsCiAgICAgIDQ2OiAnTGV2ZWwgMyBoYWx0ZWQnLAogICAgICA0NzogJ0xldmVsIDMgcmVzZXQnLAogICAgICA0ODogJ0xpbmsgbnVtYmVyIG91dCBvZiByYW5nZScsCiAgICAgIDQ5OiAnUHJvdG9jb2wgZHJpdmVyIG5vdCBhdHRhY2hlZCcsCiAgICAgIDUwOiAnTm8gQ1NJIHN0cnVjdHVyZSBhdmFpbGFibGUnLAogICAgICA1MTogJ0xldmVsIDIgaGFsdGVkJywKICAgICAgNTI6ICdJbnZhbGlkIGV4Y2hhbmdlJywKICAgICAgNTM6ICdJbnZhbGlkIHJlcXVlc3QgZGVzY3JpcHRvcicsCiAgICAgIDU0OiAnRXhjaGFuZ2UgZnVsbCcsCiAgICAgIDU1OiAnTm8gYW5vZGUnLAogICAgICA1NjogJ0ludmFsaWQgcmVxdWVzdCBjb2RlJywKICAgICAgNTc6ICdJbnZhbGlkIHNsb3QnLAogICAgICA1OTogJ0JhZCBmb250IGZpbGUgZm10JywKICAgICAgNjA6ICdEZXZpY2Ugbm90IGEgc3RyZWFtJywKICAgICAgNjE6ICdObyBkYXRhIChmb3Igbm8gZGVsYXkgaW8pJywKICAgICAgNjI6ICdUaW1lciBleHBpcmVkJywKICAgICAgNjM6ICdPdXQgb2Ygc3RyZWFtcyByZXNvdXJjZXMnLAogICAgICA2NDogJ01hY2hpbmUgaXMgbm90IG9uIHRoZSBuZXR3b3JrJywKICAgICAgNjU6ICdQYWNrYWdlIG5vdCBpbnN0YWxsZWQnLAogICAgICA2NjogJ1RoZSBvYmplY3QgaXMgcmVtb3RlJywKICAgICAgNjc6ICdUaGUgbGluayBoYXMgYmVlbiBzZXZlcmVkJywKICAgICAgNjg6ICdBZHZlcnRpc2UgZXJyb3InLAogICAgICA2OTogJ1NybW91bnQgZXJyb3InLAogICAgICA3MDogJ0NvbW11bmljYXRpb24gZXJyb3Igb24gc2VuZCcsCiAgICAgIDcxOiAnUHJvdG9jb2wgZXJyb3InLAogICAgICA3MjogJ011bHRpaG9wIGF0dGVtcHRlZCcsCiAgICAgIDczOiAnQ3Jvc3MgbW91bnQgcG9pbnQgKG5vdCByZWFsbHkgZXJyb3IpJywKICAgICAgNzQ6ICdUcnlpbmcgdG8gcmVhZCB1bnJlYWRhYmxlIG1lc3NhZ2UnLAogICAgICA3NTogJ1ZhbHVlIHRvbyBsYXJnZSBmb3IgZGVmaW5lZCBkYXRhIHR5cGUnLAogICAgICA3NjogJ0dpdmVuIGxvZy4gbmFtZSBub3QgdW5pcXVlJywKICAgICAgNzc6ICdmLmQuIGludmFsaWQgZm9yIHRoaXMgb3BlcmF0aW9uJywKICAgICAgNzg6ICdSZW1vdGUgYWRkcmVzcyBjaGFuZ2VkJywKICAgICAgNzk6ICdDYW4gICBhY2Nlc3MgYSBuZWVkZWQgc2hhcmVkIGxpYicsCiAgICAgIDgwOiAnQWNjZXNzaW5nIGEgY29ycnVwdGVkIHNoYXJlZCBsaWInLAogICAgICA4MTogJy5saWIgc2VjdGlvbiBpbiBhLm91dCBjb3JydXB0ZWQnLAogICAgICA4MjogJ0F0dGVtcHRpbmcgdG8gbGluayBpbiB0b28gbWFueSBsaWJzJywKICAgICAgODM6ICdBdHRlbXB0aW5nIHRvIGV4ZWMgYSBzaGFyZWQgbGlicmFyeScsCiAgICAgIDg0OiAnSWxsZWdhbCBieXRlIHNlcXVlbmNlJywKICAgICAgODY6ICdTdHJlYW1zIHBpcGUgZXJyb3InLAogICAgICA4NzogJ1RvbyBtYW55IHVzZXJzJywKICAgICAgODg6ICdTb2NrZXQgb3BlcmF0aW9uIG9uIG5vbi1zb2NrZXQnLAogICAgICA4OTogJ0Rlc3RpbmF0aW9uIGFkZHJlc3MgcmVxdWlyZWQnLAogICAgICA5MDogJ01lc3NhZ2UgdG9vIGxvbmcnLAogICAgICA5MTogJ1Byb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldCcsCiAgICAgIDkyOiAnUHJvdG9jb2wgbm90IGF2YWlsYWJsZScsCiAgICAgIDkzOiAnVW5rbm93biBwcm90b2NvbCcsCiAgICAgIDk0OiAnU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZCcsCiAgICAgIDk1OiAnTm90IHN1cHBvcnRlZCcsCiAgICAgIDk2OiAnUHJvdG9jb2wgZmFtaWx5IG5vdCBzdXBwb3J0ZWQnLAogICAgICA5NzogJ0FkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wgZmFtaWx5JywKICAgICAgOTg6ICdBZGRyZXNzIGFscmVhZHkgaW4gdXNlJywKICAgICAgOTk6ICdBZGRyZXNzIG5vdCBhdmFpbGFibGUnLAogICAgICAxMDA6ICdOZXR3b3JrIGludGVyZmFjZSBpcyBub3QgY29uZmlndXJlZCcsCiAgICAgIDEwMTogJ05ldHdvcmsgaXMgdW5yZWFjaGFibGUnLAogICAgICAxMDI6ICdDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsnLAogICAgICAxMDM6ICdDb25uZWN0aW9uIGFib3J0ZWQnLAogICAgICAxMDQ6ICdDb25uZWN0aW9uIHJlc2V0IGJ5IHBlZXInLAogICAgICAxMDU6ICdObyBidWZmZXIgc3BhY2UgYXZhaWxhYmxlJywKICAgICAgMTA2OiAnU29ja2V0IGlzIGFscmVhZHkgY29ubmVjdGVkJywKICAgICAgMTA3OiAnU29ja2V0IGlzIG5vdCBjb25uZWN0ZWQnLAogICAgICAxMDg6ICJDYW4ndCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93biIsCiAgICAgIDEwOTogJ1RvbyBtYW55IHJlZmVyZW5jZXMnLAogICAgICAxMTA6ICdDb25uZWN0aW9uIHRpbWVkIG91dCcsCiAgICAgIDExMTogJ0Nvbm5lY3Rpb24gcmVmdXNlZCcsCiAgICAgIDExMjogJ0hvc3QgaXMgZG93bicsCiAgICAgIDExMzogJ0hvc3QgaXMgdW5yZWFjaGFibGUnLAogICAgICAxMTQ6ICdTb2NrZXQgYWxyZWFkeSBjb25uZWN0ZWQnLAogICAgICAxMTU6ICdDb25uZWN0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MnLAogICAgICAxMTY6ICdTdGFsZSBmaWxlIGhhbmRsZScsCiAgICAgIDEyMjogJ1F1b3RhIGV4Y2VlZGVkJywKICAgICAgMTIzOiAnTm8gbWVkaXVtIChpbiB0YXBlIGRyaXZlKScsCiAgICAgIDEyNTogJ09wZXJhdGlvbiBjYW5jZWxlZCcsCiAgICAgIDEzMDogJ1ByZXZpb3VzIG93bmVyIGRpZWQnLAogICAgICAxMzE6ICdTdGF0ZSBub3QgcmVjb3ZlcmFibGUnLAogICAgfTsKICAgIHZhciBQQVRIID0gewogICAgICBzcGxpdFBhdGg6IGZ1bmN0aW9uIChmaWxlbmFtZSkgewogICAgICAgIHZhciBzcGxpdFBhdGhSZSA9IC9eKFwvP3wpKFtcc1xTXSo/KSgoPzpcLnsxLDJ9fFteXC9dKz98KShcLlteLlwvXSp8KSkoPzpbXC9dKikkLzsKICAgICAgICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSkKICAgICAgfSwKICAgICAgbm9ybWFsaXplQXJyYXk6IGZ1bmN0aW9uIChwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHsKICAgICAgICB2YXIgdXAgPSAwOwogICAgICAgIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgewogICAgICAgICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTsKICAgICAgICAgIGlmIChsYXN0ID09PSAnLicpIHsKICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpOwogICAgICAgICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7CiAgICAgICAgICAgIHBhcnRzLnNwbGljZShpLCAxKTsKICAgICAgICAgICAgdXArKzsKICAgICAgICAgIH0gZWxzZSBpZiAodXApIHsKICAgICAgICAgICAgcGFydHMuc3BsaWNlKGksIDEpOwogICAgICAgICAgICB1cC0tOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAoYWxsb3dBYm92ZVJvb3QpIHsKICAgICAgICAgIGZvciAoOyB1cDsgdXAtLSkgewogICAgICAgICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gcGFydHMKICAgICAgfSwKICAgICAgbm9ybWFsaXplOiBmdW5jdGlvbiAocGF0aCkgewogICAgICAgIHZhciBpc0Fic29sdXRlID0gcGF0aC5jaGFyQXQoMCkgPT09ICcvJywKICAgICAgICAgIHRyYWlsaW5nU2xhc2ggPSBwYXRoLnN1YnN0cigtMSkgPT09ICcvJzsKICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemVBcnJheSgKICAgICAgICAgIHBhdGguc3BsaXQoJy8nKS5maWx0ZXIoZnVuY3Rpb24gKHApIHsKICAgICAgICAgICAgcmV0dXJuICEhcAogICAgICAgICAgfSksCiAgICAgICAgICAhaXNBYnNvbHV0ZQogICAgICAgICkuam9pbignLycpOwogICAgICAgIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkgewogICAgICAgICAgcGF0aCA9ICcuJzsKICAgICAgICB9CiAgICAgICAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkgewogICAgICAgICAgcGF0aCArPSAnLyc7CiAgICAgICAgfQogICAgICAgIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGgKICAgICAgfSwKICAgICAgZGlybmFtZTogZnVuY3Rpb24gKHBhdGgpIHsKICAgICAgICB2YXIgcmVzdWx0ID0gUEFUSC5zcGxpdFBhdGgocGF0aCksCiAgICAgICAgICByb290ID0gcmVzdWx0WzBdLAogICAgICAgICAgZGlyID0gcmVzdWx0WzFdOwogICAgICAgIGlmICghcm9vdCAmJiAhZGlyKSB7CiAgICAgICAgICByZXR1cm4gJy4nCiAgICAgICAgfQogICAgICAgIGlmIChkaXIpIHsKICAgICAgICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcm9vdCArIGRpcgogICAgICB9LAogICAgICBiYXNlbmFtZTogZnVuY3Rpb24gKHBhdGgpIHsKICAgICAgICBpZiAocGF0aCA9PT0gJy8nKSByZXR1cm4gJy8nCiAgICAgICAgdmFyIGxhc3RTbGFzaCA9IHBhdGgubGFzdEluZGV4T2YoJy8nKTsKICAgICAgICBpZiAobGFzdFNsYXNoID09PSAtMSkgcmV0dXJuIHBhdGgKICAgICAgICByZXR1cm4gcGF0aC5zdWJzdHIobGFzdFNsYXNoICsgMSkKICAgICAgfSwKICAgICAgZXh0bmFtZTogZnVuY3Rpb24gKHBhdGgpIHsKICAgICAgICByZXR1cm4gUEFUSC5zcGxpdFBhdGgocGF0aClbM10KICAgICAgfSwKICAgICAgam9pbjogZnVuY3Rpb24gKCkgewogICAgICAgIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7CiAgICAgICAgcmV0dXJuIFBBVEgubm9ybWFsaXplKHBhdGhzLmpvaW4oJy8nKSkKICAgICAgfSwKICAgICAgam9pbjI6IGZ1bmN0aW9uIChsLCByKSB7CiAgICAgICAgcmV0dXJuIFBBVEgubm9ybWFsaXplKGwgKyAnLycgKyByKQogICAgICB9LAogICAgICByZXNvbHZlOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLAogICAgICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlOwogICAgICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7CiAgICAgICAgICB2YXIgcGF0aCA9IGkgPj0gMCA/IGFyZ3VtZW50c1tpXSA6IEZTLmN3ZCgpOwogICAgICAgICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgewogICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpCiAgICAgICAgICB9IGVsc2UgaWYgKCFwYXRoKSB7CiAgICAgICAgICAgIHJldHVybiAnJwogICAgICAgICAgfQogICAgICAgICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDsKICAgICAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nOwogICAgICAgIH0KICAgICAgICByZXNvbHZlZFBhdGggPSBQQVRILm5vcm1hbGl6ZUFycmF5KAogICAgICAgICAgcmVzb2x2ZWRQYXRoLnNwbGl0KCcvJykuZmlsdGVyKGZ1bmN0aW9uIChwKSB7CiAgICAgICAgICAgIHJldHVybiAhIXAKICAgICAgICAgIH0pLAogICAgICAgICAgIXJlc29sdmVkQWJzb2x1dGUKICAgICAgICApLmpvaW4oJy8nKTsKICAgICAgICByZXR1cm4gKHJlc29sdmVkQWJzb2x1dGUgPyAnLycgOiAnJykgKyByZXNvbHZlZFBhdGggfHwgJy4nCiAgICAgIH0sCiAgICAgIHJlbGF0aXZlOiBmdW5jdGlvbiAoZnJvbSwgdG8pIHsKICAgICAgICBmcm9tID0gUEFUSC5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTsKICAgICAgICB0byA9IFBBVEgucmVzb2x2ZSh0bykuc3Vic3RyKDEpOwogICAgICAgIGZ1bmN0aW9uIHRyaW0oYXJyKSB7CiAgICAgICAgICB2YXIgc3RhcnQgPSAwOwogICAgICAgICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykgewogICAgICAgICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrCiAgICAgICAgICB9CiAgICAgICAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7CiAgICAgICAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7CiAgICAgICAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrCiAgICAgICAgICB9CiAgICAgICAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXQogICAgICAgICAgcmV0dXJuIGFyci5zbGljZShzdGFydCwgZW5kIC0gc3RhcnQgKyAxKQogICAgICAgIH0KICAgICAgICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpOwogICAgICAgIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnLycpKTsKICAgICAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCwgdG9QYXJ0cy5sZW5ndGgpOwogICAgICAgIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICAgICAgaWYgKGZyb21QYXJ0c1tpXSAhPT0gdG9QYXJ0c1tpXSkgewogICAgICAgICAgICBzYW1lUGFydHNMZW5ndGggPSBpOwogICAgICAgICAgICBicmVhawogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB2YXIgb3V0cHV0UGFydHMgPSBbXTsKICAgICAgICBmb3IgKHZhciBpID0gc2FtZVBhcnRzTGVuZ3RoOyBpIDwgZnJvbVBhcnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpOwogICAgICAgIH0KICAgICAgICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpOwogICAgICAgIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJykKICAgICAgfSwKICAgIH07CiAgICB2YXIgVFRZID0gewogICAgICB0dHlzOiBbXSwKICAgICAgaW5pdDogZnVuY3Rpb24gKCkge30sCiAgICAgIHNodXRkb3duOiBmdW5jdGlvbiAoKSB7fSwKICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uIChkZXYsIG9wcykgewogICAgICAgIFRUWS50dHlzW2Rldl0gPSB7IGlucHV0OiBbXSwgb3V0cHV0OiBbXSwgb3BzOiBvcHMgfTsKICAgICAgICBGUy5yZWdpc3RlckRldmljZShkZXYsIFRUWS5zdHJlYW1fb3BzKTsKICAgICAgfSwKICAgICAgc3RyZWFtX29wczogewogICAgICAgIG9wZW46IGZ1bmN0aW9uIChzdHJlYW0pIHsKICAgICAgICAgIHZhciB0dHkgPSBUVFkudHR5c1tzdHJlYW0ubm9kZS5yZGV2XTsKICAgICAgICAgIGlmICghdHR5KSB7CiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0RFVikKICAgICAgICAgIH0KICAgICAgICAgIHN0cmVhbS50dHkgPSB0dHk7CiAgICAgICAgICBzdHJlYW0uc2Vla2FibGUgPSBmYWxzZTsKICAgICAgICB9LAogICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoc3RyZWFtKSB7CiAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5mbHVzaChzdHJlYW0udHR5KTsKICAgICAgICB9LAogICAgICAgIGZsdXNoOiBmdW5jdGlvbiAoc3RyZWFtKSB7CiAgICAgICAgICBzdHJlYW0udHR5Lm9wcy5mbHVzaChzdHJlYW0udHR5KTsKICAgICAgICB9LAogICAgICAgIHJlYWQ6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykgewogICAgICAgICAgaWYgKCFzdHJlYW0udHR5IHx8ICFzdHJlYW0udHR5Lm9wcy5nZXRfY2hhcikgewogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTlhJTykKICAgICAgICAgIH0KICAgICAgICAgIHZhciBieXRlc1JlYWQgPSAwOwogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICAgICAgICB2YXIgcmVzdWx0OwogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgIHJlc3VsdCA9IHN0cmVhbS50dHkub3BzLmdldF9jaGFyKHN0cmVhbS50dHkpOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlPKQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCAmJiBieXRlc1JlYWQgPT09IDApIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQUdBSU4pCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkgYnJlYWsKICAgICAgICAgICAgYnl0ZXNSZWFkKys7CiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IHJlc3VsdDsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChieXRlc1JlYWQpIHsKICAgICAgICAgICAgc3RyZWFtLm5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBieXRlc1JlYWQKICAgICAgICB9LAogICAgICAgIHdyaXRlOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpIHsKICAgICAgICAgIGlmICghc3RyZWFtLnR0eSB8fCAhc3RyZWFtLnR0eS5vcHMucHV0X2NoYXIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5YSU8pCiAgICAgICAgICB9CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgc3RyZWFtLnR0eS5vcHMucHV0X2NoYXIoc3RyZWFtLnR0eSwgYnVmZmVyW29mZnNldCArIGldKTsKICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTykKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgaWYgKGxlbmd0aCkgewogICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGkKICAgICAgICB9LAogICAgICB9LAogICAgICBkZWZhdWx0X3R0eV9vcHM6IHsKICAgICAgICBnZXRfY2hhcjogZnVuY3Rpb24gKHR0eSkgewogICAgICAgICAgaWYgKCF0dHkuaW5wdXQubGVuZ3RoKSB7CiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsOwogICAgICAgICAgICBpZiAoRU5WSVJPTk1FTlRfSVNfTk9ERSkgewogICAgICAgICAgICAgIHZhciBCVUZTSVpFID0gMjU2OwogICAgICAgICAgICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKEJVRlNJWkUpOwogICAgICAgICAgICAgIHZhciBieXRlc1JlYWQgPSAwOwogICAgICAgICAgICAgIHZhciBpc1Bvc2l4UGxhdGZvcm0gPSBwcm9jZXNzLnBsYXRmb3JtICE9ICd3aW4zMic7CiAgICAgICAgICAgICAgdmFyIGZkID0gcHJvY2Vzcy5zdGRpbi5mZDsKICAgICAgICAgICAgICBpZiAoaXNQb3NpeFBsYXRmb3JtKSB7CiAgICAgICAgICAgICAgICB2YXIgdXNpbmdEZXZpY2UgPSBmYWxzZTsKICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgIGZkID0gZnMub3BlblN5bmMoJy9kZXYvc3RkaW4nLCAncicpOwogICAgICAgICAgICAgICAgICB1c2luZ0RldmljZSA9IHRydWU7CiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgYnl0ZXNSZWFkID0gZnMucmVhZFN5bmMoZmQsIGJ1ZiwgMCwgQlVGU0laRSwgbnVsbCk7CiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgaWYgKGUudG9TdHJpbmcoKS5pbmRleE9mKCdFT0YnKSAhPSAtMSkgYnl0ZXNSZWFkID0gMDsKICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBpZiAodXNpbmdEZXZpY2UpIHsKICAgICAgICAgICAgICAgIGZzLmNsb3NlU3luYyhmZCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChieXRlc1JlYWQgPiAwKSB7CiAgICAgICAgICAgICAgICByZXN1bHQgPSBidWYuc2xpY2UoMCwgYnl0ZXNSZWFkKS50b1N0cmluZygndXRmLTgnKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LnByb21wdCA9PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICAgICAgcmVzdWx0ID0gd2luZG93LnByb21wdCgnSW5wdXQ6ICcpOwogICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHsKICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnXG4nOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmVhZGxpbmUgPT0gJ2Z1bmN0aW9uJykgewogICAgICAgICAgICAgIHJlc3VsdCA9IHJlYWRsaW5lKCk7CiAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkgewogICAgICAgICAgICAgICAgcmVzdWx0ICs9ICdcbic7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7CiAgICAgICAgICAgICAgcmV0dXJuIG51bGwKICAgICAgICAgICAgfQogICAgICAgICAgICB0dHkuaW5wdXQgPSBpbnRBcnJheUZyb21TdHJpbmcocmVzdWx0LCB0cnVlKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB0dHkuaW5wdXQuc2hpZnQoKQogICAgICAgIH0sCiAgICAgICAgcHV0X2NoYXI6IGZ1bmN0aW9uICh0dHksIHZhbCkgewogICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IDEwKSB7CiAgICAgICAgICAgIE1vZHVsZVsncHJpbnQnXShVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LCAwKSk7CiAgICAgICAgICAgIHR0eS5vdXRwdXQgPSBbXTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGlmICh2YWwgIT0gMCkgdHR5Lm91dHB1dC5wdXNoKHZhbCk7CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBmbHVzaDogZnVuY3Rpb24gKHR0eSkgewogICAgICAgICAgaWYgKHR0eS5vdXRwdXQgJiYgdHR5Lm91dHB1dC5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgIE1vZHVsZVsncHJpbnQnXShVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LCAwKSk7CiAgICAgICAgICAgIHR0eS5vdXRwdXQgPSBbXTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICB9LAogICAgICBkZWZhdWx0X3R0eTFfb3BzOiB7CiAgICAgICAgcHV0X2NoYXI6IGZ1bmN0aW9uICh0dHksIHZhbCkgewogICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IDEwKSB7CiAgICAgICAgICAgIE1vZHVsZVsncHJpbnRFcnInXShVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LCAwKSk7CiAgICAgICAgICAgIHR0eS5vdXRwdXQgPSBbXTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGlmICh2YWwgIT0gMCkgdHR5Lm91dHB1dC5wdXNoKHZhbCk7CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBmbHVzaDogZnVuY3Rpb24gKHR0eSkgewogICAgICAgICAgaWYgKHR0eS5vdXRwdXQgJiYgdHR5Lm91dHB1dC5sZW5ndGggPiAwKSB7CiAgICAgICAgICAgIE1vZHVsZVsncHJpbnRFcnInXShVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LCAwKSk7CiAgICAgICAgICAgIHR0eS5vdXRwdXQgPSBbXTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICB9LAogICAgfTsKICAgIHZhciBNRU1GUyA9IHsKICAgICAgb3BzX3RhYmxlOiBudWxsLAogICAgICBtb3VudDogZnVuY3Rpb24gKG1vdW50KSB7CiAgICAgICAgcmV0dXJuIE1FTUZTLmNyZWF0ZU5vZGUobnVsbCwgJy8nLCAxNjM4NCB8IDUxMSwgMCkKICAgICAgfSwKICAgICAgY3JlYXRlTm9kZTogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KSB7CiAgICAgICAgaWYgKEZTLmlzQmxrZGV2KG1vZGUpIHx8IEZTLmlzRklGTyhtb2RlKSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pCiAgICAgICAgfQogICAgICAgIGlmICghTUVNRlMub3BzX3RhYmxlKSB7CiAgICAgICAgICBNRU1GUy5vcHNfdGFibGUgPSB7CiAgICAgICAgICAgIGRpcjogewogICAgICAgICAgICAgIG5vZGU6IHsKICAgICAgICAgICAgICAgIGdldGF0dHI6IE1FTUZTLm5vZGVfb3BzLmdldGF0dHIsCiAgICAgICAgICAgICAgICBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyLAogICAgICAgICAgICAgICAgbG9va3VwOiBNRU1GUy5ub2RlX29wcy5sb29rdXAsCiAgICAgICAgICAgICAgICBta25vZDogTUVNRlMubm9kZV9vcHMubWtub2QsCiAgICAgICAgICAgICAgICByZW5hbWU6IE1FTUZTLm5vZGVfb3BzLnJlbmFtZSwKICAgICAgICAgICAgICAgIHVubGluazogTUVNRlMubm9kZV9vcHMudW5saW5rLAogICAgICAgICAgICAgICAgcm1kaXI6IE1FTUZTLm5vZGVfb3BzLnJtZGlyLAogICAgICAgICAgICAgICAgcmVhZGRpcjogTUVNRlMubm9kZV9vcHMucmVhZGRpciwKICAgICAgICAgICAgICAgIHN5bWxpbms6IE1FTUZTLm5vZGVfb3BzLnN5bWxpbmssCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBzdHJlYW06IHsgbGxzZWVrOiBNRU1GUy5zdHJlYW1fb3BzLmxsc2VlayB9LAogICAgICAgICAgICB9LAogICAgICAgICAgICBmaWxlOiB7CiAgICAgICAgICAgICAgbm9kZTogeyBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLCBzZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5zZXRhdHRyIH0sCiAgICAgICAgICAgICAgc3RyZWFtOiB7CiAgICAgICAgICAgICAgICBsbHNlZWs6IE1FTUZTLnN0cmVhbV9vcHMubGxzZWVrLAogICAgICAgICAgICAgICAgcmVhZDogTUVNRlMuc3RyZWFtX29wcy5yZWFkLAogICAgICAgICAgICAgICAgd3JpdGU6IE1FTUZTLnN0cmVhbV9vcHMud3JpdGUsCiAgICAgICAgICAgICAgICBhbGxvY2F0ZTogTUVNRlMuc3RyZWFtX29wcy5hbGxvY2F0ZSwKICAgICAgICAgICAgICAgIG1tYXA6IE1FTUZTLnN0cmVhbV9vcHMubW1hcCwKICAgICAgICAgICAgICAgIG1zeW5jOiBNRU1GUy5zdHJlYW1fb3BzLm1zeW5jLAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGxpbms6IHsKICAgICAgICAgICAgICBub2RlOiB7CiAgICAgICAgICAgICAgICBnZXRhdHRyOiBNRU1GUy5ub2RlX29wcy5nZXRhdHRyLAogICAgICAgICAgICAgICAgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0ciwKICAgICAgICAgICAgICAgIHJlYWRsaW5rOiBNRU1GUy5ub2RlX29wcy5yZWFkbGluaywKICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHN0cmVhbToge30sCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGNocmRldjogewogICAgICAgICAgICAgIG5vZGU6IHsgZ2V0YXR0cjogTUVNRlMubm9kZV9vcHMuZ2V0YXR0ciwgc2V0YXR0cjogTUVNRlMubm9kZV9vcHMuc2V0YXR0ciB9LAogICAgICAgICAgICAgIHN0cmVhbTogRlMuY2hyZGV2X3N0cmVhbV9vcHMsCiAgICAgICAgICAgIH0sCiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpOwogICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7CiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmRpci5ub2RlOwogICAgICAgICAgbm9kZS5zdHJlYW1fb3BzID0gTUVNRlMub3BzX3RhYmxlLmRpci5zdHJlYW07CiAgICAgICAgICBub2RlLmNvbnRlbnRzID0ge307CiAgICAgICAgfSBlbHNlIGlmIChGUy5pc0ZpbGUobm9kZS5tb2RlKSkgewogICAgICAgICAgbm9kZS5ub2RlX29wcyA9IE1FTUZTLm9wc190YWJsZS5maWxlLm5vZGU7CiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuZmlsZS5zdHJlYW07CiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IDA7CiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDsKICAgICAgICB9IGVsc2UgaWYgKEZTLmlzTGluayhub2RlLm1vZGUpKSB7CiAgICAgICAgICBub2RlLm5vZGVfb3BzID0gTUVNRlMub3BzX3RhYmxlLmxpbmsubm9kZTsKICAgICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE1FTUZTLm9wc190YWJsZS5saW5rLnN0cmVhbTsKICAgICAgICB9IGVsc2UgaWYgKEZTLmlzQ2hyZGV2KG5vZGUubW9kZSkpIHsKICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuY2hyZGV2Lm5vZGU7CiAgICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBNRU1GUy5vcHNfdGFibGUuY2hyZGV2LnN0cmVhbTsKICAgICAgICB9CiAgICAgICAgbm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpOwogICAgICAgIGlmIChwYXJlbnQpIHsKICAgICAgICAgIHBhcmVudC5jb250ZW50c1tuYW1lXSA9IG5vZGU7CiAgICAgICAgfQogICAgICAgIHJldHVybiBub2RlCiAgICAgIH0sCiAgICAgIGdldEZpbGVEYXRhQXNSZWd1bGFyQXJyYXk6IGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgaWYgKG5vZGUuY29udGVudHMgJiYgbm9kZS5jb250ZW50cy5zdWJhcnJheSkgewogICAgICAgICAgdmFyIGFyciA9IFtdOwogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLnVzZWRCeXRlczsgKytpKSBhcnIucHVzaChub2RlLmNvbnRlbnRzW2ldKTsKICAgICAgICAgIHJldHVybiBhcnIKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG5vZGUuY29udGVudHMKICAgICAgfSwKICAgICAgZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXk6IGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgaWYgKCFub2RlLmNvbnRlbnRzKSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKQogICAgICAgIGlmIChub2RlLmNvbnRlbnRzLnN1YmFycmF5KSByZXR1cm4gbm9kZS5jb250ZW50cy5zdWJhcnJheSgwLCBub2RlLnVzZWRCeXRlcykKICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobm9kZS5jb250ZW50cykKICAgICAgfSwKICAgICAgZXhwYW5kRmlsZVN0b3JhZ2U6IGZ1bmN0aW9uIChub2RlLCBuZXdDYXBhY2l0eSkgewogICAgICAgIGlmIChub2RlLmNvbnRlbnRzICYmIG5vZGUuY29udGVudHMuc3ViYXJyYXkgJiYgbmV3Q2FwYWNpdHkgPiBub2RlLmNvbnRlbnRzLmxlbmd0aCkgewogICAgICAgICAgbm9kZS5jb250ZW50cyA9IE1FTUZTLmdldEZpbGVEYXRhQXNSZWd1bGFyQXJyYXkobm9kZSk7CiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IG5vZGUuY29udGVudHMubGVuZ3RoOwogICAgICAgIH0KICAgICAgICBpZiAoIW5vZGUuY29udGVudHMgfHwgbm9kZS5jb250ZW50cy5zdWJhcnJheSkgewogICAgICAgICAgdmFyIHByZXZDYXBhY2l0eSA9IG5vZGUuY29udGVudHMgPyBub2RlLmNvbnRlbnRzLmxlbmd0aCA6IDA7CiAgICAgICAgICBpZiAocHJldkNhcGFjaXR5ID49IG5ld0NhcGFjaXR5KSByZXR1cm4KICAgICAgICAgIHZhciBDQVBBQ0lUWV9ET1VCTElOR19NQVggPSAxMDI0ICogMTAyNDsKICAgICAgICAgIG5ld0NhcGFjaXR5ID0gTWF0aC5tYXgobmV3Q2FwYWNpdHksIChwcmV2Q2FwYWNpdHkgKiAocHJldkNhcGFjaXR5IDwgQ0FQQUNJVFlfRE9VQkxJTkdfTUFYID8gMiA6IDEuMTI1KSkgfCAwKTsKICAgICAgICAgIGlmIChwcmV2Q2FwYWNpdHkgIT0gMCkgbmV3Q2FwYWNpdHkgPSBNYXRoLm1heChuZXdDYXBhY2l0eSwgMjU2KTsKICAgICAgICAgIHZhciBvbGRDb250ZW50cyA9IG5vZGUuY29udGVudHM7CiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbmV3IFVpbnQ4QXJyYXkobmV3Q2FwYWNpdHkpOwogICAgICAgICAgaWYgKG5vZGUudXNlZEJ5dGVzID4gMCkgbm9kZS5jb250ZW50cy5zZXQob2xkQ29udGVudHMuc3ViYXJyYXkoMCwgbm9kZS51c2VkQnl0ZXMpLCAwKTsKICAgICAgICAgIHJldHVybgogICAgICAgIH0KICAgICAgICBpZiAoIW5vZGUuY29udGVudHMgJiYgbmV3Q2FwYWNpdHkgPiAwKSBub2RlLmNvbnRlbnRzID0gW107CiAgICAgICAgd2hpbGUgKG5vZGUuY29udGVudHMubGVuZ3RoIDwgbmV3Q2FwYWNpdHkpIG5vZGUuY29udGVudHMucHVzaCgwKTsKICAgICAgfSwKICAgICAgcmVzaXplRmlsZVN0b3JhZ2U6IGZ1bmN0aW9uIChub2RlLCBuZXdTaXplKSB7CiAgICAgICAgaWYgKG5vZGUudXNlZEJ5dGVzID09IG5ld1NpemUpIHJldHVybgogICAgICAgIGlmIChuZXdTaXplID09IDApIHsKICAgICAgICAgIG5vZGUuY29udGVudHMgPSBudWxsOwogICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSAwOwogICAgICAgICAgcmV0dXJuCiAgICAgICAgfQogICAgICAgIGlmICghbm9kZS5jb250ZW50cyB8fCBub2RlLmNvbnRlbnRzLnN1YmFycmF5KSB7CiAgICAgICAgICB2YXIgb2xkQ29udGVudHMgPSBub2RlLmNvbnRlbnRzOwogICAgICAgICAgbm9kZS5jb250ZW50cyA9IG5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcihuZXdTaXplKSk7CiAgICAgICAgICBpZiAob2xkQ29udGVudHMpIHsKICAgICAgICAgICAgbm9kZS5jb250ZW50cy5zZXQob2xkQ29udGVudHMuc3ViYXJyYXkoMCwgTWF0aC5taW4obmV3U2l6ZSwgbm9kZS51c2VkQnl0ZXMpKSk7CiAgICAgICAgICB9CiAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IG5ld1NpemU7CiAgICAgICAgICByZXR1cm4KICAgICAgICB9CiAgICAgICAgaWYgKCFub2RlLmNvbnRlbnRzKSBub2RlLmNvbnRlbnRzID0gW107CiAgICAgICAgaWYgKG5vZGUuY29udGVudHMubGVuZ3RoID4gbmV3U2l6ZSkgbm9kZS5jb250ZW50cy5sZW5ndGggPSBuZXdTaXplOwogICAgICAgIGVsc2Ugd2hpbGUgKG5vZGUuY29udGVudHMubGVuZ3RoIDwgbmV3U2l6ZSkgbm9kZS5jb250ZW50cy5wdXNoKDApOwogICAgICAgIG5vZGUudXNlZEJ5dGVzID0gbmV3U2l6ZTsKICAgICAgfSwKICAgICAgbm9kZV9vcHM6IHsKICAgICAgICBnZXRhdHRyOiBmdW5jdGlvbiAobm9kZSkgewogICAgICAgICAgdmFyIGF0dHIgPSB7fTsKICAgICAgICAgIGF0dHIuZGV2ID0gRlMuaXNDaHJkZXYobm9kZS5tb2RlKSA/IG5vZGUuaWQgOiAxOwogICAgICAgICAgYXR0ci5pbm8gPSBub2RlLmlkOwogICAgICAgICAgYXR0ci5tb2RlID0gbm9kZS5tb2RlOwogICAgICAgICAgYXR0ci5ubGluayA9IDE7CiAgICAgICAgICBhdHRyLnVpZCA9IDA7CiAgICAgICAgICBhdHRyLmdpZCA9IDA7CiAgICAgICAgICBhdHRyLnJkZXYgPSBub2RlLnJkZXY7CiAgICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkgewogICAgICAgICAgICBhdHRyLnNpemUgPSA0MDk2OwogICAgICAgICAgfSBlbHNlIGlmIChGUy5pc0ZpbGUobm9kZS5tb2RlKSkgewogICAgICAgICAgICBhdHRyLnNpemUgPSBub2RlLnVzZWRCeXRlczsKICAgICAgICAgIH0gZWxzZSBpZiAoRlMuaXNMaW5rKG5vZGUubW9kZSkpIHsKICAgICAgICAgICAgYXR0ci5zaXplID0gbm9kZS5saW5rLmxlbmd0aDsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGF0dHIuc2l6ZSA9IDA7CiAgICAgICAgICB9CiAgICAgICAgICBhdHRyLmF0aW1lID0gbmV3IERhdGUobm9kZS50aW1lc3RhbXApOwogICAgICAgICAgYXR0ci5tdGltZSA9IG5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTsKICAgICAgICAgIGF0dHIuY3RpbWUgPSBuZXcgRGF0ZShub2RlLnRpbWVzdGFtcCk7CiAgICAgICAgICBhdHRyLmJsa3NpemUgPSA0MDk2OwogICAgICAgICAgYXR0ci5ibG9ja3MgPSBNYXRoLmNlaWwoYXR0ci5zaXplIC8gYXR0ci5ibGtzaXplKTsKICAgICAgICAgIHJldHVybiBhdHRyCiAgICAgICAgfSwKICAgICAgICBzZXRhdHRyOiBmdW5jdGlvbiAobm9kZSwgYXR0cikgewogICAgICAgICAgaWYgKGF0dHIubW9kZSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgIG5vZGUubW9kZSA9IGF0dHIubW9kZTsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChhdHRyLnRpbWVzdGFtcCAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgIG5vZGUudGltZXN0YW1wID0gYXR0ci50aW1lc3RhbXA7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoYXR0ci5zaXplICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgTUVNRlMucmVzaXplRmlsZVN0b3JhZ2Uobm9kZSwgYXR0ci5zaXplKTsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGxvb2t1cDogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSkgewogICAgICAgICAgdGhyb3cgRlMuZ2VuZXJpY0Vycm9yc1tFUlJOT19DT0RFUy5FTk9FTlRdCiAgICAgICAgfSwKICAgICAgICBta25vZDogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2KSB7CiAgICAgICAgICByZXR1cm4gTUVNRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5hbWUsIG1vZGUsIGRldikKICAgICAgICB9LAogICAgICAgIHJlbmFtZTogZnVuY3Rpb24gKG9sZF9ub2RlLCBuZXdfZGlyLCBuZXdfbmFtZSkgewogICAgICAgICAgaWYgKEZTLmlzRGlyKG9sZF9ub2RlLm1vZGUpKSB7CiAgICAgICAgICAgIHZhciBuZXdfbm9kZTsKICAgICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgICBuZXdfbm9kZSA9IEZTLmxvb2t1cE5vZGUobmV3X2RpciwgbmV3X25hbWUpOwogICAgICAgICAgICB9IGNhdGNoIChlKSB7fQogICAgICAgICAgICBpZiAobmV3X25vZGUpIHsKICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIG5ld19ub2RlLmNvbnRlbnRzKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9URU1QVFkpCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBkZWxldGUgb2xkX25vZGUucGFyZW50LmNvbnRlbnRzW29sZF9ub2RlLm5hbWVdOwogICAgICAgICAgb2xkX25vZGUubmFtZSA9IG5ld19uYW1lOwogICAgICAgICAgbmV3X2Rpci5jb250ZW50c1tuZXdfbmFtZV0gPSBvbGRfbm9kZTsKICAgICAgICAgIG9sZF9ub2RlLnBhcmVudCA9IG5ld19kaXI7CiAgICAgICAgfSwKICAgICAgICB1bmxpbms6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHsKICAgICAgICAgIGRlbGV0ZSBwYXJlbnQuY29udGVudHNbbmFtZV07CiAgICAgICAgfSwKICAgICAgICBybWRpcjogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSkgewogICAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7CiAgICAgICAgICBmb3IgKHZhciBpIGluIG5vZGUuY29udGVudHMpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVEVNUFRZKQogICAgICAgICAgfQogICAgICAgICAgZGVsZXRlIHBhcmVudC5jb250ZW50c1tuYW1lXTsKICAgICAgICB9LAogICAgICAgIHJlYWRkaXI6IGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgICB2YXIgZW50cmllcyA9IFsnLicsICcuLiddOwogICAgICAgICAgZm9yICh2YXIga2V5IGluIG5vZGUuY29udGVudHMpIHsKICAgICAgICAgICAgaWYgKCFub2RlLmNvbnRlbnRzLmhhc093blByb3BlcnR5KGtleSkpIHsKICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICB9CiAgICAgICAgICAgIGVudHJpZXMucHVzaChrZXkpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGVudHJpZXMKICAgICAgICB9LAogICAgICAgIHN5bWxpbms6IGZ1bmN0aW9uIChwYXJlbnQsIG5ld25hbWUsIG9sZHBhdGgpIHsKICAgICAgICAgIHZhciBub2RlID0gTUVNRlMuY3JlYXRlTm9kZShwYXJlbnQsIG5ld25hbWUsIDUxMSB8IDQwOTYwLCAwKTsKICAgICAgICAgIG5vZGUubGluayA9IG9sZHBhdGg7CiAgICAgICAgICByZXR1cm4gbm9kZQogICAgICAgIH0sCiAgICAgICAgcmVhZGxpbms6IGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgICBpZiAoIUZTLmlzTGluayhub2RlLm1vZGUpKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCkKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBub2RlLmxpbmsKICAgICAgICB9LAogICAgICB9LAogICAgICBzdHJlYW1fb3BzOiB7CiAgICAgICAgcmVhZDogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHsKICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzOwogICAgICAgICAgaWYgKHBvc2l0aW9uID49IHN0cmVhbS5ub2RlLnVzZWRCeXRlcykgcmV0dXJuIDAKICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oc3RyZWFtLm5vZGUudXNlZEJ5dGVzIC0gcG9zaXRpb24sIGxlbmd0aCk7CiAgICAgICAgICBhc3NlcnQoc2l6ZSA+PSAwKTsKICAgICAgICAgIGlmIChzaXplID4gOCAmJiBjb250ZW50cy5zdWJhcnJheSkgewogICAgICAgICAgICBidWZmZXIuc2V0KGNvbnRlbnRzLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIHNpemUpLCBvZmZzZXQpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGNvbnRlbnRzW3Bvc2l0aW9uICsgaV07CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gc2l6ZQogICAgICAgIH0sCiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBjYW5Pd24pIHsKICAgICAgICAgIGlmICghbGVuZ3RoKSByZXR1cm4gMAogICAgICAgICAgdmFyIG5vZGUgPSBzdHJlYW0ubm9kZTsKICAgICAgICAgIG5vZGUudGltZXN0YW1wID0gRGF0ZS5ub3coKTsKICAgICAgICAgIGlmIChidWZmZXIuc3ViYXJyYXkgJiYgKCFub2RlLmNvbnRlbnRzIHx8IG5vZGUuY29udGVudHMuc3ViYXJyYXkpKSB7CiAgICAgICAgICAgIGlmIChjYW5Pd24pIHsKICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzID0gYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKTsKICAgICAgICAgICAgICBub2RlLnVzZWRCeXRlcyA9IGxlbmd0aDsKICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoCiAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS51c2VkQnl0ZXMgPT09IDAgJiYgcG9zaXRpb24gPT09IDApIHsKICAgICAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKSk7CiAgICAgICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBsZW5ndGg7CiAgICAgICAgICAgICAgcmV0dXJuIGxlbmd0aAogICAgICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uICsgbGVuZ3RoIDw9IG5vZGUudXNlZEJ5dGVzKSB7CiAgICAgICAgICAgICAgbm9kZS5jb250ZW50cy5zZXQoYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuZ3RoKSwgcG9zaXRpb24pOwogICAgICAgICAgICAgIHJldHVybiBsZW5ndGgKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgTUVNRlMuZXhwYW5kRmlsZVN0b3JhZ2Uobm9kZSwgcG9zaXRpb24gKyBsZW5ndGgpOwogICAgICAgICAgaWYgKG5vZGUuY29udGVudHMuc3ViYXJyYXkgJiYgYnVmZmVyLnN1YmFycmF5KQogICAgICAgICAgICBub2RlLmNvbnRlbnRzLnNldChidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW5ndGgpLCBwb3NpdGlvbik7CiAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICAgICAgICAgIG5vZGUuY29udGVudHNbcG9zaXRpb24gKyBpXSA9IGJ1ZmZlcltvZmZzZXQgKyBpXTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgICAgbm9kZS51c2VkQnl0ZXMgPSBNYXRoLm1heChub2RlLnVzZWRCeXRlcywgcG9zaXRpb24gKyBsZW5ndGgpOwogICAgICAgICAgcmV0dXJuIGxlbmd0aAogICAgICAgIH0sCiAgICAgICAgbGxzZWVrOiBmdW5jdGlvbiAoc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSkgewogICAgICAgICAgdmFyIHBvc2l0aW9uID0gb2Zmc2V0OwogICAgICAgICAgaWYgKHdoZW5jZSA9PT0gMSkgewogICAgICAgICAgICBwb3NpdGlvbiArPSBzdHJlYW0ucG9zaXRpb247CiAgICAgICAgICB9IGVsc2UgaWYgKHdoZW5jZSA9PT0gMikgewogICAgICAgICAgICBpZiAoRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKSB7CiAgICAgICAgICAgICAgcG9zaXRpb24gKz0gc3RyZWFtLm5vZGUudXNlZEJ5dGVzOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCkKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBwb3NpdGlvbgogICAgICAgIH0sCiAgICAgICAgYWxsb2NhdGU6IGZ1bmN0aW9uIChzdHJlYW0sIG9mZnNldCwgbGVuZ3RoKSB7CiAgICAgICAgICBNRU1GUy5leHBhbmRGaWxlU3RvcmFnZShzdHJlYW0ubm9kZSwgb2Zmc2V0ICsgbGVuZ3RoKTsKICAgICAgICAgIHN0cmVhbS5ub2RlLnVzZWRCeXRlcyA9IE1hdGgubWF4KHN0cmVhbS5ub2RlLnVzZWRCeXRlcywgb2Zmc2V0ICsgbGVuZ3RoKTsKICAgICAgICB9LAogICAgICAgIG1tYXA6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncykgewogICAgICAgICAgaWYgKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PREVWKQogICAgICAgICAgfQogICAgICAgICAgdmFyIHB0cjsKICAgICAgICAgIHZhciBhbGxvY2F0ZWQ7CiAgICAgICAgICB2YXIgY29udGVudHMgPSBzdHJlYW0ubm9kZS5jb250ZW50czsKICAgICAgICAgIGlmICghKGZsYWdzICYgMikgJiYgKGNvbnRlbnRzLmJ1ZmZlciA9PT0gYnVmZmVyIHx8IGNvbnRlbnRzLmJ1ZmZlciA9PT0gYnVmZmVyLmJ1ZmZlcikpIHsKICAgICAgICAgICAgYWxsb2NhdGVkID0gZmFsc2U7CiAgICAgICAgICAgIHB0ciA9IGNvbnRlbnRzLmJ5dGVPZmZzZXQ7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBpZiAocG9zaXRpb24gPiAwIHx8IHBvc2l0aW9uICsgbGVuZ3RoIDwgc3RyZWFtLm5vZGUudXNlZEJ5dGVzKSB7CiAgICAgICAgICAgICAgaWYgKGNvbnRlbnRzLnN1YmFycmF5KSB7CiAgICAgICAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLnN1YmFycmF5KHBvc2l0aW9uLCBwb3NpdGlvbiArIGxlbmd0aCk7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGVudHMsIHBvc2l0aW9uLCBwb3NpdGlvbiArIGxlbmd0aCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGFsbG9jYXRlZCA9IHRydWU7CiAgICAgICAgICAgIHB0ciA9IF9tYWxsb2MobGVuZ3RoKTsKICAgICAgICAgICAgaWYgKCFwdHIpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9NRU0pCiAgICAgICAgICAgIH0KICAgICAgICAgICAgYnVmZmVyLnNldChjb250ZW50cywgcHRyKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB7IHB0cjogcHRyLCBhbGxvY2F0ZWQ6IGFsbG9jYXRlZCB9CiAgICAgICAgfSwKICAgICAgICBtc3luYzogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKSB7CiAgICAgICAgICBpZiAoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9ERVYpCiAgICAgICAgICB9CiAgICAgICAgICBpZiAobW1hcEZsYWdzICYgMikgewogICAgICAgICAgICByZXR1cm4gMAogICAgICAgICAgfQogICAgICAgICAgTUVNRlMuc3RyZWFtX29wcy53cml0ZShzdHJlYW0sIGJ1ZmZlciwgMCwgbGVuZ3RoLCBvZmZzZXQsIGZhbHNlKTsKICAgICAgICAgIHJldHVybiAwCiAgICAgICAgfSwKICAgICAgfSwKICAgIH07CiAgICB2YXIgSURCRlMgPSB7CiAgICAgIGRiczoge30sCiAgICAgIGluZGV4ZWREQjogZnVuY3Rpb24gKCkgewogICAgICAgIGlmICh0eXBlb2YgaW5kZXhlZERCICE9PSAndW5kZWZpbmVkJykgcmV0dXJuIGluZGV4ZWREQgogICAgICAgIHZhciByZXQgPSBudWxsOwogICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykKICAgICAgICAgIHJldCA9IHdpbmRvdy5pbmRleGVkREIgfHwgd2luZG93Lm1vekluZGV4ZWREQiB8fCB3aW5kb3cud2Via2l0SW5kZXhlZERCIHx8IHdpbmRvdy5tc0luZGV4ZWREQjsKICAgICAgICBhc3NlcnQocmV0LCAnSURCRlMgdXNlZCwgYnV0IGluZGV4ZWREQiBub3Qgc3VwcG9ydGVkJyk7CiAgICAgICAgcmV0dXJuIHJldAogICAgICB9LAogICAgICBEQl9WRVJTSU9OOiAyMSwKICAgICAgREJfU1RPUkVfTkFNRTogJ0ZJTEVfREFUQScsCiAgICAgIG1vdW50OiBmdW5jdGlvbiAobW91bnQpIHsKICAgICAgICByZXR1cm4gTUVNRlMubW91bnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgICB9LAogICAgICBzeW5jZnM6IGZ1bmN0aW9uIChtb3VudCwgcG9wdWxhdGUsIGNhbGxiYWNrKSB7CiAgICAgICAgSURCRlMuZ2V0TG9jYWxTZXQobW91bnQsIGZ1bmN0aW9uIChlcnIsIGxvY2FsKSB7CiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKQogICAgICAgICAgSURCRlMuZ2V0UmVtb3RlU2V0KG1vdW50LCBmdW5jdGlvbiAoZXJyLCByZW1vdGUpIHsKICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycikKICAgICAgICAgICAgdmFyIHNyYyA9IHBvcHVsYXRlID8gcmVtb3RlIDogbG9jYWw7CiAgICAgICAgICAgIHZhciBkc3QgPSBwb3B1bGF0ZSA/IGxvY2FsIDogcmVtb3RlOwogICAgICAgICAgICBJREJGUy5yZWNvbmNpbGUoc3JjLCBkc3QsIGNhbGxiYWNrKTsKICAgICAgICAgIH0pOwogICAgICAgIH0pOwogICAgICB9LAogICAgICBnZXREQjogZnVuY3Rpb24gKG5hbWUsIGNhbGxiYWNrKSB7CiAgICAgICAgdmFyIGRiID0gSURCRlMuZGJzW25hbWVdOwogICAgICAgIGlmIChkYikgewogICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIGRiKQogICAgICAgIH0KICAgICAgICB2YXIgcmVxOwogICAgICAgIHRyeSB7CiAgICAgICAgICByZXEgPSBJREJGUy5pbmRleGVkREIoKS5vcGVuKG5hbWUsIElEQkZTLkRCX1ZFUlNJT04pOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKQogICAgICAgIH0KICAgICAgICBpZiAoIXJlcSkgewogICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCdVbmFibGUgdG8gY29ubmVjdCB0byBJbmRleGVkREInKQogICAgICAgIH0KICAgICAgICByZXEub251cGdyYWRlbmVlZGVkID0gZnVuY3Rpb24gKGUpIHsKICAgICAgICAgIHZhciBkYiA9IGUudGFyZ2V0LnJlc3VsdDsKICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGUudGFyZ2V0LnRyYW5zYWN0aW9uOwogICAgICAgICAgdmFyIGZpbGVTdG9yZTsKICAgICAgICAgIGlmIChkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKElEQkZTLkRCX1NUT1JFX05BTUUpKSB7CiAgICAgICAgICAgIGZpbGVTdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKElEQkZTLkRCX1NUT1JFX05BTUUpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgZmlsZVN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoSURCRlMuREJfU1RPUkVfTkFNRSk7CiAgICAgICAgICB9CiAgICAgICAgICBpZiAoIWZpbGVTdG9yZS5pbmRleE5hbWVzLmNvbnRhaW5zKCd0aW1lc3RhbXAnKSkgewogICAgICAgICAgICBmaWxlU3RvcmUuY3JlYXRlSW5kZXgoJ3RpbWVzdGFtcCcsICd0aW1lc3RhbXAnLCB7IHVuaXF1ZTogZmFsc2UgfSk7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgZGIgPSByZXEucmVzdWx0OwogICAgICAgICAgSURCRlMuZGJzW25hbWVdID0gZGI7CiAgICAgICAgICBjYWxsYmFjayhudWxsLCBkYik7CiAgICAgICAgfTsKICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICBjYWxsYmFjayh0aGlzLmVycm9yKTsKICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsKICAgICAgICB9OwogICAgICB9LAogICAgICBnZXRMb2NhbFNldDogZnVuY3Rpb24gKG1vdW50LCBjYWxsYmFjaykgewogICAgICAgIHZhciBlbnRyaWVzID0ge307CiAgICAgICAgZnVuY3Rpb24gaXNSZWFsRGlyKHApIHsKICAgICAgICAgIHJldHVybiBwICE9PSAnLicgJiYgcCAhPT0gJy4uJwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB0b0Fic29sdXRlKHJvb3QpIHsKICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocCkgewogICAgICAgICAgICByZXR1cm4gUEFUSC5qb2luMihyb290LCBwKQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB2YXIgY2hlY2sgPSBGUy5yZWFkZGlyKG1vdW50Lm1vdW50cG9pbnQpLmZpbHRlcihpc1JlYWxEaXIpLm1hcCh0b0Fic29sdXRlKG1vdW50Lm1vdW50cG9pbnQpKTsKICAgICAgICB3aGlsZSAoY2hlY2subGVuZ3RoKSB7CiAgICAgICAgICB2YXIgcGF0aCA9IGNoZWNrLnBvcCgpOwogICAgICAgICAgdmFyIHN0YXQ7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBzdGF0ID0gRlMuc3RhdChwYXRoKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpCiAgICAgICAgICB9CiAgICAgICAgICBpZiAoRlMuaXNEaXIoc3RhdC5tb2RlKSkgewogICAgICAgICAgICBjaGVjay5wdXNoLmFwcGx5KGNoZWNrLCBGUy5yZWFkZGlyKHBhdGgpLmZpbHRlcihpc1JlYWxEaXIpLm1hcCh0b0Fic29sdXRlKHBhdGgpKSk7CiAgICAgICAgICB9CiAgICAgICAgICBlbnRyaWVzW3BhdGhdID0geyB0aW1lc3RhbXA6IHN0YXQubXRpbWUgfTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHsgdHlwZTogJ2xvY2FsJywgZW50cmllczogZW50cmllcyB9KQogICAgICB9LAogICAgICBnZXRSZW1vdGVTZXQ6IGZ1bmN0aW9uIChtb3VudCwgY2FsbGJhY2spIHsKICAgICAgICB2YXIgZW50cmllcyA9IHt9OwogICAgICAgIElEQkZTLmdldERCKG1vdW50Lm1vdW50cG9pbnQsIGZ1bmN0aW9uIChlcnIsIGRiKSB7CiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKQogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0lEQkZTLkRCX1NUT1JFX05BTUVdLCAncmVhZG9ubHknKTsKICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICAgICAgY2FsbGJhY2sodGhpcy5lcnJvcik7CiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOwogICAgICAgICAgICB9OwogICAgICAgICAgICB2YXIgc3RvcmUgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShJREJGUy5EQl9TVE9SRV9OQU1FKTsKICAgICAgICAgICAgdmFyIGluZGV4ID0gc3RvcmUuaW5kZXgoJ3RpbWVzdGFtcCcpOwogICAgICAgICAgICBpbmRleC5vcGVuS2V5Q3Vyc29yKCkub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7CiAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7CiAgICAgICAgICAgICAgaWYgKCFjdXJzb3IpIHsKICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCB7IHR5cGU6ICdyZW1vdGUnLCBkYjogZGIsIGVudHJpZXM6IGVudHJpZXMgfSkKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgZW50cmllc1tjdXJzb3IucHJpbWFyeUtleV0gPSB7IHRpbWVzdGFtcDogY3Vyc29yLmtleSB9OwogICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpOwogICAgICAgICAgICB9OwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSkKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgfSwKICAgICAgbG9hZExvY2FsRW50cnk6IGZ1bmN0aW9uIChwYXRoLCBjYWxsYmFjaykgewogICAgICAgIHZhciBzdGF0LCBub2RlOwogICAgICAgIHRyeSB7CiAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoKTsKICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTsKICAgICAgICAgIHN0YXQgPSBGUy5zdGF0KHBhdGgpOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKQogICAgICAgIH0KICAgICAgICBpZiAoRlMuaXNEaXIoc3RhdC5tb2RlKSkgewogICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHsgdGltZXN0YW1wOiBzdGF0Lm10aW1lLCBtb2RlOiBzdGF0Lm1vZGUgfSkKICAgICAgICB9IGVsc2UgaWYgKEZTLmlzRmlsZShzdGF0Lm1vZGUpKSB7CiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gTUVNRlMuZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXkobm9kZSk7CiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgeyB0aW1lc3RhbXA6IHN0YXQubXRpbWUsIG1vZGU6IHN0YXQubW9kZSwgY29udGVudHM6IG5vZGUuY29udGVudHMgfSkKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignbm9kZSB0eXBlIG5vdCBzdXBwb3J0ZWQnKSkKICAgICAgICB9CiAgICAgIH0sCiAgICAgIHN0b3JlTG9jYWxFbnRyeTogZnVuY3Rpb24gKHBhdGgsIGVudHJ5LCBjYWxsYmFjaykgewogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoRlMuaXNEaXIoZW50cnkubW9kZSkpIHsKICAgICAgICAgICAgRlMubWtkaXIocGF0aCwgZW50cnkubW9kZSk7CiAgICAgICAgICB9IGVsc2UgaWYgKEZTLmlzRmlsZShlbnRyeS5tb2RlKSkgewogICAgICAgICAgICBGUy53cml0ZUZpbGUocGF0aCwgZW50cnkuY29udGVudHMsIHsgY2FuT3duOiB0cnVlIH0pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignbm9kZSB0eXBlIG5vdCBzdXBwb3J0ZWQnKSkKICAgICAgICAgIH0KICAgICAgICAgIEZTLmNobW9kKHBhdGgsIGVudHJ5Lm1vZGUpOwogICAgICAgICAgRlMudXRpbWUocGF0aCwgZW50cnkudGltZXN0YW1wLCBlbnRyeS50aW1lc3RhbXApOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKQogICAgICAgIH0KICAgICAgICBjYWxsYmFjayhudWxsKTsKICAgICAgfSwKICAgICAgcmVtb3ZlTG9jYWxFbnRyeTogZnVuY3Rpb24gKHBhdGgsIGNhbGxiYWNrKSB7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgpOwogICAgICAgICAgdmFyIHN0YXQgPSBGUy5zdGF0KHBhdGgpOwogICAgICAgICAgaWYgKEZTLmlzRGlyKHN0YXQubW9kZSkpIHsKICAgICAgICAgICAgRlMucm1kaXIocGF0aCk7CiAgICAgICAgICB9IGVsc2UgaWYgKEZTLmlzRmlsZShzdGF0Lm1vZGUpKSB7CiAgICAgICAgICAgIEZTLnVubGluayhwYXRoKTsKICAgICAgICAgIH0KICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSkKICAgICAgICB9CiAgICAgICAgY2FsbGJhY2sobnVsbCk7CiAgICAgIH0sCiAgICAgIGxvYWRSZW1vdGVFbnRyeTogZnVuY3Rpb24gKHN0b3JlLCBwYXRoLCBjYWxsYmFjaykgewogICAgICAgIHZhciByZXEgPSBzdG9yZS5nZXQocGF0aCk7CiAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChldmVudCkgewogICAgICAgICAgY2FsbGJhY2sobnVsbCwgZXZlbnQudGFyZ2V0LnJlc3VsdCk7CiAgICAgICAgfTsKICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICBjYWxsYmFjayh0aGlzLmVycm9yKTsKICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsKICAgICAgICB9OwogICAgICB9LAogICAgICBzdG9yZVJlbW90ZUVudHJ5OiBmdW5jdGlvbiAoc3RvcmUsIHBhdGgsIGVudHJ5LCBjYWxsYmFjaykgewogICAgICAgIHZhciByZXEgPSBzdG9yZS5wdXQoZW50cnksIHBhdGgpOwogICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICBjYWxsYmFjayhudWxsKTsKICAgICAgICB9OwogICAgICAgIHJlcS5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHsKICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZXJyb3IpOwogICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOwogICAgICAgIH07CiAgICAgIH0sCiAgICAgIHJlbW92ZVJlbW90ZUVudHJ5OiBmdW5jdGlvbiAoc3RvcmUsIHBhdGgsIGNhbGxiYWNrKSB7CiAgICAgICAgdmFyIHJlcSA9IHN0b3JlLmRlbGV0ZShwYXRoKTsKICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgY2FsbGJhY2sobnVsbCk7CiAgICAgICAgfTsKICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7CiAgICAgICAgICBjYWxsYmFjayh0aGlzLmVycm9yKTsKICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsKICAgICAgICB9OwogICAgICB9LAogICAgICByZWNvbmNpbGU6IGZ1bmN0aW9uIChzcmMsIGRzdCwgY2FsbGJhY2spIHsKICAgICAgICB2YXIgdG90YWwgPSAwOwogICAgICAgIHZhciBjcmVhdGUgPSBbXTsKICAgICAgICBPYmplY3Qua2V5cyhzcmMuZW50cmllcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7CiAgICAgICAgICB2YXIgZSA9IHNyYy5lbnRyaWVzW2tleV07CiAgICAgICAgICB2YXIgZTIgPSBkc3QuZW50cmllc1trZXldOwogICAgICAgICAgaWYgKCFlMiB8fCBlLnRpbWVzdGFtcCA+IGUyLnRpbWVzdGFtcCkgewogICAgICAgICAgICBjcmVhdGUucHVzaChrZXkpOwogICAgICAgICAgICB0b3RhbCsrOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIHZhciByZW1vdmUgPSBbXTsKICAgICAgICBPYmplY3Qua2V5cyhkc3QuZW50cmllcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7CiAgICAgICAgICBkc3QuZW50cmllc1trZXldOwogICAgICAgICAgdmFyIGUyID0gc3JjLmVudHJpZXNba2V5XTsKICAgICAgICAgIGlmICghZTIpIHsKICAgICAgICAgICAgcmVtb3ZlLnB1c2goa2V5KTsKICAgICAgICAgICAgdG90YWwrKzsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICBpZiAoIXRvdGFsKSB7CiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCkKICAgICAgICB9CiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7CiAgICAgICAgdmFyIGRiID0gc3JjLnR5cGUgPT09ICdyZW1vdGUnID8gc3JjLmRiIDogZHN0LmRiOwogICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKFtJREJGUy5EQl9TVE9SRV9OQU1FXSwgJ3JlYWR3cml0ZScpOwogICAgICAgIHZhciBzdG9yZSA9IHRyYW5zYWN0aW9uLm9iamVjdFN0b3JlKElEQkZTLkRCX1NUT1JFX05BTUUpOwogICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyKSB7CiAgICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgIGlmICghZG9uZS5lcnJvcmVkKSB7CiAgICAgICAgICAgICAgZG9uZS5lcnJvcmVkID0gdHJ1ZTsKICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybgogICAgICAgICAgfQogICAgICAgICAgaWYgKCsrY29tcGxldGVkID49IHRvdGFsKSB7CiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsKQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0cmFuc2FjdGlvbi5vbmVycm9yID0gZnVuY3Rpb24gKGUpIHsKICAgICAgICAgIGRvbmUodGhpcy5lcnJvcik7CiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7CiAgICAgICAgfTsKICAgICAgICBjcmVhdGUuc29ydCgpLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHsKICAgICAgICAgIGlmIChkc3QudHlwZSA9PT0gJ2xvY2FsJykgewogICAgICAgICAgICBJREJGUy5sb2FkUmVtb3RlRW50cnkoc3RvcmUsIHBhdGgsIGZ1bmN0aW9uIChlcnIsIGVudHJ5KSB7CiAgICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGRvbmUoZXJyKQogICAgICAgICAgICAgIElEQkZTLnN0b3JlTG9jYWxFbnRyeShwYXRoLCBlbnRyeSwgZG9uZSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgSURCRlMubG9hZExvY2FsRW50cnkocGF0aCwgZnVuY3Rpb24gKGVyciwgZW50cnkpIHsKICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gZG9uZShlcnIpCiAgICAgICAgICAgICAgSURCRlMuc3RvcmVSZW1vdGVFbnRyeShzdG9yZSwgcGF0aCwgZW50cnksIGRvbmUpOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9KTsKICAgICAgICByZW1vdmUKICAgICAgICAgIC5zb3J0KCkKICAgICAgICAgIC5yZXZlcnNlKCkKICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChwYXRoKSB7CiAgICAgICAgICAgIGlmIChkc3QudHlwZSA9PT0gJ2xvY2FsJykgewogICAgICAgICAgICAgIElEQkZTLnJlbW92ZUxvY2FsRW50cnkocGF0aCwgZG9uZSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgSURCRlMucmVtb3ZlUmVtb3RlRW50cnkoc3RvcmUsIHBhdGgsIGRvbmUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgfSwKICAgIH07CiAgICB2YXIgTk9ERUZTID0gewogICAgICBpc1dpbmRvd3M6IGZhbHNlLAogICAgICBzdGF0aWNJbml0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgTk9ERUZTLmlzV2luZG93cyA9ICEhcHJvY2Vzcy5wbGF0Zm9ybS5tYXRjaCgvXndpbi8pOwogICAgICAgIHZhciBmbGFncyA9IHByb2Nlc3NbJ2JpbmRpbmcnXSgnY29uc3RhbnRzJyk7CiAgICAgICAgaWYgKGZsYWdzWydmcyddKSB7CiAgICAgICAgICBmbGFncyA9IGZsYWdzWydmcyddOwogICAgICAgIH0KICAgICAgICBOT0RFRlMuZmxhZ3NGb3JOb2RlTWFwID0gewogICAgICAgICAgMTAyNDogZmxhZ3NbJ09fQVBQRU5EJ10sCiAgICAgICAgICA2NDogZmxhZ3NbJ09fQ1JFQVQnXSwKICAgICAgICAgIDEyODogZmxhZ3NbJ09fRVhDTCddLAogICAgICAgICAgMDogZmxhZ3NbJ09fUkRPTkxZJ10sCiAgICAgICAgICAyOiBmbGFnc1snT19SRFdSJ10sCiAgICAgICAgICA0MDk2OiBmbGFnc1snT19TWU5DJ10sCiAgICAgICAgICA1MTI6IGZsYWdzWydPX1RSVU5DJ10sCiAgICAgICAgICAxOiBmbGFnc1snT19XUk9OTFknXSwKICAgICAgICB9OwogICAgICB9LAogICAgICBidWZmZXJGcm9tOiBmdW5jdGlvbiAoYXJyYXlCdWZmZXIpIHsKICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jID8gQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpIDogbmV3IEJ1ZmZlcihhcnJheUJ1ZmZlcikKICAgICAgfSwKICAgICAgbW91bnQ6IGZ1bmN0aW9uIChtb3VudCkgewogICAgICAgIGFzc2VydChFTlZJUk9OTUVOVF9JU19OT0RFKTsKICAgICAgICByZXR1cm4gTk9ERUZTLmNyZWF0ZU5vZGUobnVsbCwgJy8nLCBOT0RFRlMuZ2V0TW9kZShtb3VudC5vcHRzLnJvb3QpLCAwKQogICAgICB9LAogICAgICBjcmVhdGVOb2RlOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHsKICAgICAgICBpZiAoIUZTLmlzRGlyKG1vZGUpICYmICFGUy5pc0ZpbGUobW9kZSkgJiYgIUZTLmlzTGluayhtb2RlKSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgIH0KICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlKTsKICAgICAgICBub2RlLm5vZGVfb3BzID0gTk9ERUZTLm5vZGVfb3BzOwogICAgICAgIG5vZGUuc3RyZWFtX29wcyA9IE5PREVGUy5zdHJlYW1fb3BzOwogICAgICAgIHJldHVybiBub2RlCiAgICAgIH0sCiAgICAgIGdldE1vZGU6IGZ1bmN0aW9uIChwYXRoKSB7CiAgICAgICAgdmFyIHN0YXQ7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHN0YXQgPSBmcy5sc3RhdFN5bmMocGF0aCk7CiAgICAgICAgICBpZiAoTk9ERUZTLmlzV2luZG93cykgewogICAgICAgICAgICBzdGF0Lm1vZGUgPSBzdGF0Lm1vZGUgfCAoKHN0YXQubW9kZSAmIDI5MikgPj4gMik7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgaWYgKCFlLmNvZGUpIHRocm93IGUKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pCiAgICAgICAgfQogICAgICAgIHJldHVybiBzdGF0Lm1vZGUKICAgICAgfSwKICAgICAgcmVhbFBhdGg6IGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgdmFyIHBhcnRzID0gW107CiAgICAgICAgd2hpbGUgKG5vZGUucGFyZW50ICE9PSBub2RlKSB7CiAgICAgICAgICBwYXJ0cy5wdXNoKG5vZGUubmFtZSk7CiAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7CiAgICAgICAgfQogICAgICAgIHBhcnRzLnB1c2gobm9kZS5tb3VudC5vcHRzLnJvb3QpOwogICAgICAgIHBhcnRzLnJldmVyc2UoKTsKICAgICAgICByZXR1cm4gUEFUSC5qb2luLmFwcGx5KG51bGwsIHBhcnRzKQogICAgICB9LAogICAgICBmbGFnc0Zvck5vZGU6IGZ1bmN0aW9uIChmbGFncykgewogICAgICAgIGZsYWdzICY9IH4yMDk3MTUyOwogICAgICAgIGZsYWdzICY9IH4yMDQ4OwogICAgICAgIGZsYWdzICY9IH4zMjc2ODsKICAgICAgICBmbGFncyAmPSB+NTI0Mjg4OwogICAgICAgIHZhciBuZXdGbGFncyA9IDA7CiAgICAgICAgZm9yICh2YXIgayBpbiBOT0RFRlMuZmxhZ3NGb3JOb2RlTWFwKSB7CiAgICAgICAgICBpZiAoZmxhZ3MgJiBrKSB7CiAgICAgICAgICAgIG5ld0ZsYWdzIHw9IE5PREVGUy5mbGFnc0Zvck5vZGVNYXBba107CiAgICAgICAgICAgIGZsYWdzIF49IGs7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGlmICghZmxhZ3MpIHsKICAgICAgICAgIHJldHVybiBuZXdGbGFncwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpCiAgICAgICAgfQogICAgICB9LAogICAgICBub2RlX29wczogewogICAgICAgIGdldGF0dHI6IGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgICB2YXIgcGF0aCA9IE5PREVGUy5yZWFsUGF0aChub2RlKTsKICAgICAgICAgIHZhciBzdGF0OwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgc3RhdCA9IGZzLmxzdGF0U3luYyhwYXRoKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgaWYgKCFlLmNvZGUpIHRocm93IGUKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSkKICAgICAgICAgIH0KICAgICAgICAgIGlmIChOT0RFRlMuaXNXaW5kb3dzICYmICFzdGF0LmJsa3NpemUpIHsKICAgICAgICAgICAgc3RhdC5ibGtzaXplID0gNDA5NjsKICAgICAgICAgIH0KICAgICAgICAgIGlmIChOT0RFRlMuaXNXaW5kb3dzICYmICFzdGF0LmJsb2NrcykgewogICAgICAgICAgICBzdGF0LmJsb2NrcyA9ICgoc3RhdC5zaXplICsgc3RhdC5ibGtzaXplIC0gMSkgLyBzdGF0LmJsa3NpemUpIHwgMDsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgIGRldjogc3RhdC5kZXYsCiAgICAgICAgICAgIGlubzogc3RhdC5pbm8sCiAgICAgICAgICAgIG1vZGU6IHN0YXQubW9kZSwKICAgICAgICAgICAgbmxpbms6IHN0YXQubmxpbmssCiAgICAgICAgICAgIHVpZDogc3RhdC51aWQsCiAgICAgICAgICAgIGdpZDogc3RhdC5naWQsCiAgICAgICAgICAgIHJkZXY6IHN0YXQucmRldiwKICAgICAgICAgICAgc2l6ZTogc3RhdC5zaXplLAogICAgICAgICAgICBhdGltZTogc3RhdC5hdGltZSwKICAgICAgICAgICAgbXRpbWU6IHN0YXQubXRpbWUsCiAgICAgICAgICAgIGN0aW1lOiBzdGF0LmN0aW1lLAogICAgICAgICAgICBibGtzaXplOiBzdGF0LmJsa3NpemUsCiAgICAgICAgICAgIGJsb2Nrczogc3RhdC5ibG9ja3MsCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBzZXRhdHRyOiBmdW5jdGlvbiAobm9kZSwgYXR0cikgewogICAgICAgICAgdmFyIHBhdGggPSBOT0RFRlMucmVhbFBhdGgobm9kZSk7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoYXR0ci5tb2RlICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICBmcy5jaG1vZFN5bmMocGF0aCwgYXR0ci5tb2RlKTsKICAgICAgICAgICAgICBub2RlLm1vZGUgPSBhdHRyLm1vZGU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGF0dHIudGltZXN0YW1wICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKGF0dHIudGltZXN0YW1wKTsKICAgICAgICAgICAgICBmcy51dGltZXNTeW5jKHBhdGgsIGRhdGUsIGRhdGUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChhdHRyLnNpemUgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgIGZzLnRydW5jYXRlU3luYyhwYXRoLCBhdHRyLnNpemUpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGlmICghZS5jb2RlKSB0aHJvdyBlCiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBsb29rdXA6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHsKICAgICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMihOT0RFRlMucmVhbFBhdGgocGFyZW50KSwgbmFtZSk7CiAgICAgICAgICB2YXIgbW9kZSA9IE5PREVGUy5nZXRNb2RlKHBhdGgpOwogICAgICAgICAgcmV0dXJuIE5PREVGUy5jcmVhdGVOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSkKICAgICAgICB9LAogICAgICAgIG1rbm9kOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpIHsKICAgICAgICAgIHZhciBub2RlID0gTk9ERUZTLmNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlLCBkZXYpOwogICAgICAgICAgdmFyIHBhdGggPSBOT0RFRlMucmVhbFBhdGgobm9kZSk7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkgewogICAgICAgICAgICAgIGZzLm1rZGlyU3luYyhwYXRoLCBub2RlLm1vZGUpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGZzLndyaXRlRmlsZVN5bmMocGF0aCwgJycsIHsgbW9kZTogbm9kZS5tb2RlIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGlmICghZS5jb2RlKSB0aHJvdyBlCiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pCiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gbm9kZQogICAgICAgIH0sCiAgICAgICAgcmVuYW1lOiBmdW5jdGlvbiAob2xkTm9kZSwgbmV3RGlyLCBuZXdOYW1lKSB7CiAgICAgICAgICB2YXIgb2xkUGF0aCA9IE5PREVGUy5yZWFsUGF0aChvbGROb2RlKTsKICAgICAgICAgIHZhciBuZXdQYXRoID0gUEFUSC5qb2luMihOT0RFRlMucmVhbFBhdGgobmV3RGlyKSwgbmV3TmFtZSk7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBmcy5yZW5hbWVTeW5jKG9sZFBhdGgsIG5ld1BhdGgpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBpZiAoIWUuY29kZSkgdGhyb3cgZQogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgdW5saW5rOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lKSB7CiAgICAgICAgICB2YXIgcGF0aCA9IFBBVEguam9pbjIoTk9ERUZTLnJlYWxQYXRoKHBhcmVudCksIG5hbWUpOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgZnMudW5saW5rU3luYyhwYXRoKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgaWYgKCFlLmNvZGUpIHRocm93IGUKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSkKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHJtZGlyOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lKSB7CiAgICAgICAgICB2YXIgcGF0aCA9IFBBVEguam9pbjIoTk9ERUZTLnJlYWxQYXRoKHBhcmVudCksIG5hbWUpOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgZnMucm1kaXJTeW5jKHBhdGgpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBpZiAoIWUuY29kZSkgdGhyb3cgZQogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgcmVhZGRpcjogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICAgIHZhciBwYXRoID0gTk9ERUZTLnJlYWxQYXRoKG5vZGUpOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgcmV0dXJuIGZzLnJlYWRkaXJTeW5jKHBhdGgpCiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGlmICghZS5jb2RlKSB0aHJvdyBlCiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBzeW1saW5rOiBmdW5jdGlvbiAocGFyZW50LCBuZXdOYW1lLCBvbGRQYXRoKSB7CiAgICAgICAgICB2YXIgbmV3UGF0aCA9IFBBVEguam9pbjIoTk9ERUZTLnJlYWxQYXRoKHBhcmVudCksIG5ld05hbWUpOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgZnMuc3ltbGlua1N5bmMob2xkUGF0aCwgbmV3UGF0aCk7CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGlmICghZS5jb2RlKSB0aHJvdyBlCiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICByZWFkbGluazogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICAgIHZhciBwYXRoID0gTk9ERUZTLnJlYWxQYXRoKG5vZGUpOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgcGF0aCA9IGZzLnJlYWRsaW5rU3luYyhwYXRoKTsKICAgICAgICAgICAgcGF0aCA9IE5PREVKU19QQVRILnJlbGF0aXZlKE5PREVKU19QQVRILnJlc29sdmUobm9kZS5tb3VudC5vcHRzLnJvb3QpLCBwYXRoKTsKICAgICAgICAgICAgcmV0dXJuIHBhdGgKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgaWYgKCFlLmNvZGUpIHRocm93IGUKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSkKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICB9LAogICAgICBzdHJlYW1fb3BzOiB7CiAgICAgICAgb3BlbjogZnVuY3Rpb24gKHN0cmVhbSkgewogICAgICAgICAgdmFyIHBhdGggPSBOT0RFRlMucmVhbFBhdGgoc3RyZWFtLm5vZGUpOwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgaWYgKEZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkgewogICAgICAgICAgICAgIHN0cmVhbS5uZmQgPSBmcy5vcGVuU3luYyhwYXRoLCBOT0RFRlMuZmxhZ3NGb3JOb2RlKHN0cmVhbS5mbGFncykpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGlmICghZS5jb2RlKSB0aHJvdyBlCiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBjbG9zZTogZnVuY3Rpb24gKHN0cmVhbSkgewogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgaWYgKEZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSAmJiBzdHJlYW0ubmZkKSB7CiAgICAgICAgICAgICAgZnMuY2xvc2VTeW5jKHN0cmVhbS5uZmQpOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIGlmICghZS5jb2RlKSB0aHJvdyBlCiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICByZWFkOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgewogICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuIDAKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIHJldHVybiBmcy5yZWFkU3luYyhzdHJlYW0ubmZkLCBOT0RFRlMuYnVmZmVyRnJvbShidWZmZXIuYnVmZmVyKSwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKQogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFU1tlLmNvZGVdKQogICAgICAgICAgfQogICAgICAgIH0sCiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICByZXR1cm4gZnMud3JpdGVTeW5jKHN0cmVhbS5uZmQsIE5PREVGUy5idWZmZXJGcm9tKGJ1ZmZlci5idWZmZXIpLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pCiAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTW2UuY29kZV0pCiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBsbHNlZWs6IGZ1bmN0aW9uIChzdHJlYW0sIG9mZnNldCwgd2hlbmNlKSB7CiAgICAgICAgICB2YXIgcG9zaXRpb24gPSBvZmZzZXQ7CiAgICAgICAgICBpZiAod2hlbmNlID09PSAxKSB7CiAgICAgICAgICAgIHBvc2l0aW9uICs9IHN0cmVhbS5wb3NpdGlvbjsKICAgICAgICAgIH0gZWxzZSBpZiAod2hlbmNlID09PSAyKSB7CiAgICAgICAgICAgIGlmIChGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpIHsKICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgdmFyIHN0YXQgPSBmcy5mc3RhdFN5bmMoc3RyZWFtLm5mZCk7CiAgICAgICAgICAgICAgICBwb3NpdGlvbiArPSBzdGF0LnNpemU7CiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVNbZS5jb2RlXSkKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHBvc2l0aW9uCiAgICAgICAgfSwKICAgICAgfSwKICAgIH07CiAgICB2YXIgV09SS0VSRlMgPSB7CiAgICAgIERJUl9NT0RFOiAxNjg5NSwKICAgICAgRklMRV9NT0RFOiAzMzI3OSwKICAgICAgcmVhZGVyOiBudWxsLAogICAgICBtb3VudDogZnVuY3Rpb24gKG1vdW50KSB7CiAgICAgICAgYXNzZXJ0KEVOVklST05NRU5UX0lTX1dPUktFUik7CiAgICAgICAgaWYgKCFXT1JLRVJGUy5yZWFkZXIpIFdPUktFUkZTLnJlYWRlciA9IG5ldyBGaWxlUmVhZGVyU3luYygpOwogICAgICAgIHZhciByb290ID0gV09SS0VSRlMuY3JlYXRlTm9kZShudWxsLCAnLycsIFdPUktFUkZTLkRJUl9NT0RFLCAwKTsKICAgICAgICB2YXIgY3JlYXRlZFBhcmVudHMgPSB7fTsKICAgICAgICBmdW5jdGlvbiBlbnN1cmVQYXJlbnQocGF0aCkgewogICAgICAgICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLycpOwogICAgICAgICAgdmFyIHBhcmVudCA9IHJvb3Q7CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykgewogICAgICAgICAgICB2YXIgY3VyciA9IHBhcnRzLnNsaWNlKDAsIGkgKyAxKS5qb2luKCcvJyk7CiAgICAgICAgICAgIGlmICghY3JlYXRlZFBhcmVudHNbY3Vycl0pIHsKICAgICAgICAgICAgICBjcmVhdGVkUGFyZW50c1tjdXJyXSA9IFdPUktFUkZTLmNyZWF0ZU5vZGUocGFyZW50LCBwYXJ0c1tpXSwgV09SS0VSRlMuRElSX01PREUsIDApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHBhcmVudCA9IGNyZWF0ZWRQYXJlbnRzW2N1cnJdOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHBhcmVudAogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiBiYXNlKHBhdGgpIHsKICAgICAgICAgIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTsKICAgICAgICAgIHJldHVybiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXQogICAgICAgIH0KICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG1vdW50Lm9wdHNbJ2ZpbGVzJ10gfHwgW10sIGZ1bmN0aW9uIChmaWxlKSB7CiAgICAgICAgICBXT1JLRVJGUy5jcmVhdGVOb2RlKAogICAgICAgICAgICBlbnN1cmVQYXJlbnQoZmlsZS5uYW1lKSwKICAgICAgICAgICAgYmFzZShmaWxlLm5hbWUpLAogICAgICAgICAgICBXT1JLRVJGUy5GSUxFX01PREUsCiAgICAgICAgICAgIDAsCiAgICAgICAgICAgIGZpbGUsCiAgICAgICAgICAgIGZpbGUubGFzdE1vZGlmaWVkRGF0ZQogICAgICAgICAgKTsKICAgICAgICB9KQogICAgICAgIDsobW91bnQub3B0c1snYmxvYnMnXSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7CiAgICAgICAgICBXT1JLRVJGUy5jcmVhdGVOb2RlKGVuc3VyZVBhcmVudChvYmpbJ25hbWUnXSksIGJhc2Uob2JqWyduYW1lJ10pLCBXT1JLRVJGUy5GSUxFX01PREUsIDAsIG9ialsnZGF0YSddKTsKICAgICAgICB9KQogICAgICAgIDsobW91bnQub3B0c1sncGFja2FnZXMnXSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAocGFjaykgewogICAgICAgICAgcGFja1snbWV0YWRhdGEnXS5maWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7CiAgICAgICAgICAgIHZhciBuYW1lID0gZmlsZS5maWxlbmFtZS5zdWJzdHIoMSk7CiAgICAgICAgICAgIFdPUktFUkZTLmNyZWF0ZU5vZGUoCiAgICAgICAgICAgICAgZW5zdXJlUGFyZW50KG5hbWUpLAogICAgICAgICAgICAgIGJhc2UobmFtZSksCiAgICAgICAgICAgICAgV09SS0VSRlMuRklMRV9NT0RFLAogICAgICAgICAgICAgIDAsCiAgICAgICAgICAgICAgcGFja1snYmxvYiddLnNsaWNlKGZpbGUuc3RhcnQsIGZpbGUuZW5kKQogICAgICAgICAgICApOwogICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgICAgcmV0dXJuIHJvb3QKICAgICAgfSwKICAgICAgY3JlYXRlTm9kZTogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSwgbW9kZSwgZGV2LCBjb250ZW50cywgbXRpbWUpIHsKICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZU5vZGUocGFyZW50LCBuYW1lLCBtb2RlKTsKICAgICAgICBub2RlLm1vZGUgPSBtb2RlOwogICAgICAgIG5vZGUubm9kZV9vcHMgPSBXT1JLRVJGUy5ub2RlX29wczsKICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBXT1JLRVJGUy5zdHJlYW1fb3BzOwogICAgICAgIG5vZGUudGltZXN0YW1wID0gKG10aW1lIHx8IG5ldyBEYXRlKCkpLmdldFRpbWUoKTsKICAgICAgICBhc3NlcnQoV09SS0VSRlMuRklMRV9NT0RFICE9PSBXT1JLRVJGUy5ESVJfTU9ERSk7CiAgICAgICAgaWYgKG1vZGUgPT09IFdPUktFUkZTLkZJTEVfTU9ERSkgewogICAgICAgICAgbm9kZS5zaXplID0gY29udGVudHMuc2l6ZTsKICAgICAgICAgIG5vZGUuY29udGVudHMgPSBjb250ZW50czsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbm9kZS5zaXplID0gNDA5NjsKICAgICAgICAgIG5vZGUuY29udGVudHMgPSB7fTsKICAgICAgICB9CiAgICAgICAgaWYgKHBhcmVudCkgewogICAgICAgICAgcGFyZW50LmNvbnRlbnRzW25hbWVdID0gbm9kZTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG5vZGUKICAgICAgfSwKICAgICAgbm9kZV9vcHM6IHsKICAgICAgICBnZXRhdHRyOiBmdW5jdGlvbiAobm9kZSkgewogICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgZGV2OiAxLAogICAgICAgICAgICBpbm86IHVuZGVmaW5lZCwKICAgICAgICAgICAgbW9kZTogbm9kZS5tb2RlLAogICAgICAgICAgICBubGluazogMSwKICAgICAgICAgICAgdWlkOiAwLAogICAgICAgICAgICBnaWQ6IDAsCiAgICAgICAgICAgIHJkZXY6IHVuZGVmaW5lZCwKICAgICAgICAgICAgc2l6ZTogbm9kZS5zaXplLAogICAgICAgICAgICBhdGltZTogbmV3IERhdGUobm9kZS50aW1lc3RhbXApLAogICAgICAgICAgICBtdGltZTogbmV3IERhdGUobm9kZS50aW1lc3RhbXApLAogICAgICAgICAgICBjdGltZTogbmV3IERhdGUobm9kZS50aW1lc3RhbXApLAogICAgICAgICAgICBibGtzaXplOiA0MDk2LAogICAgICAgICAgICBibG9ja3M6IE1hdGguY2VpbChub2RlLnNpemUgLyA0MDk2KSwKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHNldGF0dHI6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7CiAgICAgICAgICBpZiAoYXR0ci5tb2RlICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgbm9kZS5tb2RlID0gYXR0ci5tb2RlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGF0dHIudGltZXN0YW1wICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgbm9kZS50aW1lc3RhbXAgPSBhdHRyLnRpbWVzdGFtcDsKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGxvb2t1cDogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKQogICAgICAgIH0sCiAgICAgICAgbWtub2Q6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUsIG1vZGUsIGRldikgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pCiAgICAgICAgfSwKICAgICAgICByZW5hbWU6IGZ1bmN0aW9uIChvbGROb2RlLCBuZXdEaXIsIG5ld05hbWUpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKQogICAgICAgIH0sCiAgICAgICAgdW5saW5rOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSkKICAgICAgICB9LAogICAgICAgIHJtZGlyOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSkKICAgICAgICB9LAogICAgICAgIHJlYWRkaXI6IGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgICB2YXIgZW50cmllcyA9IFsnLicsICcuLiddOwogICAgICAgICAgZm9yICh2YXIga2V5IGluIG5vZGUuY29udGVudHMpIHsKICAgICAgICAgICAgaWYgKCFub2RlLmNvbnRlbnRzLmhhc093blByb3BlcnR5KGtleSkpIHsKICAgICAgICAgICAgICBjb250aW51ZQogICAgICAgICAgICB9CiAgICAgICAgICAgIGVudHJpZXMucHVzaChrZXkpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIGVudHJpZXMKICAgICAgICB9LAogICAgICAgIHN5bWxpbms6IGZ1bmN0aW9uIChwYXJlbnQsIG5ld05hbWUsIG9sZFBhdGgpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKQogICAgICAgIH0sCiAgICAgICAgcmVhZGxpbms6IGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSkKICAgICAgICB9LAogICAgICB9LAogICAgICBzdHJlYW1fb3BzOiB7CiAgICAgICAgcmVhZDogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHsKICAgICAgICAgIGlmIChwb3NpdGlvbiA+PSBzdHJlYW0ubm9kZS5zaXplKSByZXR1cm4gMAogICAgICAgICAgdmFyIGNodW5rID0gc3RyZWFtLm5vZGUuY29udGVudHMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgbGVuZ3RoKTsKICAgICAgICAgIHZhciBhYiA9IFdPUktFUkZTLnJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihjaHVuayk7CiAgICAgICAgICBidWZmZXIuc2V0KG5ldyBVaW50OEFycmF5KGFiKSwgb2Zmc2V0KTsKICAgICAgICAgIHJldHVybiBjaHVuay5zaXplCiAgICAgICAgfSwKICAgICAgICB3cml0ZTogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24pIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTykKICAgICAgICB9LAogICAgICAgIGxsc2VlazogZnVuY3Rpb24gKHN0cmVhbSwgb2Zmc2V0LCB3aGVuY2UpIHsKICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG9mZnNldDsKICAgICAgICAgIGlmICh3aGVuY2UgPT09IDEpIHsKICAgICAgICAgICAgcG9zaXRpb24gKz0gc3RyZWFtLnBvc2l0aW9uOwogICAgICAgICAgfSBlbHNlIGlmICh3aGVuY2UgPT09IDIpIHsKICAgICAgICAgICAgaWYgKEZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSkgewogICAgICAgICAgICAgIHBvc2l0aW9uICs9IHN0cmVhbS5ub2RlLnNpemU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmIChwb3NpdGlvbiA8IDApIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHBvc2l0aW9uCiAgICAgICAgfSwKICAgICAgfSwKICAgIH07CiAgICBTVEFUSUNUT1AgKz0gMTY7CiAgICBTVEFUSUNUT1AgKz0gMTY7CiAgICBTVEFUSUNUT1AgKz0gMTY7CiAgICB2YXIgRlMgPSB7CiAgICAgIHJvb3Q6IG51bGwsCiAgICAgIG1vdW50czogW10sCiAgICAgIGRldmljZXM6IHt9LAogICAgICBzdHJlYW1zOiBbXSwKICAgICAgbmV4dElub2RlOiAxLAogICAgICBuYW1lVGFibGU6IG51bGwsCiAgICAgIGN1cnJlbnRQYXRoOiAnLycsCiAgICAgIGluaXRpYWxpemVkOiBmYWxzZSwKICAgICAgaWdub3JlUGVybWlzc2lvbnM6IHRydWUsCiAgICAgIHRyYWNraW5nRGVsZWdhdGU6IHt9LAogICAgICB0cmFja2luZzogeyBvcGVuRmxhZ3M6IHsgUkVBRDogMSwgV1JJVEU6IDIgfSB9LAogICAgICBFcnJub0Vycm9yOiBudWxsLAogICAgICBnZW5lcmljRXJyb3JzOiB7fSwKICAgICAgZmlsZXN5c3RlbXM6IG51bGwsCiAgICAgIHN5bmNGU1JlcXVlc3RzOiAwLAogICAgICBoYW5kbGVGU0Vycm9yOiBmdW5jdGlvbiAoZSkgewogICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgdGhyb3cgZSArICcgOiAnICsgc3RhY2tUcmFjZSgpCiAgICAgICAgcmV0dXJuIF9fX3NldEVyck5vKGUuZXJybm8pCiAgICAgIH0sCiAgICAgIGxvb2t1cFBhdGg6IGZ1bmN0aW9uIChwYXRoLCBvcHRzKSB7CiAgICAgICAgcGF0aCA9IFBBVEgucmVzb2x2ZShGUy5jd2QoKSwgcGF0aCk7CiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307CiAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4geyBwYXRoOiAnJywgbm9kZTogbnVsbCB9CiAgICAgICAgdmFyIGRlZmF1bHRzID0geyBmb2xsb3dfbW91bnQ6IHRydWUsIHJlY3Vyc2VfY291bnQ6IDAgfTsKICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHsKICAgICAgICAgIGlmIChvcHRzW2tleV0gPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICBvcHRzW2tleV0gPSBkZWZhdWx0c1trZXldOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBpZiAob3B0cy5yZWN1cnNlX2NvdW50ID4gOCkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUxPT1ApCiAgICAgICAgfQogICAgICAgIHZhciBwYXJ0cyA9IFBBVEgubm9ybWFsaXplQXJyYXkoCiAgICAgICAgICBwYXRoLnNwbGl0KCcvJykuZmlsdGVyKGZ1bmN0aW9uIChwKSB7CiAgICAgICAgICAgIHJldHVybiAhIXAKICAgICAgICAgIH0pLAogICAgICAgICAgZmFsc2UKICAgICAgICApOwogICAgICAgIHZhciBjdXJyZW50ID0gRlMucm9vdDsKICAgICAgICB2YXIgY3VycmVudF9wYXRoID0gJy8nOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgIHZhciBpc2xhc3QgPSBpID09PSBwYXJ0cy5sZW5ndGggLSAxOwogICAgICAgICAgaWYgKGlzbGFzdCAmJiBvcHRzLnBhcmVudCkgewogICAgICAgICAgICBicmVhawogICAgICAgICAgfQogICAgICAgICAgY3VycmVudCA9IEZTLmxvb2t1cE5vZGUoY3VycmVudCwgcGFydHNbaV0pOwogICAgICAgICAgY3VycmVudF9wYXRoID0gUEFUSC5qb2luMihjdXJyZW50X3BhdGgsIHBhcnRzW2ldKTsKICAgICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQoY3VycmVudCkpIHsKICAgICAgICAgICAgaWYgKCFpc2xhc3QgfHwgKGlzbGFzdCAmJiBvcHRzLmZvbGxvd19tb3VudCkpIHsKICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5tb3VudGVkLnJvb3Q7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGlmICghaXNsYXN0IHx8IG9wdHMuZm9sbG93KSB7CiAgICAgICAgICAgIHZhciBjb3VudCA9IDA7CiAgICAgICAgICAgIHdoaWxlIChGUy5pc0xpbmsoY3VycmVudC5tb2RlKSkgewogICAgICAgICAgICAgIHZhciBsaW5rID0gRlMucmVhZGxpbmsoY3VycmVudF9wYXRoKTsKICAgICAgICAgICAgICBjdXJyZW50X3BhdGggPSBQQVRILnJlc29sdmUoUEFUSC5kaXJuYW1lKGN1cnJlbnRfcGF0aCksIGxpbmspOwogICAgICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKGN1cnJlbnRfcGF0aCwgeyByZWN1cnNlX2NvdW50OiBvcHRzLnJlY3Vyc2VfY291bnQgfSk7CiAgICAgICAgICAgICAgY3VycmVudCA9IGxvb2t1cC5ub2RlOwogICAgICAgICAgICAgIGlmIChjb3VudCsrID4gNDApIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVMT09QKQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4geyBwYXRoOiBjdXJyZW50X3BhdGgsIG5vZGU6IGN1cnJlbnQgfQogICAgICB9LAogICAgICBnZXRQYXRoOiBmdW5jdGlvbiAobm9kZSkgewogICAgICAgIHZhciBwYXRoOwogICAgICAgIHdoaWxlICh0cnVlKSB7CiAgICAgICAgICBpZiAoRlMuaXNSb290KG5vZGUpKSB7CiAgICAgICAgICAgIHZhciBtb3VudCA9IG5vZGUubW91bnQubW91bnRwb2ludDsKICAgICAgICAgICAgaWYgKCFwYXRoKSByZXR1cm4gbW91bnQKICAgICAgICAgICAgcmV0dXJuIG1vdW50W21vdW50Lmxlbmd0aCAtIDFdICE9PSAnLycgPyBtb3VudCArICcvJyArIHBhdGggOiBtb3VudCArIHBhdGgKICAgICAgICAgIH0KICAgICAgICAgIHBhdGggPSBwYXRoID8gbm9kZS5uYW1lICsgJy8nICsgcGF0aCA6IG5vZGUubmFtZTsKICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudDsKICAgICAgICB9CiAgICAgIH0sCiAgICAgIGhhc2hOYW1lOiBmdW5jdGlvbiAocGFyZW50aWQsIG5hbWUpIHsKICAgICAgICB2YXIgaGFzaCA9IDA7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCArIG5hbWUuY2hhckNvZGVBdChpKSkgfCAwOwogICAgICAgIH0KICAgICAgICByZXR1cm4gKChwYXJlbnRpZCArIGhhc2gpID4+PiAwKSAlIEZTLm5hbWVUYWJsZS5sZW5ndGgKICAgICAgfSwKICAgICAgaGFzaEFkZE5vZGU6IGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgdmFyIGhhc2ggPSBGUy5oYXNoTmFtZShub2RlLnBhcmVudC5pZCwgbm9kZS5uYW1lKTsKICAgICAgICBub2RlLm5hbWVfbmV4dCA9IEZTLm5hbWVUYWJsZVtoYXNoXTsKICAgICAgICBGUy5uYW1lVGFibGVbaGFzaF0gPSBub2RlOwogICAgICB9LAogICAgICBoYXNoUmVtb3ZlTm9kZTogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKG5vZGUucGFyZW50LmlkLCBub2RlLm5hbWUpOwogICAgICAgIGlmIChGUy5uYW1lVGFibGVbaGFzaF0gPT09IG5vZGUpIHsKICAgICAgICAgIEZTLm5hbWVUYWJsZVtoYXNoXSA9IG5vZGUubmFtZV9uZXh0OwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB2YXIgY3VycmVudCA9IEZTLm5hbWVUYWJsZVtoYXNoXTsKICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7CiAgICAgICAgICAgIGlmIChjdXJyZW50Lm5hbWVfbmV4dCA9PT0gbm9kZSkgewogICAgICAgICAgICAgIGN1cnJlbnQubmFtZV9uZXh0ID0gbm9kZS5uYW1lX25leHQ7CiAgICAgICAgICAgICAgYnJlYWsKICAgICAgICAgICAgfQogICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uYW1lX25leHQ7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9LAogICAgICBsb29rdXBOb2RlOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lKSB7CiAgICAgICAgdmFyIGVyciA9IEZTLm1heUxvb2t1cChwYXJlbnQpOwogICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyciwgcGFyZW50KQogICAgICAgIH0KICAgICAgICB2YXIgaGFzaCA9IEZTLmhhc2hOYW1lKHBhcmVudC5pZCwgbmFtZSk7CiAgICAgICAgZm9yICh2YXIgbm9kZSA9IEZTLm5hbWVUYWJsZVtoYXNoXTsgbm9kZTsgbm9kZSA9IG5vZGUubmFtZV9uZXh0KSB7CiAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBub2RlLm5hbWU7CiAgICAgICAgICBpZiAobm9kZS5wYXJlbnQuaWQgPT09IHBhcmVudC5pZCAmJiBub2RlTmFtZSA9PT0gbmFtZSkgewogICAgICAgICAgICByZXR1cm4gbm9kZQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gRlMubG9va3VwKHBhcmVudCwgbmFtZSkKICAgICAgfSwKICAgICAgY3JlYXRlTm9kZTogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSwgbW9kZSwgcmRldikgewogICAgICAgIGlmICghRlMuRlNOb2RlKSB7CiAgICAgICAgICBGUy5GU05vZGUgPSBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBtb2RlLCByZGV2KSB7CiAgICAgICAgICAgIGlmICghcGFyZW50KSB7CiAgICAgICAgICAgICAgcGFyZW50ID0gdGhpczsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDsKICAgICAgICAgICAgdGhpcy5tb3VudCA9IHBhcmVudC5tb3VudDsKICAgICAgICAgICAgdGhpcy5tb3VudGVkID0gbnVsbDsKICAgICAgICAgICAgdGhpcy5pZCA9IEZTLm5leHRJbm9kZSsrOwogICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lOwogICAgICAgICAgICB0aGlzLm1vZGUgPSBtb2RlOwogICAgICAgICAgICB0aGlzLm5vZGVfb3BzID0ge307CiAgICAgICAgICAgIHRoaXMuc3RyZWFtX29wcyA9IHt9OwogICAgICAgICAgICB0aGlzLnJkZXYgPSByZGV2OwogICAgICAgICAgfTsKICAgICAgICAgIEZTLkZTTm9kZS5wcm90b3R5cGUgPSB7fTsKICAgICAgICAgIHZhciByZWFkTW9kZSA9IDI5MiB8IDczOwogICAgICAgICAgdmFyIHdyaXRlTW9kZSA9IDE0NjsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZTLkZTTm9kZS5wcm90b3R5cGUsIHsKICAgICAgICAgICAgcmVhZDogewogICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLm1vZGUgJiByZWFkTW9kZSkgPT09IHJlYWRNb2RlCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsKICAgICAgICAgICAgICAgIHZhbCA/ICh0aGlzLm1vZGUgfD0gcmVhZE1vZGUpIDogKHRoaXMubW9kZSAmPSB+cmVhZE1vZGUpOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHdyaXRlOiB7CiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMubW9kZSAmIHdyaXRlTW9kZSkgPT09IHdyaXRlTW9kZQogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7CiAgICAgICAgICAgICAgICB2YWwgPyAodGhpcy5tb2RlIHw9IHdyaXRlTW9kZSkgOiAodGhpcy5tb2RlICY9IH53cml0ZU1vZGUpOwogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGlzRm9sZGVyOiB7CiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gRlMuaXNEaXIodGhpcy5tb2RlKQogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGlzRGV2aWNlOiB7CiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gRlMuaXNDaHJkZXYodGhpcy5tb2RlKQogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIH0sCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgICAgdmFyIG5vZGUgPSBuZXcgRlMuRlNOb2RlKHBhcmVudCwgbmFtZSwgbW9kZSwgcmRldik7CiAgICAgICAgRlMuaGFzaEFkZE5vZGUobm9kZSk7CiAgICAgICAgcmV0dXJuIG5vZGUKICAgICAgfSwKICAgICAgZGVzdHJveU5vZGU6IGZ1bmN0aW9uIChub2RlKSB7CiAgICAgICAgRlMuaGFzaFJlbW92ZU5vZGUobm9kZSk7CiAgICAgIH0sCiAgICAgIGlzUm9vdDogZnVuY3Rpb24gKG5vZGUpIHsKICAgICAgICByZXR1cm4gbm9kZSA9PT0gbm9kZS5wYXJlbnQKICAgICAgfSwKICAgICAgaXNNb3VudHBvaW50OiBmdW5jdGlvbiAobm9kZSkgewogICAgICAgIHJldHVybiAhIW5vZGUubW91bnRlZAogICAgICB9LAogICAgICBpc0ZpbGU6IGZ1bmN0aW9uIChtb2RlKSB7CiAgICAgICAgcmV0dXJuIChtb2RlICYgNjE0NDApID09PSAzMjc2OAogICAgICB9LAogICAgICBpc0RpcjogZnVuY3Rpb24gKG1vZGUpIHsKICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDE2Mzg0CiAgICAgIH0sCiAgICAgIGlzTGluazogZnVuY3Rpb24gKG1vZGUpIHsKICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDQwOTYwCiAgICAgIH0sCiAgICAgIGlzQ2hyZGV2OiBmdW5jdGlvbiAobW9kZSkgewogICAgICAgIHJldHVybiAobW9kZSAmIDYxNDQwKSA9PT0gODE5MgogICAgICB9LAogICAgICBpc0Jsa2RldjogZnVuY3Rpb24gKG1vZGUpIHsKICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDI0NTc2CiAgICAgIH0sCiAgICAgIGlzRklGTzogZnVuY3Rpb24gKG1vZGUpIHsKICAgICAgICByZXR1cm4gKG1vZGUgJiA2MTQ0MCkgPT09IDQwOTYKICAgICAgfSwKICAgICAgaXNTb2NrZXQ6IGZ1bmN0aW9uIChtb2RlKSB7CiAgICAgICAgcmV0dXJuIChtb2RlICYgNDkxNTIpID09PSA0OTE1MgogICAgICB9LAogICAgICBmbGFnTW9kZXM6IHsKICAgICAgICByOiAwLAogICAgICAgIHJzOiAxMDUyNjcyLAogICAgICAgICdyKyc6IDIsCiAgICAgICAgdzogNTc3LAogICAgICAgIHd4OiA3MDUsCiAgICAgICAgeHc6IDcwNSwKICAgICAgICAndysnOiA1NzgsCiAgICAgICAgJ3d4Kyc6IDcwNiwKICAgICAgICAneHcrJzogNzA2LAogICAgICAgIGE6IDEwODksCiAgICAgICAgYXg6IDEyMTcsCiAgICAgICAgeGE6IDEyMTcsCiAgICAgICAgJ2ErJzogMTA5MCwKICAgICAgICAnYXgrJzogMTIxOCwKICAgICAgICAneGErJzogMTIxOCwKICAgICAgfSwKICAgICAgbW9kZVN0cmluZ1RvRmxhZ3M6IGZ1bmN0aW9uIChzdHIpIHsKICAgICAgICB2YXIgZmxhZ3MgPSBGUy5mbGFnTW9kZXNbc3RyXTsKICAgICAgICBpZiAodHlwZW9mIGZsYWdzID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGZpbGUgb3BlbiBtb2RlOiAnICsgc3RyKQogICAgICAgIH0KICAgICAgICByZXR1cm4gZmxhZ3MKICAgICAgfSwKICAgICAgZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmc6IGZ1bmN0aW9uIChmbGFnKSB7CiAgICAgICAgdmFyIHBlcm1zID0gWydyJywgJ3cnLCAncncnXVtmbGFnICYgM107CiAgICAgICAgaWYgKGZsYWcgJiA1MTIpIHsKICAgICAgICAgIHBlcm1zICs9ICd3JzsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHBlcm1zCiAgICAgIH0sCiAgICAgIG5vZGVQZXJtaXNzaW9uczogZnVuY3Rpb24gKG5vZGUsIHBlcm1zKSB7CiAgICAgICAgaWYgKEZTLmlnbm9yZVBlcm1pc3Npb25zKSB7CiAgICAgICAgICByZXR1cm4gMAogICAgICAgIH0KICAgICAgICBpZiAocGVybXMuaW5kZXhPZigncicpICE9PSAtMSAmJiAhKG5vZGUubW9kZSAmIDI5MikpIHsKICAgICAgICAgIHJldHVybiBFUlJOT19DT0RFUy5FQUNDRVMKICAgICAgICB9IGVsc2UgaWYgKHBlcm1zLmluZGV4T2YoJ3cnKSAhPT0gLTEgJiYgIShub2RlLm1vZGUgJiAxNDYpKSB7CiAgICAgICAgICByZXR1cm4gRVJSTk9fQ09ERVMuRUFDQ0VTCiAgICAgICAgfSBlbHNlIGlmIChwZXJtcy5pbmRleE9mKCd4JykgIT09IC0xICYmICEobm9kZS5tb2RlICYgNzMpKSB7CiAgICAgICAgICByZXR1cm4gRVJSTk9fQ09ERVMuRUFDQ0VTCiAgICAgICAgfQogICAgICAgIHJldHVybiAwCiAgICAgIH0sCiAgICAgIG1heUxvb2t1cDogZnVuY3Rpb24gKGRpcikgewogICAgICAgIHZhciBlcnIgPSBGUy5ub2RlUGVybWlzc2lvbnMoZGlyLCAneCcpOwogICAgICAgIGlmIChlcnIpIHJldHVybiBlcnIKICAgICAgICBpZiAoIWRpci5ub2RlX29wcy5sb29rdXApIHJldHVybiBFUlJOT19DT0RFUy5FQUNDRVMKICAgICAgICByZXR1cm4gMAogICAgICB9LAogICAgICBtYXlDcmVhdGU6IGZ1bmN0aW9uIChkaXIsIG5hbWUpIHsKICAgICAgICB0cnkgewogICAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKGRpciwgbmFtZSk7CiAgICAgICAgICByZXR1cm4gRVJSTk9fQ09ERVMuRUVYSVNUCiAgICAgICAgfSBjYXRjaCAoZSkge30KICAgICAgICByZXR1cm4gRlMubm9kZVBlcm1pc3Npb25zKGRpciwgJ3d4JykKICAgICAgfSwKICAgICAgbWF5RGVsZXRlOiBmdW5jdGlvbiAoZGlyLCBuYW1lLCBpc2RpcikgewogICAgICAgIHZhciBub2RlOwogICAgICAgIHRyeSB7CiAgICAgICAgICBub2RlID0gRlMubG9va3VwTm9kZShkaXIsIG5hbWUpOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIHJldHVybiBlLmVycm5vCiAgICAgICAgfQogICAgICAgIHZhciBlcnIgPSBGUy5ub2RlUGVybWlzc2lvbnMoZGlyLCAnd3gnKTsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICByZXR1cm4gZXJyCiAgICAgICAgfQogICAgICAgIGlmIChpc2RpcikgewogICAgICAgICAgaWYgKCFGUy5pc0Rpcihub2RlLm1vZGUpKSB7CiAgICAgICAgICAgIHJldHVybiBFUlJOT19DT0RFUy5FTk9URElSCiAgICAgICAgICB9CiAgICAgICAgICBpZiAoRlMuaXNSb290KG5vZGUpIHx8IEZTLmdldFBhdGgobm9kZSkgPT09IEZTLmN3ZCgpKSB7CiAgICAgICAgICAgIHJldHVybiBFUlJOT19DT0RFUy5FQlVTWQogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkgewogICAgICAgICAgICByZXR1cm4gRVJSTk9fQ09ERVMuRUlTRElSCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiAwCiAgICAgIH0sCiAgICAgIG1heU9wZW46IGZ1bmN0aW9uIChub2RlLCBmbGFncykgewogICAgICAgIGlmICghbm9kZSkgewogICAgICAgICAgcmV0dXJuIEVSUk5PX0NPREVTLkVOT0VOVAogICAgICAgIH0KICAgICAgICBpZiAoRlMuaXNMaW5rKG5vZGUubW9kZSkpIHsKICAgICAgICAgIHJldHVybiBFUlJOT19DT0RFUy5FTE9PUAogICAgICAgIH0gZWxzZSBpZiAoRlMuaXNEaXIobm9kZS5tb2RlKSkgewogICAgICAgICAgaWYgKEZTLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWdzKSAhPT0gJ3InIHx8IGZsYWdzICYgNTEyKSB7CiAgICAgICAgICAgIHJldHVybiBFUlJOT19DT0RFUy5FSVNESVIKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCBGUy5mbGFnc1RvUGVybWlzc2lvblN0cmluZyhmbGFncykpCiAgICAgIH0sCiAgICAgIE1BWF9PUEVOX0ZEUzogNDA5NiwKICAgICAgbmV4dGZkOiBmdW5jdGlvbiAoZmRfc3RhcnQsIGZkX2VuZCkgewogICAgICAgIGZkX3N0YXJ0ID0gZmRfc3RhcnQgfHwgMDsKICAgICAgICBmZF9lbmQgPSBmZF9lbmQgfHwgRlMuTUFYX09QRU5fRkRTOwogICAgICAgIGZvciAodmFyIGZkID0gZmRfc3RhcnQ7IGZkIDw9IGZkX2VuZDsgZmQrKykgewogICAgICAgICAgaWYgKCFGUy5zdHJlYW1zW2ZkXSkgewogICAgICAgICAgICByZXR1cm4gZmQKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU1GSUxFKQogICAgICB9LAogICAgICBnZXRTdHJlYW06IGZ1bmN0aW9uIChmZCkgewogICAgICAgIHJldHVybiBGUy5zdHJlYW1zW2ZkXQogICAgICB9LAogICAgICBjcmVhdGVTdHJlYW06IGZ1bmN0aW9uIChzdHJlYW0sIGZkX3N0YXJ0LCBmZF9lbmQpIHsKICAgICAgICBpZiAoIUZTLkZTU3RyZWFtKSB7CiAgICAgICAgICBGUy5GU1N0cmVhbSA9IGZ1bmN0aW9uICgpIHt9OwogICAgICAgICAgRlMuRlNTdHJlYW0ucHJvdG90eXBlID0ge307CiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGUy5GU1N0cmVhbS5wcm90b3R5cGUsIHsKICAgICAgICAgICAgb2JqZWN0OiB7CiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ub2RlCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHsKICAgICAgICAgICAgICAgIHRoaXMubm9kZSA9IHZhbDsKICAgICAgICAgICAgICB9LAogICAgICAgICAgICB9LAogICAgICAgICAgICBpc1JlYWQ6IHsKICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIwOTcxNTUpICE9PSAxCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgfSwKICAgICAgICAgICAgaXNXcml0ZTogewogICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLmZsYWdzICYgMjA5NzE1NSkgIT09IDAKICAgICAgICAgICAgICB9LAogICAgICAgICAgICB9LAogICAgICAgICAgICBpc0FwcGVuZDogewogICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxMDI0CiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgfSwKICAgICAgICAgIH0pOwogICAgICAgIH0KICAgICAgICB2YXIgbmV3U3RyZWFtID0gbmV3IEZTLkZTU3RyZWFtKCk7CiAgICAgICAgZm9yICh2YXIgcCBpbiBzdHJlYW0pIHsKICAgICAgICAgIG5ld1N0cmVhbVtwXSA9IHN0cmVhbVtwXTsKICAgICAgICB9CiAgICAgICAgc3RyZWFtID0gbmV3U3RyZWFtOwogICAgICAgIHZhciBmZCA9IEZTLm5leHRmZChmZF9zdGFydCwgZmRfZW5kKTsKICAgICAgICBzdHJlYW0uZmQgPSBmZDsKICAgICAgICBGUy5zdHJlYW1zW2ZkXSA9IHN0cmVhbTsKICAgICAgICByZXR1cm4gc3RyZWFtCiAgICAgIH0sCiAgICAgIGNsb3NlU3RyZWFtOiBmdW5jdGlvbiAoZmQpIHsKICAgICAgICBGUy5zdHJlYW1zW2ZkXSA9IG51bGw7CiAgICAgIH0sCiAgICAgIGNocmRldl9zdHJlYW1fb3BzOiB7CiAgICAgICAgb3BlbjogZnVuY3Rpb24gKHN0cmVhbSkgewogICAgICAgICAgdmFyIGRldmljZSA9IEZTLmdldERldmljZShzdHJlYW0ubm9kZS5yZGV2KTsKICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzID0gZGV2aWNlLnN0cmVhbV9vcHM7CiAgICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMub3BlbikgewogICAgICAgICAgICBzdHJlYW0uc3RyZWFtX29wcy5vcGVuKHN0cmVhbSk7CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICBsbHNlZWs6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVTUElQRSkKICAgICAgICB9LAogICAgICB9LAogICAgICBtYWpvcjogZnVuY3Rpb24gKGRldikgewogICAgICAgIHJldHVybiBkZXYgPj4gOAogICAgICB9LAogICAgICBtaW5vcjogZnVuY3Rpb24gKGRldikgewogICAgICAgIHJldHVybiBkZXYgJiAyNTUKICAgICAgfSwKICAgICAgbWFrZWRldjogZnVuY3Rpb24gKG1hLCBtaSkgewogICAgICAgIHJldHVybiAobWEgPDwgOCkgfCBtaQogICAgICB9LAogICAgICByZWdpc3RlckRldmljZTogZnVuY3Rpb24gKGRldiwgb3BzKSB7CiAgICAgICAgRlMuZGV2aWNlc1tkZXZdID0geyBzdHJlYW1fb3BzOiBvcHMgfTsKICAgICAgfSwKICAgICAgZ2V0RGV2aWNlOiBmdW5jdGlvbiAoZGV2KSB7CiAgICAgICAgcmV0dXJuIEZTLmRldmljZXNbZGV2XQogICAgICB9LAogICAgICBnZXRNb3VudHM6IGZ1bmN0aW9uIChtb3VudCkgewogICAgICAgIHZhciBtb3VudHMgPSBbXTsKICAgICAgICB2YXIgY2hlY2sgPSBbbW91bnRdOwogICAgICAgIHdoaWxlIChjaGVjay5sZW5ndGgpIHsKICAgICAgICAgIHZhciBtID0gY2hlY2sucG9wKCk7CiAgICAgICAgICBtb3VudHMucHVzaChtKTsKICAgICAgICAgIGNoZWNrLnB1c2guYXBwbHkoY2hlY2ssIG0ubW91bnRzKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG1vdW50cwogICAgICB9LAogICAgICBzeW5jZnM6IGZ1bmN0aW9uIChwb3B1bGF0ZSwgY2FsbGJhY2spIHsKICAgICAgICBpZiAodHlwZW9mIHBvcHVsYXRlID09PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgICBjYWxsYmFjayA9IHBvcHVsYXRlOwogICAgICAgICAgcG9wdWxhdGUgPSBmYWxzZTsKICAgICAgICB9CiAgICAgICAgRlMuc3luY0ZTUmVxdWVzdHMrKzsKICAgICAgICBpZiAoRlMuc3luY0ZTUmVxdWVzdHMgPiAxKSB7CiAgICAgICAgICBjb25zb2xlLmxvZygKICAgICAgICAgICAgJ3dhcm5pbmc6ICcgKyBGUy5zeW5jRlNSZXF1ZXN0cyArICcgRlMuc3luY2ZzIG9wZXJhdGlvbnMgaW4gZmxpZ2h0IGF0IG9uY2UsIHByb2JhYmx5IGp1c3QgZG9pbmcgZXh0cmEgd29yaycKICAgICAgICAgICk7CiAgICAgICAgfQogICAgICAgIHZhciBtb3VudHMgPSBGUy5nZXRNb3VudHMoRlMucm9vdC5tb3VudCk7CiAgICAgICAgdmFyIGNvbXBsZXRlZCA9IDA7CiAgICAgICAgZnVuY3Rpb24gZG9DYWxsYmFjayhlcnIpIHsKICAgICAgICAgIGFzc2VydChGUy5zeW5jRlNSZXF1ZXN0cyA+IDApOwogICAgICAgICAgRlMuc3luY0ZTUmVxdWVzdHMtLTsKICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpCiAgICAgICAgfQogICAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyKSB7CiAgICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgIGlmICghZG9uZS5lcnJvcmVkKSB7CiAgICAgICAgICAgICAgZG9uZS5lcnJvcmVkID0gdHJ1ZTsKICAgICAgICAgICAgICByZXR1cm4gZG9DYWxsYmFjayhlcnIpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICB9CiAgICAgICAgICBpZiAoKytjb21wbGV0ZWQgPj0gbW91bnRzLmxlbmd0aCkgewogICAgICAgICAgICBkb0NhbGxiYWNrKG51bGwpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBtb3VudHMuZm9yRWFjaChmdW5jdGlvbiAobW91bnQpIHsKICAgICAgICAgIGlmICghbW91bnQudHlwZS5zeW5jZnMpIHsKICAgICAgICAgICAgcmV0dXJuIGRvbmUobnVsbCkKICAgICAgICAgIH0KICAgICAgICAgIG1vdW50LnR5cGUuc3luY2ZzKG1vdW50LCBwb3B1bGF0ZSwgZG9uZSk7CiAgICAgICAgfSk7CiAgICAgIH0sCiAgICAgIG1vdW50OiBmdW5jdGlvbiAodHlwZSwgb3B0cywgbW91bnRwb2ludCkgewogICAgICAgIHZhciByb290ID0gbW91bnRwb2ludCA9PT0gJy8nOwogICAgICAgIHZhciBwc2V1ZG8gPSAhbW91bnRwb2ludDsKICAgICAgICB2YXIgbm9kZTsKICAgICAgICBpZiAocm9vdCAmJiBGUy5yb290KSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQlVTWSkKICAgICAgICB9IGVsc2UgaWYgKCFyb290ICYmICFwc2V1ZG8pIHsKICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKG1vdW50cG9pbnQsIHsgZm9sbG93X21vdW50OiBmYWxzZSB9KTsKICAgICAgICAgIG1vdW50cG9pbnQgPSBsb29rdXAucGF0aDsKICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTsKICAgICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJVU1kpCiAgICAgICAgICB9CiAgICAgICAgICBpZiAoIUZTLmlzRGlyKG5vZGUubW9kZSkpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVERJUikKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdmFyIG1vdW50ID0geyB0eXBlOiB0eXBlLCBvcHRzOiBvcHRzLCBtb3VudHBvaW50OiBtb3VudHBvaW50LCBtb3VudHM6IFtdIH07CiAgICAgICAgdmFyIG1vdW50Um9vdCA9IHR5cGUubW91bnQobW91bnQpOwogICAgICAgIG1vdW50Um9vdC5tb3VudCA9IG1vdW50OwogICAgICAgIG1vdW50LnJvb3QgPSBtb3VudFJvb3Q7CiAgICAgICAgaWYgKHJvb3QpIHsKICAgICAgICAgIEZTLnJvb3QgPSBtb3VudFJvb3Q7CiAgICAgICAgfSBlbHNlIGlmIChub2RlKSB7CiAgICAgICAgICBub2RlLm1vdW50ZWQgPSBtb3VudDsKICAgICAgICAgIGlmIChub2RlLm1vdW50KSB7CiAgICAgICAgICAgIG5vZGUubW91bnQubW91bnRzLnB1c2gobW91bnQpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICByZXR1cm4gbW91bnRSb290CiAgICAgIH0sCiAgICAgIHVubW91bnQ6IGZ1bmN0aW9uIChtb3VudHBvaW50KSB7CiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobW91bnRwb2ludCwgeyBmb2xsb3dfbW91bnQ6IGZhbHNlIH0pOwogICAgICAgIGlmICghRlMuaXNNb3VudHBvaW50KGxvb2t1cC5ub2RlKSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgIH0KICAgICAgICB2YXIgbm9kZSA9IGxvb2t1cC5ub2RlOwogICAgICAgIHZhciBtb3VudCA9IG5vZGUubW91bnRlZDsKICAgICAgICB2YXIgbW91bnRzID0gRlMuZ2V0TW91bnRzKG1vdW50KTsKICAgICAgICBPYmplY3Qua2V5cyhGUy5uYW1lVGFibGUpLmZvckVhY2goZnVuY3Rpb24gKGhhc2gpIHsKICAgICAgICAgIHZhciBjdXJyZW50ID0gRlMubmFtZVRhYmxlW2hhc2hdOwogICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHsKICAgICAgICAgICAgdmFyIG5leHQgPSBjdXJyZW50Lm5hbWVfbmV4dDsKICAgICAgICAgICAgaWYgKG1vdW50cy5pbmRleE9mKGN1cnJlbnQubW91bnQpICE9PSAtMSkgewogICAgICAgICAgICAgIEZTLmRlc3Ryb3lOb2RlKGN1cnJlbnQpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGN1cnJlbnQgPSBuZXh0OwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIG5vZGUubW91bnRlZCA9IG51bGw7CiAgICAgICAgdmFyIGlkeCA9IG5vZGUubW91bnQubW91bnRzLmluZGV4T2YobW91bnQpOwogICAgICAgIGFzc2VydChpZHggIT09IC0xKTsKICAgICAgICBub2RlLm1vdW50Lm1vdW50cy5zcGxpY2UoaWR4LCAxKTsKICAgICAgfSwKICAgICAgbG9va3VwOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lKSB7CiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5sb29rdXAocGFyZW50LCBuYW1lKQogICAgICB9LAogICAgICBta25vZDogZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGRldikgewogICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pOwogICAgICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTsKICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7CiAgICAgICAgaWYgKCFuYW1lIHx8IG5hbWUgPT09ICcuJyB8fCBuYW1lID09PSAnLi4nKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpCiAgICAgICAgfQogICAgICAgIHZhciBlcnIgPSBGUy5tYXlDcmVhdGUocGFyZW50LCBuYW1lKTsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpCiAgICAgICAgfQogICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLm1rbm9kKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSkKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5ta25vZChwYXJlbnQsIG5hbWUsIG1vZGUsIGRldikKICAgICAgfSwKICAgICAgY3JlYXRlOiBmdW5jdGlvbiAocGF0aCwgbW9kZSkgewogICAgICAgIG1vZGUgPSBtb2RlICE9PSB1bmRlZmluZWQgPyBtb2RlIDogNDM4OwogICAgICAgIG1vZGUgJj0gNDA5NTsKICAgICAgICBtb2RlIHw9IDMyNzY4OwogICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCAwKQogICAgICB9LAogICAgICBta2RpcjogZnVuY3Rpb24gKHBhdGgsIG1vZGUpIHsKICAgICAgICBtb2RlID0gbW9kZSAhPT0gdW5kZWZpbmVkID8gbW9kZSA6IDUxMTsKICAgICAgICBtb2RlICY9IDUxMSB8IDUxMjsKICAgICAgICBtb2RlIHw9IDE2Mzg0OwogICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCAwKQogICAgICB9LAogICAgICBta2RpclRyZWU6IGZ1bmN0aW9uIChwYXRoLCBtb2RlKSB7CiAgICAgICAgdmFyIGRpcnMgPSBwYXRoLnNwbGl0KCcvJyk7CiAgICAgICAgdmFyIGQgPSAnJzsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIGlmICghZGlyc1tpXSkgY29udGludWUKICAgICAgICAgIGQgKz0gJy8nICsgZGlyc1tpXTsKICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgIEZTLm1rZGlyKGQsIG1vZGUpOwogICAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgICBpZiAoZS5lcnJubyAhPSBFUlJOT19DT0RFUy5FRVhJU1QpIHRocm93IGUKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0sCiAgICAgIG1rZGV2OiBmdW5jdGlvbiAocGF0aCwgbW9kZSwgZGV2KSB7CiAgICAgICAgaWYgKHR5cGVvZiBkZXYgPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICBkZXYgPSBtb2RlOwogICAgICAgICAgbW9kZSA9IDQzODsKICAgICAgICB9CiAgICAgICAgbW9kZSB8PSA4MTkyOwogICAgICAgIHJldHVybiBGUy5ta25vZChwYXRoLCBtb2RlLCBkZXYpCiAgICAgIH0sCiAgICAgIHN5bWxpbms6IGZ1bmN0aW9uIChvbGRwYXRoLCBuZXdwYXRoKSB7CiAgICAgICAgaWYgKCFQQVRILnJlc29sdmUob2xkcGF0aCkpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0VOVCkKICAgICAgICB9CiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgobmV3cGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7CiAgICAgICAgdmFyIHBhcmVudCA9IGxvb2t1cC5ub2RlOwogICAgICAgIGlmICghcGFyZW50KSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9FTlQpCiAgICAgICAgfQogICAgICAgIHZhciBuZXduYW1lID0gUEFUSC5iYXNlbmFtZShuZXdwYXRoKTsKICAgICAgICB2YXIgZXJyID0gRlMubWF5Q3JlYXRlKHBhcmVudCwgbmV3bmFtZSk7CiAgICAgICAgaWYgKGVycikgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKQogICAgICAgIH0KICAgICAgICBpZiAoIXBhcmVudC5ub2RlX29wcy5zeW1saW5rKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSkKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHBhcmVudC5ub2RlX29wcy5zeW1saW5rKHBhcmVudCwgbmV3bmFtZSwgb2xkcGF0aCkKICAgICAgfSwKICAgICAgcmVuYW1lOiBmdW5jdGlvbiAob2xkX3BhdGgsIG5ld19wYXRoKSB7CiAgICAgICAgdmFyIG9sZF9kaXJuYW1lID0gUEFUSC5kaXJuYW1lKG9sZF9wYXRoKTsKICAgICAgICB2YXIgbmV3X2Rpcm5hbWUgPSBQQVRILmRpcm5hbWUobmV3X3BhdGgpOwogICAgICAgIHZhciBvbGRfbmFtZSA9IFBBVEguYmFzZW5hbWUob2xkX3BhdGgpOwogICAgICAgIHZhciBuZXdfbmFtZSA9IFBBVEguYmFzZW5hbWUobmV3X3BhdGgpOwogICAgICAgIHZhciBsb29rdXAsIG9sZF9kaXIsIG5ld19kaXI7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgob2xkX3BhdGgsIHsgcGFyZW50OiB0cnVlIH0pOwogICAgICAgICAgb2xkX2RpciA9IGxvb2t1cC5ub2RlOwogICAgICAgICAgbG9va3VwID0gRlMubG9va3VwUGF0aChuZXdfcGF0aCwgeyBwYXJlbnQ6IHRydWUgfSk7CiAgICAgICAgICBuZXdfZGlyID0gbG9va3VwLm5vZGU7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJVU1kpCiAgICAgICAgfQogICAgICAgIGlmICghb2xkX2RpciB8fCAhbmV3X2RpcikgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKQogICAgICAgIGlmIChvbGRfZGlyLm1vdW50ICE9PSBuZXdfZGlyLm1vdW50KSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FWERFVikKICAgICAgICB9CiAgICAgICAgdmFyIG9sZF9ub2RlID0gRlMubG9va3VwTm9kZShvbGRfZGlyLCBvbGRfbmFtZSk7CiAgICAgICAgdmFyIHJlbGF0aXZlID0gUEFUSC5yZWxhdGl2ZShvbGRfcGF0aCwgbmV3X2Rpcm5hbWUpOwogICAgICAgIGlmIChyZWxhdGl2ZS5jaGFyQXQoMCkgIT09ICcuJykgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgIH0KICAgICAgICByZWxhdGl2ZSA9IFBBVEgucmVsYXRpdmUobmV3X3BhdGgsIG9sZF9kaXJuYW1lKTsKICAgICAgICBpZiAocmVsYXRpdmUuY2hhckF0KDApICE9PSAnLicpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT1RFTVBUWSkKICAgICAgICB9CiAgICAgICAgdmFyIG5ld19ub2RlOwogICAgICAgIHRyeSB7CiAgICAgICAgICBuZXdfbm9kZSA9IEZTLmxvb2t1cE5vZGUobmV3X2RpciwgbmV3X25hbWUpOwogICAgICAgIH0gY2F0Y2ggKGUpIHt9CiAgICAgICAgaWYgKG9sZF9ub2RlID09PSBuZXdfbm9kZSkgewogICAgICAgICAgcmV0dXJuCiAgICAgICAgfQogICAgICAgIHZhciBpc2RpciA9IEZTLmlzRGlyKG9sZF9ub2RlLm1vZGUpOwogICAgICAgIHZhciBlcnIgPSBGUy5tYXlEZWxldGUob2xkX2Rpciwgb2xkX25hbWUsIGlzZGlyKTsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpCiAgICAgICAgfQogICAgICAgIGVyciA9IG5ld19ub2RlID8gRlMubWF5RGVsZXRlKG5ld19kaXIsIG5ld19uYW1lLCBpc2RpcikgOiBGUy5tYXlDcmVhdGUobmV3X2RpciwgbmV3X25hbWUpOwogICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycikKICAgICAgICB9CiAgICAgICAgaWYgKCFvbGRfZGlyLm5vZGVfb3BzLnJlbmFtZSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pCiAgICAgICAgfQogICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQob2xkX25vZGUpIHx8IChuZXdfbm9kZSAmJiBGUy5pc01vdW50cG9pbnQobmV3X25vZGUpKSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJVU1kpCiAgICAgICAgfQogICAgICAgIGlmIChuZXdfZGlyICE9PSBvbGRfZGlyKSB7CiAgICAgICAgICBlcnIgPSBGUy5ub2RlUGVybWlzc2lvbnMob2xkX2RpciwgJ3cnKTsKICAgICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyKQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0cnkgewogICAgICAgICAgaWYgKEZTLnRyYWNraW5nRGVsZWdhdGVbJ3dpbGxNb3ZlUGF0aCddKSA7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgY29uc29sZS5sb2coCiAgICAgICAgICAgICJGUy50cmFja2luZ0RlbGVnYXRlWyd3aWxsTW92ZVBhdGgnXSgnIiArIG9sZF9wYXRoICsgIicsICciICsgbmV3X3BhdGggKyAiJykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiICsgZS5tZXNzYWdlCiAgICAgICAgICApOwogICAgICAgIH0KICAgICAgICBGUy5oYXNoUmVtb3ZlTm9kZShvbGRfbm9kZSk7CiAgICAgICAgdHJ5IHsKICAgICAgICAgIG9sZF9kaXIubm9kZV9vcHMucmVuYW1lKG9sZF9ub2RlLCBuZXdfZGlyLCBuZXdfbmFtZSk7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgdGhyb3cgZQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBGUy5oYXNoQWRkTm9kZShvbGRfbm9kZSk7CiAgICAgICAgfQogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25Nb3ZlUGF0aCddKSA7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgY29uc29sZS5sb2coCiAgICAgICAgICAgICJGUy50cmFja2luZ0RlbGVnYXRlWydvbk1vdmVQYXRoJ10oJyIgKyBvbGRfcGF0aCArICInLCAnIiArIG5ld19wYXRoICsgIicpIHRocmV3IGFuIGV4Y2VwdGlvbjogIiArIGUubWVzc2FnZQogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgIH0sCiAgICAgIHJtZGlyOiBmdW5jdGlvbiAocGF0aCkgewogICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pOwogICAgICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTsKICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7CiAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7CiAgICAgICAgdmFyIGVyciA9IEZTLm1heURlbGV0ZShwYXJlbnQsIG5hbWUsIHRydWUpOwogICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycikKICAgICAgICB9CiAgICAgICAgaWYgKCFwYXJlbnQubm9kZV9vcHMucm1kaXIpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKQogICAgICAgIH0KICAgICAgICBpZiAoRlMuaXNNb3VudHBvaW50KG5vZGUpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQlVTWSkKICAgICAgICB9CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmIChGUy50cmFja2luZ0RlbGVnYXRlWyd3aWxsRGVsZXRlUGF0aCddKSA7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgY29uc29sZS5sb2coIkZTLnRyYWNraW5nRGVsZWdhdGVbJ3dpbGxEZWxldGVQYXRoJ10oJyIgKyBwYXRoICsgIicpIHRocmV3IGFuIGV4Y2VwdGlvbjogIiArIGUubWVzc2FnZSk7CiAgICAgICAgfQogICAgICAgIHBhcmVudC5ub2RlX29wcy5ybWRpcihwYXJlbnQsIG5hbWUpOwogICAgICAgIEZTLmRlc3Ryb3lOb2RlKG5vZGUpOwogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25EZWxldGVQYXRoJ10pIDsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICBjb25zb2xlLmxvZygiRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25EZWxldGVQYXRoJ10oJyIgKyBwYXRoICsgIicpIHRocmV3IGFuIGV4Y2VwdGlvbjogIiArIGUubWVzc2FnZSk7CiAgICAgICAgfQogICAgICB9LAogICAgICByZWFkZGlyOiBmdW5jdGlvbiAocGF0aCkgewogICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiB0cnVlIH0pOwogICAgICAgIHZhciBub2RlID0gbG9va3VwLm5vZGU7CiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnJlYWRkaXIpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT1RESVIpCiAgICAgICAgfQogICAgICAgIHJldHVybiBub2RlLm5vZGVfb3BzLnJlYWRkaXIobm9kZSkKICAgICAgfSwKICAgICAgdW5saW5rOiBmdW5jdGlvbiAocGF0aCkgewogICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pOwogICAgICAgIHZhciBwYXJlbnQgPSBsb29rdXAubm9kZTsKICAgICAgICB2YXIgbmFtZSA9IFBBVEguYmFzZW5hbWUocGF0aCk7CiAgICAgICAgdmFyIG5vZGUgPSBGUy5sb29rdXBOb2RlKHBhcmVudCwgbmFtZSk7CiAgICAgICAgdmFyIGVyciA9IEZTLm1heURlbGV0ZShwYXJlbnQsIG5hbWUsIGZhbHNlKTsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpCiAgICAgICAgfQogICAgICAgIGlmICghcGFyZW50Lm5vZGVfb3BzLnVubGluaykgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pCiAgICAgICAgfQogICAgICAgIGlmIChGUy5pc01vdW50cG9pbnQobm9kZSkpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCVVNZKQogICAgICAgIH0KICAgICAgICB0cnkgewogICAgICAgICAgaWYgKEZTLnRyYWNraW5nRGVsZWdhdGVbJ3dpbGxEZWxldGVQYXRoJ10pIDsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICBjb25zb2xlLmxvZygiRlMudHJhY2tpbmdEZWxlZ2F0ZVsnd2lsbERlbGV0ZVBhdGgnXSgnIiArIHBhdGggKyAiJykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiICsgZS5tZXNzYWdlKTsKICAgICAgICB9CiAgICAgICAgcGFyZW50Lm5vZGVfb3BzLnVubGluayhwYXJlbnQsIG5hbWUpOwogICAgICAgIEZTLmRlc3Ryb3lOb2RlKG5vZGUpOwogICAgICAgIHRyeSB7CiAgICAgICAgICBpZiAoRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25EZWxldGVQYXRoJ10pIDsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICBjb25zb2xlLmxvZygiRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25EZWxldGVQYXRoJ10oJyIgKyBwYXRoICsgIicpIHRocmV3IGFuIGV4Y2VwdGlvbjogIiArIGUubWVzc2FnZSk7CiAgICAgICAgfQogICAgICB9LAogICAgICByZWFkbGluazogZnVuY3Rpb24gKHBhdGgpIHsKICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoKTsKICAgICAgICB2YXIgbGluayA9IGxvb2t1cC5ub2RlOwogICAgICAgIGlmICghbGluaykgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKQogICAgICAgIH0KICAgICAgICBpZiAoIWxpbmsubm9kZV9vcHMucmVhZGxpbmspIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCkKICAgICAgICB9CiAgICAgICAgcmV0dXJuIFBBVEgucmVzb2x2ZShGUy5nZXRQYXRoKGxpbmsucGFyZW50KSwgbGluay5ub2RlX29wcy5yZWFkbGluayhsaW5rKSkKICAgICAgfSwKICAgICAgc3RhdDogZnVuY3Rpb24gKHBhdGgsIGRvbnRGb2xsb3cpIHsKICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRGb2xsb3cgfSk7CiAgICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTsKICAgICAgICBpZiAoIW5vZGUpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0VOVCkKICAgICAgICB9CiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLmdldGF0dHIpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKQogICAgICAgIH0KICAgICAgICByZXR1cm4gbm9kZS5ub2RlX29wcy5nZXRhdHRyKG5vZGUpCiAgICAgIH0sCiAgICAgIGxzdGF0OiBmdW5jdGlvbiAocGF0aCkgewogICAgICAgIHJldHVybiBGUy5zdGF0KHBhdGgsIHRydWUpCiAgICAgIH0sCiAgICAgIGNobW9kOiBmdW5jdGlvbiAocGF0aCwgbW9kZSwgZG9udEZvbGxvdykgewogICAgICAgIHZhciBub2RlOwogICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHsKICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgZm9sbG93OiAhZG9udEZvbGxvdyB9KTsKICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbm9kZSA9IHBhdGg7CiAgICAgICAgfQogICAgICAgIGlmICghbm9kZS5ub2RlX29wcy5zZXRhdHRyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FUEVSTSkKICAgICAgICB9CiAgICAgICAgbm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUsIHsgbW9kZTogKG1vZGUgJiA0MDk1KSB8IChub2RlLm1vZGUgJiB+NDA5NSksIHRpbWVzdGFtcDogRGF0ZS5ub3coKSB9KTsKICAgICAgfSwKICAgICAgbGNobW9kOiBmdW5jdGlvbiAocGF0aCwgbW9kZSkgewogICAgICAgIEZTLmNobW9kKHBhdGgsIG1vZGUsIHRydWUpOwogICAgICB9LAogICAgICBmY2htb2Q6IGZ1bmN0aW9uIChmZCwgbW9kZSkgewogICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpOwogICAgICAgIGlmICghc3RyZWFtKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERikKICAgICAgICB9CiAgICAgICAgRlMuY2htb2Qoc3RyZWFtLm5vZGUsIG1vZGUpOwogICAgICB9LAogICAgICBjaG93bjogZnVuY3Rpb24gKHBhdGgsIHVpZCwgZ2lkLCBkb250Rm9sbG93KSB7CiAgICAgICAgdmFyIG5vZGU7CiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgewogICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250Rm9sbG93IH0pOwogICAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBub2RlID0gcGF0aDsKICAgICAgICB9CiAgICAgICAgaWYgKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVQRVJNKQogICAgICAgIH0KICAgICAgICBub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSwgeyB0aW1lc3RhbXA6IERhdGUubm93KCkgfSk7CiAgICAgIH0sCiAgICAgIGxjaG93bjogZnVuY3Rpb24gKHBhdGgsIHVpZCwgZ2lkKSB7CiAgICAgICAgRlMuY2hvd24ocGF0aCwgdWlkLCBnaWQsIHRydWUpOwogICAgICB9LAogICAgICBmY2hvd246IGZ1bmN0aW9uIChmZCwgdWlkLCBnaWQpIHsKICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTsKICAgICAgICBpZiAoIXN0cmVhbSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpCiAgICAgICAgfQogICAgICAgIEZTLmNob3duKHN0cmVhbS5ub2RlLCB1aWQsIGdpZCk7CiAgICAgIH0sCiAgICAgIHRydW5jYXRlOiBmdW5jdGlvbiAocGF0aCwgbGVuKSB7CiAgICAgICAgaWYgKGxlbiA8IDApIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCkKICAgICAgICB9CiAgICAgICAgdmFyIG5vZGU7CiAgICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgewogICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7CiAgICAgICAgICBub2RlID0gbG9va3VwLm5vZGU7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIG5vZGUgPSBwYXRoOwogICAgICAgIH0KICAgICAgICBpZiAoIW5vZGUubm9kZV9vcHMuc2V0YXR0cikgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVBFUk0pCiAgICAgICAgfQogICAgICAgIGlmIChGUy5pc0Rpcihub2RlLm1vZGUpKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSVNESVIpCiAgICAgICAgfQogICAgICAgIGlmICghRlMuaXNGaWxlKG5vZGUubW9kZSkpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCkKICAgICAgICB9CiAgICAgICAgdmFyIGVyciA9IEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLCAndycpOwogICAgICAgIGlmIChlcnIpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycikKICAgICAgICB9CiAgICAgICAgbm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUsIHsgc2l6ZTogbGVuLCB0aW1lc3RhbXA6IERhdGUubm93KCkgfSk7CiAgICAgIH0sCiAgICAgIGZ0cnVuY2F0ZTogZnVuY3Rpb24gKGZkLCBsZW4pIHsKICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGZkKTsKICAgICAgICBpZiAoIXN0cmVhbSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpCiAgICAgICAgfQogICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTlZBTCkKICAgICAgICB9CiAgICAgICAgRlMudHJ1bmNhdGUoc3RyZWFtLm5vZGUsIGxlbik7CiAgICAgIH0sCiAgICAgIHV0aW1lOiBmdW5jdGlvbiAocGF0aCwgYXRpbWUsIG10aW1lKSB7CiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7CiAgICAgICAgdmFyIG5vZGUgPSBsb29rdXAubm9kZTsKICAgICAgICBub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSwgeyB0aW1lc3RhbXA6IE1hdGgubWF4KGF0aW1lLCBtdGltZSkgfSk7CiAgICAgIH0sCiAgICAgIG9wZW46IGZ1bmN0aW9uIChwYXRoLCBmbGFncywgbW9kZSwgZmRfc3RhcnQsIGZkX2VuZCkgewogICAgICAgIGlmIChwYXRoID09PSAnJykgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PRU5UKQogICAgICAgIH0KICAgICAgICBmbGFncyA9IHR5cGVvZiBmbGFncyA9PT0gJ3N0cmluZycgPyBGUy5tb2RlU3RyaW5nVG9GbGFncyhmbGFncykgOiBmbGFnczsKICAgICAgICBtb2RlID0gdHlwZW9mIG1vZGUgPT09ICd1bmRlZmluZWQnID8gNDM4IDogbW9kZTsKICAgICAgICBpZiAoZmxhZ3MgJiA2NCkgewogICAgICAgICAgbW9kZSA9IChtb2RlICYgNDA5NSkgfCAzMjc2ODsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgbW9kZSA9IDA7CiAgICAgICAgfQogICAgICAgIHZhciBub2RlOwogICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ29iamVjdCcpIHsKICAgICAgICAgIG5vZGUgPSBwYXRoOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBwYXRoID0gUEFUSC5ub3JtYWxpemUocGF0aCk7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIShmbGFncyAmIDEzMTA3MikgfSk7CiAgICAgICAgICAgIG5vZGUgPSBsb29rdXAubm9kZTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9CiAgICAgICAgfQogICAgICAgIHZhciBjcmVhdGVkID0gZmFsc2U7CiAgICAgICAgaWYgKGZsYWdzICYgNjQpIHsKICAgICAgICAgIGlmIChub2RlKSB7CiAgICAgICAgICAgIGlmIChmbGFncyAmIDEyOCkgewogICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVFWElTVCkKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgbm9kZSA9IEZTLm1rbm9kKHBhdGgsIG1vZGUsIDApOwogICAgICAgICAgICBjcmVhdGVkID0gdHJ1ZTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKCFub2RlKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9FTlQpCiAgICAgICAgfQogICAgICAgIGlmIChGUy5pc0NocmRldihub2RlLm1vZGUpKSB7CiAgICAgICAgICBmbGFncyAmPSB+NTEyOwogICAgICAgIH0KICAgICAgICBpZiAoZmxhZ3MgJiA2NTUzNiAmJiAhRlMuaXNEaXIobm9kZS5tb2RlKSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVERJUikKICAgICAgICB9CiAgICAgICAgaWYgKCFjcmVhdGVkKSB7CiAgICAgICAgICB2YXIgZXJyID0gRlMubWF5T3Blbihub2RlLCBmbGFncyk7CiAgICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKGVycikKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgaWYgKGZsYWdzICYgNTEyKSB7CiAgICAgICAgICBGUy50cnVuY2F0ZShub2RlLCAwKTsKICAgICAgICB9CiAgICAgICAgZmxhZ3MgJj0gfigxMjggfCA1MTIpOwogICAgICAgIHZhciBzdHJlYW0gPSBGUy5jcmVhdGVTdHJlYW0oCiAgICAgICAgICB7CiAgICAgICAgICAgIG5vZGU6IG5vZGUsCiAgICAgICAgICAgIHBhdGg6IEZTLmdldFBhdGgobm9kZSksCiAgICAgICAgICAgIGZsYWdzOiBmbGFncywKICAgICAgICAgICAgc2Vla2FibGU6IHRydWUsCiAgICAgICAgICAgIHBvc2l0aW9uOiAwLAogICAgICAgICAgICBzdHJlYW1fb3BzOiBub2RlLnN0cmVhbV9vcHMsCiAgICAgICAgICAgIHVuZ290dGVuOiBbXSwKICAgICAgICAgICAgZXJyb3I6IGZhbHNlLAogICAgICAgICAgfSwKICAgICAgICAgIGZkX3N0YXJ0LAogICAgICAgICAgZmRfZW5kCiAgICAgICAgKTsKICAgICAgICBpZiAoc3RyZWFtLnN0cmVhbV9vcHMub3BlbikgewogICAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMub3BlbihzdHJlYW0pOwogICAgICAgIH0KICAgICAgICBpZiAoTW9kdWxlWydsb2dSZWFkRmlsZXMnXSAmJiAhKGZsYWdzICYgMSkpIHsKICAgICAgICAgIGlmICghRlMucmVhZEZpbGVzKSBGUy5yZWFkRmlsZXMgPSB7fTsKICAgICAgICAgIGlmICghKHBhdGggaW4gRlMucmVhZEZpbGVzKSkgewogICAgICAgICAgICBGUy5yZWFkRmlsZXNbcGF0aF0gPSAxOwogICAgICAgICAgICBNb2R1bGVbJ3ByaW50RXJyJ10oJ3JlYWQgZmlsZTogJyArIHBhdGgpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICB0cnkgewogICAgICAgICAgdmFyIHRyYWNraW5nRmxhZ3M7IGlmIChGUy50cmFja2luZ0RlbGVnYXRlWydvbk9wZW5GaWxlJ10pIDsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICBjb25zb2xlLmxvZygiRlMudHJhY2tpbmdEZWxlZ2F0ZVsnb25PcGVuRmlsZSddKCciICsgcGF0aCArICInLCBmbGFncykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiICsgZS5tZXNzYWdlKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHN0cmVhbQogICAgICB9LAogICAgICBjbG9zZTogZnVuY3Rpb24gKHN0cmVhbSkgewogICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERikKICAgICAgICB9CiAgICAgICAgaWYgKHN0cmVhbS5nZXRkZW50cykgc3RyZWFtLmdldGRlbnRzID0gbnVsbDsKICAgICAgICB0cnkgewogICAgICAgICAgaWYgKHN0cmVhbS5zdHJlYW1fb3BzLmNsb3NlKSB7CiAgICAgICAgICAgIHN0cmVhbS5zdHJlYW1fb3BzLmNsb3NlKHN0cmVhbSk7CiAgICAgICAgICB9CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgdGhyb3cgZQogICAgICAgIH0gZmluYWxseSB7CiAgICAgICAgICBGUy5jbG9zZVN0cmVhbShzdHJlYW0uZmQpOwogICAgICAgIH0KICAgICAgICBzdHJlYW0uZmQgPSBudWxsOwogICAgICB9LAogICAgICBpc0Nsb3NlZDogZnVuY3Rpb24gKHN0cmVhbSkgewogICAgICAgIHJldHVybiBzdHJlYW0uZmQgPT09IG51bGwKICAgICAgfSwKICAgICAgbGxzZWVrOiBmdW5jdGlvbiAoc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSkgewogICAgICAgIGlmIChGUy5pc0Nsb3NlZChzdHJlYW0pKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERikKICAgICAgICB9CiAgICAgICAgaWYgKCFzdHJlYW0uc2Vla2FibGUgfHwgIXN0cmVhbS5zdHJlYW1fb3BzLmxsc2VlaykgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVNQSVBFKQogICAgICAgIH0KICAgICAgICBzdHJlYW0ucG9zaXRpb24gPSBzdHJlYW0uc3RyZWFtX29wcy5sbHNlZWsoc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSk7CiAgICAgICAgc3RyZWFtLnVuZ290dGVuID0gW107CiAgICAgICAgcmV0dXJuIHN0cmVhbS5wb3NpdGlvbgogICAgICB9LAogICAgICByZWFkOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgewogICAgICAgIGlmIChsZW5ndGggPCAwIHx8IHBvc2l0aW9uIDwgMCkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgIH0KICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpCiAgICAgICAgfQogICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDEpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKQogICAgICAgIH0KICAgICAgICBpZiAoRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJU0RJUikKICAgICAgICB9CiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5yZWFkKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpCiAgICAgICAgfQogICAgICAgIHZhciBzZWVraW5nID0gdHlwZW9mIHBvc2l0aW9uICE9PSAndW5kZWZpbmVkJzsKICAgICAgICBpZiAoIXNlZWtpbmcpIHsKICAgICAgICAgIHBvc2l0aW9uID0gc3RyZWFtLnBvc2l0aW9uOwogICAgICAgIH0gZWxzZSBpZiAoIXN0cmVhbS5zZWVrYWJsZSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVNQSVBFKQogICAgICAgIH0KICAgICAgICB2YXIgYnl0ZXNSZWFkID0gc3RyZWFtLnN0cmVhbV9vcHMucmVhZChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uKTsKICAgICAgICBpZiAoIXNlZWtpbmcpIHN0cmVhbS5wb3NpdGlvbiArPSBieXRlc1JlYWQ7CiAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZAogICAgICB9LAogICAgICB3cml0ZTogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIGNhbk93bikgewogICAgICAgIGlmIChsZW5ndGggPCAwIHx8IHBvc2l0aW9uIDwgMCkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgIH0KICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpCiAgICAgICAgfQogICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKQogICAgICAgIH0KICAgICAgICBpZiAoRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJU0RJUikKICAgICAgICB9CiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy53cml0ZSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUlOVkFMKQogICAgICAgIH0KICAgICAgICBpZiAoc3RyZWFtLmZsYWdzICYgMTAyNCkgewogICAgICAgICAgRlMubGxzZWVrKHN0cmVhbSwgMCwgMik7CiAgICAgICAgfQogICAgICAgIHZhciBzZWVraW5nID0gdHlwZW9mIHBvc2l0aW9uICE9PSAndW5kZWZpbmVkJzsKICAgICAgICBpZiAoIXNlZWtpbmcpIHsKICAgICAgICAgIHBvc2l0aW9uID0gc3RyZWFtLnBvc2l0aW9uOwogICAgICAgIH0gZWxzZSBpZiAoIXN0cmVhbS5zZWVrYWJsZSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRVNQSVBFKQogICAgICAgIH0KICAgICAgICB2YXIgYnl0ZXNXcml0dGVuID0gc3RyZWFtLnN0cmVhbV9vcHMud3JpdGUoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbiwgY2FuT3duKTsKICAgICAgICBpZiAoIXNlZWtpbmcpIHN0cmVhbS5wb3NpdGlvbiArPSBieXRlc1dyaXR0ZW47CiAgICAgICAgdHJ5IHsKICAgICAgICAgIGlmIChzdHJlYW0ucGF0aCAmJiBGUy50cmFja2luZ0RlbGVnYXRlWydvbldyaXRlVG9GaWxlJ10pIEZTLnRyYWNraW5nRGVsZWdhdGVbJ29uV3JpdGVUb0ZpbGUnXShzdHJlYW0ucGF0aCk7CiAgICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgICAgY29uc29sZS5sb2coIkZTLnRyYWNraW5nRGVsZWdhdGVbJ29uV3JpdGVUb0ZpbGUnXSgnIiArIHBhdGggKyAiJykgdGhyZXcgYW4gZXhjZXB0aW9uOiAiICsgZS5tZXNzYWdlKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIGJ5dGVzV3JpdHRlbgogICAgICB9LAogICAgICBhbGxvY2F0ZTogZnVuY3Rpb24gKHN0cmVhbSwgb2Zmc2V0LCBsZW5ndGgpIHsKICAgICAgICBpZiAoRlMuaXNDbG9zZWQoc3RyZWFtKSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpCiAgICAgICAgfQogICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IGxlbmd0aCA8PSAwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU5WQUwpCiAgICAgICAgfQogICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDApIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKQogICAgICAgIH0KICAgICAgICBpZiAoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSAmJiAhRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0RFVikKICAgICAgICB9CiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5hbGxvY2F0ZSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU9QTk9UU1VQUCkKICAgICAgICB9CiAgICAgICAgc3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUoc3RyZWFtLCBvZmZzZXQsIGxlbmd0aCk7CiAgICAgIH0sCiAgICAgIG1tYXA6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvc2l0aW9uLCBwcm90LCBmbGFncykgewogICAgICAgIGlmICgoc3RyZWFtLmZsYWdzICYgMjA5NzE1NSkgPT09IDEpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVBQ0NFUykKICAgICAgICB9CiAgICAgICAgaWYgKCFzdHJlYW0uc3RyZWFtX29wcy5tbWFwKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FTk9ERVYpCiAgICAgICAgfQogICAgICAgIHJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5tbWFwKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zaXRpb24sIHByb3QsIGZsYWdzKQogICAgICB9LAogICAgICBtc3luYzogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgbW1hcEZsYWdzKSB7CiAgICAgICAgaWYgKCFzdHJlYW0gfHwgIXN0cmVhbS5zdHJlYW1fb3BzLm1zeW5jKSB7CiAgICAgICAgICByZXR1cm4gMAogICAgICAgIH0KICAgICAgICByZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBtbWFwRmxhZ3MpCiAgICAgIH0sCiAgICAgIG11bm1hcDogZnVuY3Rpb24gKHN0cmVhbSkgewogICAgICAgIHJldHVybiAwCiAgICAgIH0sCiAgICAgIGlvY3RsOiBmdW5jdGlvbiAoc3RyZWFtLCBjbWQsIGFyZykgewogICAgICAgIGlmICghc3RyZWFtLnN0cmVhbV9vcHMuaW9jdGwpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT1RUWSkKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHN0cmVhbS5zdHJlYW1fb3BzLmlvY3RsKHN0cmVhbSwgY21kLCBhcmcpCiAgICAgIH0sCiAgICAgIHJlYWRGaWxlOiBmdW5jdGlvbiAocGF0aCwgb3B0cykgewogICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9OwogICAgICAgIG9wdHMuZmxhZ3MgPSBvcHRzLmZsYWdzIHx8ICdyJzsKICAgICAgICBvcHRzLmVuY29kaW5nID0gb3B0cy5lbmNvZGluZyB8fCAnYmluYXJ5JzsKICAgICAgICBpZiAob3B0cy5lbmNvZGluZyAhPT0gJ3V0ZjgnICYmIG9wdHMuZW5jb2RpbmcgIT09ICdiaW5hcnknKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZW5jb2RpbmcgdHlwZSAiJyArIG9wdHMuZW5jb2RpbmcgKyAnIicpCiAgICAgICAgfQogICAgICAgIHZhciByZXQ7CiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4ocGF0aCwgb3B0cy5mbGFncyk7CiAgICAgICAgdmFyIHN0YXQgPSBGUy5zdGF0KHBhdGgpOwogICAgICAgIHZhciBsZW5ndGggPSBzdGF0LnNpemU7CiAgICAgICAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7CiAgICAgICAgRlMucmVhZChzdHJlYW0sIGJ1ZiwgMCwgbGVuZ3RoLCAwKTsKICAgICAgICBpZiAob3B0cy5lbmNvZGluZyA9PT0gJ3V0ZjgnKSB7CiAgICAgICAgICByZXQgPSBVVEY4QXJyYXlUb1N0cmluZyhidWYsIDApOwogICAgICAgIH0gZWxzZSBpZiAob3B0cy5lbmNvZGluZyA9PT0gJ2JpbmFyeScpIHsKICAgICAgICAgIHJldCA9IGJ1ZjsKICAgICAgICB9CiAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTsKICAgICAgICByZXR1cm4gcmV0CiAgICAgIH0sCiAgICAgIHdyaXRlRmlsZTogZnVuY3Rpb24gKHBhdGgsIGRhdGEsIG9wdHMpIHsKICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTsKICAgICAgICBvcHRzLmZsYWdzID0gb3B0cy5mbGFncyB8fCAndyc7CiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4ocGF0aCwgb3B0cy5mbGFncywgb3B0cy5tb2RlKTsKICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoQnl0ZXNVVEY4KGRhdGEpICsgMSk7CiAgICAgICAgICB2YXIgYWN0dWFsTnVtQnl0ZXMgPSBzdHJpbmdUb1VURjhBcnJheShkYXRhLCBidWYsIDAsIGJ1Zi5sZW5ndGgpOwogICAgICAgICAgRlMud3JpdGUoc3RyZWFtLCBidWYsIDAsIGFjdHVhbE51bUJ5dGVzLCB1bmRlZmluZWQsIG9wdHMuY2FuT3duKTsKICAgICAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkgewogICAgICAgICAgRlMud3JpdGUoc3RyZWFtLCBkYXRhLCAwLCBkYXRhLmJ5dGVMZW5ndGgsIHVuZGVmaW5lZCwgb3B0cy5jYW5Pd24pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGRhdGEgdHlwZScpCiAgICAgICAgfQogICAgICAgIEZTLmNsb3NlKHN0cmVhbSk7CiAgICAgIH0sCiAgICAgIGN3ZDogZnVuY3Rpb24gKCkgewogICAgICAgIHJldHVybiBGUy5jdXJyZW50UGF0aAogICAgICB9LAogICAgICBjaGRpcjogZnVuY3Rpb24gKHBhdGgpIHsKICAgICAgICB2YXIgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogdHJ1ZSB9KTsKICAgICAgICBpZiAobG9va3VwLm5vZGUgPT09IG51bGwpIHsKICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVOT0VOVCkKICAgICAgICB9CiAgICAgICAgaWYgKCFGUy5pc0Rpcihsb29rdXAubm9kZS5tb2RlKSkgewogICAgICAgICAgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRU5PVERJUikKICAgICAgICB9CiAgICAgICAgdmFyIGVyciA9IEZTLm5vZGVQZXJtaXNzaW9ucyhsb29rdXAubm9kZSwgJ3gnKTsKICAgICAgICBpZiAoZXJyKSB7CiAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnIpCiAgICAgICAgfQogICAgICAgIEZTLmN1cnJlbnRQYXRoID0gbG9va3VwLnBhdGg7CiAgICAgIH0sCiAgICAgIGNyZWF0ZURlZmF1bHREaXJlY3RvcmllczogZnVuY3Rpb24gKCkgewogICAgICAgIEZTLm1rZGlyKCcvdG1wJyk7CiAgICAgICAgRlMubWtkaXIoJy9ob21lJyk7CiAgICAgICAgRlMubWtkaXIoJy9ob21lL3dlYl91c2VyJyk7CiAgICAgIH0sCiAgICAgIGNyZWF0ZURlZmF1bHREZXZpY2VzOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgRlMubWtkaXIoJy9kZXYnKTsKICAgICAgICBGUy5yZWdpc3RlckRldmljZShGUy5tYWtlZGV2KDEsIDMpLCB7CiAgICAgICAgICByZWFkOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIHJldHVybiAwCiAgICAgICAgICB9LAogICAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIChzdHJlYW0sIGJ1ZmZlciwgb2Zmc2V0LCBsZW5ndGgsIHBvcykgewogICAgICAgICAgICByZXR1cm4gbGVuZ3RoCiAgICAgICAgICB9LAogICAgICAgIH0pOwogICAgICAgIEZTLm1rZGV2KCcvZGV2L251bGwnLCBGUy5tYWtlZGV2KDEsIDMpKTsKICAgICAgICBUVFkucmVnaXN0ZXIoRlMubWFrZWRldig1LCAwKSwgVFRZLmRlZmF1bHRfdHR5X29wcyk7CiAgICAgICAgVFRZLnJlZ2lzdGVyKEZTLm1ha2VkZXYoNiwgMCksIFRUWS5kZWZhdWx0X3R0eTFfb3BzKTsKICAgICAgICBGUy5ta2RldignL2Rldi90dHknLCBGUy5tYWtlZGV2KDUsIDApKTsKICAgICAgICBGUy5ta2RldignL2Rldi90dHkxJywgRlMubWFrZWRldig2LCAwKSk7CiAgICAgICAgdmFyIHJhbmRvbV9kZXZpY2U7CiAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICB2YXIgcmFuZG9tQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7CiAgICAgICAgICByYW5kb21fZGV2aWNlID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJhbmRvbUJ1ZmZlcik7CiAgICAgICAgICAgIHJldHVybiByYW5kb21CdWZmZXJbMF0KICAgICAgICAgIH07CiAgICAgICAgfSBlbHNlIGlmIChFTlZJUk9OTUVOVF9JU19OT0RFKSB7CiAgICAgICAgICByYW5kb21fZGV2aWNlID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgICByZXR1cm4gcmVxdWlyZSgnY3J5cHRvJylbJ3JhbmRvbUJ5dGVzJ10oMSlbMF0KICAgICAgICAgIH07CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJhbmRvbV9kZXZpY2UgPSBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgIHJldHVybiAoTWF0aC5yYW5kb20oKSAqIDI1NikgfCAwCiAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAncmFuZG9tJywgcmFuZG9tX2RldmljZSk7CiAgICAgICAgRlMuY3JlYXRlRGV2aWNlKCcvZGV2JywgJ3VyYW5kb20nLCByYW5kb21fZGV2aWNlKTsKICAgICAgICBGUy5ta2RpcignL2Rldi9zaG0nKTsKICAgICAgICBGUy5ta2RpcignL2Rldi9zaG0vdG1wJyk7CiAgICAgIH0sCiAgICAgIGNyZWF0ZVNwZWNpYWxEaXJlY3RvcmllczogZnVuY3Rpb24gKCkgewogICAgICAgIEZTLm1rZGlyKCcvcHJvYycpOwogICAgICAgIEZTLm1rZGlyKCcvcHJvYy9zZWxmJyk7CiAgICAgICAgRlMubWtkaXIoJy9wcm9jL3NlbGYvZmQnKTsKICAgICAgICBGUy5tb3VudCgKICAgICAgICAgIHsKICAgICAgICAgICAgbW91bnQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZU5vZGUoJy9wcm9jL3NlbGYnLCAnZmQnLCAxNjM4NCB8IDUxMSwgNzMpOwogICAgICAgICAgICAgIG5vZGUubm9kZV9vcHMgPSB7CiAgICAgICAgICAgICAgICBsb29rdXA6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUpIHsKICAgICAgICAgICAgICAgICAgdmFyIGZkID0gK25hbWU7CiAgICAgICAgICAgICAgICAgIHZhciBzdHJlYW0gPSBGUy5nZXRTdHJlYW0oZmQpOwogICAgICAgICAgICAgICAgICBpZiAoIXN0cmVhbSkgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoRVJSTk9fQ09ERVMuRUJBREYpCiAgICAgICAgICAgICAgICAgIHZhciByZXQgPSB7CiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLAogICAgICAgICAgICAgICAgICAgIG1vdW50OiB7IG1vdW50cG9pbnQ6ICdmYWtlJyB9LAogICAgICAgICAgICAgICAgICAgIG5vZGVfb3BzOiB7CiAgICAgICAgICAgICAgICAgICAgICByZWFkbGluazogZnVuY3Rpb24gKCkgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyZWFtLnBhdGgKICAgICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgcmV0LnBhcmVudCA9IHJldDsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldAogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIHJldHVybiBub2RlCiAgICAgICAgICAgIH0sCiAgICAgICAgICB9LAogICAgICAgICAge30sCiAgICAgICAgICAnL3Byb2Mvc2VsZi9mZCcKICAgICAgICApOwogICAgICB9LAogICAgICBjcmVhdGVTdGFuZGFyZFN0cmVhbXM6IGZ1bmN0aW9uICgpIHsKICAgICAgICBpZiAoTW9kdWxlWydzdGRpbiddKSB7CiAgICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAnc3RkaW4nLCBNb2R1bGVbJ3N0ZGluJ10pOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBGUy5zeW1saW5rKCcvZGV2L3R0eScsICcvZGV2L3N0ZGluJyk7CiAgICAgICAgfQogICAgICAgIGlmIChNb2R1bGVbJ3N0ZG91dCddKSB7CiAgICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAnc3Rkb3V0JywgbnVsbCwgTW9kdWxlWydzdGRvdXQnXSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5JywgJy9kZXYvc3Rkb3V0Jyk7CiAgICAgICAgfQogICAgICAgIGlmIChNb2R1bGVbJ3N0ZGVyciddKSB7CiAgICAgICAgICBGUy5jcmVhdGVEZXZpY2UoJy9kZXYnLCAnc3RkZXJyJywgbnVsbCwgTW9kdWxlWydzdGRlcnInXSk7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIEZTLnN5bWxpbmsoJy9kZXYvdHR5MScsICcvZGV2L3N0ZGVycicpOwogICAgICAgIH0KICAgICAgICB2YXIgc3RkaW4gPSBGUy5vcGVuKCcvZGV2L3N0ZGluJywgJ3InKTsKICAgICAgICBhc3NlcnQoc3RkaW4uZmQgPT09IDAsICdpbnZhbGlkIGhhbmRsZSBmb3Igc3RkaW4gKCcgKyBzdGRpbi5mZCArICcpJyk7CiAgICAgICAgdmFyIHN0ZG91dCA9IEZTLm9wZW4oJy9kZXYvc3Rkb3V0JywgJ3cnKTsKICAgICAgICBhc3NlcnQoc3Rkb3V0LmZkID09PSAxLCAnaW52YWxpZCBoYW5kbGUgZm9yIHN0ZG91dCAoJyArIHN0ZG91dC5mZCArICcpJyk7CiAgICAgICAgdmFyIHN0ZGVyciA9IEZTLm9wZW4oJy9kZXYvc3RkZXJyJywgJ3cnKTsKICAgICAgICBhc3NlcnQoc3RkZXJyLmZkID09PSAyLCAnaW52YWxpZCBoYW5kbGUgZm9yIHN0ZGVyciAoJyArIHN0ZGVyci5mZCArICcpJyk7CiAgICAgIH0sCiAgICAgIGVuc3VyZUVycm5vRXJyb3I6IGZ1bmN0aW9uICgpIHsKICAgICAgICBpZiAoRlMuRXJybm9FcnJvcikgcmV0dXJuCiAgICAgICAgRlMuRXJybm9FcnJvciA9IGZ1bmN0aW9uIEVycm5vRXJyb3IoZXJybm8sIG5vZGUpIHsKICAgICAgICAgIHRoaXMubm9kZSA9IG5vZGU7CiAgICAgICAgICB0aGlzLnNldEVycm5vID0gZnVuY3Rpb24gKGVycm5vKSB7CiAgICAgICAgICAgIHRoaXMuZXJybm8gPSBlcnJubzsKICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIEVSUk5PX0NPREVTKSB7CiAgICAgICAgICAgICAgaWYgKEVSUk5PX0NPREVTW2tleV0gPT09IGVycm5vKSB7CiAgICAgICAgICAgICAgICB0aGlzLmNvZGUgPSBrZXk7CiAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfTsKICAgICAgICAgIHRoaXMuc2V0RXJybm8oZXJybm8pOwogICAgICAgICAgdGhpcy5tZXNzYWdlID0gRVJSTk9fTUVTU0FHRVNbZXJybm9dOwogICAgICAgICAgaWYgKHRoaXMuc3RhY2spIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RhY2snLCB7IHZhbHVlOiBuZXcgRXJyb3IoKS5zdGFjaywgd3JpdGFibGU6IHRydWUgfSk7CiAgICAgICAgfTsKICAgICAgICBGUy5FcnJub0Vycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpOwogICAgICAgIEZTLkVycm5vRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRlMuRXJybm9FcnJvcgogICAgICAgIDtbRVJSTk9fQ09ERVMuRU5PRU5UXS5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlKSB7CiAgICAgICAgICBGUy5nZW5lcmljRXJyb3JzW2NvZGVdID0gbmV3IEZTLkVycm5vRXJyb3IoY29kZSk7CiAgICAgICAgICBGUy5nZW5lcmljRXJyb3JzW2NvZGVdLnN0YWNrID0gJzxnZW5lcmljIGVycm9yLCBubyBzdGFjaz4nOwogICAgICAgIH0pOwogICAgICB9LAogICAgICBzdGF0aWNJbml0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgRlMuZW5zdXJlRXJybm9FcnJvcigpOwogICAgICAgIEZTLm5hbWVUYWJsZSA9IG5ldyBBcnJheSg0MDk2KTsKICAgICAgICBGUy5tb3VudChNRU1GUywge30sICcvJyk7CiAgICAgICAgRlMuY3JlYXRlRGVmYXVsdERpcmVjdG9yaWVzKCk7CiAgICAgICAgRlMuY3JlYXRlRGVmYXVsdERldmljZXMoKTsKICAgICAgICBGUy5jcmVhdGVTcGVjaWFsRGlyZWN0b3JpZXMoKTsKICAgICAgICBGUy5maWxlc3lzdGVtcyA9IHsgTUVNRlM6IE1FTUZTLCBJREJGUzogSURCRlMsIE5PREVGUzogTk9ERUZTLCBXT1JLRVJGUzogV09SS0VSRlMgfTsKICAgICAgfSwKICAgICAgaW5pdDogZnVuY3Rpb24gKGlucHV0LCBvdXRwdXQsIGVycm9yKSB7CiAgICAgICAgYXNzZXJ0KAogICAgICAgICAgIUZTLmluaXQuaW5pdGlhbGl6ZWQsCiAgICAgICAgICAnRlMuaW5pdCB3YXMgcHJldmlvdXNseSBjYWxsZWQuIElmIHlvdSB3YW50IHRvIGluaXRpYWxpemUgbGF0ZXIgd2l0aCBjdXN0b20gcGFyYW1ldGVycywgcmVtb3ZlIGFueSBlYXJsaWVyIGNhbGxzIChub3RlIHRoYXQgb25lIGlzIGF1dG9tYXRpY2FsbHkgYWRkZWQgdG8gdGhlIGdlbmVyYXRlZCBjb2RlKScKICAgICAgICApOwogICAgICAgIEZTLmluaXQuaW5pdGlhbGl6ZWQgPSB0cnVlOwogICAgICAgIEZTLmVuc3VyZUVycm5vRXJyb3IoKTsKICAgICAgICBNb2R1bGVbJ3N0ZGluJ10gPSBpbnB1dCB8fCBNb2R1bGVbJ3N0ZGluJ107CiAgICAgICAgTW9kdWxlWydzdGRvdXQnXSA9IG91dHB1dCB8fCBNb2R1bGVbJ3N0ZG91dCddOwogICAgICAgIE1vZHVsZVsnc3RkZXJyJ10gPSBlcnJvciB8fCBNb2R1bGVbJ3N0ZGVyciddOwogICAgICAgIEZTLmNyZWF0ZVN0YW5kYXJkU3RyZWFtcygpOwogICAgICB9LAogICAgICBxdWl0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgRlMuaW5pdC5pbml0aWFsaXplZCA9IGZhbHNlOwogICAgICAgIHZhciBmZmx1c2ggPSBNb2R1bGVbJ19mZmx1c2gnXTsKICAgICAgICBpZiAoZmZsdXNoKSBmZmx1c2goMCk7CiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBGUy5zdHJlYW1zLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICB2YXIgc3RyZWFtID0gRlMuc3RyZWFtc1tpXTsKICAgICAgICAgIGlmICghc3RyZWFtKSB7CiAgICAgICAgICAgIGNvbnRpbnVlCiAgICAgICAgICB9CiAgICAgICAgICBGUy5jbG9zZShzdHJlYW0pOwogICAgICAgIH0KICAgICAgfSwKICAgICAgZ2V0TW9kZTogZnVuY3Rpb24gKGNhblJlYWQsIGNhbldyaXRlKSB7CiAgICAgICAgdmFyIG1vZGUgPSAwOwogICAgICAgIGlmIChjYW5SZWFkKSBtb2RlIHw9IDI5MiB8IDczOwogICAgICAgIGlmIChjYW5Xcml0ZSkgbW9kZSB8PSAxNDY7CiAgICAgICAgcmV0dXJuIG1vZGUKICAgICAgfSwKICAgICAgam9pblBhdGg6IGZ1bmN0aW9uIChwYXJ0cywgZm9yY2VSZWxhdGl2ZSkgewogICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luLmFwcGx5KG51bGwsIHBhcnRzKTsKICAgICAgICBpZiAoZm9yY2VSZWxhdGl2ZSAmJiBwYXRoWzBdID09ICcvJykgcGF0aCA9IHBhdGguc3Vic3RyKDEpOwogICAgICAgIHJldHVybiBwYXRoCiAgICAgIH0sCiAgICAgIGFic29sdXRlUGF0aDogZnVuY3Rpb24gKHJlbGF0aXZlLCBiYXNlKSB7CiAgICAgICAgcmV0dXJuIFBBVEgucmVzb2x2ZShiYXNlLCByZWxhdGl2ZSkKICAgICAgfSwKICAgICAgc3RhbmRhcmRpemVQYXRoOiBmdW5jdGlvbiAocGF0aCkgewogICAgICAgIHJldHVybiBQQVRILm5vcm1hbGl6ZShwYXRoKQogICAgICB9LAogICAgICBmaW5kT2JqZWN0OiBmdW5jdGlvbiAocGF0aCwgZG9udFJlc29sdmVMYXN0TGluaykgewogICAgICAgIHZhciByZXQgPSBGUy5hbmFseXplUGF0aChwYXRoLCBkb250UmVzb2x2ZUxhc3RMaW5rKTsKICAgICAgICBpZiAocmV0LmV4aXN0cykgewogICAgICAgICAgcmV0dXJuIHJldC5vYmplY3QKICAgICAgICB9IGVsc2UgewogICAgICAgICAgX19fc2V0RXJyTm8ocmV0LmVycm9yKTsKICAgICAgICAgIHJldHVybiBudWxsCiAgICAgICAgfQogICAgICB9LAogICAgICBhbmFseXplUGF0aDogZnVuY3Rpb24gKHBhdGgsIGRvbnRSZXNvbHZlTGFzdExpbmspIHsKICAgICAgICB0cnkgewogICAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6ICFkb250UmVzb2x2ZUxhc3RMaW5rIH0pOwogICAgICAgICAgcGF0aCA9IGxvb2t1cC5wYXRoOwogICAgICAgIH0gY2F0Y2ggKGUpIHt9CiAgICAgICAgdmFyIHJldCA9IHsKICAgICAgICAgIGlzUm9vdDogZmFsc2UsCiAgICAgICAgICBleGlzdHM6IGZhbHNlLAogICAgICAgICAgZXJyb3I6IDAsCiAgICAgICAgICBuYW1lOiBudWxsLAogICAgICAgICAgcGF0aDogbnVsbCwKICAgICAgICAgIG9iamVjdDogbnVsbCwKICAgICAgICAgIHBhcmVudEV4aXN0czogZmFsc2UsCiAgICAgICAgICBwYXJlbnRQYXRoOiBudWxsLAogICAgICAgICAgcGFyZW50T2JqZWN0OiBudWxsLAogICAgICAgIH07CiAgICAgICAgdHJ5IHsKICAgICAgICAgIHZhciBsb29rdXAgPSBGUy5sb29rdXBQYXRoKHBhdGgsIHsgcGFyZW50OiB0cnVlIH0pOwogICAgICAgICAgcmV0LnBhcmVudEV4aXN0cyA9IHRydWU7CiAgICAgICAgICByZXQucGFyZW50UGF0aCA9IGxvb2t1cC5wYXRoOwogICAgICAgICAgcmV0LnBhcmVudE9iamVjdCA9IGxvb2t1cC5ub2RlOwogICAgICAgICAgcmV0Lm5hbWUgPSBQQVRILmJhc2VuYW1lKHBhdGgpOwogICAgICAgICAgbG9va3VwID0gRlMubG9va3VwUGF0aChwYXRoLCB7IGZvbGxvdzogIWRvbnRSZXNvbHZlTGFzdExpbmsgfSk7CiAgICAgICAgICByZXQuZXhpc3RzID0gdHJ1ZTsKICAgICAgICAgIHJldC5wYXRoID0gbG9va3VwLnBhdGg7CiAgICAgICAgICByZXQub2JqZWN0ID0gbG9va3VwLm5vZGU7CiAgICAgICAgICByZXQubmFtZSA9IGxvb2t1cC5ub2RlLm5hbWU7CiAgICAgICAgICByZXQuaXNSb290ID0gbG9va3VwLnBhdGggPT09ICcvJzsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZXQuZXJyb3IgPSBlLmVycm5vOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcmV0CiAgICAgIH0sCiAgICAgIGNyZWF0ZUZvbGRlcjogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSwgY2FuUmVhZCwgY2FuV3JpdGUpIHsKICAgICAgICB2YXIgcGF0aCA9IFBBVEguam9pbjIodHlwZW9mIHBhcmVudCA9PT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCksIG5hbWUpOwogICAgICAgIHZhciBtb2RlID0gRlMuZ2V0TW9kZShjYW5SZWFkLCBjYW5Xcml0ZSk7CiAgICAgICAgcmV0dXJuIEZTLm1rZGlyKHBhdGgsIG1vZGUpCiAgICAgIH0sCiAgICAgIGNyZWF0ZVBhdGg6IGZ1bmN0aW9uIChwYXJlbnQsIHBhdGgsIGNhblJlYWQsIGNhbldyaXRlKSB7CiAgICAgICAgcGFyZW50ID0gdHlwZW9mIHBhcmVudCA9PT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCk7CiAgICAgICAgdmFyIHBhcnRzID0gcGF0aC5zcGxpdCgnLycpLnJldmVyc2UoKTsKICAgICAgICB3aGlsZSAocGFydHMubGVuZ3RoKSB7CiAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzLnBvcCgpOwogICAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZQogICAgICAgICAgdmFyIGN1cnJlbnQgPSBQQVRILmpvaW4yKHBhcmVudCwgcGFydCk7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBGUy5ta2RpcihjdXJyZW50KTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9CiAgICAgICAgICBwYXJlbnQgPSBjdXJyZW50OwogICAgICAgIH0KICAgICAgICByZXR1cm4gY3VycmVudAogICAgICB9LAogICAgICBjcmVhdGVGaWxlOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBwcm9wZXJ0aWVzLCBjYW5SZWFkLCBjYW5Xcml0ZSkgewogICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMih0eXBlb2YgcGFyZW50ID09PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KSwgbmFtZSk7CiAgICAgICAgdmFyIG1vZGUgPSBGUy5nZXRNb2RlKGNhblJlYWQsIGNhbldyaXRlKTsKICAgICAgICByZXR1cm4gRlMuY3JlYXRlKHBhdGgsIG1vZGUpCiAgICAgIH0sCiAgICAgIGNyZWF0ZURhdGFGaWxlOiBmdW5jdGlvbiAocGFyZW50LCBuYW1lLCBkYXRhLCBjYW5SZWFkLCBjYW5Xcml0ZSwgY2FuT3duKSB7CiAgICAgICAgdmFyIHBhdGggPSBuYW1lID8gUEFUSC5qb2luMih0eXBlb2YgcGFyZW50ID09PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KSwgbmFtZSkgOiBwYXJlbnQ7CiAgICAgICAgdmFyIG1vZGUgPSBGUy5nZXRNb2RlKGNhblJlYWQsIGNhbldyaXRlKTsKICAgICAgICB2YXIgbm9kZSA9IEZTLmNyZWF0ZShwYXRoLCBtb2RlKTsKICAgICAgICBpZiAoZGF0YSkgewogICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgewogICAgICAgICAgICB2YXIgYXJyID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyArK2kpIGFycltpXSA9IGRhdGEuY2hhckNvZGVBdChpKTsKICAgICAgICAgICAgZGF0YSA9IGFycjsKICAgICAgICAgIH0KICAgICAgICAgIEZTLmNobW9kKG5vZGUsIG1vZGUgfCAxNDYpOwogICAgICAgICAgdmFyIHN0cmVhbSA9IEZTLm9wZW4obm9kZSwgJ3cnKTsKICAgICAgICAgIEZTLndyaXRlKHN0cmVhbSwgZGF0YSwgMCwgZGF0YS5sZW5ndGgsIDAsIGNhbk93bik7CiAgICAgICAgICBGUy5jbG9zZShzdHJlYW0pOwogICAgICAgICAgRlMuY2htb2Qobm9kZSwgbW9kZSk7CiAgICAgICAgfQogICAgICAgIHJldHVybiBub2RlCiAgICAgIH0sCiAgICAgIGNyZWF0ZURldmljZTogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSwgaW5wdXQsIG91dHB1dCkgewogICAgICAgIHZhciBwYXRoID0gUEFUSC5qb2luMih0eXBlb2YgcGFyZW50ID09PSAnc3RyaW5nJyA/IHBhcmVudCA6IEZTLmdldFBhdGgocGFyZW50KSwgbmFtZSk7CiAgICAgICAgdmFyIG1vZGUgPSBGUy5nZXRNb2RlKCEhaW5wdXQsICEhb3V0cHV0KTsKICAgICAgICBpZiAoIUZTLmNyZWF0ZURldmljZS5tYWpvcikgRlMuY3JlYXRlRGV2aWNlLm1ham9yID0gNjQ7CiAgICAgICAgdmFyIGRldiA9IEZTLm1ha2VkZXYoRlMuY3JlYXRlRGV2aWNlLm1ham9yKyssIDApOwogICAgICAgIEZTLnJlZ2lzdGVyRGV2aWNlKGRldiwgewogICAgICAgICAgb3BlbjogZnVuY3Rpb24gKHN0cmVhbSkgewogICAgICAgICAgICBzdHJlYW0uc2Vla2FibGUgPSBmYWxzZTsKICAgICAgICAgIH0sCiAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKHN0cmVhbSkgewogICAgICAgICAgICBpZiAob3V0cHV0ICYmIG91dHB1dC5idWZmZXIgJiYgb3V0cHV0LmJ1ZmZlci5sZW5ndGgpIHsKICAgICAgICAgICAgICBvdXRwdXQoMTApOwogICAgICAgICAgICB9CiAgICAgICAgICB9LAogICAgICAgICAgcmVhZDogZnVuY3Rpb24gKHN0cmVhbSwgYnVmZmVyLCBvZmZzZXQsIGxlbmd0aCwgcG9zKSB7CiAgICAgICAgICAgIHZhciBieXRlc1JlYWQgPSAwOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgdmFyIHJlc3VsdDsKICAgICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXQoKTsKICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU8pCiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCAmJiBieXRlc1JlYWQgPT09IDApIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVBR0FJTikKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHVuZGVmaW5lZCkgYnJlYWsKICAgICAgICAgICAgICBieXRlc1JlYWQrKzsKICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0ICsgaV0gPSByZXN1bHQ7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCkgewogICAgICAgICAgICAgIHN0cmVhbS5ub2RlLnRpbWVzdGFtcCA9IERhdGUubm93KCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGJ5dGVzUmVhZAogICAgICAgICAgfSwKICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbiAoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3MpIHsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykgewogICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBvdXRwdXQoYnVmZmVyW29mZnNldCArIGldKTsKICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FSU8pCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChsZW5ndGgpIHsKICAgICAgICAgICAgICBzdHJlYW0ubm9kZS50aW1lc3RhbXAgPSBEYXRlLm5vdygpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBpCiAgICAgICAgICB9LAogICAgICAgIH0pOwogICAgICAgIHJldHVybiBGUy5ta2RldihwYXRoLCBtb2RlLCBkZXYpCiAgICAgIH0sCiAgICAgIGNyZWF0ZUxpbms6IGZ1bmN0aW9uIChwYXJlbnQsIG5hbWUsIHRhcmdldCwgY2FuUmVhZCwgY2FuV3JpdGUpIHsKICAgICAgICB2YXIgcGF0aCA9IFBBVEguam9pbjIodHlwZW9mIHBhcmVudCA9PT0gJ3N0cmluZycgPyBwYXJlbnQgOiBGUy5nZXRQYXRoKHBhcmVudCksIG5hbWUpOwogICAgICAgIHJldHVybiBGUy5zeW1saW5rKHRhcmdldCwgcGF0aCkKICAgICAgfSwKICAgICAgZm9yY2VMb2FkRmlsZTogZnVuY3Rpb24gKG9iaikgewogICAgICAgIGlmIChvYmouaXNEZXZpY2UgfHwgb2JqLmlzRm9sZGVyIHx8IG9iai5saW5rIHx8IG9iai5jb250ZW50cykgcmV0dXJuIHRydWUKICAgICAgICB2YXIgc3VjY2VzcyA9IHRydWU7CiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIHRocm93IG5ldyBFcnJvcigKICAgICAgICAgICAgJ0xhenkgbG9hZGluZyBzaG91bGQgaGF2ZSBiZWVuIHBlcmZvcm1lZCAoY29udGVudHMgc2V0KSBpbiBjcmVhdGVMYXp5RmlsZSwgYnV0IGl0IHdhcyBub3QuIExhenkgbG9hZGluZyBvbmx5IHdvcmtzIGluIHdlYiB3b3JrZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2Mgb24gdGhlIG1haW4gdGhyZWFkLicKICAgICAgICAgICkKICAgICAgICB9IGVsc2UgaWYgKE1vZHVsZVsncmVhZCddKSB7CiAgICAgICAgICB0cnkgewogICAgICAgICAgICBvYmouY29udGVudHMgPSBpbnRBcnJheUZyb21TdHJpbmcoTW9kdWxlWydyZWFkJ10ob2JqLnVybCksIHRydWUpOwogICAgICAgICAgICBvYmoudXNlZEJ5dGVzID0gb2JqLmNvbnRlbnRzLmxlbmd0aDsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgc3VjY2VzcyA9IGZhbHNlOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBsb2FkIHdpdGhvdXQgcmVhZCgpIG9yIFhNTEh0dHBSZXF1ZXN0LicpCiAgICAgICAgfQogICAgICAgIGlmICghc3VjY2VzcykgX19fc2V0RXJyTm8oRVJSTk9fQ09ERVMuRUlPKTsKICAgICAgICByZXR1cm4gc3VjY2VzcwogICAgICB9LAogICAgICBjcmVhdGVMYXp5RmlsZTogZnVuY3Rpb24gKHBhcmVudCwgbmFtZSwgdXJsLCBjYW5SZWFkLCBjYW5Xcml0ZSkgewogICAgICAgIGZ1bmN0aW9uIExhenlVaW50OEFycmF5KCkgewogICAgICAgICAgdGhpcy5sZW5ndGhLbm93biA9IGZhbHNlOwogICAgICAgICAgdGhpcy5jaHVua3MgPSBbXTsKICAgICAgICB9CiAgICAgICAgTGF6eVVpbnQ4QXJyYXkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIExhenlVaW50OEFycmF5X2dldChpZHgpIHsKICAgICAgICAgIGlmIChpZHggPiB0aGlzLmxlbmd0aCAtIDEgfHwgaWR4IDwgMCkgewogICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkCiAgICAgICAgICB9CiAgICAgICAgICB2YXIgY2h1bmtPZmZzZXQgPSBpZHggJSB0aGlzLmNodW5rU2l6ZTsKICAgICAgICAgIHZhciBjaHVua051bSA9IChpZHggLyB0aGlzLmNodW5rU2l6ZSkgfCAwOwogICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0dGVyKGNodW5rTnVtKVtjaHVua09mZnNldF0KICAgICAgICB9OwogICAgICAgIExhenlVaW50OEFycmF5LnByb3RvdHlwZS5zZXREYXRhR2V0dGVyID0gZnVuY3Rpb24gTGF6eVVpbnQ4QXJyYXlfc2V0RGF0YUdldHRlcihnZXR0ZXIpIHsKICAgICAgICAgIHRoaXMuZ2V0dGVyID0gZ2V0dGVyOwogICAgICAgIH07CiAgICAgICAgTGF6eVVpbnQ4QXJyYXkucHJvdG90eXBlLmNhY2hlTGVuZ3RoID0gZnVuY3Rpb24gTGF6eVVpbnQ4QXJyYXlfY2FjaGVMZW5ndGgoKSB7CiAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7CiAgICAgICAgICB4aHIub3BlbignSEVBRCcsIHVybCwgZmFsc2UpOwogICAgICAgICAgeGhyLnNlbmQobnVsbCk7CiAgICAgICAgICBpZiAoISgoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkgfHwgeGhyLnN0YXR1cyA9PT0gMzA0KSkKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJDb3VsZG4ndCBsb2FkICIgKyB1cmwgKyAnLiBTdGF0dXM6ICcgKyB4aHIuc3RhdHVzKQogICAgICAgICAgdmFyIGRhdGFsZW5ndGggPSBOdW1iZXIoeGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LWxlbmd0aCcpKTsKICAgICAgICAgIHZhciBoZWFkZXI7CiAgICAgICAgICB2YXIgaGFzQnl0ZVNlcnZpbmcgPSAoaGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdBY2NlcHQtUmFuZ2VzJykpICYmIGhlYWRlciA9PT0gJ2J5dGVzJzsKICAgICAgICAgIHZhciB1c2VzR3ppcCA9IChoZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtRW5jb2RpbmcnKSkgJiYgaGVhZGVyID09PSAnZ3ppcCc7CiAgICAgICAgICB2YXIgY2h1bmtTaXplID0gMTAyNCAqIDEwMjQ7CiAgICAgICAgICBpZiAoIWhhc0J5dGVTZXJ2aW5nKSBjaHVua1NpemUgPSBkYXRhbGVuZ3RoOwogICAgICAgICAgdmFyIGRvWEhSID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7CiAgICAgICAgICAgIGlmIChmcm9tID4gdG8pIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByYW5nZSAoJyArIGZyb20gKyAnLCAnICsgdG8gKyAnKSBvciBubyBieXRlcyByZXF1ZXN0ZWQhJykKICAgICAgICAgICAgaWYgKHRvID4gZGF0YWxlbmd0aCAtIDEpIHRocm93IG5ldyBFcnJvcignb25seSAnICsgZGF0YWxlbmd0aCArICcgYnl0ZXMgYXZhaWxhYmxlISBwcm9ncmFtbWVyIGVycm9yIScpCiAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTsKICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgZmFsc2UpOwogICAgICAgICAgICBpZiAoZGF0YWxlbmd0aCAhPT0gY2h1bmtTaXplKSB4aHIuc2V0UmVxdWVzdEhlYWRlcignUmFuZ2UnLCAnYnl0ZXM9JyArIGZyb20gKyAnLScgKyB0byk7CiAgICAgICAgICAgIGlmICh0eXBlb2YgVWludDhBcnJheSAhPSAndW5kZWZpbmVkJykgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7CiAgICAgICAgICAgIGlmICh4aHIub3ZlcnJpZGVNaW1lVHlwZSkgewogICAgICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkJyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgeGhyLnNlbmQobnVsbCk7CiAgICAgICAgICAgIGlmICghKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09PSAzMDQpKQogICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiQ291bGRuJ3QgbG9hZCAiICsgdXJsICsgJy4gU3RhdHVzOiAnICsgeGhyLnN0YXR1cykKICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSB8fCBbXSkKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZXR1cm4gaW50QXJyYXlGcm9tU3RyaW5nKHhoci5yZXNwb25zZVRleHQgfHwgJycsIHRydWUpCiAgICAgICAgICAgIH0KICAgICAgICAgIH07CiAgICAgICAgICB2YXIgbGF6eUFycmF5ID0gdGhpczsKICAgICAgICAgIGxhenlBcnJheS5zZXREYXRhR2V0dGVyKGZ1bmN0aW9uIChjaHVua051bSkgewogICAgICAgICAgICB2YXIgc3RhcnQgPSBjaHVua051bSAqIGNodW5rU2l6ZTsKICAgICAgICAgICAgdmFyIGVuZCA9IChjaHVua051bSArIDEpICogY2h1bmtTaXplIC0gMTsKICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBkYXRhbGVuZ3RoIC0gMSk7CiAgICAgICAgICAgIGlmICh0eXBlb2YgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV0gPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAgICAgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV0gPSBkb1hIUihzdGFydCwgZW5kKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dID09PSAndW5kZWZpbmVkJykgdGhyb3cgbmV3IEVycm9yKCdkb1hIUiBmYWlsZWQhJykKICAgICAgICAgICAgcmV0dXJuIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dCiAgICAgICAgICB9KTsKICAgICAgICAgIGlmICh1c2VzR3ppcCB8fCAhZGF0YWxlbmd0aCkgewogICAgICAgICAgICBjaHVua1NpemUgPSBkYXRhbGVuZ3RoID0gMTsKICAgICAgICAgICAgZGF0YWxlbmd0aCA9IHRoaXMuZ2V0dGVyKDApLmxlbmd0aDsKICAgICAgICAgICAgY2h1bmtTaXplID0gZGF0YWxlbmd0aDsKICAgICAgICAgICAgY29uc29sZS5sb2coJ0xhenlGaWxlcyBvbiBnemlwIGZvcmNlcyBkb3dubG9hZCBvZiB0aGUgd2hvbGUgZmlsZSB3aGVuIGxlbmd0aCBpcyBhY2Nlc3NlZCcpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5fbGVuZ3RoID0gZGF0YWxlbmd0aDsKICAgICAgICAgIHRoaXMuX2NodW5rU2l6ZSA9IGNodW5rU2l6ZTsKICAgICAgICAgIHRoaXMubGVuZ3RoS25vd24gPSB0cnVlOwogICAgICAgIH07CiAgICAgICAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgIGlmICghRU5WSVJPTk1FTlRfSVNfV09SS0VSKQogICAgICAgICAgICB0aHJvdyAnQ2Fubm90IGRvIHN5bmNocm9ub3VzIGJpbmFyeSBYSFJzIG91dHNpZGUgd2Vid29ya2VycyBpbiBtb2Rlcm4gYnJvd3NlcnMuIFVzZSAtLWVtYmVkLWZpbGUgb3IgLS1wcmVsb2FkLWZpbGUgaW4gZW1jYycKICAgICAgICAgIHZhciBsYXp5QXJyYXkgPSBuZXcgTGF6eVVpbnQ4QXJyYXkoKTsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlBcnJheSwgewogICAgICAgICAgICBsZW5ndGg6IHsKICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgIGlmICghdGhpcy5sZW5ndGhLbm93bikgewogICAgICAgICAgICAgICAgICB0aGlzLmNhY2hlTGVuZ3RoKCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbGVuZ3RoCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgfSwKICAgICAgICAgICAgY2h1bmtTaXplOiB7CiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGVuZ3RoS25vd24pIHsKICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZUxlbmd0aCgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NodW5rU2l6ZQogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIH0sCiAgICAgICAgICB9KTsKICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0geyBpc0RldmljZTogZmFsc2UsIGNvbnRlbnRzOiBsYXp5QXJyYXkgfTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7IGlzRGV2aWNlOiBmYWxzZSwgdXJsOiB1cmwgfTsKICAgICAgICB9CiAgICAgICAgdmFyIG5vZGUgPSBGUy5jcmVhdGVGaWxlKHBhcmVudCwgbmFtZSwgcHJvcGVydGllcywgY2FuUmVhZCwgY2FuV3JpdGUpOwogICAgICAgIGlmIChwcm9wZXJ0aWVzLmNvbnRlbnRzKSB7CiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gcHJvcGVydGllcy5jb250ZW50czsKICAgICAgICB9IGVsc2UgaWYgKHByb3BlcnRpZXMudXJsKSB7CiAgICAgICAgICBub2RlLmNvbnRlbnRzID0gbnVsbDsKICAgICAgICAgIG5vZGUudXJsID0gcHJvcGVydGllcy51cmw7CiAgICAgICAgfQogICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5vZGUsIHsKICAgICAgICAgIHVzZWRCeXRlczogewogICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50cy5sZW5ndGgKICAgICAgICAgICAgfSwKICAgICAgICAgIH0sCiAgICAgICAgfSk7CiAgICAgICAgdmFyIHN0cmVhbV9vcHMgPSB7fTsKICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG5vZGUuc3RyZWFtX29wcyk7CiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsKICAgICAgICAgIHZhciBmbiA9IG5vZGUuc3RyZWFtX29wc1trZXldOwogICAgICAgICAgc3RyZWFtX29wc1trZXldID0gZnVuY3Rpb24gZm9yY2VMb2FkTGF6eUZpbGUoKSB7CiAgICAgICAgICAgIGlmICghRlMuZm9yY2VMb2FkRmlsZShub2RlKSkgewogICAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTykKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgICAgICAgfTsKICAgICAgICB9KTsKICAgICAgICBzdHJlYW1fb3BzLnJlYWQgPSBmdW5jdGlvbiBzdHJlYW1fb3BzX3JlYWQoc3RyZWFtLCBidWZmZXIsIG9mZnNldCwgbGVuZ3RoLCBwb3NpdGlvbikgewogICAgICAgICAgaWYgKCFGUy5mb3JjZUxvYWRGaWxlKG5vZGUpKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVJTykKICAgICAgICAgIH0KICAgICAgICAgIHZhciBjb250ZW50cyA9IHN0cmVhbS5ub2RlLmNvbnRlbnRzOwogICAgICAgICAgaWYgKHBvc2l0aW9uID49IGNvbnRlbnRzLmxlbmd0aCkgcmV0dXJuIDAKICAgICAgICAgIHZhciBzaXplID0gTWF0aC5taW4oY29udGVudHMubGVuZ3RoIC0gcG9zaXRpb24sIGxlbmd0aCk7CiAgICAgICAgICBhc3NlcnQoc2l6ZSA+PSAwKTsKICAgICAgICAgIGlmIChjb250ZW50cy5zbGljZSkgewogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykgewogICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGNvbnRlbnRzW3Bvc2l0aW9uICsgaV07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7CiAgICAgICAgICAgICAgYnVmZmVyW29mZnNldCArIGldID0gY29udGVudHMuZ2V0KHBvc2l0aW9uICsgaSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBzaXplCiAgICAgICAgfTsKICAgICAgICBub2RlLnN0cmVhbV9vcHMgPSBzdHJlYW1fb3BzOwogICAgICAgIHJldHVybiBub2RlCiAgICAgIH0sCiAgICAgIGNyZWF0ZVByZWxvYWRlZEZpbGU6IGZ1bmN0aW9uICgKICAgICAgICBwYXJlbnQsCiAgICAgICAgbmFtZSwKICAgICAgICB1cmwsCiAgICAgICAgY2FuUmVhZCwKICAgICAgICBjYW5Xcml0ZSwKICAgICAgICBvbmxvYWQsCiAgICAgICAgb25lcnJvciwKICAgICAgICBkb250Q3JlYXRlRmlsZSwKICAgICAgICBjYW5Pd24sCiAgICAgICAgcHJlRmluaXNoCiAgICAgICkgewogICAgICAgIEJyb3dzZXIuaW5pdCgpOwogICAgICAgIHZhciBmdWxsbmFtZSA9IG5hbWUgPyBQQVRILnJlc29sdmUoUEFUSC5qb2luMihwYXJlbnQsIG5hbWUpKSA6IHBhcmVudDsKICAgICAgICBmdW5jdGlvbiBwcm9jZXNzRGF0YShieXRlQXJyYXkpIHsKICAgICAgICAgIGZ1bmN0aW9uIGZpbmlzaChieXRlQXJyYXkpIHsKICAgICAgICAgICAgaWYgKHByZUZpbmlzaCkgcHJlRmluaXNoKCk7CiAgICAgICAgICAgIGlmICghZG9udENyZWF0ZUZpbGUpIHsKICAgICAgICAgICAgICBGUy5jcmVhdGVEYXRhRmlsZShwYXJlbnQsIG5hbWUsIGJ5dGVBcnJheSwgY2FuUmVhZCwgY2FuV3JpdGUsIGNhbk93bik7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKG9ubG9hZCkgb25sb2FkKCk7CiAgICAgICAgICAgIHJlbW92ZVJ1bkRlcGVuZGVuY3koKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBoYW5kbGVkID0gZmFsc2U7CiAgICAgICAgICBNb2R1bGVbJ3ByZWxvYWRQbHVnaW5zJ10uZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7CiAgICAgICAgICAgIGlmIChoYW5kbGVkKSByZXR1cm4KICAgICAgICAgICAgaWYgKHBsdWdpblsnY2FuSGFuZGxlJ10oZnVsbG5hbWUpKSB7CiAgICAgICAgICAgICAgcGx1Z2luWydoYW5kbGUnXShieXRlQXJyYXksIGZ1bGxuYW1lLCBmaW5pc2gsIGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgIGlmIChvbmVycm9yKSBvbmVycm9yKCk7CiAgICAgICAgICAgICAgICByZW1vdmVSdW5EZXBlbmRlbmN5KCk7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgaGFuZGxlZCA9IHRydWU7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgaWYgKCFoYW5kbGVkKSBmaW5pc2goYnl0ZUFycmF5KTsKICAgICAgICB9CiAgICAgICAgYWRkUnVuRGVwZW5kZW5jeSgpOwogICAgICAgIGlmICh0eXBlb2YgdXJsID09ICdzdHJpbmcnKSB7CiAgICAgICAgICBCcm93c2VyLmFzeW5jTG9hZCgKICAgICAgICAgICAgdXJsLAogICAgICAgICAgICBmdW5jdGlvbiAoYnl0ZUFycmF5KSB7CiAgICAgICAgICAgICAgcHJvY2Vzc0RhdGEoYnl0ZUFycmF5KTsKICAgICAgICAgICAgfSwKICAgICAgICAgICAgb25lcnJvcgogICAgICAgICAgKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcHJvY2Vzc0RhdGEodXJsKTsKICAgICAgICB9CiAgICAgIH0sCiAgICAgIGluZGV4ZWREQjogZnVuY3Rpb24gKCkgewogICAgICAgIHJldHVybiB3aW5kb3cuaW5kZXhlZERCIHx8IHdpbmRvdy5tb3pJbmRleGVkREIgfHwgd2luZG93LndlYmtpdEluZGV4ZWREQiB8fCB3aW5kb3cubXNJbmRleGVkREIKICAgICAgfSwKICAgICAgREJfTkFNRTogZnVuY3Rpb24gKCkgewogICAgICAgIHJldHVybiAnRU1fRlNfJyArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZQogICAgICB9LAogICAgICBEQl9WRVJTSU9OOiAyMCwKICAgICAgREJfU1RPUkVfTkFNRTogJ0ZJTEVfREFUQScsCiAgICAgIHNhdmVGaWxlc1RvREI6IGZ1bmN0aW9uIChwYXRocywgb25sb2FkLCBvbmVycm9yKSB7CiAgICAgICAgb25sb2FkID0gb25sb2FkIHx8IGZ1bmN0aW9uICgpIHt9OwogICAgICAgIG9uZXJyb3IgPSBvbmVycm9yIHx8IGZ1bmN0aW9uICgpIHt9OwogICAgICAgIHZhciBpbmRleGVkREIgPSBGUy5pbmRleGVkREIoKTsKICAgICAgICB0cnkgewogICAgICAgICAgdmFyIG9wZW5SZXF1ZXN0ID0gaW5kZXhlZERCLm9wZW4oRlMuREJfTkFNRSgpLCBGUy5EQl9WRVJTSU9OKTsKICAgICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgICByZXR1cm4gb25lcnJvcihlKQogICAgICAgIH0KICAgICAgICBvcGVuUmVxdWVzdC5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiBvcGVuUmVxdWVzdF9vbnVwZ3JhZGVuZWVkZWQoKSB7CiAgICAgICAgICBjb25zb2xlLmxvZygnY3JlYXRpbmcgZGInKTsKICAgICAgICAgIHZhciBkYiA9IG9wZW5SZXF1ZXN0LnJlc3VsdDsKICAgICAgICAgIGRiLmNyZWF0ZU9iamVjdFN0b3JlKEZTLkRCX1NUT1JFX05BTUUpOwogICAgICAgIH07CiAgICAgICAgb3BlblJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gb3BlblJlcXVlc3Rfb25zdWNjZXNzKCkgewogICAgICAgICAgdmFyIGRiID0gb3BlblJlcXVlc3QucmVzdWx0OwogICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZTLkRCX1NUT1JFX05BTUVdLCAncmVhZHdyaXRlJyk7CiAgICAgICAgICB2YXIgZmlsZXMgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGUy5EQl9TVE9SRV9OQU1FKTsKICAgICAgICAgIHZhciBvayA9IDAsCiAgICAgICAgICAgIGZhaWwgPSAwLAogICAgICAgICAgICB0b3RhbCA9IHBhdGhzLmxlbmd0aDsKICAgICAgICAgIGZ1bmN0aW9uIGZpbmlzaCgpIHsKICAgICAgICAgICAgaWYgKGZhaWwgPT0gMCkgb25sb2FkKCk7CiAgICAgICAgICAgIGVsc2Ugb25lcnJvcigpOwogICAgICAgICAgfQogICAgICAgICAgcGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkgewogICAgICAgICAgICB2YXIgcHV0UmVxdWVzdCA9IGZpbGVzLnB1dChGUy5hbmFseXplUGF0aChwYXRoKS5vYmplY3QuY29udGVudHMsIHBhdGgpOwogICAgICAgICAgICBwdXRSZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIHB1dFJlcXVlc3Rfb25zdWNjZXNzKCkgewogICAgICAgICAgICAgIG9rKys7CiAgICAgICAgICAgICAgaWYgKG9rICsgZmFpbCA9PSB0b3RhbCkgZmluaXNoKCk7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIHB1dFJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIHB1dFJlcXVlc3Rfb25lcnJvcigpIHsKICAgICAgICAgICAgICBmYWlsKys7CiAgICAgICAgICAgICAgaWYgKG9rICsgZmFpbCA9PSB0b3RhbCkgZmluaXNoKCk7CiAgICAgICAgICAgIH07CiAgICAgICAgICB9KTsKICAgICAgICAgIHRyYW5zYWN0aW9uLm9uZXJyb3IgPSBvbmVycm9yOwogICAgICAgIH07CiAgICAgICAgb3BlblJlcXVlc3Qub25lcnJvciA9IG9uZXJyb3I7CiAgICAgIH0sCiAgICAgIGxvYWRGaWxlc0Zyb21EQjogZnVuY3Rpb24gKHBhdGhzLCBvbmxvYWQsIG9uZXJyb3IpIHsKICAgICAgICBvbmxvYWQgPSBvbmxvYWQgfHwgZnVuY3Rpb24gKCkge307CiAgICAgICAgb25lcnJvciA9IG9uZXJyb3IgfHwgZnVuY3Rpb24gKCkge307CiAgICAgICAgdmFyIGluZGV4ZWREQiA9IEZTLmluZGV4ZWREQigpOwogICAgICAgIHRyeSB7CiAgICAgICAgICB2YXIgb3BlblJlcXVlc3QgPSBpbmRleGVkREIub3BlbihGUy5EQl9OQU1FKCksIEZTLkRCX1ZFUlNJT04pOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIHJldHVybiBvbmVycm9yKGUpCiAgICAgICAgfQogICAgICAgIG9wZW5SZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IG9uZXJyb3I7CiAgICAgICAgb3BlblJlcXVlc3Qub25zdWNjZXNzID0gZnVuY3Rpb24gb3BlblJlcXVlc3Rfb25zdWNjZXNzKCkgewogICAgICAgICAgdmFyIGRiID0gb3BlblJlcXVlc3QucmVzdWx0OwogICAgICAgICAgdHJ5IHsKICAgICAgICAgICAgdmFyIHRyYW5zYWN0aW9uID0gZGIudHJhbnNhY3Rpb24oW0ZTLkRCX1NUT1JFX05BTUVdLCAncmVhZG9ubHknKTsKICAgICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgb25lcnJvcihlKTsKICAgICAgICAgICAgcmV0dXJuCiAgICAgICAgICB9CiAgICAgICAgICB2YXIgZmlsZXMgPSB0cmFuc2FjdGlvbi5vYmplY3RTdG9yZShGUy5EQl9TVE9SRV9OQU1FKTsKICAgICAgICAgIHZhciBvayA9IDAsCiAgICAgICAgICAgIGZhaWwgPSAwLAogICAgICAgICAgICB0b3RhbCA9IHBhdGhzLmxlbmd0aDsKICAgICAgICAgIGZ1bmN0aW9uIGZpbmlzaCgpIHsKICAgICAgICAgICAgaWYgKGZhaWwgPT0gMCkgb25sb2FkKCk7CiAgICAgICAgICAgIGVsc2Ugb25lcnJvcigpOwogICAgICAgICAgfQogICAgICAgICAgcGF0aHMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkgewogICAgICAgICAgICB2YXIgZ2V0UmVxdWVzdCA9IGZpbGVzLmdldChwYXRoKTsKICAgICAgICAgICAgZ2V0UmVxdWVzdC5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiBnZXRSZXF1ZXN0X29uc3VjY2VzcygpIHsKICAgICAgICAgICAgICBpZiAoRlMuYW5hbHl6ZVBhdGgocGF0aCkuZXhpc3RzKSB7CiAgICAgICAgICAgICAgICBGUy51bmxpbmsocGF0aCk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIEZTLmNyZWF0ZURhdGFGaWxlKFBBVEguZGlybmFtZShwYXRoKSwgUEFUSC5iYXNlbmFtZShwYXRoKSwgZ2V0UmVxdWVzdC5yZXN1bHQsIHRydWUsIHRydWUsIHRydWUpOwogICAgICAgICAgICAgIG9rKys7CiAgICAgICAgICAgICAgaWYgKG9rICsgZmFpbCA9PSB0b3RhbCkgZmluaXNoKCk7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGdldFJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGdldFJlcXVlc3Rfb25lcnJvcigpIHsKICAgICAgICAgICAgICBmYWlsKys7CiAgICAgICAgICAgICAgaWYgKG9rICsgZmFpbCA9PSB0b3RhbCkgZmluaXNoKCk7CiAgICAgICAgICAgIH07CiAgICAgICAgICB9KTsKICAgICAgICAgIHRyYW5zYWN0aW9uLm9uZXJyb3IgPSBvbmVycm9yOwogICAgICAgIH07CiAgICAgICAgb3BlblJlcXVlc3Qub25lcnJvciA9IG9uZXJyb3I7CiAgICAgIH0sCiAgICB9OwogICAgdmFyIFNZU0NBTExTID0gewogICAgICBERUZBVUxUX1BPTExNQVNLOiA1LAogICAgICBtYXBwaW5nczoge30sCiAgICAgIHVtYXNrOiA1MTEsCiAgICAgIGNhbGN1bGF0ZUF0OiBmdW5jdGlvbiAoZGlyZmQsIHBhdGgpIHsKICAgICAgICBpZiAocGF0aFswXSAhPT0gJy8nKSB7CiAgICAgICAgICB2YXIgZGlyOwogICAgICAgICAgaWYgKGRpcmZkID09PSAtMTAwKSB7CiAgICAgICAgICAgIGRpciA9IEZTLmN3ZCgpOwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdmFyIGRpcnN0cmVhbSA9IEZTLmdldFN0cmVhbShkaXJmZCk7CiAgICAgICAgICAgIGlmICghZGlyc3RyZWFtKSB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERikKICAgICAgICAgICAgZGlyID0gZGlyc3RyZWFtLnBhdGg7CiAgICAgICAgICB9CiAgICAgICAgICBwYXRoID0gUEFUSC5qb2luMihkaXIsIHBhdGgpOwogICAgICAgIH0KICAgICAgICByZXR1cm4gcGF0aAogICAgICB9LAogICAgICBkb1N0YXQ6IGZ1bmN0aW9uIChmdW5jLCBwYXRoLCBidWYpIHsKICAgICAgICB0cnkgewogICAgICAgICAgdmFyIHN0YXQgPSBmdW5jKHBhdGgpOwogICAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgIGlmIChlICYmIGUubm9kZSAmJiBQQVRILm5vcm1hbGl6ZShwYXRoKSAhPT0gUEFUSC5ub3JtYWxpemUoRlMuZ2V0UGF0aChlLm5vZGUpKSkgewogICAgICAgICAgICByZXR1cm4gLUVSUk5PX0NPREVTLkVOT1RESVIKICAgICAgICAgIH0KICAgICAgICAgIHRocm93IGUKICAgICAgICB9CiAgICAgICAgSEVBUDMyW2J1ZiA+PiAyXSA9IHN0YXQuZGV2OwogICAgICAgIEhFQVAzMlsoYnVmICsgNCkgPj4gMl0gPSAwOwogICAgICAgIEhFQVAzMlsoYnVmICsgOCkgPj4gMl0gPSBzdGF0LmlubzsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDEyKSA+PiAyXSA9IHN0YXQubW9kZTsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDE2KSA+PiAyXSA9IHN0YXQubmxpbms7CiAgICAgICAgSEVBUDMyWyhidWYgKyAyMCkgPj4gMl0gPSBzdGF0LnVpZDsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDI0KSA+PiAyXSA9IHN0YXQuZ2lkOwogICAgICAgIEhFQVAzMlsoYnVmICsgMjgpID4+IDJdID0gc3RhdC5yZGV2OwogICAgICAgIEhFQVAzMlsoYnVmICsgMzIpID4+IDJdID0gMDsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDM2KSA+PiAyXSA9IHN0YXQuc2l6ZTsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDQwKSA+PiAyXSA9IDQwOTY7CiAgICAgICAgSEVBUDMyWyhidWYgKyA0NCkgPj4gMl0gPSBzdGF0LmJsb2NrczsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDQ4KSA+PiAyXSA9IChzdGF0LmF0aW1lLmdldFRpbWUoKSAvIDFlMykgfCAwOwogICAgICAgIEhFQVAzMlsoYnVmICsgNTIpID4+IDJdID0gMDsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDU2KSA+PiAyXSA9IChzdGF0Lm10aW1lLmdldFRpbWUoKSAvIDFlMykgfCAwOwogICAgICAgIEhFQVAzMlsoYnVmICsgNjApID4+IDJdID0gMDsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDY0KSA+PiAyXSA9IChzdGF0LmN0aW1lLmdldFRpbWUoKSAvIDFlMykgfCAwOwogICAgICAgIEhFQVAzMlsoYnVmICsgNjgpID4+IDJdID0gMDsKICAgICAgICBIRUFQMzJbKGJ1ZiArIDcyKSA+PiAyXSA9IHN0YXQuaW5vOwogICAgICAgIHJldHVybiAwCiAgICAgIH0sCiAgICAgIGRvTXN5bmM6IGZ1bmN0aW9uIChhZGRyLCBzdHJlYW0sIGxlbiwgZmxhZ3MpIHsKICAgICAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoSEVBUFU4LnN1YmFycmF5KGFkZHIsIGFkZHIgKyBsZW4pKTsKICAgICAgICBGUy5tc3luYyhzdHJlYW0sIGJ1ZmZlciwgMCwgbGVuLCBmbGFncyk7CiAgICAgIH0sCiAgICAgIGRvTWtkaXI6IGZ1bmN0aW9uIChwYXRoLCBtb2RlKSB7CiAgICAgICAgcGF0aCA9IFBBVEgubm9ybWFsaXplKHBhdGgpOwogICAgICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcvJykgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHBhdGgubGVuZ3RoIC0gMSk7CiAgICAgICAgRlMubWtkaXIocGF0aCwgbW9kZSwgMCk7CiAgICAgICAgcmV0dXJuIDAKICAgICAgfSwKICAgICAgZG9Na25vZDogZnVuY3Rpb24gKHBhdGgsIG1vZGUsIGRldikgewogICAgICAgIHN3aXRjaCAobW9kZSAmIDYxNDQwKSB7CiAgICAgICAgICBjYXNlIDMyNzY4OgogICAgICAgICAgY2FzZSA4MTkyOgogICAgICAgICAgY2FzZSAyNDU3NjoKICAgICAgICAgIGNhc2UgNDA5NjoKICAgICAgICAgIGNhc2UgNDkxNTI6CiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICByZXR1cm4gLUVSUk5PX0NPREVTLkVJTlZBTAogICAgICAgIH0KICAgICAgICBGUy5ta25vZChwYXRoLCBtb2RlLCBkZXYpOwogICAgICAgIHJldHVybiAwCiAgICAgIH0sCiAgICAgIGRvUmVhZGxpbms6IGZ1bmN0aW9uIChwYXRoLCBidWYsIGJ1ZnNpemUpIHsKICAgICAgICBpZiAoYnVmc2l6ZSA8PSAwKSByZXR1cm4gLUVSUk5PX0NPREVTLkVJTlZBTAogICAgICAgIHZhciByZXQgPSBGUy5yZWFkbGluayhwYXRoKTsKICAgICAgICB2YXIgbGVuID0gTWF0aC5taW4oYnVmc2l6ZSwgbGVuZ3RoQnl0ZXNVVEY4KHJldCkpOwogICAgICAgIHZhciBlbmRDaGFyID0gSEVBUDhbYnVmICsgbGVuXTsKICAgICAgICBzdHJpbmdUb1VURjgocmV0LCBidWYsIGJ1ZnNpemUgKyAxKTsKICAgICAgICBIRUFQOFtidWYgKyBsZW5dID0gZW5kQ2hhcjsKICAgICAgICByZXR1cm4gbGVuCiAgICAgIH0sCiAgICAgIGRvQWNjZXNzOiBmdW5jdGlvbiAocGF0aCwgYW1vZGUpIHsKICAgICAgICBpZiAoYW1vZGUgJiB+NykgewogICAgICAgICAgcmV0dXJuIC1FUlJOT19DT0RFUy5FSU5WQUwKICAgICAgICB9CiAgICAgICAgdmFyIG5vZGU7CiAgICAgICAgdmFyIGxvb2t1cCA9IEZTLmxvb2t1cFBhdGgocGF0aCwgeyBmb2xsb3c6IHRydWUgfSk7CiAgICAgICAgbm9kZSA9IGxvb2t1cC5ub2RlOwogICAgICAgIHZhciBwZXJtcyA9ICcnOwogICAgICAgIGlmIChhbW9kZSAmIDQpIHBlcm1zICs9ICdyJzsKICAgICAgICBpZiAoYW1vZGUgJiAyKSBwZXJtcyArPSAndyc7CiAgICAgICAgaWYgKGFtb2RlICYgMSkgcGVybXMgKz0gJ3gnOwogICAgICAgIGlmIChwZXJtcyAmJiBGUy5ub2RlUGVybWlzc2lvbnMobm9kZSwgcGVybXMpKSB7CiAgICAgICAgICByZXR1cm4gLUVSUk5PX0NPREVTLkVBQ0NFUwogICAgICAgIH0KICAgICAgICByZXR1cm4gMAogICAgICB9LAogICAgICBkb0R1cDogZnVuY3Rpb24gKHBhdGgsIGZsYWdzLCBzdWdnZXN0RkQpIHsKICAgICAgICB2YXIgc3VnZ2VzdCA9IEZTLmdldFN0cmVhbShzdWdnZXN0RkQpOwogICAgICAgIGlmIChzdWdnZXN0KSBGUy5jbG9zZShzdWdnZXN0KTsKICAgICAgICByZXR1cm4gRlMub3BlbihwYXRoLCBmbGFncywgMCwgc3VnZ2VzdEZELCBzdWdnZXN0RkQpLmZkCiAgICAgIH0sCiAgICAgIGRvUmVhZHY6IGZ1bmN0aW9uIChzdHJlYW0sIGlvdiwgaW92Y250LCBvZmZzZXQpIHsKICAgICAgICB2YXIgcmV0ID0gMDsKICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlvdmNudDsgaSsrKSB7CiAgICAgICAgICB2YXIgcHRyID0gSEVBUDMyWyhpb3YgKyBpICogOCkgPj4gMl07CiAgICAgICAgICB2YXIgbGVuID0gSEVBUDMyWyhpb3YgKyAoaSAqIDggKyA0KSkgPj4gMl07CiAgICAgICAgICB2YXIgY3VyciA9IEZTLnJlYWQoc3RyZWFtLCBIRUFQOCwgcHRyLCBsZW4sIG9mZnNldCk7CiAgICAgICAgICBpZiAoY3VyciA8IDApIHJldHVybiAtMQogICAgICAgICAgcmV0ICs9IGN1cnI7CiAgICAgICAgICBpZiAoY3VyciA8IGxlbikgYnJlYWsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIHJldAogICAgICB9LAogICAgICBkb1dyaXRldjogZnVuY3Rpb24gKHN0cmVhbSwgaW92LCBpb3ZjbnQsIG9mZnNldCkgewogICAgICAgIHZhciByZXQgPSAwOwogICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW92Y250OyBpKyspIHsKICAgICAgICAgIHZhciBwdHIgPSBIRUFQMzJbKGlvdiArIGkgKiA4KSA+PiAyXTsKICAgICAgICAgIHZhciBsZW4gPSBIRUFQMzJbKGlvdiArIChpICogOCArIDQpKSA+PiAyXTsKICAgICAgICAgIHZhciBjdXJyID0gRlMud3JpdGUoc3RyZWFtLCBIRUFQOCwgcHRyLCBsZW4sIG9mZnNldCk7CiAgICAgICAgICBpZiAoY3VyciA8IDApIHJldHVybiAtMQogICAgICAgICAgcmV0ICs9IGN1cnI7CiAgICAgICAgfQogICAgICAgIHJldHVybiByZXQKICAgICAgfSwKICAgICAgdmFyYXJnczogMCwKICAgICAgZ2V0OiBmdW5jdGlvbiAodmFyYXJncykgewogICAgICAgIFNZU0NBTExTLnZhcmFyZ3MgKz0gNDsKICAgICAgICB2YXIgcmV0ID0gSEVBUDMyWyhTWVNDQUxMUy52YXJhcmdzIC0gNCkgPj4gMl07CiAgICAgICAgcmV0dXJuIHJldAogICAgICB9LAogICAgICBnZXRTdHI6IGZ1bmN0aW9uICgpIHsKICAgICAgICB2YXIgcmV0ID0gUG9pbnRlcl9zdHJpbmdpZnkoU1lTQ0FMTFMuZ2V0KCkpOwogICAgICAgIHJldHVybiByZXQKICAgICAgfSwKICAgICAgZ2V0U3RyZWFtRnJvbUZEOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgdmFyIHN0cmVhbSA9IEZTLmdldFN0cmVhbShTWVNDQUxMUy5nZXQoKSk7CiAgICAgICAgaWYgKCFzdHJlYW0pIHRocm93IG5ldyBGUy5FcnJub0Vycm9yKEVSUk5PX0NPREVTLkVCQURGKQogICAgICAgIHJldHVybiBzdHJlYW0KICAgICAgfSwKICAgICAgZ2V0U29ja2V0RnJvbUZEOiBmdW5jdGlvbiAoKSB7CiAgICAgICAgdmFyIHNvY2tldCA9IFNPQ0tGUy5nZXRTb2NrZXQoU1lTQ0FMTFMuZ2V0KCkpOwogICAgICAgIGlmICghc29ja2V0KSB0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihFUlJOT19DT0RFUy5FQkFERikKICAgICAgICByZXR1cm4gc29ja2V0CiAgICAgIH0sCiAgICAgIGdldFNvY2tldEFkZHJlc3M6IGZ1bmN0aW9uIChhbGxvd051bGwpIHsKICAgICAgICB2YXIgYWRkcnAgPSBTWVNDQUxMUy5nZXQoKSwKICAgICAgICAgIGFkZHJsZW4gPSBTWVNDQUxMUy5nZXQoKTsKICAgICAgICBpZiAoYWxsb3dOdWxsICYmIGFkZHJwID09PSAwKSByZXR1cm4gbnVsbAogICAgICAgIHZhciBpbmZvID0gX19yZWFkX3NvY2thZGRyKGFkZHJwLCBhZGRybGVuKTsKICAgICAgICBpZiAoaW5mby5lcnJubykgdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoaW5mby5lcnJubykKICAgICAgICBpbmZvLmFkZHIgPSBETlMubG9va3VwX2FkZHIoaW5mby5hZGRyKSB8fCBpbmZvLmFkZHI7CiAgICAgICAgcmV0dXJuIGluZm8KICAgICAgfSwKICAgICAgZ2V0NjQ6IGZ1bmN0aW9uICgpIHsKICAgICAgICB2YXIgbG93ID0gU1lTQ0FMTFMuZ2V0KCksCiAgICAgICAgICBoaWdoID0gU1lTQ0FMTFMuZ2V0KCk7CiAgICAgICAgaWYgKGxvdyA+PSAwKSBhc3NlcnQoaGlnaCA9PT0gMCk7CiAgICAgICAgZWxzZSBhc3NlcnQoaGlnaCA9PT0gLTEpOwogICAgICAgIHJldHVybiBsb3cKICAgICAgfSwKICAgICAgZ2V0WmVybzogZnVuY3Rpb24gKCkgewogICAgICAgIGFzc2VydChTWVNDQUxMUy5nZXQoKSA9PT0gMCk7CiAgICAgIH0sCiAgICB9OwogICAgZnVuY3Rpb24gX19fc3lzY2FsbDE0MCh3aGljaCwgdmFyYXJncykgewogICAgICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJnczsKICAgICAgdHJ5IHsKICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKCksCiAgICAgICAgICBvZmZzZXRfaGlnaCA9IFNZU0NBTExTLmdldCgpLAogICAgICAgICAgb2Zmc2V0X2xvdyA9IFNZU0NBTExTLmdldCgpLAogICAgICAgICAgcmVzdWx0ID0gU1lTQ0FMTFMuZ2V0KCksCiAgICAgICAgICB3aGVuY2UgPSBTWVNDQUxMUy5nZXQoKTsKICAgICAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0X2xvdzsKICAgICAgICBGUy5sbHNlZWsoc3RyZWFtLCBvZmZzZXQsIHdoZW5jZSk7CiAgICAgICAgSEVBUDMyW3Jlc3VsdCA+PiAyXSA9IHN0cmVhbS5wb3NpdGlvbjsKICAgICAgICBpZiAoc3RyZWFtLmdldGRlbnRzICYmIG9mZnNldCA9PT0gMCAmJiB3aGVuY2UgPT09IDApIHN0cmVhbS5nZXRkZW50cyA9IG51bGw7CiAgICAgICAgcmV0dXJuIDAKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTsKICAgICAgICByZXR1cm4gLWUuZXJybm8KICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gX19fc3lzY2FsbDE0NSh3aGljaCwgdmFyYXJncykgewogICAgICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJnczsKICAgICAgdHJ5IHsKICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKCksCiAgICAgICAgICBpb3YgPSBTWVNDQUxMUy5nZXQoKSwKICAgICAgICAgIGlvdmNudCA9IFNZU0NBTExTLmdldCgpOwogICAgICAgIHJldHVybiBTWVNDQUxMUy5kb1JlYWR2KHN0cmVhbSwgaW92LCBpb3ZjbnQpCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIEZTID09PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgYWJvcnQoZSk7CiAgICAgICAgcmV0dXJuIC1lLmVycm5vCiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIF9fX3N5c2NhbGwxNDYod2hpY2gsIHZhcmFyZ3MpIHsKICAgICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7CiAgICAgIHRyeSB7CiAgICAgICAgdmFyIHN0cmVhbSA9IFNZU0NBTExTLmdldFN0cmVhbUZyb21GRCgpLAogICAgICAgICAgaW92ID0gU1lTQ0FMTFMuZ2V0KCksCiAgICAgICAgICBpb3ZjbnQgPSBTWVNDQUxMUy5nZXQoKTsKICAgICAgICByZXR1cm4gU1lTQ0FMTFMuZG9Xcml0ZXYoc3RyZWFtLCBpb3YsIGlvdmNudCkKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTsKICAgICAgICByZXR1cm4gLWUuZXJybm8KICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gX19fc3lzY2FsbDE4Myh3aGljaCwgdmFyYXJncykgewogICAgICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJnczsKICAgICAgdHJ5IHsKICAgICAgICB2YXIgYnVmID0gU1lTQ0FMTFMuZ2V0KCksCiAgICAgICAgICBzaXplID0gU1lTQ0FMTFMuZ2V0KCk7CiAgICAgICAgaWYgKHNpemUgPT09IDApIHJldHVybiAtRVJSTk9fQ09ERVMuRUlOVkFMCiAgICAgICAgdmFyIGN3ZCA9IEZTLmN3ZCgpOwogICAgICAgIHZhciBjd2RMZW5ndGhJbkJ5dGVzID0gbGVuZ3RoQnl0ZXNVVEY4KGN3ZCk7CiAgICAgICAgaWYgKHNpemUgPCBjd2RMZW5ndGhJbkJ5dGVzICsgMSkgcmV0dXJuIC1FUlJOT19DT0RFUy5FUkFOR0UKICAgICAgICBzdHJpbmdUb1VURjgoY3dkLCBidWYsIHNpemUpOwogICAgICAgIHJldHVybiBidWYKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTsKICAgICAgICByZXR1cm4gLWUuZXJybm8KICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gX19fc3lzY2FsbDE5OCh3aGljaCwgdmFyYXJncykgewogICAgICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJnczsKICAgICAgdHJ5IHsKICAgICAgICB2YXIgcGF0aCA9IFNZU0NBTExTLmdldFN0cigpLAogICAgICAgICAgb3duZXIgPSBTWVNDQUxMUy5nZXQoKSwKICAgICAgICAgIGdyb3VwID0gU1lTQ0FMTFMuZ2V0KCk7CiAgICAgICAgRlMuY2hvd24ocGF0aCwgb3duZXIsIGdyb3VwKTsKICAgICAgICByZXR1cm4gMAogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIGFib3J0KGUpOwogICAgICAgIHJldHVybiAtZS5lcnJubwogICAgICB9CiAgICB9CiAgICB2YXIgUFJPQ0lORk8gPSB7IHBwaWQ6IDEsIHBpZDogNDIsIHNpZDogNDIsIHBnaWQ6IDQyIH07CiAgICBmdW5jdGlvbiBfX19zeXNjYWxsMjAod2hpY2gsIHZhcmFyZ3MpIHsKICAgICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7CiAgICAgIHRyeSB7CiAgICAgICAgcmV0dXJuIFBST0NJTkZPLnBpZAogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIGFib3J0KGUpOwogICAgICAgIHJldHVybiAtZS5lcnJubwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBfX19zeXNjYWxsNih3aGljaCwgdmFyYXJncykgewogICAgICBTWVNDQUxMUy52YXJhcmdzID0gdmFyYXJnczsKICAgICAgdHJ5IHsKICAgICAgICB2YXIgc3RyZWFtID0gU1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKCk7CiAgICAgICAgRlMuY2xvc2Uoc3RyZWFtKTsKICAgICAgICByZXR1cm4gMAogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIGFib3J0KGUpOwogICAgICAgIHJldHVybiAtZS5lcnJubwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBfX19zeXNjYWxsNjAod2hpY2gsIHZhcmFyZ3MpIHsKICAgICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7CiAgICAgIHRyeSB7CiAgICAgICAgdmFyIG1hc2sgPSBTWVNDQUxMUy5nZXQoKTsKICAgICAgICB2YXIgb2xkID0gU1lTQ0FMTFMudW1hc2s7CiAgICAgICAgU1lTQ0FMTFMudW1hc2sgPSBtYXNrOwogICAgICAgIHJldHVybiBvbGQKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgRlMgPT09ICd1bmRlZmluZWQnIHx8ICEoZSBpbnN0YW5jZW9mIEZTLkVycm5vRXJyb3IpKSBhYm9ydChlKTsKICAgICAgICByZXR1cm4gLWUuZXJybm8KICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gX19fc3lzY2FsbDgzKHdoaWNoLCB2YXJhcmdzKSB7CiAgICAgIFNZU0NBTExTLnZhcmFyZ3MgPSB2YXJhcmdzOwogICAgICB0cnkgewogICAgICAgIHZhciB0YXJnZXQgPSBTWVNDQUxMUy5nZXRTdHIoKSwKICAgICAgICAgIGxpbmtwYXRoID0gU1lTQ0FMTFMuZ2V0U3RyKCk7CiAgICAgICAgRlMuc3ltbGluayh0YXJnZXQsIGxpbmtwYXRoKTsKICAgICAgICByZXR1cm4gMAogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBGUyA9PT0gJ3VuZGVmaW5lZCcgfHwgIShlIGluc3RhbmNlb2YgRlMuRXJybm9FcnJvcikpIGFib3J0KGUpOwogICAgICAgIHJldHVybiAtZS5lcnJubwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBfX19zeXNjYWxsOTEod2hpY2gsIHZhcmFyZ3MpIHsKICAgICAgU1lTQ0FMTFMudmFyYXJncyA9IHZhcmFyZ3M7CiAgICAgIHRyeSB7CiAgICAgICAgdmFyIGFkZHIgPSBTWVNDQUxMUy5nZXQoKSwKICAgICAgICAgIGxlbiA9IFNZU0NBTExTLmdldCgpOwogICAgICAgIHZhciBpbmZvID0gU1lTQ0FMTFMubWFwcGluZ3NbYWRkcl07CiAgICAgICAgaWYgKCFpbmZvKSByZXR1cm4gMAogICAgICAgIGlmIChsZW4gPT09IGluZm8ubGVuKSB7CiAgICAgICAgICB2YXIgc3RyZWFtID0gRlMuZ2V0U3RyZWFtKGluZm8uZmQpOwogICAgICAgICAgU1lTQ0FMTFMuZG9Nc3luYyhhZGRyLCBzdHJlYW0sIGxlbiwgaW5mby5mbGFncyk7CiAgICAgICAgICBGUy5tdW5tYXAoc3RyZWFtKTsKICAgICAgICAgIFNZU0NBTExTLm1hcHBpbmdzW2FkZHJdID0gbnVsbDsKICAgICAgICAgIGlmIChpbmZvLmFsbG9jYXRlZCkgewogICAgICAgICAgICBfZnJlZShpbmZvLm1hbGxvYyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHJldHVybiAwCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIEZTID09PSAndW5kZWZpbmVkJyB8fCAhKGUgaW5zdGFuY2VvZiBGUy5FcnJub0Vycm9yKSkgYWJvcnQoZSk7CiAgICAgICAgcmV0dXJuIC1lLmVycm5vCiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIF9fX3VubG9jaygpIHt9CiAgICB2YXIgc3RydWN0UmVnaXN0cmF0aW9ucyA9IHt9OwogICAgZnVuY3Rpb24gcnVuRGVzdHJ1Y3RvcnMoZGVzdHJ1Y3RvcnMpIHsKICAgICAgd2hpbGUgKGRlc3RydWN0b3JzLmxlbmd0aCkgewogICAgICAgIHZhciBwdHIgPSBkZXN0cnVjdG9ycy5wb3AoKTsKICAgICAgICB2YXIgZGVsID0gZGVzdHJ1Y3RvcnMucG9wKCk7CiAgICAgICAgZGVsKHB0cik7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIHNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyKHBvaW50ZXIpIHsKICAgICAgcmV0dXJuIHRoaXNbJ2Zyb21XaXJlVHlwZSddKEhFQVBVMzJbcG9pbnRlciA+PiAyXSkKICAgIH0KICAgIHZhciBhd2FpdGluZ0RlcGVuZGVuY2llcyA9IHt9OwogICAgdmFyIHJlZ2lzdGVyZWRUeXBlcyA9IHt9OwogICAgdmFyIHR5cGVEZXBlbmRlbmNpZXMgPSB7fTsKICAgIHZhciBjaGFyXzAgPSA0ODsKICAgIHZhciBjaGFyXzkgPSA1NzsKICAgIGZ1bmN0aW9uIG1ha2VMZWdhbEZ1bmN0aW9uTmFtZShuYW1lKSB7CiAgICAgIGlmICh1bmRlZmluZWQgPT09IG5hbWUpIHsKICAgICAgICByZXR1cm4gJ191bmtub3duJwogICAgICB9CiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1teYS16QS1aMC05X10vZywgJyQnKTsKICAgICAgdmFyIGYgPSBuYW1lLmNoYXJDb2RlQXQoMCk7CiAgICAgIGlmIChmID49IGNoYXJfMCAmJiBmIDw9IGNoYXJfOSkgewogICAgICAgIHJldHVybiAnXycgKyBuYW1lCiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIG5hbWUKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gY3JlYXRlTmFtZWRGdW5jdGlvbihuYW1lLCBib2R5KSB7CiAgICAgIG5hbWUgPSBtYWtlTGVnYWxGdW5jdGlvbk5hbWUobmFtZSk7CiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oCiAgICAgICAgJ2JvZHknLAogICAgICAgICdyZXR1cm4gZnVuY3Rpb24gJyArIG5hbWUgKyAnKCkge1xuJyArICcgICAgInVzZSBzdHJpY3QiOycgKyAnICAgIHJldHVybiBib2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4nICsgJ307XG4nCiAgICAgICkoYm9keSkKICAgIH0KICAgIGZ1bmN0aW9uIGV4dGVuZEVycm9yKGJhc2VFcnJvclR5cGUsIGVycm9yTmFtZSkgewogICAgICB2YXIgZXJyb3JDbGFzcyA9IGNyZWF0ZU5hbWVkRnVuY3Rpb24oZXJyb3JOYW1lLCBmdW5jdGlvbiAobWVzc2FnZSkgewogICAgICAgIHRoaXMubmFtZSA9IGVycm9yTmFtZTsKICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlOwogICAgICAgIHZhciBzdGFjayA9IG5ldyBFcnJvcihtZXNzYWdlKS5zdGFjazsKICAgICAgICBpZiAoc3RhY2sgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgdGhpcy5zdGFjayA9IHRoaXMudG9TdHJpbmcoKSArICdcbicgKyBzdGFjay5yZXBsYWNlKC9eRXJyb3IoOlteXG5dKik/XG4vLCAnJyk7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgZXJyb3JDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGJhc2VFcnJvclR5cGUucHJvdG90eXBlKTsKICAgICAgZXJyb3JDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBlcnJvckNsYXNzOwogICAgICBlcnJvckNsYXNzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsKICAgICAgICBpZiAodGhpcy5tZXNzYWdlID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgIHJldHVybiB0aGlzLm5hbWUKICAgICAgICB9IGVsc2UgewogICAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArICc6ICcgKyB0aGlzLm1lc3NhZ2UKICAgICAgICB9CiAgICAgIH07CiAgICAgIHJldHVybiBlcnJvckNsYXNzCiAgICB9CiAgICB2YXIgSW50ZXJuYWxFcnJvciA9IHVuZGVmaW5lZDsKICAgIGZ1bmN0aW9uIHRocm93SW50ZXJuYWxFcnJvcihtZXNzYWdlKSB7CiAgICAgIHRocm93IG5ldyBJbnRlcm5hbEVycm9yKG1lc3NhZ2UpCiAgICB9CiAgICBmdW5jdGlvbiB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChteVR5cGVzLCBkZXBlbmRlbnRUeXBlcywgZ2V0VHlwZUNvbnZlcnRlcnMpIHsKICAgICAgbXlUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7CiAgICAgICAgdHlwZURlcGVuZGVuY2llc1t0eXBlXSA9IGRlcGVuZGVudFR5cGVzOwogICAgICB9KTsKICAgICAgZnVuY3Rpb24gb25Db21wbGV0ZSh0eXBlQ29udmVydGVycykgewogICAgICAgIHZhciBteVR5cGVDb252ZXJ0ZXJzID0gZ2V0VHlwZUNvbnZlcnRlcnModHlwZUNvbnZlcnRlcnMpOwogICAgICAgIGlmIChteVR5cGVDb252ZXJ0ZXJzLmxlbmd0aCAhPT0gbXlUeXBlcy5sZW5ndGgpIHsKICAgICAgICAgIHRocm93SW50ZXJuYWxFcnJvcignTWlzbWF0Y2hlZCB0eXBlIGNvbnZlcnRlciBjb3VudCcpOwogICAgICAgIH0KICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG15VHlwZXMubGVuZ3RoOyArK2kpIHsKICAgICAgICAgIHJlZ2lzdGVyVHlwZShteVR5cGVzW2ldLCBteVR5cGVDb252ZXJ0ZXJzW2ldKTsKICAgICAgICB9CiAgICAgIH0KICAgICAgdmFyIHR5cGVDb252ZXJ0ZXJzID0gbmV3IEFycmF5KGRlcGVuZGVudFR5cGVzLmxlbmd0aCk7CiAgICAgIHZhciB1bnJlZ2lzdGVyZWRUeXBlcyA9IFtdOwogICAgICB2YXIgcmVnaXN0ZXJlZCA9IDA7CiAgICAgIGRlcGVuZGVudFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKGR0LCBpKSB7CiAgICAgICAgaWYgKHJlZ2lzdGVyZWRUeXBlcy5oYXNPd25Qcm9wZXJ0eShkdCkpIHsKICAgICAgICAgIHR5cGVDb252ZXJ0ZXJzW2ldID0gcmVnaXN0ZXJlZFR5cGVzW2R0XTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdW5yZWdpc3RlcmVkVHlwZXMucHVzaChkdCk7CiAgICAgICAgICBpZiAoIWF3YWl0aW5nRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KGR0KSkgewogICAgICAgICAgICBhd2FpdGluZ0RlcGVuZGVuY2llc1tkdF0gPSBbXTsKICAgICAgICAgIH0KICAgICAgICAgIGF3YWl0aW5nRGVwZW5kZW5jaWVzW2R0XS5wdXNoKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgdHlwZUNvbnZlcnRlcnNbaV0gPSByZWdpc3RlcmVkVHlwZXNbZHRdOwogICAgICAgICAgICArK3JlZ2lzdGVyZWQ7CiAgICAgICAgICAgIGlmIChyZWdpc3RlcmVkID09PSB1bnJlZ2lzdGVyZWRUeXBlcy5sZW5ndGgpIHsKICAgICAgICAgICAgICBvbkNvbXBsZXRlKHR5cGVDb252ZXJ0ZXJzKTsKICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICB9KTsKICAgICAgaWYgKDAgPT09IHVucmVnaXN0ZXJlZFR5cGVzLmxlbmd0aCkgewogICAgICAgIG9uQ29tcGxldGUodHlwZUNvbnZlcnRlcnMpOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBfX2VtYmluZF9maW5hbGl6ZV92YWx1ZV9vYmplY3Qoc3RydWN0VHlwZSkgewogICAgICB2YXIgcmVnID0gc3RydWN0UmVnaXN0cmF0aW9uc1tzdHJ1Y3RUeXBlXTsKICAgICAgZGVsZXRlIHN0cnVjdFJlZ2lzdHJhdGlvbnNbc3RydWN0VHlwZV07CiAgICAgIHZhciByYXdDb25zdHJ1Y3RvciA9IHJlZy5yYXdDb25zdHJ1Y3RvcjsKICAgICAgdmFyIHJhd0Rlc3RydWN0b3IgPSByZWcucmF3RGVzdHJ1Y3RvcjsKICAgICAgdmFyIGZpZWxkUmVjb3JkcyA9IHJlZy5maWVsZHM7CiAgICAgIHZhciBmaWVsZFR5cGVzID0gZmllbGRSZWNvcmRzCiAgICAgICAgLm1hcChmdW5jdGlvbiAoZmllbGQpIHsKICAgICAgICAgIHJldHVybiBmaWVsZC5nZXR0ZXJSZXR1cm5UeXBlCiAgICAgICAgfSkKICAgICAgICAuY29uY2F0KAogICAgICAgICAgZmllbGRSZWNvcmRzLm1hcChmdW5jdGlvbiAoZmllbGQpIHsKICAgICAgICAgICAgcmV0dXJuIGZpZWxkLnNldHRlckFyZ3VtZW50VHlwZQogICAgICAgICAgfSkKICAgICAgICApOwogICAgICB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbc3RydWN0VHlwZV0sIGZpZWxkVHlwZXMsIGZ1bmN0aW9uIChmaWVsZFR5cGVzKSB7CiAgICAgICAgdmFyIGZpZWxkcyA9IHt9OwogICAgICAgIGZpZWxkUmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCwgaSkgewogICAgICAgICAgdmFyIGZpZWxkTmFtZSA9IGZpZWxkLmZpZWxkTmFtZTsKICAgICAgICAgIHZhciBnZXR0ZXJSZXR1cm5UeXBlID0gZmllbGRUeXBlc1tpXTsKICAgICAgICAgIHZhciBnZXR0ZXIgPSBmaWVsZC5nZXR0ZXI7CiAgICAgICAgICB2YXIgZ2V0dGVyQ29udGV4dCA9IGZpZWxkLmdldHRlckNvbnRleHQ7CiAgICAgICAgICB2YXIgc2V0dGVyQXJndW1lbnRUeXBlID0gZmllbGRUeXBlc1tpICsgZmllbGRSZWNvcmRzLmxlbmd0aF07CiAgICAgICAgICB2YXIgc2V0dGVyID0gZmllbGQuc2V0dGVyOwogICAgICAgICAgdmFyIHNldHRlckNvbnRleHQgPSBmaWVsZC5zZXR0ZXJDb250ZXh0OwogICAgICAgICAgZmllbGRzW2ZpZWxkTmFtZV0gPSB7CiAgICAgICAgICAgIHJlYWQ6IGZ1bmN0aW9uIChwdHIpIHsKICAgICAgICAgICAgICByZXR1cm4gZ2V0dGVyUmV0dXJuVHlwZVsnZnJvbVdpcmVUeXBlJ10oZ2V0dGVyKGdldHRlckNvbnRleHQsIHB0cikpCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHdyaXRlOiBmdW5jdGlvbiAocHRyLCBvKSB7CiAgICAgICAgICAgICAgdmFyIGRlc3RydWN0b3JzID0gW107CiAgICAgICAgICAgICAgc2V0dGVyKHNldHRlckNvbnRleHQsIHB0ciwgc2V0dGVyQXJndW1lbnRUeXBlWyd0b1dpcmVUeXBlJ10oZGVzdHJ1Y3RvcnMsIG8pKTsKICAgICAgICAgICAgICBydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7CiAgICAgICAgICAgIH0sCiAgICAgICAgICB9OwogICAgICAgIH0pOwogICAgICAgIHJldHVybiBbCiAgICAgICAgICB7CiAgICAgICAgICAgIG5hbWU6IHJlZy5uYW1lLAogICAgICAgICAgICBmcm9tV2lyZVR5cGU6IGZ1bmN0aW9uIChwdHIpIHsKICAgICAgICAgICAgICB2YXIgcnYgPSB7fTsKICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGZpZWxkcykgewogICAgICAgICAgICAgICAgcnZbaV0gPSBmaWVsZHNbaV0ucmVhZChwdHIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByYXdEZXN0cnVjdG9yKHB0cik7CiAgICAgICAgICAgICAgcmV0dXJuIHJ2CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHRvV2lyZVR5cGU6IGZ1bmN0aW9uIChkZXN0cnVjdG9ycywgbykgewogICAgICAgICAgICAgIGZvciAodmFyIGZpZWxkTmFtZSBpbiBmaWVsZHMpIHsKICAgICAgICAgICAgICAgIGlmICghKGZpZWxkTmFtZSBpbiBvKSkgewogICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdNaXNzaW5nIGZpZWxkJykKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgdmFyIHB0ciA9IHJhd0NvbnN0cnVjdG9yKCk7CiAgICAgICAgICAgICAgZm9yIChmaWVsZE5hbWUgaW4gZmllbGRzKSB7CiAgICAgICAgICAgICAgICBmaWVsZHNbZmllbGROYW1lXS53cml0ZShwdHIsIG9bZmllbGROYW1lXSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmIChkZXN0cnVjdG9ycyAhPT0gbnVsbCkgewogICAgICAgICAgICAgICAgZGVzdHJ1Y3RvcnMucHVzaChyYXdEZXN0cnVjdG9yLCBwdHIpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gcHRyCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGFyZ1BhY2tBZHZhbmNlOiA4LAogICAgICAgICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogc2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIsCiAgICAgICAgICAgIGRlc3RydWN0b3JGdW5jdGlvbjogcmF3RGVzdHJ1Y3RvciwKICAgICAgICAgIH0sCiAgICAgICAgXQogICAgICB9KTsKICAgIH0KICAgIGZ1bmN0aW9uIGdldFNoaWZ0RnJvbVNpemUoc2l6ZSkgewogICAgICBzd2l0Y2ggKHNpemUpIHsKICAgICAgICBjYXNlIDE6CiAgICAgICAgICByZXR1cm4gMAogICAgICAgIGNhc2UgMjoKICAgICAgICAgIHJldHVybiAxCiAgICAgICAgY2FzZSA0OgogICAgICAgICAgcmV0dXJuIDIKICAgICAgICBjYXNlIDg6CiAgICAgICAgICByZXR1cm4gMwogICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIHR5cGUgc2l6ZTogJyArIHNpemUpCiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGVtYmluZF9pbml0X2NoYXJDb2RlcygpIHsKICAgICAgdmFyIGNvZGVzID0gbmV3IEFycmF5KDI1Nik7CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHsKICAgICAgICBjb2Rlc1tpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7CiAgICAgIH0KICAgICAgZW1iaW5kX2NoYXJDb2RlcyA9IGNvZGVzOwogICAgfQogICAgdmFyIGVtYmluZF9jaGFyQ29kZXMgPSB1bmRlZmluZWQ7CiAgICBmdW5jdGlvbiByZWFkTGF0aW4xU3RyaW5nKHB0cikgewogICAgICB2YXIgcmV0ID0gJyc7CiAgICAgIHZhciBjID0gcHRyOwogICAgICB3aGlsZSAoSEVBUFU4W2NdKSB7CiAgICAgICAgcmV0ICs9IGVtYmluZF9jaGFyQ29kZXNbSEVBUFU4W2MrK11dOwogICAgICB9CiAgICAgIHJldHVybiByZXQKICAgIH0KICAgIHZhciBCaW5kaW5nRXJyb3IgPSB1bmRlZmluZWQ7CiAgICBmdW5jdGlvbiB0aHJvd0JpbmRpbmdFcnJvcihtZXNzYWdlKSB7CiAgICAgIHRocm93IG5ldyBCaW5kaW5nRXJyb3IobWVzc2FnZSkKICAgIH0KICAgIGZ1bmN0aW9uIHJlZ2lzdGVyVHlwZShyYXdUeXBlLCByZWdpc3RlcmVkSW5zdGFuY2UsIG9wdGlvbnMpIHsKICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307CiAgICAgIGlmICghKCdhcmdQYWNrQWR2YW5jZScgaW4gcmVnaXN0ZXJlZEluc3RhbmNlKSkgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlZ2lzdGVyVHlwZSByZWdpc3RlcmVkSW5zdGFuY2UgcmVxdWlyZXMgYXJnUGFja0FkdmFuY2UnKQogICAgICB9CiAgICAgIHZhciBuYW1lID0gcmVnaXN0ZXJlZEluc3RhbmNlLm5hbWU7CiAgICAgIGlmICghcmF3VHlwZSkgewogICAgICAgIHRocm93QmluZGluZ0Vycm9yKCd0eXBlICInICsgbmFtZSArICciIG11c3QgaGF2ZSBhIHBvc2l0aXZlIGludGVnZXIgdHlwZWlkIHBvaW50ZXInKTsKICAgICAgfQogICAgICBpZiAocmVnaXN0ZXJlZFR5cGVzLmhhc093blByb3BlcnR5KHJhd1R5cGUpKSB7CiAgICAgICAgaWYgKG9wdGlvbnMuaWdub3JlRHVwbGljYXRlUmVnaXN0cmF0aW9ucykgewogICAgICAgICAgcmV0dXJuCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKCJDYW5ub3QgcmVnaXN0ZXIgdHlwZSAnIiArIG5hbWUgKyAiJyB0d2ljZSIpOwogICAgICAgIH0KICAgICAgfQogICAgICByZWdpc3RlcmVkVHlwZXNbcmF3VHlwZV0gPSByZWdpc3RlcmVkSW5zdGFuY2U7CiAgICAgIGRlbGV0ZSB0eXBlRGVwZW5kZW5jaWVzW3Jhd1R5cGVdOwogICAgICBpZiAoYXdhaXRpbmdEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocmF3VHlwZSkpIHsKICAgICAgICB2YXIgY2FsbGJhY2tzID0gYXdhaXRpbmdEZXBlbmRlbmNpZXNbcmF3VHlwZV07CiAgICAgICAgZGVsZXRlIGF3YWl0aW5nRGVwZW5kZW5jaWVzW3Jhd1R5cGVdOwogICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uIChjYikgewogICAgICAgICAgY2IoKTsKICAgICAgICB9KTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfYm9vbChyYXdUeXBlLCBuYW1lLCBzaXplLCB0cnVlVmFsdWUsIGZhbHNlVmFsdWUpIHsKICAgICAgdmFyIHNoaWZ0ID0gZ2V0U2hpZnRGcm9tU2l6ZShzaXplKTsKICAgICAgbmFtZSA9IHJlYWRMYXRpbjFTdHJpbmcobmFtZSk7CiAgICAgIHJlZ2lzdGVyVHlwZShyYXdUeXBlLCB7CiAgICAgICAgbmFtZTogbmFtZSwKICAgICAgICBmcm9tV2lyZVR5cGU6IGZ1bmN0aW9uICh3dCkgewogICAgICAgICAgcmV0dXJuICEhd3QKICAgICAgICB9LAogICAgICAgIHRvV2lyZVR5cGU6IGZ1bmN0aW9uIChkZXN0cnVjdG9ycywgbykgewogICAgICAgICAgcmV0dXJuIG8gPyB0cnVlVmFsdWUgOiBmYWxzZVZhbHVlCiAgICAgICAgfSwKICAgICAgICBhcmdQYWNrQWR2YW5jZTogOCwKICAgICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogZnVuY3Rpb24gKHBvaW50ZXIpIHsKICAgICAgICAgIHZhciBoZWFwOwogICAgICAgICAgaWYgKHNpemUgPT09IDEpIHsKICAgICAgICAgICAgaGVhcCA9IEhFQVA4OwogICAgICAgICAgfSBlbHNlIGlmIChzaXplID09PSAyKSB7CiAgICAgICAgICAgIGhlYXAgPSBIRUFQMTY7CiAgICAgICAgICB9IGVsc2UgaWYgKHNpemUgPT09IDQpIHsKICAgICAgICAgICAgaGVhcCA9IEhFQVAzMjsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gYm9vbGVhbiB0eXBlIHNpemU6ICcgKyBuYW1lKQogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHRoaXNbJ2Zyb21XaXJlVHlwZSddKGhlYXBbcG9pbnRlciA+PiBzaGlmdF0pCiAgICAgICAgfSwKICAgICAgICBkZXN0cnVjdG9yRnVuY3Rpb246IG51bGwsCiAgICAgIH0pOwogICAgfQogICAgZnVuY3Rpb24gQ2xhc3NIYW5kbGVfaXNBbGlhc09mKG90aGVyKSB7CiAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDbGFzc0hhbmRsZSkpIHsKICAgICAgICByZXR1cm4gZmFsc2UKICAgICAgfQogICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIENsYXNzSGFuZGxlKSkgewogICAgICAgIHJldHVybiBmYWxzZQogICAgICB9CiAgICAgIHZhciBsZWZ0Q2xhc3MgPSB0aGlzLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzOwogICAgICB2YXIgbGVmdCA9IHRoaXMuJCQucHRyOwogICAgICB2YXIgcmlnaHRDbGFzcyA9IG90aGVyLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzOwogICAgICB2YXIgcmlnaHQgPSBvdGhlci4kJC5wdHI7CiAgICAgIHdoaWxlIChsZWZ0Q2xhc3MuYmFzZUNsYXNzKSB7CiAgICAgICAgbGVmdCA9IGxlZnRDbGFzcy51cGNhc3QobGVmdCk7CiAgICAgICAgbGVmdENsYXNzID0gbGVmdENsYXNzLmJhc2VDbGFzczsKICAgICAgfQogICAgICB3aGlsZSAocmlnaHRDbGFzcy5iYXNlQ2xhc3MpIHsKICAgICAgICByaWdodCA9IHJpZ2h0Q2xhc3MudXBjYXN0KHJpZ2h0KTsKICAgICAgICByaWdodENsYXNzID0gcmlnaHRDbGFzcy5iYXNlQ2xhc3M7CiAgICAgIH0KICAgICAgcmV0dXJuIGxlZnRDbGFzcyA9PT0gcmlnaHRDbGFzcyAmJiBsZWZ0ID09PSByaWdodAogICAgfQogICAgZnVuY3Rpb24gc2hhbGxvd0NvcHlJbnRlcm5hbFBvaW50ZXIobykgewogICAgICByZXR1cm4gewogICAgICAgIGNvdW50OiBvLmNvdW50LAogICAgICAgIGRlbGV0ZVNjaGVkdWxlZDogby5kZWxldGVTY2hlZHVsZWQsCiAgICAgICAgcHJlc2VydmVQb2ludGVyT25EZWxldGU6IG8ucHJlc2VydmVQb2ludGVyT25EZWxldGUsCiAgICAgICAgcHRyOiBvLnB0ciwKICAgICAgICBwdHJUeXBlOiBvLnB0clR5cGUsCiAgICAgICAgc21hcnRQdHI6IG8uc21hcnRQdHIsCiAgICAgICAgc21hcnRQdHJUeXBlOiBvLnNtYXJ0UHRyVHlwZSwKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gdGhyb3dJbnN0YW5jZUFscmVhZHlEZWxldGVkKG9iaikgewogICAgICBmdW5jdGlvbiBnZXRJbnN0YW5jZVR5cGVOYW1lKGhhbmRsZSkgewogICAgICAgIHJldHVybiBoYW5kbGUuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3MubmFtZQogICAgICB9CiAgICAgIHRocm93QmluZGluZ0Vycm9yKGdldEluc3RhbmNlVHlwZU5hbWUob2JqKSArICcgaW5zdGFuY2UgYWxyZWFkeSBkZWxldGVkJyk7CiAgICB9CiAgICBmdW5jdGlvbiBDbGFzc0hhbmRsZV9jbG9uZSgpIHsKICAgICAgaWYgKCF0aGlzLiQkLnB0cikgewogICAgICAgIHRocm93SW5zdGFuY2VBbHJlYWR5RGVsZXRlZCh0aGlzKTsKICAgICAgfQogICAgICBpZiAodGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSkgewogICAgICAgIHRoaXMuJCQuY291bnQudmFsdWUgKz0gMTsKICAgICAgICByZXR1cm4gdGhpcwogICAgICB9IGVsc2UgewogICAgICAgIHZhciBjbG9uZSA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLCB7ICQkOiB7IHZhbHVlOiBzaGFsbG93Q29weUludGVybmFsUG9pbnRlcih0aGlzLiQkKSB9IH0pOwogICAgICAgIGNsb25lLiQkLmNvdW50LnZhbHVlICs9IDE7CiAgICAgICAgY2xvbmUuJCQuZGVsZXRlU2NoZWR1bGVkID0gZmFsc2U7CiAgICAgICAgcmV0dXJuIGNsb25lCiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIHJ1bkRlc3RydWN0b3IoaGFuZGxlKSB7CiAgICAgIHZhciAkJCA9IGhhbmRsZS4kJDsKICAgICAgaWYgKCQkLnNtYXJ0UHRyKSB7CiAgICAgICAgJCQuc21hcnRQdHJUeXBlLnJhd0Rlc3RydWN0b3IoJCQuc21hcnRQdHIpOwogICAgICB9IGVsc2UgewogICAgICAgICQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzLnJhd0Rlc3RydWN0b3IoJCQucHRyKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gQ2xhc3NIYW5kbGVfZGVsZXRlKCkgewogICAgICBpZiAoIXRoaXMuJCQucHRyKSB7CiAgICAgICAgdGhyb3dJbnN0YW5jZUFscmVhZHlEZWxldGVkKHRoaXMpOwogICAgICB9CiAgICAgIGlmICh0aGlzLiQkLmRlbGV0ZVNjaGVkdWxlZCAmJiAhdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSkgewogICAgICAgIHRocm93QmluZGluZ0Vycm9yKCdPYmplY3QgYWxyZWFkeSBzY2hlZHVsZWQgZm9yIGRlbGV0aW9uJyk7CiAgICAgIH0KICAgICAgdGhpcy4kJC5jb3VudC52YWx1ZSAtPSAxOwogICAgICB2YXIgdG9EZWxldGUgPSAwID09PSB0aGlzLiQkLmNvdW50LnZhbHVlOwogICAgICBpZiAodG9EZWxldGUpIHsKICAgICAgICBydW5EZXN0cnVjdG9yKHRoaXMpOwogICAgICB9CiAgICAgIGlmICghdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSkgewogICAgICAgIHRoaXMuJCQuc21hcnRQdHIgPSB1bmRlZmluZWQ7CiAgICAgICAgdGhpcy4kJC5wdHIgPSB1bmRlZmluZWQ7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIENsYXNzSGFuZGxlX2lzRGVsZXRlZCgpIHsKICAgICAgcmV0dXJuICF0aGlzLiQkLnB0cgogICAgfQogICAgdmFyIGRlbGF5RnVuY3Rpb24gPSB1bmRlZmluZWQ7CiAgICB2YXIgZGVsZXRpb25RdWV1ZSA9IFtdOwogICAgZnVuY3Rpb24gZmx1c2hQZW5kaW5nRGVsZXRlcygpIHsKICAgICAgd2hpbGUgKGRlbGV0aW9uUXVldWUubGVuZ3RoKSB7CiAgICAgICAgdmFyIG9iaiA9IGRlbGV0aW9uUXVldWUucG9wKCk7CiAgICAgICAgb2JqLiQkLmRlbGV0ZVNjaGVkdWxlZCA9IGZhbHNlOwogICAgICAgIG9ialsnZGVsZXRlJ10oKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gQ2xhc3NIYW5kbGVfZGVsZXRlTGF0ZXIoKSB7CiAgICAgIGlmICghdGhpcy4kJC5wdHIpIHsKICAgICAgICB0aHJvd0luc3RhbmNlQWxyZWFkeURlbGV0ZWQodGhpcyk7CiAgICAgIH0KICAgICAgaWYgKHRoaXMuJCQuZGVsZXRlU2NoZWR1bGVkICYmICF0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlKSB7CiAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoJ09iamVjdCBhbHJlYWR5IHNjaGVkdWxlZCBmb3IgZGVsZXRpb24nKTsKICAgICAgfQogICAgICBkZWxldGlvblF1ZXVlLnB1c2godGhpcyk7CiAgICAgIGlmIChkZWxldGlvblF1ZXVlLmxlbmd0aCA9PT0gMSAmJiBkZWxheUZ1bmN0aW9uKSB7CiAgICAgICAgZGVsYXlGdW5jdGlvbihmbHVzaFBlbmRpbmdEZWxldGVzKTsKICAgICAgfQogICAgICB0aGlzLiQkLmRlbGV0ZVNjaGVkdWxlZCA9IHRydWU7CiAgICAgIHJldHVybiB0aGlzCiAgICB9CiAgICBmdW5jdGlvbiBpbml0X0NsYXNzSGFuZGxlKCkgewogICAgICBDbGFzc0hhbmRsZS5wcm90b3R5cGVbJ2lzQWxpYXNPZiddID0gQ2xhc3NIYW5kbGVfaXNBbGlhc09mOwogICAgICBDbGFzc0hhbmRsZS5wcm90b3R5cGVbJ2Nsb25lJ10gPSBDbGFzc0hhbmRsZV9jbG9uZTsKICAgICAgQ2xhc3NIYW5kbGUucHJvdG90eXBlWydkZWxldGUnXSA9IENsYXNzSGFuZGxlX2RlbGV0ZTsKICAgICAgQ2xhc3NIYW5kbGUucHJvdG90eXBlWydpc0RlbGV0ZWQnXSA9IENsYXNzSGFuZGxlX2lzRGVsZXRlZDsKICAgICAgQ2xhc3NIYW5kbGUucHJvdG90eXBlWydkZWxldGVMYXRlciddID0gQ2xhc3NIYW5kbGVfZGVsZXRlTGF0ZXI7CiAgICB9CiAgICBmdW5jdGlvbiBDbGFzc0hhbmRsZSgpIHt9CiAgICB2YXIgcmVnaXN0ZXJlZFBvaW50ZXJzID0ge307CiAgICBmdW5jdGlvbiBlbnN1cmVPdmVybG9hZFRhYmxlKHByb3RvLCBtZXRob2ROYW1lLCBodW1hbk5hbWUpIHsKICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gcHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZSkgewogICAgICAgIHZhciBwcmV2RnVuYyA9IHByb3RvW21ldGhvZE5hbWVdOwogICAgICAgIHByb3RvW21ldGhvZE5hbWVdID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgaWYgKCFwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlLmhhc093blByb3BlcnR5KGFyZ3VtZW50cy5sZW5ndGgpKSB7CiAgICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKAogICAgICAgICAgICAgICJGdW5jdGlvbiAnIiArCiAgICAgICAgICAgICAgICBodW1hbk5hbWUgKwogICAgICAgICAgICAgICAgIicgY2FsbGVkIHdpdGggYW4gaW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzICgiICsKICAgICAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGggKwogICAgICAgICAgICAgICAgJykgLSBleHBlY3RzIG9uZSBvZiAoJyArCiAgICAgICAgICAgICAgICBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlICsKICAgICAgICAgICAgICAgICcpIScKICAgICAgICAgICAgKTsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW2FyZ3VtZW50cy5sZW5ndGhdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykKICAgICAgICB9OwogICAgICAgIHByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGUgPSBbXTsKICAgICAgICBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW3ByZXZGdW5jLmFyZ0NvdW50XSA9IHByZXZGdW5jOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBleHBvc2VQdWJsaWNTeW1ib2wobmFtZSwgdmFsdWUsIG51bUFyZ3VtZW50cykgewogICAgICBpZiAoTW9kdWxlLmhhc093blByb3BlcnR5KG5hbWUpKSB7CiAgICAgICAgaWYgKAogICAgICAgICAgdW5kZWZpbmVkID09PSBudW1Bcmd1bWVudHMgfHwKICAgICAgICAgICh1bmRlZmluZWQgIT09IE1vZHVsZVtuYW1lXS5vdmVybG9hZFRhYmxlICYmIHVuZGVmaW5lZCAhPT0gTW9kdWxlW25hbWVdLm92ZXJsb2FkVGFibGVbbnVtQXJndW1lbnRzXSkKICAgICAgICApIHsKICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKCJDYW5ub3QgcmVnaXN0ZXIgcHVibGljIG5hbWUgJyIgKyBuYW1lICsgIicgdHdpY2UiKTsKICAgICAgICB9CiAgICAgICAgZW5zdXJlT3ZlcmxvYWRUYWJsZShNb2R1bGUsIG5hbWUsIG5hbWUpOwogICAgICAgIGlmIChNb2R1bGUuaGFzT3duUHJvcGVydHkobnVtQXJndW1lbnRzKSkgewogICAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoCiAgICAgICAgICAgICdDYW5ub3QgcmVnaXN0ZXIgbXVsdGlwbGUgb3ZlcmxvYWRzIG9mIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzICgnICsgbnVtQXJndW1lbnRzICsgJykhJwogICAgICAgICAgKTsKICAgICAgICB9CiAgICAgICAgTW9kdWxlW25hbWVdLm92ZXJsb2FkVGFibGVbbnVtQXJndW1lbnRzXSA9IHZhbHVlOwogICAgICB9IGVsc2UgewogICAgICAgIE1vZHVsZVtuYW1lXSA9IHZhbHVlOwogICAgICAgIGlmICh1bmRlZmluZWQgIT09IG51bUFyZ3VtZW50cykgewogICAgICAgICAgTW9kdWxlW25hbWVdLm51bUFyZ3VtZW50cyA9IG51bUFyZ3VtZW50czsKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIFJlZ2lzdGVyZWRDbGFzcygKICAgICAgbmFtZSwKICAgICAgY29uc3RydWN0b3IsCiAgICAgIGluc3RhbmNlUHJvdG90eXBlLAogICAgICByYXdEZXN0cnVjdG9yLAogICAgICBiYXNlQ2xhc3MsCiAgICAgIGdldEFjdHVhbFR5cGUsCiAgICAgIHVwY2FzdCwKICAgICAgZG93bmNhc3QKICAgICkgewogICAgICB0aGlzLm5hbWUgPSBuYW1lOwogICAgICB0aGlzLmNvbnN0cnVjdG9yID0gY29uc3RydWN0b3I7CiAgICAgIHRoaXMuaW5zdGFuY2VQcm90b3R5cGUgPSBpbnN0YW5jZVByb3RvdHlwZTsKICAgICAgdGhpcy5yYXdEZXN0cnVjdG9yID0gcmF3RGVzdHJ1Y3RvcjsKICAgICAgdGhpcy5iYXNlQ2xhc3MgPSBiYXNlQ2xhc3M7CiAgICAgIHRoaXMuZ2V0QWN0dWFsVHlwZSA9IGdldEFjdHVhbFR5cGU7CiAgICAgIHRoaXMudXBjYXN0ID0gdXBjYXN0OwogICAgICB0aGlzLmRvd25jYXN0ID0gZG93bmNhc3Q7CiAgICAgIHRoaXMucHVyZVZpcnR1YWxGdW5jdGlvbnMgPSBbXTsKICAgIH0KICAgIGZ1bmN0aW9uIHVwY2FzdFBvaW50ZXIocHRyLCBwdHJDbGFzcywgZGVzaXJlZENsYXNzKSB7CiAgICAgIHdoaWxlIChwdHJDbGFzcyAhPT0gZGVzaXJlZENsYXNzKSB7CiAgICAgICAgaWYgKCFwdHJDbGFzcy51cGNhc3QpIHsKICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKCdFeHBlY3RlZCBudWxsIG9yIGluc3RhbmNlIG9mICcgKyBkZXNpcmVkQ2xhc3MubmFtZSArICcsIGdvdCBhbiBpbnN0YW5jZSBvZiAnICsgcHRyQ2xhc3MubmFtZSk7CiAgICAgICAgfQogICAgICAgIHB0ciA9IHB0ckNsYXNzLnVwY2FzdChwdHIpOwogICAgICAgIHB0ckNsYXNzID0gcHRyQ2xhc3MuYmFzZUNsYXNzOwogICAgICB9CiAgICAgIHJldHVybiBwdHIKICAgIH0KICAgIGZ1bmN0aW9uIGNvbnN0Tm9TbWFydFB0clJhd1BvaW50ZXJUb1dpcmVUeXBlKGRlc3RydWN0b3JzLCBoYW5kbGUpIHsKICAgICAgaWYgKGhhbmRsZSA9PT0gbnVsbCkgewogICAgICAgIGlmICh0aGlzLmlzUmVmZXJlbmNlKSB7CiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignbnVsbCBpcyBub3QgYSB2YWxpZCAnICsgdGhpcy5uYW1lKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIDAKICAgICAgfQogICAgICBpZiAoIWhhbmRsZS4kJCkgewogICAgICAgIHRocm93QmluZGluZ0Vycm9yKCdDYW5ub3QgcGFzcyAiJyArIF9lbWJpbmRfcmVwcihoYW5kbGUpICsgJyIgYXMgYSAnICsgdGhpcy5uYW1lKTsKICAgICAgfQogICAgICBpZiAoIWhhbmRsZS4kJC5wdHIpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgJyArIHRoaXMubmFtZSk7CiAgICAgIH0KICAgICAgdmFyIGhhbmRsZUNsYXNzID0gaGFuZGxlLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzOwogICAgICB2YXIgcHRyID0gdXBjYXN0UG9pbnRlcihoYW5kbGUuJCQucHRyLCBoYW5kbGVDbGFzcywgdGhpcy5yZWdpc3RlcmVkQ2xhc3MpOwogICAgICByZXR1cm4gcHRyCiAgICB9CiAgICBmdW5jdGlvbiBnZW5lcmljUG9pbnRlclRvV2lyZVR5cGUoZGVzdHJ1Y3RvcnMsIGhhbmRsZSkgewogICAgICB2YXIgcHRyOwogICAgICBpZiAoaGFuZGxlID09PSBudWxsKSB7CiAgICAgICAgaWYgKHRoaXMuaXNSZWZlcmVuY2UpIHsKICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKCdudWxsIGlzIG5vdCBhIHZhbGlkICcgKyB0aGlzLm5hbWUpOwogICAgICAgIH0KICAgICAgICBpZiAodGhpcy5pc1NtYXJ0UG9pbnRlcikgewogICAgICAgICAgcHRyID0gdGhpcy5yYXdDb25zdHJ1Y3RvcigpOwogICAgICAgICAgaWYgKGRlc3RydWN0b3JzICE9PSBudWxsKSB7CiAgICAgICAgICAgIGRlc3RydWN0b3JzLnB1c2godGhpcy5yYXdEZXN0cnVjdG9yLCBwdHIpOwogICAgICAgICAgfQogICAgICAgICAgcmV0dXJuIHB0cgogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICByZXR1cm4gMAogICAgICAgIH0KICAgICAgfQogICAgICBpZiAoIWhhbmRsZS4kJCkgewogICAgICAgIHRocm93QmluZGluZ0Vycm9yKCdDYW5ub3QgcGFzcyAiJyArIF9lbWJpbmRfcmVwcihoYW5kbGUpICsgJyIgYXMgYSAnICsgdGhpcy5uYW1lKTsKICAgICAgfQogICAgICBpZiAoIWhhbmRsZS4kJC5wdHIpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgJyArIHRoaXMubmFtZSk7CiAgICAgIH0KICAgICAgaWYgKCF0aGlzLmlzQ29uc3QgJiYgaGFuZGxlLiQkLnB0clR5cGUuaXNDb25zdCkgewogICAgICAgIHRocm93QmluZGluZ0Vycm9yKAogICAgICAgICAgJ0Nhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgJyArCiAgICAgICAgICAgIChoYW5kbGUuJCQuc21hcnRQdHJUeXBlID8gaGFuZGxlLiQkLnNtYXJ0UHRyVHlwZS5uYW1lIDogaGFuZGxlLiQkLnB0clR5cGUubmFtZSkgKwogICAgICAgICAgICAnIHRvIHBhcmFtZXRlciB0eXBlICcgKwogICAgICAgICAgICB0aGlzLm5hbWUKICAgICAgICApOwogICAgICB9CiAgICAgIHZhciBoYW5kbGVDbGFzcyA9IGhhbmRsZS4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzczsKICAgICAgcHRyID0gdXBjYXN0UG9pbnRlcihoYW5kbGUuJCQucHRyLCBoYW5kbGVDbGFzcywgdGhpcy5yZWdpc3RlcmVkQ2xhc3MpOwogICAgICBpZiAodGhpcy5pc1NtYXJ0UG9pbnRlcikgewogICAgICAgIGlmICh1bmRlZmluZWQgPT09IGhhbmRsZS4kJC5zbWFydFB0cikgewogICAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoJ1Bhc3NpbmcgcmF3IHBvaW50ZXIgdG8gc21hcnQgcG9pbnRlciBpcyBpbGxlZ2FsJyk7CiAgICAgICAgfQogICAgICAgIHN3aXRjaCAodGhpcy5zaGFyaW5nUG9saWN5KSB7CiAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgIGlmIChoYW5kbGUuJCQuc21hcnRQdHJUeXBlID09PSB0aGlzKSB7CiAgICAgICAgICAgICAgcHRyID0gaGFuZGxlLiQkLnNtYXJ0UHRyOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIHRocm93QmluZGluZ0Vycm9yKAogICAgICAgICAgICAgICAgJ0Nhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgJyArCiAgICAgICAgICAgICAgICAgIChoYW5kbGUuJCQuc21hcnRQdHJUeXBlID8gaGFuZGxlLiQkLnNtYXJ0UHRyVHlwZS5uYW1lIDogaGFuZGxlLiQkLnB0clR5cGUubmFtZSkgKwogICAgICAgICAgICAgICAgICAnIHRvIHBhcmFtZXRlciB0eXBlICcgKwogICAgICAgICAgICAgICAgICB0aGlzLm5hbWUKICAgICAgICAgICAgICApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgIHB0ciA9IGhhbmRsZS4kJC5zbWFydFB0cjsKICAgICAgICAgICAgYnJlYWsKICAgICAgICAgIGNhc2UgMjoKICAgICAgICAgICAgaWYgKGhhbmRsZS4kJC5zbWFydFB0clR5cGUgPT09IHRoaXMpIHsKICAgICAgICAgICAgICBwdHIgPSBoYW5kbGUuJCQuc21hcnRQdHI7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdmFyIGNsb25lZEhhbmRsZSA9IGhhbmRsZVsnY2xvbmUnXSgpOwogICAgICAgICAgICAgIHB0ciA9IHRoaXMucmF3U2hhcmUoCiAgICAgICAgICAgICAgICBwdHIsCiAgICAgICAgICAgICAgICBfX2VtdmFsX3JlZ2lzdGVyKGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgICAgICAgY2xvbmVkSGFuZGxlWydkZWxldGUnXSgpOwogICAgICAgICAgICAgICAgfSkKICAgICAgICAgICAgICApOwogICAgICAgICAgICAgIGlmIChkZXN0cnVjdG9ycyAhPT0gbnVsbCkgewogICAgICAgICAgICAgICAgZGVzdHJ1Y3RvcnMucHVzaCh0aGlzLnJhd0Rlc3RydWN0b3IsIHB0cik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignVW5zdXBwb3J0aW5nIHNoYXJpbmcgcG9saWN5Jyk7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBwdHIKICAgIH0KICAgIGZ1bmN0aW9uIG5vbkNvbnN0Tm9TbWFydFB0clJhd1BvaW50ZXJUb1dpcmVUeXBlKGRlc3RydWN0b3JzLCBoYW5kbGUpIHsKICAgICAgaWYgKGhhbmRsZSA9PT0gbnVsbCkgewogICAgICAgIGlmICh0aGlzLmlzUmVmZXJlbmNlKSB7CiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignbnVsbCBpcyBub3QgYSB2YWxpZCAnICsgdGhpcy5uYW1lKTsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIDAKICAgICAgfQogICAgICBpZiAoIWhhbmRsZS4kJCkgewogICAgICAgIHRocm93QmluZGluZ0Vycm9yKCdDYW5ub3QgcGFzcyAiJyArIF9lbWJpbmRfcmVwcihoYW5kbGUpICsgJyIgYXMgYSAnICsgdGhpcy5uYW1lKTsKICAgICAgfQogICAgICBpZiAoIWhhbmRsZS4kJC5wdHIpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgJyArIHRoaXMubmFtZSk7CiAgICAgIH0KICAgICAgaWYgKGhhbmRsZS4kJC5wdHJUeXBlLmlzQ29uc3QpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSAnICsgaGFuZGxlLiQkLnB0clR5cGUubmFtZSArICcgdG8gcGFyYW1ldGVyIHR5cGUgJyArIHRoaXMubmFtZSk7CiAgICAgIH0KICAgICAgdmFyIGhhbmRsZUNsYXNzID0gaGFuZGxlLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzOwogICAgICB2YXIgcHRyID0gdXBjYXN0UG9pbnRlcihoYW5kbGUuJCQucHRyLCBoYW5kbGVDbGFzcywgdGhpcy5yZWdpc3RlcmVkQ2xhc3MpOwogICAgICByZXR1cm4gcHRyCiAgICB9CiAgICBmdW5jdGlvbiBSZWdpc3RlcmVkUG9pbnRlcl9nZXRQb2ludGVlKHB0cikgewogICAgICBpZiAodGhpcy5yYXdHZXRQb2ludGVlKSB7CiAgICAgICAgcHRyID0gdGhpcy5yYXdHZXRQb2ludGVlKHB0cik7CiAgICAgIH0KICAgICAgcmV0dXJuIHB0cgogICAgfQogICAgZnVuY3Rpb24gUmVnaXN0ZXJlZFBvaW50ZXJfZGVzdHJ1Y3RvcihwdHIpIHsKICAgICAgaWYgKHRoaXMucmF3RGVzdHJ1Y3RvcikgewogICAgICAgIHRoaXMucmF3RGVzdHJ1Y3RvcihwdHIpOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBSZWdpc3RlcmVkUG9pbnRlcl9kZWxldGVPYmplY3QoaGFuZGxlKSB7CiAgICAgIGlmIChoYW5kbGUgIT09IG51bGwpIHsKICAgICAgICBoYW5kbGVbJ2RlbGV0ZSddKCk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGRvd25jYXN0UG9pbnRlcihwdHIsIHB0ckNsYXNzLCBkZXNpcmVkQ2xhc3MpIHsKICAgICAgaWYgKHB0ckNsYXNzID09PSBkZXNpcmVkQ2xhc3MpIHsKICAgICAgICByZXR1cm4gcHRyCiAgICAgIH0KICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gZGVzaXJlZENsYXNzLmJhc2VDbGFzcykgewogICAgICAgIHJldHVybiBudWxsCiAgICAgIH0KICAgICAgdmFyIHJ2ID0gZG93bmNhc3RQb2ludGVyKHB0ciwgcHRyQ2xhc3MsIGRlc2lyZWRDbGFzcy5iYXNlQ2xhc3MpOwogICAgICBpZiAocnYgPT09IG51bGwpIHsKICAgICAgICByZXR1cm4gbnVsbAogICAgICB9CiAgICAgIHJldHVybiBkZXNpcmVkQ2xhc3MuZG93bmNhc3QocnYpCiAgICB9CiAgICBmdW5jdGlvbiBnZXRJbmhlcml0ZWRJbnN0YW5jZUNvdW50KCkgewogICAgICByZXR1cm4gT2JqZWN0LmtleXMocmVnaXN0ZXJlZEluc3RhbmNlcykubGVuZ3RoCiAgICB9CiAgICBmdW5jdGlvbiBnZXRMaXZlSW5oZXJpdGVkSW5zdGFuY2VzKCkgewogICAgICB2YXIgcnYgPSBbXTsKICAgICAgZm9yICh2YXIgayBpbiByZWdpc3RlcmVkSW5zdGFuY2VzKSB7CiAgICAgICAgaWYgKHJlZ2lzdGVyZWRJbnN0YW5jZXMuaGFzT3duUHJvcGVydHkoaykpIHsKICAgICAgICAgIHJ2LnB1c2gocmVnaXN0ZXJlZEluc3RhbmNlc1trXSk7CiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybiBydgogICAgfQogICAgZnVuY3Rpb24gc2V0RGVsYXlGdW5jdGlvbihmbikgewogICAgICBkZWxheUZ1bmN0aW9uID0gZm47CiAgICAgIGlmIChkZWxldGlvblF1ZXVlLmxlbmd0aCAmJiBkZWxheUZ1bmN0aW9uKSB7CiAgICAgICAgZGVsYXlGdW5jdGlvbihmbHVzaFBlbmRpbmdEZWxldGVzKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW5pdF9lbWJpbmQoKSB7CiAgICAgIE1vZHVsZVsnZ2V0SW5oZXJpdGVkSW5zdGFuY2VDb3VudCddID0gZ2V0SW5oZXJpdGVkSW5zdGFuY2VDb3VudDsKICAgICAgTW9kdWxlWydnZXRMaXZlSW5oZXJpdGVkSW5zdGFuY2VzJ10gPSBnZXRMaXZlSW5oZXJpdGVkSW5zdGFuY2VzOwogICAgICBNb2R1bGVbJ2ZsdXNoUGVuZGluZ0RlbGV0ZXMnXSA9IGZsdXNoUGVuZGluZ0RlbGV0ZXM7CiAgICAgIE1vZHVsZVsnc2V0RGVsYXlGdW5jdGlvbiddID0gc2V0RGVsYXlGdW5jdGlvbjsKICAgIH0KICAgIHZhciByZWdpc3RlcmVkSW5zdGFuY2VzID0ge307CiAgICBmdW5jdGlvbiBnZXRCYXNlc3RQb2ludGVyKGNsYXNzXywgcHRyKSB7CiAgICAgIGlmIChwdHIgPT09IHVuZGVmaW5lZCkgewogICAgICAgIHRocm93QmluZGluZ0Vycm9yKCdwdHIgc2hvdWxkIG5vdCBiZSB1bmRlZmluZWQnKTsKICAgICAgfQogICAgICB3aGlsZSAoY2xhc3NfLmJhc2VDbGFzcykgewogICAgICAgIHB0ciA9IGNsYXNzXy51cGNhc3QocHRyKTsKICAgICAgICBjbGFzc18gPSBjbGFzc18uYmFzZUNsYXNzOwogICAgICB9CiAgICAgIHJldHVybiBwdHIKICAgIH0KICAgIGZ1bmN0aW9uIGdldEluaGVyaXRlZEluc3RhbmNlKGNsYXNzXywgcHRyKSB7CiAgICAgIHB0ciA9IGdldEJhc2VzdFBvaW50ZXIoY2xhc3NfLCBwdHIpOwogICAgICByZXR1cm4gcmVnaXN0ZXJlZEluc3RhbmNlc1twdHJdCiAgICB9CiAgICBmdW5jdGlvbiBtYWtlQ2xhc3NIYW5kbGUocHJvdG90eXBlLCByZWNvcmQpIHsKICAgICAgaWYgKCFyZWNvcmQucHRyVHlwZSB8fCAhcmVjb3JkLnB0cikgewogICAgICAgIHRocm93SW50ZXJuYWxFcnJvcignbWFrZUNsYXNzSGFuZGxlIHJlcXVpcmVzIHB0ciBhbmQgcHRyVHlwZScpOwogICAgICB9CiAgICAgIHZhciBoYXNTbWFydFB0clR5cGUgPSAhIXJlY29yZC5zbWFydFB0clR5cGU7CiAgICAgIHZhciBoYXNTbWFydFB0ciA9ICEhcmVjb3JkLnNtYXJ0UHRyOwogICAgICBpZiAoaGFzU21hcnRQdHJUeXBlICE9PSBoYXNTbWFydFB0cikgewogICAgICAgIHRocm93SW50ZXJuYWxFcnJvcignQm90aCBzbWFydFB0clR5cGUgYW5kIHNtYXJ0UHRyIG11c3QgYmUgc3BlY2lmaWVkJyk7CiAgICAgIH0KICAgICAgcmVjb3JkLmNvdW50ID0geyB2YWx1ZTogMSB9OwogICAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUsIHsgJCQ6IHsgdmFsdWU6IHJlY29yZCB9IH0pCiAgICB9CiAgICBmdW5jdGlvbiBSZWdpc3RlcmVkUG9pbnRlcl9mcm9tV2lyZVR5cGUocHRyKSB7CiAgICAgIHZhciByYXdQb2ludGVyID0gdGhpcy5nZXRQb2ludGVlKHB0cik7CiAgICAgIGlmICghcmF3UG9pbnRlcikgewogICAgICAgIHRoaXMuZGVzdHJ1Y3RvcihwdHIpOwogICAgICAgIHJldHVybiBudWxsCiAgICAgIH0KICAgICAgdmFyIHJlZ2lzdGVyZWRJbnN0YW5jZSA9IGdldEluaGVyaXRlZEluc3RhbmNlKHRoaXMucmVnaXN0ZXJlZENsYXNzLCByYXdQb2ludGVyKTsKICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gcmVnaXN0ZXJlZEluc3RhbmNlKSB7CiAgICAgICAgaWYgKDAgPT09IHJlZ2lzdGVyZWRJbnN0YW5jZS4kJC5jb3VudC52YWx1ZSkgewogICAgICAgICAgcmVnaXN0ZXJlZEluc3RhbmNlLiQkLnB0ciA9IHJhd1BvaW50ZXI7CiAgICAgICAgICByZWdpc3RlcmVkSW5zdGFuY2UuJCQuc21hcnRQdHIgPSBwdHI7CiAgICAgICAgICByZXR1cm4gcmVnaXN0ZXJlZEluc3RhbmNlWydjbG9uZSddKCkKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdmFyIHJ2ID0gcmVnaXN0ZXJlZEluc3RhbmNlWydjbG9uZSddKCk7CiAgICAgICAgICB0aGlzLmRlc3RydWN0b3IocHRyKTsKICAgICAgICAgIHJldHVybiBydgogICAgICAgIH0KICAgICAgfQogICAgICBmdW5jdGlvbiBtYWtlRGVmYXVsdEhhbmRsZSgpIHsKICAgICAgICBpZiAodGhpcy5pc1NtYXJ0UG9pbnRlcikgewogICAgICAgICAgcmV0dXJuIG1ha2VDbGFzc0hhbmRsZSh0aGlzLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSwgewogICAgICAgICAgICBwdHJUeXBlOiB0aGlzLnBvaW50ZWVUeXBlLAogICAgICAgICAgICBwdHI6IHJhd1BvaW50ZXIsCiAgICAgICAgICAgIHNtYXJ0UHRyVHlwZTogdGhpcywKICAgICAgICAgICAgc21hcnRQdHI6IHB0ciwKICAgICAgICAgIH0pCiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIHJldHVybiBtYWtlQ2xhc3NIYW5kbGUodGhpcy5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUsIHsgcHRyVHlwZTogdGhpcywgcHRyOiBwdHIgfSkKICAgICAgICB9CiAgICAgIH0KICAgICAgdmFyIGFjdHVhbFR5cGUgPSB0aGlzLnJlZ2lzdGVyZWRDbGFzcy5nZXRBY3R1YWxUeXBlKHJhd1BvaW50ZXIpOwogICAgICB2YXIgcmVnaXN0ZXJlZFBvaW50ZXJSZWNvcmQgPSByZWdpc3RlcmVkUG9pbnRlcnNbYWN0dWFsVHlwZV07CiAgICAgIGlmICghcmVnaXN0ZXJlZFBvaW50ZXJSZWNvcmQpIHsKICAgICAgICByZXR1cm4gbWFrZURlZmF1bHRIYW5kbGUuY2FsbCh0aGlzKQogICAgICB9CiAgICAgIHZhciB0b1R5cGU7CiAgICAgIGlmICh0aGlzLmlzQ29uc3QpIHsKICAgICAgICB0b1R5cGUgPSByZWdpc3RlcmVkUG9pbnRlclJlY29yZC5jb25zdFBvaW50ZXJUeXBlOwogICAgICB9IGVsc2UgewogICAgICAgIHRvVHlwZSA9IHJlZ2lzdGVyZWRQb2ludGVyUmVjb3JkLnBvaW50ZXJUeXBlOwogICAgICB9CiAgICAgIHZhciBkcCA9IGRvd25jYXN0UG9pbnRlcihyYXdQb2ludGVyLCB0aGlzLnJlZ2lzdGVyZWRDbGFzcywgdG9UeXBlLnJlZ2lzdGVyZWRDbGFzcyk7CiAgICAgIGlmIChkcCA9PT0gbnVsbCkgewogICAgICAgIHJldHVybiBtYWtlRGVmYXVsdEhhbmRsZS5jYWxsKHRoaXMpCiAgICAgIH0KICAgICAgaWYgKHRoaXMuaXNTbWFydFBvaW50ZXIpIHsKICAgICAgICByZXR1cm4gbWFrZUNsYXNzSGFuZGxlKHRvVHlwZS5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUsIHsKICAgICAgICAgIHB0clR5cGU6IHRvVHlwZSwKICAgICAgICAgIHB0cjogZHAsCiAgICAgICAgICBzbWFydFB0clR5cGU6IHRoaXMsCiAgICAgICAgICBzbWFydFB0cjogcHRyLAogICAgICAgIH0pCiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuIG1ha2VDbGFzc0hhbmRsZSh0b1R5cGUucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLCB7IHB0clR5cGU6IHRvVHlwZSwgcHRyOiBkcCB9KQogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbml0X1JlZ2lzdGVyZWRQb2ludGVyKCkgewogICAgICBSZWdpc3RlcmVkUG9pbnRlci5wcm90b3R5cGUuZ2V0UG9pbnRlZSA9IFJlZ2lzdGVyZWRQb2ludGVyX2dldFBvaW50ZWU7CiAgICAgIFJlZ2lzdGVyZWRQb2ludGVyLnByb3RvdHlwZS5kZXN0cnVjdG9yID0gUmVnaXN0ZXJlZFBvaW50ZXJfZGVzdHJ1Y3RvcjsKICAgICAgUmVnaXN0ZXJlZFBvaW50ZXIucHJvdG90eXBlWydhcmdQYWNrQWR2YW5jZSddID0gODsKICAgICAgUmVnaXN0ZXJlZFBvaW50ZXIucHJvdG90eXBlWydyZWFkVmFsdWVGcm9tUG9pbnRlciddID0gc2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXI7CiAgICAgIFJlZ2lzdGVyZWRQb2ludGVyLnByb3RvdHlwZVsnZGVsZXRlT2JqZWN0J10gPSBSZWdpc3RlcmVkUG9pbnRlcl9kZWxldGVPYmplY3Q7CiAgICAgIFJlZ2lzdGVyZWRQb2ludGVyLnByb3RvdHlwZVsnZnJvbVdpcmVUeXBlJ10gPSBSZWdpc3RlcmVkUG9pbnRlcl9mcm9tV2lyZVR5cGU7CiAgICB9CiAgICBmdW5jdGlvbiBSZWdpc3RlcmVkUG9pbnRlcigKICAgICAgbmFtZSwKICAgICAgcmVnaXN0ZXJlZENsYXNzLAogICAgICBpc1JlZmVyZW5jZSwKICAgICAgaXNDb25zdCwKICAgICAgaXNTbWFydFBvaW50ZXIsCiAgICAgIHBvaW50ZWVUeXBlLAogICAgICBzaGFyaW5nUG9saWN5LAogICAgICByYXdHZXRQb2ludGVlLAogICAgICByYXdDb25zdHJ1Y3RvciwKICAgICAgcmF3U2hhcmUsCiAgICAgIHJhd0Rlc3RydWN0b3IKICAgICkgewogICAgICB0aGlzLm5hbWUgPSBuYW1lOwogICAgICB0aGlzLnJlZ2lzdGVyZWRDbGFzcyA9IHJlZ2lzdGVyZWRDbGFzczsKICAgICAgdGhpcy5pc1JlZmVyZW5jZSA9IGlzUmVmZXJlbmNlOwogICAgICB0aGlzLmlzQ29uc3QgPSBpc0NvbnN0OwogICAgICB0aGlzLmlzU21hcnRQb2ludGVyID0gaXNTbWFydFBvaW50ZXI7CiAgICAgIHRoaXMucG9pbnRlZVR5cGUgPSBwb2ludGVlVHlwZTsKICAgICAgdGhpcy5zaGFyaW5nUG9saWN5ID0gc2hhcmluZ1BvbGljeTsKICAgICAgdGhpcy5yYXdHZXRQb2ludGVlID0gcmF3R2V0UG9pbnRlZTsKICAgICAgdGhpcy5yYXdDb25zdHJ1Y3RvciA9IHJhd0NvbnN0cnVjdG9yOwogICAgICB0aGlzLnJhd1NoYXJlID0gcmF3U2hhcmU7CiAgICAgIHRoaXMucmF3RGVzdHJ1Y3RvciA9IHJhd0Rlc3RydWN0b3I7CiAgICAgIGlmICghaXNTbWFydFBvaW50ZXIgJiYgcmVnaXN0ZXJlZENsYXNzLmJhc2VDbGFzcyA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgaWYgKGlzQ29uc3QpIHsKICAgICAgICAgIHRoaXNbJ3RvV2lyZVR5cGUnXSA9IGNvbnN0Tm9TbWFydFB0clJhd1BvaW50ZXJUb1dpcmVUeXBlOwogICAgICAgICAgdGhpcy5kZXN0cnVjdG9yRnVuY3Rpb24gPSBudWxsOwogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICB0aGlzWyd0b1dpcmVUeXBlJ10gPSBub25Db25zdE5vU21hcnRQdHJSYXdQb2ludGVyVG9XaXJlVHlwZTsKICAgICAgICAgIHRoaXMuZGVzdHJ1Y3RvckZ1bmN0aW9uID0gbnVsbDsKICAgICAgICB9CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdGhpc1sndG9XaXJlVHlwZSddID0gZ2VuZXJpY1BvaW50ZXJUb1dpcmVUeXBlOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiByZXBsYWNlUHVibGljU3ltYm9sKG5hbWUsIHZhbHVlLCBudW1Bcmd1bWVudHMpIHsKICAgICAgaWYgKCFNb2R1bGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHsKICAgICAgICB0aHJvd0ludGVybmFsRXJyb3IoJ1JlcGxhY2luZyBub25leGlzdGFudCBwdWJsaWMgc3ltYm9sJyk7CiAgICAgIH0KICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gTW9kdWxlW25hbWVdLm92ZXJsb2FkVGFibGUgJiYgdW5kZWZpbmVkICE9PSBudW1Bcmd1bWVudHMpIHsKICAgICAgICBNb2R1bGVbbmFtZV0ub3ZlcmxvYWRUYWJsZVtudW1Bcmd1bWVudHNdID0gdmFsdWU7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgTW9kdWxlW25hbWVdID0gdmFsdWU7CiAgICAgICAgTW9kdWxlW25hbWVdLmFyZ0NvdW50ID0gbnVtQXJndW1lbnRzOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihzaWduYXR1cmUsIHJhd0Z1bmN0aW9uKSB7CiAgICAgIHNpZ25hdHVyZSA9IHJlYWRMYXRpbjFTdHJpbmcoc2lnbmF0dXJlKTsKICAgICAgZnVuY3Rpb24gbWFrZUR5bkNhbGxlcihkeW5DYWxsKSB7CiAgICAgICAgdmFyIGFyZ3MgPSBbXTsKICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHNpZ25hdHVyZS5sZW5ndGg7ICsraSkgewogICAgICAgICAgYXJncy5wdXNoKCdhJyArIGkpOwogICAgICAgIH0KICAgICAgICB2YXIgbmFtZSA9ICdkeW5DYWxsXycgKyBzaWduYXR1cmUgKyAnXycgKyByYXdGdW5jdGlvbjsKICAgICAgICB2YXIgYm9keSA9ICdyZXR1cm4gZnVuY3Rpb24gJyArIG5hbWUgKyAnKCcgKyBhcmdzLmpvaW4oJywgJykgKyAnKSB7XG4nOwogICAgICAgIGJvZHkgKz0gJyAgICByZXR1cm4gZHluQ2FsbChyYXdGdW5jdGlvbicgKyAoYXJncy5sZW5ndGggPyAnLCAnIDogJycpICsgYXJncy5qb2luKCcsICcpICsgJyk7XG4nOwogICAgICAgIGJvZHkgKz0gJ307XG4nOwogICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ2R5bkNhbGwnLCAncmF3RnVuY3Rpb24nLCBib2R5KShkeW5DYWxsLCByYXdGdW5jdGlvbikKICAgICAgfQogICAgICB2YXIgZnA7CiAgICAgIGlmIChNb2R1bGVbJ0ZVTkNUSU9OX1RBQkxFXycgKyBzaWduYXR1cmVdICE9PSB1bmRlZmluZWQpIHsKICAgICAgICBmcCA9IE1vZHVsZVsnRlVOQ1RJT05fVEFCTEVfJyArIHNpZ25hdHVyZV1bcmF3RnVuY3Rpb25dOwogICAgICB9IGVsc2UgaWYgKHR5cGVvZiBGVU5DVElPTl9UQUJMRSAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICBmcCA9IEZVTkNUSU9OX1RBQkxFW3Jhd0Z1bmN0aW9uXTsKICAgICAgfSBlbHNlIHsKICAgICAgICB2YXIgZGMgPSBNb2R1bGVbJ2FzbSddWydkeW5DYWxsXycgKyBzaWduYXR1cmVdOwogICAgICAgIGlmIChkYyA9PT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICBkYyA9IE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfJyArIHNpZ25hdHVyZS5yZXBsYWNlKC9mL2csICdkJyldOwogICAgICAgICAgaWYgKGRjID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoJ05vIGR5bkNhbGwgaW52b2tlciBmb3Igc2lnbmF0dXJlOiAnICsgc2lnbmF0dXJlKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgZnAgPSBtYWtlRHluQ2FsbGVyKGRjKTsKICAgICAgfQogICAgICBpZiAodHlwZW9mIGZwICE9PSAnZnVuY3Rpb24nKSB7CiAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoJ3Vua25vd24gZnVuY3Rpb24gcG9pbnRlciB3aXRoIHNpZ25hdHVyZSAnICsgc2lnbmF0dXJlICsgJzogJyArIHJhd0Z1bmN0aW9uKTsKICAgICAgfQogICAgICByZXR1cm4gZnAKICAgIH0KICAgIHZhciBVbmJvdW5kVHlwZUVycm9yID0gdW5kZWZpbmVkOwogICAgZnVuY3Rpb24gZ2V0VHlwZU5hbWUodHlwZSkgewogICAgICB2YXIgcHRyID0gX19fZ2V0VHlwZU5hbWUodHlwZSk7CiAgICAgIHZhciBydiA9IHJlYWRMYXRpbjFTdHJpbmcocHRyKTsKICAgICAgX2ZyZWUocHRyKTsKICAgICAgcmV0dXJuIHJ2CiAgICB9CiAgICBmdW5jdGlvbiB0aHJvd1VuYm91bmRUeXBlRXJyb3IobWVzc2FnZSwgdHlwZXMpIHsKICAgICAgdmFyIHVuYm91bmRUeXBlcyA9IFtdOwogICAgICB2YXIgc2VlbiA9IHt9OwogICAgICBmdW5jdGlvbiB2aXNpdCh0eXBlKSB7CiAgICAgICAgaWYgKHNlZW5bdHlwZV0pIHsKICAgICAgICAgIHJldHVybgogICAgICAgIH0KICAgICAgICBpZiAocmVnaXN0ZXJlZFR5cGVzW3R5cGVdKSB7CiAgICAgICAgICByZXR1cm4KICAgICAgICB9CiAgICAgICAgaWYgKHR5cGVEZXBlbmRlbmNpZXNbdHlwZV0pIHsKICAgICAgICAgIHR5cGVEZXBlbmRlbmNpZXNbdHlwZV0uZm9yRWFjaCh2aXNpdCk7CiAgICAgICAgICByZXR1cm4KICAgICAgICB9CiAgICAgICAgdW5ib3VuZFR5cGVzLnB1c2godHlwZSk7CiAgICAgICAgc2Vlblt0eXBlXSA9IHRydWU7CiAgICAgIH0KICAgICAgdHlwZXMuZm9yRWFjaCh2aXNpdCk7CiAgICAgIHRocm93IG5ldyBVbmJvdW5kVHlwZUVycm9yKG1lc3NhZ2UgKyAnOiAnICsgdW5ib3VuZFR5cGVzLm1hcChnZXRUeXBlTmFtZSkuam9pbihbJywgJ10pKQogICAgfQogICAgZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3MoCiAgICAgIHJhd1R5cGUsCiAgICAgIHJhd1BvaW50ZXJUeXBlLAogICAgICByYXdDb25zdFBvaW50ZXJUeXBlLAogICAgICBiYXNlQ2xhc3NSYXdUeXBlLAogICAgICBnZXRBY3R1YWxUeXBlU2lnbmF0dXJlLAogICAgICBnZXRBY3R1YWxUeXBlLAogICAgICB1cGNhc3RTaWduYXR1cmUsCiAgICAgIHVwY2FzdCwKICAgICAgZG93bmNhc3RTaWduYXR1cmUsCiAgICAgIGRvd25jYXN0LAogICAgICBuYW1lLAogICAgICBkZXN0cnVjdG9yU2lnbmF0dXJlLAogICAgICByYXdEZXN0cnVjdG9yCiAgICApIHsKICAgICAgbmFtZSA9IHJlYWRMYXRpbjFTdHJpbmcobmFtZSk7CiAgICAgIGdldEFjdHVhbFR5cGUgPSBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihnZXRBY3R1YWxUeXBlU2lnbmF0dXJlLCBnZXRBY3R1YWxUeXBlKTsKICAgICAgaWYgKHVwY2FzdCkgewogICAgICAgIHVwY2FzdCA9IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKHVwY2FzdFNpZ25hdHVyZSwgdXBjYXN0KTsKICAgICAgfQogICAgICBpZiAoZG93bmNhc3QpIHsKICAgICAgICBkb3duY2FzdCA9IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGRvd25jYXN0U2lnbmF0dXJlLCBkb3duY2FzdCk7CiAgICAgIH0KICAgICAgcmF3RGVzdHJ1Y3RvciA9IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGRlc3RydWN0b3JTaWduYXR1cmUsIHJhd0Rlc3RydWN0b3IpOwogICAgICB2YXIgbGVnYWxGdW5jdGlvbk5hbWUgPSBtYWtlTGVnYWxGdW5jdGlvbk5hbWUobmFtZSk7CiAgICAgIGV4cG9zZVB1YmxpY1N5bWJvbChsZWdhbEZ1bmN0aW9uTmFtZSwgZnVuY3Rpb24gKCkgewogICAgICAgIHRocm93VW5ib3VuZFR5cGVFcnJvcignQ2Fubm90IGNvbnN0cnVjdCAnICsgbmFtZSArICcgZHVlIHRvIHVuYm91bmQgdHlwZXMnLCBbYmFzZUNsYXNzUmF3VHlwZV0pOwogICAgICB9KTsKICAgICAgd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoCiAgICAgICAgW3Jhd1R5cGUsIHJhd1BvaW50ZXJUeXBlLCByYXdDb25zdFBvaW50ZXJUeXBlXSwKICAgICAgICBiYXNlQ2xhc3NSYXdUeXBlID8gW2Jhc2VDbGFzc1Jhd1R5cGVdIDogW10sCiAgICAgICAgZnVuY3Rpb24gKGJhc2UpIHsKICAgICAgICAgIGJhc2UgPSBiYXNlWzBdOwogICAgICAgICAgdmFyIGJhc2VDbGFzczsKICAgICAgICAgIHZhciBiYXNlUHJvdG90eXBlOwogICAgICAgICAgaWYgKGJhc2VDbGFzc1Jhd1R5cGUpIHsKICAgICAgICAgICAgYmFzZUNsYXNzID0gYmFzZS5yZWdpc3RlcmVkQ2xhc3M7CiAgICAgICAgICAgIGJhc2VQcm90b3R5cGUgPSBiYXNlQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGU7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBiYXNlUHJvdG90eXBlID0gQ2xhc3NIYW5kbGUucHJvdG90eXBlOwogICAgICAgICAgfQogICAgICAgICAgdmFyIGNvbnN0cnVjdG9yID0gY3JlYXRlTmFtZWRGdW5jdGlvbihsZWdhbEZ1bmN0aW9uTmFtZSwgZnVuY3Rpb24gKCkgewogICAgICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpICE9PSBpbnN0YW5jZVByb3RvdHlwZSkgewogICAgICAgICAgICAgIHRocm93IG5ldyBCaW5kaW5nRXJyb3IoIlVzZSAnbmV3JyB0byBjb25zdHJ1Y3QgIiArIG5hbWUpCiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gcmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkpIHsKICAgICAgICAgICAgICB0aHJvdyBuZXcgQmluZGluZ0Vycm9yKG5hbWUgKyAnIGhhcyBubyBhY2Nlc3NpYmxlIGNvbnN0cnVjdG9yJykKICAgICAgICAgICAgfQogICAgICAgICAgICB2YXIgYm9keSA9IHJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W2FyZ3VtZW50cy5sZW5ndGhdOwogICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBib2R5KSB7CiAgICAgICAgICAgICAgdGhyb3cgbmV3IEJpbmRpbmdFcnJvcigKICAgICAgICAgICAgICAgICdUcmllZCB0byBpbnZva2UgY3RvciBvZiAnICsKICAgICAgICAgICAgICAgICAgbmFtZSArCiAgICAgICAgICAgICAgICAgICcgd2l0aCBpbnZhbGlkIG51bWJlciBvZiBwYXJhbWV0ZXJzICgnICsKICAgICAgICAgICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCArCiAgICAgICAgICAgICAgICAgICcpIC0gZXhwZWN0ZWQgKCcgKwogICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhyZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keSkudG9TdHJpbmcoKSArCiAgICAgICAgICAgICAgICAgICcpIHBhcmFtZXRlcnMgaW5zdGVhZCEnCiAgICAgICAgICAgICAgKQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBib2R5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykKICAgICAgICAgIH0pOwogICAgICAgICAgdmFyIGluc3RhbmNlUHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBjb25zdHJ1Y3RvciB9IH0pOwogICAgICAgICAgY29uc3RydWN0b3IucHJvdG90eXBlID0gaW5zdGFuY2VQcm90b3R5cGU7CiAgICAgICAgICB2YXIgcmVnaXN0ZXJlZENsYXNzID0gbmV3IFJlZ2lzdGVyZWRDbGFzcygKICAgICAgICAgICAgbmFtZSwKICAgICAgICAgICAgY29uc3RydWN0b3IsCiAgICAgICAgICAgIGluc3RhbmNlUHJvdG90eXBlLAogICAgICAgICAgICByYXdEZXN0cnVjdG9yLAogICAgICAgICAgICBiYXNlQ2xhc3MsCiAgICAgICAgICAgIGdldEFjdHVhbFR5cGUsCiAgICAgICAgICAgIHVwY2FzdCwKICAgICAgICAgICAgZG93bmNhc3QKICAgICAgICAgICk7CiAgICAgICAgICB2YXIgcmVmZXJlbmNlQ29udmVydGVyID0gbmV3IFJlZ2lzdGVyZWRQb2ludGVyKG5hbWUsIHJlZ2lzdGVyZWRDbGFzcywgdHJ1ZSwgZmFsc2UsIGZhbHNlKTsKICAgICAgICAgIHZhciBwb2ludGVyQ29udmVydGVyID0gbmV3IFJlZ2lzdGVyZWRQb2ludGVyKG5hbWUgKyAnKicsIHJlZ2lzdGVyZWRDbGFzcywgZmFsc2UsIGZhbHNlLCBmYWxzZSk7CiAgICAgICAgICB2YXIgY29uc3RQb2ludGVyQ29udmVydGVyID0gbmV3IFJlZ2lzdGVyZWRQb2ludGVyKG5hbWUgKyAnIGNvbnN0KicsIHJlZ2lzdGVyZWRDbGFzcywgZmFsc2UsIHRydWUsIGZhbHNlKTsKICAgICAgICAgIHJlZ2lzdGVyZWRQb2ludGVyc1tyYXdUeXBlXSA9IHsgcG9pbnRlclR5cGU6IHBvaW50ZXJDb252ZXJ0ZXIsIGNvbnN0UG9pbnRlclR5cGU6IGNvbnN0UG9pbnRlckNvbnZlcnRlciB9OwogICAgICAgICAgcmVwbGFjZVB1YmxpY1N5bWJvbChsZWdhbEZ1bmN0aW9uTmFtZSwgY29uc3RydWN0b3IpOwogICAgICAgICAgcmV0dXJuIFtyZWZlcmVuY2VDb252ZXJ0ZXIsIHBvaW50ZXJDb252ZXJ0ZXIsIGNvbnN0UG9pbnRlckNvbnZlcnRlcl0KICAgICAgICB9CiAgICAgICk7CiAgICB9CiAgICBmdW5jdGlvbiBoZWFwMzJWZWN0b3JUb0FycmF5KGNvdW50LCBmaXJzdEVsZW1lbnQpIHsKICAgICAgdmFyIGFycmF5ID0gW107CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykgewogICAgICAgIGFycmF5LnB1c2goSEVBUDMyWyhmaXJzdEVsZW1lbnQgPj4gMikgKyBpXSk7CiAgICAgIH0KICAgICAgcmV0dXJuIGFycmF5CiAgICB9CiAgICBmdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3RvcigKICAgICAgcmF3Q2xhc3NUeXBlLAogICAgICBhcmdDb3VudCwKICAgICAgcmF3QXJnVHlwZXNBZGRyLAogICAgICBpbnZva2VyU2lnbmF0dXJlLAogICAgICBpbnZva2VyLAogICAgICByYXdDb25zdHJ1Y3RvcgogICAgKSB7CiAgICAgIHZhciByYXdBcmdUeXBlcyA9IGhlYXAzMlZlY3RvclRvQXJyYXkoYXJnQ291bnQsIHJhd0FyZ1R5cGVzQWRkcik7CiAgICAgIGludm9rZXIgPSBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihpbnZva2VyU2lnbmF0dXJlLCBpbnZva2VyKTsKICAgICAgd2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10sIFtyYXdDbGFzc1R5cGVdLCBmdW5jdGlvbiAoY2xhc3NUeXBlKSB7CiAgICAgICAgY2xhc3NUeXBlID0gY2xhc3NUeXBlWzBdOwogICAgICAgIHZhciBodW1hbk5hbWUgPSAnY29uc3RydWN0b3IgJyArIGNsYXNzVHlwZS5uYW1lOwogICAgICAgIGlmICh1bmRlZmluZWQgPT09IGNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keSkgewogICAgICAgICAgY2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5ID0gW107CiAgICAgICAgfQogICAgICAgIGlmICh1bmRlZmluZWQgIT09IGNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keVthcmdDb3VudCAtIDFdKSB7CiAgICAgICAgICB0aHJvdyBuZXcgQmluZGluZ0Vycm9yKAogICAgICAgICAgICAnQ2Fubm90IHJlZ2lzdGVyIG11bHRpcGxlIGNvbnN0cnVjdG9ycyB3aXRoIGlkZW50aWNhbCBudW1iZXIgb2YgcGFyYW1ldGVycyAoJyArCiAgICAgICAgICAgICAgKGFyZ0NvdW50IC0gMSkgKwogICAgICAgICAgICAgICIpIGZvciBjbGFzcyAnIiArCiAgICAgICAgICAgICAgY2xhc3NUeXBlLm5hbWUgKwogICAgICAgICAgICAgICInISBPdmVybG9hZCByZXNvbHV0aW9uIGlzIGN1cnJlbnRseSBvbmx5IHBlcmZvcm1lZCB1c2luZyB0aGUgcGFyYW1ldGVyIGNvdW50LCBub3QgYWN0dWFsIHR5cGUgaW5mbyEiCiAgICAgICAgICApCiAgICAgICAgfQogICAgICAgIGNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keVthcmdDb3VudCAtIDFdID0gZnVuY3Rpb24gdW5ib3VuZFR5cGVIYW5kbGVyKCkgewogICAgICAgICAgdGhyb3dVbmJvdW5kVHlwZUVycm9yKCdDYW5ub3QgY29uc3RydWN0ICcgKyBjbGFzc1R5cGUubmFtZSArICcgZHVlIHRvIHVuYm91bmQgdHlwZXMnLCByYXdBcmdUeXBlcyk7CiAgICAgICAgfTsKICAgICAgICB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSwgcmF3QXJnVHlwZXMsIGZ1bmN0aW9uIChhcmdUeXBlcykgewogICAgICAgICAgY2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5jb25zdHJ1Y3Rvcl9ib2R5W2FyZ0NvdW50IC0gMV0gPSBmdW5jdGlvbiBjb25zdHJ1Y3Rvcl9ib2R5KCkgewogICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gYXJnQ291bnQgLSAxKSB7CiAgICAgICAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoaHVtYW5OYW1lICsgJyBjYWxsZWQgd2l0aCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLCBleHBlY3RlZCAnICsgKGFyZ0NvdW50IC0gMSkpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBkZXN0cnVjdG9ycyA9IFtdOwogICAgICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmdDb3VudCk7CiAgICAgICAgICAgIGFyZ3NbMF0gPSByYXdDb25zdHJ1Y3RvcjsKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdDb3VudDsgKytpKSB7CiAgICAgICAgICAgICAgYXJnc1tpXSA9IGFyZ1R5cGVzW2ldWyd0b1dpcmVUeXBlJ10oZGVzdHJ1Y3RvcnMsIGFyZ3VtZW50c1tpIC0gMV0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHZhciBwdHIgPSBpbnZva2VyLmFwcGx5KG51bGwsIGFyZ3MpOwogICAgICAgICAgICBydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyk7CiAgICAgICAgICAgIHJldHVybiBhcmdUeXBlc1swXVsnZnJvbVdpcmVUeXBlJ10ocHRyKQogICAgICAgICAgfTsKICAgICAgICAgIHJldHVybiBbXQogICAgICAgIH0pOwogICAgICAgIHJldHVybiBbXQogICAgICB9KTsKICAgIH0KICAgIGZ1bmN0aW9uIG5ld18oY29uc3RydWN0b3IsIGFyZ3VtZW50TGlzdCkgewogICAgICBpZiAoIShjb25zdHJ1Y3RvciBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkgewogICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25ld18gY2FsbGVkIHdpdGggY29uc3RydWN0b3IgdHlwZSAnICsgdHlwZW9mIGNvbnN0cnVjdG9yICsgJyB3aGljaCBpcyBub3QgYSBmdW5jdGlvbicpCiAgICAgIH0KICAgICAgdmFyIGR1bW15ID0gY3JlYXRlTmFtZWRGdW5jdGlvbihjb25zdHJ1Y3Rvci5uYW1lIHx8ICd1bmtub3duRnVuY3Rpb25OYW1lJywgZnVuY3Rpb24gKCkge30pOwogICAgICBkdW1teS5wcm90b3R5cGUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7CiAgICAgIHZhciBvYmogPSBuZXcgZHVtbXkoKTsKICAgICAgdmFyIHIgPSBjb25zdHJ1Y3Rvci5hcHBseShvYmosIGFyZ3VtZW50TGlzdCk7CiAgICAgIHJldHVybiByIGluc3RhbmNlb2YgT2JqZWN0ID8gciA6IG9iagogICAgfQogICAgZnVuY3Rpb24gY3JhZnRJbnZva2VyRnVuY3Rpb24oaHVtYW5OYW1lLCBhcmdUeXBlcywgY2xhc3NUeXBlLCBjcHBJbnZva2VyRnVuYywgY3BwVGFyZ2V0RnVuYykgewogICAgICB2YXIgYXJnQ291bnQgPSBhcmdUeXBlcy5sZW5ndGg7CiAgICAgIGlmIChhcmdDb3VudCA8IDIpIHsKICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcigiYXJnVHlwZXMgYXJyYXkgc2l6ZSBtaXNtYXRjaCEgTXVzdCBhdCBsZWFzdCBnZXQgcmV0dXJuIHZhbHVlIGFuZCAndGhpcycgdHlwZXMhIik7CiAgICAgIH0KICAgICAgdmFyIGlzQ2xhc3NNZXRob2RGdW5jID0gYXJnVHlwZXNbMV0gIT09IG51bGwgJiYgY2xhc3NUeXBlICE9PSBudWxsOwogICAgICB2YXIgbmVlZHNEZXN0cnVjdG9yU3RhY2sgPSBmYWxzZTsKICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmdUeXBlcy5sZW5ndGg7ICsraSkgewogICAgICAgIGlmIChhcmdUeXBlc1tpXSAhPT0gbnVsbCAmJiBhcmdUeXBlc1tpXS5kZXN0cnVjdG9yRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkgewogICAgICAgICAgbmVlZHNEZXN0cnVjdG9yU3RhY2sgPSB0cnVlOwogICAgICAgICAgYnJlYWsKICAgICAgICB9CiAgICAgIH0KICAgICAgdmFyIHJldHVybnMgPSBhcmdUeXBlc1swXS5uYW1lICE9PSAndm9pZCc7CiAgICAgIHZhciBhcmdzTGlzdCA9ICcnOwogICAgICB2YXIgYXJnc0xpc3RXaXJlZCA9ICcnOwogICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ0NvdW50IC0gMjsgKytpKSB7CiAgICAgICAgYXJnc0xpc3QgKz0gKGkgIT09IDAgPyAnLCAnIDogJycpICsgJ2FyZycgKyBpOwogICAgICAgIGFyZ3NMaXN0V2lyZWQgKz0gKGkgIT09IDAgPyAnLCAnIDogJycpICsgJ2FyZycgKyBpICsgJ1dpcmVkJzsKICAgICAgfQogICAgICB2YXIgaW52b2tlckZuQm9keSA9CiAgICAgICAgJ3JldHVybiBmdW5jdGlvbiAnICsKICAgICAgICBtYWtlTGVnYWxGdW5jdGlvbk5hbWUoaHVtYW5OYW1lKSArCiAgICAgICAgJygnICsKICAgICAgICBhcmdzTGlzdCArCiAgICAgICAgJykge1xuJyArCiAgICAgICAgJ2lmIChhcmd1bWVudHMubGVuZ3RoICE9PSAnICsKICAgICAgICAoYXJnQ291bnQgLSAyKSArCiAgICAgICAgJykge1xuJyArCiAgICAgICAgInRocm93QmluZGluZ0Vycm9yKCdmdW5jdGlvbiAiICsKICAgICAgICBodW1hbk5hbWUgKwogICAgICAgICIgY2FsbGVkIHdpdGggJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGFyZ3VtZW50cywgZXhwZWN0ZWQgIiArCiAgICAgICAgKGFyZ0NvdW50IC0gMikgKwogICAgICAgICIgYXJncyEnKTtcbiIgKwogICAgICAgICd9XG4nOwogICAgICBpZiAobmVlZHNEZXN0cnVjdG9yU3RhY2spIHsKICAgICAgICBpbnZva2VyRm5Cb2R5ICs9ICd2YXIgZGVzdHJ1Y3RvcnMgPSBbXTtcbic7CiAgICAgIH0KICAgICAgdmFyIGR0b3JTdGFjayA9IG5lZWRzRGVzdHJ1Y3RvclN0YWNrID8gJ2Rlc3RydWN0b3JzJyA6ICdudWxsJzsKICAgICAgdmFyIGFyZ3MxID0gWyd0aHJvd0JpbmRpbmdFcnJvcicsICdpbnZva2VyJywgJ2ZuJywgJ3J1bkRlc3RydWN0b3JzJywgJ3JldFR5cGUnLCAnY2xhc3NQYXJhbSddOwogICAgICB2YXIgYXJnczIgPSBbdGhyb3dCaW5kaW5nRXJyb3IsIGNwcEludm9rZXJGdW5jLCBjcHBUYXJnZXRGdW5jLCBydW5EZXN0cnVjdG9ycywgYXJnVHlwZXNbMF0sIGFyZ1R5cGVzWzFdXTsKICAgICAgaWYgKGlzQ2xhc3NNZXRob2RGdW5jKSB7CiAgICAgICAgaW52b2tlckZuQm9keSArPSAndmFyIHRoaXNXaXJlZCA9IGNsYXNzUGFyYW0udG9XaXJlVHlwZSgnICsgZHRvclN0YWNrICsgJywgdGhpcyk7XG4nOwogICAgICB9CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnQ291bnQgLSAyOyArK2kpIHsKICAgICAgICBpbnZva2VyRm5Cb2R5ICs9CiAgICAgICAgICAndmFyIGFyZycgKwogICAgICAgICAgaSArCiAgICAgICAgICAnV2lyZWQgPSBhcmdUeXBlJyArCiAgICAgICAgICBpICsKICAgICAgICAgICcudG9XaXJlVHlwZSgnICsKICAgICAgICAgIGR0b3JTdGFjayArCiAgICAgICAgICAnLCBhcmcnICsKICAgICAgICAgIGkgKwogICAgICAgICAgJyk7IC8vICcgKwogICAgICAgICAgYXJnVHlwZXNbaSArIDJdLm5hbWUgKwogICAgICAgICAgJ1xuJzsKICAgICAgICBhcmdzMS5wdXNoKCdhcmdUeXBlJyArIGkpOwogICAgICAgIGFyZ3MyLnB1c2goYXJnVHlwZXNbaSArIDJdKTsKICAgICAgfQogICAgICBpZiAoaXNDbGFzc01ldGhvZEZ1bmMpIHsKICAgICAgICBhcmdzTGlzdFdpcmVkID0gJ3RoaXNXaXJlZCcgKyAoYXJnc0xpc3RXaXJlZC5sZW5ndGggPiAwID8gJywgJyA6ICcnKSArIGFyZ3NMaXN0V2lyZWQ7CiAgICAgIH0KICAgICAgaW52b2tlckZuQm9keSArPQogICAgICAgIChyZXR1cm5zID8gJ3ZhciBydiA9ICcgOiAnJykgKyAnaW52b2tlcihmbicgKyAoYXJnc0xpc3RXaXJlZC5sZW5ndGggPiAwID8gJywgJyA6ICcnKSArIGFyZ3NMaXN0V2lyZWQgKyAnKTtcbic7CiAgICAgIGlmIChuZWVkc0Rlc3RydWN0b3JTdGFjaykgewogICAgICAgIGludm9rZXJGbkJvZHkgKz0gJ3J1bkRlc3RydWN0b3JzKGRlc3RydWN0b3JzKTtcbic7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZm9yICh2YXIgaSA9IGlzQ2xhc3NNZXRob2RGdW5jID8gMSA6IDI7IGkgPCBhcmdUeXBlcy5sZW5ndGg7ICsraSkgewogICAgICAgICAgdmFyIHBhcmFtTmFtZSA9IGkgPT09IDEgPyAndGhpc1dpcmVkJyA6ICdhcmcnICsgKGkgLSAyKSArICdXaXJlZCc7CiAgICAgICAgICBpZiAoYXJnVHlwZXNbaV0uZGVzdHJ1Y3RvckZ1bmN0aW9uICE9PSBudWxsKSB7CiAgICAgICAgICAgIGludm9rZXJGbkJvZHkgKz0gcGFyYW1OYW1lICsgJ19kdG9yKCcgKyBwYXJhbU5hbWUgKyAnKTsgLy8gJyArIGFyZ1R5cGVzW2ldLm5hbWUgKyAnXG4nOwogICAgICAgICAgICBhcmdzMS5wdXNoKHBhcmFtTmFtZSArICdfZHRvcicpOwogICAgICAgICAgICBhcmdzMi5wdXNoKGFyZ1R5cGVzW2ldLmRlc3RydWN0b3JGdW5jdGlvbik7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CiAgICAgIGlmIChyZXR1cm5zKSB7CiAgICAgICAgaW52b2tlckZuQm9keSArPSAndmFyIHJldCA9IHJldFR5cGUuZnJvbVdpcmVUeXBlKHJ2KTtcbicgKyAncmV0dXJuIHJldDtcbic7CiAgICAgIH0KICAgICAgaW52b2tlckZuQm9keSArPSAnfVxuJzsKICAgICAgYXJnczEucHVzaChpbnZva2VyRm5Cb2R5KTsKICAgICAgdmFyIGludm9rZXJGdW5jdGlvbiA9IG5ld18oRnVuY3Rpb24sIGFyZ3MxKS5hcHBseShudWxsLCBhcmdzMik7CiAgICAgIHJldHVybiBpbnZva2VyRnVuY3Rpb24KICAgIH0KICAgIGZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2Z1bmN0aW9uKAogICAgICByYXdDbGFzc1R5cGUsCiAgICAgIG1ldGhvZE5hbWUsCiAgICAgIGFyZ0NvdW50LAogICAgICByYXdBcmdUeXBlc0FkZHIsCiAgICAgIGludm9rZXJTaWduYXR1cmUsCiAgICAgIHJhd0ludm9rZXIsCiAgICAgIGNvbnRleHQsCiAgICAgIGlzUHVyZVZpcnR1YWwKICAgICkgewogICAgICB2YXIgcmF3QXJnVHlwZXMgPSBoZWFwMzJWZWN0b3JUb0FycmF5KGFyZ0NvdW50LCByYXdBcmdUeXBlc0FkZHIpOwogICAgICBtZXRob2ROYW1lID0gcmVhZExhdGluMVN0cmluZyhtZXRob2ROYW1lKTsKICAgICAgcmF3SW52b2tlciA9IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGludm9rZXJTaWduYXR1cmUsIHJhd0ludm9rZXIpOwogICAgICB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSwgW3Jhd0NsYXNzVHlwZV0sIGZ1bmN0aW9uIChjbGFzc1R5cGUpIHsKICAgICAgICBjbGFzc1R5cGUgPSBjbGFzc1R5cGVbMF07CiAgICAgICAgdmFyIGh1bWFuTmFtZSA9IGNsYXNzVHlwZS5uYW1lICsgJy4nICsgbWV0aG9kTmFtZTsKICAgICAgICBpZiAoaXNQdXJlVmlydHVhbCkgewogICAgICAgICAgY2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5wdXJlVmlydHVhbEZ1bmN0aW9ucy5wdXNoKG1ldGhvZE5hbWUpOwogICAgICAgIH0KICAgICAgICBmdW5jdGlvbiB1bmJvdW5kVHlwZXNIYW5kbGVyKCkgewogICAgICAgICAgdGhyb3dVbmJvdW5kVHlwZUVycm9yKCdDYW5ub3QgY2FsbCAnICsgaHVtYW5OYW1lICsgJyBkdWUgdG8gdW5ib3VuZCB0eXBlcycsIHJhd0FyZ1R5cGVzKTsKICAgICAgICB9CiAgICAgICAgdmFyIHByb3RvID0gY2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZTsKICAgICAgICB2YXIgbWV0aG9kID0gcHJvdG9bbWV0aG9kTmFtZV07CiAgICAgICAgaWYgKAogICAgICAgICAgdW5kZWZpbmVkID09PSBtZXRob2QgfHwKICAgICAgICAgICh1bmRlZmluZWQgPT09IG1ldGhvZC5vdmVybG9hZFRhYmxlICYmIG1ldGhvZC5jbGFzc05hbWUgIT09IGNsYXNzVHlwZS5uYW1lICYmIG1ldGhvZC5hcmdDb3VudCA9PT0gYXJnQ291bnQgLSAyKQogICAgICAgICkgewogICAgICAgICAgdW5ib3VuZFR5cGVzSGFuZGxlci5hcmdDb3VudCA9IGFyZ0NvdW50IC0gMjsKICAgICAgICAgIHVuYm91bmRUeXBlc0hhbmRsZXIuY2xhc3NOYW1lID0gY2xhc3NUeXBlLm5hbWU7CiAgICAgICAgICBwcm90b1ttZXRob2ROYW1lXSA9IHVuYm91bmRUeXBlc0hhbmRsZXI7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGVuc3VyZU92ZXJsb2FkVGFibGUocHJvdG8sIG1ldGhvZE5hbWUsIGh1bWFuTmFtZSk7CiAgICAgICAgICBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW2FyZ0NvdW50IC0gMl0gPSB1bmJvdW5kVHlwZXNIYW5kbGVyOwogICAgICAgIH0KICAgICAgICB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSwgcmF3QXJnVHlwZXMsIGZ1bmN0aW9uIChhcmdUeXBlcykgewogICAgICAgICAgdmFyIG1lbWJlckZ1bmN0aW9uID0gY3JhZnRJbnZva2VyRnVuY3Rpb24oaHVtYW5OYW1lLCBhcmdUeXBlcywgY2xhc3NUeXBlLCByYXdJbnZva2VyLCBjb250ZXh0KTsKICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IHByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGUpIHsKICAgICAgICAgICAgbWVtYmVyRnVuY3Rpb24uYXJnQ291bnQgPSBhcmdDb3VudCAtIDI7CiAgICAgICAgICAgIHByb3RvW21ldGhvZE5hbWVdID0gbWVtYmVyRnVuY3Rpb247CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW2FyZ0NvdW50IC0gMl0gPSBtZW1iZXJGdW5jdGlvbjsKICAgICAgICAgIH0KICAgICAgICAgIHJldHVybiBbXQogICAgICAgIH0pOwogICAgICAgIHJldHVybiBbXQogICAgICB9KTsKICAgIH0KICAgIHZhciBlbXZhbF9mcmVlX2xpc3QgPSBbXTsKICAgIHZhciBlbXZhbF9oYW5kbGVfYXJyYXkgPSBbe30sIHsgdmFsdWU6IHVuZGVmaW5lZCB9LCB7IHZhbHVlOiBudWxsIH0sIHsgdmFsdWU6IHRydWUgfSwgeyB2YWx1ZTogZmFsc2UgfV07CiAgICBmdW5jdGlvbiBfX2VtdmFsX2RlY3JlZihoYW5kbGUpIHsKICAgICAgaWYgKGhhbmRsZSA+IDQgJiYgMCA9PT0gLS1lbXZhbF9oYW5kbGVfYXJyYXlbaGFuZGxlXS5yZWZjb3VudCkgewogICAgICAgIGVtdmFsX2hhbmRsZV9hcnJheVtoYW5kbGVdID0gdW5kZWZpbmVkOwogICAgICAgIGVtdmFsX2ZyZWVfbGlzdC5wdXNoKGhhbmRsZSk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGNvdW50X2VtdmFsX2hhbmRsZXMoKSB7CiAgICAgIHZhciBjb3VudCA9IDA7CiAgICAgIGZvciAodmFyIGkgPSA1OyBpIDwgZW12YWxfaGFuZGxlX2FycmF5Lmxlbmd0aDsgKytpKSB7CiAgICAgICAgaWYgKGVtdmFsX2hhbmRsZV9hcnJheVtpXSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICArK2NvdW50OwogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gY291bnQKICAgIH0KICAgIGZ1bmN0aW9uIGdldF9maXJzdF9lbXZhbCgpIHsKICAgICAgZm9yICh2YXIgaSA9IDU7IGkgPCBlbXZhbF9oYW5kbGVfYXJyYXkubGVuZ3RoOyArK2kpIHsKICAgICAgICBpZiAoZW12YWxfaGFuZGxlX2FycmF5W2ldICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgIHJldHVybiBlbXZhbF9oYW5kbGVfYXJyYXlbaV0KICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIG51bGwKICAgIH0KICAgIGZ1bmN0aW9uIGluaXRfZW12YWwoKSB7CiAgICAgIE1vZHVsZVsnY291bnRfZW12YWxfaGFuZGxlcyddID0gY291bnRfZW12YWxfaGFuZGxlczsKICAgICAgTW9kdWxlWydnZXRfZmlyc3RfZW12YWwnXSA9IGdldF9maXJzdF9lbXZhbDsKICAgIH0KICAgIGZ1bmN0aW9uIF9fZW12YWxfcmVnaXN0ZXIodmFsdWUpIHsKICAgICAgc3dpdGNoICh2YWx1ZSkgewogICAgICAgIGNhc2UgdW5kZWZpbmVkOiB7CiAgICAgICAgICByZXR1cm4gMQogICAgICAgIH0KICAgICAgICBjYXNlIG51bGw6IHsKICAgICAgICAgIHJldHVybiAyCiAgICAgICAgfQogICAgICAgIGNhc2UgdHJ1ZTogewogICAgICAgICAgcmV0dXJuIDMKICAgICAgICB9CiAgICAgICAgY2FzZSBmYWxzZTogewogICAgICAgICAgcmV0dXJuIDQKICAgICAgICB9CiAgICAgICAgZGVmYXVsdDogewogICAgICAgICAgdmFyIGhhbmRsZSA9IGVtdmFsX2ZyZWVfbGlzdC5sZW5ndGggPyBlbXZhbF9mcmVlX2xpc3QucG9wKCkgOiBlbXZhbF9oYW5kbGVfYXJyYXkubGVuZ3RoOwogICAgICAgICAgZW12YWxfaGFuZGxlX2FycmF5W2hhbmRsZV0gPSB7IHJlZmNvdW50OiAxLCB2YWx1ZTogdmFsdWUgfTsKICAgICAgICAgIHJldHVybiBoYW5kbGUKICAgICAgICB9CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX2VtdmFsKHJhd1R5cGUsIG5hbWUpIHsKICAgICAgbmFtZSA9IHJlYWRMYXRpbjFTdHJpbmcobmFtZSk7CiAgICAgIHJlZ2lzdGVyVHlwZShyYXdUeXBlLCB7CiAgICAgICAgbmFtZTogbmFtZSwKICAgICAgICBmcm9tV2lyZVR5cGU6IGZ1bmN0aW9uIChoYW5kbGUpIHsKICAgICAgICAgIHZhciBydiA9IGVtdmFsX2hhbmRsZV9hcnJheVtoYW5kbGVdLnZhbHVlOwogICAgICAgICAgX19lbXZhbF9kZWNyZWYoaGFuZGxlKTsKICAgICAgICAgIHJldHVybiBydgogICAgICAgIH0sCiAgICAgICAgdG9XaXJlVHlwZTogZnVuY3Rpb24gKGRlc3RydWN0b3JzLCB2YWx1ZSkgewogICAgICAgICAgcmV0dXJuIF9fZW12YWxfcmVnaXN0ZXIodmFsdWUpCiAgICAgICAgfSwKICAgICAgICBhcmdQYWNrQWR2YW5jZTogOCwKICAgICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogc2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIsCiAgICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uOiBudWxsLAogICAgICB9KTsKICAgIH0KICAgIGZ1bmN0aW9uIF9lbWJpbmRfcmVwcih2KSB7CiAgICAgIGlmICh2ID09PSBudWxsKSB7CiAgICAgICAgcmV0dXJuICdudWxsJwogICAgICB9CiAgICAgIHZhciB0ID0gdHlwZW9mIHY7CiAgICAgIGlmICh0ID09PSAnb2JqZWN0JyB8fCB0ID09PSAnYXJyYXknIHx8IHQgPT09ICdmdW5jdGlvbicpIHsKICAgICAgICByZXR1cm4gdi50b1N0cmluZygpCiAgICAgIH0gZWxzZSB7CiAgICAgICAgcmV0dXJuICcnICsgdgogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBmbG9hdFJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsIHNoaWZ0KSB7CiAgICAgIHN3aXRjaCAoc2hpZnQpIHsKICAgICAgICBjYXNlIDI6CiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBvaW50ZXIpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXNbJ2Zyb21XaXJlVHlwZSddKEhFQVBGMzJbcG9pbnRlciA+PiAyXSkKICAgICAgICAgIH0KICAgICAgICBjYXNlIDM6CiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBvaW50ZXIpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXNbJ2Zyb21XaXJlVHlwZSddKEhFQVBGNjRbcG9pbnRlciA+PiAzXSkKICAgICAgICAgIH0KICAgICAgICBkZWZhdWx0OgogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBmbG9hdCB0eXBlOiAnICsgbmFtZSkKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQocmF3VHlwZSwgbmFtZSwgc2l6ZSkgewogICAgICB2YXIgc2hpZnQgPSBnZXRTaGlmdEZyb21TaXplKHNpemUpOwogICAgICBuYW1lID0gcmVhZExhdGluMVN0cmluZyhuYW1lKTsKICAgICAgcmVnaXN0ZXJUeXBlKHJhd1R5cGUsIHsKICAgICAgICBuYW1lOiBuYW1lLAogICAgICAgIGZyb21XaXJlVHlwZTogZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gdmFsdWUKICAgICAgICB9LAogICAgICAgIHRvV2lyZVR5cGU6IGZ1bmN0aW9uIChkZXN0cnVjdG9ycywgdmFsdWUpIHsKICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0ICInICsgX2VtYmluZF9yZXByKHZhbHVlKSArICciIHRvICcgKyB0aGlzLm5hbWUpCiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gdmFsdWUKICAgICAgICB9LAogICAgICAgIGFyZ1BhY2tBZHZhbmNlOiA4LAogICAgICAgIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBmbG9hdFJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsIHNoaWZ0KSwKICAgICAgICBkZXN0cnVjdG9yRnVuY3Rpb246IG51bGwsCiAgICAgIH0pOwogICAgfQogICAgZnVuY3Rpb24gaW50ZWdlclJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsIHNoaWZ0LCBzaWduZWQpIHsKICAgICAgc3dpdGNoIChzaGlmdCkgewogICAgICAgIGNhc2UgMDoKICAgICAgICAgIHJldHVybiBzaWduZWQKICAgICAgICAgICAgPyBmdW5jdGlvbiByZWFkUzhGcm9tUG9pbnRlcihwb2ludGVyKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gSEVBUDhbcG9pbnRlcl0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIDogZnVuY3Rpb24gcmVhZFU4RnJvbVBvaW50ZXIocG9pbnRlcikgewogICAgICAgICAgICAgICAgcmV0dXJuIEhFQVBVOFtwb2ludGVyXQogICAgICAgICAgICAgIH0KICAgICAgICBjYXNlIDE6CiAgICAgICAgICByZXR1cm4gc2lnbmVkCiAgICAgICAgICAgID8gZnVuY3Rpb24gcmVhZFMxNkZyb21Qb2ludGVyKHBvaW50ZXIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBIRUFQMTZbcG9pbnRlciA+PiAxXQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgOiBmdW5jdGlvbiByZWFkVTE2RnJvbVBvaW50ZXIocG9pbnRlcikgewogICAgICAgICAgICAgICAgcmV0dXJuIEhFQVBVMTZbcG9pbnRlciA+PiAxXQogICAgICAgICAgICAgIH0KICAgICAgICBjYXNlIDI6CiAgICAgICAgICByZXR1cm4gc2lnbmVkCiAgICAgICAgICAgID8gZnVuY3Rpb24gcmVhZFMzMkZyb21Qb2ludGVyKHBvaW50ZXIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBIRUFQMzJbcG9pbnRlciA+PiAyXQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgOiBmdW5jdGlvbiByZWFkVTMyRnJvbVBvaW50ZXIocG9pbnRlcikgewogICAgICAgICAgICAgICAgcmV0dXJuIEhFQVBVMzJbcG9pbnRlciA+PiAyXQogICAgICAgICAgICAgIH0KICAgICAgICBkZWZhdWx0OgogICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBpbnRlZ2VyIHR5cGU6ICcgKyBuYW1lKQogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyKHByaW1pdGl2ZVR5cGUsIG5hbWUsIHNpemUsIG1pblJhbmdlLCBtYXhSYW5nZSkgewogICAgICBuYW1lID0gcmVhZExhdGluMVN0cmluZyhuYW1lKTsKICAgICAgaWYgKG1heFJhbmdlID09PSAtMSkgewogICAgICAgIG1heFJhbmdlID0gNDI5NDk2NzI5NTsKICAgICAgfQogICAgICB2YXIgc2hpZnQgPSBnZXRTaGlmdEZyb21TaXplKHNpemUpOwogICAgICB2YXIgZnJvbVdpcmVUeXBlID0gZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAgICAgcmV0dXJuIHZhbHVlCiAgICAgIH07CiAgICAgIGlmIChtaW5SYW5nZSA9PT0gMCkgewogICAgICAgIHZhciBiaXRzaGlmdCA9IDMyIC0gOCAqIHNpemU7CiAgICAgICAgZnJvbVdpcmVUeXBlID0gZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAgICAgICByZXR1cm4gKHZhbHVlIDw8IGJpdHNoaWZ0KSA+Pj4gYml0c2hpZnQKICAgICAgICB9OwogICAgICB9CiAgICAgIHZhciBpc1Vuc2lnbmVkVHlwZSA9IG5hbWUuaW5kZXhPZigndW5zaWduZWQnKSAhPSAtMTsKICAgICAgcmVnaXN0ZXJUeXBlKHByaW1pdGl2ZVR5cGUsIHsKICAgICAgICBuYW1lOiBuYW1lLAogICAgICAgIGZyb21XaXJlVHlwZTogZnJvbVdpcmVUeXBlLAogICAgICAgIHRvV2lyZVR5cGU6IGZ1bmN0aW9uIChkZXN0cnVjdG9ycywgdmFsdWUpIHsKICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0ICInICsgX2VtYmluZF9yZXByKHZhbHVlKSArICciIHRvICcgKyB0aGlzLm5hbWUpCiAgICAgICAgICB9CiAgICAgICAgICBpZiAodmFsdWUgPCBtaW5SYW5nZSB8fCB2YWx1ZSA+IG1heFJhbmdlKSB7CiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoCiAgICAgICAgICAgICAgJ1Bhc3NpbmcgYSBudW1iZXIgIicgKwogICAgICAgICAgICAgICAgX2VtYmluZF9yZXByKHZhbHVlKSArCiAgICAgICAgICAgICAgICAnIiBmcm9tIEpTIHNpZGUgdG8gQy9DKysgc2lkZSB0byBhbiBhcmd1bWVudCBvZiB0eXBlICInICsKICAgICAgICAgICAgICAgIG5hbWUgKwogICAgICAgICAgICAgICAgJyIsIHdoaWNoIGlzIG91dHNpZGUgdGhlIHZhbGlkIHJhbmdlIFsnICsKICAgICAgICAgICAgICAgIG1pblJhbmdlICsKICAgICAgICAgICAgICAgICcsICcgKwogICAgICAgICAgICAgICAgbWF4UmFuZ2UgKwogICAgICAgICAgICAgICAgJ10hJwogICAgICAgICAgICApCiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gaXNVbnNpZ25lZFR5cGUgPyB2YWx1ZSA+Pj4gMCA6IHZhbHVlIHwgMAogICAgICAgIH0sCiAgICAgICAgYXJnUGFja0FkdmFuY2U6IDgsCiAgICAgICAgcmVhZFZhbHVlRnJvbVBvaW50ZXI6IGludGVnZXJSZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLCBzaGlmdCwgbWluUmFuZ2UgIT09IDApLAogICAgICAgIGRlc3RydWN0b3JGdW5jdGlvbjogbnVsbCwKICAgICAgfSk7CiAgICB9CiAgICBmdW5jdGlvbiBfX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldyhyYXdUeXBlLCBkYXRhVHlwZUluZGV4LCBuYW1lKSB7CiAgICAgIHZhciB0eXBlTWFwcGluZyA9IFsKICAgICAgICBJbnQ4QXJyYXksCiAgICAgICAgVWludDhBcnJheSwKICAgICAgICBJbnQxNkFycmF5LAogICAgICAgIFVpbnQxNkFycmF5LAogICAgICAgIEludDMyQXJyYXksCiAgICAgICAgVWludDMyQXJyYXksCiAgICAgICAgRmxvYXQzMkFycmF5LAogICAgICAgIEZsb2F0NjRBcnJheSwKICAgICAgXTsKICAgICAgdmFyIFRBID0gdHlwZU1hcHBpbmdbZGF0YVR5cGVJbmRleF07CiAgICAgIGZ1bmN0aW9uIGRlY29kZU1lbW9yeVZpZXcoaGFuZGxlKSB7CiAgICAgICAgaGFuZGxlID0gaGFuZGxlID4+IDI7CiAgICAgICAgdmFyIGhlYXAgPSBIRUFQVTMyOwogICAgICAgIHZhciBzaXplID0gaGVhcFtoYW5kbGVdOwogICAgICAgIHZhciBkYXRhID0gaGVhcFtoYW5kbGUgKyAxXTsKICAgICAgICByZXR1cm4gbmV3IFRBKGhlYXBbJ2J1ZmZlciddLCBkYXRhLCBzaXplKQogICAgICB9CiAgICAgIG5hbWUgPSByZWFkTGF0aW4xU3RyaW5nKG5hbWUpOwogICAgICByZWdpc3RlclR5cGUoCiAgICAgICAgcmF3VHlwZSwKICAgICAgICB7IG5hbWU6IG5hbWUsIGZyb21XaXJlVHlwZTogZGVjb2RlTWVtb3J5VmlldywgYXJnUGFja0FkdmFuY2U6IDgsIHJlYWRWYWx1ZUZyb21Qb2ludGVyOiBkZWNvZGVNZW1vcnlWaWV3IH0sCiAgICAgICAgeyBpZ25vcmVEdXBsaWNhdGVSZWdpc3RyYXRpb25zOiB0cnVlIH0KICAgICAgKTsKICAgIH0KICAgIGZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmcocmF3VHlwZSwgbmFtZSkgewogICAgICBuYW1lID0gcmVhZExhdGluMVN0cmluZyhuYW1lKTsKICAgICAgcmVnaXN0ZXJUeXBlKHJhd1R5cGUsIHsKICAgICAgICBuYW1lOiBuYW1lLAogICAgICAgIGZyb21XaXJlVHlwZTogZnVuY3Rpb24gKHZhbHVlKSB7CiAgICAgICAgICB2YXIgbGVuZ3RoID0gSEVBUFUzMlt2YWx1ZSA+PiAyXTsKICAgICAgICAgIHZhciBhID0gbmV3IEFycmF5KGxlbmd0aCk7CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIGFbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKEhFQVBVOFt2YWx1ZSArIDQgKyBpXSk7CiAgICAgICAgICB9CiAgICAgICAgICBfZnJlZSh2YWx1ZSk7CiAgICAgICAgICByZXR1cm4gYS5qb2luKCcnKQogICAgICAgIH0sCiAgICAgICAgdG9XaXJlVHlwZTogZnVuY3Rpb24gKGRlc3RydWN0b3JzLCB2YWx1ZSkgewogICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHsKICAgICAgICAgICAgdmFsdWUgPSBuZXcgVWludDhBcnJheSh2YWx1ZSk7CiAgICAgICAgICB9CiAgICAgICAgICBmdW5jdGlvbiBnZXRUQUVsZW1lbnQodGEsIGluZGV4KSB7CiAgICAgICAgICAgIHJldHVybiB0YVtpbmRleF0KICAgICAgICAgIH0KICAgICAgICAgIGZ1bmN0aW9uIGdldFN0cmluZ0VsZW1lbnQoc3RyaW5nLCBpbmRleCkgewogICAgICAgICAgICByZXR1cm4gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpCiAgICAgICAgICB9CiAgICAgICAgICB2YXIgZ2V0RWxlbWVudDsKICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHsKICAgICAgICAgICAgZ2V0RWxlbWVudCA9IGdldFRBRWxlbWVudDsKICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkgewogICAgICAgICAgICBnZXRFbGVtZW50ID0gZ2V0VEFFbGVtZW50OwogICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEludDhBcnJheSkgewogICAgICAgICAgICBnZXRFbGVtZW50ID0gZ2V0VEFFbGVtZW50OwogICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICAgIGdldEVsZW1lbnQgPSBnZXRTdHJpbmdFbGVtZW50OwogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhyb3dCaW5kaW5nRXJyb3IoJ0Nhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gc3RkOjpzdHJpbmcnKTsKICAgICAgICAgIH0KICAgICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7CiAgICAgICAgICB2YXIgcHRyID0gX21hbGxvYyg0ICsgbGVuZ3RoKTsKICAgICAgICAgIEhFQVBVMzJbcHRyID4+IDJdID0gbGVuZ3RoOwogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgICB2YXIgY2hhckNvZGUgPSBnZXRFbGVtZW50KHZhbHVlLCBpKTsKICAgICAgICAgICAgaWYgKGNoYXJDb2RlID4gMjU1KSB7CiAgICAgICAgICAgICAgX2ZyZWUocHRyKTsKICAgICAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignU3RyaW5nIGhhcyBVVEYtMTYgY29kZSB1bml0cyB0aGF0IGRvIG5vdCBmaXQgaW4gOCBiaXRzJyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgSEVBUFU4W3B0ciArIDQgKyBpXSA9IGNoYXJDb2RlOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGRlc3RydWN0b3JzICE9PSBudWxsKSB7CiAgICAgICAgICAgIGRlc3RydWN0b3JzLnB1c2goX2ZyZWUsIHB0cik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcHRyCiAgICAgICAgfSwKICAgICAgICBhcmdQYWNrQWR2YW5jZTogOCwKICAgICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogc2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIsCiAgICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uOiBmdW5jdGlvbiAocHRyKSB7CiAgICAgICAgICBfZnJlZShwdHIpOwogICAgICAgIH0sCiAgICAgIH0pOwogICAgfQogICAgZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmcocmF3VHlwZSwgY2hhclNpemUsIG5hbWUpIHsKICAgICAgbmFtZSA9IHJlYWRMYXRpbjFTdHJpbmcobmFtZSk7CiAgICAgIHZhciBnZXRIZWFwLCBzaGlmdDsKICAgICAgaWYgKGNoYXJTaXplID09PSAyKSB7CiAgICAgICAgZ2V0SGVhcCA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHJldHVybiBIRUFQVTE2CiAgICAgICAgfTsKICAgICAgICBzaGlmdCA9IDE7CiAgICAgIH0gZWxzZSBpZiAoY2hhclNpemUgPT09IDQpIHsKICAgICAgICBnZXRIZWFwID0gZnVuY3Rpb24gKCkgewogICAgICAgICAgcmV0dXJuIEhFQVBVMzIKICAgICAgICB9OwogICAgICAgIHNoaWZ0ID0gMjsKICAgICAgfQogICAgICByZWdpc3RlclR5cGUocmF3VHlwZSwgewogICAgICAgIG5hbWU6IG5hbWUsCiAgICAgICAgZnJvbVdpcmVUeXBlOiBmdW5jdGlvbiAodmFsdWUpIHsKICAgICAgICAgIHZhciBIRUFQID0gZ2V0SGVhcCgpOwogICAgICAgICAgdmFyIGxlbmd0aCA9IEhFQVBVMzJbdmFsdWUgPj4gMl07CiAgICAgICAgICB2YXIgYSA9IG5ldyBBcnJheShsZW5ndGgpOwogICAgICAgICAgdmFyIHN0YXJ0ID0gKHZhbHVlICsgNCkgPj4gc2hpZnQ7CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgIGFbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKEhFQVBbc3RhcnQgKyBpXSk7CiAgICAgICAgICB9CiAgICAgICAgICBfZnJlZSh2YWx1ZSk7CiAgICAgICAgICByZXR1cm4gYS5qb2luKCcnKQogICAgICAgIH0sCiAgICAgICAgdG9XaXJlVHlwZTogZnVuY3Rpb24gKGRlc3RydWN0b3JzLCB2YWx1ZSkgewogICAgICAgICAgdmFyIEhFQVAgPSBnZXRIZWFwKCk7CiAgICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOwogICAgICAgICAgdmFyIHB0ciA9IF9tYWxsb2MoNCArIGxlbmd0aCAqIGNoYXJTaXplKTsKICAgICAgICAgIEhFQVBVMzJbcHRyID4+IDJdID0gbGVuZ3RoOwogICAgICAgICAgdmFyIHN0YXJ0ID0gKHB0ciArIDQpID4+IHNoaWZ0OwogICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkgewogICAgICAgICAgICBIRUFQW3N0YXJ0ICsgaV0gPSB2YWx1ZS5jaGFyQ29kZUF0KGkpOwogICAgICAgICAgfQogICAgICAgICAgaWYgKGRlc3RydWN0b3JzICE9PSBudWxsKSB7CiAgICAgICAgICAgIGRlc3RydWN0b3JzLnB1c2goX2ZyZWUsIHB0cik7CiAgICAgICAgICB9CiAgICAgICAgICByZXR1cm4gcHRyCiAgICAgICAgfSwKICAgICAgICBhcmdQYWNrQWR2YW5jZTogOCwKICAgICAgICByZWFkVmFsdWVGcm9tUG9pbnRlcjogc2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIsCiAgICAgICAgZGVzdHJ1Y3RvckZ1bmN0aW9uOiBmdW5jdGlvbiAocHRyKSB7CiAgICAgICAgICBfZnJlZShwdHIpOwogICAgICAgIH0sCiAgICAgIH0pOwogICAgfQogICAgZnVuY3Rpb24gX19lbWJpbmRfcmVnaXN0ZXJfdmFsdWVfb2JqZWN0KAogICAgICByYXdUeXBlLAogICAgICBuYW1lLAogICAgICBjb25zdHJ1Y3RvclNpZ25hdHVyZSwKICAgICAgcmF3Q29uc3RydWN0b3IsCiAgICAgIGRlc3RydWN0b3JTaWduYXR1cmUsCiAgICAgIHJhd0Rlc3RydWN0b3IKICAgICkgewogICAgICBzdHJ1Y3RSZWdpc3RyYXRpb25zW3Jhd1R5cGVdID0gewogICAgICAgIG5hbWU6IHJlYWRMYXRpbjFTdHJpbmcobmFtZSksCiAgICAgICAgcmF3Q29uc3RydWN0b3I6IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGNvbnN0cnVjdG9yU2lnbmF0dXJlLCByYXdDb25zdHJ1Y3RvciksCiAgICAgICAgcmF3RGVzdHJ1Y3RvcjogZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZGVzdHJ1Y3RvclNpZ25hdHVyZSwgcmF3RGVzdHJ1Y3RvciksCiAgICAgICAgZmllbGRzOiBbXSwKICAgICAgfTsKICAgIH0KICAgIGZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdF9maWVsZCgKICAgICAgc3RydWN0VHlwZSwKICAgICAgZmllbGROYW1lLAogICAgICBnZXR0ZXJSZXR1cm5UeXBlLAogICAgICBnZXR0ZXJTaWduYXR1cmUsCiAgICAgIGdldHRlciwKICAgICAgZ2V0dGVyQ29udGV4dCwKICAgICAgc2V0dGVyQXJndW1lbnRUeXBlLAogICAgICBzZXR0ZXJTaWduYXR1cmUsCiAgICAgIHNldHRlciwKICAgICAgc2V0dGVyQ29udGV4dAogICAgKSB7CiAgICAgIHN0cnVjdFJlZ2lzdHJhdGlvbnNbc3RydWN0VHlwZV0uZmllbGRzLnB1c2goewogICAgICAgIGZpZWxkTmFtZTogcmVhZExhdGluMVN0cmluZyhmaWVsZE5hbWUpLAogICAgICAgIGdldHRlclJldHVyblR5cGU6IGdldHRlclJldHVyblR5cGUsCiAgICAgICAgZ2V0dGVyOiBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihnZXR0ZXJTaWduYXR1cmUsIGdldHRlciksCiAgICAgICAgZ2V0dGVyQ29udGV4dDogZ2V0dGVyQ29udGV4dCwKICAgICAgICBzZXR0ZXJBcmd1bWVudFR5cGU6IHNldHRlckFyZ3VtZW50VHlwZSwKICAgICAgICBzZXR0ZXI6IGVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKHNldHRlclNpZ25hdHVyZSwgc2V0dGVyKSwKICAgICAgICBzZXR0ZXJDb250ZXh0OiBzZXR0ZXJDb250ZXh0LAogICAgICB9KTsKICAgIH0KICAgIGZ1bmN0aW9uIF9fZW1iaW5kX3JlZ2lzdGVyX3ZvaWQocmF3VHlwZSwgbmFtZSkgewogICAgICBuYW1lID0gcmVhZExhdGluMVN0cmluZyhuYW1lKTsKICAgICAgcmVnaXN0ZXJUeXBlKHJhd1R5cGUsIHsKICAgICAgICBpc1ZvaWQ6IHRydWUsCiAgICAgICAgbmFtZTogbmFtZSwKICAgICAgICBhcmdQYWNrQWR2YW5jZTogMCwKICAgICAgICBmcm9tV2lyZVR5cGU6IGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHJldHVybiB1bmRlZmluZWQKICAgICAgICB9LAogICAgICAgIHRvV2lyZVR5cGU6IGZ1bmN0aW9uIChkZXN0cnVjdG9ycywgbykgewogICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZAogICAgICAgIH0sCiAgICAgIH0pOwogICAgfQogICAgZnVuY3Rpb24gX2Fib3J0KCkgewogICAgICBNb2R1bGVbJ2Fib3J0J10oKTsKICAgIH0KICAgIHZhciBfZW52aXJvbiA9IFNUQVRJQ1RPUDsKICAgIFNUQVRJQ1RPUCArPSAxNjsKICAgIGZ1bmN0aW9uIF9fX2J1aWxkRW52aXJvbm1lbnQoZW52KSB7CiAgICAgIHZhciBNQVhfRU5WX1ZBTFVFUyA9IDY0OwogICAgICB2YXIgVE9UQUxfRU5WX1NJWkUgPSAxMDI0OwogICAgICB2YXIgcG9vbFB0cjsKICAgICAgdmFyIGVudlB0cjsKICAgICAgaWYgKCFfX19idWlsZEVudmlyb25tZW50LmNhbGxlZCkgewogICAgICAgIF9fX2J1aWxkRW52aXJvbm1lbnQuY2FsbGVkID0gdHJ1ZTsKICAgICAgICBFTlZbJ1VTRVInXSA9IEVOVlsnTE9HTkFNRSddID0gJ3dlYl91c2VyJzsKICAgICAgICBFTlZbJ1BBVEgnXSA9ICcvJzsKICAgICAgICBFTlZbJ1BXRCddID0gJy8nOwogICAgICAgIEVOVlsnSE9NRSddID0gJy9ob21lL3dlYl91c2VyJzsKICAgICAgICBFTlZbJ0xBTkcnXSA9ICdDLlVURi04JzsKICAgICAgICBFTlZbJ18nXSA9IE1vZHVsZVsndGhpc1Byb2dyYW0nXTsKICAgICAgICBwb29sUHRyID0gc3RhdGljQWxsb2MoVE9UQUxfRU5WX1NJWkUpOwogICAgICAgIGVudlB0ciA9IHN0YXRpY0FsbG9jKE1BWF9FTlZfVkFMVUVTICogNCk7CiAgICAgICAgSEVBUDMyW2VudlB0ciA+PiAyXSA9IHBvb2xQdHI7CiAgICAgICAgSEVBUDMyW19lbnZpcm9uID4+IDJdID0gZW52UHRyOwogICAgICB9IGVsc2UgewogICAgICAgIGVudlB0ciA9IEhFQVAzMltfZW52aXJvbiA+PiAyXTsKICAgICAgICBwb29sUHRyID0gSEVBUDMyW2VudlB0ciA+PiAyXTsKICAgICAgfQogICAgICB2YXIgc3RyaW5ncyA9IFtdOwogICAgICB2YXIgdG90YWxTaXplID0gMDsKICAgICAgZm9yICh2YXIga2V5IGluIGVudikgewogICAgICAgIGlmICh0eXBlb2YgZW52W2tleV0gPT09ICdzdHJpbmcnKSB7CiAgICAgICAgICB2YXIgbGluZSA9IGtleSArICc9JyArIGVudltrZXldOwogICAgICAgICAgc3RyaW5ncy5wdXNoKGxpbmUpOwogICAgICAgICAgdG90YWxTaXplICs9IGxpbmUubGVuZ3RoOwogICAgICAgIH0KICAgICAgfQogICAgICBpZiAodG90YWxTaXplID4gVE9UQUxfRU5WX1NJWkUpIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vudmlyb25tZW50IHNpemUgZXhjZWVkZWQgVE9UQUxfRU5WX1NJWkUhJykKICAgICAgfQogICAgICB2YXIgcHRyU2l6ZSA9IDQ7CiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciBsaW5lID0gc3RyaW5nc1tpXTsKICAgICAgICB3cml0ZUFzY2lpVG9NZW1vcnkobGluZSwgcG9vbFB0cik7CiAgICAgICAgSEVBUDMyWyhlbnZQdHIgKyBpICogcHRyU2l6ZSkgPj4gMl0gPSBwb29sUHRyOwogICAgICAgIHBvb2xQdHIgKz0gbGluZS5sZW5ndGggKyAxOwogICAgICB9CiAgICAgIEhFQVAzMlsoZW52UHRyICsgc3RyaW5ncy5sZW5ndGggKiBwdHJTaXplKSA+PiAyXSA9IDA7CiAgICB9CiAgICB2YXIgRU5WID0ge307CiAgICBmdW5jdGlvbiBfZ2V0ZW52KG5hbWUpIHsKICAgICAgaWYgKG5hbWUgPT09IDApIHJldHVybiAwCiAgICAgIG5hbWUgPSBQb2ludGVyX3N0cmluZ2lmeShuYW1lKTsKICAgICAgaWYgKCFFTlYuaGFzT3duUHJvcGVydHkobmFtZSkpIHJldHVybiAwCiAgICAgIGlmIChfZ2V0ZW52LnJldCkgX2ZyZWUoX2dldGVudi5yZXQpOwogICAgICBfZ2V0ZW52LnJldCA9IGFsbG9jYXRlVVRGOChFTlZbbmFtZV0pOwogICAgICByZXR1cm4gX2dldGVudi5yZXQKICAgIH0KICAgIGZ1bmN0aW9uIF9nZXRncm5hbSgpIHsKICAgICAgTW9kdWxlWydwcmludEVyciddKCdtaXNzaW5nIGZ1bmN0aW9uOiBnZXRncm5hbScpOwogICAgICBhYm9ydCgtMSk7CiAgICB9CiAgICBmdW5jdGlvbiBfZ2V0cHduYW0oKSB7CiAgICAgIHRocm93ICdnZXRwd25hbTogVE9ETycKICAgIH0KICAgIGZ1bmN0aW9uIF9qc0Nsb3NlKCkgewogICAgICByZXR1cm4ganNBUEkuY2xvc2UuYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfQogICAgZnVuY3Rpb24gX2pzQ3JlYXRlKGZpbGVuYW1lKSB7CiAgICAgIHJldHVybiBqc0FQSS5jcmVhdGUuY2FsbChudWxsLCBVVEYzMlRvU3RyaW5nKGZpbGVuYW1lKSkKICAgIH0KICAgIGZ1bmN0aW9uIF9qc09wZW4oZmlsZW5hbWUpIHsKICAgICAgcmV0dXJuIGpzQVBJLm9wZW4uY2FsbChudWxsLCBVVEYzMlRvU3RyaW5nKGZpbGVuYW1lKSkKICAgIH0KICAgIGZ1bmN0aW9uIF9qc1JlYWQoKSB7CiAgICAgIHJldHVybiBqc0FQSS5yZWFkLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0KICAgIGZ1bmN0aW9uIF9qc1NlZWsoZmQsIG9mZnNldCwgbWV0aG9kKSB7CiAgICAgIHJldHVybiBqc0FQSS5zZWVrLmNhbGwobnVsbCwgZmQsIG9mZnNldCwgVVRGOFRvU3RyaW5nKG1ldGhvZCkpCiAgICB9CiAgICBmdW5jdGlvbiBfanNUZWxsKCkgewogICAgICByZXR1cm4ganNBUEkudGVsbC5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9CiAgICBmdW5jdGlvbiBfanNXcml0ZSgpIHsKICAgICAgcmV0dXJuIGpzQVBJLndyaXRlLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0KICAgIGZ1bmN0aW9uIF9sbHZtX2VoX3R5cGVpZF9mb3IodHlwZSkgewogICAgICByZXR1cm4gdHlwZQogICAgfQogICAgdmFyIF9fX3RtX2N1cnJlbnQgPSBTVEFUSUNUT1A7CiAgICBTVEFUSUNUT1AgKz0gNDg7CiAgICBhbGxvY2F0ZShpbnRBcnJheUZyb21TdHJpbmcoJ0dNVCcpLCAnaTgnLCBBTExPQ19TVEFUSUMpOwogICAgdmFyIF90em5hbWUgPSBTVEFUSUNUT1A7CiAgICBTVEFUSUNUT1AgKz0gMTY7CiAgICB2YXIgX2RheWxpZ2h0ID0gU1RBVElDVE9QOwogICAgU1RBVElDVE9QICs9IDE2OwogICAgdmFyIF90aW1lem9uZSA9IFNUQVRJQ1RPUDsKICAgIFNUQVRJQ1RPUCArPSAxNjsKICAgIGZ1bmN0aW9uIF90enNldCgpIHsKICAgICAgaWYgKF90enNldC5jYWxsZWQpIHJldHVybgogICAgICBfdHpzZXQuY2FsbGVkID0gdHJ1ZTsKICAgICAgSEVBUDMyW190aW1lem9uZSA+PiAyXSA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwOwogICAgICB2YXIgd2ludGVyID0gbmV3IERhdGUoMmUzLCAwLCAxKTsKICAgICAgdmFyIHN1bW1lciA9IG5ldyBEYXRlKDJlMywgNiwgMSk7CiAgICAgIEhFQVAzMltfZGF5bGlnaHQgPj4gMl0gPSBOdW1iZXIod2ludGVyLmdldFRpbWV6b25lT2Zmc2V0KCkgIT0gc3VtbWVyLmdldFRpbWV6b25lT2Zmc2V0KCkpOwogICAgICBmdW5jdGlvbiBleHRyYWN0Wm9uZShkYXRlKSB7CiAgICAgICAgdmFyIG1hdGNoID0gZGF0ZS50b1RpbWVTdHJpbmcoKS5tYXRjaCgvXCgoW0EtWmEteiBdKylcKSQvKTsKICAgICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICdHTVQnCiAgICAgIH0KICAgICAgdmFyIHdpbnRlck5hbWUgPSBleHRyYWN0Wm9uZSh3aW50ZXIpOwogICAgICB2YXIgc3VtbWVyTmFtZSA9IGV4dHJhY3Rab25lKHN1bW1lcik7CiAgICAgIHZhciB3aW50ZXJOYW1lUHRyID0gYWxsb2NhdGUoaW50QXJyYXlGcm9tU3RyaW5nKHdpbnRlck5hbWUpLCAnaTgnLCBBTExPQ19OT1JNQUwpOwogICAgICB2YXIgc3VtbWVyTmFtZVB0ciA9IGFsbG9jYXRlKGludEFycmF5RnJvbVN0cmluZyhzdW1tZXJOYW1lKSwgJ2k4JywgQUxMT0NfTk9STUFMKTsKICAgICAgaWYgKHN1bW1lci5nZXRUaW1lem9uZU9mZnNldCgpIDwgd2ludGVyLmdldFRpbWV6b25lT2Zmc2V0KCkpIHsKICAgICAgICBIRUFQMzJbX3R6bmFtZSA+PiAyXSA9IHdpbnRlck5hbWVQdHI7CiAgICAgICAgSEVBUDMyWyhfdHpuYW1lICsgNCkgPj4gMl0gPSBzdW1tZXJOYW1lUHRyOwogICAgICB9IGVsc2UgewogICAgICAgIEhFQVAzMltfdHpuYW1lID4+IDJdID0gc3VtbWVyTmFtZVB0cjsKICAgICAgICBIRUFQMzJbKF90em5hbWUgKyA0KSA+PiAyXSA9IHdpbnRlck5hbWVQdHI7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIF9sb2NhbHRpbWVfcih0aW1lLCB0bVB0cikgewogICAgICBfdHpzZXQoKTsKICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZShIRUFQMzJbdGltZSA+PiAyXSAqIDFlMyk7CiAgICAgIEhFQVAzMlt0bVB0ciA+PiAyXSA9IGRhdGUuZ2V0U2Vjb25kcygpOwogICAgICBIRUFQMzJbKHRtUHRyICsgNCkgPj4gMl0gPSBkYXRlLmdldE1pbnV0ZXMoKTsKICAgICAgSEVBUDMyWyh0bVB0ciArIDgpID4+IDJdID0gZGF0ZS5nZXRIb3VycygpOwogICAgICBIRUFQMzJbKHRtUHRyICsgMTIpID4+IDJdID0gZGF0ZS5nZXREYXRlKCk7CiAgICAgIEhFQVAzMlsodG1QdHIgKyAxNikgPj4gMl0gPSBkYXRlLmdldE1vbnRoKCk7CiAgICAgIEhFQVAzMlsodG1QdHIgKyAyMCkgPj4gMl0gPSBkYXRlLmdldEZ1bGxZZWFyKCkgLSAxOTAwOwogICAgICBIRUFQMzJbKHRtUHRyICsgMjQpID4+IDJdID0gZGF0ZS5nZXREYXkoKTsKICAgICAgdmFyIHN0YXJ0ID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTsKICAgICAgdmFyIHlkYXkgPSAoKGRhdGUuZ2V0VGltZSgpIC0gc3RhcnQuZ2V0VGltZSgpKSAvICgxZTMgKiA2MCAqIDYwICogMjQpKSB8IDA7CiAgICAgIEhFQVAzMlsodG1QdHIgKyAyOCkgPj4gMl0gPSB5ZGF5OwogICAgICBIRUFQMzJbKHRtUHRyICsgMzYpID4+IDJdID0gLShkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MCk7CiAgICAgIHZhciBzdW1tZXJPZmZzZXQgPSBuZXcgRGF0ZSgyZTMsIDYsIDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7CiAgICAgIHZhciB3aW50ZXJPZmZzZXQgPSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpOwogICAgICB2YXIgZHN0ID0gKHN1bW1lck9mZnNldCAhPSB3aW50ZXJPZmZzZXQgJiYgZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpID09IE1hdGgubWluKHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KSkgfCAwOwogICAgICBIRUFQMzJbKHRtUHRyICsgMzIpID4+IDJdID0gZHN0OwogICAgICB2YXIgem9uZVB0ciA9IEhFQVAzMlsoX3R6bmFtZSArIChkc3QgPyA0IDogMCkpID4+IDJdOwogICAgICBIRUFQMzJbKHRtUHRyICsgNDApID4+IDJdID0gem9uZVB0cjsKICAgICAgcmV0dXJuIHRtUHRyCiAgICB9CiAgICBmdW5jdGlvbiBfbG9jYWx0aW1lKHRpbWUpIHsKICAgICAgcmV0dXJuIF9sb2NhbHRpbWVfcih0aW1lLCBfX190bV9jdXJyZW50KQogICAgfQogICAgZnVuY3Rpb24gX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZyhkZXN0LCBzcmMsIG51bSkgewogICAgICBIRUFQVTguc2V0KEhFQVBVOC5zdWJhcnJheShzcmMsIHNyYyArIG51bSksIGRlc3QpOwogICAgICByZXR1cm4gZGVzdAogICAgfQogICAgZnVuY3Rpb24gX21rdGltZSh0bVB0cikgewogICAgICBfdHpzZXQoKTsKICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgKICAgICAgICBIRUFQMzJbKHRtUHRyICsgMjApID4+IDJdICsgMTkwMCwKICAgICAgICBIRUFQMzJbKHRtUHRyICsgMTYpID4+IDJdLAogICAgICAgIEhFQVAzMlsodG1QdHIgKyAxMikgPj4gMl0sCiAgICAgICAgSEVBUDMyWyh0bVB0ciArIDgpID4+IDJdLAogICAgICAgIEhFQVAzMlsodG1QdHIgKyA0KSA+PiAyXSwKICAgICAgICBIRUFQMzJbdG1QdHIgPj4gMl0sCiAgICAgICAgMAogICAgICApOwogICAgICB2YXIgZHN0ID0gSEVBUDMyWyh0bVB0ciArIDMyKSA+PiAyXTsKICAgICAgdmFyIGd1ZXNzZWRPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7CiAgICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSk7CiAgICAgIHZhciBzdW1tZXJPZmZzZXQgPSBuZXcgRGF0ZSgyZTMsIDYsIDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7CiAgICAgIHZhciB3aW50ZXJPZmZzZXQgPSBzdGFydC5nZXRUaW1lem9uZU9mZnNldCgpOwogICAgICB2YXIgZHN0T2Zmc2V0ID0gTWF0aC5taW4od2ludGVyT2Zmc2V0LCBzdW1tZXJPZmZzZXQpOwogICAgICBpZiAoZHN0IDwgMCkgewogICAgICAgIEhFQVAzMlsodG1QdHIgKyAzMikgPj4gMl0gPSBOdW1iZXIoc3VtbWVyT2Zmc2V0ICE9IHdpbnRlck9mZnNldCAmJiBkc3RPZmZzZXQgPT0gZ3Vlc3NlZE9mZnNldCk7CiAgICAgIH0gZWxzZSBpZiAoZHN0ID4gMCAhPSAoZHN0T2Zmc2V0ID09IGd1ZXNzZWRPZmZzZXQpKSB7CiAgICAgICAgdmFyIG5vbkRzdE9mZnNldCA9IE1hdGgubWF4KHdpbnRlck9mZnNldCwgc3VtbWVyT2Zmc2V0KTsKICAgICAgICB2YXIgdHJ1ZU9mZnNldCA9IGRzdCA+IDAgPyBkc3RPZmZzZXQgOiBub25Ec3RPZmZzZXQ7CiAgICAgICAgZGF0ZS5zZXRUaW1lKGRhdGUuZ2V0VGltZSgpICsgKHRydWVPZmZzZXQgLSBndWVzc2VkT2Zmc2V0KSAqIDZlNCk7CiAgICAgIH0KICAgICAgSEVBUDMyWyh0bVB0ciArIDI0KSA+PiAyXSA9IGRhdGUuZ2V0RGF5KCk7CiAgICAgIHZhciB5ZGF5ID0gKChkYXRlLmdldFRpbWUoKSAtIHN0YXJ0LmdldFRpbWUoKSkgLyAoMWUzICogNjAgKiA2MCAqIDI0KSkgfCAwOwogICAgICBIRUFQMzJbKHRtUHRyICsgMjgpID4+IDJdID0geWRheTsKICAgICAgcmV0dXJuIChkYXRlLmdldFRpbWUoKSAvIDFlMykgfCAwCiAgICB9CiAgICB2YXIgUFRIUkVBRF9TUEVDSUZJQyA9IHt9OwogICAgZnVuY3Rpb24gX3B0aHJlYWRfZ2V0c3BlY2lmaWMoa2V5KSB7CiAgICAgIHJldHVybiBQVEhSRUFEX1NQRUNJRklDW2tleV0gfHwgMAogICAgfQogICAgdmFyIFBUSFJFQURfU1BFQ0lGSUNfTkVYVF9LRVkgPSAxOwogICAgZnVuY3Rpb24gX3B0aHJlYWRfa2V5X2NyZWF0ZShrZXksIGRlc3RydWN0b3IpIHsKICAgICAgaWYgKGtleSA9PSAwKSB7CiAgICAgICAgcmV0dXJuIEVSUk5PX0NPREVTLkVJTlZBTAogICAgICB9CiAgICAgIEhFQVAzMltrZXkgPj4gMl0gPSBQVEhSRUFEX1NQRUNJRklDX05FWFRfS0VZOwogICAgICBQVEhSRUFEX1NQRUNJRklDW1BUSFJFQURfU1BFQ0lGSUNfTkVYVF9LRVldID0gMDsKICAgICAgUFRIUkVBRF9TUEVDSUZJQ19ORVhUX0tFWSsrOwogICAgICByZXR1cm4gMAogICAgfQogICAgZnVuY3Rpb24gX3B0aHJlYWRfb25jZShwdHIsIGZ1bmMpIHsKICAgICAgaWYgKCFfcHRocmVhZF9vbmNlLnNlZW4pIF9wdGhyZWFkX29uY2Uuc2VlbiA9IHt9OwogICAgICBpZiAocHRyIGluIF9wdGhyZWFkX29uY2Uuc2VlbikgcmV0dXJuCiAgICAgIE1vZHVsZVsnZHluQ2FsbF92J10oZnVuYyk7CiAgICAgIF9wdGhyZWFkX29uY2Uuc2VlbltwdHJdID0gMTsKICAgIH0KICAgIGZ1bmN0aW9uIF9wdGhyZWFkX3NldHNwZWNpZmljKGtleSwgdmFsdWUpIHsKICAgICAgaWYgKCEoa2V5IGluIFBUSFJFQURfU1BFQ0lGSUMpKSB7CiAgICAgICAgcmV0dXJuIEVSUk5PX0NPREVTLkVJTlZBTAogICAgICB9CiAgICAgIFBUSFJFQURfU1BFQ0lGSUNba2V5XSA9IHZhbHVlOwogICAgICByZXR1cm4gMAogICAgfQogICAgZnVuY3Rpb24gX3RpbWUocHRyKSB7CiAgICAgIHZhciByZXQgPSAoRGF0ZS5ub3coKSAvIDFlMykgfCAwOwogICAgICBpZiAocHRyKSB7CiAgICAgICAgSEVBUDMyW3B0ciA+PiAyXSA9IHJldDsKICAgICAgfQogICAgICByZXR1cm4gcmV0CiAgICB9CiAgICBGUy5zdGF0aWNJbml0KCk7CiAgICBfX0FUSU5JVF9fLnVuc2hpZnQoZnVuY3Rpb24gKCkgewogICAgICBpZiAoIU1vZHVsZVsnbm9GU0luaXQnXSAmJiAhRlMuaW5pdC5pbml0aWFsaXplZCkgRlMuaW5pdCgpOwogICAgfSk7CiAgICBfX0FUTUFJTl9fLnB1c2goZnVuY3Rpb24gKCkgewogICAgICBGUy5pZ25vcmVQZXJtaXNzaW9ucyA9IGZhbHNlOwogICAgfSk7CiAgICBfX0FURVhJVF9fLnB1c2goZnVuY3Rpb24gKCkgewogICAgICBGUy5xdWl0KCk7CiAgICB9KTsKICAgIF9fQVRJTklUX18udW5zaGlmdChmdW5jdGlvbiAoKSB7CiAgICB9KTsKICAgIF9fQVRFWElUX18ucHVzaChmdW5jdGlvbiAoKSB7CiAgICB9KTsKICAgIEludGVybmFsRXJyb3IgPSBNb2R1bGVbJ0ludGVybmFsRXJyb3InXSA9IGV4dGVuZEVycm9yKEVycm9yLCAnSW50ZXJuYWxFcnJvcicpOwogICAgZW1iaW5kX2luaXRfY2hhckNvZGVzKCk7CiAgICBCaW5kaW5nRXJyb3IgPSBNb2R1bGVbJ0JpbmRpbmdFcnJvciddID0gZXh0ZW5kRXJyb3IoRXJyb3IsICdCaW5kaW5nRXJyb3InKTsKICAgIGluaXRfQ2xhc3NIYW5kbGUoKTsKICAgIGluaXRfUmVnaXN0ZXJlZFBvaW50ZXIoKTsKICAgIGluaXRfZW1iaW5kKCk7CiAgICBVbmJvdW5kVHlwZUVycm9yID0gTW9kdWxlWydVbmJvdW5kVHlwZUVycm9yJ10gPSBleHRlbmRFcnJvcihFcnJvciwgJ1VuYm91bmRUeXBlRXJyb3InKTsKICAgIGluaXRfZW12YWwoKTsKICAgIF9fX2J1aWxkRW52aXJvbm1lbnQoRU5WKTsKICAgIERZTkFNSUNUT1BfUFRSID0gc3RhdGljQWxsb2MoNCk7CiAgICBTVEFDS19CQVNFID0gU1RBQ0tUT1AgPSBhbGlnbk1lbW9yeShTVEFUSUNUT1ApOwogICAgU1RBQ0tfTUFYID0gU1RBQ0tfQkFTRSArIFRPVEFMX1NUQUNLOwogICAgRFlOQU1JQ19CQVNFID0gYWxpZ25NZW1vcnkoU1RBQ0tfTUFYKTsKICAgIEhFQVAzMltEWU5BTUlDVE9QX1BUUiA+PiAyXSA9IERZTkFNSUNfQkFTRTsKICAgIHN0YXRpY1NlYWxlZCA9IHRydWU7CiAgICBmdW5jdGlvbiBpbnRBcnJheUZyb21TdHJpbmcoc3RyaW5neSwgZG9udEFkZE51bGwsIGxlbmd0aCkgewogICAgICB2YXIgbGVuID0gbGVuZ3RoID4gMCA/IGxlbmd0aCA6IGxlbmd0aEJ5dGVzVVRGOChzdHJpbmd5KSArIDE7CiAgICAgIHZhciB1OGFycmF5ID0gbmV3IEFycmF5KGxlbik7CiAgICAgIHZhciBudW1CeXRlc1dyaXR0ZW4gPSBzdHJpbmdUb1VURjhBcnJheShzdHJpbmd5LCB1OGFycmF5LCAwLCB1OGFycmF5Lmxlbmd0aCk7CiAgICAgIGlmIChkb250QWRkTnVsbCkgdThhcnJheS5sZW5ndGggPSBudW1CeXRlc1dyaXR0ZW47CiAgICAgIHJldHVybiB1OGFycmF5CiAgICB9CiAgICBNb2R1bGVbJ3dhc21UYWJsZVNpemUnXSA9IDMxNjsKICAgIE1vZHVsZVsnd2FzbU1heFRhYmxlU2l6ZSddID0gMzE2OwogICAgZnVuY3Rpb24gaW52b2tlX2koaW5kZXgpIHsKICAgICAgdHJ5IHsKICAgICAgICByZXR1cm4gTW9kdWxlWydkeW5DYWxsX2knXShpbmRleCkKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfaWkoaW5kZXgsIGExKSB7CiAgICAgIHRyeSB7CiAgICAgICAgcmV0dXJuIE1vZHVsZVsnZHluQ2FsbF9paSddKGluZGV4LCBhMSkKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfaWlpKGluZGV4LCBhMSwgYTIpIHsKICAgICAgdHJ5IHsKICAgICAgICByZXR1cm4gTW9kdWxlWydkeW5DYWxsX2lpaSddKGluZGV4LCBhMSwgYTIpCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZQogICAgICAgIE1vZHVsZVsnc2V0VGhyZXcnXSgxLCAwKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW52b2tlX2lpaWkoaW5kZXgsIGExLCBhMiwgYTMpIHsKICAgICAgdHJ5IHsKICAgICAgICByZXR1cm4gTW9kdWxlWydkeW5DYWxsX2lpaWknXShpbmRleCwgYTEsIGEyLCBhMykKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfaWlpaWkoaW5kZXgsIGExLCBhMiwgYTMsIGE0KSB7CiAgICAgIHRyeSB7CiAgICAgICAgcmV0dXJuIE1vZHVsZVsnZHluQ2FsbF9paWlpaSddKGluZGV4LCBhMSwgYTIsIGEzLCBhNCkKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfaWlpaWlpaShpbmRleCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNikgewogICAgICB0cnkgewogICAgICAgIHJldHVybiBNb2R1bGVbJ2R5bkNhbGxfaWlpaWlpaSddKGluZGV4LCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2KQogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlICE9PSAnbnVtYmVyJyAmJiBlICE9PSAnbG9uZ2ptcCcpIHRocm93IGUKICAgICAgICBNb2R1bGVbJ3NldFRocmV3J10oMSwgMCk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGludm9rZV9paWlpaWlpaWlpKGluZGV4LCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KSB7CiAgICAgIHRyeSB7CiAgICAgICAgcmV0dXJuIE1vZHVsZVsnZHluQ2FsbF9paWlpaWlpaWlpJ10oaW5kZXgsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZQogICAgICAgIE1vZHVsZVsnc2V0VGhyZXcnXSgxLCAwKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW52b2tlX2lpaWlpaWppaShpbmRleCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSkgewogICAgICB0cnkgewogICAgICAgIHJldHVybiBNb2R1bGVbJ2R5bkNhbGxfaWlpaWlpamlpJ10oaW5kZXgsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYsIGE3LCBhOCwgYTkpCiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZQogICAgICAgIE1vZHVsZVsnc2V0VGhyZXcnXSgxLCAwKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW52b2tlX2lqaihpbmRleCwgYTEsIGEyLCBhMywgYTQpIHsKICAgICAgdHJ5IHsKICAgICAgICByZXR1cm4gTW9kdWxlWydkeW5DYWxsX2lqaiddKGluZGV4LCBhMSwgYTIsIGEzLCBhNCkKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfamkoaW5kZXgsIGExKSB7CiAgICAgIHRyeSB7CiAgICAgICAgcmV0dXJuIE1vZHVsZVsnZHluQ2FsbF9qaSddKGluZGV4LCBhMSkKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfdihpbmRleCkgewogICAgICB0cnkgewogICAgICAgIE1vZHVsZVsnZHluQ2FsbF92J10oaW5kZXgpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlICE9PSAnbnVtYmVyJyAmJiBlICE9PSAnbG9uZ2ptcCcpIHRocm93IGUKICAgICAgICBNb2R1bGVbJ3NldFRocmV3J10oMSwgMCk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGludm9rZV92aShpbmRleCwgYTEpIHsKICAgICAgdHJ5IHsKICAgICAgICBNb2R1bGVbJ2R5bkNhbGxfdmknXShpbmRleCwgYTEpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlICE9PSAnbnVtYmVyJyAmJiBlICE9PSAnbG9uZ2ptcCcpIHRocm93IGUKICAgICAgICBNb2R1bGVbJ3NldFRocmV3J10oMSwgMCk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGludm9rZV92aWkoaW5kZXgsIGExLCBhMikgewogICAgICB0cnkgewogICAgICAgIE1vZHVsZVsnZHluQ2FsbF92aWknXShpbmRleCwgYTEsIGEyKTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfdmlpaShpbmRleCwgYTEsIGEyLCBhMykgewogICAgICB0cnkgewogICAgICAgIE1vZHVsZVsnZHluQ2FsbF92aWlpJ10oaW5kZXgsIGExLCBhMiwgYTMpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlICE9PSAnbnVtYmVyJyAmJiBlICE9PSAnbG9uZ2ptcCcpIHRocm93IGUKICAgICAgICBNb2R1bGVbJ3NldFRocmV3J10oMSwgMCk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGludm9rZV92aWlpaShpbmRleCwgYTEsIGEyLCBhMywgYTQpIHsKICAgICAgdHJ5IHsKICAgICAgICBNb2R1bGVbJ2R5bkNhbGxfdmlpaWknXShpbmRleCwgYTEsIGEyLCBhMywgYTQpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlICE9PSAnbnVtYmVyJyAmJiBlICE9PSAnbG9uZ2ptcCcpIHRocm93IGUKICAgICAgICBNb2R1bGVbJ3NldFRocmV3J10oMSwgMCk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGludm9rZV92aWlpaWkoaW5kZXgsIGExLCBhMiwgYTMsIGE0LCBhNSkgewogICAgICB0cnkgewogICAgICAgIE1vZHVsZVsnZHluQ2FsbF92aWlpaWknXShpbmRleCwgYTEsIGEyLCBhMywgYTQsIGE1KTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfdmlpaWlpaShpbmRleCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNikgewogICAgICB0cnkgewogICAgICAgIE1vZHVsZVsnZHluQ2FsbF92aWlpaWlpJ10oaW5kZXgsIGExLCBhMiwgYTMsIGE0LCBhNSwgYTYpOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgaWYgKHR5cGVvZiBlICE9PSAnbnVtYmVyJyAmJiBlICE9PSAnbG9uZ2ptcCcpIHRocm93IGUKICAgICAgICBNb2R1bGVbJ3NldFRocmV3J10oMSwgMCk7CiAgICAgIH0KICAgIH0KICAgIGZ1bmN0aW9uIGludm9rZV92aWlpaWlpaWlpKGluZGV4LCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5KSB7CiAgICAgIHRyeSB7CiAgICAgICAgTW9kdWxlWydkeW5DYWxsX3ZpaWlpaWlpaWknXShpbmRleCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZQogICAgICAgIE1vZHVsZVsnc2V0VGhyZXcnXSgxLCAwKTsKICAgICAgfQogICAgfQogICAgZnVuY3Rpb24gaW52b2tlX3ZpaWlpaWlpaWlpKGluZGV4LCBhMSwgYTIsIGEzLCBhNCwgYTUsIGE2LCBhNywgYTgsIGE5LCBhMTApIHsKICAgICAgdHJ5IHsKICAgICAgICBNb2R1bGVbJ2R5bkNhbGxfdmlpaWlpaWlpaWknXShpbmRleCwgYTEsIGEyLCBhMywgYTQsIGE1LCBhNiwgYTcsIGE4LCBhOSwgYTEwKTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfdmlqKGluZGV4LCBhMSwgYTIsIGEzKSB7CiAgICAgIHRyeSB7CiAgICAgICAgTW9kdWxlWydkeW5DYWxsX3ZpaiddKGluZGV4LCBhMSwgYTIsIGEzKTsKICAgICAgfSBjYXRjaCAoZSkgewogICAgICAgIGlmICh0eXBlb2YgZSAhPT0gJ251bWJlcicgJiYgZSAhPT0gJ2xvbmdqbXAnKSB0aHJvdyBlCiAgICAgICAgTW9kdWxlWydzZXRUaHJldyddKDEsIDApOwogICAgICB9CiAgICB9CiAgICBmdW5jdGlvbiBpbnZva2VfdmlqaShpbmRleCwgYTEsIGEyLCBhMywgYTQpIHsKICAgICAgdHJ5IHsKICAgICAgICBNb2R1bGVbJ2R5bkNhbGxfdmlqaSddKGluZGV4LCBhMSwgYTIsIGEzLCBhNCk7CiAgICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICBpZiAodHlwZW9mIGUgIT09ICdudW1iZXInICYmIGUgIT09ICdsb25nam1wJykgdGhyb3cgZQogICAgICAgIE1vZHVsZVsnc2V0VGhyZXcnXSgxLCAwKTsKICAgICAgfQogICAgfQogICAgTW9kdWxlLmFzbUdsb2JhbEFyZyA9IHt9OwogICAgTW9kdWxlLmFzbUxpYnJhcnlBcmcgPSB7CiAgICAgIGFib3J0OiBhYm9ydCwKICAgICAgZW5sYXJnZU1lbW9yeTogZW5sYXJnZU1lbW9yeSwKICAgICAgZ2V0VG90YWxNZW1vcnk6IGdldFRvdGFsTWVtb3J5LAogICAgICBhYm9ydE9uQ2Fubm90R3Jvd01lbW9yeTogYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnksCiAgICAgIGludm9rZV9pOiBpbnZva2VfaSwKICAgICAgaW52b2tlX2lpOiBpbnZva2VfaWksCiAgICAgIGludm9rZV9paWk6IGludm9rZV9paWksCiAgICAgIGludm9rZV9paWlpOiBpbnZva2VfaWlpaSwKICAgICAgaW52b2tlX2lpaWlpOiBpbnZva2VfaWlpaWksCiAgICAgIGludm9rZV9paWlpaWlpOiBpbnZva2VfaWlpaWlpaSwKICAgICAgaW52b2tlX2lpaWlpaWlpaWk6IGludm9rZV9paWlpaWlpaWlpLAogICAgICBpbnZva2VfaWlpaWlpamlpOiBpbnZva2VfaWlpaWlpamlpLAogICAgICBpbnZva2VfaWpqOiBpbnZva2VfaWpqLAogICAgICBpbnZva2Vfamk6IGludm9rZV9qaSwKICAgICAgaW52b2tlX3Y6IGludm9rZV92LAogICAgICBpbnZva2Vfdmk6IGludm9rZV92aSwKICAgICAgaW52b2tlX3ZpaTogaW52b2tlX3ZpaSwKICAgICAgaW52b2tlX3ZpaWk6IGludm9rZV92aWlpLAogICAgICBpbnZva2VfdmlpaWk6IGludm9rZV92aWlpaSwKICAgICAgaW52b2tlX3ZpaWlpaTogaW52b2tlX3ZpaWlpaSwKICAgICAgaW52b2tlX3ZpaWlpaWk6IGludm9rZV92aWlpaWlpLAogICAgICBpbnZva2VfdmlpaWlpaWlpaTogaW52b2tlX3ZpaWlpaWlpaWksCiAgICAgIGludm9rZV92aWlpaWlpaWlpaTogaW52b2tlX3ZpaWlpaWlpaWlpLAogICAgICBpbnZva2VfdmlqOiBpbnZva2VfdmlqLAogICAgICBpbnZva2VfdmlqaTogaW52b2tlX3ZpamksCiAgICAgIF9fX2N4YV9hbGxvY2F0ZV9leGNlcHRpb246IF9fX2N4YV9hbGxvY2F0ZV9leGNlcHRpb24sCiAgICAgIF9fX2N4YV9iZWdpbl9jYXRjaDogX19fY3hhX2JlZ2luX2NhdGNoLAogICAgICBfX19jeGFfZW5kX2NhdGNoOiBfX19jeGFfZW5kX2NhdGNoLAogICAgICBfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaF8yOiBfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaF8yLAogICAgICBfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaF8zOiBfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaF8zLAogICAgICBfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaF80OiBfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaF80LAogICAgICBfX19jeGFfZnJlZV9leGNlcHRpb246IF9fX2N4YV9mcmVlX2V4Y2VwdGlvbiwKICAgICAgX19fY3hhX3Rocm93OiBfX19jeGFfdGhyb3csCiAgICAgIF9fX2xvY2s6IF9fX2xvY2ssCiAgICAgIF9fX21hcF9maWxlOiBfX19tYXBfZmlsZSwKICAgICAgX19fcmVzdW1lRXhjZXB0aW9uOiBfX19yZXN1bWVFeGNlcHRpb24sCiAgICAgIF9fX3NldEVyck5vOiBfX19zZXRFcnJObywKICAgICAgX19fc3lzY2FsbDE0MDogX19fc3lzY2FsbDE0MCwKICAgICAgX19fc3lzY2FsbDE0NTogX19fc3lzY2FsbDE0NSwKICAgICAgX19fc3lzY2FsbDE0NjogX19fc3lzY2FsbDE0NiwKICAgICAgX19fc3lzY2FsbDE4MzogX19fc3lzY2FsbDE4MywKICAgICAgX19fc3lzY2FsbDE5ODogX19fc3lzY2FsbDE5OCwKICAgICAgX19fc3lzY2FsbDIwOiBfX19zeXNjYWxsMjAsCiAgICAgIF9fX3N5c2NhbGw2OiBfX19zeXNjYWxsNiwKICAgICAgX19fc3lzY2FsbDYwOiBfX19zeXNjYWxsNjAsCiAgICAgIF9fX3N5c2NhbGw4MzogX19fc3lzY2FsbDgzLAogICAgICBfX19zeXNjYWxsOTE6IF9fX3N5c2NhbGw5MSwKICAgICAgX19fdW5sb2NrOiBfX191bmxvY2ssCiAgICAgIF9fZW1iaW5kX2ZpbmFsaXplX3ZhbHVlX29iamVjdDogX19lbWJpbmRfZmluYWxpemVfdmFsdWVfb2JqZWN0LAogICAgICBfX2VtYmluZF9yZWdpc3Rlcl9ib29sOiBfX2VtYmluZF9yZWdpc3Rlcl9ib29sLAogICAgICBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzczogX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3MsCiAgICAgIF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NvbnN0cnVjdG9yOiBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3RvciwKICAgICAgX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfZnVuY3Rpb246IF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2Z1bmN0aW9uLAogICAgICBfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbDogX19lbWJpbmRfcmVnaXN0ZXJfZW12YWwsCiAgICAgIF9fZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0OiBfX2VtYmluZF9yZWdpc3Rlcl9mbG9hdCwKICAgICAgX19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcjogX19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlciwKICAgICAgX19lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXc6IF9fZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3LAogICAgICBfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nOiBfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nLAogICAgICBfX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZzogX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmcsCiAgICAgIF9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdDogX19lbWJpbmRfcmVnaXN0ZXJfdmFsdWVfb2JqZWN0LAogICAgICBfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3RfZmllbGQ6IF9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdF9maWVsZCwKICAgICAgX19lbWJpbmRfcmVnaXN0ZXJfdm9pZDogX19lbWJpbmRfcmVnaXN0ZXJfdm9pZCwKICAgICAgX2Fib3J0OiBfYWJvcnQsCiAgICAgIF9lbXNjcmlwdGVuX21lbWNweV9iaWc6IF9lbXNjcmlwdGVuX21lbWNweV9iaWcsCiAgICAgIF9nZXRlbnY6IF9nZXRlbnYsCiAgICAgIF9nZXRncm5hbTogX2dldGdybmFtLAogICAgICBfZ2V0cHduYW06IF9nZXRwd25hbSwKICAgICAgX2pzQ2xvc2U6IF9qc0Nsb3NlLAogICAgICBfanNDcmVhdGU6IF9qc0NyZWF0ZSwKICAgICAgX2pzT3BlbjogX2pzT3BlbiwKICAgICAgX2pzUmVhZDogX2pzUmVhZCwKICAgICAgX2pzU2VlazogX2pzU2VlaywKICAgICAgX2pzVGVsbDogX2pzVGVsbCwKICAgICAgX2pzV3JpdGU6IF9qc1dyaXRlLAogICAgICBfbGx2bV9laF90eXBlaWRfZm9yOiBfbGx2bV9laF90eXBlaWRfZm9yLAogICAgICBfbG9jYWx0aW1lOiBfbG9jYWx0aW1lLAogICAgICBfbWt0aW1lOiBfbWt0aW1lLAogICAgICBfcHRocmVhZF9nZXRzcGVjaWZpYzogX3B0aHJlYWRfZ2V0c3BlY2lmaWMsCiAgICAgIF9wdGhyZWFkX2tleV9jcmVhdGU6IF9wdGhyZWFkX2tleV9jcmVhdGUsCiAgICAgIF9wdGhyZWFkX29uY2U6IF9wdGhyZWFkX29uY2UsCiAgICAgIF9wdGhyZWFkX3NldHNwZWNpZmljOiBfcHRocmVhZF9zZXRzcGVjaWZpYywKICAgICAgX3RpbWU6IF90aW1lLAogICAgICBEWU5BTUlDVE9QX1BUUjogRFlOQU1JQ1RPUF9QVFIsCiAgICAgIFNUQUNLVE9QOiBTVEFDS1RPUCwKICAgIH07CiAgICB2YXIgYXNtID0gTW9kdWxlWydhc20nXShNb2R1bGUuYXNtR2xvYmFsQXJnLCBNb2R1bGUuYXNtTGlicmFyeUFyZywgYnVmZmVyKTsKICAgIE1vZHVsZVsnYXNtJ10gPSBhc207CiAgICB2YXIgX19HTE9CQUxfX3N1Yl9JX2JpbmRfY3BwID0gKE1vZHVsZVsnX19HTE9CQUxfX3N1Yl9JX2JpbmRfY3BwJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydfX0dMT0JBTF9fc3ViX0lfYmluZF9jcHAnXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIHZhciBfX0dMT0JBTF9fc3ViX0lfYnJpZGdlX2NwcCA9IChNb2R1bGVbJ19fR0xPQkFMX19zdWJfSV9icmlkZ2VfY3BwJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydfX0dMT0JBTF9fc3ViX0lfYnJpZGdlX2NwcCddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgdmFyIF9fR0xPQkFMX19zdWJfSV9jcmNfY3BwID0gKE1vZHVsZVsnX19HTE9CQUxfX3N1Yl9JX2NyY19jcHAnXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ19fR0xPQkFMX19zdWJfSV9jcmNfY3BwJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICB2YXIgX19HTE9CQUxfX3N1Yl9JX2dsb2JhbF9jcHAgPSAoTW9kdWxlWydfX0dMT0JBTF9fc3ViX0lfZ2xvYmFsX2NwcCddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnX19HTE9CQUxfX3N1Yl9JX2dsb2JhbF9jcHAnXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ19fX2N4YV9jYW5fY2F0Y2gnXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ19fX2N4YV9jYW5fY2F0Y2gnXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ19fX2N4YV9pc19wb2ludGVyX3R5cGUnXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ19fX2N4YV9pc19wb2ludGVyX3R5cGUnXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ19fX2Vycm5vX2xvY2F0aW9uJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydfX19lcnJub19sb2NhdGlvbiddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgdmFyIF9fX2dldFR5cGVOYW1lID0gKE1vZHVsZVsnX19fZ2V0VHlwZU5hbWUnXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ19fX2dldFR5cGVOYW1lJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICB2YXIgX2Vtc2NyaXB0ZW5fcmVwbGFjZV9tZW1vcnkgPSAoTW9kdWxlWydfZW1zY3JpcHRlbl9yZXBsYWNlX21lbW9yeSddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnX2Vtc2NyaXB0ZW5fcmVwbGFjZV9tZW1vcnknXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIHZhciBfZnJlZSA9IChNb2R1bGVbJ19mcmVlJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydfZnJlZSddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgdmFyIF9tYWxsb2MgPSAoTW9kdWxlWydfbWFsbG9jJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydfbWFsbG9jJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICB2YXIgc2V0VGVtcFJldDAgPSAoTW9kdWxlWydzZXRUZW1wUmV0MCddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnc2V0VGVtcFJldDAnXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ3NldFRocmV3J10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydzZXRUaHJldyddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgdmFyIHN0YWNrQWxsb2MgPSAoTW9kdWxlWydzdGFja0FsbG9jJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydzdGFja0FsbG9jJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX2RpaSddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF9kaWknXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ2R5bkNhbGxfaSddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF9pJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX2lpJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX2lpJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX2lpaSddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF9paWknXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ2R5bkNhbGxfaWlpaSddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF9paWlpJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX2lpaWlpJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX2lpaWlpJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX2lpaWlpaSddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF9paWlpaWknXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ2R5bkNhbGxfaWlpaWlpaSddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF9paWlpaWlpJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX2lpaWlpaWlpaWknXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfaWlpaWlpaWlpaSddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF9paWlpaWlqaWknXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfaWlpaWlpamlpJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX2lqaiddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF9pamonXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ2R5bkNhbGxfamknXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfamknXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ2R5bkNhbGxfdiddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF92J10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX3ZpJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX3ZpJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX3ZpaSddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF92aWknXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ2R5bkNhbGxfdmlpZCddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF92aWlkJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX3ZpaWknXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfdmlpaSddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF92aWlpaSddID0gZnVuY3Rpb24gKCkgewogICAgICByZXR1cm4gTW9kdWxlWydhc20nXVsnZHluQ2FsbF92aWlpaSddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF92aWlpaWknXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfdmlpaWlpJ10uYXBwbHkobnVsbCwgYXJndW1lbnRzKQogICAgfSk7CiAgICAoTW9kdWxlWydkeW5DYWxsX3ZpaWlpaWknXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfdmlpaWlpaSddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF92aWlpaWlpaWlpJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX3ZpaWlpaWlpaWknXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ2R5bkNhbGxfdmlpaWlpaWlpaWknXSA9IGZ1bmN0aW9uICgpIHsKICAgICAgcmV0dXJuIE1vZHVsZVsnYXNtJ11bJ2R5bkNhbGxfdmlpaWlpaWlpaWknXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIChNb2R1bGVbJ2R5bkNhbGxfdmlqJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX3ZpaiddLmFwcGx5KG51bGwsIGFyZ3VtZW50cykKICAgIH0pOwogICAgKE1vZHVsZVsnZHluQ2FsbF92aWppJ10gPSBmdW5jdGlvbiAoKSB7CiAgICAgIHJldHVybiBNb2R1bGVbJ2FzbSddWydkeW5DYWxsX3ZpamknXS5hcHBseShudWxsLCBhcmd1bWVudHMpCiAgICB9KTsKICAgIE1vZHVsZVsnYXNtJ10gPSBhc207CiAgICBmdW5jdGlvbiBFeGl0U3RhdHVzKHN0YXR1cykgewogICAgICB0aGlzLm5hbWUgPSAnRXhpdFN0YXR1cyc7CiAgICAgIHRoaXMubWVzc2FnZSA9ICdQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCcgKyBzdGF0dXMgKyAnKSc7CiAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzOwogICAgfQogICAgRXhpdFN0YXR1cy5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTsKICAgIEV4aXRTdGF0dXMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXhpdFN0YXR1czsKICAgIHZhciBpbml0aWFsU3RhY2tUb3A7CiAgICBkZXBlbmRlbmNpZXNGdWxmaWxsZWQgPSBmdW5jdGlvbiBydW5DYWxsZXIoKSB7CiAgICAgIGlmICghTW9kdWxlWydjYWxsZWRSdW4nXSkgcnVuKCk7CiAgICAgIGlmICghTW9kdWxlWydjYWxsZWRSdW4nXSkgZGVwZW5kZW5jaWVzRnVsZmlsbGVkID0gcnVuQ2FsbGVyOwogICAgfTsKICAgIGZ1bmN0aW9uIHJ1bihhcmdzKSB7CiAgICAgIGFyZ3MgPSBhcmdzIHx8IE1vZHVsZVsnYXJndW1lbnRzJ107CiAgICAgIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSB7CiAgICAgICAgcmV0dXJuCiAgICAgIH0KICAgICAgcHJlUnVuKCk7CiAgICAgIGlmIChydW5EZXBlbmRlbmNpZXMgPiAwKSByZXR1cm4KICAgICAgaWYgKE1vZHVsZVsnY2FsbGVkUnVuJ10pIHJldHVybgogICAgICBmdW5jdGlvbiBkb1J1bigpIHsKICAgICAgICBpZiAoTW9kdWxlWydjYWxsZWRSdW4nXSkgcmV0dXJuCiAgICAgICAgTW9kdWxlWydjYWxsZWRSdW4nXSA9IHRydWU7CiAgICAgICAgaWYgKEFCT1JUKSByZXR1cm4KICAgICAgICBlbnN1cmVJbml0UnVudGltZSgpOwogICAgICAgIHByZU1haW4oKTsKICAgICAgICBpZiAoTW9kdWxlWydvblJ1bnRpbWVJbml0aWFsaXplZCddKSBNb2R1bGVbJ29uUnVudGltZUluaXRpYWxpemVkJ10oKTsKICAgICAgICBwb3N0UnVuKCk7CiAgICAgIH0KICAgICAgaWYgKE1vZHVsZVsnc2V0U3RhdHVzJ10pIHsKICAgICAgICBNb2R1bGVbJ3NldFN0YXR1cyddKCdSdW5uaW5nLi4uJyk7CiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7CiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgTW9kdWxlWydzZXRTdGF0dXMnXSgnJyk7CiAgICAgICAgICB9LCAxKTsKICAgICAgICAgIGRvUnVuKCk7CiAgICAgICAgfSwgMSk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgZG9SdW4oKTsKICAgICAgfQogICAgfQogICAgTW9kdWxlWydydW4nXSA9IHJ1bjsKICAgIGZ1bmN0aW9uIGV4aXQoc3RhdHVzLCBpbXBsaWNpdCkgewogICAgICBpZiAoaW1wbGljaXQgJiYgTW9kdWxlWydub0V4aXRSdW50aW1lJ10gJiYgc3RhdHVzID09PSAwKSB7CiAgICAgICAgcmV0dXJuCiAgICAgIH0KICAgICAgaWYgKE1vZHVsZVsnbm9FeGl0UnVudGltZSddKSA7IGVsc2UgewogICAgICAgIEFCT1JUID0gdHJ1ZTsKICAgICAgICBTVEFDS1RPUCA9IGluaXRpYWxTdGFja1RvcDsKICAgICAgICBleGl0UnVudGltZSgpOwogICAgICAgIGlmIChNb2R1bGVbJ29uRXhpdCddKSBNb2R1bGVbJ29uRXhpdCddKHN0YXR1cyk7CiAgICAgIH0KICAgICAgaWYgKEVOVklST05NRU5UX0lTX05PREUpIHsKICAgICAgICBwcm9jZXNzWydleGl0J10oc3RhdHVzKTsKICAgICAgfQogICAgICBNb2R1bGVbJ3F1aXQnXShzdGF0dXMsIG5ldyBFeGl0U3RhdHVzKHN0YXR1cykpOwogICAgfQogICAgTW9kdWxlWydleGl0J10gPSBleGl0OwogICAgZnVuY3Rpb24gYWJvcnQod2hhdCkgewogICAgICBpZiAoTW9kdWxlWydvbkFib3J0J10pIHsKICAgICAgICBNb2R1bGVbJ29uQWJvcnQnXSh3aGF0KTsKICAgICAgfQogICAgICBpZiAod2hhdCAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgTW9kdWxlLnByaW50KHdoYXQpOwogICAgICAgIE1vZHVsZS5wcmludEVycih3aGF0KTsKICAgICAgICB3aGF0ID0gSlNPTi5zdHJpbmdpZnkod2hhdCk7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgd2hhdCA9ICcnOwogICAgICB9CiAgICAgIEFCT1JUID0gdHJ1ZTsKICAgICAgdGhyb3cgJ2Fib3J0KCcgKyB3aGF0ICsgJykuIEJ1aWxkIHdpdGggLXMgQVNTRVJUSU9OUz0xIGZvciBtb3JlIGluZm8uJwogICAgfQogICAgTW9kdWxlWydhYm9ydCddID0gYWJvcnQ7CiAgICBpZiAoTW9kdWxlWydwcmVJbml0J10pIHsKICAgICAgaWYgKHR5cGVvZiBNb2R1bGVbJ3ByZUluaXQnXSA9PSAnZnVuY3Rpb24nKSBNb2R1bGVbJ3ByZUluaXQnXSA9IFtNb2R1bGVbJ3ByZUluaXQnXV07CiAgICAgIHdoaWxlIChNb2R1bGVbJ3ByZUluaXQnXS5sZW5ndGggPiAwKSB7CiAgICAgICAgTW9kdWxlWydwcmVJbml0J10ucG9wKCkoKTsKICAgICAgfQogICAgfQogICAgTW9kdWxlWydub0V4aXRSdW50aW1lJ10gPSB0cnVlOwogICAgcnVuKCk7CgogICAgcmV0dXJuIHVucGFjawogIH07CiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgogIC8qKgogICAqIFJldHVybnMgYSBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIHJhciBleHRyYWN0b3IgZm9yIHRoZSBnaXZlbiBmaWxlbmFtZS4KICAgKiBAcHJpdmF0ZQogICAqLwogIGZ1bmN0aW9uIGdldEV4dHJhY3Rvcih1cmwpIHsKICAgIHJldHVybiBmZXRjaChuZXcgUmVxdWVzdCh1cmwpKQogICAgICAudGhlbigocmVzcG9uc2UpID0+IHsKICAgICAgICBpZiAocmVzcG9uc2Uub2spIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpCiAgICAgICAgZWxzZSB7CiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzQwNCBFcnJvcjogRmlsZSBub3QgZm91bmQuJykKICAgICAgICB9CiAgICAgIH0pCiAgICAgIC50aGVuKChidWZmZXIpID0+IHVucGFja0JyaWRnZS5jcmVhdGVFeHRyYWN0b3JGcm9tRGF0YShidWZmZXIpKQogIH0KCiAgLyoqCiAgICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBmb3JtYXR0ZWQgY29udGVudHMgb2YgdGhlIGdpdmVuIGZpbGUuCiAgICogQHByaXZhdGUKICAgKi8KICBmdW5jdGlvbiBleHRyYWN0KHsgcmVzb3VyY2VJZCwgdXJsIH0pIHsKICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7CiAgICAgIGlmICghdW5wYWNrQnJpZGdlKSB7CiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnBhY2tCcmlkZ2Ugbm90IGRldGVjdGVkJykKICAgICAgfQogICAgICBpZiAoIXVucGFjaykgewogICAgICAgIHRocm93IG5ldyBFcnJvcigndW5wYWNrIG5vdCBkZXRlY3RlZCcpCiAgICAgIH0KCiAgICAgIGdldEV4dHJhY3Rvcih1cmwpLnRoZW4oCiAgICAgICAgKGV4dHJhY3RvcikgPT4gewogICAgICAgICAgLy8gcmV0dXJuIGV4dHJhY3Rvci5leHRyYWN0QWxsKCk7CiAgICAgICAgICByZXNvbHZlKGV4dHJhY3Rvci5leHRyYWN0QWxsKCkpOwogICAgICAgIH0sCiAgICAgICAgKGVycikgPT4gewogICAgICAgICAgcmVqZWN0KGVycik7CiAgICAgICAgfQogICAgICApOwogICAgfSkKICB9CgogIC8qKgogICAqIExpc3RlbiBmb3IgbWVzc2FnZXMgc2VudCB0byB0aGUgd29ya2VyLgogICAqIEBwcml2YXRlCiAgICovCiAgZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShkYXRhLCBwb3N0TWVzc2FnZSkgewogICAgaWYgKGRhdGEudHlwZSA9PSAnaW5pdCcpIHsKICAgICAgdW5wYWNrID0gaW5pdHVucGFjayhkYXRhLmJ1ZmZlcik7CiAgICAgIHVucGFjay5vblJ1bnRpbWVJbml0aWFsaXplZCA9ICgpID0+IHsKICAgICAgICBwb3N0TWVzc2FnZSh7IHR5cGU6ICdXQVNNX0xPQURFRCcgfSk7CiAgICAgIH07CiAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PSAnZmV0Y2gnKSB7CiAgICAgIGV4dHJhY3QoZGF0YSkudGhlbigKICAgICAgICAodW5wYWNrZWQpID0+IHsKICAgICAgICAgIHJldHVybkRhdGEoZGF0YSwgdW5wYWNrZWQsIHBvc3RNZXNzYWdlKTsKICAgICAgICB9LAogICAgICAgIChlcnIpID0+IHsKICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsKICAgICAgICAgICAgdGFza0lkOiBkYXRhLnRhc2tJZCwKICAgICAgICAgICAgdHlwZTogJ0VSUk9SJywKICAgICAgICAgICAgcmVzb3VyY2VJZDogZGF0YS5yZXNvdXJjZUlkLAogICAgICAgICAgICB1cmw6IGRhdGEudXJsLAogICAgICAgICAgfTsKICAgICAgICAgIHBvc3RNZXNzYWdlKHJlc3VsdCk7CiAgICAgICAgfQogICAgICApOwogICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT0gJ3VucGFjaycpIHsKICAgICAgY29uc3QgeyBidWZmZXIgfSA9IGRhdGE7CgogICAgICBpZiAoIXVucGFja0JyaWRnZSkgewogICAgICAgIHRocm93IG5ldyBFcnJvcigndW5wYWNrQnJpZGdlIG5vdCBkZXRlY3RlZCcpCiAgICAgIH0KICAgICAgaWYgKCF1bnBhY2spIHsKICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VucGFjayBub3QgZGV0ZWN0ZWQnKQogICAgICB9CgogICAgICBjb25zdCBleHRyYWN0b3IgPSB1bnBhY2tCcmlkZ2UuY3JlYXRlRXh0cmFjdG9yRnJvbURhdGEoYnVmZmVyKTsKICAgICAgY29uc3QgdW5wYWNrZWQgPSBleHRyYWN0b3IuZXh0cmFjdEFsbCgpOwogICAgICByZXR1cm5EYXRhKGRhdGEsIHVucGFja2VkLCBwb3N0TWVzc2FnZSk7CiAgICB9CiAgfQoKICBmdW5jdGlvbiByZXR1cm5EYXRhKGRhdGEsIHVucGFja2VkLCBwb3N0TWVzc2FnZSkgewogICAgY29uc3QgW3N0YXRlLCBsaXN0XSA9IHVucGFja2VkOwogICAgaWYgKHN0YXRlLnN0YXRlID09ICdGQUlMJykgewogICAgICBjb25zdCByZXN1bHQgPSB7CiAgICAgICAgdGFza0lkOiBkYXRhLnRhc2tJZCwKICAgICAgICB0eXBlOiAnRVJST1InLAogICAgICAgIHJlYXNvbjogc3RhdGUucmVhc29uLAogICAgICAgIG1zZzogc3RhdGUubXNnLAogICAgICAgIHJlc291cmNlSWQ6IGRhdGEucmVzb3VyY2VJZCwKICAgICAgICB1cmw6IGRhdGEudXJsLAogICAgICB9OwogICAgICBwb3N0TWVzc2FnZShyZXN1bHQpOwogICAgICByZXR1cm4KICAgIH0KICAgIGNvbnN0IHJlc3VsdCA9IHsKICAgICAgdGFza0lkOiBkYXRhLnRhc2tJZCwKICAgICAgdHlwZTogJ0ZJTklTSEVEJywKICAgICAgcmVzb3VyY2VJZDogZGF0YS5yZXNvdXJjZUlkLAogICAgICBlbnRyaWVzOiB7fSwKICAgIH07CgogICAgY29uc3QgdHJhbnNmZXJhYmxlcyA9IFtdOwogICAgaWYgKGxpc3QgJiYgbGlzdC5maWxlcykgewogICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgbGlzdC5maWxlcykgewogICAgICAgIHJlc3VsdC5lbnRyaWVzW2ZpbGUuZmlsZUhlYWRlci5uYW1lXSA9IGZpbGUuZXh0cmFjdFsxXTsKICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2goZmlsZS5leHRyYWN0WzFdLmJ1ZmZlcik7CiAgICAgIH0KICAgIH0KICAgIHBvc3RNZXNzYWdlKHJlc3VsdCwgdHJhbnNmZXJhYmxlcyk7CiAgfQoKICAvKiBOT0RFX1NUQVJUCiAgZXhwb3J0IHsgaGFuZGxlTWVzc2FnZSB9CiAgLy8gTk9ERV9FTFNFICovCiAgb25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7CiAgICBoYW5kbGVNZXNzYWdlKGV2ZW50LmRhdGEsIHNlbGYucG9zdE1lc3NhZ2UpOwogIH07CiAgLy8gTk9ERV9FTkQKICAvKioKICAgKiBXaGVuIHRoZSBXQVNNIHJ1bnRpbWUgaGFzIGJlZW4gaW5pdGlhbGl6ZWQgb24gdGhlIHVucGFjay5qcyBtb2R1bGUsIHNlbmQgYSBtZXNzYWdlIGluZGljYXRpbmcKICAgKiB0aGF0IHRoZSBsaWJyYXJ5IGlzIHJlYWR5LgogICAqLwogIC8vIDwhLS0gcHJldHRpZXItaWdub3JlLWVuZCAtLT4KCn0pKCk7Cgo=", null, false);
  var uA = Uint8Array.from(atob("AGFzbQEAAAABrgIlYAF/AX5gA39/fwF/YAN/fn8AYAR/f39/AX9gAn9/AX9gAAF/YAJ/fwBgA39/fwBgAABgAX8Bf2AEf39/fwBgBn9/f39/fwBgBX9/f39/AGACf38BfGAFf39/f38Bf2AGf39/f39/AX9gCX9/f39/f39/fwF/YAh/f39/f35/fwF/YAJ+fgF/YAF/AGADf398AGAJf39/f39/f39/AGAKf39/f39/f39/fwBgAn9+AGAHf39/f39/fwF/YAp/f39/f39/f39/AX9gB39/f39/f38AYAt/f39/f39/f39/fwBgDX9/f39/f39/f39/f38AYAh/f39/f39/fwBgA39+fwF/YAN+f38Bf2ACfn8Bf2AGf3x/f39/AX9gAnx/AXxgA39/fwF8YAR/f398AAKID1cDZW52Bm1lbW9yeQIAgAIDZW52BXRhYmxlAXABvAK8AgNlbnYJdGFibGVCYXNlA38AA2Vudg5EWU5BTUlDVE9QX1BUUgN/AANlbnYIU1RBQ0tUT1ADfwADZW52BWFib3J0ABMDZW52DWVubGFyZ2VNZW1vcnkABQNlbnYOZ2V0VG90YWxNZW1vcnkABQNlbnYXYWJvcnRPbkNhbm5vdEdyb3dNZW1vcnkABQNlbnYIaW52b2tlX2kACQNlbnYJaW52b2tlX2lpAAQDZW52Cmludm9rZV9paWkAAQNlbnYLaW52b2tlX2lpaWkAAwNlbnYMaW52b2tlX2lpaWlpAA4DZW52Dmludm9rZV9paWlpaWlpABgDZW52EWludm9rZV9paWlpaWlpaWlpABkDZW52CGludm9rZV92ABMDZW52CWludm9rZV92aQAGA2VudgppbnZva2VfdmlpAAcDZW52C2ludm9rZV92aWlpAAoDZW52DGludm9rZV92aWlpaQAMA2Vudg1pbnZva2VfdmlpaWlpAAsDZW52Dmludm9rZV92aWlpaWlpABoDZW52EWludm9rZV92aWlpaWlpaWlpABYDZW52Emludm9rZV92aWlpaWlpaWlpaQAbA2VudhlfX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uAAkDZW52El9fX2N4YV9iZWdpbl9jYXRjaAAJA2VudhBfX19jeGFfZW5kX2NhdGNoAAgDZW52HF9fX2N4YV9maW5kX21hdGNoaW5nX2NhdGNoXzIABQNlbnYcX19fY3hhX2ZpbmRfbWF0Y2hpbmdfY2F0Y2hfMwAJA2VudhxfX19jeGFfZmluZF9tYXRjaGluZ19jYXRjaF80AAQDZW52FV9fX2N4YV9mcmVlX2V4Y2VwdGlvbgATA2VudgxfX19jeGFfdGhyb3cABwNlbnYHX19fbG9jawATA2VudgtfX19tYXBfZmlsZQAEA2VudhJfX19yZXN1bWVFeGNlcHRpb24AEwNlbnYLX19fc2V0RXJyTm8AEwNlbnYNX19fc3lzY2FsbDE0MAAEA2Vudg1fX19zeXNjYWxsMTQ1AAQDZW52DV9fX3N5c2NhbGwxNDYABANlbnYNX19fc3lzY2FsbDE4MwAEA2Vudg1fX19zeXNjYWxsMTk4AAQDZW52DF9fX3N5c2NhbGwyMAAEA2VudgtfX19zeXNjYWxsNgAEA2VudgxfX19zeXNjYWxsNjAABANlbnYMX19fc3lzY2FsbDgzAAQDZW52DF9fX3N5c2NhbGw5MQAEA2VudglfX191bmxvY2sAEwNlbnYeX19lbWJpbmRfZmluYWxpemVfdmFsdWVfb2JqZWN0ABMDZW52Fl9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2wADANlbnYXX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3MAHANlbnYjX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY29uc3RydWN0b3IACwNlbnYgX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfZnVuY3Rpb24AHQNlbnYXX19lbWJpbmRfcmVnaXN0ZXJfZW12YWwABgNlbnYXX19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQABwNlbnYZX19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcgAMA2Vudh1fX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldwAHA2VudhxfX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nAAYDZW52HV9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nAAcDZW52Hl9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdAALA2VudiRfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3RfZmllbGQAFgNlbnYWX19lbWJpbmRfcmVnaXN0ZXJfdm9pZAAGA2VudgZfYWJvcnQACANlbnYWX2Vtc2NyaXB0ZW5fbWVtY3B5X2JpZwABA2VudgdfZ2V0ZW52AAkDZW52CV9nZXRncm5hbQAJA2VudglfZ2V0cHduYW0ACQNlbnYIX2pzQ2xvc2UAEwNlbnYJX2pzQ3JlYXRlAAkDZW52B19qc09wZW4ACQNlbnYHX2pzUmVhZAABA2VudgdfanNTZWVrAAEDZW52CF9qc1dyaXRlAAEDZW52E19sbHZtX2VoX3R5cGVpZF9mb3IACQNlbnYKX2xvY2FsdGltZQAJA2VudgdfbWt0aW1lAAkDZW52FF9wdGhyZWFkX2dldHNwZWNpZmljAAkDZW52E19wdGhyZWFkX2tleV9jcmVhdGUABANlbnYNX3B0aHJlYWRfb25jZQAEA2VudhRfcHRocmVhZF9zZXRzcGVjaWZpYwAEA2VudgVfdGltZQAJA2VudhBpbnZva2VfaWlpaWlpamlpABkDZW52Cmludm9rZV9pamoADgNlbnYJaW52b2tlX2ppAAQDZW52Cmludm9rZV92aWoACgNlbnYLaW52b2tlX3ZpamkADANlbnYHX2pzVGVsbAAJA4QEggQTAQEGEwQJCRMGEwEBCQcAEwcGBwwJCgEEAQkGCQETCQkEBAQHBAETAQEJBxMHAwkGBhMIBgkTARMEBBMTAQEBIAkJExMGEwEDCQIEEwcEExMKBgEJDAsIBAwEBAEEBAcJBwkDChMGEAERDAAFCwwKBwMBBwEEBgEJAQEOAQkEABMAAQYHBBMTAQkTEwYTBhMJCgYMCgEABwcGBAcTBAQEAhcKDwQHBwoBExMTBQEDBAcJDgQECQEBAwQJASIJAQQJBAkGCQEBBwQHBBMBCQ4JBgMBEwYTAQwBBwcHBhMXBhMHBhMTEwkPBAkTEwQGFR0MBgYGBwkTCQkJAQEJAQAJBAoTCQkJEwYGBBMEAAIBARMMCgQOGRYVCBQSERIGEA4BDRsWGgsMCiQHBhMZGA8OAwEEIwkBCgwLBwETCQkIEwYICgwLCgwLAQgEBh0BAQkEBh0EBgYGCQMEBAEEAQEBAQEEBAQJAwMHBAEhIB8DAwQBBAQBBAkBBQEBCQQJEwgECQEEHhMDFA0FCgUHBBMFAQcEBg4MBRMJEwcIAwYPExMTBgcHBgMEAQYBBgMJCQYTBAYTBhMEBgQTARMTBh4GFw8BBwkDBgQDBwcBBAQGBgYBCQkGEwYGAwcTEwoTBhMTBwoGEwcGBwYTBwcTFQcHExMTBgkGBgQLEwQJBAMBEwgJBhoFfwEjAQt/ASMCC38BQQALfwFBAAt/AUEACweXBSUYX19HTE9CQUxfX3N1Yl9JX2JpbmRfY3BwANEDGl9fR0xPQkFMX19zdWJfSV9icmlkZ2VfY3BwAO0DF19fR0xPQkFMX19zdWJfSV9jcmNfY3BwANIEGl9fR0xPQkFMX19zdWJfSV9nbG9iYWxfY3BwAOoCEF9fX2N4YV9jYW5fY2F0Y2gAhwMWX19fY3hhX2lzX3BvaW50ZXJfdHlwZQCGAxFfX19lcnJub19sb2NhdGlvbgDKAw5fX19nZXRUeXBlTmFtZQDPAwVfZnJlZQBSB19tYWxsb2MAbAtkeW5DYWxsX2RpaQCFAwlkeW5DYWxsX2kAnwIKZHluQ2FsbF9paQCEAwtkeW5DYWxsX2lpaQCDAwxkeW5DYWxsX2lpaWkAggMNZHluQ2FsbF9paWlpaQCBAw5keW5DYWxsX2lpaWlpaQCAAw9keW5DYWxsX2lpaWlpaWkA/wISZHluQ2FsbF9paWlpaWlpaWlpAP4CEWR5bkNhbGxfaWlpaWlpamlpAOcCC2R5bkNhbGxfaWpqAOYCCmR5bkNhbGxfamkA5QIJZHluQ2FsbF92AP0CCmR5bkNhbGxfdmkA/AILZHluQ2FsbF92aWkA+wIMZHluQ2FsbF92aWlkAPoCDGR5bkNhbGxfdmlpaQD5Ag1keW5DYWxsX3ZpaWlpAPgCDmR5bkNhbGxfdmlpaWlpAPcCD2R5bkNhbGxfdmlpaWlpaQD2AhJkeW5DYWxsX3ZpaWlpaWlpaWkA9QITZHluQ2FsbF92aWlpaWlpaWlpaQD0AgtkeW5DYWxsX3ZpagDkAgxkeW5DYWxsX3ZpamkA4wILc2V0VGVtcFJldDAA3AIIc2V0VGhyZXcA7wIKc3RhY2tBbGxvYwDTBAnKBAEAIwALvALzAtoDvgHoA+ED3QPbA/4BvgG+AYEBzQOPA44DX8YEfKkD0wOlBM0EuwKmAcoCywK4ApYC0QKWArIBcVjqA58CxwKBAYEBgQGBAYEBgQGBAaoB8QHdAu8BvgJqc5kE0gLbAs4E8AHMBLoCyQTSA9UD5APXAd8DnAKaAtcBnAKaAtcBuwOi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DiAAQThqIQ8gAEGQAWohECAAQfAAaiELIABBzABqIREgAEEIaiESIABBBGohDAJAAkADQCAERQRAIAMhAgwCCyANKAIAIQcgACwAAARAIAEgEigCACAMKAIAEFMaIAwoAgAhAiAMQQA2AgAFIAopAwAiEyAErVMhCCATpyECIAgEfyACBSAEIgILBEAgDiwAAARAIAksAAAEQCACIAIgBmpBD3FrIgNBAEoEQCADIQILIAhFBEAgBCECCwsLIAcoAgRFDQQgByAFIAIgBygCACgCDEEfcUHKAGoRAQAhAiAHQbCnAWohCCAPKAIAIgMEfyADBSAIC0GJwQBqLAAABEAgECAFIAIQqwILBSADIQILCyALIAspAwAgAqwiE3w3AwAgAiAGaiEGIAogCikDACATfSITNwMAIBNCAFEgDiwAAEEAR3FFDQEgAgRAIAZBD3FFIAksAABFcg0CCyAFIAJqIQUgBCACayEEIAcgAEEBIBEoAgAQtQEEQCACIQMMAQsLIABBAToAUkF/DwsgDSgCACIDBEAgCykDACADQYi8A2opAwB8IRQgACwAKARAIAApA1ghFSAAKQOIASITQgBRBEAgFSETBSAAKQOAASAUfCEUCyADQazzAGooAgAhAyATIBRTBH9B5AAFIBNCAFEEf0EABSAUQuQAfiATf6cLCyEFIANBzIQDaiwAAEUEQCAFIABByABqIgMoAgBHBEAgAyAFNgIACwsLCyACQX9GBEBBfyEGBSAJLAAABEAgACgCRCABIAYQ6gELCxCFASAGDwtBfwtiAQF/IABFBEBBASEACwJAAkACQANAIAAQbCIBDQJBsLwDQbC8AygCACIBNgIAIAFFDQEgAUEHcUGOAWoRCAAMAAsAC0EEEBQiAEHEJTYCACAAQdgKQQoQGwwBCyABDwtBAAtTAQF/IwQhACMEQeAgaiQEIABBgCBqIgMgAjYCACAAQYAIIAEgAxCAAhogAEGQIGoiAUEANgJEIAFBATYCSCABQUBrQQE2AgAgASAANgIAIAAkBAt6AgV/AX4gAEEYaiIDKAIAIgEgACgCFCIETwRAQgAPCyAAKAIAIQUgASEAAkADQCADIABBAWoiATYCACAFIABqLQAAIgBB/wBxrSACrYYgBnwhBiAAQYABcUUNASACQQdqIQIgASAESQRAIAEhAAwBBUIAIQYL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IAQgAGogAy0AAHM6AAAgAEEBaiIAQYAERw0ACyACQfwDagUgAgshAyAFIQAgA0EANgIAIAEsAIAEBH8gACABQYAEEFMaIwQhASMEQRBqJARBFCABECUhAyABJAQgA0HLAGohBEEAIQEDQCAAIAFqIgMgBCABaiADLQAAczoAACABQQFqIgFBgARHDQALIABB/ANqBSAAC0EANgIAIAIgABBzIQEgAkEAOgAAIAJBADoAASACQQA6AAIgAkEAOgADIAJBADoABCACQQA6AAUgAkEAOgAGIAJBADoAByACQQA6AAggAkEAOgAJIAJBADoACiACQQA6AAsgAkEAOgAMIAJBADoADSACQQA6AA4gAkEAOgAPIAJBADoAECACQQA6ABEgAkEAOgASIAJBADoAEyACQQA6ABQgAkEAOgAVIAJBADoAFiACQQA6ABcgAkEAOgAYIAJBADoAGSACQQA6ABogAkEAOgAbIAJBADoAHCACQQA6AB0gAkEAOgAeIAJBADoAHyACQQA6ACAgAkEAOgAhIAJBADoAIiACQQA6ACMgAkEAOgAkIAJBADoAJSACQQA6ACYgAkEAOgAnIAJBADoAKCACQQA6ACkgAkEAOgAqIAJBADoAKyACQQA6ACwgAkEAOgAtIAJBADoALiACQQA6AC8gAkEAOgAwIAJBADoAMSACQQA6ADIgAkEAOgAzIAJBADoANCACQQA6ADUgAkEAOgA2IAJBADoANyACQQA6ADggAkEAOgA5IAJBADoAOiACQQA6ADsgAkEAOgA8IAJBADoAPSACQQA6AD4gAkEAOgA/IAJBQGtBADoAACACQQA6AEEgAkEAOgBCIAJBADoAQyACQQA6AEQgAkEAOgBFIAJBADoARiACQQA6AEcgAkEAOgBIIAJBADoASSACQQA6AEogAkEAOgBLIAJBADoATCACQQA6AE0gAkEAOgBOIAJBADoATyACQQA6AFAgAkEAOgBRIAJBADoAUiACQQA6AFMgAkEAOgBUIAJBADoAVSACQQA6AFYgAkEAOgBXIAJBADoAWCACQQA6AFkgAkEAOgBaIAJBADoAWyACQQA6AFwgAkEAOgBdIAJBADoAXiACQQA6AF8gAkEAOgBgIAJBADoAYSACQQA6AGIgAkEAOgBjIAJBADoAZCACQQA6AGUgAkEAOgBmIAJBADoAZyACQQA6AGggAkEAOgBpIAJBADoAaiACQQA6AGsgAkEAOgBsIAJBADoAbSACQQA6AG4gAkEAOgBvIAJBADoAcCACQQA6AHEgAkEAOgByIAJBADoAcyACQQA6AHQgAkEAOgB1IAJBADoAdiACQQA6AHcgAkEAOgB4IAJBADoAeSACQQA6AHogAkEAOgB7IAJBADoAfCACQQA6AH0gAkEAOgB+IAJBADoAfyAAQQA6AAAgAEEAOgABIABBADoAAiAAQQA6AAMgAEEAOgAEIABBADoABSAAQQA6AAYgAEEAOgAHIABBADoACCAAQQA6AAkgAEEAOgAKIABBADoACyAAQQA6AAwgAEEAOgANIABBADoADiAAQQA6AA8gAEEAOgAQIABBADoAESAAQQA6ABIgAEEAOgATIABBADoAFCAAQQA6ABUgAEEAOgAWIABBADoAFyAAQQA6ABggAEEAOgAZIABBADoAGiAAQQA6ABsgAEEAOgAcIABBADoAHSAAQQA6AB4gAEEAOgAfIABBADoAICAAQQA6ACEgAEEAOgAiIABBADoAIyAAQQA6ACQgAEEAOgAlIABBADoAJiAAQQA6ACcgAEEAOgAoIABBADoAKSAAQQA6ACogAEEAOgArIABBADoALCAAQQA6AC0gAEEAOgAuIABBADoALyAAQQA6ADAgAEEAOgAxIABBADoAMiAAQQA6ADMgAEEAOgA0IABBADoANSAAQQA6ADYgAEEAOgA3IABBADoAOCAAQQA6ADkgAEEAOgA6IABBADoAOyAAQQA6ADwgAEEAOgA9IABBADoAPiAAQQA6AD8gAEFAa0EAOgAAIABBADoAQSAAQQA6AEIgAEEAOgBDIABBADoARCAAQQA6AEUgAEEAOgBGIABBADoARyAAQQA6AEggAEEAOgBJIABBADoASiAAQQA6AEsgAEEAOgBMIABBADoATSAAQQA6AE4gAEEAOgBPIABBADoAUCAAQQA6AFEgAEEAOgBSIABBADoAUyAAQQA6AFQgAEEAOgBVIABBADoAViAAQQA6AFcgAEEAOgBYIABBADoAWSAAQQA6AFogAEEAOgBbIABBADoAXCAAQQA6AF0gAEEAOgBeIABBADoAXyAAQQA6AGAgAEEAOgBhIABBADoAYiAAQQA6AGMgAEEAOgBkIABBADoAZSAAQQA6AGYgAEEAOgBnIABBADoAaCAAQQA6AGkgAEEAOgBqIABBADoAayAAQQA6AGwgAEEAOgBtIABBADoAbiAAQQA6AG8gAEEAOgBwIABBADoAcSAAQQA6AHIgAEEAOgBzIABBADoAdCAAQQA6AHUgAEEAOgB2IABBADoAdyAAQQA6AHggAEEAOgB5IABBADoAeiAAQQA6AHsgAEEAOgB8IABBADoAfSAAQQA6AH4gAEEAOgB/IAAkBCABRQslAQF/IAIgABBZa0F/aiIDQQBMBEAgAA8LIAAgASADELIDGiAACxYAIABBAEHAywQQVBogAEGowAJqEFwLbQEEfyAAKAIUIABBGGoiBCgCACIFayIDIAJJIgYEfyADBSACIgMLBEAgASAAKAIAIAVqIAMQUxoLIAZFBEAgBCAEKAIAIANqNgIAIAMPCyABIANqQQAgAiADaxBUGiAEIAQoAgAgA2o2AgAgAwueAwEIfyMEIQQjBEEgaiQEIARBCGohBSABQQA2AgAgBEIANwMAIARBEGoiAyAANgIAAkACQAJAAkACQAJAIAEgAyACIAQQuQNBf2sOAgABAgsMAgsgACwAAA0BQQEhAAwCC0EBIQAMAQsgAkEBSwRAQQAhAwJAAkADQCAAIAhqIgYsAABFDQEgBUIANwMAIAEgA0ECdGoiCSAGQawjKAIAKAIABH9BBAVBAQsgBRCKAkF/RgR/IAYsAAAiB0EATg0DIApFBEAgCUH+/wM2AgAgA0EBaiIDIAJPDQQgBiwAACEHCyABIANBAnRqIAdB/wFxQYDAA3I2AgBBASEKIAhBAWoFIAVCADcDACAGQawjKAIAKAIABH9BBAVBAQsgBRCIAiIHQQFKBH8gBwVBAQsgCGoLIQggA0EBaiIDIAJJDQBBACEADAULAAsgASADQQJ0akEANgIAQQEhAAwDC0EAIQAFQQAhAAwBCwwBCyACRQRAIAQkBCAAQf8BcUEARw8LCyABIAJBf2pBAnRqQQA2AgAgBCQEIABB/wFxQQBHC/EBAgN/AX4jBCEBIwRB0ABqJAQgAEGtvANqLAAABEAgASQEQQAPCyAAQYi8A2oiAyAAIAAoAgAoAhRBB3FBhgFqEQAAIgQ3AwACQAJAAkACQAJAAkAgAEGYvANqKAIAQQFrDgMAAQIDCyAAENcCIQIMAwsgABDWAiECDAILIAAQ1QIhAgwBCwwBCyACBEAgAykDACEEBSABJARBAA8LCyAAQZC8A2opAwAgBFUEQCABJAQgAg8LIAFBADYCRCABQRg2AkggAUFAa0EBNgIAIAEgAEEYajYCACAAQay8A2pBAToAAEGs9QJBAxBkIAEkBEEAC9cBAgZ/AX4jBCEDIwRBoAJqJAQgA0EgaiEGIAMhBSAAQSBqIgMpAwAhCSADIAkgAq18NwMAIAJFBEAgBUEgEFsgBkGAAhBbIAUkBA8LIABBKGohByAAQSxqIQggCadBP3EhAwNAIAJBwAAgA2siBEsEfyAEBSACIgQLQcAARgRAIAcgATYCAAUgByAINgIAIABBLGogA2ogASAEEFMaCyAEIANqIgNBwABGBEAgABDhAUEAIQMLIAEgBGohASACIARrIgINAAsgBUEgEFsgBkGAAhBbIAUkBAt4AQF/IABB9A02AgAgAEGo8wBqLAAABEAgAEGs8wBqKAIAIgEEQCABEHkgARBSCwsgAEGQ7gJqKAIAIgEEQCABEFILIABB0OcBaigCACIBBEAgARBSCyAAQdjzAGoQtQIgAEHw8QBqEIQBIABBnMAAahCOASAAEHALBgBBEBAACwgAQQUQAEEACwgAQQIQAEEACzABAX8jBCECIwRBEGokBCACIAE2AgBB8CAoAgAiASAAIAIQzgEaQQogARCrAxoQOQujAgEEfyABRQRAIABBvM0DakEANgIAIABByM0DakEANgIAIABBnM0DaiIEKAIAIgEEQCAAQZjNA2ohBQNAIAUoAgAgAkECdGooAgAiAwRAIAMoAjwiAQRAIAEQUgsgAygCLCIBBEAgARBSCyADKAIUIgEEQCABEFILIAMQUiAEKAIAIQELIAJBAWoiAiABSQ0ACwsgBEEANgIACyAAQazNA2oiAygCACICRQRAIANBADYCAA8LIABBqM0DaiEEQQAhASACIQADQCAEKAIAIAFBAnRqKAIAIgIEQCACKAI8IgAEQCAAEFILIAIoAiwiAARAIAAQUgsgAigCFCIABEAgABBSCyACEFIgAygCACEACyABQQFqIgEgAEkNAAsgA0EANgIAC0gBAX8gAEFAaygCACIBBEAgARCOASABEFILIAAoAkQiAQRAIAEQjgEgARBSCyAAQagBahCNASAAQZwBahCNASAAQZABahCNAQsYAEG39QIsAABFBEAPC0Gs9QJB/wEQ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TBogACABEKwDIgALQQEBfwJAIAAQWSICQX9KBEAgACACQQJ0aiECA0AgAigCACABRg0CIAJBfGoiAiAATw0AQQAhAgsFQQAhAgsLIAILZAEDfwJAIAIEQCABIQMgACEBA0AgAygCACIFRQ0CIANBBGohAyABQQRqIQQgASAFNgIAIAJBf2oiAgRAIAQhAQwBBSAEIQFBACECCwsFIAAhAUEAIQILCyABQQAgAhCwAxogAAvCBAEKfyMEIQYjBEGAQGskBCAAIQcDQAJAA0AgACIEKAIAIQgCQAJAA0ACQAJAAkACQCAIDjAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgECCyAHIQAMBwsMAQsMAgsgBEEEaiIAKAIAIghBLkYNAiAAIQQMAAsACyAEQQRqIQAMAQsgBCgCCEEuRw0ACyAEQRBqIQggBCgCDEEvRgRAIAghBwsMAQsLAkACQANAAkACQAJAAkACQCAAKAIAIgcOXQACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAQILDAMLIAAoAgRB3ABGBEAgAEEIakHcABB0IgIEQCACQQRqQdwAEHQiA0EEaiECIAMEfyACBSAAIgILIQMFIAAiAyECCwUgACIDIQILQQ0hBQwBCyAAIgohCSAHIQsLA0AgBUENRgRAQQAhBSADIQogAiEJIAMoAgAhCwsCQAJAAkAgC0Euaw4CAAECCyAKQQRqIQMgCSECQQ0hBQwCCyAKQQRqIgIhA0ENIQUMAQsLIAkgAEYNAiAJIQAMAQsLDAELIAAoAgBBLkYEQCAAKAIEQS5GBEAgAEEIaiICKAIARQRAIAIhAAsLCwsgAUUEQCAGJAQgAA8LIAYgAEGAEBBvGiABIAYQahogBiQEIAALEwAgAAR/IAAgAUEAEJEBBUEACwvaAwMBfwF+AXwCQCABQRRNBEACQAJAAkACQAJAAkACQAJAAkACQAJAIAFBCWsOCgABAgMEBQYHCAkKCyACKAIAQQNqQXxxIgEoAgAhAyACIAFBBGo2AgAgACADNgIADAsLIAIoAgBBA2pBfHEiASgCACEDIAIgAUEE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ACEEQQAhAwNAIAAgDCADrXxBACAAKAIAKAIQQQNxQbgCahECACAIKAIAQQFGBEAgBiAJNgIACyAHLAAABEAgB0EAOgAACyAGKAIAIAEgAiADayIFQYAESQR/IAUFQYAECxBBIgVBf0YEf0GABAUgBQsgBGohBCADQYAEaiIDIAJJDQALIAQPC0Gs9QIgAxC6BEF/DwsgBAuMAgEDfyABKAIAIQIgAEIANwIAIABBADYCCCACQe////8DSwRAIAAQigELIAFBBGohBAJAIAJBAkkEQCAAIAI6AAsgAgRAIAAhAwUgACACQQJ0akEANgIADwsFIAJBBGpBfHEiAUH/////A00EQCAAIAFBAnQQXyIDNgIAIAAgAUGAgICAeHI2AgggACACNgIEDAILQQgQFCEAQQAkBUEXIABBzO4AEA0jBSEBQQAkBSABQQFxBEAQFyEBIAAQGiABEB4FIABB7CU2AgAgAEH4CkEMEBsLCwtBACQFQR0gAyAEIAIQBxojBSEAQQAkBSAAQQFxBEBBABAYIgAQWgUgAyACQQJ0akEANgIACwsPACABIAAoAgBqIAI2AgALDQAgASAAKAIAaigCAAvQBgECfyAAKAIAIgEEQCABEFIgAEEANgIACyAAQQRqIgEoAgAiAgRAIAIQUiABQQA2AgALIABBCGoiASgCACICBEAgAhBSIAFBADYCAAsgAEEMaiIBKAIAIgIEQCACEFIgAUEANgIACyAAQRBqIgEoAgAiAgRAIAIQUiABQQA2AgALIABBFGoiASgCACICBEAgAhBSIAFBADYCAAsgAEEYaiIBKAIAIgIEQCACEFIgAUEANgIACyAAQRxqIgEoAgAiAgRAIAIQUiABQQA2AgALIABBIGoiASgCACICBEAgAhBSIAFBADYCAAsgAEEkaiIBKAIAIgIEQCACEFIgAUEANgIACyAAQShqIgEoAgAiAgRAIAIQUiABQQA2AgALIABBLGoiASgCACICBEAgAhBSIAFBADYCAAsgAEEwaiIBKAIAIgIEQCACEFIgAUEANgIACyAAQTRqIgEoAgAiAgRAIAIQUiABQQA2AgALIABBOGoiASgCACICBEAgAhBSIAFBADYCAAsgAEE8aiIBKAIAIgIEQCACEFIgAUEANgIACyAAQUBrIgEoAgAiAgRAIAIQUiABQQA2AgALIABBxABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABByABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABBzABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB0ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB1ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB2ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB3ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB4ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB5ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB6ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB7ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB8ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB9ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB+ABqIgEoAgAiAgRAIAIQUiABQQA2AgALIABB/ABqIgAoAgAiAUUEQA8LIAEQUiAAQQA2AgAL6AoBGn8jBCECIwRBEGokBCACQQhqIRIgAiEJIABB4ABqIgooAgAgAEHkAGoiDCgCACICayAAQdDNA2oiDSgCACIDcSETIABBNGohBwJAAkAgAEE4aiILKAIARQ0AIABBHGohDiAAQRhqIRQgAEEgaiEXIABBFGohDyAAQczNA2ohGCAAQaiYAWohFSAAQaSWAWohECAAQaiWAWohESAAQbqYAWohGSAAQcCYAWohFiATIQECQAJAAkACQANAAkAgBygCACIGIAVBBHRqIhosAABBCEcEQCAGIAVBBHRqKAIEIQQgBiAFQQR0akENaiIILAAABEAgBCAMKAIAayADcSATSw0CIAhBADoAAAwCCyAGIAVBBHRqKAIIIQYgAyAEIAJrcSABSQRAIAQgAkcEQCAAIAIgBBCzASAEIQIgCigCACAEayANKAIAIgNxIQELIAYgAUsNBCAGBEAgDigCACEBIBQgBjYCACABIAZJBEAgFygCACICQQBHIAYgAktxBH8gCSACNgIAQaz1AkHYGyAJEGBBrPUCEFYgDigCACEBIBQoAgAFIAYLIQIgDygCACACIAFBIGogAUECdmoiAUsEfyACBSABIgILEFciAUUEQEGs9QIQVgsgDyABNgIAIA4gAjYCAAsgDygCACEBAkAg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ACADIAFBlJUBaiAEai0AACIEQQR0aiEDIAIgBGshAgsgASACakG5lQFqLQAAIQQLIAMgAUHIlgFqIARBAnRqIgEoAgA2AgAgASADNgIACyAKIAA2AgALIA0gADYCACAGJAQLuxIBCX8gAEHwDGpBAEGAAhBUGiAAQZCVAWoiBhCOBCAAQewMaiIIIABB5AxqIgUoAgAiA0F/cyIBQXNKBH8gAQVBcws2AgAgAEHElgFqIgcoAgAiASAAQcCWAWoiAigCAEYEQCAAQciWAWoiBCgCACIBBEAgBCABKAIANgIABSAGQQAQoAEhASAFKAIAIQMLBSAHIAFBcGoiATYCAAsgAEHQDGogATYCACAAQcgMaiIFIAE2AgAgAUEANgIMIABB4AxqIAM2AgAgAUGAAjsBACABQYECOwEEIABByJYBaiAAQbmWAWotAAAiA0ECdGoiBCgCACIBBEAgBCABKAIANgIABSACIAIoAgAiASAAQZSVAWogA2oiCS0AAEEEdGoiBDYCACAEIAcoAgBLBEAgAiAEIAktAABBBHRrNgIAIAYgAxCgASEBCwsgBSgCACABNgIIIABB1AxqIAE2AgAgAEHoDGogCCgCADYCACAAQfEUakEAOgAAIAUoAgBBCGohA0EAIQEDQCADKAIAIAFBA3RqIAE6AAAgAygCACABQQN0akEBOgABIAMoAgAgAUEDdGpBADYCBCABQQFqIgFBgAJHDQBBACEBCwNAIABB9BRqIAFBB3RqQYCAAUHd+QAgAUECaiIDbmtB//8DcSICOwEAIAAgAUEHdGpBhBVqIAI7AQAgACABQQd0akGUFWogAjsBACAAIAFBB3RqQaQVaiACOwEAIAAgAUEHdGpBtBVqIAI7AQAgACABQQd0akHEFWogAjsBACAAIAFBB3RqQdQVaiACOwEAIAAgAUEHdGpB5BVqIAI7AQAgACABQQd0akH2FGpBgIABQb8+IANua0H//wNxIgI7AQAgACABQQd0akGGFWogAjsBACAAIAFBB3RqQZYVaiACOwEAIAAgAUEHdGpBphVqIAI7AQAgACABQQd0akG2FWogAjsBACAAIAFBB3RqQcYVaiACOwEAIAAgAUEHdGpB1hVqIAI7AQAgACABQQd0akHmFWogAjsBACAAIAFBB3RqQfgUakGAgAFBv7MBIANua0H//wNxIgI7AQAgACABQQd0akGIFWogAjsBACAAIAFBB3RqQZgVaiACOwEAIAAgAUEHdGpBqBVqIAI7AQAgACABQQd0akG4FWogAjsBACAAIAFBB3RqQcgVaiACOwEAIAAgAUEHdGpB2BVqIAI7AQAgACABQQd0akHoFWogAjsBACAAIAFBB3RqQfoUakGAgAFB85EBIANua0H//wNxIgI7AQAgACABQQd0akGKFWogAjsBACAAIAFBB3RqQZoVaiACOwEAIAAgAUEHdGpBqhVqIAI7AQAgACABQQd0akG6FWogAjsBACAAIAFBB3RqQcoVaiACOwEAIAAgAUEHdGpB2hVqIAI7AQAgACABQQd0akHqFWogAjsBACAAIAFBB3RqQfwUakGAgAFBockBIANua0H//wNxIgI7AQAgACABQQd0akGMFWogAjsBACAAIAFBB3RqQZwVaiACOwEAIAAgAUEHdGpBrBVqIAI7AQAgACABQQd0akG8FWogAjsBACAAIAFBB3RqQcwVaiACOwEAIAAgAUEHdGpB3BVqIAI7AQAgACABQQd0akHsFWogAjsBACAAIAFBB3RqQf4UakGAgAFBvLUBIANua0H//wNxIgI7AQAgACABQQd0akGOFWogAjsBACAAIAFBB3RqQZ4VaiACOwEAIAAgAUEHdGpBrhVqIAI7AQAgACABQQd0akG+FWogAjsBACAAIAFBB3RqQc4VaiACOwEAIAAgAUEHdGpB3hVqIAI7AQAgACABQQd0akHuFWogAjsBACAAIAFBB3RqQYAVakGAgAFBsswBIANua0H//wNxIgI7AQAgACABQQd0akGQFWogAjsBACAAIAFBB3RqQaAVaiACOwEAIAAgAUEHdGpBsBVqIAI7AQAgACABQQd0akHAFWogAjsBACAAIAFBB3RqQdAVaiACOwEAIAAgAUEHdGpB4BVqIAI7AQAgACABQQd0akHwFWogAjsBACAAIAFBB3RqQYIVakGAgAFB0cABIANua0H//wNxIgM7AQAgACABQQd0akGSFWogAzsBACAAIAFBB3RqQaIVaiADOwEAIAAgAUEHdGpBshVqIAM7AQAgACABQQd0akHCFWogAzsBACAAIAFBB3RqQdIVaiADOwEAIAAgAUEHdGpB4hVqIAM7AQAgACABQQd0akHyFWogAzsBACABQQFqIgFBgAFHDQBB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QEEAEBgQWgUgBhAeCwsgByAZNwMAIAMgGjcDACACIAo2AgAgACgCACgCECECQQAkBSACIAAgF6cgF0IgiKdBABBQIwUhAkEAJAUgAkEBcQRAQQAQGBBaBSABIQ8LCyAPLAAABEAgAEGhvANqLAAARQRAIAUkBEEBDwsLIABB5LwDaiAAQRhqEGoaIAUkBEEBDwsgBSQEQQALBgBBFxAACwYAQRYQAAsGAEEREAALCABBBxAAQQALLQEBfyAAQTsQrQEiAgRAIAJBBGoQyQIhACABBEAgAkEANgIACwVBACEACyAAC9YBAQJ/IwQhAyMEQYAQaiQEAkAgAARAAkACQAJAAkAgACgCAA4wAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIBAgsMBAsgAUEANgIADAELIANBgBAQtgNFBEAgA0EAOgAACyADIAEgAhB7GiABEFkiBARAIARBAWogAkkgASAEQX9qQQJ0aigCAEEvR3EEQCABQfwMEIYCGgsLCyABIAAgAhB4GiADJAQPCwsgAkUEQCADJAQPCyABQQA2AgAgAyQEC78BAQJ/AkAgAkF/aiIEBEBBACECA0ACQAJAAkAgACACQQJ0aigCACIDDl0AAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgECCwwEC0EvIQMLIAEgAkECdGogAzYCACACQQFqIgIgBEkNAAsFQQAhAgsLIAEgAkECdGpBADYCAAtWAQN/IAAoAgQiBUEIdSEEIAVBAXEEQCACKAIAIARqKAIAIQQLIAAoAgAiACgCACgCHCEGIAAgASACIARqIAVBAnEEfyADBUECCyAGQQdxQZgCahEKAAsHACAAIAFGCwsAIAAQ/AEgABBSCxIAIABB2CU2AgAgAEEEahCNAwuDAQEBfyMEIQEjBEEQaiQEQQAkBSAAEAsjBSEAQQAkBSAAQQFxRQRAQQAkBUEZQbvyACABEA1BACQFC0EAEBgiABAVGkEAJAVBGUHj8gAgAUEIahANQQAkBUEAEBghAUEAJAVBBBALIwUhAEEAJAUgAEEBcQRAQQAQGCIAEFoFIAEQWgsLOAECfyMEIQAjBEEQaiQEQai8A0EDEEkEQEGj8QAgABCCAQVBrLwDKAIAEEchASAAJAQgAQ8LQQALuAEBBX8jBCEFIwRBEGokBCAAQQtqIgYsAAAiA0EASCIEBH8gACgCCEH/////B3FBf2oFQQoLIgcgAkkEQCAAIAcgAiAHayAEBH8gACgCBAUgA0H/AXELIgNBACADIAIgARCkAwUgBAR/IAAoAgAFIAALIgMhBCACBEAgBCABIAIQXRoLIAVBADoAACADIAJqIAUsAAA6AAAgBiwAAEEASARAIAAgAjYCBAUgBiACOgAACwsgBSQEIAALpwEBAn8jBCEFIwRBkANqJAQgBSAANgIAIAUgAUF/ajYCBCAFQQhqIgRBAEH8ABBUGiAEQX86AEsgBEEeNgIkIARBgAI2AjAgBCAFQYgBajYCLCAEQX82AkwgBCAFNgJUIAEEQCABQQBIBEBBiLwDQcsANgIAQX8hAAUgBCACIAMQrQMhACAEQQBBABDEARogACABTwRAQX8hAAsLBUF/IQALIAUkBCAAC6kBAQV/IwQhAiMEQRBqJAQgAiABQf8BcSIGOgAAAkACQCAAQRBqIgMoAgAiBA0AIAAQjAIEQEF/IQEFIAMoAgAhBAwBCwwBCyAAQRRqIgMoAgAiBSAESQRAIAFB/wFxIgEgACwAS0cEQCADIAVBAWo2AgAgBSAGOgAADAILCyAAIAJBASAAKAIkQR9xQcoAahEBAEEBRgR/IAItAAAFQX8LIQELIAIkBCABC9EBAQN/IAJFBEAPCyACQX9qIQQgABBZIQMCQAJAA0ACQCADQQBMBEAgACECDAELIAAgA0F/aiICQQJ0aigCAEEvRg0CIAIhAwwBCwsMAQsgACADQQJ0aiECCyAEIAIgACIFa0ECdU8EQCAAEFkhAwJAAkADQAJAIANBAEwEQCAAIQIMAQsgACADQX9qIgJBAnRqKAIAQS9GDQIgAiEDDAELCwwBCyAAIANBAnRqIQILIAIgBWtBAnUhBAsgASAAIAQQrgEaIAEgBEECdGpBADYCAAtIAQJ/IAAoAgAoAgBBUGpBCkkEQANAIAJBCmxBUGogACgCACIBKAIAaiECIAAgAUEEaiIBNgIAIAEoAgBBUGpBCkkNAAsLIAIL3hIDFn8BfgF8IwQhCCMEQYABaiQEIAhB2ABqIREgCEHIAGohEiAIQShqIQ4gCEEgaiETIAhBGGohFCAIQRBqIRUgCEEIaiEWIAhB8ABqIRcgCEHoAGohGCAIQewAaiIKIAE2AgAgAEEARyEQQQAhAQJAAkADQAJAAkAgCUF/SgRAIAVB/////wcgCWtMBEAgBSAJaiEJDAILIAAoAgBBIHFFBEBBiLwDQcsANgIAC0F/IQkLCyAKKAIAIgYoAgAiB0UNAiAGIQUDQAJAAkACQCAHDiYAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAELDAELIAogBUEEaiIFNgIAIAUoAgAhBwwBCwsgBUHgJBCuAyEFIAogCigCACIHIAVBfnFBAnRqNgIAIAcgBUEBdkECdGogBmtBAnUhBSAQBEAgACAGIAUQxQELIAUNASAKIAooAgAiBSAKKAIAKAIEQVBqQQpPBH9BfyEPQQEFIAUoAghBJEYEfyAFKAIEQVBqIQ9BASEBQQMFQX8hD0EBCwtBAnRqIgU2AgAgBSgCACIHQWBqIgZBH0tBASAGdEGJ0QRxRXIEQEEAIQYFQQAhCyAHIQYDQEEBIAZBYGp0IAtyIQYgBUEEaiIFKAIAIgdBYGoiC0EfS0EBIAt0QYnRBHFFckUEQCAGIQsgByEGDAELCyAKIAU2AgALAkAgB0EqRgR/An8CQCAFKAIEQVBqQQpPDQAgCigCACIFKAIIQSRHDQAgBCAFQQRqIgEoAgBBUGpBAnRqQQo2AgAgAyABKAIAQVBqQQN0aikDAKchAUEBIQcgBUEMagwBCyABBEBBfyEJDAQLIBAEQCACKAIAQQNqQXxxIgUoAgAhASACIAVBBGo2AgAFQQAhAQtBACEHIAooAgBBBGoLIQUgCiAFNgIAIAZBgMAAciELQQAgAWshDSABQQBIIgxFBEAgBiELCyAMRQRAIAEhDQsgByEBIAUFIAoQgwIiDUEASARAQX8hCQwDCyAGIQsgCigCAAsiBigCAEEuRgRAIAYoAgRBKkcEQCAKIAZBBGo2AgAgChCDAiEFIAooAgAhBgwCCyAGKAIIQVBqQQpJBEAgCigCACIGKAIMQSRGBEAgBCAGQQhqIgUoAgBBUGpBAnRqQQo2AgAgAyAFKAIAQVBqQQN0aikDAKchBSAKIAZBEGoiBjYCAAwDCwsgAQRAQX8hCQwDCyAQBEAgAigCAEEDakF8cSIGKAIAIQUgAiAGQQRqNgIABUEAIQULIAogCigCAEEIaiIGNgIABUF/IQULC0EAIQcDQCAGKAIAQb9/aiIMQTlLBEBBfyEJDAILIAogBkEEaiIGNgIAIAdBOmxBruoAaiAMaiwAACIZQf8BcSIMQX9qQQhJBEAgDCEHDAELCyAZRQRAQX8hCQwBCyAPQX9KIRoCQAJAIBlBE0YEQCAaBEBBfyEJDAQFDAILAAUgGgRAIAQgD0ECdGogDDYCACAIIAMgD0EDdGopAwA3AwAMAgsgEEUEQEEAIQkMBAsgCCAMIAIQsQEgCigCACEGCwwBCyAQRQRAQQAhBQwDCwsgBkF8aigCACIMQV9xIQYCQAJAAkACQAJAAkACQAJAIAdBAEcgDEEPcUEDRnEEfyAGBSAMIgYLQcMAaw4xAgYGBgYGBgYGBgYGBgYGBgMGBgYGBgYGBgYGBgYGBgYBBgYGBgYGBgYGBAAGBgYGBQYLAkACQAJAAkACQAJAAkACQCAHQf8BcUEYdEEYdQ4IAAECAwQHBQYHCyAIKAIAIAk2AgBBACEFDA8LIAgoAgAgCTYCAEEAIQUMDgsgCCgCACAJrDcDAEEAIQUMDQsgCCgCACAJOwEAQQAhBQwMCyAIKAIAIAk6AABBACEFDAsLIAgoAgAgCTYCAEEAIQUMCgsgCCgCACAJrDcDAEEAIQUMCQtBACEFDAgLIAgpAwCnELcDIAAQrAEaQQEhBQwHCyAIKQMApyAAEKwBGkEBIQUMBgsgCCgCACIHQQAgBRCzAyIGIAdrQQJ1IQwgDSAGBH8gDAUgBQsiBkgEfyAGBSANCyEFIAtBgMAAcQRAIAAgByAGEMUBIBUgBSAGazYCACAVQYyLBDYCBCAAQf7tACAVEJABGgUgFiAFIAZrNgIAIBZBjIsENgIEIABB/u0AIBYQkAEaIAAgByAGEMUBCwwFCyAIQYi8AygCABCSAiIHNgIADAILIAgoAgAhBwwBCyAGQSByIgdBsu0AaiwAACEMIA4gC0EDdkEBcUEBc0GJ7gBqNgIAIA4gC0ELdkEBcUEBc0GL7gBqNgIEIA4gC0ENdkEBcUEBc0GN7gBqNgIIIA4gC0EBcUEBc0GP7gBqNgIMIA4gC0EQdkEBcUEBc0GR7gBqNgIQIA4gDDYCFCAOIAY2AhggF0EQQavuACAOEMEDGgJAAkACQCAHQeEAaw4YAAICAQAAAAIBAgICAgIBAQICAgIBAgIBAgsgCCsDACEcIBIgDTYCACASIAU2AgQgEiAcOQMIIAAgFyASEJABIQUMBAsgCCkDACEbIBEgDTYCACARIAU2AgQgESAbNwMIIAAgFyAREJABIQUMAwtBACEFDAILIAdFBEAgCEGC7gA2AgBBgu4AIQcLAkAgBUH/////B0kEfyAFBUH/////BwsiDEEASgRAIAchBUEAIQYDQCAYIAVBBBDMASIPQQBKBEAgBSAPaiEFIAZBAWoiBiAMSA0BIAYhBQwDCwsgD0EASARAQX8hCQwDBSAGIQULBUEAIQULCyANIAVIBH8gBQUgDQshBiALQYDAAHFBAEciDUUEQCAUIAYgBWs2AgAgFEGMiwQ2AgQgAEH+7QAgFBCQARoLIAUEQCAFIQsDQCAHIBggB0EEEMwBaiEHIBgoAgAgABCsARogC0F/aiILDQALCyANBEAgEyAGIAVrNgIAIBNBjIsENgIEIABB/u0AIBMQkAEaCyAGIQUMAQsLDAELIABFBEAgAQRAQQEhAANAIAQgAEECdGooAgAiAQRAIAMgAEEDdGogASACELEBIABBAWohASAAQQlIBEAgASEADAIFIAEhAAsLCyAAQQpIBEADQCAEIABBAnRqKAIABEBBfyEJDAULIABBAWohASAAQQlIBEAgASEADAEFQQEhCQsLBUEBIQkLBUEAIQkLCwsgCCQEIAkLcAEBfyAAKAJMGiABBEAgAEH4AGoiAigCAEUEQCACQawjKAIAKAIABH9BjB4FQbC7Aws2AgALIABBygBqIgAsAAAiAgRAIAIhAQUgACABQQBKBH9BAQVBfwsiAToAAAsFIAAsAEohAQsgAUEYdEEYdQsTACAAIAAQWUECdGogARBqGiAACyEBAn8gABBuQQFqIgEQbCICBH8gAiAAIAEQUwVBAAsiAAsXAEEAIAAgASACBH8gAgVBpLwDCxCKAgtCAQN/IAIEQCABIQMgACEBA0AgA0EEaiEEIAFBBGohBSABIAMoAgA2AgAgAkF/aiICBEAgBCEDIAUhAQwBCwsLIAAL7AIBBX8jBCEGIwRBEGokBCADBH8gAwVBoLwDCyIEKAIAIQMCfwJAIAEEfyAABH8gAAUgBgshBSACBEACQAJAIAMEQCADIQAgAiEDDAEFIAEsAAAiAEF/SgRAIAUgAEH/AXE2AgAgAEEARwwHCyABLAAAIQBBrCMoAgAoAgBFBEAgBSAAQf+/A3E2AgBBAQwHCyAAQf8BcUG+fmoiAEEySw0FIAFBAWohASAAQQJ0QaQeaigCACEAIAJBf2oiAw0BCwwBCyABLAAAIgdB/wFxQQN2IghBcGogCCAAQRp1anJBB0sNAwNAAkAgA0F/aiEDIAdB/wFxQYB/aiAAQQZ0ciIAQQBODQAgA0UNAiABQQFqIgEsAAAiB0HAAXFBgAFGDQEMBQsLIARBADYCACAFIAA2AgAgAiADawwECyAEIAA2AgALQX4FIAMNAUEACwwBCyAEQQA2AgBBiLwDQdQANgIAQX8LIQAgBiQEIAALQAAgAQRAIABBAnRB8LsDaiAAIAEQxQMiADYCAAUgAEECdEHwuwNqKAIAIQALIABBCGohASAABH8gAQVBrOoACwtrAQJ/IABBygBqIgIsAAAhASACIAFB/wFqIAFyOgAAIAAoAgAiAUEIcQR/IAAgAUEgcjYCAEF/BSAAQQA2AgggAEEANgIEIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAsiAAvtAQEEfwJAAkAgAkEQaiIEKAIAIgMNACACEIwCBEBBACECBSAEKAIAIQMMAQsMAQsgAyACQRRqIgUoAgAiBGsgAUkEQCACIAAgASACKAIkQR9xQcoAahEBACECDAELAkAgAiwAS0F/SgRAIAEhAwNAIANFBEBBACEDDAMLIAAgA0F/aiIGaiwAAEEKRwRAIAYhAwwBCwsgAiAAIAMgAigCJEEfcUHKAGoRAQAiAiADSQ0CIAAgA2ohACABIANrIQEgBSgCACEEBUEAIQMLCyAEIAAgARBTGiAFIAUoAgAgAWo2AgAgAyABaiECCyACC5kBAgF/An4CQAJAAkAgAL0iA0I0iCIEp0H/D3EiAgRAIAJB/w9GBEAMBAUMAwsACyABIABEAAAAAAAAAABiBH8gAEQAAAAAAADwQ6IgARCOAiEAIAEoAgBBQGoFQQALIgI2AgAMAgALAAALIAEgBKdB/w9xQYJ4ajYCACADQv////////+HgH+DQoCAgICAgIDwP4S/IQALIAALSAECfyAAKAIALAAAQVBqQQpJBEADQCACQQpsQVBqIAAoAgAiASwAAGohAiAAIAFBAWoiATYCACABLAAAQVBqQQpJDQALCyACC3QBAn8gAgR/AkAgACwAACIDBEAgACEEIAMhAANAIABBGHRBGHUgASwAACIDRiACQX9qIgJBAEcgA0EAR3FxRQ0CIAFBAWohASAEQQFqIgQsAAAiAA0AQQAhAAsFQQAhAAsLIABB/wFxIAEtAABrBUEACyIAC/sBAQN/AkAgAUH/AXEiAgRAIABBA3EEQCABQf8BcSEDA0AgACwAACIERSAEIANBGHRBGHVGcg0DIABBAWoiAEEDcQ0ACwsgAkGBgoQIbCEDAkAgACgCACICQYCBgoR4cUGAgYKEeHMgAkH//ft3anFFBEADQCACIANzIgJBgIGChHhxQYCBgoR4cyACQf/9+3dqcQ0CIABBBGoiACgCACICQYCBgoR4cUGAgYKEeHMgAkH//ft3anFFDQALCwsgAUH/AXEhAgNAIABBAWohASAALAAAIgNFIAMgAkEYdEEYdUZyRQRAIAEhAAwBCwsFIAAgABBuaiEACwsgAAsNACAAQawjKAIAEMcDC6QDAQZ/IAFBAXRBf2ohAyABQX9qIQQCQCAAQYCwfWpBgK4BSSAAQYCkf2pBwPABSSAAQYB0akGAFEkgABDIA0VycnJFBEAgAUEARyICIABB4F5qQS5JcQRAIABBxSFKBEACQAJAAkAgAEHHIWsOBwABAQEBAQABCwwBCwwECwsgAEHgOGohAAwCCyAAQYCmf2pBJkkgAkEBc3EEQCAAQaBHaiEADAIFQQAhAgsCQAJAA0AgACACQQJ0Qdwqai8BAGsiBSAEIAJBAnRB3ipqLAAAIgYiB3FrIAJBAnRB3ypqLQAASQ0BIAJBAWoiAkE9Rw0ACwwBCyAGQQFGBEAgASAAaiAFQQFxayEABSADIAdsIABqIQALDAILAkBBASABayIEQQF0QfQmai4BACICBEBBACEDA0AgAkH//wNxIABHBEAgA0EBaiIDQQJ0QfQmaiAEQQF0ai4BACICRQ0DDAELCyADQQJ0QfQmaiABQQF0ai8BACEADAMLCyAAQVhqIAFB0ABsaiECIABB2Pd7aiABQShsakEoSQR/IAIFIAALDwsLIAALOwEBfyMEIQEjBEEQaiQEIAEgADYCAEE8IAEQJyIAQYBgSwRAQYi8A0EAIABrNgIAQX8hAAsgASQEIAALywwBBn8CQCAAIAFqIQUCQCAAKAIEIgNBAXFFBEAgACgCACECIANBA3FFBEAPCyACIAFqIQFB1LcDKAIAIAAgAmsiAEYEQCAFQQRqIgIoAgAiA0EDcUEDRw0CQci3AyABNgIAIAIgA0F+cTYCACAAIAFBAXI2AgQgBSABNgIADwsgAkEDdiEEIAJBgAJJBEAgACgCDCICIAAoAggiA0YEQEHAtwNBwLcDKAIAQQEgBHRBf3NxNgIABSADIAI2AgwgAiADNgIICwwCCyAAKAIYIQcCQCAAKAIMIgIgAEYEQCAAQRBqIgNBBGoiBCgCACICBEAgBCEDBSADKAIAIgJFBEBBACECDAMLCwNAIAJBFGoiBCgCACIGBEAgBiECIAQhAwwBCyACQRBqIgQoAgAiBgRAIAYhAiAEIQMMAQsLIANBADYCAAUgACgCCCIDIAI2AgwgAiADNgIICwsgBwRAIAAoAhwiA0ECdEHwuQNqIgQoAgAgAEYEQCAEIAI2AgAgAkUEQEHEtwNBxLcDKAIAQQEgA3RBf3NxNgIADAQLBSAHQRBqIAcoAhAgAEdBAnRqIAI2AgAgAkUNAwsgAiAHNgIYIABBEGoiBCgCACIDBEAgAiADNgIQIAMgAjYCGAsgBCgCBCIDBEAgAiADNgIUIAMgAjYCGAsLCwsgBUEEaiIDKAIAIgJBAnEEQCADIAJBfnE2AgAgACABQQFyNgIEIAAgAWogATYCACABIQIFQdi3AygCACAFRgRAQcy3A0HMtwMoAgAgAWoiATYCAEHYtwMgADYCACAAIAFBAXI2AgQgAEHUtwMoAgBHBEAPC0HUtwNBADYCAEHItwNBADYCAA8LQdS3AygCACAFRgRAQci3A0HItwMoAgAgAWoiATYCAEHUtwMgADYCACAAIAFBAXI2AgQgACABaiABNgIADwsgAkF4cSABaiEGIAJBA3YhAwJAIAJBgAJJBEAgBSgCDCIBIAUoAggiAkYEQEHAtwNBwLcDKAIAQQEgA3RBf3NxNgIABSACIAE2AgwgASACNgIICwUgBSgCGCEHAkAgBSgCDCIBIAVGBEAgBUEQaiICQQRqIgMoAgAiAQRAIAMhAgUgAigCACIBRQRAQQAhAQwDCwsDQCABQRRqIgMoAgAiBARAIAQhASADIQIMAQsgAUEQaiIDKAIAIgQEQCAEIQEgAyECDAELCyACQQA2AgAFIAUoAggiAiABNgIMIAEgAjYCCAsLIAcEQCAFKAIcIgJBAnRB8LkDaiIDKAIAIAVGBEAgAyABNgIAIAFFBEBBxLcDQcS3AygCAEEBIAJ0QX9zcTYCAAwECwUgB0EQaiAHKAIQIAVHQQJ0aiABNgIAIAFFDQMLIAEgBzYCGCAFQRBqIgMoAgAiAgRAIAEgAjYCECACIAE2AhgLIAMoAgQiAgRAIAEgAjYCFCACIAE2AhgLCwsLIAAgBkEBcjYCBCAAIAZqIAY2AgAgAEHUtwMoAgBGBEBByLcDIAY2AgAPBSAGIQILCyACQQN2IQMgAkGAAkkEQCADQQN0Qei3A2ohAUHAtwMoAgAiAkEBIAN0IgNxBH8gAUEIaiIDKAIABUHAtwMgAiADcjYCACABQQhqIQMgAQshAiADIAA2AgAgAiAANgIMIAAgAjYCCCAAIAE2AgwPCyACQQh2IgEEfyACQf///wdLBH9BHwUgAkEOIAEgAUGA/j9qQRB2QQhxIgF0IgNBgOAfakEQdkEEcSIEIAFyIAMgBHQiAUGAgA9qQRB2QQJxIgNyayABIAN0QQ92aiIBQQdqdkEBcSABQQF0cgsFQQALIgNBAnRB8LkDaiEBIAAgAzYCHCAAQQA2AhQgAEEANgIQQcS3AygCACIEQQEgA3QiBnFFBEBBxLcDIAQgBnI2AgAgASAANgIADAELIAEoAgAhAUEZIANBAXZrIQQgAiADQR9GBH9BAAUgBAt0IQMCQANAIAEoAgRBeHEgAkYNASADQQF0IQQgAUEQaiADQR92QQJ0aiIDKAIAIgYEQCAEIQMgBiEBDAELCyADIAA2AgAMAQsgAUEIaiICKAIAIgMgADYCDCACIAA2AgAgACADNgIIIAAgATYCDCAAQQA2AhgPCyAAIAE2AhggACAANgIMIAAgADYCCAsEAEEAC1oBAX8jBCECIwRBgBBqJAQgASACQYAQEGkaIABBBGoiAyABED82AgAgAEEBOgASIABBADYCDCAAQQA6ABAgAEEYaiABQYAQEG8aIAMoAgBBAEchACACJAQgAAuHAQECfyMEIQIjBEGAEGokBCAAQZjAAGoiA0EANgIAIAEgAkGAEBBpGiABEEAiBEUEQEGIvAMoAgBBAkYEQCADQQE2AgALCyAAQQA6ABIgAEEANgIMIABBADoAECAEQQBHIgNFBEAgAiQEIAMPCyAAIAQ2AgQgAEEYaiABQYAQEG8aIAIkBCADC4sBAQF/IwQhAyMEQRBqJAQgAyACENUBIAEgACgCAGoiAEELaiIBLAAAQQBIBEAgACgCAEEANgIAIABBADYCBAUgAEEANgIAIAFBADoAAAtBACQFQRYgAEEAEA0jBSEBQQAkBSABQQFxBEBBABAYIgAQWgUgACADKQIANwIAIAAgAygCCDYCCCADJAQLC2ABA38gASAAKAIAaiIBLAALIgJBAEghAyABKAIEIQAgAkH/AXEhAiADBH8gAAUgAiIAC0ECdEEEahBsIgIgADYCACABKAIAIQQgAkEEaiADBH8gBAUgAQsgABCJAhogAgskAQF/IAEgACgCAGoiAyACKAIANgIAIANBBGogAkEEahClAxoLTgAgASAAKAIAaiEBQRAQXyIAIAEoAgA2AgBBACQFQRUgAEEEaiABQQRqEA0jBSEBQQAkBSABQQFxBEAQFyEBIAAQUiABEB4FIAAPC0EACzgBAX8gAEUEQA8LIAAsABtBAEgEQCAAKAIQEFILIABBBGoiASwAC0EASARAIAEoAgAQUgsgABBSCygBAX8gAkUEQCAADwsgACABIAJBf2oiAxDGARogACADakEAOgAAIAALDQAgAEEHcUECahEFAAv2AwEHfyMEIQYjBEGQwAFqJAQgAkEAEK8BIQcgBkGIgAFqIghBADYCACAAQQA2AhAgACAGQYjAAGoiBUGAEBDaAUUEQCAGJARBAA8LIAZBBGohCiAGQQhqIQsgAQRAA0ACfyAFEM8BIgEoAgBBL0YEQCABQQA2AgALAkACQCADRQ0AIAUoAgBBL0cNACAIKAIARQRAIAIgCEGAEBD3AQsgBSAIIAQQpQEEQEEBIQFBGwwDCwwBCyAFQQAQrwEiCSgCAEEqRgR/IAkoAgRBL0YEfyAGQS42AgAgCkEvNgIAIAsgB0GAEBBvGiAGBSAHCwUgBwshASAJIAEgBBClAQRAQQEhAUEbDAILCyAAIAVBgBAQ2gENAUEAIQFBGwshAAsFA0ACfyAFEM8BKAIAQS9GBEAgBUGIHUGAEBB4GgsCQAJAIANFDQAgBSgCAEEvRw0AIAgoAgBFBEAgAiAIQYAQEPcBCyAFIAggBBClAQRAQQEhAUEbDAMLDAELIAVBABCvASIJKAIAQSpGBH8gCSgCBEEvRgR/IAZBLjYCACAKQS82AgAgCyAHQYAQEG8aIAYFIAcLBSAHCyEBIAkgASAEEKUBBEBBASEBQRsMAgsLIAAgBUGAEBDaAQ0BQQAhAUEbCyEACwsgAEEbRgRAIAYkBCABDwtBAAs4AQJ/IABBEGoiAigCACIBIAAoAgRPBEBBAA8LIAIgAUEBaiAAKAIAIAFBAnRqIgAQWWo2AgAgAAuMBwEGfyAAQQRqIgVBARDkASAAQaiWAWoiBkEAQYACEFQaIABB0MYDaiIDQQA2AgAgAEGIvgJqQQA2AgAgAEGQvgJqQQA2AgAgAEGMvgJqQQA2AgAgAEEUaiICQgA3AgAgAkIANwIIIAJCADcCECACQgA3AhggAkIANwIgIAJCADcCKEEAJAVBJCAAQdDMA2oiBxAMIwUhBEEAJAUCQCAEQQFxBEAQFyEBBUEAJAVBESAAQYjNA2pBARANIwUhBEEAJAUgBEEBcQRAEBchASAHELICDAILIABBmM0DaiICQgA3AgAgAkIANwIIIAJCADcCECACQgA3AhggAkIANwIgIAJCADcCKCAAIAE2AgAgAEGomAFqQQA6AAAgAEG4mAFqQQA6AAAgAEG5mAFqQQA6AAAgAEG6mAFqQQA6AAAgAEHMzQNqQQA2AgAgAEHQzQNqQQA2AgAgAEEANgI4IABBADYCCCAAQQA2AgQgAEHAmAFqQgA3AwAgAEHEAGpBAEHklQEQVBogAEF/NgJwIABBwK4CakEANgIAIABBxK4CakEANgIAIABBuK4CakEANgIAIABBvK4CakEBNgIAIABByK4CakEAQfACEFQaIABBhK8BakEAQbT/ABBUGiAAQczMA2pBADoAACAAQbTJA2pBAEGUAxBUGiAAQbDJA2pBAjYCACAAQcjMA2pBADYCACAAQQAQgwEgAEHUrgFqIgFCADcCACABQgA3AgggAUIANwIQIABB0K4BakGA6gA2AgAgAEGArwFqQYHAADYCACAAQfyuAWpBgAE2AgAgAEH4rgFqQYABNgIAIABB9K4BakEANgIAIABBzK4BakEANgIAIABB7K4BakEANgIAIABB8K4BakEANgIAIABBADYCaEEAIQEDQCAAQcqgAWogAUEBdGogAUEIdEH//wNxIgI7AQAgAEHKmAFqIAFBAXRqIAI7AQAgAEHKnAFqIAFBAXRqIAE7AQAgAEHKpAFqIAFBAXRqQQAgAWtBCHQ7AQAgAUEBaiIBQYACRw0ACyAAQcqoAWpBAEGABhBUGkEAIABByqABaiAAQcqqAWoQnwEPCwsgAygCAARAIANBADYCACAAQfzHA2ooAgAQUgsgBhDYASAAKAI0IgMEQCADEFILIAAoAiQiAARAIAAQUgsgAigCACIARQRAIAUQmAEgARAeCyAAEFIgBRCYASABEB4Lmw0BE38jBCEIIwRB0ANqJAQgAiwAEUUEQCAIJARBAQ8LIAFBCGoiECwAAEUEQCABKAIAIABB6ABqIgYoAgAiBEFnakoEQCAEIABBBGoiBygCACIFayICQQBIBEAgCCQEQQAPCyAAQfAAaiIKIABB+ABqIgsoAgAgBWsgCigCAGo2AgAgBUGAgAFKBEAgAkEASgRAIAAoAhAiBCAEIAVqIAIQXRoLIAdBADYCACAGIAI2AgAFIAQhAgsgAkGAgAJGBEBBACECQYCAAiEEBSAAKAIAIAAoAhAgAmpBgIACIAJrEF4hAiAGKAIAIgUgAmohBCACQQBKBEAgBiAENgIABSAFIQQLCyAAQewAaiIGIARBYmoiBDYCACALIAcoAgAiBTYCACAFQX9qIAooAgAiB2ohBSAHQX9HBEAgBiAEIAVIBH8gBAUgBQs2AgALIAJBf0YEQCAIJARBAA8LCwsgCEGwA2ohB0EAIQIDQCABEFhBDHYhBCABQQQQVQJAAkAgBEH/AXFBD0YEQCABEFhBDHZB/wFxIQUgAUEEEFUgBQRAIAVBAmohBCAHIAJqQQBBAEF+IAVrIgUgAkFsaiIGSwR/IAUFIAYLaxBUGgNAIARBf2ohBSAEQQFKIAJBAWoiBkEUSXEEQCAFIQQgBiECDAELCwVBDyEEDAILBSAEQf8BcSEEDAELDAELIAcgAmogBDoAAAsgAkEBaiICQRRJDQALQQAgByADQbD3AGoiEUEUEGggAEHoAGohByAAQQRqIQogAEH4AGohDSAAQfAAaiELIABBEGohDiAAQewAaiEPIAFBDGohEiABQQRqIQwgA0G0+ABqIRMgCEF/aiEUQQAhAgJAAkADQAJAIAJBrgNIIRUgAkEASiEWAkACQAJAA0AgECwAAEUhBCAVRQ0GIAQEQCABKAIAIAcoAgAiBUF7akoEQCAFIAooAgAiBmsiBEEASA0GIAsgDSgCACAGayALKAIAajYCACAGQYCAAUoEQCAEQQBKBEAgDigCACIFIAUgBmogBBBdGgsgCkEANgIAIAcgBDYCAAUgBSEECyAEQYCAAkYEQEEAIQRBgIACIQUFIAAoAgAgDigCACAEakGAgAIgBGsQXiEEIAcoAgAiBiAEaiEFIARBAEoEQCAHIAU2AgAFIAYhBQsLIA8gBUFiaiIFNgIAIA0gCigCACIGNgIAIAZBf2ogCygCACIJaiEGIAlBf0cEQCAPIAUgBkgEfyAFBSAGCzYCAAsgBEF/Rg0GCwsgEigCACIEIAEoAgAiBUEBamotAABBCHQgBCAFai0AAEEQdHIgBCAFQQJqai0AAHJBCCAMKAIAIglrdkH+/wNxIgYgA0G09wBqIBMoAgAiBEECdGooAgBJBH8gASAJIANBuPgAaiAGQRAgBGt2IgRqLQAAaiIGQQN2IAVqNgIAIAwgBkEHcTYCACADQbiAAWogBEEBdGoFA0ACQCAEQQFqIgRBD08EQEEPIQQMAQsgBiADQbT3AGogBEECdGooAgBPDQELCyABIAQgCWoiCUEDdiAFajYCACAMIAlBB3E2AgAgA0G4kAFqIAYgAyAEQQJ0akGw9wBqKAIAa0EQIARrdiADQfT3AGogBEECdGooAgBqIgQgESgCAE8Ef0EABSAEC0EBdGoLIgQuAQAiBEH//wNxQRBIDQEgBEH//wNxQRJODQMgARBYIQUgBEEQRgR/IAFBAxBVIAVBDXZBA2oFIAFBBxBVIAVBCXZBC2oLIQUgFkUNAAwCCwALIAggAmogBDoAACACQQFqIQIMAwsgFCACaiwAACEJIAIhBANAIAVBf2ohBiAIIARqIAk6AAAgBEEBaiECIARBrQNIIAVBAUpxRQ0DIAYhBSACIQQMAAsACyABEFghBSAEQRJGBH8gAUEDEFUgBUENdkEDagUgAUEHEFUgBUEJdkELagshBCAIIAJqQQBBACACQX9qIAJBrQNKBH8gAgVBrQMLayIFQX4gBGsgBEF/cyIGQX5KBH8gBgVBfgtrIgZLBH8gBQUgBgtrEFQaIAIhBQNAIARBf2ohBiAFQQFqIQIgBUGtA0ggBEEBSnFFDQIgBiEEIAIhBQwACwALQQAhAAsMAQsgBARAIAEoAgAgBygCAEoEQEEAIQAMAgsLQQAgCCADQbICEGhBACAIQbICaiADQewdakHAABBoQQAgCEHyAmogA0HYO2pBEBBoQQAgCEGCA2ogA0HE2QBqQSwQaEEBIQALIAgkBCAAC+cEAQl/IAJBDGoiCUEANgIAIAEsAAhFBEAgASgCACAAQegAaiIGKAIAIgRBeWpKBEAgBCAAQQRqIgcoAgAiBWsiA0EASARAQQAPCyAAQfAAaiIIIABB+ABqIgooAgAgBWsgCCgCAGo2AgAgBUGAgAFKBEAgA0EASgRAIAAoAhAiBCAEIAVqIAMQXRoLIAdBADYCACAGIAM2AgAFIAQhAwsgA0GAgAJGBEBBACEDQYCAAiEEBSAAKAIAIAAoAhAgA2pBgIACIANrEF4hAyAGKAIAIgUgA2ohBCADQQBKBEAgBiAENgIABSAFIQQLCyAAQewAaiIGIARBYmoiBDYCACAKIAcoAgAiBTYCACAFQX9qIAgoAgAiB2ohBSAHQX9HBEAgBiAEIAVIBH8gBAUgBQs2AgALIANBf0YEQEEADwsLCyABQQAgAUEEaiIHKAIAa0EHcRBVIAEQWCEGIAFBCBBVIAZBC3ZBA3EiCEEDRgRAQQAPCyAJIAhBA2o2AgAgAiAGQQh2IgpBB3FBAWo2AgQgARBYIQsgAUEIEFVBACEEQQAhAwNAIAEQWEEIdiAEQQN0dCADaiEDIAEgBygCAEEIaiIFQQN2IAEoAgBqIgk2AgAgByAFQQdxNgIAIARBAWohBSAEIAhHBEAgBSEEDAELCyACIAM2AgAgCkHaAHMgC0EIdnMgA3MgA0EIdnMgA0EQdnNB/wFxBEBBAA8LIAIgCTYCCCAAQewAaiIBKAIAIQAgASAAIAlBf2ogA2oiAUgEfyAABSABCzYCACACIAZBDnZBAXE6ABAgAiAGQQ92QQFxOgARQQELsBABHH8CQCMEIQIjBEEgaiQEIAJBGGohFiACQRBqIRcgAkEIaiEYIAIhESAAQeQAaiIZKAIAIQEgAEHQzQNqIRMgAEHgAGoiFCgCACEDAkAgAEGszQNqIhIoAgAiDwRAIABBqM0DaiEMIABBzM0DaiEbIABB0MwDaiENIABBpJYBaiEVIABBmM0DaiEaIABBupgBaiEcIABBwJgBaiEOIAMgAWsgEygCACIEcSEFQQAhAgNAAkACQCAMKAIAIAJBAnRqKAIAIgcEQCAHQQxqIgssAAAEQCALQQA6AAAMAgsgBygCBCEIIAQgBygCACILIAFrcSAFSQRAIAsgAUcEQCAAIAEgCxCzASALIQEgFCgCACALayATKAIAIgRxIQULIAggBUsNAyAEIAggC2pxIg9Bf2ogC0kEQCANQQAgFSgCACALaiAbKAIAIAtrIgEQtgEgDSABIBUoAgAgDxC2AQUgDUEAIBUoAgAgC2ogCBC2AQsgGigCACAHKAIQQQJ0aigCACIJQSxqIQUgCUEwaiIIKAIAIgFBwABLBH8gB0EsaiEGIAdBNGoiCigCACEEIAdBMGoiAyABNgIAIAQgAUkEQCAHKAI4IhBBAEcgASAQS3EEQCARIBA2AgBBrPUCQdgbIBEQYEGs9QIQViAKKAIAIQQgAygCACEBCyAGKAIAIAEgBEEgaiAEQQJ2aiIESwR/IAEFIAQiAQsQVyIERQRAQaz1AhBWCyAGIAQ2AgAgCiABNgIACyAGKAIAQUBrIAUoAgBBQGsgCCgCAEFAahBTGiADBSAHQTBqCyEEIAdBFGohAQJAAkAgBCgCAEUNACAHIA4pAwCnIgM2AmQgB0EsaiIGKAIAQSRqIgogAzoAACAKIANBCHY6AAEgCiADQRB2OgACIAogA0EYdjoAAyAGKAIAQShqIgMgDikDAEIgiKciBjoAACADIAZBCHY6AAEgAyAGQRB2OgACIAMgBkEYdjoAAyANIAEQsQIgBCgCACIBQcAATQ0AIAgoAgAgAUkEQCAJQTRqIgYoAgAhAyAIIAE2AgAgAyABSQRAIAkoAjgiCUEARyABIAlLcQRAIBggCTYCAEGs9QJB2BsgGBBgQaz1AhBWIAYoAgAhAyAIKAIAIQELIAUoAgAgASADQSBqIANBAnZqIgNLBH8gAQUgAyIBCxBXIgNFBEBBrPUCEFYLIAUgAzYCACAGIAE2AgALCyAFKAIAQUBrIAcoAixBQGsgBCgCAEFAahBTGgwBCyAFKAIAIgEEQCABEFIgBUEANgIACyAIQQA2AgAgCUEANgI0CyAHKAJoIQQgBygCbCEBIAwoAgAiAyACQQJ0aigCACIFBEAgBSgCPCIDBEAgAxBSCyAFKAIsIgMEQCADEFILIAUoAhQiAwRAIAMQUgsgBRBSIAwoAgAhAwsgAyACQQJ0akEANgIAAkAgAkEBaiIDIBIoAgBJBEADQCAMKAIAIANBAnRqKAIAIgVFDQIgBSgCACALRw0CIAUoAgQgAUcNAiAFLAAMDQIgDUEAIAQgARC2ASAaKAIAIAUoAhBBAnRqKAIAIglBLGohByAJQTBqIggoAgAiAkHAAEsEfyAFQSxqIQYgBUE0aiIKKAIAIQEgBUEwaiIEIAI2AgAgASACSQRAIAUoAjgiEEEARyACIBBLcQRAIBcgEDYCAEGs9QJB2BsgFxBgQaz1AhBWIAooAgAhASAEKAIAIQILIAYoAgAgAiABQSBqIAFBAnZqIgFLBH8gAgUgASICCxBXIgFFBEBBrPUCEFYLIAYgATYCACAKIAI2AgALIAYoAgBBQGsgBygCAEFAayAIKAIAQUBqEFMaIAQFIAVBMGoLIQEgBUEUaiECAkACQCABKAIARQ0AIAUgDikDAKciBDYCZCAFQSxqIgYoAgBBJGoiCiAEOgAAIAogBEEIdjoAASAKIARBEHY6AAIgCiAEQRh2OgADIAYoAgBBKGoiBCAOKQMAQiCIpyIGOgAAIAQgBkEIdjoAASAEIAZBEHY6AAIgBCAGQRh2OgADIA0gAhCxAiABKAIAIgJBwABNDQACQCAIKAIAIAJJBEAgCUE0aiIGKAIAIQQgCCACNgIAIAQgAk8NASAJKAI4IglBAEcgAiAJS3EEQCAWIAk2AgBBrPUCQdgbIBYQYEGs9QIQViAGKAIAIQQgCCgCACECCyAHKAIAIAIgBEEgaiAEQQJ2aiIESwR/IAIFIAQiAgsQVyIERQRAQaz1AhBWCyAHIAQ2AgAgBiACNgIACwsgBygCAEFAayAFKAIsQUBrIAEoAgBBQGoQUxoMAQsgBygCACICBEAgAhBSIAdBADYCAAsgCEEANgIAIAlBADYCNAsgBSgCaCEEIAUoAmwhASAMKAIAIgIgA0ECdGooAgAiBQRAIAUoAjwiAgRAIAIQUgsgBSgCLCICBEAgAhBSCyAFKAIUIgIEQCACEFILIAUQUiAMKAIAIQILIAIgA0ECdGpBADYCACADQQFqIgUgEigCAEkEQCADIQIgBSEDDAEFIAMhAgsLCwsgACgCACAEIAEQZSAcQQE6AAAgDiAOKQMAIAGtfDcDACAUKAIAIgMgDyIBayATKAIAIgRxIQUgEigCACEPCwsLIAJBAWoiAiAPSQ0BDAMLCyACIBIoAgAiAE8NAiAMKAIAIQQDQCAEIAJBAnRqKAIAIgMEQCADQQxqIgMsAAAEQCADQQA6AAALCyACQQFqIgIgAEkNAAsMAgsLIAAgASADELMBIBkgFCgCADYCACARJAQPCyAZIAE2AgAgESQEC5oCAQd/IwQhAiMEQRBqJAQgAEEEaiIEKAIAIgVBAWogAQR/IAEFQby1AwsiBhBZaiEBIAQgATYCACABIABBCGoiBygCACIITQRAIAAoAgAgBUECdGogBhBqGiAAQRRqIgAoAgBBAWohASAAIAE2AgAgAiQEDwsgAiEDIAAoAgwiAkEARyABIAJLcQR/IAMgAjYCAEGs9QJB2BsgAxBgQaz1AhBWIAQoAgAhASAHKAIABSAICyECIAAoAgAgASACQSBqIAJBAnZqIgJLBH8gAQUgAiIBC0ECdBBXIgJFBEBBrPUCEFYLIAAgAjYCACAHIAE2AgAgAiAFQQJ0aiAGEGoaIABBFGoiACgCAEEBaiEBIAAgATYCACADJAQL5AsBC38gAEHorgFqQQA2AgAgAEH8rgFqIgIoAgBBEGohASACIAE2AgAgAUH/AUsEQCACQZABNgIAIABB+K4BaiIBIAEoAgBBAXY2AgALIABB3K4BaiIEKAIAIQogAEEEaiIGEFghBQJAIAQoAgAiAUH5AEsEf0GAwAIgBUHw/wNxIgVLBH8gBkEDEFVBAyEBQQAFQQMhAQNAIAFBAWohASADQQFqIgJBAnRB9BRqKAIAIAVNBEAgAiEDDAELCyAGIAEQVSADQQJ0QfQUaigCAAshAiAFIAJrQRAgAWt2IAFBAnRBnBVqKAIAagUgAUE/TQRAIAVBgAJJBEAgBkEQEFUMAwVBACEBCwNAIAFBAWohAkGAgAIgAXYgBXFFBEAgAiEBDAELCyAGIAIQVSABIQUMAgtBgIACIAVB8P8DcSIFSwR/IAZBAhBVQQIhAUEABUECIQEDQCABQQFqIQEgA0EBaiICQQJ0QdAVaigCACAFTQRAIAIhAwwBCwsgBiABEFUgA0ECdEHQFWooAgALIQIgBSACa0EQIAFrdiABQQJ0QfwVaigCAGoLIQULIAQgBCgCACAFaiIBIAFBBXZrNgIAIAYQWCECIABB1K4BaiIHKAIAIgFB/9EASwR/QYAgIAJB8P8DcSIESwR/IAZBBRBVQQUhAUEABUEFIQFBACEDA0AgAUEBaiEBIANBAWoiAkECdEGwFmooAgAgBE0EQCACIQMMAQsLIAYgARBVIANBAnRBsBZqKAIACyECIAQgAmtBECABa3YhAiABQQJ0QdAWagUgAkHw/wNxIQQgAUH/DUsEfyAEQYDAACAESwR/IAZBBRBVQQUhAUEABUEFIQFBACEDA0AgAUEBaiEBIANBAWoiAkECdEGEF2ooAgAgBE0EQCACIQMMAQsLIAYgARBVIANBAnRBhBdqKAIACyICa0EQIAFrdiECIAFBAnRBpBdqBSAEQYCAAiAESwR/IAZBBBBVQQQhAUEABUEEIQFBACEDA0AgAUEBaiEBIANBAWoiAkECdEHYF2ooAgAgBE0EQCACIQMMAQsLIAYgARBVIANBAnRB2BdqKAIACyICa0EQIAFrdiECIAFBAnRB/BdqCwshASAHIAcoAgAgASgCACACaiIJaiIBIAFBCHZrNgIAIABByqoBaiAAQcqgAWogCUH/AXFBAXRqIgsuAQAiBEH//wNxIgFB/wFxaiIDLAAAIQIgAyACQQFqOgAAIARBAWpBEHRBEHUiA0H/AXFFBEAgAEHKoAFqIQggAEHKqgFqIQcDQEEAIAggBxCfASAAQcqqAWogCy4BACIEQf//A3EiAUH/AXFqIgMsAAAhAiADIAJBAWo6AAAgBEEBakEQdEEQdSIDQf8BcUUNAAsLIABByqABaiAJQQF0aiAAQcqgAWogAkH/AXFBAXRqIgIuAQA7AQAgAiABQQFqOwEAIAYQWEEIdiADQYD+A3FyIgRBAXYhCCAGQQcQVSAAQeCuAWoiASgCACEHAkACQAJAAkACQCAFDgUBAAICAAILDAMLIAggAEGArwFqKAIASw0BIAEgB0EBaiIBIAFBCHZrNgIADAILCyAHBEAgASAHQX9qNgIACwsgCCAAQYCvAWoiAygCAEkEf0EDBUEECyAFaiICQQhqIQEgBEGCBE8EQCACIQELIAMCfwJAIAdBsAFLDQAgCkHAAEkgAEHQrgFqKAIAQf/TAEtxDQBBgcAADAELQYD+AQsiAjYCACAAQdQAaiIDKAIAIQIgAyACQQFqNgIAIABBxABqIAJBAnRqIAg2AgAgAyADKAIAQQNxNgIAIAAgATYCWCAAIAg2AlwgAEGwmAFqIgIgAikDACABrX03AwAgAUUEQA8LIABBpJYBaiEEIABB4ABqIgcoAgAhAyAAQdDNA2oiBSgCACECA0AgBCgCACIAIANqIAAgAyAIayACcWosAAA6AAAgByAHKAIAQQFqIAUoAgAiAnEiADYCACABQX9qIgEEQCAAIQMMAQsLC8QFAQx/IwQhCyMEQYACaiQEIAshCiAAQcgMaigCACEGIABB1AxqIgwoAgAiDSgCBCEOAkACQCABBEAgCiEBDAEFIApBBGohASAKIA02AgAgBigCDA0BIAYhAwsMAQsgBigCDCEGIAIEQCAGIQMgAiEIIAEhBEEIIQkFIAEhByAGIQULA0ACQCAJQQhGBEAgCCgCBCIBIA5HBEAgASEDIAQhAQwCCyAEQQRqIQEgBCAINgIAIAMoAgwiBUUNASABIQcLIAUuAQBBAUYEQCAFIQMgBUEEaiEIIAchBEEIIQkMAgsgBSgCCCIILAAAIAwoAgAsAAAiAUYEQCAFIQMgByEEQQghCQwCCwNAIAhBCGoiCCwAACABRgRAIAUhAyAHIQRBCCEJDAMFDAELAAsACwsgASAKRgRAIAskBCADDwsLIA4sAAAhCSADLgEAIgVBAUYEfyADLAAFBSAAQeCXAWooAgAgA08EQCALJARBAA8LIAMoAggiAiwAACAJRwRAA0AgAkEIaiICLAAAIAlHDQALCyACLQABIgRBf2oiB0EBdCICIAMvAQQgBUH//wNxa0EBIARraiIESwR/IAJBf2ogBEEDbGogBEEBdG4FIAdBBWwgBEsLIgJBAWpB/wFxCyECIA5BAWohBiAAQZCVAWohCCAAQcSWAWohDCAAQcCWAWohBSAAQciWAWohDSACQf8BcUEIdCAJQf8BcXIhBAJAA0AgAUF8aiICKAIAIQcCQAJAIAwoAgAiACAFKAIARgRAIA0oAgAiAARAIA0gACgCADYCAAUgCEEAEKABIQALIAANAQUgDCAAQXBqIgA2AgAMAQsMAQsgACEBIABBATsBACAAIAQ2AgQgACAGNgIIIAAgAzYCDCAHIAA2AgQLIABFBEBBACEADAILIAIgCkcEQCAAIQMgAiEBDAELCwsgCyQEIAAL+gIBAn8gAyAAQQhqIgUoAgBBmIABaiAEEG8aIAUoAgBBmIABaiIAKAIABEAgABDPASgCAEEvRwRAIAMgBBDIAQsLIAUoAgAiAEGQywNqLAAABEAgAyABQeS8A2oQmwEgBBB4GiADQQAgBBC6AyADIAQQyAEgBSgCACEACwJAIABBqIACahBZIgYEQCACIAYgAhBZIgFJBH8gBgUgAQtBAnRqIQIDQAJAAkACQAJAAkAgAigCAA4wAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIBAgsMAwsMAQsMBAsgAkEEaiECDAELCyADQQA2AgAPCwsCQAJAIABByMsEaigCACIBQdgARiAAQeCEA2ooAgBBBEZxBEBBACEBBSABQcUARgRAQQAhAQwCBUEAIQELCyAFKAIAQeCEA2ooAgBBAUYNACADIAIgBBB4GgwBCyADIAIQmwEgBBB4GgsgAygCABCTASEADwv4AQEDfyMEIQMjBEHwFmokBCADQSRqIQQgAyAAKAIAIgU2AgACQAJAAkACQCAFQQFrDgMAAQIDCyADIAAoAgQ2AgQMAgsgAyAAKAIEQX9zNgIEDAELIAQgACgCCBCmBCAEIANBBGoQqQQLIAIEQCADIAIQvwILIAMoAgAiAkUEQCADJARBAQ8LIAEoAgAiAEUEQCADJARBAQ8LIAJBAUYgAEEBRnFFBEAgAkECRiAAQQJGcUUEQCACQQNGIABBA0ZxRQRAIAMkBEEADwsgA0EEaiABQQRqQSAQa0UhACADJAQgAA8LCyADKAIEIAEoAgRGIQAgAyQEIAALcgEBfyAAKAIAIgNBAUYEQCAAQQRqIgMgAygCAEH//wNxIAEgAhDQBEH//wNxNgIAIAAoAgAhAwsgA0ECRgRAIABBBGoiAyADKAIAIAEgAhCZATYCACAAKAIAIQMLIANBA0cEQA8LIAAoAgggASACEKsEC74FAQJ/IABBCGoiBCgCACICRQRAQQBBzBYQXyICIgNrQT9xIANqIQMgAiADNgLwASACIANBgAFqNgL0ASACIANBoAFqNgL4ASACIANBqAFqNgL8ASACQQAgAkGIAmoiA2tBP3EgA2oiAzYC+AMgAiADQYABajYC/AMgAiADQaABajYCgAQgAiADQagBajYChAQgAkEAIAJBkARqIgNrQT9xIANqIgM2AoAGIAIgA0GAAWo2AoQGIAIgA0GgAWo2AogGIAIgA0GoAWo2AowGIAJBiAhqQQAgAkGYBmoiA2tBP3EgA2oiAzYCACACQYwIaiADQYABajYCACACQZAIaiADQaABajYCACAC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AUGg0ABqIAIEfyADBSAECzYAACABQZjQAGogAEHstwdqIgIoAgA2AABBACQFQQUgAEG4twdqEAUhAyMFIQRBACQFIARBAXFFBEAgAUGc0ABqIAM2AAAgAUGk0ABqIABBovcGai0AAEEwajYAACABQajQAGogAEGk9wZqKAIANgAAIAFBtNAAakEANgAAIAFBuNAAakEANgAAIAFBvNAAaiAAQey4B2ooAgBBCnY2AAACQAJAAkACQCAAQei3B2ooAgBBAWsOAwAAAQILIAFBwNAAakEBNgAADAILIAFBwNAAakECNgAAIAFBxNAAaiIDIAIpAAA3AAAgAyACKQAINwAIIAMgAikAEDcAECADIAIpABg3ABgMAQsgAUHA0ABqQQA2AAALIAFB5NAAaiAAQfi4B2ooAgAiAjYAACACBEAgAUHo0ABqKAAAIgIEQCABQezQAGooAAAiA0F/akGfjQZJBEBBACQFQRAgAiAAQfy4B2ogAxAHGiMFIQJBACQFIAJBAXENCQsLCyABQfDQAGogAEH8+AdqLQAANgAAQQAPCwsLCwsLC0GACBAYIQEjB0GACBBERwRAIAEQHgsgARAVIQECQCAAQajLBGooAgAiAEUEQAJAAkACQAJAAkACQAJAAkACQCABKAIADgwHCAABCAIDCAUECAYIC0ESIQAMCQtBDCEADAgLQRMhAAwHC0EPIQAMBgtBECEADAULQQshAAwEC0EYIQAMAwtBACEADAILQRUhAAsLEBYgAAvEAwEEfyMEIQIjBEFAayQEIAJBIGohAyAAKAIAIgRBAkYEQCADIABBBGoiBSgCACIEOgAAIAMgBEEIdjoAASADIARBEHY6AAIgAyAEQRh2OgADIAFBICADQQQgAhCnASAFQQA2AgAgBSACLQAfQRh0IAItAB5BEHQgAi0AHUEIdCACLQAbQRh0IAItABpBEHQgAi0AGUEIdCACLQAXQRh0IAItABZBEHQgAi0AFUEIdCACLQATQRh0IAItABJBEHQgAi0AEUEIdCACLQAPQRh0IAItAA5BEHQgAi0ADUEIdCACLQALQRh0IAItAApBEHQgAi0ACUEIdCACLQAHQRh0IAItAAZBEHQgAi0ABUEIdCACLQADQRh0IAItAAJBEHQgAi0AAUEIdCACLQAAcnJyIAItAARzc3NzIAItAAhzc3NzIAIt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IBwgAa18NwMAAkACQAJAAkACQAJAAkACQAJAAkAgFCgCACIBQQFrDnkAAQEIAggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAMFBwYECAtBACQFQRsgAEG4pgFqIgEQDCMFIQJBACQFIAJBAXENDSABIAcpAgA3AgAgASAHKQIINwIIIAEgBygCEDYCEEEAJAVBCiAEEAUhASMFIQJBACQFIAJBAXENDSAAQcymAWoiAyABOwEAQQAkBUEMIAQQBSECIwUhAUEAJAUgAUEBcQ0NIABB0KYBaiACNgIAIABBnbwDaiAAQcCmAWooAgAiAUEBcToAACAAQZy8A2ogAUEDdkEBcToAACAAQZ+8A2ogAUECdkEBcToAACAAQaO8A2ogAUEGdkEBcToAACAIIAFBB3ZBAXE6AAAgAEGgvANqIAIEf0EBBSADLgEAQQBHC0EBcToAACAAQdSmAWogAUEBdkEBcToAACAAQaG8A2ogAUEIdkEBcToAACAAQaK8A2ogAUEEdkEBcToAAAwICyAAQbCnAWohAyAAQfCtAmohAkEAJAVBCCABQQJGIg8EfyADBSACIgMLQQAQDSMFIQFBACQFIAFBAXFFBEAgAyAHKQIANwIAIAMgBykCCDcCCCADIAcoAhA2AhAgA0GIwQBqIANBCGoiCSgCACIBQQFxOgAAIANBicEAaiABQQF2QQFxOgAAIANBi8EAaiIGIAFBAnZBAXE6AAAgA0GQwQBqIAFBCnZBAXE6AAAgA0HgwQBqIA8Ef0EAIQUgAUEEdkEBcQUgAUEQcUEARyEFQQALOgAAIANB6sEAaiAFQQFxOgAAIANB4cEAaiIMIAFB4AFxQeABRiICOgAAIANB5MEAaiACBH9BAAVBgIAEIAFBBXZBB3F0CzYCACADQeLBAGoiGSABQQN2QQFxOgAAIANB48EAaiABQQt2QQFxOgAAQQAkBUEMIAQQBSEBIwUhAkEAJAUgAkEBcUUEQCADQRRqIhogATYCAEEAJAVBDCAEEAUhAiMFIQFBACQFAkAgAUEBcUUEQEEAJAVBCyAEEAUhASMFIQVBACQFIAVBAXFFBEAgA0EYaiIIIAE6AAAgA0HgwABqQQI2AgBBACQFQQwgBBAFIQEjBSEFQQAkBSAFQQFxDQIgA0HkwABqIAE2AgBBACQFQQwgBBAFIRsjBSEBQQAkBQJAIAFBAXFFBEBBACQFQQsgBBAFIQEjBSEFQQAkBSAFQQFxDQEgA0EZaiIRIAE6AABBACQFQQsgBBAFIQEjBSEFQQAkBSAFQQFxDQEgAyABQf8BcUHQAWo6ABpBACQFQQogBBAFIRIjBSEBQQAkBQJAIAFBAXFFBEBBACQFQQwgBBAFIQUjBSEBQQAkBSABQQFxDQEgA0EcaiITIAU2AgAgA0GMwQBqIhVBADYCACAGLAAABEAgFQJ/AkACQAJAAkAgESwAAEENaw4OAAMBAwMDAwIDAwMDAwIDC0EBDAMLQQIMAgtBAwwBC0EECzYCAAsgEkH//wNxIQEgA0HswQBqIhJBAjYCAAJAAkACQAJAIAgsAAAiBkEDaw4DAAEAAQtBASEIDAELIAZB/wFxQQZIBEBBACEIDAELIANB8MEAakEANgIADAELIBIgCDYCACADQfDBAGoiCEEANgIAIAZBA0YgBUGA4ANxQYDAAkZxRQ0AIAhBATYCACADQfTBAGpBADYCAAsgA0HowQBqIAVBAEggD0EBc3E6AAAgA0HpwQBqIAkoAgBBgAJxIgVBCHY6AAACQCAFBEBBACQFQQwgBBAFIQUjBSEGQQAkBQJAIAZBAXFFBEBBACQFQQwgBBAFIQYjBSEIQQAkBSAIQQFxDQEgBiACcSEIDAMLCxAXIQAMGgVBACEFQQAhBiACIQgLCyADQYrBAGogCEF/RiIIOgAAIANByMAAaiIVIAWtQiCGIBooAgCthDcDACAGrUIghiACrYQhHCADQdDAAGogCAR+Qv/////3/////wAFIBwLNwMAQQAkBUESIAQgDSABQf8/SQR/IAEFQf8/CyICEAcaIwUhBUEAJAUCfwJAIAVBAXENACANIAJqQQA6AAACQCAPBEACQAJAIAkoAgBBgARxBEBBACQFQR0gCxAMIwUhAkEAJAUCQCACQQFxRQRAIA0QbkEBaiECQQAkBUEEIAsgDSANIAJqIAEgAmsgA0EgaiIBQYAQEBEjBSECQQAkBSACQQFxDQEgASgCAEUNAwwECwsQFwwGBSADQSBqIgFBADYCAAsLQQAkBUEEIA0gAUGAEEEBEA8jBSECQQAkBSACQQFxDQMLIABBrPMAaiIFKAIAQYyFA2ooAgAiAkEBRgRAQQAkBUENIAEQBRojBSECQQAkBSACQQFxDQMgBSgCAEGMhQNqKAIAIQILIAJBAkYEQEEAJAVBDiABEAUaIwUhAkEAJAUgAkEBcQ0DCwJAIABBmLwDaiIGKAIAQQJGBEAgES0AAEEUTg0BIBMoAgBBEHFFDQEgDEEBOgAACwsgEigCACIFQQJGBH8gEyAMLAAABH9BEAVBIAs2AgAgASECQQIFIAEhAiAFCyEBA0ACQAJAAkACQAJAAkAgAigCAA5dAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMBAwsMBwsgBigCAEEDRw0CIAENAyACQd8ANgIAQQAhAQwDCwwBCwwBCyACQS82AgALIAJBBGohAgwACwAFQQAkBUERIA0gA0EgaiIIQYAQEAcaIwUhAkEAJAUgAkEBcQ0CAkACQCADKAIMIAFrQVhqIAkoAgBBB3ZBCHFBCHNqIgJBAEwNACADQaDAAGohBiADQajAAGoiDygCACEFIANBpMAAaiIMIAI2AgAgBSACSQRAIANBrMAAaigCACIBQQBHIAIgAUtxBH9BACQFIBAgATYCAEECQaz1AkHYGyAQEA4jBSEBQQAkBSABQQFxDQNBACQFQRRBrPUCEAwjBSEBQQAkBSABQQFxDQMgDygCACEFIAwoAgAFIAILIQEgBigCACABIAVBIGogBUECdmoiBUsEfyABBSAFIgELEFciBUUEQEEAJAVBFEGs9QIQDCMFIQxBACQFIAxBAXENAwsgBiAFNgIAIA8gATYCAAsgBigCACEBQQAkBUESIAQgASACEAcaIwUhAUEAJAUgAUEBcQ0BQQAkBUEGIAhBrA4QBiEBIwUhAkEAJAUgAkEBcQ0BIAENACAAQbDzAGoiAiAGKAIAIgEtAAlBCHQgAS0ACHIgAS0ACkEQdHIgAS0AC0EYdHKtQgmGNwMAIAAoAgAoAhQhAUEAJAUgASAAEE6tIwetQiCGhCEcIwUhAUEAJAUgAUEBcQ0BIAIpAwAhHUEAJAVBASAdpyAdQiCIpyAcpyAcQiCIpxBNIQUjBSEBQQAkBSABQQFxDQEgAEG48wBqIgEgBTYCACACKQMAIBxCyAF/fCEdQQAkBUEBIB2nIB1CIIinIBynIBxCIIinEE0hAiMFIQVBACQFIAVBAXENASACIAEoAgAiAkwNACABIAJBAWo2AgALQQAkBUEGIAhBjA4QBiEBIwUhAkEAJAUgAkEBcQ0AIAENAiAAQZ68A2pBAToAAAwCCxAXDAMLAAsgCSgCAEGACHEEQEEAJAVBEiAEIANBkcEAakEIEAcaIwUhAUEAJAUgAUEBcQ0BC0EAJAVBCSADQbDAAGogGxANIwUhAUEAJAUgAUEBcQ0AAkAgCSgCAEGAIHEEQEEAJAVBCiAEEAUhASMFIQJBACQFIAJBAXEEQBAXDAQLIABB4OcBaiEJIABB6OcBaiEGIABB8OcBaiEIIAtBGGohAiALQRRqIQUCQCABQf//A3EiD0EMdiIBQQhxBEBBACQFQQsgCSALEA0jBSEMQQAkBSAMQQFxDQEgAUEEcQRAIAUgBSgCAEEBajYCAAsgAkEANgIAIAFBA3EiDARAIAxBA3MhEUEAIQEDQEEAJAVBCyAEEAUhEyMFIRJBACQFIBJBAXENAyACIAIoAgAgE0H/AXEgESABakEDdHRyNgIAIAFBAWoiASAMSA0ACwtBACQFQQwgCSALEA0jBSEBQQAkBSABQQFxDQELAkAgD0EIdiIBQQhxBEBBACQFQQwgBBAFIQkjBSEMQQAkBSAMQQFxDQFBACQFQQkgBiAJEA0jBSEJQQAkBSAJQQFxDQFBACQFQQsgBiALEA0jBSEJQQAkBSAJQQFxDQIgAUEEcQRAIAUgBSgCAEEBajYCAAsgAkEANgIAIAFBA3EiCQRAIAlBA3MhDEEAIQEDQEEAJAVBCyAEEAUhESMFIRNBACQFIBNBAXENBCACIAIoAgAgEUH/AXEgDCABakEDdHRyNgIAIAFBAWoiASAJSA0ACwtBACQFQQwgBiALEA0jBSEBQQAkBSABQQFxDQILIA9BBHYiAUEIcUUNA0EAJAVBDCAEEAUhBiMFIQlBACQFIAlBAXENAEEAJAVBCSAIIAYQDSMFIQZBACQFIAZBAXENAEEAJAVBCyAIIAsQDSMFIQZBACQFIAZBAXENASABQQRxBEAgBSAFKAIAQQFqNgIACyACQQA2AgAgAUEDcSIFBEAgBUEDcyEGQQAhAQNAQQAkBUELIAQQBSEJIwUhD0EAJAUgD0EBcQ0DIAIgAigCACAJQf8BcSAGIAFqQQN0dHI2AgAgAUEBaiIBIAVIDQALC0EAJAVBDCAIIAsQDSMFIQFBACQFIAFBAXENAQwDCxAXDAQLEBcMAwsLIAogCikDACAVKQMAfDcDACAZLAAAQQBHIQFBACQFQQwgBCABEAYhASMFIQJBACQFAkAgAkEBcUUEQCADKAIAIAFB//8DcUcEQCAAQay8A2pBAToAAEEAJAVBCkGs9QJBARANIwUhAUEAJAUgAUEBcQ0CIBYNFSAOQQA2AkQgDkEaNgJIIA4gAEEYajYCACAOQUBrQQI2AgAgDiADQSBqNgIEQQAkBSMFIQFBACQFIAFBAXENAgsMFAsLEBcMAQsQFwshAAwYCwsQFyEADBYLCxAXIQAMFAsLCxAXIQAMEQsLEBchAAwPCyAAQbCtAmoiASAHKQIANwIAIAEgBykCCDcCCCABIAcoAhA2AhAgAEHMrQJqIABBuK0CaigCACIBQQFxOgAAIABBza0CaiABQQF2QQFxIgI6AAAgAEHOrQJqIAFBAnZBAXE6AAAgAEHPrQJqIgMgAUEDdkEBcSIBOgAAIAJB/wFxBEBBACQFQQwgBBAFIQEjBSECQQAkBSACQQFxDQwgAEHErQJqIAE2AgAgAywAACEBCyABQf8BcQRAQQAkBUEKIAQQBSEBIwUhAkEAJAUgAkEBcQ0MIABByK0CaiABQf//A3EiATYCACAAQcC8A2ogATYCAAsMBgsgAEHwswNqIgEgBykCADcCACABIAcpAgg3AgggASAHKAIQNgIQQQAkBUEKIAQQBSEBIwUhAkEAJAUgAkEBcQ0KIABBhLQDaiABOwEAQQAkBUELIAQQBSEBIwUhAkEAJAUgAkEBcQ0KIABBhrQDaiABOgAAQQAkBUELIAQQBSEBIwUhAkEAJAUgAkEBcQ0KIABBh7QDaiABOgAAQQAkBUEKIAQQBSEBIwUhAkEAJAUgAkEBcQ0KIABBiLQDaiABOwEADAULIABB0LQDaiIBIAcpAgA3AgAgASAHKQIINwIIIAEgBygCEDYCEEEAJAVBDCAEEAUhASMFIQJBACQFIAJBAXENCSAAQeS0A2ogATYCAEEAJAVBCiAEEAUhASMFIQJBACQFIAJBAXENCSAAQei0A2ogATsBAEEAJAVBCiAEEAUhASMFIQJBACQFIAJBAXENCSAAQeq0A2ogATsBAAwECyAAQbS0A2oiASAHKQIANwIAIAEgBykCCDcCCCABIAcoAhA2AhBBACQFQQsgBBAFIQEjBSECQQAkBSACQQFxDQggAEHItANqIAE6AABBACQFQQsgBBAFIQEjBSECQQAkBSACQQFxDQggAEHJtANqIAE6AABBACQFQQsgBBAFIQEjBSECQQAkBSACQQFxDQggAEHKtANqIAE6AABBACQFQQwgBBAFIQEjBSECQQAkBSACQQFxDQggAEHMtANqIAE2AgAMAwsgAEGMtANqIgEgBykCADcCACABIAcpAgg3AgggASAHKAIQNgIQQQAkBUEMIAQQBSEBIwUhAkEAJAUgAkEBcQ0HIABBoLQDaiICIAE2AgBBACQFQQsgBBAFIQEjBSEDQQAkBSADQQFxDQcgAEGktANqIAE6AABBACQFQQogBBAFIQEjBSEDQQAkBSADQQFxDQcgAEGmtANqIgMgATsBAEEAJAVBDCAEEAUhASMFIQVBACQFIAVBAXENByAAQai0A2ogATYCAEEAJAVBEiAEIABBrLQDakEIEAcaIwUhAUEAJAUgAUEBcQ0HIAogCikDACACKAIArXw3AwAgAEGw8wBqIAMvAQBBCXStNwMADAILIABB0K0CaiIBIAcpAgA3AgAgASAHKQIINwIIIAEgBygCEDYCEEEAJAVBDCAEEAUhAiMFIQNBACQFIANBAXENBiAAQeStAmogAjYCACAKIAopAwAgAq18NwMAQQAkBUEKIAQQBSECIwUhA0EAJAUgA0EBcQ0GIABB6K0CaiIDIAI7AQBBACQFQQsgBBAFIQIjBSEFQQAkBSAFQQFxDQYgAEHqrQJqIAI6AAACQAJAAkACQAJAIAMuAQBBgAJrDgYCAAECAgMECyAAQey0A2oiAiABKQIANwIAIAIgASkCCDcCCCACIAEpAhA3AhAgAiABLgEYOwEYIAIgASwAGjoAGkEAJAVBCiAEEAUhASMFIQJBACQFIAJBAXENCiAAQYi1A2oiAiABOwEAQQAkBUEKIAQQBSEFIwUhAUEAJAUgAUEBcQ0KIABBirUDaiIDIAU7AQAgAi4BACIBQf//A3FB/wFKBEAgAkH/ATsBAEH/ASEBCyAFQf//A3FB/wFKBEAgA0H/ATsBAAtBACQFQRIgBCAAQYy1A2ogAUH//wNxEAcaIwUhAUEAJAUgAUEBcQ0KIAMvAQAhAUEAJAVBEiAEIABBjLcDaiABEAcaIwUhAUEAJAUgAUEBcQ0KIABBjLUDaiACLwEAakEAOgAAIABBjLcDaiADLwEAakEAOgAADAULIABBjLkDaiICIAEpAgA3AgAgAiABKQIINwIIIAIgASkCEDcCECACIAEuARg7ARggAiABLAAaOgAaQQAkBUEMIAQQBSEBIwUhAkEAJAUgAkEBcQ0JIABBqLkDaiABNgIAQQAkBUEMIAQQBSEBIwUhAkEAJAUgAkEBcQ0JIABBrLkDaiABNgIADAQLIABBsLkDaiICIAEpAgA3AgAgAiABKQIINwIIIAIgASkCEDcCECACIAEuARg7ARggAiABLAAaOgAaQQAkBUEMIAQQBSEBIwUhAkEAJAUgAkEBcQ0IIABBzLkDaiABNgIAQQAkBUELIAQQBSEBIwUhAkEAJAUgAkEBcQ0IIABB0LkDaiABOgAAQQAkBUELIAQQBSEBIwUhAkEAJAUgAkEBcQ0IIABB0bkDaiABOgAAQQAkBUEMIAQQBSEBIwUhAkEAJAUgAkEBcQ0IIABB1LkDaiABNgIADAMLIABB2LkDaiICIAEpAgA3AgAgAiABKQIINwIIIAIgASkCEDcCECACIAEuARg7ARggAiABLAAaOgAaQQAkBUEMIAQQBSEBIwUhAkEAJAUgAkEBcQ0HIABB9LkDaiABNgIAQQAkBUELIAQQBSEBIwUhAkEAJAUgAkEBcQ0HIABB+LkDaiABOgAAQQAkBUELIAQQBSEBIwUhAkEAJAUgAkEBcQ0HIABB+bkDaiABOgAAQQAkBUEMIAQQBSEBIwUhAkEAJAUgAkEBcQ0HIABB/LkDaiABNgIAQQAkBUEKIAQQBSEBIwUhAkEAJAUgAkEBcQ0HIABBgLoDaiICIAFB//8DcUGDAkgEfyABBUGDAiIBCzsBAEEAJAVBEiAEIABBgroDaiABQf//A3EQBxojBSEBQQAkBSABQQFxDQcgAEGCugNqIAIvAQBqQQA6AAAMAgsMAQsgBSgCAEGAgAJxBEBBACQFQQwgBBAFIQEjBSECQQAkBSACQQFxDQYgCiAKKQMAIAGtfDcDAAsLQQAkBUEMIARBABAGIQEjBSECQQAkBSACQQFxRQRAAkAgBygCACABQf//A3FHBEACQAJAAkAgFCgCAEEFaw51AQICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgIAAgsMAwsgAEHOrQJqLAAABEAgACgCACgCFCEBQQAkBSABIAAQTq0jB61CIIaEIRwjBSEBQQAkBSABQQFxBEAQFyEADA0LIAAoAgAoAhQhAUEAJAUgASAAEE6tIwetQiCGhCEdIwUhAUEAJAUCQCABQQFxRQRAIAAoAgAoAhAhAUEAJAUgASAAIB1CeXwiHacgHUIgiKdBABBQIwUhAUEAJAUgAUEBcQ0BQQAkBUEIIAAQBSEBIwUhAkEAJAUgAkEBcQ0BQQAkBUEIIAAQBSECIwUhA0EAJAUgA0EBcQ0BQQAkBUEIIAAQBSEDIwUhBUEAJAUgBUEBcQ0BQQAkBUEIIAAQBSEFIwUhBkEAJAUgBkEBcQ0BQQAkBUEIIAAQBSEGIwUhCEEAJAUgCEEBcQ0BQQAkBUEIIAAQBSEIIwUhB0EAJAUgB0EBcQ0BQQAkBUEIIAAQBSEHIwUhDkEAJAUgDkEBcQ0BIAAoAgAoAhAhDkEAJAUgDiAAIBynIBxCIIinQQAQUCMFIQ5BACQFIA5BAXEEQEEAEBgQWgUgByAIIAYgBSADIAIgAXJycnJyckH/AXFFDQYMBAsLCxAXIQEgACgCACgCECECQQAkBSACIAAgHKcgHEIgiKdBABBQIwUhAkEAJAUgAkEBcUUEQCABIQAMDQtBABAYEFoLCyAAQay8A2pBAToAAEEAJAVBCkGs9QJBAxANIwUhAUEAJAUgAUEBcUUEQCAWRQ0CIAtBADYCRCALQQQ2AkggCyAAQRhqIgE2AgAgC0FAa0ECNgIAIAsgATYCBEEAJAUjBSEBQQAkBSABQQFxRQRAIABBrbwDakEBOgAAQQAhAAwLCwsQFyEADAoLCyAKKQMAIBgpAwBVBEAgFygCACEADAgLIA1BADYCRCANQRg2AkggDUFAa0EBNgIAIA0gAEEYajYCAEEAJAUjBSEBQQAkBSABQQFxRQRAIABBrLwDakEBOgAAQQAkBUEKQaz1AkEDEA0jBSEAQQAkBSAAQQFxRQRAQQAhAAwJCwsLEBchAAwHCwsLCwsQFyEADAILEBchAAwBCyAEKAIAIgFFBEAgECQEIAAPCyABEFIgECQEIAAPCyAEKAIAIgFFBEAgABAeCyABEFIgABAeQQALlAsCCn8CfiMEIQMjBEGgEGokBCADQSBqIQIgAyAAELgBAkACQAJAIABBiLwDaiIHKQMAIABBqLwDaigCAK1VBH9BACQFQQogA0EVEAYaIwUhAUEAJAUgAUEBcQ0BQQAkBUEIIABBsKcBakEAEA0jBSEBQQAkBSABQQFxDQEgAEG0pwFqQQI2AgBBACQFQQwgAxAFIQEjBSEEQQAkBSAEQQFxDQEgAEHEpwFqIgUgATYCAEEAJAVBDCADEAUhASMFIQRBACQFIARBAXENASAAQYDoAWogAa03AwAgAEGQ6AFqQQE2AgBBACQFQQogAxAFIQEjBSEEQQAkBSAEQQFxDQEgAEGU6AFqIAFB//8DcTYCAEEAJAVBCiADEAUhASMFIQRBACQFIARBAXENASAAQbynAWoiCCABQf//A3E2AgBBACQFQQwgAxAFIQkjBSEBQQAkBSABQQFxRQRAQQAkBUELIAMQBSEBIwUhBEEAJAUgBEEBcUUEQCAAQcynAWogAUH/AXE2AgBBACQFQQsgAxAFIQEjBSEEQQAkBSAEQQFxRQRAIABBuKcBaiIEIAFB/wFxQYCAAnI2AgBBACQFQQsgAxAFIQEjBSEGQQAkBSAGQQFxRQRAIABByacBaiABQf8BcUECRgR/QQ0FQQoLOgAAQQAkBUELIAMQBSEBIwUhBkEAJAUgBkEBcUUEQCABQf8BcSEBQQAkBUELIAMQBSEGIwUhCkEAJAUgCkEBcUUEQCAAQcqnAWogBjoAACAAQbjoAWogBCgCACIEQQFxOgAAIABBuegBaiAEQQF2QQFxOgAAIABBu+gBaiAEQQJ2QQFxIgQ6AAAgAEG86AFqIAQ2AgAgAEH45wFqIgQgBSgCAK03AwAgAEGU6QFqQYCABDYCAEEAJAVBCSAAQeDnAWogCRANIwUhBUEAJAUgBUEBcUUEQEEAJAVBCiADIAEQBhojBSEFQQAkBSAFQQFxRQRAQQAkBUESIAMgAiABEAcaIwUhBUEAJAUCQCAFQQFxRQRAIAIgAWpBADoAAEEAJAVBCCACIAJBgBAQDiMFIQFBACQFIAFBAXENAUEAJAVBESACIABB0KcBaiIBQYAQEAcaIwUhAkEAJAUgAkEBcQ0BIABBrPMAaiIFKAIAQYyFA2ooAgAiAkEBRgRAQQAkBUENIAEQBRojBSECQQAkBSACQQFxDQIgBSgCAEGMhQNqKAIAIQILIAJBAkYEQEEAJAVBDiABEAUaIwUhAkEAJAUgAkEBcQ0CCyADKAIUIgIEQCAAQZC8A2ogBykDACIMIAgoAgCtfCAEKQMAfCILNwMABSAAQZC8A2opAwAhCyAHKQMAIQwLIABBzPMAakECNgIAIAIhAAwMCwsQFyEADAsLCwsLEBchAAwHCwsLCxAXBUEAJAVBCiADQQcQBhojBSEBQQAkBSABQQFxDQFBACQFQRsgAEG4pgFqEAwjBSEBQQAkBSABQQFxDQFBACQFQRIgAyACQQQQBxojBSECQQAkBSACQQFxRQRAQQAkBUEKIAMQBSECIwUhAUEAJAUgAUEBcUUEQEEAJAVBCyADEAUhASMFIQRBACQFIARBAXFFBEAgAEGQvANqIAcpAwAiDCACQf//A3GtfCILNwMAIABBzPMAakEBNgIAIABBnbwDaiABQf8BcSICQQFxOgAAIABBnLwDaiACQQN2QQFxOgAAIABBn7wDaiACQQJ2QQFxOgAAIABB1KYBaiACQQF2QQFxOgAAIABB1aYBaiACQQR2QQFxOgAAIAMoAhQhAAwFCwsLEBcLIQAMAgsQFyEADAELIAsgDFcEQEEAIQALIAMoAgAiAkUEQCADJAQgAA8LIAIQUiADJAQgAA8LIAMoAgAiA0UEQCAAEB4LIAMQUiAAEB5BAAsiACAAIABBkLwDaikDAEEAIAAoAgAoAhBBA3FBuAJqEQIAC1wBAX8jBCECIwRB0ABqJAQgACABEPEBBEAgAiQEDwsgAEGtvANqLAAARQRAIAJBADYCRCACQTg2AkggAkFAa0EBNgIAIAIgAEEYajYCAAtBrPUCQQIQpAEgAiQEC6QGAQd/IAAQ0gEgAEH0DTYCAEEAJAVBGCAAQZzAAGoiBBAMIwUhAkEAJAUgAkEBcQRAEBchAiAAEHAgAhAeC0EAJAVBFiAAQfDxAGoiBRAMIwUhAkEAJAUgAkEBcQRAEBchAgUgAEHA8wBqIgZCADcDAEEAJAVBGSAAQdjzAGoiBxAMIwUhAkEAJAUCQCACQQFxBEAQFyECBSAAQdDnAWoiAkIANwIAIAJCADcCCCACQgA3AhAgAkIANwIYIAJCADcCICAAQZDuAmoiAkIANwIAIAJCADcCCCACQgA3AhAgAkIANwIYIAJCADcCICAAQazzAGoiCEEANgIAIABBqPMAaiABRSICOgAAAkAgAgRAQQAkBUEEQcDLBBAFIQMjBSEBQQAkBSABQQFxBEAQFyECBUEAJAVBGiADEAwjBSEBQQAkBSABQQFxRQRAIAMhAQwDCxAXIQIgAxBSIABBkO4CaigCACIDBEAgAxBSCwsgAEHQ5wFqKAIAIgMEQCADEFILIAcQtQIMAwsLIAggATYCACAAIAFBnYUDaiwAADoAFSAAQZi8A2pBAjYCACAAQai8A2pBADYCACAGQgA3AwAgAEGtvANqQQA6AAAgAEGsvANqQQA6AAAgAEHI8wBqQQA2AgAgAEGIvANqIgFCADcDACABQgA3AwggAEGcvANqIgFCADcCACABQQA6AAggAEGw8wBqQn83AwAgAEG48wBqQX82AgAgAEGwrQJqIgFCADcDACABQgA3AwggAUIANwMQIAFCADcDGCAAQcC8A2pBADYCACAAQeS8A2pBADYCACAAQb68A2pBADoAACAAQdDzAGpBADoAACAAQbimAWoiAUIANwMAIAFCADcDCCABQgA3AxAgAUIANwMYIAFCADcDICABQgA3AyggAUIANwMwIAFCADcDOCABQUBrQgA3AwAgAUIANwNIIAFCADcDUCABQgA3A1ggAUIANwNgIAFCADcDaCABQQA2AnAgAEHIvANqIgBCADcDACAAQgA3AwggAEIANwMQIABBADoAGA8LCyAFEIQBCyAEEI4BIAAQcCACEB4LjwgBC38jBCECIwRBMGokBCACQRBqIQogAkEIaiEHIAIiCUEYaiIFQgA3AgAgBUIANwIIQQAkBUEUIAAgBUEAEAchAiMFIQNBACQFAkAgA0EBcUUEQCACBH8gBUEEaiIGKAIAIgtBAWohAiAGIAI2AgAgAiAFQQhqIggoAgAiBEsEfyAFKAIMIgNBAEcgAiADS3EEf0EAJAUgCSADNgIAQQJBrPUCQdgbIAkQDiMFIQNBACQFIANBAXENBEEAJAVBFEGs9QIQDCMFIQNBACQFIANBAXENBCAIKAIA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IABBwJgBaiIaQgA3AwAgAEHoAGoiA0IANwMAIANCADcDCCADQgA3AxAgA0EANgIYIABB8ABqIgZBfzYCACABRQRAIABBwK4CakEANgIAIABBxK4CakEANgIAIABBuK4CakEANgIAIABBvK4CakEBNgIAIABByK4CakEAQfACEFQaIABBhK8BakEAQbT/ABBUGiAAQczMA2pBADoAACAAQbTJA2pBAEGUAxBUGiAAQbDJA2pBAjYCACAAQcjMA2pBADYCAAsgACABEIMBIAMoAgAiAiAFKAIAIghrIgFBAEgNASAGIABB+ABqIhIoAgAgCGsgBigCAGo2AgAgCEGAgAFKBEAgAUEASgRAIAAoAhAiAiACIAhqIAEQXRoLIAVBADYCACADIAE2AgAFIAIhAQsgAUGAgAJGBEBBACEBQYCAAiECBSAAKAIAIAAoAhAgAWpBgIACIAFrEF4hASADKAIAIgggAWohAiABQQBKBEAgAyACNgIABSAIIQILCyAAQewAaiIOIAJBYmoiAjYCACASIAUoAgAiCDYCACAIQX9qIAYoAgAiDGohCCAMQX9HBEAgDiACIAhIBH8gAgUgCAs2AgALIAFBf0YNASAAIABBBGoiDCAAQfAAaiITEKQCRQ0BIAAgDCATIABBhAFqIhsQowJFDQECQCADIQggBSEXIAYhGAsLIAQhDyAAQdDNA2ohECAAQeAAaiEJIABBBGohCiAAQaCWAWohICAAQRBqIRQgAEGIAmohISAAQaiYAWohFSAAQaSWAWohIiAAQaiWAWohDSAAQfQfaiEjIABBzABqIRwgAEHQAGohJCAAQcgAaiEdIABBxABqIRYgAEHYAGohGSAAQeA9aiElIABB3DxqISYgAEHwHmohJyAAQczbAGohKCAAQcjaAGohKSAAQYQBaiEqIABBsJgBaiErIABB8ABqISwgAEH0AGohLSAAQYABaiEuAkACQAJAA0ACQCAJIAkoAgAgECgCACIEcSICNgIAIAooAgAiASAOKAIATgRAA0ACQCABICwoAgAiAyASKAIAIgVqIgJIBEAgASACQX9qRw0BIAcoAgAgLSgCAEgNAQsgLiwAAA0DIAAgDCATEKQCRQ0GIAAgDCATIBsQowJFDQYgCigCACEBDAELCyAIKAIAIgQgAWsiAkEASA0BIBggBSABayADajYCACAB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NwIIIAJCADcCECACQgA3AhggAkEANgIgIABBoJYBaiAAQczNA2ooAgAiAkGAgIACSQR/IAIFQYCAgAILIABB0M0DaigCAHE2AgALIABBADYCOCAAQQhqIghBADYCACAAQQRqIgdBADYCACAAQcCYAWoiGkIANwMAIABB6ABqIgJCADcDACACQgA3AwggAkIANwMQIAJBADYCGCAAQX82AnAgAUUEQCAAQcCuAmpBADYCACAAQcSuAmpBADYCACAAQbiuAmpBADYCACAAQbyuAmpBATYCACAAQciuAmpBAEHwAhBUGiAAQYSvAWpBAEG0/wAQVBogAEHMzANqQQA6AAAgAEG0yQNqQQBBlAMQVBogAEGwyQNqQQI2AgAgAEHIzANqQQA2AgALIAAgARCDASACKAIAIgogBygCACIJayIDQQBIBEAPCyAJQYCAAUoEQCADQQBKBEAgACgCECIKIAogCWogAxBdGgsgB0EANgIAIAIgAzYCAAUgCiEDCyAAKAIAIABBEGoiDigCACADakGAgAIgA2sQXiEDIAIoAgAiCSADaiEKIANBAEoEQCACIAo2AgAgACAKQWJqNgJsBSAAIAlBYmo2AmwgA0F/RgRADwsLIAEEQCAAQczMA2osAAAEQCACIQkgACEKDAMLCyAAENsBBEAgAiEJIAAhCgUPCwsLIABB0M0DaiERIABB4ABqIQsgAEHsAGohFyAAQeQAaiEfIABByMwDaiESIABBwLECaiEMIABBsMkDaiEgIABBpJYBaiETIABBiAJqISEgAEH0H2ohIiAAQcwAaiEUIABB0ABqIRsgAEHIAGohFSAAQcQAaiEPIABB2ABqIRYgAEG8sQJqIRggAEG4sQJqIRkgAEHgPWohIyAAQdw8aiEkIABB8B5qISUgAEHM2wBqISYgAEHI2gBqIScgAEHMzQNqISggAEHMzANqIRwgAEGEAWohKSAAQbCYAWohKkEAIQECQAJAAkACQAJAAkACQAJAA0ACQCALIAsoAgAgESgCAHE2AgAgBygCACIEIBcoAgBKBEAgCSgCACIDIARrIgJBAEgNASAEQYCAAUoEQCACQQBKBEAgDigCACIDIAMgBGogAhBdGgsgB0EANgIAIAkgAjYCAAUgAyECCyAKKAIAIA4oAgAgAmpBgIACIAJrEF4hAiAJKAIAIgQgAmohAyAC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wQBqEJsECwwBCyABQcytAmosAABFDQEgASAAQRBqQQAgDRC1AQRAIAEgAUGIvANqKQMAQQAgASgCACgCEEEDcUG4AmoRAgAgBiQEQQEPBUGs9QJBARBkDAILAAsgASABQZC8A2opAwBBACABKAIAKAIQQQNxQbgCahECACAGJARBAQ8LIAYkBEEAC5oBAQJ/IABCADcDACAAQRBqIgMQtwIgACABNgIIIABBADYC3AEgAEHgwQBqQQA2AgAgAEEANgLMAUEAJAVBBEHYzQMQBSEBIwUhAkEAJAUgAkEBcQRAEBchAiADEIQBIAIQHgtBACQFQQcgASADEA0jBSECQQAkBSACQQFxRQRAIAAgATYCyAEPCxAXIQAgARBSIAMQhAEgABAeC4IDAgd/AX4gAEGQMmohBkGAgAQgAEGUMmoiAygCACICa0GAAkkEQCAAKAIQIgUgBSACaiAGKAIAIAJrIgIQUxogA0EANgIAIAYgAjYCACAAEOIBGiADKAIAIQILIAJBB2ogBigCAEsEQEEADwsgASAAQRBqIgcoAgAgAmpBBxDpASADIAMoAgBBB2o2AgAgARCmASEIIAFBBBC6AiICQX1qIAEQYSIJp2ohBCAJQgBRIAJFIARBAEhycgRAIABB6DFqQQA6AABBAA8LIAYoAgAgAygCACICayEFAkAgBEEASgRAIAEgBygCACACaiAFIARJBH8gBQUgBAsiAhDpASADIAMoAgAgAmo2AgAgBCACayICQQBKBEADQAJAIANBADYCACAGQQA2AgAgABDiAUUEQEEAIQAMAQsgASAHKAIAIAMoAgBqIAUgAkkEfyAFBSACCyIEEOkBIAMgAygCACAEajYCACACIARrIgJBAEoNAQwECwtBAA8LCwsgCCABELgCRgtOAQF/AkACQAJAIAJBmLwDaigCAEECaw4CAAECCyMEIQQjBEGAEGokBCACQcynAWooAgAaIAQkBEEADwsgACADIAJBsKcBahCdBA8LQQALRwAgAEHJiQNqLAAABEAPCyAAQZCFA2osAABFBEAPCyABQZi8A2ooAgBBAkcEQA8LIAFBkK4CakHMERBzBEAPCyABIAIQoQQLOAAgAEHJiQNqLAAABEAPCyABQeitAmouAQBBgQJHBEAPCyAAQZCFA2osAABFBEAPCyABIAIQogQLrQEBAn8jBCED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IABBpA5qIAJBgAFqNgIAIABBqA5qIAJBoAFqNgIAIABBrA5qIAJBqAFqNgIAIABBqBBqQQAgAEG4DmoiAmtBP3EgAmoiAjYCACAAQawQaiACQYABajYCACAAQbAQaiACQaABajYCACAAQbQQaiACQagBajYCAAUgAiABKALwAUGwARBTGiAAIAEoAoACNgKAAiAAIAEsAIQCOgCEAiAAQQAgAEGIAmoiAmtBP3EgAmoiAjYC+AMgACACQYABajYC/AMgACACQaABajYCgAQgACACQagBajYChAQgAiABKAL4A0GwARBTGiAAIAEoAogENgKIBCAAIAEsAIwEOgCMBCAAQQAgAEGQBGoiAmtBP3EgAmoiAjYCgAYgACACQYABajYChAYgACACQaABajYCiAYgACACQagBajYCjAYgAiABKAKABkGwARBTGiAAIAEoApAGNgKQBiAAIAEsAJQGOgCUBiAAQYgIakEAIABBmAZqIgJrQT9xIAJqIgI2AgAgAEGMCGogAkGAAWo2AgAgAEGQCGogAkGgAWo2AgAgAEGUCGogAkGoAWo2AgAgAiABQYgIaigCAEGwARBTGiAAQZgIaiABQZgIaigCADYCACAAQZwIaiABQZwIaiwAADoAACAAQZAKakEAIABBoAhqIgJrQT9xIAJqIgI2AgAgAEGUCmogAkGAAWo2AgAgAEGYCmogAkGgAWo2AgAgAEGcCmogAkGoAWo2AgAgAiABQZAKaigCAEGwARBTGiAAQaAKaiABQaAKaigCADYCACAAQaQKaiABQaQKaiwAADoAACAAQZgMakEAIABBqApqIgJrQT9xIAJqIgI2AgAgAEGcDGogAkGAAWo2AgAgAEGgDGogAkGgAWo2AgAgAEGkDGogAkGoAWo2AgAgAiABQZgMaigCAEGwARBTGiAAQagMaiABQagMaigCADYCACAAQawMaiABQawMaiwAADoAACAAQaAOakEAIABBsAxqIgJrQT9xIAJqIgI2AgAgAEGkDmogAkGAAWo2AgAgAEGoDmogAkGgAWo2AgAgAEGsDmogAkGoAWo2AgAgAiABQaAOaigCAEGwARBTGiAAQbAOaiABQbAOaigCADYCACAAQbQOaiABQbQOaiwAADoAACAAQagQakEAIABBuA5qIgJrQT9xIAJqIgI2AgAgAEGsEGogAkGAAWo2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ABggACACKQAgNwAgIAAgAikAKDcAKCAAIAIpADA3ADAgACACKQA4NwA4IAQgBCgCAEFAaiIANgIAIAMgBmohAyAFIAZrIgUNAAsMAQsgAiADIAUQUxogBCAEKAIAIAVqIgA2AgALQSAhBSAKQYABaiEDAkACQANAIAcoAgAgAGohAiAFQYABIABrIgZNDQEgAiADIAYQUxogBCAEKAIAIAZqNgIAIAkoAgAiACgCACECIAAgAkFAazYCACAAQQRqIgAgACgCACACQb9/S2o2AgAgCCAHKAIAEG0gBygCACIAQUBrIQIgACACKQAANwAAIAAgAikACDcACCAAIAIpABA3ABAgACACKQAYNwAYIAAgAikAIDcAICAAIAIpACg3ACggACACKQAwNwAwIAAgAikAODcAOCAEIAQoAgBBQGoiADYCACADIAZqIQMgBSAGayIFDQALDAELIAIgAyAFEFMaIAQgBCgCACAFaiIANgIAC0EgIQUgCkGgAWohAwJAAkADQCAHKAIAIABqIQIgBUGAASAAayIGTQ0BIAIgAyAGEFMaIAQgBCgCACAGajYCACAJKAIAIgAoAgAhAiAAIAJBQGs2AgAgAEEEaiIAIAAoAgAgAkG/f0tqNgIAIAggBygCABBtIAcoAgAiAEFAayECIAAgAikAADcAACAAIAIpAAg3AAggACACKQAQNwAQIAAgAikAGDcAGCAAIAIpACA3ACAgACACKQAoNwAoIAAgAikAMDcAMCAAIAIpADg3ADggBCAEKAIAQUBqIgA2AgAgAyAGaiEDIAUgBmsiBQ0ACwwBCyACIAMgBRBTGiAEIAQoAgAgBWoiADYCAAtBICEFIApBwAFqIQMCQAJAA0AgBygCACAAaiECIAVBgAEgAGsiBk0NASACIAMgBhBTGiAEIAQoAgAgBmo2AgAgCSgCACIAKAIAIQIgACACQUBrNgIAIABBBGoiACAAKAIAIAJBv39LajYCACAIIAcoAgAQbSAHKAIAIgBBQGshAiAAIAIpAAA3AAAgACACKQAINwAIIAAgAikAEDcAECAAIAIpABg3ABggACACKQAgNwAgIAAgAikAKDcAKCAAIAIpADA3ADAgACACKQA4NwA4IAQgBCgCAEFAaiIANgIAIAMgBmohAyAFIAZrIgUNAAsMAQsgAiADIAUQUxogBCAEKAIAIAVqIgA2AgALQSAhBSAKQeABaiEKAkACQANAAkAgBygCACAAaiEDIAVBgAEgAGsiAk0NACADIAogAhBTGiAEIAQoAgAgAmo2AgAgCSgCACIAKAIAIQMgACADQUBrNgIAIABBBGoiACAAKAIAIANBv39LajYCACAIIAcoAgAQbSAHKAIAIgBBQGshAyAAIAMpAAA3AAAgACADKQAINwAIIAAgAykAEDcAECAAIAMpABg3ABggACADKQAgNwAgIAAgAykAKDcAKCAAIAMpADA3ADAgACADKQA4NwA4IAQgBCgCAEFAaiIANgIAIAUgAmsiBUUNAiAKIAJqIQoMAQsLDAELIAggARDgASALJAQPCyADIAogBRBTGiAEIAQoAgAgBWo2AgAgCCABEOABIAskBAuwAgIEfwN+IABB6DFqIgYsAABFBEBBAA8LIABBqDJqIQUgAEGcMmohByAAQbAyaiEEA0AgBSkDACAHKAIArXwgBCkDAFgEQCAAEKQEDQELCyAGLAAARQRAIABBuDJqLAAARQRAQQAPCyAAKAIAIAQpAwBBABCcAUEADwsgBCkDACIIIAUpAwAiCVoEQCAIIAKtIgp8IAkgBygCAK18WARAIAEgAEGYMmooAgAgCCAJfadqIAIQUxogAyACNgIAIAQgBCkDACAKfDcDACAAQbgyakEBOgAAQQEPCwsgAEG4MmoiBSwAAARAIAAoAgAgCEEAEJwBIAVBADoAAAsgACgCACABIAIQ1AEiAEEASAR/IAZBADoAAEEABSADIAA2AgAgBCAEKQMAIACsfDcDAEEBCwv2BgEPf0GABCAAQcgWaiIOKAIAIgdrIQYgB0UgBiACS3IEfyABIQkgAgUgAEHIEmogB2ogASAGEFMaA0AgACADQYgCbGohDCAAIANBiAJsakHwAWohCCAAIANBiAJsakH4AWohDUHAACEKIABByBJqIANBBnRqIQsgACADQYgCbGpBgAJqIgcoAgAhBAJAAkADQCAIKAIAIARqIQUgCkGAASAEayIJTQ0BIAUgCyAJEFMaIAcgBygCACAJajYCACANKAIAIgQoAgAhBSAEIAVBQGs2AgAgBEEEaiIEIAQoAgAgBUG/f0tqNgIAIAwgCCgCABBtIAgoAgAiBEFAayEFIAQgBSkAADcAACAEIAUpAAg3AAggBCAFKQAQNwAQIAQgBSkAGDcAGCAEIAUpACA3ACAgBCAFKQAoNwAoIAQgBSkAMDcAMCAEIAUpADg3ADggByAHKAIAQUBqIgQ2AgAgCyAJaiELIAogCWsiCg0ACwwBCyAFIAsgChBTGiAHIAcoAgAgCmo2AgALIANBAWoiA0EIRw0ACyABIAZqIQlBACEHIAIgBmsLIgtB/wNLIQ9BACEEA0AgACAEQYgCbGohECAPBEAgACAEQYgCbGpB8AFqIQ0gACAEQYgCbGpB+AFqIREgCSAEQQZ0aiECIAshCiAAIARBiAJsakGAAmoiCCgCACEDA0BBwAAhBSACIQECQAJAA0AgDSgCACADaiEGIAVBgAEgA2siDE0NASAGIAEgDBBTGiAIIAgoAgAgDGo2AgAgESgCACIDKAIAIQYgAyAGQUBrNgIAIANBBGoiAyADKAIAIAZBv39LajYCACAQIA0oAgAQbSANKAIAIgNBQGshBiADIAYpAAA3AAAgAyAGKQAINwAIIAMgBikAEDcAECADIAYpABg3ABggAyAGKQAgNwAgIAMgBikAKDcAKCADIAYpADA3ADAgAyAGKQA4NwA4IAggCCgCAEFAaiIDNgIAIAEgDGohASAFIAxrIgUNACADIQELDAELIAYgASAFEFMaIAggCCgCACAFaiIBNgIACyACQYAEaiECIApBgHxqIgpB/wNLBEAgASEDDAELCwsgBEEBaiIEQQhJDQALIAtB/wNxIgFFBEAgDiABIAdqNgIADwsgAEHIEmogB2ogCSALIAFraiABEFMaIA4gASAHajYCAAu5CgEDfyAAQcAQakEAQfABEFQaIABBwBJqQQA2AgAgAEHEEmoiA0EAOgAAIABByBJqQQBBhAQQVBogAEG0EmoiAigCACIBQawRKQIANwIAIAFBtBEpAgA3AgggAUG8ESkCADcCECABQcQRKQIANwIYIAIoAgAiASABKAIAQaCAoBBzNgIAIAFBDGoiASABKAIAQYCAhIACczYCACAAQQBB8AEQVBogAEEANgKAAiAAQQA6AIQCIABB9AFqIgIoAgAiAUGsESkCADcCACABQbQRKQIANwIIIAFBvBEpAgA3AhAgAUHEESkCADcCGCACKAIAIgEgASgCAEGggKAQczYCACABQQxqIgEgASgCAEGAgICAAnM2AgAgAEGIAmpBAEHwARBUGiAAQQA2AogEIABBADoAjAQgAEH8A2oiAigCACIBQawRKQIANwIAIAFBtBEpAgA3AgggAUG8ESkCADcCECABQcQRKQIANwIYIAIoAgAiASABKAIAQaCAoBBzNgIAIAFBCGoiAiACKAIAQQFzNgIAIAFBDGoiASABKAIAQYCAgIACczYCACAAQZAEakEAQfABEFQaIABBADYCkAYgAEEAOgCUBiAAQYQGaiICKAIAIgFBrBEpAgA3AgAgAUG0ESkCADcCCCABQbwRKQIANwIQIAFBxBEpAgA3AhggAigCACIBIAEoAgBBoICgEHM2AgAgAUEIaiICIAIoAgBBAnM2AgAgAUEMaiIBIAEoAgBBgICAgAJzNgIAIABBmAZqQQBB8AEQVBogAEGYCGpBADYCACAAQZwIakEAOgAAIABBjAhqIgIoAgAiAUGsESkCADcCACABQbQRKQIANwIIIAFBvBEpAgA3AhAgAUHEESkCADcCGCACKAIAIgEgASgCAEGggKAQczYCACABQQhqIgIgAigCAEEDczYCACABQQxqIgEgASgCAEGAgICAAnM2AgAgAEGgCGpBAEHwARBUGiAAQaAKakEANgIAIABBpApqQQA6AAAgAEGUCmoiAigCACIBQawRKQIANwIAIAFBtBEpAgA3AgggAUG8ESkCADcCECABQcQRKQIANwIYIAIoAgAiASABKAIAQaCAoBBzNgIAIAFBCGoiAiACKAIAQQRzNgIAIAFBDGoiASABKAIAQYCAgIACczYCACAAQagKakEAQfABEFQaIABBqAxqQQA2AgAgAEGsDGpBADoAACAAQZwMaiICKAIAIgFBrBEpAgA3AgAgAUG0ESkCADcCCCABQbwRKQIANwIQIAFBxBEpAgA3AhggAigCACIBIAEoAgBBoICgEHM2AgAgAUEIaiICIAIoAgBBBXM2AgAgAUEMaiIBIAEoAgBBgICAgAJzNgIAIABBsAxqQQBB8AEQVBogAEGwDmpBADYCACAAQbQOakEAOgAAIABBpA5qIgIoAgAiAUGsESkCADcCACABQbQRKQIANwIIIAFBvBEpAgA3AhAgAUHEESkCADcCGCACKAIAIgEgASgCAEGggKAQczYCACABQQhqIgIgAigCAEEGczYCACABQQxqIgEgASgCAEGAgICAAnM2AgAgAEG4DmpBAEHwARBUGiAAQbgQakEANgIA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BgYGaWkAdgBSYXJBcmNoaXZlAHZpAG9wZW4AaWlpaWlpAGdldEZpbGVIZWFkZXIAaWlpAHJlYWRGaWxlAGlpaWkAU3RhdGUAaQBlcnJDb2RlAHZpaWkAZXJyVHlwZQBBcmNIZWFkZXIAc3RhdGUAY29tbWVudABmbGFncwBBcmNGaWxlSGVhZGVyAG5hbWUAcGFja1NpemUAZGlpAHZpaWQAdW5wU2l6ZQBob3N0T1MAY3JjAHRpbWUAdW5wVmVyAG1ldGhvZABmaWxlQXR0cgAxM0FyY0ZpbGVIZWFkZXIATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUATlN0M19fMjIxX19iYXNpY19zdHJpbmdfY29tbW9uSUxiMUVFRQA5QXJjSGVhZGVyAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFADVTdGF0ZQBFUlJfUFJPQ0VTUwBFUlJfUkVBRABFUlJfT1BFTgBQSzEwUmFyQXJjaGl2ZQBQMTBSYXJBcmNoaXZlADEwUmFyQXJjaGl2ZQBTRVQARU5EAENVUgA0RmlsZQB2b2lkAGJvb2wAY2hhcgBzaWduZWQgY2hhcgB1bnNpZ25lZCBjaGFyAHNob3J0AHVuc2lnbmVkIHNob3J0AGludAB1bnNpZ25lZCBpbnQAbG9uZwB1bnNpZ25lZCBsb25nAGZsb2F0AGRvdWJsZQBzdGQ6OnN0cmluZwBzdGQ6OmJhc2ljX3N0cmluZzx1bnNpZ25lZCBjaGFyPgBzdGQ6OndzdHJpbmcAZW1zY3JpcHRlbjo6dmFsAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGRvdWJsZT4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZyBkb3VibGU+AE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWVFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lkRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lsRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l0RUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWhFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lhRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAE4xMGVtc2NyaXB0ZW4zdmFsRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQASERMUFRYXGBkaGxwdHh8gIREiIyQRJSYnKCkqKywRLS4vEBAwEBAQEBAQEDEyMxA0NRAQERERERERERERERERERERERERERERERERETYRERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERERE3ERERETgROTo7PD0+ERERERERERERERERERERERERERERERERERERERERERERERERERERERERET8QEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBARQEERQkNERUZHSEkQEBBKS0xNThAQEE9QEBAQEFEQEBAQEBAQEBARERFSUxAQEBAQEBAQEBAQEREREVQQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAREVUQEBAQVhAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBBXEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBBYWVpbEBAQEBAQEBAQEBAQEBAQEBAQEBAQEFwQEBAQEBAQEBAQEBAQEBAQEABBusMACyD//////////////////////////////////////////wBB4sMACzb+//8H/v//BwAAAAAABCAE//9/////f//////////////////////////////////D/wMAH1AAQaLEAAukASAAAAAAAN88QNf///v///////////+///////////////////////8D/P////////////////////////8A/v///38C/v////8AAAAAAP+/tgD///8HBwAAAP8H//////////7/w////////////////+8f/uH/nwAA////////AOD///////////////8DAP//////BzAE/////P8fAAD///8BAEHOxQAL5AH9HwAAAAAAAPAD/3//////////7//f4f/P//7+7p/5///9xeOfWYCwz/8DAO6H+f///W3DhxkCXsD/PwDuv/v///3t478bAQDP/wAA7p/5///97eOfGcCwz/8CAOzHPdYYx//Dxx2BAMD/AADu3/3///3v498dYAPP/wAA7N/9///97+PfHWBAz/8GAOzf/f/////n312AAM//APzs/3/8///7L3+AX/8AAAwA/v////9//wc/IP8DAAAAAJYl8P6u7P87XyD/8wAAAAABAAAA/wMAAP/+////H/7/A////v///x8AQbrHAAuVAv///////3/5/wP//+fB//9/QP8z/////78g///////3////////////PX89//////89/////z1/Pf9//////////z3//////////4cAAAAA//8AAP////////////8fAP7//////////////////////////////////////////////////////////5////7//wf////////////HAQD/3w8A//8PAP//DwD/3w0A////////z///AYAQ/wMAAAAA/wP//////////////wD//////wf//////////z8A////H/8P/wHA/////z8fAP//////D////wP/AwAAAAD///8P/////////3/+/x8A/wP/A4AAQdrJAAsw////////7//vD/8DAAAAAP//////8////////7//AwD///////8/AP/j//////8/AEGXygALG95vAP///////////////////////////////wBBusoACyD//z8//////z8//6r///8/////////31/cH88P/x/cHwBB6MoACwYCgAAA/x8AQfrKAAsShPwvPlC9//PgQwAA//////8BAEGwywALUMD///////8DAAD//////3///////3//////////////////////H3gMAP////+/IP////////+AAAD//38Af39/f39/f3//////AAAAAACAAEGazAALV+AAAAD+Az4f/v///////////3/g/v/////////////34P////8//v////////////9/AAD///8HAAAAAAAA////////////////////////////////PwBB+swACzL/////////////////////////////////HwAAAAAAAP//////////////////////HwBBtM0ACzz//////z//H////w8AAP//////f/CP////gP////////////8AAAAAgP/8////////////////eQ8A/wcAQfnNAAtn/7v3////AAAA////////DwD//////////w8A/wMAAPwI//////8H/////wcA////H/////////f/AID/AwAAAAD///////9/AP8//wP//38E/////////38FAAA4//88AH5+fgB/fwBB8s4AC4gB//////8H/wP//////////////////////////w8A//9/+P//////D/////////////////8//////////////////wMAAAAAfwD44P/9f1/b/////////////////wMAAAD4////////////////PwAA///////////8////////AAAAAAD/DwBBiNAAC1Lf/////////////////////x8AAP8D/v//B/7//wfA/////////////3/8/PwcAAAAAP/v//9///+3/z//PwAAAAD///////////////////8HAEHi0AALB////////x8AQYrRAAtG////H////////wEAAAAAAP///38AAP///wcAAAAAAAD///8//////w//PgAAAAAA/////////////////////////z//AwBB2tEACws//f////+/kf//PwBB+tEACwj//z8A////AwBBitIACwj/////////wABBmtIACxBv8O/+//8PAAAAAAD///8fAEG60gALD////////z8A//8/AP//BwBB2tIACwr///////////8BAEH60gALKP//////////PwAAAMD/AAD8////////AQAA////Af8D////////x/8AQarTAAsM//////////8eAP8DAEHK0wALHv///////z8A/wMAAAAAAAD/////////////////fwBB+tMACw3///////////////8HAEGa1AALBv//////fwBButQACwj/////////AQBB2tQACxT//////////x8A//////9/AAD4/wBB+tQACwEDAEGa1QALmAH/////////////3///////////32Te/+vv/////////7/n39////97X/z9//////////////////////////////////////////////////////8//////f//9/////f//9/////f//9/////f/////3////9///3z////////+////+W/vcKhOqWqpb3917/+/8P7vv/DwBButYAC+sPVCEiGQ0BAgMRSxwMEAQLHRIeJ2hub3BxYiAFBg8TFBUaCBYHKCQXGAkKDhsfJSODgn0mKis8PT4/Q0dKTVhZWltcXV5fYGFjZGVmZ2lqa2xyc3R5ent8AElsbGVnYWwgYnl0ZSBzZXF1ZW5jZQBEb21haW4gZXJyb3IAUmVzdWx0IG5vdCByZXByZXNlbnRhYmxlAE5vdCBhIHR0eQBQZXJtaXNzaW9uIGRlbmllZABPcGVyYXRpb24gbm90IHBlcm1pdHRlZABObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5AE5vIHN1Y2ggcHJvY2VzcwBGaWxlIGV4aXN0cwBWYWx1ZSB0b28gbGFyZ2UgZm9yIGRhdGEgdHlwZQBObyBzcGFjZSBsZWZ0IG9uIGRldmljZQBPdXQgb2YgbWVtb3J5AFJlc291cmNlIGJ1c3kASW50ZXJydXB0ZWQgc3lzdGVtIGNhbGwAUmVzb3VyY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUASW52YWxpZCBzZWVrAENyb3NzLWRldmljZSBsaW5rAFJlYWQtb25seSBmaWxlIHN5c3RlbQBEaXJlY3Rvcnkgbm90IGVtcHR5AENvbm5lY3Rpb24gcmVzZXQgYnkgcGVlcgBPcGVyYXRpb24gdGltZWQgb3V0AENvbm5lY3Rpb24gcmVmdXNlZABIb3N0IGlzIGRvd24ASG9zdCBpcyB1bnJlYWNoYWJsZQBBZGRyZXNzIGluIHVzZQBCcm9rZW4gcGlwZQBJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBCbG9jayBkZXZpY2UgcmVxdWlyZWQATm8gc3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQATm90IHN1cHBvcnRlZABQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZABBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sAEFkZHJlc3Mgbm90IGF2YWlsYWJsZQBOZXR3b3JrIGlzIGRvd24ATmV0d29yayB1bnJlYWNoYWJsZQBDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsAQ29ubmVjdGlvbiBhYm9ydGVkAE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUAU29ja2V0IGlzIGNvbm5lY3RlZABTb2NrZXQgbm90IGNvbm5lY3RlZABDYW5ub3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24AT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFJlbW90ZSBJL08gZXJyb3IAUXVvdGEgZXhjZWVkZWQATm8gbWVkaXVtIGZvdW5kAFdyb25nIG1lZGl1bSB0eXBlAE5vIGVycm9yIGluZm9ybWF0aW9uAABMQ19BTEwATENfQ1RZUEUAAAAATENfTlVNRVJJQwAATENfVElNRQAAAAAATENfQ09MTEFURQAATENfTU9ORVRBUlkATENfTUVTU0FHRVMATEFORwBDLlVURi04AFBPU0lYAE1VU0xfTE9DUEFUSAARAAoAERERAAAAAAUAAAAAAAAJAAAAAAsAQa3mAAshEQAPChEREQMKBwABEwkLCwAACQYLAAALAAYRAAAAERERAEHe5gALAQsAQefmAAsYEQAKChEREQAKAAACAAkLAAAACQALAAALAEGY5wALAQwAQaTnAAsVDAAAAAAMAAAAAAkMAAAAAAAMAAAMAEHS5wALAQ4AQd7nAAsVDQAAAAQNAAAAAAkOAAAAAAAOAAAOAEGM6AALARAAQZjoAAseDwAAAAAPAAAAAAkQAAAAAAAQAAAQAAASAAAAEhISAEHP6AALDhIAAAASEhIAAAAAAAAJAEGA6QALAQsAQYzpAAsVCgAAAAAKAAAAAAkLAAAAAAALAAALAEG66QALAQwAQcbpAAtdDAAAAAAMAAAAAAkMAAAAAAAMAAAMAAAtKyAgIDBYMHgALTBYKzBYIDBYLTB4KzB4IDB4AGluZgBJTkYAbmFuAE5BTgAwMTIzNDU2Nzg5QUJDREVGLgBDLlVURi04AEGs6gALGkMAEQAKABEREQAAAAAFAAAAAAAACQAAAAALAEHO6gALGhEADwoREREDCgcAARMJCwsAAAkGCwAACwAGAEH/6gALAQsAQYrrAAsWCgoAAAAACgAAAgAJCwAAAAkACwAACwBBuesACwEMAEHF6wALFQwAAAAADAAAAAAJDAAAAAAADAAADABB8+sACwEOAEH/6wALFQ0AAAAEDQAAAAAJDgAAAAAADgAADgBBrewACwEQAEG57AALHg8AAAAADwAAAAAJEAAAAAAAEAAAEAAAEgAAABISEgBB8OwACw4SAAAAEhISAAAAAAAACQBBoe0ACwELAEGt7QALFQoAAAAACgAAAAAJCwAAAAAACwAACwBB2+0ACwEMAEHn7QALvAcMAAAAAAwAAAAACQwAAAAAAAwAAAwAACUqcwAobnVsbCkAIwArAC0AIAAwAEwAAGpMTEwAagAAAAAAamoAAAAAagAAaiUlJXMlcyVzJXMlcyouKiVjJWMAYmFzaWNfc3RyaW5nAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAdGVybWluYXRpbmcgd2l0aCAlcyBleGNlcHRpb24gb2YgdHlwZSAlczogJXMAdGVybWluYXRpbmcgd2l0aCAlcyBleGNlcHRpb24gb2YgdHlwZSAlcwB0ZXJtaW5hdGluZyB3aXRoICVzIGZvcmVpZ24gZXhjZXB0aW9uAHRlcm1pbmF0aW5nAHVuY2F1Z2h0AFN0OWV4Y2VwdGlvbgBOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQBTdDl0eXBlX2luZm8ATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAE4xMF9fY3h4YWJpdjExN19fY2xhc3NfdHlwZV9pbmZvRQBwdGhyZWFkX29uY2UgZmFpbHVyZSBpbiBfX2N4YV9nZXRfZ2xvYmFsc19mYXN0KCkAY2Fubm90IGNyZWF0ZSBwdGhyZWFkIGtleSBmb3IgX19jeGFfZ2V0X2dsb2JhbHMoKQBjYW5ub3QgemVybyBvdXQgdGhyZWFkIHZhbHVlIGZvciBfX2N4YV9nZXRfZ2xvYmFscygpAHRlcm1pbmF0ZV9oYW5kbGVyIHVuZXhwZWN0ZWRseSByZXR1cm5lZAB0ZXJtaW5hdGVfaGFuZGxlciB1bmV4cGVjdGVkbHkgdGhyZXcgYW4gZXhjZXB0aW9uAHN0ZDo6YmFkX2FsbG9jAFN0OWJhZF9hbGxvYwBTdDExbG9naWNfZXJyb3IAU3QxMmxlbmd0aF9lcnJvcgBOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTIzX19mdW5kYW1lbnRhbF90eXBlX2luZm9FAHYARG4AYgBjAGgAYQBzAHQAaQBqAGwAbQBmAGQATjEwX19jeHhhYml2MTE2X19lbnVtX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTIxX192bWlfY2xhc3NfdHlwZV9pbmZvRQ=="), (A3) => A3.charCodeAt(0));
  var RA = class extends EA {
    constructor() {
      super(true);
    }
    constructWorker() {
      return new Promise((A3) => {
        const g3 = new yA();
        g3.onmessage = (I3) => {
          I3.data.type == "WASM_LOADED" && A3(g3);
        }, g3.postMessage({type: "init", buffer: uA.buffer});
      });
    }
  };
  var VA = class extends V {
    constructor() {
      super(), this.baseUrl = "", this.loadCount = 0, this.queue = [], this.__totalWork = 0, this.__doneWork = 0, this.plugins = {}, this.systemUrls = {};
      const A3 = "https://storage.googleapis.com/visualive-tmp/zea-engine-resources";
      this.systemUrls["ZeaEngine/Vive.vla"] = A3 + "/Vive.vla", this.systemUrls["ZeaEngine/Oculus.vla"] = A3 + "/Oculus.vla", this.commonResources = {};
    }
    registerPlugin(A3) {
      A3.init(this), this.plugins[A3.getType()] = A3;
    }
    loadFile(A3, g3, I3 = true) {
      const C3 = this.plugins[A3];
      if (!C3)
        throw new Error(`There's no plugin registered for the type of file "${A3}". Did you add the plugins script? See: https://docs.zea.live/zea-engine/#/adding-default-plugins`);
      if (I3 && this.incrementWorkload(), this.loadCount < 2e3) {
        this.loadCount++;
        const A4 = C3.loadFile(g3);
        return A4.then(() => {
          for (this.loadCount--, this.incrementWorkDone(), this.emit("loaded", {url: g3}); this.loadCount < 2e3 && this.queue.length > 0; ) {
            this.queue.pop()();
          }
        }, () => {
          this.incrementWorkDone();
        }), A4;
      }
      return new Promise((A4, I4) => {
        this.queue.push(() => {
          this.loadCount++;
          C3.loadFile(g3).then((I5) => {
            for (this.loadCount--, this.incrementWorkDone(), this.emit("loaded", {url: g3}); this.loadCount < 2e3 && this.queue.length > 0; ) {
              this.queue.pop()();
            }
            A4(I5);
          }, () => {
            this.incrementWorkDone();
          });
        });
      });
    }
    getCommonResource(A3) {
      return this.commonResources[A3];
    }
    setCommonResource(A3, g3) {
      this.commonResources[A3] = g3;
    }
    incrementWorkload(A3 = 1) {
      this.__totalWork += A3;
      const g3 = this.__doneWork / this.__totalWork * 100;
      this.emit("progressIncremented", {percent: g3});
    }
    incrementWorkDone(A3 = 1) {
      this.__doneWork += A3;
      const g3 = this.__doneWork / this.__totalWork * 100;
      if (this.emit("progressIncremented", {percent: g3}), this.__doneWork > this.__totalWork)
        throw new Error("Mismatch between work loaded and work done.");
    }
  };
  var FA = new VA();
  var SA = new class {
    constructor() {
      this.threadPool = new RA();
    }
    init(A3) {
      this.resourceLoader = A3;
    }
    getType() {
      return "archive";
    }
    loadFile(A3) {
      this.resourceLoader.incrementWorkload(1);
      const g3 = new Promise((g4, I3) => {
        fetch(A3).then((g5) => (this.resourceLoader.incrementWorkDone(1), function(A4) {
          return !!A4.ok && A4;
        }(g5) ? g5.arrayBuffer() : (I3(new Error(`loadArchive: ${g5.status} - ${g5.statusText} : ${A3}`)), null))).then((C3) => {
          if (!C3)
            return void I3("Buffer is null");
          const i3 = A3;
          this.threadPool.addTask({type: "unpack", resourceId: i3, buffer: C3}, [C3]).then((A4) => {
            A4.type === "FINISHED" ? g4(A4.entries) : A4.type === "ERROR" && I3(new Error(`Unable to load Resource: ${i3}`));
          });
        });
      });
      return g3;
    }
  }();
  FA.registerPlugin(SA);
  var wA = new class {
    init(A3) {
      this.resourceLoader = A3;
    }
    getType() {
      return "json";
    }
    loadFile(A3) {
      this.resourceLoader.incrementWorkload(1);
      return new Promise((g3, I3) => {
        fetch(A3).then((C3) => {
          this.resourceLoader.incrementWorkDone(1), !function(A4) {
            return !!A4.ok && A4;
          }(C3) ? I3(`loadJSON: ${C3.status} - ${C3.statusText} : ${A3}`) : g3(C3.json());
        });
      });
    }
  }();
  FA.registerPlugin(wA);
  var XA = new class {
    init(A3) {
      this.resourceLoader = A3;
    }
    getType() {
      return "text";
    }
    loadFile(A3) {
      this.resourceLoader.incrementWorkload(1);
      return new Promise((g3, I3) => {
        fetch(A3).then((C3) => {
          this.resourceLoader.incrementWorkDone(1), !function(A4) {
            return !!A4.ok && A4;
          }(C3) ? I3(`loadText: ${C3.status} - ${C3.statusText} : ${A3}`) : g3(C3.text());
        });
      });
    }
  }();
  FA.registerPlugin(XA);
  var HA = new class {
    init(A3) {
      this.resourceLoader = A3;
    }
    getType() {
      return "binary";
    }
    loadFile(A3) {
      this.resourceLoader.incrementWorkload(1);
      return new Promise((g3, I3) => {
        fetch(A3).then((C3) => {
          this.resourceLoader.incrementWorkDone(1), !function(A4) {
            return !!A4.ok && A4;
          }(C3) ? I3(`loadBinary: ${C3.status} - ${C3.statusText} : ${A3}`) : g3(C3.arrayBuffer());
        });
      });
    }
  }();
  FA.registerPlugin(HA);
  var WA = class {
    constructor(A3 = "") {
      if (this.branch = "", A3) {
        const g3 = A3.split("-"), I3 = g3[0].split(".");
        this.major = parseInt(I3[0]), this.minor = parseInt(I3[1]), this.patch = parseInt(I3[2]), g3.length == 2 && (this.branch = g3[1]);
      } else
        this.major = 0, this.minor = 0, this.patch = 0;
    }
    compare(A3) {
      const g3 = [this.major, this.minor, this.patch];
      for (let I3 = 0; I3 < 3; I3++)
        if (g3[I3] !== A3[I3])
          return g3[I3] - A3[I3];
      return 0;
    }
    toString() {
      return `v${this.major}.${this.minor}.${this.patch}` + (this.branch != "" ? `-${this.branch}` : "");
    }
  };
  var YA = class {
    constructor(A3, g3 = 0, I3 = true) {
      this.__data = A3, this.__byteOffset = g3, this.__dataView = new DataView(this.__data), this.__isMobileDevice = I3, this.utf8decoder = new TextDecoder();
    }
    get isMobileDevice() {
      return this.__isMobileDevice;
    }
    get data() {
      return this.__data;
    }
    get byteLength() {
      return this.__dataView.byteLength;
    }
    get remainingByteLength() {
      return this.__dataView.byteLength - this.__byteOffset;
    }
    pos() {
      return this.__byteOffset;
    }
    seek(A3) {
      this.__byteOffset = A3;
    }
    advance(A3) {
      this.__byteOffset += A3;
    }
    loadUInt8() {
      const A3 = this.__dataView.getUint8(this.__byteOffset);
      return this.__byteOffset += 1, A3;
    }
    loadUInt16() {
      const A3 = this.__dataView.getUint16(this.__byteOffset, true);
      return this.__byteOffset += 2, A3;
    }
    loadUInt32() {
      const A3 = this.__dataView.getUint32(this.__byteOffset, true);
      return this.__byteOffset += 4, A3;
    }
    loadSInt32() {
      const A3 = this.__dataView.getInt32(this.__byteOffset, true);
      return this.__byteOffset += 4, A3;
    }
    loadFloat16() {
      const A3 = this.loadUInt16();
      return r.decode16BitFloat(A3);
    }
    loadUFloat16() {
      const A3 = this.loadFloat16();
      return A3 < 0 ? 2048 - A3 : A3;
    }
    loadFloat16From2xUInt8() {
      throw Error("loadFloat16From2xUInt8 not implemented!");
    }
    loadUInt32From2xUFloat16() {
      return this.loadUFloat16() + 4096 * this.loadUFloat16();
    }
    loadSInt32From2xFloat16() {
      return this.loadFloat16() + 2048 * this.loadFloat16();
    }
    loadFloat32() {
      const A3 = this.__dataView.getFloat32(this.__byteOffset, true);
      return this.__byteOffset += 4, A3;
    }
    loadUInt8Array(A3, g3 = false) {
      let I3;
      return A3 == null && (A3 = this.loadUInt32()), g3 ? (I3 = new Uint8Array(this.__data.slice(this.__byteOffset, this.__byteOffset + A3)), I3.length != A3 && console.log("broken")) : I3 = new Uint8Array(this.__data, this.__byteOffset, A3), this.__byteOffset += A3, I3;
    }
    loadUInt16Array(A3, g3 = false) {
      if (A3 == null && (A3 = this.loadUInt32()), A3 == 0)
        return new Uint16Array();
      let I3;
      if (this.readPad(2), this.__isMobileDevice) {
        I3 = new Uint16Array(A3);
        for (let g4 = 0; g4 < A3; g4++)
          I3[g4] = this.__dataView.getUint16(this.__byteOffset, true), this.__byteOffset += 2;
      } else
        g3 ? (I3 = new Uint16Array(this.__data.slice(this.__byteOffset, this.__byteOffset + 2 * A3)), I3.length != A3 && console.log("broken")) : I3 = new Uint16Array(this.__data, this.__byteOffset, A3), this.__byteOffset += 2 * A3;
      return I3;
    }
    loadUInt32Array(A3, g3 = false) {
      if (A3 == null && (A3 = this.loadUInt32()), A3 == 0)
        return new Uint32Array();
      let I3;
      if (this.readPad(4), this.__isMobileDevice) {
        I3 = new Uint32Array(A3);
        for (let g4 = 0; g4 < A3; g4++)
          I3[g4] = this.__dataView.getUint32(this.__byteOffset, true), this.__byteOffset += 4;
      } else
        g3 ? (I3 = new Uint32Array(this.__data.slice(this.__byteOffset, this.__byteOffset + 4 * A3)), I3.length != A3 && console.log("broken")) : I3 = new Uint32Array(this.__data, this.__byteOffset, A3), this.__byteOffset += 4 * A3;
      return I3;
    }
    loadFloat32Array(A3, g3 = false) {
      if (A3 == null && (A3 = this.loadUInt32()), A3 == 0)
        return new Float32Array();
      let I3;
      if (this.readPad(4), this.__isMobileDevice) {
        I3 = new Float32Array(A3);
        for (let g4 = 0; g4 < A3; g4++)
          I3[g4] = this.__dataView.getFloat32(this.__byteOffset, true), this.__byteOffset += 4;
      } else
        I3 = g3 ? new Float32Array(this.__data.slice(this.__byteOffset, this.__byteOffset + 4 * A3)) : new Float32Array(this.__data, this.__byteOffset, A3), this.__byteOffset += 4 * A3;
      return I3;
    }
    loadStr() {
      const A3 = this.loadUInt32(), g3 = new Uint8Array(this.__data, this.__byteOffset, A3);
      return this.__byteOffset += A3, this.utf8decoder.decode(g3);
    }
    loadStrArray() {
      const A3 = this.loadUInt32(), g3 = [];
      for (let I3 = 0; I3 < A3; I3++)
        g3[I3] = this.loadStr();
      return g3;
    }
    loadSInt32Vec2() {
      const A3 = this.loadSInt32(), g3 = this.loadSInt32();
      return new B(A3, g3);
    }
    loadUInt32Vec2() {
      const A3 = this.loadUInt32(), g3 = this.loadUInt32();
      return new B(A3, g3);
    }
    loadFloat16Vec2() {
      const A3 = this.loadFloat16(), g3 = this.loadFloat16();
      return new B(A3, g3);
    }
    loadFloat32Vec2() {
      const A3 = this.loadFloat32(), g3 = this.loadFloat32();
      return new B(A3, g3);
    }
    loadFloat16Vec3() {
      const A3 = this.loadFloat16(), g3 = this.loadFloat16(), I3 = this.loadFloat16();
      return new o(A3, g3, I3);
    }
    loadFloat32Vec3() {
      const A3 = this.loadFloat32(), g3 = this.loadFloat32(), I3 = this.loadFloat32();
      return new o(A3, g3, I3);
    }
    loadFloat16Quat() {
      const A3 = this.loadFloat16(), g3 = this.loadFloat16(), I3 = this.loadFloat16(), C3 = this.loadFloat16();
      return new c(A3, g3, I3, C3);
    }
    loadFloat32Quat() {
      const A3 = this.loadFloat32(), g3 = this.loadFloat32(), I3 = this.loadFloat32(), C3 = this.loadFloat32();
      return new c(A3, g3, I3, C3);
    }
    loadRGBFloat32Color() {
      const A3 = this.loadFloat32(), g3 = this.loadFloat32(), I3 = this.loadFloat32();
      return new l(A3, g3, I3);
    }
    loadRGBAFloat32Color() {
      const A3 = this.loadFloat32(), g3 = this.loadFloat32(), I3 = this.loadFloat32(), C3 = this.loadFloat32();
      return new l(A3, g3, I3, C3);
    }
    loadRGBUInt8Color() {
      const A3 = this.loadUInt8(), g3 = this.loadUInt8(), I3 = this.loadUInt8();
      return new l(A3 / 255, g3 / 255, I3 / 255);
    }
    loadRGBAUInt8Color() {
      const A3 = this.loadUInt8(), g3 = this.loadUInt8(), I3 = this.loadUInt8(), C3 = this.loadUInt8();
      return new l(A3 / 255, g3 / 255, I3 / 255, C3 / 255);
    }
    loadBox2() {
      return new Q(this.loadFloat32Vec2(), this.loadFloat32Vec2());
    }
    loadBox3() {
      return new b(this.loadFloat32Vec3(), this.loadFloat32Vec3());
    }
    readPad(A3) {
      const g3 = this.__byteOffset % A3;
      g3 != 0 && (this.__byteOffset += A3 - g3);
    }
  };
  var KA;
  var pA;
  !function(A3) {
    A3[A3.OP_WRITE = 0] = "OP_WRITE", A3[A3.OP_READ_WRITE = 1] = "OP_READ_WRITE";
  }(KA || (KA = {}));
  var NA = class extends V {
    constructor(A3 = "", g3, I3) {
      super(), this.dirty = false, this.boundInputs = [], this.boundOutputs = [], this.cleaning = false, this.dirtyOpIndex = 0, this.firstOP_WRITE = 0, this.name = A3, this.__value = g3, this.dataType = I3;
    }
    getName() {
      return this.name;
    }
    setName(A3) {
      if (A3 === this.name)
        return;
      const g3 = this.name;
      this.name = A3, this.emit("nameChanged", {newName: this.name, prevName: g3});
    }
    getOwner() {
      return this.ownerItem;
    }
    setOwner(A3) {
      this.ownerItem = A3;
    }
    getPath() {
      return this.ownerItem && this.ownerItem instanceof hA ? [...this.ownerItem.getPath(), this.name] : [this.name];
    }
    getDataType() {
      return this.dataType;
    }
    bindOperatorInput(A3) {
      this.boundInputs.push(A3);
    }
    unbindOperatorInput(A3) {
      const g3 = this.boundInputs.indexOf(A3);
      this.boundInputs.splice(g3, 1);
    }
    bindOperatorOutput(A3, g3 = -1) {
      g3 == -1 && (g3 = this.boundOutputs.length), this.boundOutputs.splice(g3, 0, A3);
      for (let A4 = g3; A4 < this.boundOutputs.length; A4++)
        this.boundOutputs[A4].setParamBindIndex(A4);
      return this.__findFirstOP_WRITE(), this.dirtyOpIndex = this.boundOutputs.length, this.setDirty(g3), g3;
    }
    unbindOperatorOutput(A3) {
      const g3 = A3.getParamBindIndex();
      this.boundOutputs.splice(g3, 1);
      for (let A4 = g3; A4 < this.boundOutputs.length; A4++)
        this.boundOutputs[A4].setParamBindIndex(A4);
      return this.__findFirstOP_WRITE(), this.dirtyOpIndex = this.boundOutputs.length, this.setDirty(Math.max(0, g3 - 1)), g3;
    }
    __findFirstOP_WRITE() {
      if (this.firstOP_WRITE = this.boundOutputs.length, this.boundOutputs.length > 0)
        for (this.firstOP_WRITE--; this.firstOP_WRITE > 0 && this.boundOutputs[this.firstOP_WRITE].getMode() != KA.OP_WRITE; this.firstOP_WRITE--)
          ;
    }
    setDirty(A3) {
      if (A3 < this.dirtyOpIndex) {
        let g3 = this.firstOP_WRITE;
        if (g3 <= A3) {
          for (this.dirtyOpIndex = g3, g3++; g3 < this.boundOutputs.length; g3++)
            g3 != A3 && this.boundOutputs[g3].getOperator().setDirty();
          for (let A4 = 0; A4 < this.boundInputs.length; A4++)
            this.boundInputs[A4].setDirty();
          return this.emit("valueChanged"), true;
        }
      }
      return false;
    }
    isDirty() {
      return this.dirtyOpIndex < this.boundOutputs.length;
    }
    getDirtyBindingIndex() {
      return this.dirtyOpIndex;
    }
    setCleanFromOp(A3, g3) {
      if (g3 != this.dirtyOpIndex) {
        if (g3 < this.dirtyOpIndex)
          console.log("Parameter is cleaned when it was already clean to that point in the stack:", this.getPath());
        else if (this.boundOutputs[g3].getMode() != KA.OP_WRITE) {
          const A4 = this.getClassName(), I3 = this.boundOutputs[g3].getOperator(), C3 = I3.getClassName();
          throw new Error(`Parameter: ${A4} with name: ${this.getName()} is not cleaning all outputs during evaluation of op: ${C3} with name: ${I3.getName()}`);
        }
      }
      this.__value = A3, this.dirtyOpIndex = g3 + 1;
    }
    getValueFromOp(A3) {
      return this.dirtyOpIndex < A3 && this._clean(A3), this.__value;
    }
    _clean(A3) {
      if (this.cleaning)
        throw new Error(`Cycle detected when cleaning: ${this.getPath()}. Operators need to be rebound to fix errors`);
      for (this.cleaning = true; this.dirtyOpIndex < A3; ) {
        const A4 = this.dirtyOpIndex;
        if (this.boundOutputs[this.dirtyOpIndex].getOperator().evaluate(), A4 == this.dirtyOpIndex) {
          const A5 = this.boundOutputs[this.dirtyOpIndex].getOperator(), g3 = A5.getClassName();
          console.warn(`Operator: ${g3} with name: ${A5.getName()} is not cleaning its outputs during evaluation`), this.dirtyOpIndex++;
        }
      }
      this.cleaning = false;
    }
    getValue() {
      return this.dirtyOpIndex < this.boundOutputs.length && this._clean(this.boundOutputs.length), this.__value;
    }
    setValue(A3) {
      if (A3 == null)
        throw "undefined was passed into the set value for param:" + this.getName();
      if (this.boundOutputs.length > 0)
        for (let g3 = this.boundOutputs.length - 1; g3 >= 0; g3--) {
          const I3 = this.boundOutputs[g3];
          if (A3 = I3.backPropagateValue(A3), I3.getMode() == 0)
            return;
        }
      if (typeof A3 == "object" || this.__value != A3) {
        this.__value = A3;
        for (let A4 = 0; A4 < this.boundInputs.length; A4++)
          this.boundInputs[A4].paramValueChanged();
        this.emit("valueChanged");
      }
    }
    get value() {
      return this.getValue();
    }
    set value(A3) {
      this.setValue(A3);
    }
    loadValue(A3) {
      this.__value = A3;
    }
    copyFrom(A3, g3) {
      this.loadValue(A3.__value);
    }
    readBinary(A3, g3) {
      console.warn(`TODO: Parameter: ${this.constructor.name} with name: ${this.name} does not implement readBinary`);
    }
    destroy() {
      console.warn("nothing destroyed. This method was not overwritten in subclass");
    }
  };
  var JA = class extends NA {
    constructor(A3 = "", g3 = 0, I3, C3) {
      super(A3, g3, "Number"), this.range = I3, this.step = C3;
    }
    getRange() {
      return this.range;
    }
    setRange(A3) {
      this.range = A3;
    }
    getStep() {
      return this.step;
    }
    setStep(A3) {
      this.step = A3;
    }
    toJSON(A3) {
      const g3 = {value: this.__value};
      return this.range && (g3.range = this.range), this.step && (g3.step = this.step), g3;
    }
    fromJSON(A3, g3) {
      this.__value = A3.value, A3.range && (this.range = A3.range), A3.step && (this.step = A3.step);
    }
    readBinary(A3, g3) {
      this.__value = A3.loadFloat32();
    }
    clone() {
      return new JA(this.name, this.__value, this.range, this.step);
    }
  };
  e.register("NumberParameter", JA), e.register("Property_SInt32", class extends JA {
    readBinary(A3, g3) {
      this.__value = A3.loadSInt32();
    }
  }), e.register("Property_UInt32", class extends JA {
    readBinary(A3, g3) {
      this.__value = A3.loadUInt32();
    }
  }), e.register("Property_Float32", class extends JA {
    readBinary(A3, g3) {
      this.__value = A3.loadFloat32();
    }
  });
  var DA = class extends JA {
    constructor(A3, g3, I3 = []) {
      super(A3, g3, [0, I3.length], 1), this.choices = I3;
    }
    getChoices() {
      return this.choices;
    }
    setValue(A3) {
      typeof A3 == "string" ? super.setValue(this.choices.indexOf(A3)) : super.setValue(A3);
    }
  };
  e.register("MultiChoiceParameter", DA);
  var fA = class extends NA {
    constructor(A3 = "", g3) {
      super(A3, g3 != null && g3, "Boolean");
    }
    readBinary(A3, g3) {
      this.__value = A3.loadUInt8() != 0;
    }
    toJSON(A3) {
      return {value: this.__value};
    }
    fromJSON(A3, g3) {
      this.__value = A3.value, this.emit("valueChanged", {mode: 0});
    }
    clone() {
      return new fA(this.name, this.__value);
    }
  };
  e.register("BooleanParameter", fA), e.register("Property_Boolean", fA);
  var MA = class extends NA {
    constructor(A3 = "", g3, I3) {
      super(A3, g3 || new B(), "Vec2"), this.range = I3;
    }
    getRange() {
      return this.range;
    }
    setRange(A3) {
      this.range = A3, this.emit("rangeChanged", {range: A3});
    }
    readBinary(A3, g3) {
      var I3;
      (I3 = this.__value) === null || I3 === void 0 || I3.readBinary(A3);
    }
    toJSON(A3) {
      var g3;
      return {name: this.name, value: (g3 = this.__value) === null || g3 === void 0 ? void 0 : g3.toJSON()};
    }
    fromJSON(A3, g3) {
      const I3 = new B();
      I3.fromJSON(A3.value), this.__value = I3, A3.name && (this.name = A3.name);
    }
    clone() {
      var A3;
      const g3 = new MA(this.name, (A3 = this.__value) === null || A3 === void 0 ? void 0 : A3.clone());
      return this.range && g3.setRange(this.range), g3;
    }
  };
  e.register("Vec2Parameter", MA), e.register("Property_Vec2_32f", MA);
  var LA = class extends NA {
    constructor(A3 = "", g3, I3) {
      super(A3, g3 || new o(), "Vec3"), this.range = I3;
    }
    readBinary(A3, g3) {
      var I3;
      (I3 = this.__value) === null || I3 === void 0 || I3.readBinary(A3);
    }
    toJSON(A3) {
      var g3;
      return {name: this.name, value: (g3 = this.__value) === null || g3 === void 0 ? void 0 : g3.toJSON()};
    }
    fromJSON(A3, g3) {
      const I3 = new o();
      I3.fromJSON(A3.value), this.__value = I3, A3.name && (this.name = A3.name);
    }
    clone() {
      var A3;
      return new LA(this.name, (A3 = this.__value) === null || A3 === void 0 ? void 0 : A3.clone());
    }
  };
  e.register("Vec3Parameter", LA), e.register("Property_Vec3_32f", LA);
  var UA = class extends NA {
    constructor(A3 = "", g3) {
      super(A3, g3 || new s(), "Vec4");
    }
    readBinary(A3, g3) {
      var I3;
      (I3 = this.__value) === null || I3 === void 0 || I3.readBinary(A3);
    }
    toJSON(A3) {
      var g3;
      return {name: this.name, value: (g3 = this.__value) === null || g3 === void 0 ? void 0 : g3.toJSON()};
    }
    fromJSON(A3, g3) {
      const I3 = new s();
      I3.fromJSON(A3.value), this.__value = I3, A3.name && (this.name = A3.name);
    }
    clone() {
      var A3;
      return new UA(this.name, (A3 = this.__value) === null || A3 === void 0 ? void 0 : A3.clone());
    }
  };
  e.register("Vec4Parameter", UA), e.register("Property_Vec4_32f", UA);
  var vA = class extends NA {
    constructor(A3 = "", g3) {
      super(A3, g3 || new Q(), "Box2");
    }
    readBinary(A3, g3) {
      this.__value.p0.readBinary(A3), this.__value.p1.readBinary(A3);
    }
    toJSON(A3) {
      return {value: {p0: this.__value.p0.toJSON(), p1: this.__value.p1.toJSON()}};
    }
    fromJSON(A3, g3) {
      this.__value.p0.fromJSON(A3.p0), this.__value.p1.fromJSON(A3.p1);
    }
    clone() {
      var A3;
      return new vA(this.name, (A3 = this.__value) === null || A3 === void 0 ? void 0 : A3.clone());
    }
  };
  e.register("Box2Parameter", vA), e.register("Property_Box2_32f", vA);
  var kA = class extends NA {
    constructor(A3 = "", g3) {
      super(A3, g3 || new b(), "Box3");
    }
    readBinary(A3, g3) {
      this.__value.p0.readBinary(A3), this.__value.p1.readBinary(A3);
    }
    toJSON(A3) {
      return {value: {p0: this.__value.p0.toJSON(), p1: this.__value.p1.toJSON()}};
    }
    fromJSON(A3, g3) {
      A3.value && (this.__value.p0.fromJSON(A3.value.p0), this.__value.p1.fromJSON(A3.value.p1));
    }
    clone() {
      var A3;
      return new kA(this.name, (A3 = this.__value) === null || A3 === void 0 ? void 0 : A3.clone());
    }
  };
  e.register("Box3Parameter", kA), e.register("Property_Box3_32f", kA);
  var xA = class extends NA {
    constructor(A3 = "", g3) {
      super(A3, g3 || new l(), "Color");
    }
    readBinary(A3, g3) {
      const I3 = A3.loadRGBAFloat32Color();
      I3.applyGamma(2.2), this.__value = I3;
    }
    toJSON(A3) {
      var g3;
      return {value: (g3 = this.__value) === null || g3 === void 0 ? void 0 : g3.toJSON()};
    }
    fromJSON(A3, g3) {
      var I3;
      (I3 = this.__value) === null || I3 === void 0 || I3.fromJSON(A3.value);
    }
    clone() {
      var A3;
      return new xA(this.name, (A3 = this.__value) === null || A3 === void 0 ? void 0 : A3.clone());
    }
  };
  e.register("ColorParameter", xA), e.register("Property_Color_32f", xA);
  var zA = class extends NA {
    constructor(A3 = "", g3) {
      super(A3, g3 || new c(), "Quat");
    }
    readBinary(A3, g3) {
      var I3;
      (I3 = this.__value) === null || I3 === void 0 || I3.readBinary(A3);
    }
    toJSON(A3) {
      var g3;
      return {value: (g3 = this.__value) === null || g3 === void 0 ? void 0 : g3.toJSON()};
    }
    fromJSON(A3, g3) {
      const I3 = new c();
      I3.fromJSON(A3.value), this.__value = I3;
    }
    clone() {
      var A3;
      return new zA(this.name, (A3 = this.__value) === null || A3 === void 0 ? void 0 : A3.clone());
    }
  };
  e.register("QuatParameter", zA), e.register("Property_Quat_32f", zA);
  var TA = class extends NA {
    constructor(A3 = "", g3) {
      super(A3, g3 || new d(), "Mat3");
    }
    readBinary(A3, g3) {
      var I3;
      (I3 = this.__value) === null || I3 === void 0 || I3.readBinary(A3);
    }
    toJSON(A3) {
      var g3;
      return {value: (g3 = this.__value) === null || g3 === void 0 ? void 0 : g3.toJSON()};
    }
    fromJSON(A3, g3) {
      const I3 = new d();
      I3.fromJSON(A3.value), this.__value = I3;
    }
    clone() {
      var A3;
      return new TA(this.name, (A3 = this.__value) === null || A3 === void 0 ? void 0 : A3.clone());
    }
  };
  e.register("Mat3Parameter", TA), e.register("Property_Mat3_32f", TA);
  var _A = class extends NA {
    constructor(A3 = "", g3) {
      super(A3, g3 || new h(), "Mat4");
    }
    readBinary(A3, g3) {
      var I3;
      (I3 = this.__value) === null || I3 === void 0 || I3.readBinary(A3);
    }
    toJSON(A3) {
      var g3;
      return {value: (g3 = this.__value) === null || g3 === void 0 ? void 0 : g3.toJSON()};
    }
    fromJSON(A3, g3) {
      const I3 = new h();
      I3.fromJSON(A3.value), this.__value = I3;
    }
    clone() {
      var A3;
      return new _A(this.name, (A3 = this.__value) === null || A3 === void 0 ? void 0 : A3.clone());
    }
  };
  e.register("Mat4Parameter", _A), e.register("Property_Mat4_32f", _A);
  var PA = class extends NA {
    constructor(A3 = "", g3) {
      super(A3, g3 || new m(), "Xfo");
    }
    readBinary(A3, g3) {
      this.__value.readBinary(A3);
    }
    toJSON(A3) {
      return {name: this.name, value: this.__value.toJSON()};
    }
    fromJSON(A3, g3) {
      const I3 = new m();
      I3.fromJSON(A3.value), this.__value = I3, A3.name && (this.name = A3.name);
    }
    clone() {
      return new PA(this.name, this.__value.clone());
    }
  };
  e.register("XfoParameter", PA), e.register("Property_Xfo_32f", PA);
  var OA = class extends NA {
    constructor(A3 = "", g3) {
      super(A3, g3, "BaseImage");
    }
    toJSON(A3) {
      const g3 = {name: this.name};
      return this.__value && (g3.imageType = this.__value.getClassName(), g3.value = this.__value.toJSON()), g3;
    }
    fromJSON(A3, g3) {
      var I3;
      A3.imageType && (this.__value = e.constructClass(A3.imageType), A3.value && ((I3 = this.__value) === null || I3 === void 0 || I3.fromJSON(A3.value, g3)));
    }
    clone() {
      return new OA(this.name, this.__value);
    }
  };
  e.register("ImageParameter", OA);
  var jA = class extends NA {
    constructor(A3 = "", g3 = "") {
      super(A3, g3, "String"), this.multiLine = false;
    }
    setMultiLine(A3) {
      this.multiLine = A3;
    }
    getMultiLine() {
      return this.multiLine;
    }
    readBinary(A3, g3) {
      this.__value = A3.loadStr();
    }
    toJSON(A3) {
      return {value: this.__value};
    }
    fromJSON(A3, g3) {
      this.__value = A3.value ? A3.value : "", this.emit("valueChanged", {mode: 0});
    }
    clone() {
      return new jA(this.name, this.__value);
    }
  };
  e.register("StringParameter", jA), e.register("Property_String", jA);
  var qA = class extends NA {
    constructor(A3 = "", g3 = []) {
      super(A3, g3, "String[]");
    }
    readBinary(A3, g3) {
      this.__value = A3.loadStrArray();
    }
    toJSON(A3) {
      return {value: this.__value};
    }
    fromJSON(A3, g3) {
      this.__value = A3.value, this.emit("valueChanged", {mode: 0});
    }
    clone() {
      return new qA(this.name, this.__value);
    }
  };
  e.register("StringListParameter", qA), e.register("Property_StringList", qA);
  var $A = class extends NA {
    constructor(A3 = "", g3) {
      super(A3, [], g3);
    }
    filter(A3) {
      return true;
    }
    getCount() {
      var A3;
      return ((A3 = this.__value) === null || A3 === void 0 ? void 0 : A3.length) || 0;
    }
    getElement(A3) {
      if (this.__value)
        return this.__value[A3];
    }
    setElement(A3, g3) {
      this.__value || (this.__value = []), this.__value[A3] = g3, this.emit("valueChanged");
    }
    addElement(A3) {
      if ((A3 || A3 == 0) && this.filter(A3))
        return this.__value || (this.__value = []), this.__value.push(A3), this.emit("elementAdded", {elem: A3, index: this.__value.length - 1}), this.emit("valueChanged"), A3;
    }
    removeElement(A3) {
      this.__value || (this.__value = []);
      const g3 = this.__value[A3];
      this.__value.splice(A3, 1), this.emit("elementRemoved", {elem: g3, index: A3}), this.emit("valueChanged");
    }
    insertElement(A3, g3) {
      this.__value && this.filter(g3) && (this.__value.splice(A3, 0, g3), this.emit("elementAdded", {elem: g3, index: A3}), this.emit("valueChanged"));
    }
    toJSON(A3) {
      const g3 = [];
      if (this.__value)
        for (const I3 of this.__value)
          typeof this.dataType == "string" ? g3.push(I3) : g3.push(I3.toJSON(A3));
      return {value: g3};
    }
    fromJSON(A3, g3) {
      if (A3.items != null) {
        this.__value = [];
        for (let I3 = 0; I3 < A3.items.length; I3++) {
          let C3;
          if (typeof this.dataType == "string")
            C3 = A3.items[I3];
          else {
            if (!this.dataType)
              throw "No DataType";
            C3 = e.constructClass(this.dataType), C3.fromJSON(A3.items[I3], g3);
          }
          this.__value.push(C3), this.emit("elementAdded", {elem: C3, index: this.__value.length - 1});
        }
        this.emit("valueChanged", {mode: 0});
      } else
        console.warn("Invalid Parameter JSON");
    }
    clone() {
      const A3 = this.__value ? this.__value.slice(0) : [];
      if (!this.dataType)
        throw "This parameter does not have a DataType";
      const g3 = new $A(this.name, this.dataType);
      return g3.setValue(A3), g3;
    }
    destroy() {
      if (this.__value)
        for (let A3 = 0; A3 < this.__value.length; A3++)
          this.__value[A3] instanceof NA && this.__value[A3].destroy(), this.removeElement(A3);
    }
  };
  var Ag = class extends NA {
    constructor(A3) {
      super(A3, {}, "Struct"), this.members = [];
    }
    addMember(A3) {
      return this.__value && (this.__value[A3.getName()] = A3.value), A3.on("valueChanged", () => {
        this.__value && (this.__value[A3.getName()] = A3.value);
      }), this.members.push(A3), this.emit("valueChanged"), A3;
    }
    getParameter(A3) {
      for (const g3 of this.members)
        if (g3.getName() == A3)
          return g3;
    }
    getMember(A3) {
      return this.getParameter(A3);
    }
    getMemberNames() {
      const A3 = [];
      for (let g3 = 0; g3 < this.members.length; g3++) {
        const I3 = this.members[g3];
        I3 != null && (A3[g3] = I3.getName());
      }
      return A3;
    }
    toJSON(A3) {
      const g3 = {}, I3 = [];
      for (const g4 of this.members)
        I3.push(g4.toJSON(A3));
      return g3.members = I3, g3.name = this.name, g3;
    }
    fromJSON(A3, g3) {
      if (A3.members != null) {
        for (let I3 = 0; I3 < A3.members.length; I3++)
          A3.members[I3] && this.members[I3].fromJSON(A3.members[I3], g3);
        this.name = A3.name;
      } else
        console.warn("Invalid Parameter JSON");
    }
    clone() {
      return new Ag(this.name);
    }
    destroy() {
      for (const A3 of this.members)
        A3.destroy();
    }
  };
  e.register("StructParameter", Ag);
  var gg = class extends V {
    constructor(A3, g3 = KA.OP_WRITE) {
      super(), this._op = null, this.__name = A3, this._mode = g3, this._param = void 0, this._paramBindIndex = -1, this.detached = false;
    }
    getName() {
      return this.__name;
    }
    setOperator(A3) {
      this._op = A3;
    }
    getOperator() {
      return this._op;
    }
    getMode() {
      return this._mode;
    }
    isConnected() {
      return this._param != null;
    }
    getParam() {
      return this._param;
    }
    setParam(A3, g3 = -1) {
      this._param && this._param.unbindOperatorOutput(this), this._param = A3, this._param && (this._paramBindIndex = this._param.bindOperatorOutput(this, g3)), this.emit("paramSet", {param: this._param});
    }
    getParamBindIndex() {
      return this._paramBindIndex;
    }
    setParamBindIndex(A3) {
      this._paramBindIndex = A3;
    }
    setDirty() {
      this._param && this._param.setDirty(this._paramBindIndex);
    }
    getValue() {
      if (this._param)
        return this._param.getValueFromOp(this._paramBindIndex);
      throw new Error("Cannot call getValue on OperatorOutput that is not connected:", this.__name);
    }
    backPropagateValue(A3) {
      return this._op && (A3 = this._op.backPropagateValue(A3)), A3;
    }
    setClean(A3) {
      this._param && this._param.setCleanFromOp(A3, this._paramBindIndex);
    }
    toJSON(A3) {
      const g3 = this._param ? this._param.getPath() : "";
      return {name: this.__name, paramPath: A3 && A3.makeRelative ? A3.makeRelative(g3) : g3, paramBindIndex: this._paramBindIndex};
    }
    fromJSON(A3, g3) {
      A3.paramPath && (g3 == null || g3.resolvePath(A3.paramPath, (g4) => {
        this.setParam(g4, A3.paramBindIndex);
      }, (g4) => {
        console.warn("OperatorOutput: '" + this.getName() + "'. Unable to connect to:" + A3.paramPath);
      }));
    }
    detach() {
      this.detached = true, this._paramBindIndex = this._param ? this._param.unbindOperatorOutput(this) : -1;
    }
    reattach() {
      this.detached = false, this._param && (this._paramBindIndex = this._param.bindOperatorOutput(this, this._paramBindIndex));
    }
    rebind() {
      this._param && (this._param.unbindOperatorOutput(this), this._paramBindIndex = this._param.bindOperatorOutput(this));
    }
  };
  var Ig = class extends gg {
  };
  var Cg = class extends gg {
  };
  var ig = class extends gg {
  };
  var eg = class extends hA {
    constructor(A3 = "") {
      super(A3), this.__inputs = new Map(), this.__outputs = new Map();
    }
    setDirty() {
      this.__outputs.forEach((A3) => A3.setDirty());
    }
    parameterValueChanged(A3) {
      super.parameterValueChanged(A3), this.setDirty();
    }
    addInput(A3) {
      return A3.setOperator(this), this.__inputs.set(A3.getName(), A3), this.setDirty(), A3;
    }
    removeInput(A3) {
      typeof A3 == "string" && (A3 = this.getInput(A3)), A3.getParam() && A3.setParam(void 0), this.__inputs.delete(A3.getName());
    }
    getNumInputs() {
      return this.__inputs.size;
    }
    getInputByIndex(A3) {
      return Array.from(this.__inputs.values())[A3];
    }
    getInput(A3) {
      const g3 = this.__inputs.get(A3);
      if (!g3)
        throw `Couldn't find an Input with the name of '${A3}'`;
      return g3;
    }
    addOutput(A3) {
      return A3.setOperator(this), this.__outputs.set(A3.getName(), A3), this.setDirty(), A3;
    }
    removeOutput(A3) {
      if (typeof A3 == "string" && (A3 = this.getOutput(A3)), !(A3 instanceof gg))
        throw new Error("removeOutput only accepts string or OperatorInput");
      A3.getParam() && A3.setParam(), this.__outputs.delete(A3.getName());
    }
    getNumOutputs() {
      return this.__outputs.size;
    }
    getOutputByIndex(A3) {
      return Array.from(this.__outputs.values())[A3];
    }
    getOutput(A3) {
      const g3 = this.__outputs.get(A3);
      if (!g3)
        throw new Error(`Couldn't find an Output with the name of '${A3}'`);
      return g3;
    }
    evaluate() {
      throw new Error("Not yet implemented");
    }
    backPropagateValue(A3) {
      return A3;
    }
    toJSON(A3) {
      const g3 = super.toJSON(A3);
      g3.type = this.getClassName();
      const I3 = [];
      this.__inputs.forEach((g4) => {
        I3.push(g4.toJSON(A3));
      }), g3.inputs = I3;
      const C3 = [];
      return this.__outputs.forEach((g4) => {
        C3.push(g4.toJSON(A3));
      }), g3.outputs = C3, g3;
    }
    fromJSON(A3, g3) {
      super.fromJSON(A3, g3), A3.inputs && A3.inputs.forEach((A4, I3) => {
        let C3;
        A4.name ? (C3 = this.getInput(A4.name), C3 || (C3 = this.addInput(A4.name))) : C3 = this.getInputByIndex(I3), C3.fromJSON(A4, g3);
      }), A3.outputs && A3.outputs.forEach((A4, I3) => {
        let C3;
        A4.name ? (C3 = this.getOutput(A4.name), C3 || (C3 = this.addOutput(A4.name))) : C3 = this.getOutputByIndex(I3), C3.fromJSON(A4, g3);
      });
    }
    detach() {
      this.__inputs.forEach((A3) => A3.detach()), this.__outputs.forEach((A3) => A3.detach());
    }
    reattach() {
      this.__inputs.forEach((A3) => A3.reattach()), this.__outputs.forEach((A3) => A3.reattach());
    }
    rebind() {
      this.__outputs.forEach((A3) => A3.rebind());
    }
  };
  var tg = class extends V {
    constructor(A3) {
      super(), this.detached = false, this.name = A3;
    }
    getName() {
      return this.name;
    }
    setOperator(A3) {
      this._op = A3;
    }
    getOperator() {
      return this._op;
    }
    isConnected() {
      return this.param != null;
    }
    getParam() {
      return this.param;
    }
    paramValueChanged() {
      this._op && this._op.setDirty();
    }
    setParam(A3) {
      this.param && this.param.unbindOperatorInput(this), this.param = A3, this.param && this.param.bindOperatorInput(this), this.emit("paramSet", {param: this.param});
    }
    getValue() {
      if (this.param)
        return this.param.value;
      throw new Error("Unable to getValue");
    }
    setValue(A3) {
      this.param && this.param.setValue(A3);
    }
    setDirty() {
      this._op && this._op.setDirty();
    }
    toJSON(A3) {
      const g3 = this.param ? this.param.getPath() : [], I3 = A3 && A3.makeRelative ? A3.makeRelative(g3) : g3;
      return {name: this.name, paramPath: I3};
    }
    fromJSON(A3, g3) {
      A3.paramPath && (g3 == null || g3.resolvePath(A3.paramPath, (A4) => {
        this.setParam(A4);
      }, () => {
        console.warn("OperatorInput: '" + this.getName() + "'. Unable to connect to:" + A3.paramPath);
      }));
    }
    detach() {
      this.param && this.param.unbindOperatorInput(this);
    }
    reattach() {
      this.detached = false, this.param && this.param.bindOperatorInput(this);
    }
  };
  var Bg = class extends tg {
  };
  var og = class extends eg {
    constructor(A3, g3) {
      super("CalcGlobalXfoOperator"), this.parentGlobal = new Bg("ParentGlobal"), this.localXfo = new Bg("LocalXfo"), this.globalXfo = new Cg("GlobalXfo"), this.localXfo.setParam(g3), this.globalXfo.setParam(A3), this.addInput(this.parentGlobal), this.addInput(this.localXfo), this.addOutput(this.globalXfo);
    }
    backPropagateValue(A3) {
      if (this.parentGlobal.isConnected()) {
        const g3 = this.parentGlobal.getValue();
        this.localXfo.setValue(g3.inverse().multiply(A3));
      } else
        this.localXfo.setValue(A3);
    }
    evaluate() {
      const A3 = this.localXfo.getValue();
      if (this.parentGlobal.isConnected()) {
        const g3 = this.parentGlobal.getValue();
        this.globalXfo.setClean(g3.multiply(A3));
      } else
        this.globalXfo.setClean(A3);
    }
  };
  e.register("CalcGlobalXfoOperator", og);
  var sg = class extends kA {
    constructor(A3 = "", g3) {
      super(A3), this.dirty = true, this.treeItem = g3;
    }
    setDirty(A3) {
      return this.dirty || (this.dirty = true, this.emit("valueChanged")), true;
    }
    getValue() {
      return this.dirty && (this.__value = this.treeItem._cleanBoundingBox(), this.dirty = false), this.__value;
    }
    clone() {
      var A3;
      const g3 = new sg(this.name, this.treeItem);
      return g3.value = (A3 = this.__value) === null || A3 === void 0 ? void 0 : A3.clone(), g3;
    }
    loadValue(A3) {
      this.__value = A3.clone();
    }
  };
  var ag = class extends hA {
    constructor(A3) {
      super(A3), this.disableBoundingBox = false, this.__childItems = [], this.__childItemsEventHandlers = [], this.__childItemsMapping = {}, this.__childItemsMappingCorrupt = false, this.globalXfoParam = new PA("GlobalXfo", new m()), this.localXfoParam = new PA("LocalXfo", new m()), this.boundingBoxParam = new sg("BoundingBox", this), this.visibleParam = new fA("Visible", true), this.opacityParam = new JA("Opacity", 1, [0, 1]), this.__highlightMapping = {}, this.__highlights = [], this.__visible = true, this.__visibleCounter = 1, this.__opacity = 1, this.addParameter(this.visibleParam), this.addParameter(this.opacityParam), this.addParameter(this.localXfoParam), this.addParameter(this.globalXfoParam), this.addParameter(this.boundingBoxParam), this.globalXfoOp = new og(this.globalXfoParam, this.localXfoParam), this.globalXfoParam.on("valueChanged", (A4) => {
        this.setBoundingBoxDirty(), this.emit("globalXfoChanged", A4);
      }), this.visibleParam.on("valueChanged", () => {
        this.__visibleCounter += this.visibleParam.value ? 1 : -1, this.updateVisibility();
      }), this.opacityParam.on("valueChanged", () => {
        this.updateOpacity();
      });
    }
    setOwner(A3) {
      if (this.__ownerItem) {
        const A4 = this.__ownerItem;
        if (A4 && A4 instanceof ag) {
          A4.isVisible() || this.__visibleCounter++;
          const g3 = A4.getChildIndex(this);
          g3 >= 0 && A4.unbindChild(g3, this);
        }
      }
      if (super.setOwner(A3), this.__ownerItem) {
        const A4 = this.__ownerItem;
        A4 && (A4.isVisible() || this.__visibleCounter--, this.globalXfoOp.getInput("ParentGlobal").setParam(A4.globalXfoParam));
      } else
        this.globalXfoOp.getInput("ParentGlobal").setParam(void 0);
      this.updateVisibility();
    }
    updatePath() {
      super.updatePath();
      for (const A3 of this.__childItems)
        A3 && A3.updatePath();
    }
    getParentItem() {
      return this.getOwner();
    }
    setParentItem(A3) {
      this.setOwner(A3);
    }
    isVisible() {
      return this.__visibleCounter > 0;
    }
    setVisible(A3) {
      this.visibleParam.value = A3;
    }
    propagateVisibility(A3) {
      this.__visibleCounter += A3, this.updateVisibility();
    }
    updateVisibility() {
      const A3 = this.__visibleCounter > 0;
      if (A3 != this.__visible) {
        this.__visible = A3;
        for (const A4 of this.__childItems)
          A4.propagateVisibility(this.__visible ? 1 : -1);
        this.emit("visibilityChanged", new O(A3));
        const g3 = this.__ownerItem;
        return g3 && g3 instanceof ag && g3.setBoundingBoxDirty(), true;
      }
      return false;
    }
    get opacity() {
      return this.__opacity;
    }
    isOpaque() {
      return this.__opacity > 0.999;
    }
    updateOpacity() {
      const A3 = this.__opacity > 0.999, g3 = this.getParentItem();
      this.__opacity = g3 ? this.opacityParam.value * g3.__opacity : this.opacityParam.value;
      for (const A4 of this.__childItems)
        A4.updateOpacity();
      const I3 = this.__opacity > 0.999;
      this.emit("opacityChanged", new _(I3, A3 != I3));
    }
    addHighlight(A3, g3, I3 = false) {
      if (A3 in this.__highlightMapping)
        if (this.__highlights[this.__highlights.length - 1] != A3) {
          const I4 = this.__highlights.indexOf(A3);
          this.__highlights.splice(I4, 1), this.__highlights.push(A3), this.emit("highlightChanged", {name: A3, color: g3});
        } else
          this.__highlightMapping[A3].isEqual(g3) || (this.__highlightMapping[A3] = g3, this.emit("highlightChanged", {name: A3, color: g3}));
      else
        this.__highlights.push(A3), this.__highlightMapping[A3] = g3, this.emit("highlightChanged", {name: A3, color: g3});
      I3 && this.__childItems.forEach((C3) => {
        C3.addHighlight(A3, g3, I3);
      });
    }
    removeHighlight(A3, g3 = false) {
      if (A3 in this.__highlightMapping) {
        if (this.__highlights[this.__highlights.length - 1] == A3)
          if (this.__highlights.pop(), delete this.__highlightMapping[A3], this.__highlights.length > 0) {
            const A4 = this.__highlights[this.__highlights.length - 1], g4 = this.__highlightMapping[A4];
            this.emit("highlightChanged", {name: A4, color: g4});
          } else
            this.emit("highlightChanged");
        else {
          const g4 = this.__highlights.indexOf(A3);
          this.__highlights.splice(g4, 1), delete this.__highlightMapping[A3], this.emit("highlightChanged");
        }
        g3 && this.__childItems.forEach((I3) => {
          I3.removeHighlight(A3, g3);
        });
      }
    }
    getHighlight() {
      return this.__highlights.length == 0 ? null : this.__highlightMapping[this.__highlights[this.__highlights.length - 1]];
    }
    getHighlightName() {
      return this.__highlights.length == 0 ? null : this.__highlights[this.__highlights.length - 1];
    }
    isHighlighted() {
      return this.__highlights.length > 0;
    }
    _cleanBoundingBox() {
      const A3 = new b();
      return this.__childItems.forEach((g3) => {
        if (g3.isVisible()) {
          const I3 = g3.boundingBoxParam.value;
          I3 && A3.addBox3(I3);
        }
      }), A3;
    }
    setBoundingBoxDirty() {
      this.boundingBoxParam && this.boundingBoxParam.setDirty(-1);
      const A3 = this.__ownerItem;
      A3 && A3 instanceof ag && A3.setBoundingBoxDirty();
    }
    getChildren() {
      return this.__childItems;
    }
    getNumChildren() {
      return this.__childItems.length;
    }
    generateUniqueName(A3) {
      if (!(A3 in this.__childItemsMapping))
        return A3;
      let g3 = 1;
      A3.length > 4 && !Number.isNaN(parseInt(A3.substring(A3.length - 4))) ? g3 = parseInt(A3.substr(A3.length - 4)) : A3.length > 3 && !Number.isNaN(parseInt(A3.substring(A3.length - 3))) ? g3 = parseInt(A3.substr(A3.length - 3)) : A3.length > 2 && !Number.isNaN(parseInt(A3.substring(A3.length - 2))) && (g3 = parseInt(A3.substr(A3.length - 2)));
      const I3 = [];
      for (const A4 of this.__childItems)
        A4 && I3.push(A4.getName());
      let C3 = A3;
      for (; ; ) {
        let i3 = "" + g3;
        for (; i3.length < 2; )
          i3 = "0" + i3;
        if (C3 = A3 + i3, !I3.includes(C3))
          break;
        g3++;
      }
      return C3;
    }
    updateChildNameMapping(A3) {
      for (let g3 = A3; g3 < this.__childItems.length; g3++)
        this.__childItemsMapping[this.__childItems[g3].getName()] = g3;
    }
    childNameChanged(A3) {
      if (this.__childItemsMappingCorrupt)
        this.updateChildNameMapping(0), this.__childItemsMappingCorrupt = false;
      else {
        const g3 = this.__childItemsMapping[A3.oldName];
        this.__childItemsMapping[A3.newName] != null && (this.__childItemsMappingCorrupt = true), delete this.__childItemsMapping[A3.oldName], this.__childItemsMapping[A3.newName] = g3;
      }
    }
    insertChild(A3, g3, I3 = false, C3 = true) {
      if (A3.getName() in this.__childItemsMapping) {
        if (!C3)
          throw new Error("Item '" + A3.getName() + "' is already a child of :" + this.getPath());
        A3.setName(this.generateUniqueName(A3.getName()));
      }
      if (!(A3 instanceof ag))
        throw new Error("Object is is not a tree item :" + A3);
      const i3 = {};
      if (i3.nameChanged = A3.on("nameChanged", (A4) => {
        this.childNameChanged(A4);
      }), I3) {
        const g4 = this.globalXfoParam.value, I4 = A3.globalXfoParam.value, C4 = g4.inverse().multiply(I4);
        A3.localXfoParam.value = C4;
      }
      this.setBoundingBoxDirty(), this.__highlights.forEach((g4) => {
        const I4 = this.__highlightMapping[g4];
        A3.addHighlight(g4, I4, true);
      }), this.__childItems.splice(g3, 0, A3), this.__childItemsEventHandlers.splice(g3, 0, i3);
      const e3 = A3.getName();
      return this.__childItemsMapping[e3] && (this.__childItemsMappingCorrupt = true), this.__childItemsMapping[e3] = g3, this.updateChildNameMapping(g3), A3.setOwner(this), this.emit("childAdded", new oA(g3, A3)), A3;
    }
    addChild(A3, g3 = true, I3 = true) {
      const C3 = this.__childItems.length;
      return this.insertChild(A3, C3, g3, I3), A3;
    }
    getChild(A3) {
      return this.__childItems[A3];
    }
    getChildByName(A3) {
      const g3 = this.__childItemsMapping[A3];
      return g3 != null ? this.__childItems[g3] : null;
    }
    getChildNames() {
      const A3 = [];
      for (let g3 = 0; g3 < this.__childItems.length; g3++) {
        const I3 = this.__childItems[g3];
        I3 != null && (A3[g3] = I3.getName());
      }
      return A3;
    }
    unbindChild(A3, g3) {
      const I3 = this.__childItemsEventHandlers[A3];
      for (const A4 in I3)
        g3.removeListenerById(A4, I3[A4]);
      this.__childItems.splice(A3, 1), this.__childItemsEventHandlers.splice(A3, 1), delete this.__childItemsMapping[g3.getName()], this.updateChildNameMapping(A3), this.setBoundingBoxDirty(), this.emit("childRemoved", {childItem: g3, index: A3});
    }
    removeChild(A3) {
      const g3 = this.__childItems[A3];
      g3 && (this.unbindChild(A3, g3), g3.setOwner(void 0));
    }
    removeChildByName(A3) {
      const g3 = this.__childItemsMapping[A3];
      if (g3 != null)
        return this.removeChild(g3);
    }
    removeChildByHandle(A3) {
      const g3 = this.__childItems.indexOf(A3);
      if (g3 == -1)
        throw new Error("Error in removeChildByHandle. Child not found:" + A3.getName());
      this.removeChild(g3);
    }
    removeAllChildren() {
      let A3 = this.__childItems.length;
      for (; A3--; )
        this.removeChild(A3);
      this.setBoundingBoxDirty();
    }
    getChildIndex(A3) {
      return this.__childItems.indexOf(A3);
    }
    resolvePath(A3, g3 = 0, I3 = false) {
      if (typeof A3 == "string" && (A3 = A3.split("/")), g3 == 0) {
        if (A3[0] == "." || A3[0] == this.__name)
          g3++;
        else if (A3[0] == "..") {
          if (this.__ownerItem)
            return this.__ownerItem.resolvePath(A3, g3 + 1);
          if (I3)
            throw Error("this.__ownerItem is undefined");
          console.warn("this.__ownerItem is undefined");
        }
      }
      if (g3 == A3.length)
        return this;
      const C3 = A3[g3], i3 = this.getChildByName(C3);
      if (i3 == null) {
        const I4 = this.getParameter(A3[g3]);
        if (I4)
          return I4;
        throw new Error(`Unable to resolve path : [${A3.toString()}] after: ${this.getName()} 
No child or parameter called : "${A3[g3]}"`);
      }
      return i3.resolvePath(A3, g3 + 1);
    }
    traverse(A3, g3 = true) {
      const I3 = (A4, g4) => {
        const I4 = A4.getChildren();
        for (const A5 of I4)
          A5 && C3(A5, g4 + 1);
      }, C3 = (g4, C4) => {
        A3(g4, C4) != 0 && I3(g4, C4);
      };
      g3 ? C3(this, 1) : I3(this, 0);
    }
    onPointerDown(A3) {
      this.emit("pointerDown", A3);
      const g3 = this.__ownerItem;
      A3.propagating && g3 && g3.onPointerDown(A3);
    }
    onPointerUp(A3) {
      this.emit("pointerUp", A3);
      const g3 = this.__ownerItem;
      A3.propagating && g3 && g3.onPointerUp(A3);
    }
    onPointerMove(A3) {
      this.emit("pointerMove", A3);
      const g3 = this.__ownerItem;
      A3.propagating && g3 && g3.onPointerMove(A3);
    }
    onPointerEnter(A3) {
      this.emit("pointerEnter", A3);
      const g3 = this.__ownerItem;
      A3.propagating && g3 && g3.onPointerEnter(A3);
    }
    onPointerLeave(A3) {
      this.emit("pointerLeave", A3);
      const g3 = this.__ownerItem;
      A3.propagating && g3 && g3.onPointerLeave(A3);
    }
    onWheel(A3) {
      this.emit("mouseWheel", A3);
      const g3 = this.__ownerItem;
      A3.propagating && g3 && g3.onWheel(A3);
    }
    onTouchCancel(A3) {
      this.emit("touchCancel", A3);
      const g3 = this.__ownerItem;
      A3.propagating && g3 && g3.onTouchCancel(A3);
    }
    toJSON(A3) {
      let g3 = super.toJSON(A3);
      const I3 = {};
      for (const g4 of this.__childItems)
        if (g4) {
          const C3 = g4.toJSON(A3);
          C3 && (I3[g4.getName()] = C3);
        }
      return Object.keys(I3).length > 0 && (g3 ? g3.children = I3 : g3 = {name: this.__name, children: I3}), g3;
    }
    fromJSON(A3, g3, I3) {
      if (super.fromJSON(A3, g3), A3.children != null) {
        const I4 = A3.children;
        if (Array.isArray(I4))
          for (const A4 of I4) {
            let I5 = this.getChildByName(A4.name);
            I5 ? I5.fromJSON(A4, g3) : A4.type && (I5 = e.constructClass(A4.type), I5 && (I5.fromJSON(A4, g3), this.addChild(I5, false, false)));
          }
        else
          for (const A4 in I4) {
            const C3 = I4[A4];
            let i3 = this.getChildByName(A4);
            i3 ? i3.fromJSON(C3, g3) : C3.type && (i3 = e.constructClass(C3.type), i3 && (i3.fromJSON(C3, g3), this.addChild(i3, false, false)));
          }
      }
    }
    readBinary(A3, g3) {
      super.readBinary(A3, g3);
      const I3 = A3.loadUInt8();
      this.setVisible((2 & I3) != 0);
      if (4 & I3) {
        const g4 = new m();
        if (g4.tr = A3.loadFloat32Vec3(), g4.ori = A3.loadFloat32Quat(), 32 & I3)
          g4.sc = A3.loadFloat32Vec3();
        else {
          const I4 = A3.loadFloat32();
          g4.sc.set(I4, I4, I4);
        }
        this.localXfoParam.value = g4;
      }
      8 & I3 && this.boundingBoxParam.loadValue(new b(A3.loadFloat32Vec3(), A3.loadFloat32Vec3()));
      const C3 = A3.loadUInt32();
      if (C3 > 0) {
        const I4 = A3.loadUInt32Array(C3);
        for (let i3 = 0; i3 < C3; i3++)
          try {
            A3.seek(I4[i3]);
            let C4 = A3.loadStr();
            const t3 = e.constructClass(C4);
            if (!t3) {
              const g4 = A3.loadStr();
              console.warn("Unable to construct child:" + g4 + " of type:" + C4);
              continue;
            }
            A3.seek(I4[i3]), t3.readBinary(A3, g3), this.addChild(t3, false, true);
          } catch (A4) {
            console.warn("Error loading tree item: ", A4);
          }
      }
    }
    clone(A3) {
      const g3 = new ag("");
      return g3.copyFrom(this, A3), g3;
    }
    copyFrom(A3, g3) {
      super.copyFrom(A3, g3), A3.getChildren().forEach((A4) => {
        A4 && this.addChild(A4.clone(g3), false, false);
      });
    }
  };
  e.register("TreeItem", ag);
  var lg = class extends NA {
    constructor(A3 = "", g3) {
      super(A3, void 0, "TreeItem"), this.listenerIDs = {}, this.owner = new ag(""), this.filterFn = g3;
    }
    emitTreeItemGlobalXfoChanged(A3) {
      this.emit("treeItemGlobalXfoChanged", A3);
    }
    setOwner(A3) {
      this.owner = A3;
    }
    getOwner() {
      return this.owner;
    }
    setFilterFn(A3) {
      this.filterFn = A3;
    }
    getFilterFn() {
      return this.filterFn;
    }
    setValue(A3) {
      this.filterFn && !this.filterFn(A3) || this.__value !== A3 && (this.__value && this.__value.removeListenerById("globalXfoChanged", this.listenerIDs.globalXfoChanged), this.__value = A3, this.__value && (this.listenerIDs.globalXfoChanged = this.__value.on("globalXfoChanged", (A4) => {
        this.emitTreeItemGlobalXfoChanged(A4);
      })), this.emit("valueChanged"));
    }
    toJSON(A3) {
      var g3;
      return {value: A3.makeRelative((g3 = this.__value) === null || g3 === void 0 ? void 0 : g3.getPath())};
    }
    fromJSON(A3, g3) {
      A3.value != null ? g3.resolvePath(A3.value, (A4) => {
        this.setValue(A4);
      }, () => {
        console.warn("Unable to resolve tree item parameter value:" + A3.paramPath);
      }) : console.warn("Invalid Parameter JSON");
    }
    clone(A3) {
      const g3 = new lg(this.name, this.filterFn);
      return this.__value && g3.setValue(this.__value.clone(A3)), g3;
    }
  };
  e.register("TreeItemParameter", lg);
  var ng = class extends R {
    constructor(A3, g3) {
      super(), this.index = g3, this.item = A3;
    }
  };
  var dg = class extends NA {
    constructor(A3 = "", g3) {
      super(A3, new Set(), "TreeItem"), this.filterFn = g3;
    }
    setFilterFn(A3) {
      this.filterFn = A3;
    }
    getFilterFn() {
      return this.filterFn;
    }
    getItem(A3) {
      return Array.from(this.__value)[A3];
    }
    addItem(A3, g3 = true) {
      if (this.filterFn && !this.filterFn(A3))
        return void console.warn("ItemSet __filterFn rejecting item:", A3.getPath());
      this.__value.add(A3);
      const I3 = Array.from(this.__value).indexOf(A3);
      return this.emit("itemAdded", new ng(A3, I3)), g3 && this.emit("valueChanged"), I3;
    }
    addItems(A3, g3 = true) {
      A3.forEach((A4) => this.addItem(A4, false)), g3 && this.emit("valueChanged");
    }
    removeItem(A3, g3 = true) {
      const I3 = Array.from(this.__value)[A3];
      return this.__value.delete(I3), this.emit("itemRemoved", new ng(I3, A3)), g3 && this.emit("valueChanged"), I3;
    }
    setItems(A3, g3 = true) {
      const I3 = Array.from(this.__value);
      for (let g4 = I3.length - 1; g4 >= 0; g4--) {
        const C3 = I3[g4];
        A3.has(C3) || this.removeItem(g4, false);
      }
      for (const g4 of A3)
        this.__value.has(g4) || this.addItem(g4, false);
      g3 && this.emit("valueChanged");
    }
    clearItems(A3 = true) {
      this.__value.clear(), A3 && this.emit("valueChanged");
    }
    getNumItems() {
      return this.__value.size;
    }
    toJSON(A3) {
      this.__value || (this.__value = new Set());
      const g3 = [];
      if (A3)
        for (const A4 of this.__value)
          g3.push(A4.getPath());
      return {value: g3};
    }
    fromJSON(A3, g3) {
      if (g3)
        for (const I3 in A3.value) {
          const A4 = g3.resolvePath(I3);
          this.__value.add(A4);
        }
    }
    clone() {
      return new dg(this.name, this.filterFn);
    }
  };
  var hg = class extends NA {
    constructor(A3 = "", g3) {
      super(A3, g3, "Geometry"), this.listenerIDs = {}, g3 && this.setValue(g3);
    }
    emitBoundingBoxDirtied(A3) {
      this.emit("boundingBoxChanged", A3);
    }
    setValue(A3) {
      this.__value !== A3 && (this.__value && this.__value.removeListenerById("boundingBoxChanged", this.listenerIDs.boundingBoxChanged), this.__value = A3, this.__value && (this.listenerIDs.boundingBoxChanged = this.__value.on("boundingBoxChanged", (A4) => {
        this.emitBoundingBoxDirtied(A4);
      })), this.emit("valueChanged"));
    }
    loadValue(A3) {
      this.__value && this.__value.removeListenerById("boundingBoxChanged", this.listenerIDs.boundingBoxChanged), this.__value = A3, this.__value && (this.listenerIDs.boundingBoxChanged = this.__value.on("boundingBoxChanged", (A4) => {
        this.emitBoundingBoxDirtied(A4);
      }));
    }
    toJSON(A3) {
      var g3;
      return {name: this.name, value: (g3 = this.__value) === null || g3 === void 0 ? void 0 : g3.toJSON(A3)};
    }
    fromJSON(A3, g3) {
      A3.name && (this.name = A3.name);
      const I3 = e.constructClass(A3.value.type);
      I3.fromJSON(A3.value, g3), this.__value = I3;
    }
    clone() {
      return new hg(this.name, this.__value);
    }
  };
  e.register("GeometryParameter", hg);
  var cg = class extends NA {
    constructor(A3 = "") {
      super(A3, "", "FilePath");
    }
    getFilename() {
      if (!this.__value)
        throw "No file value";
      return this.__value.lastIndexOf("/") > -1 ? this.__value.substring(this.__value.lastIndexOf("/") + 1) : "";
    }
    getExt() {
      const A3 = this.getFilename(), g3 = A3.lastIndexOf(".");
      if (g3 != -1)
        return A3.substring(g3).toLowerCase();
    }
    getStem() {
      const A3 = this.getFilename();
      if (A3) {
        const g3 = A3.split(".");
        return g3.length == 2 ? g3[0] : A3;
      }
      return null;
    }
    setValue(A3) {
      if (!A3)
        throw new Error("Invalid value for setValue.");
      A3 != this.__value && (this.__value = A3, this.emit("valueChanged"));
    }
    toJSON(A3) {
      return {value: this.__value};
    }
    fromJSON(A3, g3) {
      A3.value && (this.__value = A3.value);
    }
    clone() {
      const A3 = new cg(this.name);
      return this.__value && A3.setValue(this.__value), A3;
    }
  };
  e.register("FilePathParameter", cg);
  var rg = class extends NA {
    constructor(A3 = "", g3) {
      super(A3, g3, "Material"), this.listenerIDs = {}, g3 && this.setValue(g3);
    }
    valueParameterValueChanged(A3) {
      this.emit("valueParameterValueChanged", A3);
    }
    setValue(A3) {
      this.__value !== A3 && (this.__value && this.__value.removeListenerById("parameterValueChanged", this.listenerIDs.parameterValueChanged), this.__value = A3, this.__value && (this.listenerIDs.parameterValueChanged = this.__value.on("parameterValueChanged", (A4) => {
        this.valueParameterValueChanged(A4);
      })), this.emit("valueChanged"));
    }
    loadValue(A3) {
      this.__value && this.__value.removeListenerById("parameterValueChanged", this.listenerIDs.parameterValueChanged), this.__value = A3, this.__value && (this.listenerIDs.parameterValueChanged = this.__value.on("parameterValueChanged", (A4) => {
        this.valueParameterValueChanged(A4);
      }));
    }
    toJSON(A3) {
      let g3 = {};
      return g3.name = this.name, this.__value && (g3 = {value: A3 && A3.onlyPath ? this.__value.getPath() : this.__value.toJSON(A3)}), g3;
    }
    fromJSON(A3, g3) {
      if (A3.value != null)
        if (A3.value instanceof Array || A3.value instanceof String) {
          if (g3 && g3.assetItem) {
            const I3 = g3.assetItem.getMaterialLibrary().getMaterial(A3.value instanceof Array ? A3.value[1] : A3.value);
            I3 && this.loadValue(I3);
          }
        } else {
          const I3 = e.constructClass(A3.value.type);
          A3.value && I3.fromJSON(A3.value, g3), this.loadValue(I3);
        }
      else
        console.warn("Invalid Parameter JSON");
    }
    clone() {
      return new rg(this.name, this.__value);
    }
  };
  e.register("MaterialParameter", rg);
  var Gg = class extends hA {
    constructor(A3) {
      super(A3), this.width = 0, this.height = 0, this.format = "RGB", this.type = "UNSIGNED_BYTE", this.loaded = false, this.mipMapped = true, this.wrapS = "REPEAT", this.wrapT = "REPEAT", this.minFilter = "LINEAR", this.magFilter = "LINEAR", this.alphaFromLuminance = false, this.on("parameterValueChanged", () => {
        this.emit("updated");
      });
    }
    isLoaded() {
      return this.loaded;
    }
    getParams() {
      return {type: this.type, format: this.format, width: this.width, height: this.height, wrapS: this.wrapS, wrapT: this.wrapT, minFilter: this.minFilter, magFilter: this.magFilter, mipMapped: this.mipMapped, alphaFromLuminance: this.alphaFromLuminance};
    }
  };
  var mg = class extends JA {
    constructor(A3 = "", g3, I3) {
      super(A3, g3, I3);
    }
    getImage() {
      return this.image;
    }
    setImage(A3) {
      const g3 = () => {
        this.emit("textureDisconnected");
      };
      A3 ? (this.image != null && this.image !== A3 && g3(), this.image = A3, this.emit("textureConnected"), this.emit("valueChanged", {mode: 0})) : this.image != null && (g3(), this.image = void 0, this.emit("textureDisconnected"));
    }
    setValue(A3) {
      A3 instanceof Gg ? this.setImage(A3) : super.setValue(A3);
    }
    readBinary(A3, g3) {
      super.readBinary(A3, g3);
      const I3 = A3.loadStr();
      I3 != "" && (console.log("Load Texture"), this.setImage(g3.assetItem.materialLibrary.getImage(I3)));
    }
    clone() {
      return new mg(this.name, this.__value, this.range);
    }
  };
  e.register("MaterialFloatParam", mg), function(A3) {
    A3.Gamma = "Gamma", A3.Linear = "Linear";
  }(pA || (pA = {}));
  var Qg = class extends xA {
    constructor(A3, g3) {
      super(A3, g3), this.listenerIDs = {}, this.colorSpace = pA.Gamma;
    }
    getImage() {
      return this.image;
    }
    imageUpdated() {
      this.emit("valueChanged");
    }
    setImage(A3) {
      const g3 = () => {
        this.image && (this.image.removeListenerById("updated", this.listenerIDs.updated), this.image = void 0), this.emit("textureDisconnected");
      };
      A3 ? (this.image != null && this.image !== A3 && g3(), this.image = A3, this.listenerIDs.updated = this.image.on("updated", () => {
        this.imageUpdated();
      }), this.emit("textureConnected"), this.emit("valueChanged")) : this.image != null && (g3(), this.image = void 0, this.emit("textureDisconnected"));
    }
    setValue(A3) {
      A3 instanceof Gg ? this.setImage(A3) : super.setValue(A3);
    }
    readBinary(A3, g3) {
      super.readBinary(A3, g3);
      const I3 = A3.loadStr();
      I3 != "" && this.setImage(g3.assetItem.materialLibrary.getImage(I3)), this.colorSpace = pA.Linear;
    }
    clone() {
      var A3;
      const g3 = new Qg(this.name, (A3 = this.__value) === null || A3 === void 0 ? void 0 : A3.clone());
      return g3.colorSpace = this.colorSpace, g3;
    }
  };
  function Eg(A3, g3) {
    return !A3.some((A4, I3) => Math.abs(g3[I3] - A4) > 1e-3);
  }
  e.register("MaterialColorParam", Qg);
  var bg = class extends u {
    constructor(A3, g3) {
      super(), this.data = new Float32Array(0), this.dataTypeName = A3, this.stride = g3, this.initRange(0), this.splits = {}, this.splitValues = [];
    }
    setMesh(A3) {
      this.mesh = A3;
    }
    asArray() {
      return this.data;
    }
    getDataTypeName() {
      return this.dataTypeName;
    }
    getCount() {
      return this.data.length / this.stride;
    }
    setCount(A3) {
      const g3 = this.data.length, I3 = A3 * this.stride;
      if (I3 > g3) {
        const A4 = new Float32Array(I3);
        A4.set(this.data, 0), this.data = A4, this.initRange(g3);
      } else
        I3 < g3 && (this.data = this.data.slice(0, I3));
      this.splits = {}, this.splitValues = [];
    }
    initRange(A3) {
      for (let g3 = A3; g3 < this.data.length; g3++)
        this.data[g3] = Number.NaN;
    }
    get numElements() {
      return this.stride;
    }
    getFloat32Value(A3) {
      return this.data[A3];
    }
    setFloat32Value(A3, g3) {
      this.data[A3] = g3;
    }
    getSplits() {
      return this.splits;
    }
    getFaceVertexValueRef_array(A3, g3) {
      const I3 = this.mesh.getFaceVertexIndex(A3, g3);
      return I3 in this.splits && A3 in this.splits[I3] ? this.splitValues[this.splits[I3][A3]] : this.data.subarray(I3 * this.stride, (I3 + 1) * this.stride);
    }
    setFaceVertexValue_array(A3, g3, I3) {
      const C3 = this.mesh.getFaceVertexIndex(A3, g3);
      this.setFaceVertexValue_ByVertexIndex(A3, C3, I3);
    }
    setFaceVertexValue_ByVertexIndex(A3, g3, I3) {
      const C3 = this.data.subarray(g3 * this.stride, (g3 + 1) * this.stride);
      if (function(A4) {
        for (let g4 = 0; g4 < A4.length; g4++)
          if (!Number.isNaN(A4[g4]))
            return true;
        return false;
      }(C3))
        if (Eg(C3, I3))
          ;
        else {
          if (g3 in this.splits) {
            const C4 = this.splits[g3];
            for (const g4 in C4) {
              const i3 = C4[g4];
              if (Eg(this.splitValues[i3], I3))
                return void (C4[A3] = i3);
            }
            if (A3 in this.splits[g3])
              return void (this.splitValues[this.splits[g3][A3]] = I3);
          } else
            this.splits[g3] = {};
          this.splits[g3][A3] = this.splitValues.length, this.splitValues.push(I3);
        }
      else
        C3.set(I3);
    }
    setSplitVertexValue_array(A3, g3, I3) {
      if (A3 in this.splits || (this.splits[A3] = {}), g3 in this.splits[A3]) {
        if (Eg(this.splitValues[this.splits[A3][g3]], I3))
          return;
        console.warn("Face Vertex Already Split with different value");
      }
      this.splits[A3][g3] = this.splitValues.length, this.splitValues.push(I3);
    }
    setSplitVertexValues(A3, g3, I3) {
      A3 in this.splits || (this.splits[A3] = {});
      const C3 = this.splitValues.length;
      this.splitValues.push(I3);
      for (const I4 of g3)
        this.splits[A3][I4] = C3;
    }
    generateSplitValues(A3, g3) {
      if (g3 == 0)
        return this.data;
      const I3 = this.getCount(), C3 = new Float32Array((I3 + g3) * this.stride);
      C3.set(this.data);
      for (const g4 in A3) {
        const i3 = A3[g4];
        for (const A4 in i3) {
          const e3 = I3 + i3[A4];
          if (g4 in this.splits && A4 in this.splits[g4]) {
            const I4 = this.splits[g4][A4];
            this.splitValues[I4].forEach((A5, g5) => {
              C3[e3 * this.stride + g5] = A5;
            });
          } else {
            const A5 = parseInt(g4);
            for (let g5 = 0; g5 < this.stride; g5++)
              C3[e3 * this.stride + g5] = this.data[A5 * this.stride + g5];
          }
        }
      }
      return C3;
    }
    toJSON(A3) {
      return {data: this.data, dataType: this.dataTypeName, length: this.data.length / this.stride};
    }
    fromJSON(A3) {
      const g3 = A3.data.map((A4) => r.isNumeric(A4) ? A4 : Number.POSITIVE_INFINITY);
      this.data = Float32Array.from(g3);
    }
    loadSplitValues(A3) {
      const g3 = A3.loadUInt32Array();
      if (g3.length == 0)
        return;
      let I3 = 0, C3 = 0;
      for (; ; ) {
        const A4 = g3[I3++], i4 = g3[I3++], e4 = {};
        for (let A5 = 0; A5 < i4; A5++) {
          const A6 = g3[I3++], i5 = g3[I3++];
          e4[A6] = i5, i5 >= C3 && (C3 = i5 + 1);
        }
        if (this.splits[A4] = e4, I3 >= g3.length)
          break;
      }
      const i3 = this.stride, e3 = A3.loadFloat32Array(C3 * i3);
      this.splitValues = [];
      for (let A4 = 0; A4 < C3; A4++) {
        const g4 = e3.slice(A4 * i3, A4 * i3 + i3);
        this.splitValues.push(g4);
      }
    }
    toString() {
      return JSON.stringify(this.toJSON(), null, 2);
    }
    genBuffer() {
      return {values: this.data, count: this.getCount(), dataType: this.dataTypeName, normalized: this.normalized};
    }
  };
  var Zg = class extends bg {
    constructor() {
      super("Vec3", 3), this.normalized = false;
    }
    getValueRef(A3) {
      if (A3 >= this.data.length / this.stride)
        throw new Error("Invalid vertex index:" + A3 + ". Num Vertices:" + this.data.length / 3);
      const g3 = A3 * this.stride, I3 = this.data.subarray(g3, g3 + this.stride);
      return new o(I3);
    }
    getValue(A3) {
      if (A3 >= this.data.length / this.stride)
        throw new Error("Invalid vertex index:" + A3 + ". Num Vertices:" + this.data.length / 3);
      const g3 = A3 * this.stride, I3 = this.data.slice(g3, g3 + this.stride);
      return new o(I3);
    }
    setValue(A3, g3) {
      if (A3 >= this.data.length / this.stride)
        throw new Error("Invalid vertex index:" + A3 + ". Num Vertices:" + this.data.length / 3);
      const I3 = A3 * this.stride;
      this.data.set(g3.asArray(), I3);
    }
    getFaceVertexValueRef(A3, g3) {
      const I3 = this.getFaceVertexValueRef_array(A3, g3);
      return new o(I3);
    }
    setFaceVertexValue(A3, g3, I3) {
      this.setFaceVertexValue_array(A3, g3, I3.asArray());
    }
    setSplitVertexValue(A3, g3, I3) {
      this.setSplitVertexValue_array(A3, g3, I3.asArray());
    }
  };
  e.register("Vec3Attribute", Zg);
  var yg = class extends bg {
    constructor() {
      super("Vec2", 2), this.normalized = false;
    }
    getValueRef(A3) {
      if (A3 >= this.data.length / this.stride)
        throw new Error("Invalid vertex index:" + A3 + ". Num Vertices:" + this.data.length / 3);
      const g3 = A3 * this.stride, I3 = this.data.subarray(g3, g3 + this.stride);
      return new B(I3);
    }
    getValue(A3) {
      if (A3 >= this.data.length / this.stride)
        throw new Error("Invalid vertex index:" + A3 + ". Num Vertices:" + this.data.length / 3);
      const g3 = A3 * this.stride, I3 = this.data.slice(g3, g3 + this.stride);
      return new B(I3);
    }
    setValue(A3, g3) {
      if (A3 >= this.data.length / this.stride)
        throw new Error("Invalid vertex index:" + A3 + ". Num Vertices:" + this.data.length / 3);
      const I3 = A3 * this.stride;
      this.data.set(g3.asArray(), I3);
    }
    getFaceVertexValueRef(A3, g3) {
      const I3 = this.getFaceVertexValueRef_array(A3, g3);
      return new B(I3);
    }
    setFaceVertexValue(A3, g3, I3) {
      this.setFaceVertexValue_array(A3, g3, I3.asArray());
    }
    setSplitVertexValue(A3, g3, I3) {
      this.setSplitVertexValue_array(A3, g3, I3.asArray());
    }
  };
  e.register("Vec2Attribute", yg);
  var ug = (A3, g3, I3, C3, i3) => {
    for (let e3 = A3[0]; e3 < A3[1]; e3++) {
      const A4 = new o(C3[3 * e3 + 0] / 255, C3[3 * e3 + 1] / 255, C3[3 * e3 + 2] / 255);
      A4.multiplyInPlace(I3), A4.addInPlace(g3), i3.setValue(e3, A4);
    }
  };
  var Rg = (A3, g3, I3, C3, i3) => {
    for (let e3 = A3[0]; e3 < A3[1]; e3++) {
      const A4 = new o(C3[3 * e3 + 0] / 65535, C3[3 * e3 + 1] / 65535, C3[3 * e3 + 2] / 65535);
      A4.multiplyInPlace(I3), A4.addInPlace(g3), i3.setValue(e3, A4);
    }
  };
  var Vg = (A3, g3, I3, C3, i3) => {
    I3.isNull() && I3.set(1, 1, 1);
    for (let e3 = A3[0]; e3 < A3[1]; e3++) {
      const A4 = new o(C3[3 * e3 + 0] / 255, C3[3 * e3 + 1] / 255, C3[3 * e3 + 2] / 255);
      A4.multiplyInPlace(I3), A4.addInPlace(g3), A4.normalizeInPlace(), i3.setValue(e3, A4);
    }
  };
  var Fg = (A3, g3, I3, C3, i3) => {
    for (let e3 = A3[0]; e3 < A3[1]; e3++) {
      const A4 = new B(C3[2 * e3 + 0] / 255, C3[2 * e3 + 1] / 255);
      A4.multiplyInPlace(I3), A4.addInPlace(g3), i3.setValue(e3, A4);
    }
  };
  var Sg = (A3, g3, I3, C3, i3) => {
    for (let e3 = A3[0]; e3 < A3[1]; e3++) {
      const A4 = new B(C3[2 * e3 + 0] / 65535, C3[2 * e3 + 1] / 65535);
      A4.multiplyInPlace(I3), A4.addInPlace(g3), i3.setValue(e3, A4);
    }
  };
  var wg = class extends nA {
    constructor() {
      super(), this.__boundingBox = new b(), this.__boundingBoxDirty = true, this.__metaData = new Map(), this.__name = "", this.__numVertices = 0, this.__vertexAttributes = new Map(), this.debugColor = new l(1, 0, 0, 1), this.name = "", this.addVertexAttribute("positions", new Zg());
    }
    clear() {
      this.setNumVertices(0);
    }
    setDebugName(A3) {
      this.name = A3;
    }
    addVertexAttribute(A3, g3) {
      g3.setCount(this.__numVertices), this.__vertexAttributes.set(A3, g3);
    }
    hasVertexAttribute(A3) {
      return this.__vertexAttributes.has(A3);
    }
    getVertexAttribute(A3) {
      return this.__vertexAttributes.get(A3);
    }
    getVertexAttributes() {
      const A3 = {};
      for (const [g3, I3] of this.__vertexAttributes.entries())
        A3[g3] = I3;
      return A3;
    }
    get positions() {
      return this.__vertexAttributes.get("positions");
    }
    numVertices() {
      return this.__numVertices;
    }
    getNumVertices() {
      return this.__numVertices;
    }
    setNumVertices(A3) {
      this.__numVertices = A3, this.__vertexAttributes.forEach((A4) => A4.setCount(this.__numVertices)), this.setBoundingBoxDirty();
    }
    getBoundingBox() {
      return this.__boundingBoxDirty && this.updateBoundingBox(), this.__boundingBox;
    }
    setBoundingBoxDirty() {
      this.__boundingBoxDirty = true, this.emit("boundingBoxChanged");
    }
    updateBoundingBox() {
      const A3 = this.positions, g3 = new b();
      if (A3) {
        const I3 = A3.getCount();
        for (let C3 = 0; C3 < I3; C3++)
          g3.addPoint(A3.getValueRef(C3));
      }
      this.__boundingBox = g3, this.__boundingBoxDirty = false;
    }
    getMetadata(A3) {
      return this.__metaData.get(A3);
    }
    hasMetadata(A3) {
      return this.__metaData.has(A3);
    }
    setMetadata(A3, g3) {
      this.__metaData.set(A3, g3);
    }
    deleteMetadata(A3) {
      this.__metaData.delete(A3);
    }
    genBuffers(A3) {
      const g3 = {};
      for (const [A4, I3] of this.__vertexAttributes)
        g3[A4] = I3.genBuffer();
      return {numVertices: this.numVertices(), attrBuffers: g3};
    }
    freeBuffers() {
    }
    loadBaseGeomBinary(A3, g3) {
      this.name = A3.loadStr();
      const I3 = A3.loadUInt8();
      this.debugColor = A3.loadRGBFloat32Color();
      const C3 = A3.loadUInt32();
      this.__boundingBox.set(A3.loadFloat32Vec3(), A3.loadFloat32Vec3()), this.setNumVertices(C3);
      const i3 = this.positions;
      let e3, t3;
      2 & I3 && (e3 = this.getVertexAttribute("normals"), e3 || (e3 = new Zg(), this.addVertexAttribute("normals", e3))), 4 & I3 && (t3 = this.getVertexAttribute("texCoords"), t3 || (t3 = new yg(), this.addVertexAttribute("texCoords", t3)));
      const B3 = A3.loadUInt32();
      if (B3 == 1) {
        {
          const I4 = this.__boundingBox;
          if (g3.versions["zea-engine"].compare([3, 9, 1]) >= 0) {
            const g4 = A3.loadUInt16Array(3 * C3);
            Rg([0, C3], I4.p0, I4.diagonal(), g4, i3);
          } else {
            const g4 = A3.loadUInt8Array(3 * C3);
            ug([0, C3], I4.p0, I4.diagonal(), g4, i3);
          }
        }
        if (e3) {
          const g4 = new b(A3.loadFloat32Vec3(), A3.loadFloat32Vec3()), I4 = A3.loadUInt8Array(3 * C3);
          Vg([0, C3], g4.p0, g4.diagonal(), I4, e3), e3.loadSplitValues(A3);
        }
        if (t3) {
          const I4 = new Q(A3.loadFloat32Vec2(), A3.loadFloat32Vec2());
          if (g3.versions["zea-engine"].compare([3, 9, 1]) >= 0) {
            const g4 = A3.loadUInt16Array(2 * C3);
            Sg([0, C3], I4.p0, I4.diagonal(), g4, t3);
          } else {
            const g4 = A3.loadUInt8Array(2 * C3);
            Fg([0, C3], I4.p0, I4.diagonal(), g4, t3);
          }
          t3.loadSplitValues(A3);
        }
      } else {
        const I4 = [];
        let o3, s3 = 0;
        for (let g4 = 0; g4 < B3; g4++) {
          const g5 = A3.loadUInt32(), C4 = {range: [s3, s3 + g5], bbox: new b(A3.loadFloat32Vec3(), A3.loadFloat32Vec3()), normalsRange: new b(), texCoordsRange: new Q()};
          e3 && C4.normalsRange.set(A3.loadFloat32Vec3(), A3.loadFloat32Vec3()), t3 && C4.texCoordsRange.set(A3.loadFloat32Vec2(), A3.loadFloat32Vec2()), I4.push(C4), s3 += g5;
        }
        o3 = g3.versions["zea-engine"].compare([3, 9, 1]) >= 0 ? A3.loadUInt16Array(3 * C3) : A3.loadUInt8Array(3 * C3);
        let a3 = null, l3 = null;
        e3 && (a3 = A3.loadUInt8Array(3 * C3)), t3 && (l3 = A3.loadUInt8Array(2 * C3));
        for (let A4 = 0; A4 < B3; A4++) {
          {
            const C4 = I4[A4].bbox;
            g3.versions["zea-engine"].compare([3, 9, 1]) >= 0 ? Rg(I4[A4].range, C4.p0, C4.diagonal(), o3, i3) : ug(I4[A4].range, C4.p0, C4.diagonal(), o3, i3);
          }
          if (a3) {
            const g4 = I4[A4].normalsRange;
            Vg(I4[A4].range, g4.p0, g4.diagonal(), a3, e3);
          }
          if (l3) {
            const i4 = I4[A4].texCoordsRange;
            g3.versions["zea-engine"].compare([3, 9, 1]) >= 0 ? Sg([0, C3], i4.p0, i4.diagonal(), l3, t3) : Fg(I4[A4].range, i4.p0, i4.diagonal(), l3, t3);
          }
        }
        e3 && e3.loadSplitValues(A3), t3 && t3.loadSplitValues(A3);
      }
    }
    toJSON(A3) {
      const g3 = super.toJSON(A3);
      A3 && A3.skipTopology || (g3.numVertices = this.__numVertices || 0);
      const I3 = {};
      for (const [g4, C3] of this.__vertexAttributes.entries())
        A3 && "skipAttributes" in A3 && A3.skipAttributes.includes(g4) || (I3[g4] = C3.toJSON(A3));
      return g3.vertexAttributes = I3, g3;
    }
    fromJSON(A3, g3) {
      this.clear(), super.fromJSON(A3, g3), this.setNumVertices(A3.numVertices);
      for (const g4 in A3.vertexAttributes) {
        let I3 = this.__vertexAttributes.get(g4);
        const C3 = A3.vertexAttributes[g4];
        I3 ? I3.fromJSON(C3) : console.warn("attr undefined, cannot execute fromJSON()");
      }
      this.emit("geomDataTopologyChanged");
    }
    toString() {
      return JSON.stringify(this.toJSON(), null, 2);
    }
  };
  var Xg = class extends bg {
    constructor() {
      super("Vec4", 4), this.normalized = false;
    }
    getValueRef(A3) {
      if (A3 >= this.data.length / this.stride)
        throw new Error("Invalid vertex index:" + A3 + ". Num Vertices:" + this.data.length / 3);
      const g3 = A3 * this.stride, I3 = this.data.subarray(g3, g3 + this.stride);
      return new s(I3);
    }
    getValue(A3) {
      if (A3 >= this.data.length / this.stride)
        throw new Error("Invalid vertex index:" + A3 + ". Num Vertices:" + this.data.length / 3);
      const g3 = A3 * this.stride, I3 = this.data.slice(g3, g3 + this.stride);
      return new s(I3);
    }
    setValue(A3, g3) {
      if (A3 >= this.data.length / this.stride)
        throw new Error("Invalid vertex index:" + A3 + ". Num Vertices:" + this.data.length / 3);
      const I3 = A3 * this.stride;
      this.data.set(g3.asArray(), I3);
    }
    getFaceVertexValueRef(A3, g3) {
      const I3 = this.getFaceVertexValueRef_array(A3, g3);
      return new s(I3);
    }
    setFaceVertexValue(A3, g3, I3) {
      this.setFaceVertexValue_array(A3, g3, I3.asArray());
    }
    setSplitVertexValue(A3, g3, I3) {
      this.setSplitVertexValue_array(A3, g3, I3.asArray());
    }
  };
  e.register("Vec4Attribute", Xg);
  var Hg = class extends bg {
    constructor() {
      super("Color", 4), this.normalized = false;
    }
    getValueRef(A3) {
      if (A3 >= this.data.length / this.stride)
        throw new Error("Invalid vertex index:" + A3 + ". Num Vertices:" + this.data.length / 3);
      const g3 = A3 * this.stride, I3 = this.data.subarray(g3, g3 + this.stride);
      return new l(I3);
    }
    getValue(A3) {
      if (A3 >= this.data.length / this.stride)
        throw new Error("Invalid vertex index:" + A3 + ". Num Vertices:" + this.data.length / 3);
      const g3 = A3 * this.stride, I3 = this.data.slice(g3, g3 + this.stride);
      return new l(I3);
    }
    setValue(A3, g3) {
      if (A3 >= this.data.length / this.stride)
        throw new Error("Invalid vertex index:" + A3 + ". Num Vertices:" + this.data.length / 3);
      const I3 = A3 * this.stride;
      this.data.set(g3.asArray(), I3);
    }
    getFaceVertexValueRef(A3, g3) {
      const I3 = this.getFaceVertexValueRef_array(A3, g3);
      return new l(I3);
    }
    setFaceVertexValue(A3, g3, I3) {
      this.setFaceVertexValue_array(A3, g3, I3.asArray());
    }
    setSplitVertexValue(A3, g3, I3) {
      this.setSplitVertexValue_array(A3, g3, I3.asArray());
    }
  };
  e.register("ColorAttribute", Hg);
  var Wg = class extends wg {
    constructor() {
      super();
    }
    clear() {
      this.setNumVertices(0), this.emit("geomDataTopologyChanged");
    }
    readBinary(A3, g3) {
      super.loadBaseGeomBinary(A3, g3), this.emit("geomDataChanged");
    }
  };
  e.register("Points", Wg);
  var Yg = class extends wg {
    constructor() {
      super(), this.__indices = new Uint32Array();
    }
    clear() {
      this.setNumSegments(0), this.setNumVertices(0), this.emit("geomDataTopologyChanged");
    }
    getIndices() {
      return this.__indices;
    }
    getNumSegments() {
      return this.__indices.length / 2;
    }
    getNumLineSegments() {
      return this.__indices.length / 2;
    }
    setNumSegments(A3) {
      if (A3 > this.getNumSegments()) {
        const g3 = new Uint32Array(2 * A3);
        g3.set(this.__indices), this.__indices = g3;
      } else
        this.__indices = this.__indices.slice(0, 2 * A3);
    }
    setSegmentVertexIndices(A3, g3, I3) {
      if (A3 >= this.__indices.length / 2)
        throw new Error("Invalid line index:" + A3 + ". Num Segments:" + this.__indices.length / 2);
      this.__indices[2 * A3 + 0] = g3, this.__indices[2 * A3 + 1] = I3;
    }
    getSegmentVertexIndex(A3, g3) {
      return A3 < this.getNumSegments() ? this.__indices[2 * A3 + g3] : -1;
    }
    genBuffers(A3) {
      const g3 = super.genBuffers();
      let I3;
      return I3 = g3.numVertices < Math.pow(2, 8) ? new Uint8Array(this.__indices) : g3.numVertices < Math.pow(2, 16) ? new Uint16Array(this.__indices) : this.__indices, g3.indices = I3, g3;
    }
    readBinary(A3, g3) {
      super.loadBaseGeomBinary(A3, g3), this.setNumSegments(A3.loadUInt32());
      const I3 = A3.loadUInt8();
      I3 == 1 ? this.__indices = A3.loadUInt8Array() : I3 == 2 ? this.__indices = A3.loadUInt16Array() : I3 == 4 && (this.__indices = A3.loadUInt32Array()), this.emit("geomDataChanged");
    }
    toJSON(A3) {
      const g3 = super.toJSON(A3);
      return A3 && A3.skipTopology || (g3.indices = Array.from(this.__indices)), g3;
    }
    fromJSON(A3, g3) {
      super.fromJSON(A3, g3), A3.indices && (this.__indices = Uint32Array.from(A3.indices));
    }
  };
  e.register("Lines", Yg);
  var Kg = class extends wg {
    constructor() {
      super(), this.edgeFaces = [], this.faceEdges = [[]], this.faceCounts = [], this.__faceVertexIndices = new Uint32Array(), this.__logTopologyWarnings = false, this.__edgeAttributes = new Map(), this.__faceAttributes = new Map(), this.numEdges = 0, this.edgeVerts = [], this.vertexEdges = [], this.edgeAngles = new Float32Array(), this.edgeVecs = [];
    }
    clear() {
      super.clear(), this.edgeVerts = [], this.vertexEdges = [], this.numEdges = 0, this.edgeAngles = new Float32Array(), this.emit("geomDataTopologyChanged");
    }
    addVertexAttribute(A3, g3) {
      super.addVertexAttribute(A3, g3), g3.setMesh(this);
    }
    getFaceCounts() {
      return this.faceCounts;
    }
    getNumFaces() {
      return this.faceCounts.length == 0 ? 0 : this.faceCounts.reduce((A3, g3) => A3 + g3);
    }
    getNumTriangles() {
      let A3 = 0, g3 = 1;
      for (const I3 of this.faceCounts)
        A3 += I3 * g3, g3++;
      return A3;
    }
    setFaceCounts(A3) {
      let g3 = 0, I3 = 3;
      for (const C3 of A3)
        g3 += C3 * I3, I3++;
      if (this.getNumFaces() == 0)
        this.__faceVertexIndices = new Uint32Array(g3);
      else {
        const C3 = new Uint32Array(g3);
        let i3 = 0, e3 = 0;
        g3 = 0, I3 = 3, A3.forEach((A4, g4) => {
          const t3 = i3 + Math.min(A4, this.faceCounts[g4]) * I3;
          C3.set(this.__faceVertexIndices.slice(i3, t3), e3), i3 += this.faceCounts[g4] * I3, e3 += A4 * I3, I3++;
        }), this.__faceVertexIndices = C3;
      }
      this.faceCounts = A3;
    }
    getFaceVertexCount(A3) {
      let g3 = 0, I3 = 0;
      return this.faceCounts.some((C3, i3) => (g3 += C3, g3 > A3 && (I3 = i3 + 3, true))), I3;
    }
    getFaceVertexOffset(A3) {
      let g3 = 0, I3 = 0;
      return this.faceCounts.some((C3, i3) => g3 + C3 > A3 ? (I3 += (A3 - g3) * (i3 + 3), true) : (g3 += C3, I3 += C3 * (i3 + 3), false)), I3;
    }
    setFaceVertexIndices(A3, g3) {
      const I3 = this.getFaceVertexCount(A3);
      if (g3.length != I3)
        throw new Error(`Invalid indices for face:${A3} vertexIndices:${g3}. Expected ${I3} indices`);
      const C3 = this.getFaceVertexOffset(A3);
      this.__faceVertexIndices.set(g3, C3);
    }
    addFace(A3) {
      const g3 = [...this.faceCounts];
      if (g3.length <= A3.length - 3) {
        for (let I4 = g3.length; I4 < A3.length - 3; I4++)
          g3[I4] = 0;
        g3[A3.length - 3] = 1;
      } else
        g3[A3.length - 3]++;
      this.setFaceCounts(g3);
      let I3 = 0, C3 = 0;
      return this.faceCounts.some((g4, i3) => i3 + 3 == A3.length ? (I3 += g4 - 1, C3 += (g4 - 1) * (i3 + 3), true) : (I3 += g4, C3 += g4 * (i3 + 3), false)), this.__faceVertexIndices.set(A3, C3), I3;
    }
    getFaceVertexIndices(A3) {
      const g3 = [], I3 = this.getFaceVertexOffset(A3), C3 = this.getFaceVertexCount(A3);
      for (let A4 = 0; A4 < C3; A4++)
        g3.push(this.__faceVertexIndices[I3 + A4]);
      return g3;
    }
    getFaceVertexIndex(A3, g3) {
      const I3 = this.getFaceVertexOffset(A3);
      return this.__faceVertexIndices[I3 + g3];
    }
    addFaceAttribute(A3, g3) {
      return g3.setCount(this.getNumFaces()), this.__faceAttributes.set(A3, g3), g3;
    }
    hasFaceAttribute(A3) {
      return this.__faceAttributes.has(A3);
    }
    getFaceAttribute(A3) {
      return this.__faceAttributes.get(A3);
    }
    addEdgeAttribute(A3, g3) {
      g3.setCount(this.numEdges), this.__edgeAttributes.set(A3, g3);
    }
    hasEdgeAttribute(A3) {
      return this.__edgeAttributes.has(A3);
    }
    getEdgeAttribute(A3) {
      return this.__edgeAttributes.get(A3);
    }
    genTopologyInfo() {
      let A3 = {};
      this.vertexEdges = [], this.edgeFaces = [], this.edgeVerts = [], this.faceEdges = [], this.numEdges = 0;
      const g3 = this.positions, I3 = (I4, C4) => {
        let i4 = I4, e3 = C4;
        if (e3 < i4) {
          const A4 = i4;
          i4 = e3, e3 = A4;
        }
        const t3 = i4 + ">" + e3;
        if (t3 in A3)
          return A3[t3];
        const B3 = g3.getValueRef(i4), o3 = g3.getValueRef(e3).subtract(B3), s3 = {edgeIndex: this.edgeFaces.length / 2, edgeVec: o3};
        return A3[t3] = s3, this.edgeFaces.push(-1), this.edgeFaces.push(-1), this.edgeVerts.push(i4), this.edgeVerts.push(e3), this.numEdges++, s3;
      }, C3 = (A4, g4, C4) => {
        const i4 = I3(A4, g4).edgeIndex;
        if (g4 < A4) {
          const A5 = 2 * i4 + 0;
          this.__logTopologyWarnings && this.edgeFaces[A5] != -1 && console.warn("Edge poly 0 already set. Mesh is non-manifold."), this.edgeFaces[A5] = C4;
        } else {
          const A5 = 2 * i4 + 1;
          this.__logTopologyWarnings && this.edgeFaces[A5] != -1 && console.warn("Edge poly 1 already set. Mesh is non-manifold."), this.edgeFaces[A5] = C4;
        }
        C4 in this.faceEdges || (this.faceEdges[C4] = []), this.faceEdges[C4].push(i4), this.vertexEdges[A4] == null && (this.vertexEdges[A4] = new Set()), this.vertexEdges[g4] == null && (this.vertexEdges[g4] = new Set()), this.vertexEdges[A4].add(i4), this.vertexEdges[g4].add(i4);
      }, i3 = this.getNumFaces();
      for (let A4 = 0; A4 < i3; A4++) {
        const g4 = this.getFaceVertexIndices(A4);
        for (let I4 = 0; I4 < g4.length; I4++) {
          C3(g4[I4], g4[(I4 + 1) % g4.length], A4);
        }
      }
    }
    computeFaceNormals() {
      const A3 = this.positions, g3 = new Zg();
      this.addFaceAttribute("normals", g3);
      const I3 = this.getNumFaces();
      for (let C3 = 0; C3 < I3; C3++) {
        const I4 = this.getFaceVertexIndices(C3), i3 = A3.getValueRef(I4[0]);
        let e3 = A3.getValueRef(I4[1]);
        const t3 = new o();
        for (let g4 = 2; g4 < I4.length; g4++) {
          const C4 = A3.getValueRef(I4[g4]), B3 = e3.subtract(i3), o3 = C4.subtract(i3);
          t3.addInPlace(B3.cross(o3).normalize()), e3 = C4;
        }
        t3.lengthSquared() < Number.EPSILON || g3.setValue(C3, t3.normalize());
      }
    }
    calculateEdgeAngles() {
      this.vertexEdges.length == 0 && this.genTopologyInfo(), this.computeFaceNormals();
      const A3 = this.positions, g3 = this.getFaceAttribute("normals");
      this.edgeVecs = [], this.edgeAngles = new Float32Array(this.numEdges);
      for (let I3 = 0; I3 < this.edgeFaces.length; I3 += 2) {
        const C3 = this.edgeVerts[I3], i3 = this.edgeVerts[I3 + 1], e3 = A3.getValueRef(i3).subtract(A3.getValueRef(C3));
        e3.normalizeInPlace(), this.edgeVecs.push(e3);
        const t3 = this.edgeFaces[I3], B3 = this.edgeFaces[I3 + 1];
        if (t3 == -1 || B3 == -1) {
          this.edgeAngles[I3 / 2] = 2 * Math.PI;
          continue;
        }
        const o3 = g3.getValueRef(t3), s3 = g3.getValueRef(B3);
        this.edgeAngles[I3 / 2] = o3.angleTo(s3);
      }
    }
    computeVertexNormals(A3 = 1) {
      this.calculateEdgeAngles();
      const g3 = this.getFaceAttribute("normals"), I3 = new Zg();
      this.addVertexAttribute("normals", I3);
      const C3 = (A4, g4) => {
        I3.setValue(A4, g4);
      }, i3 = (A4, g4) => {
        let I4, C4;
        const i4 = this.faceEdges[A4];
        for (const A5 of i4)
          (this.edgeVerts[2 * A5] == g4 || this.edgeVerts[2 * A5 + 1] == g4) && (I4 ? C4 = this.edgeVecs[A5] : I4 = this.edgeVecs[A5]);
        return [I4, C4];
      };
      for (let t3 = 0; t3 < this.vertexEdges.length; t3++) {
        if (this.vertexEdges[t3] == null)
          continue;
        const B3 = this.vertexEdges[t3], s3 = [], a3 = (A4) => {
          let g4 = false;
          for (const I4 of s3)
            if (g4 = I4.includes(A4), g4)
              break;
          g4 || s3.push([A4]);
        };
        for (const g4 of B3) {
          const I4 = this.edgeFaces[2 * g4], C4 = this.edgeFaces[2 * g4 + 1];
          if (I4 != -1 && C4 != -1 && this.edgeAngles[g4] < A3) {
            let A4 = -1, g5 = -1;
            for (let i4 = 0; i4 < s3.length; i4++)
              A4 == -1 && s3[i4].includes(I4) && (A4 = i4), g5 == -1 && s3[i4].includes(C4) && (g5 = i4);
            A4 == -1 && g5 == -1 ? s3.push([I4, C4]) : A4 != -1 && g5 != -1 ? A4 != g5 && (s3[A4] = s3[A4].concat(s3[g5]), s3.splice(g5, 1)) : (A4 == -1 && s3[g5].push(I4), g5 == -1 && s3[A4].push(C4));
          } else
            I4 != -1 && a3(I4), C4 != -1 && a3(C4);
        }
        s3.sort((A4, g4) => A4.length < g4.length ? 1 : A4.length > g4.length ? -1 : 0);
        let l3 = true;
        for (const A4 of s3) {
          const B4 = new o();
          for (const I4 of A4) {
            const A5 = i3(I4, t3);
            let C4;
            A5[0] && A5[1] ? (C4 = A5[0].angleTo(A5[1]), B4.addInPlace((e3 = I4, g3.getValueRef(e3)).scale(C4))) : console.warn("variable weight is undefined because faceEdges[0] or faceEdges[1] is undefined");
          }
          B4.normalizeInPlace(), l3 ? (C3(t3, B4), l3 = false) : I3.setSplitVertexValues(t3, A4, B4.asArray());
        }
      }
      var e3;
      return I3;
    }
    computeHardEdgesIndices(A3 = 1) {
      this.edgeVerts.length == 0 && this.calculateEdgeAngles();
      const g3 = [], I3 = (A4) => {
        g3.push(this.edgeVerts[A4]), g3.push(this.edgeVerts[A4 + 1]);
      };
      for (let g4 = 0; g4 < this.edgeAngles.length; g4++)
        this.edgeAngles[g4] > A3 && I3(2 * g4);
      return Uint32Array.from(g3);
    }
    genBuffers(A3) {
      const g3 = {};
      let I3 = 0;
      for (const [, A4] of this.__vertexAttributes) {
        const C4 = A4.getSplits();
        for (const A5 in C4) {
          A5 in g3 || (g3[A5] = {});
          const i4 = C4[A5];
          for (const C5 in i4) {
            const i5 = parseInt(C5);
            i5 in g3[A5] || (g3[A5][i5] = I3, I3++);
          }
        }
      }
      const C3 = this.positions.getCount(), i3 = C3 + I3;
      let e3;
      A3 && A3.includeIndices == 0 || (e3 = this.generateTriangulatedIndices(i3, C3, g3));
      const t3 = {};
      for (const [A4, C4] of this.__vertexAttributes) {
        let i4;
        i4 = I3 == 0 ? C4.asArray() : C4.generateSplitValues(g3, I3);
        const e4 = C4.stride, B3 = i4.length / e4;
        t3[A4] = {values: i4, count: B3, dimension: e4, normalized: A4 == "normals", dataType: C4.getDataTypeName()};
      }
      return {numVertices: this.numVertices(), numRenderVerts: i3, indices: e3, attrBuffers: t3};
    }
    computeNumTriangles() {
      let A3 = 3, g3 = 0;
      for (const I3 of this.faceCounts)
        g3 += I3 * (A3 - 2), A3++;
      return g3;
    }
    generateTriangulatedIndices(A3, g3, I3) {
      const C3 = this.computeNumTriangles();
      let i3;
      i3 = A3 < Math.pow(2, 8) ? new Uint8Array(3 * C3) : A3 < Math.pow(2, 16) ? new Uint16Array(3 * C3) : new Uint32Array(3 * C3);
      let e3 = 0;
      const t3 = function(A4, C4) {
        A4 in I3 && C4 in I3[A4] && (A4 = g3 + I3[A4][C4]), i3[e3] = A4, e3++;
      }, B3 = this.getNumFaces();
      for (let A4 = 0; A4 < B3; A4++) {
        const g4 = this.getFaceVertexIndices(A4);
        for (let I4 = 0; I4 < g4.length; I4++)
          I4 >= 3 && (t3(g4[0], A4), t3(g4[I4 - 1], A4)), t3(g4[I4], A4);
      }
      return i3;
    }
    readBinary(A3, g3) {
      super.loadBaseGeomBinary(A3, g3), this.setFaceCounts(Array.from(A3.loadUInt32Array()));
      const I3 = this.getNumFaces(), C3 = A3.loadUInt8Array(I3), i3 = A3.loadSInt32Vec2(), e3 = A3.loadUInt8();
      let t3;
      if (e3 == 1)
        t3 = A3.loadUInt8Array();
      else if (e3 == 2)
        t3 = A3.loadUInt16Array();
      else {
        if (e3 != 4)
          throw Error("faceVertexIndexDeltas undefined");
        t3 = A3.loadUInt32Array();
      }
      let B3 = 3, o3 = 0;
      const s3 = this.faceCounts.map((A4, g4) => {
        const I4 = o3;
        return o3 += A4 * B3, B3++, I4;
      });
      let a3 = 0, l3 = 0;
      const n3 = [];
      for (let A4 = 0; A4 < I3; A4++) {
        const g4 = C3[A4], I4 = s3[g4], e4 = g4 + 3;
        n3[A4] = I4;
        for (let g5 = 0; g5 < e4; g5++) {
          const C4 = I4 + g5, e5 = t3[a3 + g5] + i3.x;
          if (A4 == 0)
            this.__faceVertexIndices[C4] = e5;
          else {
            let I5 = n3[A4 - 1];
            I5 += g5 < l3 ? g5 : l3 - 1, this.__faceVertexIndices[C4] = this.__faceVertexIndices[I5] + e5;
          }
        }
        a3 += e4, s3[g4] += e4, l3 = e4;
      }
      this.hasVertexAttribute("normals") || this.computeVertexNormals(), this.emit("geomDataChanged");
    }
    toJSON(A3) {
      const g3 = super.toJSON(A3);
      return A3 && A3.skipTopology || (g3.faceCounts = Array.from(this.faceCounts), g3.faceVertexIndices = Array.from(this.__faceVertexIndices)), g3;
    }
    fromJSON(A3, g3) {
      super.fromJSON(A3, g3), A3.faceCounts && (this.faceCounts = A3.faceCounts), A3.faceVertexIndices && (this.__faceVertexIndices = Uint32Array.from(A3.faceVertexIndices));
    }
  };
  e.register("Mesh", Kg);
  var pg = class extends V {
    constructor(A3) {
      super(), this.name = A3.name, this.__buffers = A3.geomBuffers, this.__buffers.attrBuffers, this.boundingBox = new b(), this.boundingBox.p0.__data = A3.bbox.p0.__data, this.boundingBox.p1.__data = A3.bbox.p1.__data, this.__metaData = new Map();
    }
    getNumVertices() {
      return this.__buffers.numVertices;
    }
    getBoundingBox() {
      return this.boundingBox;
    }
    genBuffers() {
      return this.__buffers;
    }
    freeBuffers() {
      for (const A3 in this.__buffers.attrBuffers) {
        this.__buffers.attrBuffers[A3].values = null;
      }
      this.__buffers.indices && (this.__buffers.indices = null);
    }
  };
  var Ng = class extends pg {
    constructor(A3) {
      super(A3);
    }
  };
  var Jg = class extends pg {
    constructor(A3) {
      super(A3);
    }
    getNumLineSegments() {
      return this.__buffers.indices.length / 2;
    }
  };
  var Dg = class extends pg {
    constructor(A3) {
      super(A3);
    }
    getNumTriangles() {
      return this.__buffers.indices.length / 3;
    }
  };
  var fg = class extends hA {
  };
  e.register("SubGeom", fg);
  var Mg = class extends pg {
    constructor(A3, g3) {
      super(A3), this.materials = [], this.subGeomMaterialIndices = new Uint8Array(0), this.subGeoms = [], this.counts = A3.geomBuffers.counts;
      const I3 = g3.getMaterials();
      A3.geomBuffers.materialLibraryIndices.forEach((A4, g4) => {
        this.materials[g4] = I3[A4];
      }), this.subGeomMaterialIndices = A3.geomBuffers.subGeomMaterialIndices, this.__buffers.materials = this.materials;
    }
    getNumTriangles() {
      return this.counts.TRIANGLES / 3;
    }
    getNumLineSegments() {
      return this.counts.LINES / 2;
    }
    getNumPoints() {
      return this.counts.POINTS;
    }
    loadMetadata(A3, g3) {
      A3.loadUInt32Array().forEach((I3, C3) => {
        const i3 = new fg();
        A3.seek(I3), i3.readBinary(A3, g3), this.subGeoms[C3] = i3;
      });
    }
  };
  var Lg = class extends Wg {
    constructor() {
      super(), this.dirtyTopology = true, this.dirtyVertices = true, this.topologyParams = [];
    }
    parameterValueChanged(A3) {
      this.setBoundingBoxDirty(), this.topologyParams.includes(A3.param.getName()) ? (this.dirtyTopology = true, this.emit("geomDataTopologyChanged")) : (this.dirtyVertices = true, this.setBoundingBoxDirty(), this.emit("geomDataChanged")), super.parameterValueChanged(A3);
    }
    update() {
      this.dirtyTopology ? (this.rebuild(), this.dirtyTopology = false, this.dirtyVertices = false, this.rebuild()) : this.dirtyVertices && (this.dirtyVertices = false, this.resize(), this.dirtyVertices = false);
    }
    getBoundingBox() {
      return this.update(), super.getBoundingBox();
    }
    getNumVertices() {
      return this.update(), super.getNumVertices();
    }
    genBuffers(A3) {
      return this.update(), super.genBuffers(A3);
    }
    toJSON(A3) {
      A3 || (A3 = {}), A3.skipTopology = true, A3.skipAttributes = ["positions", "normals", "texCoords"];
      const g3 = super.toJSON(A3);
      return A3.skipTopology = false, A3.skipAttributes = [], g3;
    }
  };
  var Ug = class extends Yg {
    constructor() {
      super(), this.dirtyTopology = true, this.dirtyVertices = true, this.topologyParams = [];
    }
    parameterValueChanged(A3) {
      this.setBoundingBoxDirty(), this.topologyParams.includes(A3.param.getName()) ? (this.dirtyTopology = true, this.emit("geomDataTopologyChanged")) : (this.dirtyVertices = true, this.setBoundingBoxDirty(), this.emit("geomDataChanged")), super.parameterValueChanged(A3);
    }
    update() {
      this.dirtyTopology ? (this.rebuild(), this.dirtyTopology = false, this.dirtyVertices = false, this.rebuild()) : this.dirtyVertices && (this.resize(), this.dirtyVertices = false, this.resize());
    }
    getBoundingBox() {
      return this.update(), super.getBoundingBox();
    }
    getNumVertices() {
      return this.update(), super.getNumVertices();
    }
    genBuffers(A3) {
      return this.update(), super.genBuffers();
    }
    toJSON(A3) {
      A3 || (A3 = {}), A3.skipTopology = true, A3.skipAttributes = ["positions", "normals", "texCoords"];
      const g3 = super.toJSON(A3);
      return A3.skipTopology = false, A3.skipAttributes = [], g3;
    }
  };
  var vg = class extends Kg {
    constructor() {
      super(), this.dirtyTopology = true, this.dirtyVertices = true, this.topologyParams = [];
    }
    parameterValueChanged(A3) {
      this.setBoundingBoxDirty(), this.topologyParams.includes(A3.param.getName()) ? (this.dirtyTopology = true, this.emit("geomDataTopologyChanged")) : (this.dirtyVertices = true, this.setBoundingBoxDirty(), this.emit("geomDataChanged")), super.parameterValueChanged(A3);
    }
    update() {
      this.dirtyTopology ? (this.vertexEdges = [], this.dirtyTopology = false, this.dirtyVertices = false, this.rebuild()) : this.dirtyVertices && (this.dirtyVertices = false, this.resize());
    }
    getBoundingBox() {
      return this.update(), super.getBoundingBox();
    }
    getNumVertices() {
      return this.update(), super.getNumVertices();
    }
    computeVertexNormals(A3 = 1) {
      return this.update(), super.computeVertexNormals(A3);
    }
    computeHardEdgesIndices(A3 = 1) {
      return this.update(), super.computeHardEdgesIndices(A3);
    }
    genBuffers(A3) {
      return this.update(), super.genBuffers(A3);
    }
    toJSON(A3) {
      A3 || (A3 = {}), A3.skipTopology = true, A3.skipAttributes = ["positions", "normals", "texCoords"];
      const g3 = super.toJSON(A3);
      return A3.skipTopology = false, A3.skipAttributes = [], g3;
    }
  };
  var kg = class extends Lg {
    constructor(A3 = 1, g3 = 1, I3 = 1, C3 = 1, i3 = false) {
      if (super(), this.topologyParams = [], isNaN(A3) || isNaN(g3) || isNaN(I3) || isNaN(C3))
        throw new Error("Invalid geom args");
      this.sizeXParam = this.addParameter(new JA("X", A3)), this.sizeYParam = this.addParameter(new JA("Y", g3)), this.divisionsXParam = this.addParameter(new JA("XDivisions", I3)), this.divisionsYParam = this.addParameter(new JA("YDivisions", C3)), i3 && this.addVertexAttribute("texCoords", new yg()), this.topologyParams.push("XDivisions"), this.topologyParams.push("YDivisions");
    }
    rebuild() {
      const A3 = this.divisionsXParam.value, g3 = this.divisionsYParam.value;
      this.setNumVertices(A3 * g3);
      const I3 = this.getVertexAttribute("texCoords");
      if (I3)
        for (let C3 = 0; C3 < g3; C3++) {
          const i3 = C3 / (g3 - 1);
          for (let g4 = 0; g4 < A3; g4++) {
            const e3 = g4 / (A3 - 1);
            I3.getValueRef(C3 * A3 + g4).set(e3, i3);
          }
        }
      this.resize();
    }
    resize() {
      const A3 = this.divisionsXParam.value, g3 = this.divisionsYParam.value, I3 = this.sizeXParam.value, C3 = this.sizeYParam.value, i3 = this.getVertexAttribute("positions");
      if (i3)
        for (let e3 = 0; e3 < g3; e3++) {
          const t3 = (e3 / (g3 - 1) - 0.5) * C3;
          for (let g4 = 0; g4 < A3; g4++) {
            const C4 = (g4 / (A3 - 1) - 0.5) * I3;
            i3.getValueRef(e3 * A3 + g4).set(C4, t3, 0);
          }
        }
    }
  };
  e.register("PointGrid", kg);
  var xg = class extends Ug {
    constructor(A3 = 1, g3 = 1) {
      if (super(), isNaN(A3) || isNaN(g3))
        throw new Error("Invalid geom args");
      this.sizeXParam = this.addParameter(new JA("X", A3)), this.sizeXParam.on("valueChanged", this.resize.bind(this)), this.sizeYParam = this.addParameter(new JA("Y", g3)), this.sizeYParam.on("valueChanged", this.resize.bind(this)), this.rebuild();
    }
    rebuild() {
      this.setNumVertices(4), this.setNumSegments(4), this.setSegmentVertexIndices(0, 0, 1), this.setSegmentVertexIndices(1, 1, 2), this.setSegmentVertexIndices(2, 2, 3), this.setSegmentVertexIndices(3, 3, 0), this.resize(false);
    }
    resize() {
      const A3 = this.sizeXParam.value, g3 = this.sizeYParam.value, I3 = this.getVertexAttribute("positions");
      I3 && (I3.getValueRef(0).set(-0.5 * A3, -0.5 * g3, 0), I3.getValueRef(1).set(0.5 * A3, -0.5 * g3, 0), I3.getValueRef(2).set(0.5 * A3, 0.5 * g3, 0), I3.getValueRef(3).set(-0.5 * A3, 0.5 * g3, 0));
    }
  };
  e.register("Rect", xg);
  var zg = class extends Ug {
    constructor(A3 = 1, g3 = 32, I3 = 2 * Math.PI) {
      if (super(), this.topologyParams = [], isNaN(A3) || isNaN(g3))
        throw new Error("Invalid geom args");
      this.radiusParam = this.addParameter(new JA("Radius", A3)), this.angleParam = this.addParameter(new JA("Angle", I3)), this.sidesParam = this.addParameter(new JA("Sides", g3 >= 3 ? g3 : 3, [3, 200], 1)), this.topologyParams.push("Sides");
    }
    rebuild() {
      const A3 = this.sidesParam.value;
      this.setNumVertices(A3);
      const g3 = this.angleParam.value < 2 * Math.PI;
      g3 ? this.setNumSegments(A3 - 1) : this.setNumSegments(A3);
      for (let I3 = 0; I3 < (g3 ? A3 - 1 : A3); I3++)
        this.setSegmentVertexIndices(I3, I3, (I3 + 1) % A3);
      this.resize();
    }
    resize() {
      const A3 = this.radiusParam.value, g3 = this.sidesParam.value, I3 = this.angleParam.value / g3, C3 = this.getVertexAttribute("positions");
      if (C3)
        for (let i3 = 0; i3 < g3; i3++)
          C3.getValueRef(i3).set(Math.cos(I3 * i3) * A3, Math.sin(I3 * i3) * A3, 0);
    }
  };
  e.register("Circle", zg);
  var Tg = class extends Ug {
    constructor(A3 = 1) {
      if (super(), isNaN(A3))
        throw new Error("Invalid geom args");
      this.sizeParam = this.addParameter(new JA("Size", A3));
    }
    rebuild() {
      this.setNumVertices(6), this.setNumSegments(3), this.setSegmentVertexIndices(0, 0, 1), this.setSegmentVertexIndices(1, 2, 3), this.setSegmentVertexIndices(2, 4, 5), this.resize();
    }
    resize() {
      const A3 = this.sizeParam.value, g3 = this.getVertexAttribute("positions");
      g3 && (g3.getValueRef(0).set(-0.5 * A3, 0, 0), g3.getValueRef(1).set(0.5 * A3, 0, 0), g3.getValueRef(2).set(0, 0.5 * A3, 0), g3.getValueRef(3).set(0, -0.5 * A3, 0), g3.getValueRef(4).set(0, 0, 0.5 * A3), g3.getValueRef(5).set(0, 0, -0.5 * A3));
    }
  };
  e.register("Cross", Tg);
  var _g = class extends Ug {
    constructor(A3 = 1, g3 = 1, I3 = 1, C3 = false) {
      super(), this.sizeXParam = this.addParameter(new JA("X", A3)), this.sizeYParam = this.addParameter(new JA("Y", g3)), this.sizeZParam = this.addParameter(new JA("Z", I3)), this.baseZAtZeroParam = this.addParameter(new fA("BaseZAtZero", C3));
    }
    rebuild() {
      this.setNumVertices(8), this.setNumSegments(12), this.setSegmentVertexIndices(0, 0, 1), this.setSegmentVertexIndices(1, 1, 2), this.setSegmentVertexIndices(2, 2, 3), this.setSegmentVertexIndices(3, 3, 0), this.setSegmentVertexIndices(4, 4, 5), this.setSegmentVertexIndices(5, 5, 6), this.setSegmentVertexIndices(6, 6, 7), this.setSegmentVertexIndices(7, 7, 4), this.setSegmentVertexIndices(8, 0, 4), this.setSegmentVertexIndices(9, 1, 5), this.setSegmentVertexIndices(10, 2, 6), this.setSegmentVertexIndices(11, 3, 7), this.resize();
    }
    resize() {
      const A3 = this.sizeXParam.value, g3 = this.sizeYParam.value, I3 = this.sizeZParam.value, C3 = this.baseZAtZeroParam.value, i3 = this.getVertexAttribute("positions");
      if (i3) {
        let e3 = 0.5;
        C3 && (e3 = 1), i3.getValueRef(0).set(0.5 * A3, -0.5 * g3, e3 * I3), i3.getValueRef(1).set(0.5 * A3, 0.5 * g3, e3 * I3), i3.getValueRef(2).set(-0.5 * A3, 0.5 * g3, e3 * I3), i3.getValueRef(3).set(-0.5 * A3, -0.5 * g3, e3 * I3), e3 = -0.5, C3 && (e3 = 0), i3.getValueRef(4).set(0.5 * A3, -0.5 * g3, e3 * I3), i3.getValueRef(5).set(0.5 * A3, 0.5 * g3, e3 * I3), i3.getValueRef(6).set(-0.5 * A3, 0.5 * g3, e3 * I3), i3.getValueRef(7).set(-0.5 * A3, -0.5 * g3, e3 * I3);
      }
    }
  };
  e.register("LinesCuboid", _g);
  var Pg = class extends Ug {
    constructor(A3 = 1, g3 = 1, I3 = 10, C3 = 10, i3 = false) {
      if (super(), this.topologyParams = [], isNaN(A3) || isNaN(g3) || isNaN(I3) || isNaN(C3))
        throw new Error("Invalid geom args");
      this.xParam = this.addParameter(new JA("X", A3)), this.yParam = this.addParameter(new JA("Y", g3)), this.xDivisionsParam = this.addParameter(new JA("XDivisions", I3)), this.yDivisionsParam = this.addParameter(new JA("YDivisions", C3)), this.skipCenterLinesParam = this.addParameter(new fA("SkipCenterLines", i3)), this.topologyParams.push("XDivisions"), this.topologyParams.push("YDivisions"), this.topologyParams.push("SkipCenterLines");
    }
    rebuild() {
      const A3 = this.xDivisionsParam.value, g3 = this.yDivisionsParam.value, I3 = this.skipCenterLinesParam.value && A3 % 2 == 0 && g3 % 2 == 0;
      this.setNumVertices(2 * (A3 + g3 + 2 - (I3 ? 1 : 0))), this.setNumSegments(A3 + g3 + 2 - (I3 ? 1 : 0));
      let C3 = 0;
      for (let g4 = 0; g4 <= A3; g4++) {
        if (I3 && g4 == A3 / 2)
          continue;
        const i3 = 2 * C3, e3 = 2 * C3 + 1;
        this.setSegmentVertexIndices(C3, i3, e3), C3++;
      }
      for (let i3 = 0; i3 <= g3; i3++) {
        if (I3 && i3 == A3 / 2)
          continue;
        const g4 = 2 * C3, e3 = 2 * C3 + 1;
        this.setSegmentVertexIndices(C3, g4, e3), C3++;
      }
      this.resize();
    }
    resize() {
      const A3 = this.getVertexAttribute("positions"), g3 = this.xDivisionsParam.value, I3 = this.yDivisionsParam.value, C3 = this.xParam.value, i3 = this.yParam.value, e3 = this.skipCenterLinesParam.value && g3 % 2 == 0 && I3 % 2 == 0;
      let t3 = 0;
      for (let I4 = 0; I4 <= g3; I4++) {
        if (e3 && I4 == g3 / 2)
          continue;
        const B3 = 2 * t3, o3 = 2 * t3 + 1, s3 = (I4 / g3 - 0.5) * C3;
        A3 && (A3.getValueRef(B3).set(s3, -0.5 * i3, 0), A3.getValueRef(o3).set(s3, 0.5 * i3, 0)), t3++;
      }
      for (let B3 = 0; B3 <= I3; B3++) {
        if (e3 && B3 == g3 / 2)
          continue;
        const o3 = 2 * t3, s3 = 2 * t3 + 1, a3 = (B3 / I3 - 0.5) * i3;
        A3 && (A3.getValueRef(o3).set(-0.5 * C3, a3, 0), A3.getValueRef(s3).set(0.5 * C3, a3, 0)), t3++;
      }
    }
  };
  e.register("Grid", Pg);
  var Og = class extends vg {
    constructor(A3 = 0.5, g3 = 1, I3 = 32, C3 = true, i3 = true, e3 = true) {
      if (super(), this.topologyParams = [], isNaN(A3) || isNaN(g3) || isNaN(I3))
        throw new Error("Invalid geom args");
      this.radiusParam = this.addParameter(new JA("Radius", A3)), this.heightParam = this.addParameter(new JA("Height", g3)), this.detailParam = this.addParameter(new JA("Detail", I3 >= 3 ? I3 : 3, [3, 200], 1)), this.capParam = this.addParameter(new fA("Cap", C3)), i3 && this.addVertexAttribute("normals", new Zg()), e3 && this.addVertexAttribute("texCoords", new yg()), this.topologyParams.push("Detail"), this.topologyParams.push("Cap");
    }
    rebuild() {
      const A3 = this.detailParam.value, g3 = this.radiusParam.value, I3 = this.heightParam.value, C3 = this.capParam.value;
      let i3 = A3 + 1;
      C3 && (i3 += 1), this.setNumVertices(i3);
      const e3 = A3, t3 = A3 + 1, o3 = this.getVertexAttribute("positions");
      if (o3) {
        o3.getValueRef(e3).set(0, 0, I3);
        for (let I4 = 0; I4 < A3; I4++) {
          const C4 = -I4 / A3 * 2 * Math.PI;
          o3.getValueRef(I4).set(g3 * Math.cos(C4), g3 * Math.sin(C4), 0);
        }
        C3 && o3.getValueRef(t3).set(0, 0, 0);
      }
      this.setFaceCounts([A3 + (C3 ? A3 : 0)]);
      for (let g4 = 0; g4 < A3; g4++) {
        const I4 = (g4 + 1) % A3;
        this.setFaceVertexIndices(g4, [I4, g4, e3]);
      }
      if (C3)
        for (let g4 = 0; g4 < A3; g4++) {
          const I4 = (g4 + 1) % A3;
          this.setFaceVertexIndices(A3 + g4, [g4, I4, t3]);
        }
      const s3 = this.getVertexAttribute("texCoords");
      if (s3) {
        let g4 = 0;
        for (let I4 = 0; I4 < A3; I4++)
          "setFaceVertexValue" in s3 && (s3.setFaceVertexValue(g4, 0, new B((I4 + 1) / A3, 0)), s3.setFaceVertexValue(g4, 1, new B(I4 / A3, 0)), s3.setFaceVertexValue(g4, 2, new B((I4 + 0.5) / A3, 1)));
        if (C3)
          for (let I4 = 0; I4 < A3; I4++)
            s3.setFaceVertexValue(g4, 0, new B(I4 / A3, 0)), s3.setFaceVertexValue(g4, 1, new B((I4 + 1) / A3, 0)), s3.setFaceVertexValue(g4, 2, new B((I4 + 0.5) / A3, 1)), g4++;
      }
      this.resize();
    }
    resize() {
      const A3 = this.detailParam.value, g3 = this.radiusParam.value, I3 = this.heightParam.value, C3 = A3, i3 = A3 + 1, e3 = this.getVertexAttribute("positions");
      if (e3) {
        e3.getValueRef(C3).set(0, 0, I3);
        for (let I4 = 0; I4 < A3; I4++) {
          const C4 = -I4 / A3 * 2 * Math.PI;
          e3.getValueRef(I4).set(g3 * Math.cos(C4), g3 * Math.sin(C4), 0);
        }
        this.capParam.value && e3.getValueRef(i3).set(0, 0, 0);
      }
      this.dirtyTopology = false, this.dirtyVertices = false;
      this.getVertexAttribute("normals") && this.computeVertexNormals();
    }
  };
  e.register("Cone", Og);
  var jg = class extends vg {
    constructor(A3 = 1, g3 = 1, I3 = 1, C3 = false) {
      if (super(), isNaN(A3) || isNaN(g3) || isNaN(I3))
        throw new Error("Invalid geom args");
      this.sizeXParam = this.addParameter(new JA("X", A3)), this.sizeYParam = this.addParameter(new JA("Y", g3)), this.sizeZParam = this.addParameter(new JA("Z", I3)), this.baseZAtZeroParam = this.addParameter(new fA("BaseZAtZero", C3)), this.setFaceCounts([0, 6]), this.setFaceVertexIndices(0, [0, 1, 2, 3]), this.setFaceVertexIndices(1, [7, 6, 5, 4]), this.setFaceVertexIndices(2, [1, 0, 4, 5]), this.setFaceVertexIndices(3, [3, 2, 6, 7]), this.setFaceVertexIndices(4, [0, 3, 7, 4]), this.setFaceVertexIndices(5, [2, 1, 5, 6]), this.setNumVertices(8), this.addVertexAttribute("normals", new Zg());
    }
    rebuild() {
      const A3 = this.getVertexAttribute("normals");
      if (A3)
        for (let g3 = 0; g3 < 6; g3++) {
          let I3;
          switch (g3) {
            case 0:
              I3 = new o(0, 0, 1);
              break;
            case 1:
              I3 = new o(0, 0, -1);
              break;
            case 2:
              I3 = new o(1, 0, 0);
              break;
            case 3:
              I3 = new o(-1, 0, 0);
              break;
            case 4:
              I3 = new o(0, -1, 0);
              break;
            default:
              I3 = new o(0, 1, 0);
          }
          A3.setFaceVertexValue(g3, 0, I3), A3.setFaceVertexValue(g3, 1, I3), A3.setFaceVertexValue(g3, 2, I3), A3.setFaceVertexValue(g3, 3, I3);
        }
      this.resize();
    }
    resize() {
      const A3 = this.sizeXParam.value, g3 = this.sizeYParam.value, I3 = this.sizeZParam.value, C3 = this.baseZAtZeroParam.value;
      let i3 = 0.5;
      const e3 = this.getVertexAttribute("positions");
      C3 && (i3 = 1), e3 && (e3.getValueRef(0).set(0.5 * A3, -0.5 * g3, i3 * I3), e3.getValueRef(1).set(0.5 * A3, 0.5 * g3, i3 * I3), e3.getValueRef(2).set(-0.5 * A3, 0.5 * g3, i3 * I3), e3.getValueRef(3).set(-0.5 * A3, -0.5 * g3, i3 * I3), i3 = -0.5, C3 && (i3 = 0), e3.getValueRef(4).set(0.5 * A3, -0.5 * g3, i3 * I3), e3.getValueRef(5).set(0.5 * A3, 0.5 * g3, i3 * I3), e3.getValueRef(6).set(-0.5 * A3, 0.5 * g3, i3 * I3), e3.getValueRef(7).set(-0.5 * A3, -0.5 * g3, i3 * I3));
    }
  };
  e.register("Cuboid", jg);
  var qg = class extends vg {
    constructor(A3 = 0.5, g3 = 1, I3 = 32, C3 = 2, i3 = true, e3 = false) {
      if (super(), this.topologyParams = [], isNaN(A3) || isNaN(g3) || isNaN(I3) || isNaN(C3))
        throw new Error("Invalid geom args");
      this.radiusParam = this.addParameter(new JA("Radius", A3)), this.heightParam = this.addParameter(new JA("Height", g3)), this.sidesParam = this.addParameter(new JA("Sides", I3 >= 3 ? I3 : 3, [3, 200], 1)), this.loopsParam = this.addParameter(new JA("Loops", C3 >= 2 ? C3 : 2, [1, 200], 1)), this.capsParam = this.addParameter(new fA("Caps", i3)), this.baseZAtZeroParam = this.addParameter(new fA("BaseZAtZero", e3)), this.addVertexAttribute("texCoords", new yg()), this.addVertexAttribute("normals", new Zg()), this.topologyParams.push("Sides"), this.topologyParams.push("Loops"), this.topologyParams.push("Caps");
    }
    rebuild() {
      const A3 = this.sidesParam.value, g3 = this.loopsParam.value, I3 = this.capsParam.value;
      let C3 = A3 * g3;
      I3 && (C3 += 2), this.setNumVertices(C3), I3 ? this.setFaceCounts([2 * A3, A3]) : this.setFaceCounts([0, A3]);
      let i3 = 0;
      if (I3) {
        for (let g4 = 0; g4 < A3; g4++) {
          const I4 = C3 - 1, e4 = g4, t4 = (g4 + 1) % A3;
          this.setFaceVertexIndices(i3++, [I4, e4, t4]);
        }
        for (let I4 = 0; I4 < A3; I4++) {
          const e4 = A3 * (g3 - 1) + I4, t4 = C3 - 2, B3 = A3 * (g3 - 1) + (I4 + 1) % A3;
          this.setFaceVertexIndices(i3++, [e4, t4, B3]);
        }
      }
      for (let I4 = 0; I4 < g3 - 1; I4++)
        for (let g4 = 0; g4 < A3; g4++) {
          const C4 = A3 * I4 + (g4 + 1) % A3, e4 = A3 * I4 + g4, t4 = A3 * (I4 + 1) + g4, B3 = A3 * (I4 + 1) + (g4 + 1) % A3;
          this.setFaceVertexIndices(i3++, [C4, e4, t4, B3]);
        }
      const e3 = this.getVertexAttribute("normals");
      if (e3) {
        if (i3 = 0, I3) {
          const g4 = new o(0, 0, -1);
          for (let I4 = 0; I4 < A3; I4++)
            e3.setFaceVertexValue(i3, 0, g4), e3.setFaceVertexValue(i3, 1, g4), e3.setFaceVertexValue(i3, 2, g4), i3++;
          g4.set(0, 0, 1);
          for (let I4 = 0; I4 < A3; I4++)
            e3.setFaceVertexValue(i3, 0, g4), e3.setFaceVertexValue(i3, 1, g4), e3.setFaceVertexValue(i3, 2, g4), i3++;
        }
        for (let I4 = 0; I4 < g3 - 1; I4++)
          for (let g4 = 0; g4 < A3; g4++) {
            let I5 = g4 / A3 * 2 * Math.PI;
            const C4 = new o(Math.sin(I5), Math.cos(I5), 0);
            e3.setFaceVertexValue(i3, 0, C4), e3.setFaceVertexValue(i3, 1, C4), I5 = (g4 + 1) / A3 * 2 * Math.PI;
            const t4 = new o(Math.sin(I5), Math.cos(I5), 0);
            e3.setFaceVertexValue(i3, 2, t4), e3.setFaceVertexValue(i3, 3, t4), i3++;
          }
      }
      const t3 = this.getVertexAttribute("texCoords");
      if (t3) {
        if (i3 = 0, I3) {
          for (let g4 = 0; g4 < A3; g4++)
            t3.setFaceVertexValue(i3, 0, new B(g4 / A3, 0)), t3.setFaceVertexValue(i3, 1, new B((g4 + 1) / A3, 0)), t3.setFaceVertexValue(i3, 2, new B((g4 + 0.5) / A3, 1)), i3++;
          for (let g4 = 0; g4 < A3; g4++)
            t3.setFaceVertexValue(i3, 0, new B(g4 / A3, 0)), t3.setFaceVertexValue(i3, 1, new B((g4 + 1) / A3, 0)), t3.setFaceVertexValue(i3, 2, new B((g4 + 0.5) / A3, 1)), i3++;
        }
        for (let g4 = 0; g4 < A3; g4++)
          t3.setFaceVertexValue(i3, 0, new B((g4 + 1) / A3, 0)), t3.setFaceVertexValue(i3, 2, new B((g4 + 1) / A3, 1)), t3.setFaceVertexValue(i3, 1, new B(g4 / A3, 0)), t3.setFaceVertexValue(i3, 3, new B(g4 / A3, 1)), i3++;
      }
      this.resize();
    }
    resize() {
      const A3 = this.sidesParam.value, g3 = this.loopsParam.value, I3 = this.radiusParam.value, C3 = this.heightParam.value, i3 = this.capsParam.value, e3 = this.baseZAtZeroParam.value;
      let t3 = A3 * g3;
      i3 && (t3 += 2);
      let B3 = 0, o3 = 0.5;
      e3 && (o3 = 0);
      const s3 = this.getVertexAttribute("positions");
      if (s3) {
        for (let i4 = 0; i4 < g3; i4++) {
          const e4 = i4 / (g3 - 1) * C3 - C3 * o3;
          for (let g4 = 0; g4 < A3; g4++) {
            const C4 = g4 / A3 * 2 * Math.PI;
            s3.getValueRef(B3).set(Math.sin(C4) * I3, Math.cos(C4) * I3, e4), B3++;
          }
        }
        i3 && (s3.getValueRef(t3 - 1).set(0, 0, C3 * (e3 ? 0 : -0.5)), s3.getValueRef(t3 - 2).set(0, 0, C3 * (e3 ? 1 : 0.5)));
      }
      this.dirtyTopology = false, this.dirtyVertices = false, this.computeVertexNormals();
    }
  };
  e.register("Cylinder", qg);
  var $g = class extends vg {
    constructor(A3 = 0.5, g3 = 32) {
      if (super(), this.topologyParams = [], isNaN(A3) || isNaN(g3))
        throw new Error("Invalid geom args");
      this.radiusParam = this.addParameter(new JA("Radius", A3)), this.sidesParam = this.addParameter(new JA("Sides", g3 >= 3 ? g3 : 3, [3, 200], 1)), this.addVertexAttribute("texCoords", new yg()), this.addVertexAttribute("normals", new Zg()), this.topologyParams.push("Sides");
    }
    rebuild() {
      const A3 = this.sidesParam.value;
      this.setNumVertices(A3 + 1), this.setFaceCounts([A3]);
      const g3 = this.getVertexAttribute("positions");
      g3 && g3.getValueRef(0).set(0, 0, 0);
      for (let g4 = 0; g4 < A3; g4++) {
        const I4 = g4 % A3 + 1, C4 = (g4 + 1) % A3 + 1;
        this.setFaceVertexIndices(g4, [0, I4, C4]);
      }
      const I3 = this.getVertexAttribute("normals");
      if (I3) {
        const g4 = new o(0, 0, 1);
        I3.setValue(0, g4);
        for (let C4 = 0; C4 < A3; C4++)
          I3.setValue(C4 + 1, g4);
      }
      const C3 = this.getVertexAttribute("texCoords");
      if (C3) {
        C3.getValueRef(0).set(0.5, 0.5);
        for (let g4 = 0; g4 < A3; g4++) {
          const I4 = g4 / A3 * 2 * Math.PI;
          C3.getValueRef(g4 + 1).set(0.5 * Math.sin(I4) + 0.5, 0.5 * Math.cos(I4) + 0.5);
        }
      }
      this.resize();
    }
    resize() {
      const A3 = this.sidesParam.value, g3 = this.radiusParam.value, I3 = this.getVertexAttribute("positions");
      if (I3)
        for (let C3 = 0; C3 < A3; C3++) {
          const i3 = C3 / A3 * 2 * Math.PI;
          I3.getValueRef(C3 + 1).set(Math.sin(i3) * g3, Math.cos(i3) * g3, 0);
        }
    }
  };
  e.register("Disc", $g);
  var AI = class extends vg {
    constructor(A3 = 1, g3 = 1, I3 = 1, C3 = 1, i3 = true, e3 = true) {
      if (super(), this.topologyParams = [], isNaN(A3) || isNaN(g3) || isNaN(I3) || isNaN(C3))
        throw new Error("Invalid geom args");
      this.sizeXParam = this.addParameter(new JA("SizeX", A3)), this.sizeYParam = this.addParameter(new JA("SizeY", g3)), this.detailXParam = this.addParameter(new JA("DetailX", I3)), this.detailYParam = this.addParameter(new JA("DetailY", C3)), i3 && this.addVertexAttribute("normals", new Zg()), e3 && this.addVertexAttribute("texCoords", new yg()), this.topologyParams.push("DetailX"), this.topologyParams.push("DetailY");
    }
    rebuild() {
      const A3 = this.detailXParam.value, g3 = this.detailYParam.value;
      this.setNumVertices((A3 + 1) * (g3 + 1)), this.setFaceCounts([0, A3 * g3]);
      let I3 = 0;
      for (let C4 = 0; C4 < g3; C4++)
        for (let g4 = 0; g4 < A3; g4++) {
          const i4 = (A3 + 1) * (C4 + 1) + g4, e4 = (A3 + 1) * C4 + g4, t3 = (A3 + 1) * C4 + (g4 + 1), B3 = (A3 + 1) * (C4 + 1) + (g4 + 1);
          this.setFaceVertexIndices(I3, [i4, e4, t3, B3]), I3 += 1;
        }
      let C3 = 0;
      const i3 = this.getVertexAttribute("normals");
      if (i3)
        for (let I4 = 0; I4 <= g3; I4++)
          for (let g4 = 0; g4 <= A3; g4++)
            i3.getValueRef(C3).set(0, 0, 1), C3++;
      C3 = 0;
      const e3 = this.getVertexAttribute("texCoords");
      if (e3)
        for (let I4 = 0; I4 <= g3; I4++) {
          const i4 = I4 / g3;
          for (let g4 = 0; g4 <= A3; g4++) {
            const I5 = g4 / A3;
            e3.getValueRef(C3).set(I5, i4), C3++;
          }
        }
      this.resize();
    }
    resize() {
      const A3 = this.sizeXParam.value, g3 = this.sizeYParam.value, I3 = this.detailXParam.value, C3 = this.detailYParam.value, i3 = this.getVertexAttribute("positions");
      if (!i3)
        return;
      let e3 = 0;
      for (let t3 = 0; t3 <= C3; t3++) {
        const B3 = (t3 / C3 - 0.5) * g3;
        for (let g4 = 0; g4 <= I3; g4++) {
          const C4 = (g4 / I3 - 0.5) * A3;
          i3.getValueRef(e3).set(C4, B3, 0), e3++;
        }
      }
    }
  };
  e.register("Plane", AI);
  var gI = class extends vg {
    constructor(A3 = 1, g3 = 12, I3 = 12, C3 = true, i3 = true) {
      if (super(), this.radiusParam = new JA("Radius", 1), this.sidesParam = new JA("Sides", 12, [3, 200], 1), this.loopsParam = new JA("Loops", 6, [3, 200], 1), isNaN(A3) || isNaN(g3) || isNaN(I3))
        throw new Error("Invalid geom args");
      this.addParameter(this.radiusParam), this.addParameter(this.sidesParam), this.addParameter(this.loopsParam), this.radiusParam.value = A3, this.sidesParam.value = g3, this.loopsParam.value = I3, C3 && this.addVertexAttribute("normals", new Zg()), i3 && this.addVertexAttribute("texCoords", new yg()), this.topologyParams.push("Sides"), this.topologyParams.push("Loops");
    }
    rebuild() {
      const A3 = this.radiusParam.value, g3 = this.sidesParam.value, I3 = this.loopsParam.value, C3 = 2 + g3 * I3, i3 = 2 * g3, e3 = g3 * I3;
      this.setNumVertices(C3), this.setFaceCounts([i3, e3]);
      const t3 = this.getVertexAttribute("positions"), s3 = this.getVertexAttribute("normals"), a3 = new o(0, 0, 1);
      let l3 = 0;
      if (!t3)
        return;
      t3.getValueRef(l3).set(0, 0, A3), s3 && s3.getValueRef(l3).set(0, 0, 1), l3++;
      for (let C4 = 0; C4 < I3; C4++) {
        const i4 = (C4 + 1) / (I3 + 1) * Math.PI;
        for (let I4 = 0; I4 < g3; I4++) {
          const C5 = -I4 / g3 * 2 * Math.PI;
          a3.set(Math.sin(i4) * Math.cos(C5), Math.sin(i4) * Math.sin(C5), Math.cos(i4)), t3.getValueRef(l3).setFromOther(a3.scale(A3)), s3 && s3.getValueRef(l3).setFromOther(a3), l3++;
        }
      }
      t3.getValueRef(l3).set(0, 0, -A3), s3 && s3.getValueRef(l3).set(0, 0, -1), l3++;
      const n3 = this.getVertexAttribute("texCoords");
      let d3 = 0;
      for (let A4 = 0; A4 < g3; A4++) {
        const C4 = 0, i4 = (A4 + 1) % g3 + 1, e4 = A4 + 1;
        if (this.setFaceVertexIndices(d3, [C4, i4, e4]), n3) {
          const C5 = new B(0.5, 0), i5 = new B((A4 + 1) / (g3 - 1), 1 / (I3 + 1)), e5 = new B(A4 / (g3 - 1), 1 / (I3 + 1));
          n3.setFaceVertexValue(d3, 0, C5), n3.setFaceVertexValue(d3, 1, i5), n3.setFaceVertexValue(d3, 2, e5);
        }
        d3++;
      }
      for (let A4 = 0; A4 < g3; A4++) {
        const i4 = C3 - 1, e4 = g3 * (I3 - 1) + (A4 + 1) % g3 + 1, t4 = g3 * (I3 - 1) + A4 + 1;
        if (this.setFaceVertexIndices(d3, [i4, t4, e4]), n3) {
          const C4 = new B(0.5, 1), i5 = new B((A4 + 1) / (g3 - 1), 1 - 1 / (I3 + 1)), e5 = new B(A4 / (g3 - 1), 1 - 1 / (I3 + 1));
          n3.setFaceVertexValue(d3, 0, C4), n3.setFaceVertexValue(d3, 1, i5), n3.setFaceVertexValue(d3, 2, e5);
        }
        d3++;
      }
      for (let A4 = 0; A4 < I3 - 1; A4++)
        for (let C4 = 0; C4 < g3; C4++) {
          const i4 = g3 * A4 + C4 + 1, e4 = g3 * A4 + (C4 + 1) % g3 + 1, t4 = g3 * (A4 + 1) + (C4 + 1) % g3 + 1, o3 = g3 * (A4 + 1) + C4 + 1;
          this.setFaceVertexIndices(d3, [i4, e4, t4, o3]), n3 && (n3.setFaceVertexValue(d3, 0, new B(C4 / g3, (A4 + 1) / I3)), n3.setFaceVertexValue(d3, 1, new B((C4 + 1) / g3, (A4 + 1) / I3)), n3.setFaceVertexValue(d3, 2, new B((C4 + 1) / g3, (A4 + 2) / I3)), n3.setFaceVertexValue(d3, 3, new B(C4 / g3, (A4 + 2) / I3))), d3++;
        }
    }
    resize() {
      const A3 = this.radiusParam.value, g3 = this.sidesParam.value, I3 = this.loopsParam.value;
      if (!g3 || !I3)
        return void console.warn("resize() failed");
      const C3 = this.getVertexAttribute("positions"), i3 = this.getVertexAttribute("normals");
      let e3 = 0;
      const t3 = new o(0, 0, 1);
      C3.getValueRef(e3).set(0, 0, A3), i3 && i3.getValueRef(e3).set(0, 0, 1), e3++;
      for (let B3 = 0; B3 < I3; B3++) {
        const o3 = (B3 + 1) / (I3 + 1) * Math.PI;
        for (let I4 = 0; I4 < g3; I4++) {
          const B4 = -I4 / g3 * 2 * Math.PI;
          t3.set(Math.sin(o3) * Math.cos(B4), Math.sin(o3) * Math.sin(B4), Math.cos(o3)), C3.getValueRef(e3).setFromOther(t3.scale(A3)), i3 && i3.getValueRef(e3).setFromOther(t3), e3++;
        }
      }
      C3.getValueRef(e3).set(0, 0, -A3), i3 && i3.getValueRef(e3).set(0, 0, -1), e3++;
    }
  };
  e.register("Sphere", gI);
  var II = class extends vg {
    constructor(A3 = 0.5, g3 = 3, I3 = 32, C3 = 2 * Math.PI) {
      if (super(), isNaN(A3) || isNaN(g3) || isNaN(I3))
        throw new Error("Invalid geom args");
      this.innerRadiusParam = this.addParameter(new JA("InnerRadius", A3)), this.outerRadiusParam = this.addParameter(new JA("OuterRadius", g3)), this.detailParam = this.addParameter(new JA("Detail", I3 >= 3 ? I3 : 3, [3, 200], 1)), this.arcAngleParam = this.addParameter(new JA("ArcAngle", C3)), this.addVertexAttribute("texCoords", new yg()), this.addVertexAttribute("normals", new Zg()), this.topologyParams.push("Detail"), this.topologyParams.push("ArcAngle");
    }
    rebuild() {
      const A3 = this.arcAngleParam.value < 2 * Math.PI, g3 = this.detailParam.value, I3 = g3, C3 = 2 * g3 + (A3 ? 1 : 0), i3 = I3 * C3;
      this.setNumVertices(i3), this.setFaceCounts([0, I3 * C3]);
      const e3 = this.getVertexAttribute("texCoords");
      if (e3) {
        let g4 = 0;
        for (let i4 = 0; i4 < (A3 ? C3 - 1 : C3); i4++)
          for (let A4 = 0; A4 < I3; A4++) {
            const t3 = (i4 + 1) % C3, o3 = (A4 + 1) % I3, s3 = I3 * i4 + A4, a3 = I3 * i4 + o3, l3 = I3 * t3 + o3, n3 = I3 * t3 + A4;
            this.setFaceVertexIndices(g4, [s3, a3, l3, n3]), e3.setFaceVertexValue(g4, 0, new B(i4 / C3, A4 / C3)), e3.setFaceVertexValue(g4, 1, new B(i4 / C3, (A4 + 1) / C3)), e3.setFaceVertexValue(g4, 2, new B((i4 + 1) / C3, (A4 + 1) / C3)), e3.setFaceVertexValue(g4, 3, new B((i4 + 1) / C3, A4 / C3)), g4++;
          }
      }
      this.resize();
    }
    resize() {
      const A3 = this.innerRadiusParam.value, g3 = this.outerRadiusParam.value, I3 = this.arcAngleParam.value, C3 = this.detailParam.value, i3 = I3 < 2 * Math.PI, e3 = C3, t3 = 2 * C3 + (i3 ? 1 : 0), B3 = this.getVertexAttribute("positions"), o3 = this.getVertexAttribute("normals");
      if (!B3 || !o3)
        return;
      let s3 = 0;
      for (let C4 = 0; C4 < t3; C4++) {
        const a3 = -C4 / (i3 ? t3 - 1 : t3) * I3, l3 = Math.cos(a3), n3 = Math.sin(a3);
        for (let I4 = 0; I4 < e3; I4++) {
          const C5 = I4 / e3 * 2 * Math.PI, i4 = Math.sin(C5), t4 = Math.cos(C5), a4 = g3 + t4 * A3;
          B3.getValueRef(s3).set(l3 * a4, n3 * a4, A3 * i4), o3.getValueRef(s3).set(l3 * t4, n3 * t4, i4), s3++;
        }
      }
    }
  };
  e.register("Torus", II);
  var CI = class extends Gg {
    constructor(A3) {
      super(A3), this.__data = new Uint8Array(4), this.format = "RGBA", this.type = "UNSIGNED_BYTE", this.width = 1, this.height = 1;
    }
    isLoaded() {
      return this.loaded;
    }
    isStream() {
      return false;
    }
    setData(A3, g3, I3) {
      this.__data != I3 && (this.width = A3, this.height = g3, this.__data = I3, this.loaded ? this.emit("updated") : (this.loaded = true, this.emit("loaded")));
    }
    getParams() {
      const A3 = super.getParams();
      return A3.data = this.__data, A3;
    }
  };
  e.register("DataImage2D", CI), e.register("DataImage", CI);
  var iI = {};
  var eI = class extends Gg {
    constructor(A3, g3 = "", I3 = {}) {
      super(A3), this.__data = null, this.type = "UNSIGNED_BYTE", this.crossOrigin = "anonymous", g3 && g3 != "" && this.load(g3);
    }
    setCrossOrigin(A3) {
      this.crossOrigin = A3;
    }
    getDOMElement() {
      return this.__data;
    }
    load(A3, g3 = "RGB") {
      return new Promise((I3, C3) => {
        if (!g3) {
          const I4 = A3.lastIndexOf(".");
          if (I4 != -1) {
            A3.substring(I4).toLowerCase() == ".png" && (g3 = "RGBA");
          }
        }
        this.format = g3, this.loaded = false;
        const i3 = () => {
          this.url = A3, this.width = this.__data.width, this.height = this.__data.height, this.loaded = true, this.emit("loaded"), I3();
        };
        A3 in iI ? (this.__data = iI[A3], this.__data.complete ? i3() : (this.__data.addEventListener("load", i3), this.__data.addEventListener("error", C3))) : (this.__data = new Image(), this.__data.crossOrigin = this.crossOrigin, this.__data.src = A3, this.__data.addEventListener("load", i3), this.__data.addEventListener("error", C3), iI[A3] = this.__data);
      });
    }
    setImageURL(A3, g3 = "RGB") {
      this.load(A3, g3);
    }
    getParams() {
      const A3 = super.getParams();
      return this.loaded && (A3.data = this.__data), A3;
    }
    readBinary(A3, g3) {
      this.setName(A3.loadStr());
      const I3 = A3.loadStr();
      if (typeof I3 == "string" && I3 != "") {
        const A4 = g3.url.substring(0, g3.url.lastIndexOf("/"));
        this.load(A4 + "/" + I3);
      }
    }
  };
  e.register("FileImage2D", eI), e.register("FileImage", eI);
  var tI = class extends eI {
    constructor(A3, g3, I3) {
      super(A3, g3, I3);
    }
  };
  e.register("LDRImage", tI);
  var BI = class extends Gg {
    constructor(A3, g3 = {}) {
      let I3;
      super(A3), this.exposure = 1, this.hdrTint = new l(1, 1, 1, 1), A3 != null && A3.includes(".") && (I3 = A3, this.setName(A3.substring(A3.lastIndexOf("/") + 1, A3.lastIndexOf(".")))), this.type = "FLOAT", I3 && this.load(I3);
    }
    __decodeData(A3) {
      return new Promise((g3, I3) => {
        const C3 = A3.ldr, i3 = A3.cdm, e3 = new Blob([C3.buffer]), t3 = new Image();
        t3.onload = () => {
          this.width = t3.width, this.height = t3.height, this.__data = {ldr: t3, cdm: i3}, this.loaded ? this.emit("updated") : (this.loaded = true, this.emit("loaded")), g3();
        }, t3.src = URL.createObjectURL(e3);
      });
    }
    load(A3) {
      return this.loaded = false, new Promise((g3, I3) => {
        const C3 = A3.lastIndexOf("/") > -1 ? A3.substring(A3.lastIndexOf("/") + 1) : "", i3 = C3.substring(0, C3.lastIndexOf("."));
        this.getName() == "" && this.setName(i3), this.type = "FLOAT", FA.loadFile("archive", A3).then((A4) => {
          if (!A4.ldr || !A4.cdm)
            for (const g4 in A4)
              g4.endsWith(".jpg") ? (A4.ldr = A4[g4], delete A4[g4]) : g4.endsWith(".bin") && (A4.cdm = A4[g4], delete A4[g4]);
          this.__decodeData(A4).then(() => {
            g3();
          });
        }, (A4) => {
          this.emit("error", A4), I3(A4);
        });
      });
    }
    isStream() {
      return false;
    }
    getParams() {
      const A3 = super.getParams();
      return this.loaded && (A3.data = this.__data, A3.exposure = this.exposure), A3;
    }
    setHDRTint(A3) {
      this.hdrTint = A3;
    }
    getHDRTint() {
      return this.hdrTint;
    }
    readBinary(A3, g3) {
      this.setName(A3.loadStr());
      let I3 = A3.loadStr();
      typeof I3 == "string" && I3 != "" && this.load(I3);
    }
  };
  e.register("HDRImage", BI);
  var oI = class extends eI {
    constructor(A3, g3, I3) {
      super(A3, g3, I3), this.videoElem = new HTMLVideoElement(), this.muteParam = new fA("Mute", false), this.loopParam = new fA("Loop", true), this.spatializeAudioParam = new fA("SpatializeAudio", true), this.refDistanceParam = new JA("refDistance", 2), this.maxDistanceParam = new JA("maxDistance", 1e4), this.rolloffFactorParam = new JA("rolloffFactor", 1), this.coneInnerAngleParam = new JA("coneInnerAngle", 360), this.coneOuterAngleParam = new JA("coneOuterAngle", 0), this.coneOuterGainParam = new JA("coneOuterGain", 1), this.gainParam = new JA("Gain", 2), this.format = "RGB", this.type = "UNSIGNED_BYTE", this.addParameter(this.muteParam), this.addParameter(this.loopParam), this.addParameter(this.spatializeAudioParam), this.addParameter(this.refDistanceParam), this.addParameter(this.maxDistanceParam), this.addParameter(this.rolloffFactorParam), this.addParameter(this.coneInnerAngleParam), this.addParameter(this.coneOuterAngleParam), this.addParameter(this.coneOuterGainParam), this.addParameter(this.gainParam).setRange([0, 5]);
    }
    getAudioSource() {
      return this.videoElem;
    }
    load(A3, g3 = "RGB") {
      return new Promise((g4, I3) => {
        FA.incrementWorkload(1), this.videoElem.style.display = "none", this.videoElem.preload = "auto", this.videoElem.crossOrigin = "anonymous", document.body.appendChild(this.videoElem), this.videoElem.addEventListener("loadedmetadata", () => {
          this.videoElem.muted = this.muteParam.value, this.muteParam.on("valueChanged", () => {
            this.videoElem.muted = this.muteParam.value;
          }), this.videoElem.loop = this.loopParam.value, this.loopParam.on("valueChanged", () => {
            this.videoElem.loop = this.loopParam.value;
          }), this.width = this.videoElem.videoHeight, this.height = this.videoElem.videoWidth, this.loaded = true, FA.incrementWorkDone(1), this.emit("loaded"), g4(C3);
          let A4 = 0;
          const I4 = () => {
            if (this.videoElem.paused || this.videoElem.ended)
              return;
            const g5 = Math.floor(29.97 * this.videoElem.currentTime);
            A4 != g5 && (this.emit("updated"), A4 = g5), setTimeout(I4, 20);
          };
          I4();
        }, false), this.videoElem.src = A3;
        const C3 = this.videoElem.play();
        C3 !== void 0 && C3.then((A4) => {
          console.log("Autoplay started!");
        }).catch(() => {
          console.log("Autoplay was prevented.");
        });
      });
    }
    getParams() {
      const A3 = super.getParams();
      return this.loaded && (A3.data = this.videoElem), A3;
    }
  };
  function sI(A3) {
    this.data = A3, this.pos = 0;
  }
  function aI(A3) {
    this.stream = new sI(A3), this.output = {};
  }
  e.register("LDRVideo", oI), sI.prototype.readByte = function() {
    return this.data[this.pos++];
  }, sI.prototype.peekByte = function() {
    return this.data[this.pos];
  }, sI.prototype.readBytes = function(A3) {
    for (var g3 = new Array(A3), I3 = 0; I3 < A3; I3++)
      g3[I3] = this.readByte();
    return g3;
  }, sI.prototype.peekBytes = function(A3) {
    for (var g3 = new Array(A3), I3 = 0; I3 < A3; I3++)
      g3[I3] = this.data[this.pos + I3];
    return g3;
  }, sI.prototype.readString = function(A3) {
    for (var g3 = "", I3 = 0; I3 < A3; I3++)
      g3 += String.fromCharCode(this.readByte());
    return g3;
  }, sI.prototype.readBitArray = function() {
    for (var A3 = [], g3 = this.readByte(), I3 = 7; I3 >= 0; I3--)
      A3.push(!!(g3 & 1 << I3));
    return A3;
  }, sI.prototype.readUnsigned = function(A3) {
    var g3 = this.readBytes(2);
    return A3 ? (g3[1] << 8) + g3[0] : (g3[0] << 8) + g3[1];
  }, aI.prototype.parse = function(A3) {
    return this.parseParts(this.output, A3), this.output;
  }, aI.prototype.parseParts = function(A3, g3) {
    for (var I3 = 0; I3 < g3.length; I3++) {
      var C3 = g3[I3];
      this.parsePart(A3, C3);
    }
  }, aI.prototype.parsePart = function(A3, g3) {
    var I3, C3 = g3.label;
    if (!g3.requires || g3.requires(this.stream, this.output, A3))
      if (g3.loop) {
        for (var i3 = []; g3.loop(this.stream); ) {
          var e3 = {};
          this.parseParts(e3, g3.parts), i3.push(e3);
        }
        A3[C3] = i3;
      } else
        g3.parts ? (I3 = {}, this.parseParts(I3, g3.parts), A3[C3] = I3) : g3.parser ? (I3 = g3.parser(this.stream, this.output, A3), g3.skip || (A3[C3] = I3)) : g3.bits && (A3[C3] = this.parseBits(g3.bits));
  }, aI.prototype.parseBits = function(A3) {
    var g3 = {}, I3 = this.stream.readBitArray();
    for (var C3 in A3) {
      var i3 = A3[C3];
      i3.length ? g3[C3] = I3.slice(i3.index, i3.index + i3.length).reduce(function(A4, g4) {
        return 2 * A4 + g4;
      }, 0) : g3[C3] = I3[i3.index];
    }
    return g3;
  };
  var lI = function() {
    return function(A3) {
      return A3.readByte();
    };
  };
  var nI = function(A3) {
    return function(g3) {
      return g3.readBytes(A3);
    };
  };
  var dI = function(A3) {
    return function(g3) {
      return g3.readString(A3);
    };
  };
  var hI = function(A3) {
    return function(g3) {
      return g3.readUnsigned(A3);
    };
  };
  var cI = function(A3, g3) {
    return function(I3, C3, i3) {
      for (var e3 = g3(I3, C3, i3), t3 = new Array(e3), B3 = 0; B3 < e3; B3++)
        t3[B3] = I3.readBytes(A3);
      return t3;
    };
  };
  var rI = {label: "blocks", parser: function(A3) {
    for (var g3 = [], I3 = A3.readByte(); I3 !== 0; I3 = A3.readByte())
      g3 = g3.concat(A3.readBytes(I3));
    return g3;
  }};
  var GI = {label: "gce", requires: function(A3) {
    var g3 = A3.peekBytes(2);
    return g3[0] === 33 && g3[1] === 249;
  }, parts: [{label: "codes", parser: nI(2), skip: true}, {label: "byteSize", parser: lI()}, {label: "extras", bits: {future: {index: 0, length: 3}, disposal: {index: 3, length: 3}, userInput: {index: 6}, transparentColorGiven: {index: 7}}}, {label: "delay", parser: hI(true)}, {label: "transparentColorIndex", parser: lI()}, {label: "terminator", parser: lI(), skip: true}]};
  var mI = {label: "image", requires: function(A3) {
    return A3.peekByte() === 44;
  }, parts: [{label: "code", parser: lI(), skip: true}, {label: "descriptor", parts: [{label: "left", parser: hI(true)}, {label: "top", parser: hI(true)}, {label: "width", parser: hI(true)}, {label: "height", parser: hI(true)}, {label: "lct", bits: {exists: {index: 0}, interlaced: {index: 1}, sort: {index: 2}, future: {index: 3, length: 2}, size: {index: 5, length: 3}}}]}, {label: "lct", requires: function(A3, g3, I3) {
    return I3.descriptor.lct.exists;
  }, parser: cI(3, function(A3, g3, I3) {
    return Math.pow(2, I3.descriptor.lct.size + 1);
  })}, {label: "data", parts: [{label: "minCodeSize", parser: lI()}, rI]}]};
  var QI = {label: "text", requires: function(A3) {
    var g3 = A3.peekBytes(2);
    return g3[0] === 33 && g3[1] === 1;
  }, parts: [{label: "codes", parser: nI(2), skip: true}, {label: "blockSize", parser: lI()}, {label: "preData", parser: function(A3, g3, I3) {
    return A3.readBytes(I3.text.blockSize);
  }}, rI]};
  var EI = {label: "frames", parts: [GI, {label: "application", requires: function(A3, g3, I3) {
    var C3 = A3.peekBytes(2);
    return C3[0] === 33 && C3[1] === 255;
  }, parts: [{label: "codes", parser: nI(2), skip: true}, {label: "blockSize", parser: lI()}, {label: "id", parser: function(A3, g3, I3) {
    return A3.readString(I3.blockSize);
  }}, rI]}, {label: "comment", requires: function(A3, g3, I3) {
    var C3 = A3.peekBytes(2);
    return C3[0] === 33 && C3[1] === 254;
  }, parts: [{label: "codes", parser: nI(2), skip: true}, rI]}, mI, QI], loop: function(A3) {
    var g3 = A3.peekByte();
    return g3 === 33 || g3 === 44;
  }};
  var bI = [{label: "header", parts: [{label: "signature", parser: dI(3)}, {label: "version", parser: dI(3)}]}, {label: "lsd", parts: [{label: "width", parser: hI(true)}, {label: "height", parser: hI(true)}, {label: "gct", bits: {exists: {index: 0}, resolution: {index: 1, length: 3}, sort: {index: 4}, size: {index: 5, length: 3}}}, {label: "backgroundColorIndex", parser: lI()}, {label: "pixelAspectRatio", parser: lI()}]}, {label: "gct", requires: function(A3, g3) {
    return g3.lsd.gct.exists;
  }, parser: cI(3, function(A3, g3) {
    return Math.pow(2, g3.lsd.gct.size + 1);
  })}, EI];
  function ZI(A3) {
    var g3 = new aI(new Uint8Array(A3));
    this.raw = g3.parse(bI), this.raw.hasImages = false;
    for (var I3 = 0; I3 < this.raw.frames.length; I3++)
      if (this.raw.frames[I3].image) {
        this.raw.hasImages = true;
        break;
      }
  }
  ZI.prototype.decompressFrame = function(A3, g3) {
    if (A3 >= this.raw.frames.length)
      return null;
    var I3 = this.raw.frames[A3];
    if (I3.image) {
      var C3 = I3.image.descriptor.width * I3.image.descriptor.height, i3 = function(A4, g4, I4) {
        var C4, i4, e4, t3, B3, o3, s3, a3, l3, n3, d3, h3, c3, r3, G3, m3, Q3 = 4096, E3 = -1, b3 = I4, Z3 = new Array(I4), y3 = new Array(Q3), u3 = new Array(Q3), R3 = new Array(Q3 + 1);
        for (B3 = (i4 = 1 << (h3 = A4)) + 1, C4 = i4 + 2, s3 = E3, e4 = (1 << (t3 = h3 + 1)) - 1, l3 = 0; l3 < i4; l3++)
          y3[l3] = 0, u3[l3] = l3;
        for (d3 = a3 = c3 = r3 = m3 = G3 = 0, n3 = 0; n3 < b3; ) {
          if (r3 === 0) {
            if (a3 < t3) {
              d3 += g4[G3] << a3, a3 += 8, G3++;
              continue;
            }
            if (l3 = d3 & e4, d3 >>= t3, a3 -= t3, l3 > C4 || l3 == B3)
              break;
            if (l3 == i4) {
              e4 = (1 << (t3 = h3 + 1)) - 1, C4 = i4 + 2, s3 = E3;
              continue;
            }
            if (s3 == E3) {
              R3[r3++] = u3[l3], s3 = l3, c3 = l3;
              continue;
            }
            for (o3 = l3, l3 == C4 && (R3[r3++] = c3, l3 = s3); l3 > i4; )
              R3[r3++] = u3[l3], l3 = y3[l3];
            c3 = 255 & u3[l3], R3[r3++] = c3, C4 < Q3 && (y3[C4] = s3, u3[C4] = c3, (++C4 & e4) == 0 && C4 < Q3 && (t3++, e4 += C4)), s3 = o3;
          }
          r3--, Z3[m3++] = R3[r3], n3++;
        }
        for (n3 = m3; n3 < b3; n3++)
          Z3[n3] = 0;
        return Z3;
      }(I3.image.data.minCodeSize, I3.image.data.blocks, C3);
      I3.image.descriptor.lct.interlaced && (i3 = function(A4, g4) {
        for (var I4 = new Array(A4.length), C4 = A4.length / g4, i4 = function(C5, i5) {
          var e5 = A4.slice(i5 * g4, (i5 + 1) * g4);
          I4.splice.apply(I4, [C5 * g4, g4].concat(e5));
        }, e4 = [0, 4, 2, 1], t3 = [8, 8, 4, 2], B3 = 0, o3 = 0; o3 < 4; o3++)
          for (var s3 = e4[o3]; s3 < C4; s3 += t3[o3])
            i4(s3, B3), B3++;
        return I4;
      }(i3, I3.image.descriptor.width));
      var e3 = {pixels: i3, dims: {top: I3.image.descriptor.top, left: I3.image.descriptor.left, width: I3.image.descriptor.width, height: I3.image.descriptor.height}};
      return I3.image.descriptor.lct && I3.image.descriptor.lct.exists ? e3.colorTable = I3.image.lct : e3.colorTable = this.raw.gct, I3.gce && (e3.delay = 10 * (I3.gce.delay || 10), e3.disposalType = I3.gce.extras.disposal, I3.gce.extras.transparentColorGiven && (e3.transparentIndex = I3.gce.transparentColorIndex)), g3 && (e3.patch = function(A4) {
        for (var g4 = A4.pixels.length, I4 = new Uint8ClampedArray(4 * g4), C4 = 0; C4 < g4; C4++) {
          var i4 = 4 * C4, e4 = A4.pixels[C4], t3 = A4.colorTable[e4];
          I4[i4] = t3[0], I4[i4 + 1] = t3[1], I4[i4 + 2] = t3[2], I4[i4 + 3] = e4 !== A4.transparentIndex ? 255 : 0;
        }
        return I4;
      }(e3)), e3;
    }
    return null;
  }, ZI.prototype.decompressFrames = function(A3) {
    for (var g3 = [], I3 = 0; I3 < this.raw.frames.length; I3++) {
      this.raw.frames[I3].image && g3.push(this.decompressFrame(I3, A3));
    }
    return g3;
  };
  var yI = {};
  var uI = class extends eI {
    constructor(A3, g3 = "", I3 = {}) {
      super(A3, g3, I3), this.streamAtlasDescParam = new UA("StreamAtlasDesc"), this.streamAtlasIndexParam = new JA("StreamAtlasIndex", 0), this.format = "RGBA", this.type = "UNSIGNED_BYTE", this.__streamAtlas = true, this.addParameter(this.streamAtlasDescParam), this.addParameter(this.streamAtlasIndexParam);
      const C3 = this.streamAtlasIndexParam;
      let i3;
      C3.setRange([0, 1]);
      let e3 = 0;
      const t3 = (A4) => {
        C3.value = e3, i3 && setTimeout(() => t3(A4), this.getFrameDelay(e3)), e3 = (e3 + 1) % A4;
      };
      this.play = () => {
        this.__resourcePromise.then(() => {
          i3 = true;
          let A4 = C3.getRange();
          if (!A4)
            return void console.warn("numFrames is null");
          const g4 = A4[1];
          t3(g4);
        });
      }, this.stop = () => {
        i3 = false;
      };
    }
    getFrameDelay(A3) {
      return 10 * this.__unpackedData.frameDelays[A3];
    }
    load(A3, g3 = "RGB") {
      return A3 in yI ? (this.__resourcePromise = yI[A3], this.__resourcePromise) : (this.__resourcePromise = new Promise((g4, I3) => {
        FA.incrementWorkload(1), GA(A3, (I4) => {
          console.warn("Unpacking Gif client side:" + A3);
          const C3 = performance.now(), i3 = new ZI(I4).decompressFrames(true), e3 = Math.sqrt(i3.length), t3 = [e3, e3];
          r.fract(e3) > 0 && (t3[0] = Math.floor(t3[0] + 1), r.fract(e3) > 0.5 ? t3[1] = Math.floor(t3[1] + 1) : t3[1] = Math.floor(t3[1]));
          const B3 = i3[0].dims.width, o3 = i3[0].dims.height, s3 = document.createElement("canvas"), a3 = s3.getContext("2d"), l3 = document.createElement("canvas"), n3 = l3.getContext("2d");
          l3.width = B3, l3.height = o3;
          const d3 = document.createElement("canvas"), h3 = d3.getContext("2d");
          let c3;
          d3.width = t3[0] * B3, d3.height = t3[1] * o3;
          const G3 = [], m3 = (A4, g5) => {
            const I5 = A4.dims;
            G3.push(A4.delay / 10), c3 && I5.width == c3.width && I5.height == c3.height || (s3.width = I5.width, s3.height = I5.height, c3 = a3 == null ? void 0 : a3.createImageData(I5.width, I5.height)), c3.data.set(A4.patch), a3 == null || a3.putImageData(c3, 0, 0), A4.disposalType == 2 && (n3 == null || n3.clearRect(0, 0, l3.width, l3.height)), n3 == null || n3.drawImage(s3, I5.left, I5.top), h3 == null || h3.drawImage(l3, g5 % t3[0] * B3, Math.floor(g5 / t3[0]) * o3);
          };
          for (let A4 = 0; A4 < i3.length; A4++)
            m3(i3[A4], A4);
          FA.incrementWorkDone(1);
          const Q3 = h3 == null ? void 0 : h3.getImageData(0, 0, d3.width, d3.height), E3 = performance.now() - C3;
          console.log(`Decode GIF '${A3}' time:` + E3), g4({width: d3.width, height: d3.height, atlasSize: t3, frameRange: [0, i3.length], frameDelays: G3, imageData: Q3});
        }, (g5) => {
          const C3 = "Unable to Load URL:" + g5 + ":" + A3;
          console.warn(C3), I3(C3);
        });
      }), yI[A3] = this.__resourcePromise, this.__resourcePromise.then((A4) => {
        this.width = A4.width, this.height = A4.height, this.streamAtlasDescParam.value = new s(A4.atlasSize[0], A4.atlasSize[1], 0, 0), this.streamAtlasIndexParam.setRange(A4.frameRange), this.__unpackedData = A4, this.__data = A4.imageData, this.loaded = true, this.emit("loaded");
      }), this.__resourcePromise);
    }
  };
  e.register("GIFImage", uI);
  var RI = class extends BI {
    constructor(A3, g3 = {}) {
      super(A3, g3), this.headlightModeParam = new fA("HeadLightMode", false), this.addParameter(this.headlightModeParam), this.utf8decoder = new TextDecoder(), this.shCoeffs = [];
    }
    __decodeData(A3) {
      const g3 = A3.samples;
      if (g3 && (this.luminanceData = JSON.parse(this.utf8decoder.decode(g3)), this.luminanceData.shCoeffs))
        for (let A4 = 0; A4 < 9; A4++)
          this.shCoeffs[A4] = new l(this.luminanceData.shCoeffs[3 * A4 + 0], this.luminanceData.shCoeffs[3 * A4 + 1], this.luminanceData.shCoeffs[3 * A4 + 2]);
      return super.__decodeData(A3);
    }
    dirToLuminance(A3) {
      const g3 = A3.x, I3 = A3.y, C3 = A3.z, i3 = this.shCoeffs[0].scale(0.886227);
      return i3.addInPlace(this.shCoeffs[1].scale(1.023328 * I3)), i3.addInPlace(this.shCoeffs[2].scale(1.023328 * C3)), i3.addInPlace(this.shCoeffs[3].scale(1.023328 * g3)), i3.addInPlace(this.shCoeffs[4].scale(0.858086 * g3 * I3)), i3.addInPlace(this.shCoeffs[5].scale(0.858086 * I3 * C3)), i3.addInPlace(this.shCoeffs[6].scale(0.743125 * C3 * C3 - 0.247708)), i3.addInPlace(this.shCoeffs[7].scale(0.858086 * g3 * C3)), i3.addInPlace(this.shCoeffs[8].scale(0.429043 * (g3 * g3 - I3 * I3))), i3.luminance();
    }
  };
  e.register("EnvMap", RI);
  var VI = class extends V {
    constructor() {
      super(), this.__labelLibraries = {}, this.__language = function() {
        if (!globalThis.navigator)
          return "en";
        const A3 = new URLSearchParams(window.location.search);
        if (A3.has("lang"))
          return A3.get("lang");
        const g3 = globalThis.navigator;
        let I3, C3;
        const i3 = (A4) => A4.startsWith("en") ? "En" : A4.startsWith("es") ? "Es" : A4.startsWith("fr") ? "Fr" : A4.startsWith("gb") || A4.startsWith("de") ? "Gb" : A4;
        if (Array.isArray(g3.languages)) {
          for (I3 = 0; I3 < g3.languages.length; I3++)
            if (C3 = g3.languages[I3], C3 && C3.length)
              return i3(C3);
        }
        return null;
      }(), this.__foundLabelLibraries = {};
    }
    loadLibrary(A3, g3) {
      const I3 = A3.substring(0, A3.lastIndexOf("."));
      if (this.__foundLabelLibraries[I3] = g3, A3.endsWith(".labels"))
        rA(g3, (A4) => {
          this.__labelLibraries[I3] = JSON.parse(A4), this.emit("labelLibraryLoaded", {library: I3});
        });
      else if (A3.endsWith(".xlsx")) {
        const A4 = globalThis.XLSX;
        GA(g3, (g4) => {
          const C3 = new Uint8Array(g4), i3 = A4.read(C3, {type: "array"}), e3 = {};
          i3.SheetNames.forEach(function(g5) {
            A4.utils.sheet_to_json(i3.Sheets[g5], {}).forEach(function(A5) {
              const g6 = A5.Identifier;
              delete A5.Identifier, e3[g6] = A5;
            });
          }), this.__labelLibraries[I3] = e3, this.emit("labelLibraryLoaded", {library: I3});
        });
      }
    }
    isLibraryFound(A3) {
      return A3 in this.__foundLabelLibraries;
    }
    isLibraryLoaded(A3) {
      return A3 in this.__labelLibraries;
    }
    getLabelText(A3, g3) {
      const I3 = this.__labelLibraries[A3];
      if (!I3)
        throw new Error("LabelLibrary: '" + A3 + "' not found in LabelManager. Found: [" + Object.keys(this.__labelLibraries) + "]");
      const C3 = I3[g3];
      if (!C3)
        throw new Error("Label: '" + g3 + "' not found in LabelLibrary: '" + A3 + "'. Found: [" + Object.keys(I3) + "]");
      const i3 = C3[this.__language];
      if (!i3) {
        if (C3.En)
          return C3.En;
        throw new Error("labelText: '" + this.__language + "' not found in Label. Found: [" + Object.keys(C3) + "]");
      }
      return i3;
    }
    setLabelText(A3, g3, I3) {
      let C3 = this.__labelLibraries[A3];
      C3 || (C3 = {}, this.__labelLibraries[A3] = C3);
      let i3 = C3[g3];
      i3 || (i3 = {}, C3[g3] = i3), i3[this.__language] = I3;
    }
    setLanguage(A3) {
      this.__language = A3;
    }
  };
  var FI = new VI();
  var SI = class extends CI {
    constructor(A3, g3) {
      super(A3), this.requestedReRender = false, this.libraryParam = new jA("Library"), this.textParam = new jA("Text", ""), this.fontColorParam = new xA("FontColor", new l(0, 0, 0)), this.fontSizeParam = new JA("FontSize", 22), this.fontParam = new jA("Font", "Helvetica"), this.borderWidthParam = new JA("BorderWidth", 2), this.outlineParam = new fA("Outline", false), this.outlineColorParam = new xA("OutlineColor", new l(0, 0, 0)), this.backgroundParam = new fA("Background", true), this.backgroundColorParam = new xA("BackgroundColor", new l("#FBC02D")), this.fillBackgroundParam = new fA("FillBackground", true), this.strokeBackgroundOutlineParam = new fA("StrokeBackgroundOutline", true), this.canvasElem = document.createElement("canvas");
      this.marginParam = new JA("Margin", 11), this.borderRadiusParam = new JA("BorderRadius", 11), this.addParameter(this.marginParam), this.addParameter(this.borderRadiusParam), this.addParameter(this.libraryParam), this.addParameter(this.textParam), this.addParameter(this.fontColorParam), this.addParameter(this.fontSizeParam), this.addParameter(this.fontParam), this.addParameter(this.borderWidthParam), this.addParameter(this.outlineParam), this.addParameter(this.outlineColorParam), this.addParameter(this.backgroundParam), this.addParameter(this.backgroundColorParam), this.addParameter(this.fillBackgroundParam), this.addParameter(this.strokeBackgroundOutlineParam);
      this.on("nameChanged", () => {
        this.loadLabelData();
      }), g3 && (this.libraryParam.value = g3), this.requestedReRender = false, this.needsRender = false, this.loadLabelData();
    }
    __parameterValueChanged(A3) {
      super.parameterValueChanged(A3), this.requestedReRender || (this.requestedReRender = true, this.loadLabelData());
    }
    loadLabelData() {
      Promise.all([(() => new Promise((A3) => {
        const g3 = this.libraryParam.value;
        if (g3 == "")
          return void A3();
        if (!FI.isLibraryFound(g3))
          return console.warn("Label Library not found:", g3), void A3();
        const I3 = () => {
          try {
            const A4 = this.getName(), I4 = FI.getLabelText(g3, A4);
            this.textParam.value = I4;
          } catch (A4) {
            console.warn(A4);
          }
          A3();
        };
        FI.isLibraryLoaded(g3) ? I3() : FI.on("labelLibraryLoaded", (A4) => {
          A4.library == g3 && I3();
        });
      }))(), (() => new Promise((A3) => {
        if (document.fonts != null) {
          const g3 = this.fontParam.value, I3 = this.fontSizeParam.value;
          document.fonts.load(I3 + 'px "' + g3 + '"').then(() => {
            A3();
          });
        } else
          A3();
      }))()]).then(() => {
        this.requestedReRender = false, this.needsRender = true, this.loaded ? this.emit("updated") : (this.loaded = true, this.emit("loaded"));
      });
    }
    renderLabelToImage() {
      const A3 = this.canvasElem.getContext("2d", {alpha: true});
      let g3 = this.textParam.value;
      g3 == "" && (g3 = this.getName());
      const I3 = this.fontParam.value, C3 = this.fontColorParam.value, i3 = this.fontSizeParam.value, e3 = this.marginParam.value, t3 = this.borderWidthParam.value, B3 = this.borderRadiusParam.value, o3 = this.outlineParam.value, s3 = this.outlineColorParam.value, a3 = this.backgroundParam.value, l3 = this.backgroundColorParam.value, n3 = this.fillBackgroundParam.value, d3 = this.strokeBackgroundOutlineParam.value, h3 = e3 + t3, c3 = g3.split("\n");
      A3.font = i3 + 'px "' + I3 + '"';
      let r3 = 0;
      c3.forEach((g4) => {
        r3 = Math.max(A3.measureText(g4).width, r3);
      });
      const G3 = i3;
      this.width = Math.ceil(r3 + 2 * h3), this.height = Math.ceil(G3 * c3.length + 2 * h3), A3.canvas.width = this.width, A3.canvas.height = this.height, this.canvasElem.width = this.width, this.canvasElem.height = this.height, A3.fillStyle = "rgba(0, 0, 0, 0.0)", A3.fillRect(0, 0, this.width, this.height), a3 && (A3.fillStyle = l3.toHex(), A3.strokeStyle = s3.toHex(), function(A4, g4, I4, C4, i4, e4, t4 = false, B4 = true, o4) {
        if (B4 === void 0 && (B4 = true), e4 === void 0 && (e4 = 5), typeof e4 == "number")
          e4 = {tl: e4, tr: e4, br: e4, bl: e4};
        else {
          const A5 = {tl: 0, tr: 0, br: 0, bl: 0};
          for (const g5 in A5)
            e4[g5] = e4[g5] || A5[g5];
        }
        A4.beginPath(), A4.moveTo(g4 + e4.tl, I4), A4.lineTo(g4 + C4 - e4.tr, I4), A4.quadraticCurveTo(g4 + C4, I4, g4 + C4, I4 + e4.tr), A4.lineTo(g4 + C4, I4 + i4 - e4.br), A4.quadraticCurveTo(g4 + C4, I4 + i4, g4 + C4 - e4.br, I4 + i4), A4.lineTo(g4 + e4.bl, I4 + i4), A4.quadraticCurveTo(g4, I4 + i4, g4, I4 + i4 - e4.bl), A4.lineTo(g4, I4 + e4.tl), A4.quadraticCurveTo(g4, I4, g4 + e4.tl, I4), A4.closePath(), t4 && A4.fill(), B4 && (A4.lineWidth = o4, A4.stroke());
      }(A3, t3, t3, this.width - 2 * t3, this.height - 2 * t3, B3, n3, d3, t3)), A3.font = i3 + 'px "' + I3 + '"', A3.textAlign = "left", A3.fillStyle = C3.toHex(), A3.textBaseline = "hanging", c3.forEach((g4, I4) => {
        A3.fillText(g4, h3, h3 + I4 * G3);
      }), o3 && (A3.strokeStyle = s3.toHex(), A3.lineWidth = 1.5, A3.strokeText(g3, h3, h3)), this.__data = A3.getImageData(0, 0, this.width, this.height), this.needsRender = false, this.emit("labelRendered", {width: this.width, height: this.height, data: this.__data});
    }
    getParams() {
      return this.needsRender && this.renderLabelToImage(), super.getParams();
    }
  };
  e.register("Label", SI);
  var wI = class extends Gg {
    constructor() {
      super("");
    }
    connectWebcam(A3, g3, I3 = false) {
      const C3 = {width: A3, height: g3, frameRate: {ideal: 60, max: 60}};
      C3.facingMode = I3 ? {exact: "environment"} : {facingMode: "user"};
      const i3 = document.createElement("video");
      i3.style.display = "none", i3.preload = "auto", i3.crossOrigin = "anonymous", document.body.appendChild(i3), navigator.mediaDevices.getUserMedia({audio: false, video: C3}).then((A4) => {
        i3.srcObject = A4, i3.onloadedmetadata = (A5) => {
          i3.play(), this.width = i3.videoWidth, this.height = i3.videoHeight, console.log("Webcam:[" + this.width + ", " + this.height + "]"), this.__data = i3, this.loaded = true, this.emit("loaded");
          let g4 = 0;
          const I4 = () => {
            if (i3.paused || i3.ended)
              return;
            const A6 = Math.floor(60 * i3.currentTime);
            g4 != A6 && (this.emit("updated"), g4 = A6), setTimeout(I4, 20);
          };
          I4();
        };
      }).catch(function(A4) {
      });
    }
    setVideoStream(A3) {
      this.loaded = false, this.width = A3.videoWidth, this.height = A3.videoHeight, this.start(), this.__data = A3, this.loaded = true, this.emit("loaded");
    }
    stop() {
      clearInterval(this.__intervalId);
    }
    start() {
      this.__intervalId = setInterval(() => {
        this.emit("updated");
      }, 20);
    }
    isLoaded() {
      return this.loaded;
    }
    getParams() {
      return {type: this.type, format: this.format, width: this.width, height: this.height, data: this.__data, flipY: true};
    }
  };
  e.register("VideoStreamImage2D", wI);
  var XI = class extends hA {
    constructor(A3, g3) {
      super(A3), this.__isOpaque = true, this.__isTextured = false, this.__shaderName = "", g3 && this.setShaderName(g3);
    }
    getShaderName() {
      return this.__shaderName;
    }
    setShaderName(A3) {
      if (this.__shaderName == A3)
        return;
      this.__shaderName = A3;
      const g3 = e.getClassDefinition(A3).getMaterialTemplate();
      if (!g3)
        throw new Error("Error setting Shader. Material template not registered found:" + A3);
      const I3 = {};
      let C3 = g3.getNumParameters();
      for (; C3--; ) {
        const A4 = g3.getParameterByIndex(C3);
        this.getParameter(A4.getName()) || this.addParameter(A4.clone()), I3[A4.getName()] = true;
      }
      for (const A4 of this.params)
        I3[A4.getName()] || this.removeParameter(A4.getName());
      this.__shaderName = A3, this.__checkOpacity({});
      const i3 = new k(A3);
      this.emit("shaderNameChanged", i3);
    }
    removeAllTextures() {
      for (const A3 of this.params)
        A3 instanceof Qg ? A3.getImage() && A3.setImage(null) : A3 instanceof mg && A3.getImage() && A3.setImage(null);
    }
    getParamTextures() {
      const A3 = {};
      for (const g3 of this.params)
        g3 instanceof Qg ? g3.getImage() && (A3[g3.getName()] = g3.getImage()) : g3 instanceof mg && g3.getImage() && (A3[g3.getName()] = g3.getImage());
      return A3;
    }
    isOpaque() {
      return this.__isOpaque;
    }
    __checkOpacity(A3) {
      let g3 = true;
      try {
        this.getShaderClass().isOpaque() || (g3 = false);
      } catch (A4) {
      }
      if (g3) {
        const A4 = this.getParameter("Opacity");
        if (A4 && (A4.value < 0.99 || A4 instanceof mg && A4.getImage()))
          g3 = false;
        else {
          const A5 = this.getParameter("BaseColor");
          if (A5) {
            if (A5 instanceof Qg) {
              const I3 = A5.getImage();
              I3 && I3.format == "RGBA" && (g3 = false);
            }
            if (g3 && A5.value) {
              A5.value.a < 1 && (g3 = false);
            }
          }
        }
      }
      if (g3 != this.__isOpaque) {
        this.__isOpaque = g3;
        const A4 = new _(g3, true);
        this.emit("opacityChanged", A4), this.emit("transparencyChanged", A4);
      }
    }
    isTextured() {
      return this.__isTextured;
    }
    __checkTextures(A3) {
      const g3 = A3 || {};
      let I3 = false;
      for (const A4 of this.params)
        if (A4 instanceof Qg) {
          if (A4.getImage()) {
            I3 = true;
            break;
          }
        } else if (A4 instanceof mg && A4.getImage()) {
          I3 = true;
          break;
        }
      if (I3 != this.__isTextured) {
        this.__isTextured = I3;
        let A4 = new T(I3, g3);
        this.emit("texturedChanged", A4);
      }
    }
    parameterValueChanged(A3) {
      this.__checkOpacity(A3), this.__checkTextures(A3), super.parameterValueChanged(A3);
    }
    getShaderClass() {
      return e.getClassDefinition(this.getShaderName());
    }
    toJSON(A3) {
      const g3 = super.toJSON(A3);
      return g3.shader = this.__shaderName, g3;
    }
    fromJSON(A3, g3 = {}) {
      A3.shader ? (this.setShaderName(A3.shader), super.fromJSON(A3, g3)) : console.warn("Invalid Material JSON");
    }
    readBinary(A3, g3) {
      let I3 = A3.loadStr();
      if (I3 == "StandardMaterial" && (I3 = "StandardSurfaceShader"), I3 == "TransparentMaterial" && (I3 = "StandardSurfaceShader"), this.setShaderName(I3), g3.versions["zea-engine"].compare([0, 0, 3]) < 0)
        throw `Loading zcad files of version ${g3.versions["zea-engine"]} is not longer support`;
      super.readBinary(A3, g3), this.__checkOpacity(), this.__checkTextures();
    }
    clone(A3) {
      const g3 = new XI("clone", "");
      return g3.copyFrom(this, A3), g3;
    }
    copyFrom(A3, g3) {
      this.setShaderName(A3.getShaderName()), super.copyFrom(A3, g3);
    }
  };
  e.register("Material", XI);
  var HI = class extends XI {
    constructor(A3) {
      super(A3), this.baseColorParam = new Qg("BaseColor", new l(1, 1, 0.5)), this.opacityParam = new JA("Opacity", 1), this.lineThicknessParam = new JA("LineThickness", 0.01), this.overlayParam = new JA("Overlay", 0), this.__shaderName = "FatLinesShader", this.addParameter(this.baseColorParam), this.addParameter(this.opacityParam), this.addParameter(this.overlayParam), this.addParameter(this.lineThicknessParam);
    }
  };
  e.register("FatLinesMaterial", HI);
  var WI = class extends XI {
    constructor(A3) {
      super(A3), this.baseColorParam = new Qg("BaseColor", new l(1, 1, 0.5)), this.pointSizeParam = new JA("PointSize", 1), this.roundedParam = new JA("Rounded", 1), this.borderWidthParam = new JA("BorderWidth", 0.2), this.overlayParam = new JA("Overlay", 0), this.__shaderName = "FatPointsShader", this.addParameter(this.baseColorParam), this.addParameter(this.pointSizeParam), this.addParameter(this.roundedParam), this.addParameter(this.borderWidthParam), this.addParameter(this.overlayParam);
    }
    clone(A3) {
      const g3 = new WI();
      return g3.copyFrom(this, A3), g3;
    }
  };
  e.register("FatPointsMaterial", WI);
  var YI = class extends XI {
    constructor(A3) {
      super(A3), this.baseColorParam = new Qg("BaseColor", new l(1, 1, 0.5)), this.overlayParam = new mg("Overlay", 0), this.__shaderName = "FlatSurfaceShader", this.addParameter(this.baseColorParam), this.addParameter(this.overlayParam);
    }
    clone(A3) {
      const g3 = new YI();
      return g3.copyFrom(this, A3), g3;
    }
  };
  e.register("FlatSurfaceMaterial", YI);
  var KI = class extends XI {
    constructor(A3) {
      super(A3), this.baseColorParam = new Qg("BaseColor", new l(1, 1, 0.5)), this.opacityParam = new mg("Opacity", 0.7, [0, 1]), this.overlayParam = new mg("Overlay", 1e-6), this.hiddenEdgeColorParam = new Qg("HiddenEdgeColor", new l(0.2, 0.2, 0.2, 0)), this.__shaderName = "LinesShader", this.addParameter(this.baseColorParam), this.addParameter(this.opacityParam), this.addParameter(this.overlayParam), this.addParameter(this.hiddenEdgeColorParam);
    }
    clone(A3) {
      const g3 = new KI();
      return g3.copyFrom(this, A3), g3;
    }
  };
  e.register("LinesMaterial", KI);
  var pI = class extends XI {
    constructor(A3) {
      super(A3), this.baseColorParam = new Qg("BaseColor", new l(1, 1, 0.5)), this.pointSizeParam = new mg("PointSize", 2), this.overlayParam = new mg("Overlay", 2e-5), this.__shaderName = "PointsShader", this.addParameter(this.baseColorParam), this.addParameter(this.pointSizeParam), this.addParameter(this.overlayParam);
    }
    clone(A3) {
      const g3 = new pI();
      return g3.copyFrom(this, A3), g3;
    }
  };
  e.register("PointsMaterial", pI);
  var NI = class extends XI {
    constructor(A3) {
      super(A3), this.baseColorParam = new Qg("BaseColor", new l(1, 1, 0.5)), this.__shaderName = "ScreenSpaceShader", this.addParameter(this.baseColorParam);
    }
    clone(A3) {
      const g3 = new NI();
      return g3.copyFrom(this, A3), g3;
    }
  };
  e.register("ScreenSpaceMaterial", NI);
  var JI = class extends XI {
    constructor(A3) {
      super(A3), this.baseColorParam = new Qg("BaseColor", new l(1, 1, 0.5)), this.opacityParam = new mg("Opacity", 1, [0, 1]), this.emissiveStrengthParam = new mg("EmissiveStrength", 0, [0, 1]), this.__shaderName = "SimpleSurfaceShader", this.addParameter(this.baseColorParam), this.addParameter(this.opacityParam), this.addParameter(this.emissiveStrengthParam);
    }
    clone(A3) {
      const g3 = new JI();
      return g3.copyFrom(this, A3), g3;
    }
  };
  e.register("SimpleSurfaceMaterial", JI);
  var DI = class extends XI {
    constructor(A3) {
      super(A3), this.baseColorParam = new Qg("BaseColor", new l(1, 1, 0.5)), this.normalParam = new Qg("Normal", new l(1, 1, 0.5)), this.ambientOcclusion = new mg("AmbientOcclusion", 1, [0, 1]), this.metallicParam = new mg("Metallic", 0.05, [0, 1]), this.roughnessParam = new mg("Roughness", 0.5, [0, 1]), this.reflectanceParam = new mg("Reflectance", 0.5, [0, 1]), this.emissiveStrengthParam = new mg("EmissiveStrength", 0, [0, 1]), this.opacityParam = new mg("Opacity", 1, [0, 1]), this.edgeColorParam = new Qg("EdgeColor", new l(0.2, 0.2, 0.2)), this.pointColorParam = new Qg("PointColor", new l(0.1, 0.1, 0.1)), this.hiddenEdgeColorParam = new Qg("HiddenEdgeColor", new l(0.2, 0.2, 0.2, 0)), this.__shaderName = "StandardSurfaceShader", this.addParameter(this.baseColorParam), this.addParameter(this.normalParam), this.addParameter(this.ambientOcclusion), this.addParameter(this.metallicParam), this.addParameter(this.roughnessParam), this.addParameter(this.reflectanceParam), this.addParameter(this.emissiveStrengthParam), this.addParameter(this.opacityParam), this.addParameter(this.edgeColorParam), this.addParameter(this.pointColorParam), this.addParameter(this.hiddenEdgeColorParam);
    }
    clone(A3) {
      const g3 = new DI();
      return g3.copyFrom(this, A3), g3;
    }
  };
  e.register("StandardSurfaceMaterial", DI);
  var fI = class extends V {
    constructor() {
      super(), this.assetItem = null;
    }
  };
  var MI = class extends ag {
    constructor(A3) {
      super(A3), this.srcTreePath = [], this.srcTree = null;
    }
    setSrcTree(A3) {
      this.srcTree = A3;
      const g3 = new fI(), I3 = this.srcTree.clone(g3);
      I3.localXfoParam.value = new m(), this.addChild(I3, false, false);
    }
    getSrcTree() {
      return this.srcTree;
    }
    readBinary(A3, g3) {
      if (super.readBinary(A3, g3), this.srcTreePath = A3.loadStrArray(), this.srcTreePath.length > 0)
        try {
          g3.addPLCB(() => {
            g3.resolvePath(this.srcTreePath, (A4) => {
              this.setSrcTree(A4);
            }, (A4) => {
              console.warn(`Error loading InstanceItem: ${this.getPath()}, unable to resolve: ${this.srcTreePath}. ` + A4.message);
            });
          });
        } catch (A4) {
          console.warn(`Error loading InstanceItem: ${this.getPath()}: ` + A4);
        }
    }
    clone(A3) {
      const g3 = new MI();
      return g3.copyFrom(this, A3), g3;
    }
    copyFrom(A3, g3) {
      super.copyFrom(A3, g3), this.srcTreePath = A3.srcTreePath, this.srcTreePath.length > 0 && this.getNumChildren() == 0 && A3.once("childAdded", (A4) => {
        const g4 = A4.childItem;
        this.setSrcTree(g4);
      });
    }
  };
  e.register("InstanceItem", MI);
  var LI = class extends ag {
    constructor(A3) {
      super(A3), this.materialParam = new rg("Material"), this.overlay = false, this.__cutAway = false, this.__cutAwayVector = new o(1, 0, 0), this.__cutAwayDist = 0, this.__layers = [];
    }
    setOverlay(A3) {
      this.overlay = A3;
    }
    isOverlay() {
      return this.overlay;
    }
    addLayer(A3) {
      this.__layers.push(A3);
    }
    getLayers() {
      return this.__layers;
    }
    isCutawayEnabled() {
      return this.__cutAway;
    }
    setCutawayEnabled(A3) {
      this.__cutAway = A3, this.emit("cutAwayChanged");
    }
    getCutVector() {
      return this.__cutAwayVector;
    }
    setCutVector(A3) {
      this.__cutAwayVector = A3, this.emit("cutAwayChanged");
    }
    getCutDist() {
      return this.__cutAwayDist;
    }
    setCutDist(A3) {
      this.__cutAwayDist = A3, this.emit("cutAwayChanged");
    }
    readBinary(A3, g3) {
      if (super.readBinary(A3, g3), g3.versions["zea-engine"].compare([0, 0, 4]) >= 0) {
        const I3 = A3.loadStr();
        let C3 = g3.assetItem.getMaterialLibrary().getMaterial(I3, false);
        if (C3 || (C3 = new XI(I3, "SimpleSurfaceShader"), C3.getParameter("BaseColor").loadValue(l.random(0.25)), g3.assetItem.getMaterialLibrary().addMaterial(C3)), this.materialParam.loadValue(C3), this.__layers = A3.loadStrArray(), this.__layers.length > 0)
          for (const A4 of this.__layers)
            g3.addGeomToLayer(this, A4);
      }
    }
  };
  var UI = false;
  var vI = class extends eg {
    constructor(A3, g3, I3) {
      super("CalcGeomMatOperator"), this.globalXfo = new Bg("GlobalXfo"), this.geomOffsetXfo = new Bg("GeomOffsetXfo"), this.geomMat = new ig("GeomMat"), this.globalXfo.setParam(A3), this.geomOffsetXfo.setParam(g3), this.geomMat.setParam(I3), this.addInput(this.globalXfo), this.addInput(this.geomOffsetXfo), this.addOutput(this.geomMat);
    }
    evaluate() {
      const A3 = this.globalXfo.getValue().toMat4(), g3 = this.geomOffsetXfo.getValue().toMat4();
      this.geomMat.setClean(A3.multiply(g3));
    }
  };
  var kI = class extends LI {
    constructor(A3, g3, I3, C3) {
      super(A3), this.listenerIDs = {}, this.geomIndex = -1, this.assetItem = null, this.cullable = true, this.geomOffsetXfoParam = new PA("GeomOffsetXfo"), this.geomParam = new hg("Geometry"), this.geomMatParam = new _A("GeomMat"), this.addParameter(this.geomParam), this.addParameter(this.materialParam), this.addParameter(this.geomOffsetXfoParam), this.addParameter(this.geomMatParam);
      const i3 = () => {
        this.setBoundingBoxDirty();
      };
      this.geomParam.on("valueChanged", i3), this.geomParam.on("boundingBoxChanged", i3), this.calcGeomMatOperator = new vI(this.globalXfoParam, this.geomOffsetXfoParam, this.geomMatParam), g3 && this.geomParam.loadValue(g3), I3 && this.materialParam.loadValue(I3), C3 && (this.localXfoParam.value = C3);
    }
    _cleanBoundingBox() {
      if (this.disableBoundingBox)
        return new b();
      const A3 = super._cleanBoundingBox();
      if (this.geomBBox) {
        const g3 = this.geomMatParam.value;
        A3.addPoint(g3.transformVec3(this.geomBBox.p0)), A3.addPoint(g3.transformVec3(this.geomBBox.p1));
      } else {
        const g3 = this.geomParam.value;
        if (g3)
          if (UI) {
            const I3 = this.geomMatParam.value;
            if (g3 instanceof pg) {
              const C3 = g3.__buffers.attrBuffers.positions.values, i3 = (A4) => {
                const g4 = 3 * A4;
                return new o(C3.subarray(g4, g4 + 3));
              };
              for (let C4 = 0; C4 < g3.getNumVertices(); C4++)
                A3.addPoint(I3.transformVec3(i3(C4)));
            } else {
              const C3 = g3.getVertexAttribute("positions");
              for (let i3 = 0; i3 < g3.getNumVertices(); i3++)
                A3.addPoint(I3.transformVec3(C3.getValueRef(i3)));
            }
          } else
            A3.addBox3(g3.getBoundingBox(), this.geomMatParam.value);
      }
      return A3;
    }
    fromJSON(A3, g3) {
      super.fromJSON(A3, g3);
    }
    readBinary(A3, g3) {
      super.readBinary(A3, g3);
      const I3 = A3.loadUInt8(), C3 = A3.loadUInt32(), i3 = g3.assetItem.getGeometryLibrary();
      this.geomIndex = C3, this.assetItem = g3.assetItem;
      const e3 = i3.getGeom(C3);
      if (e3)
        this.geomParam.loadValue(e3);
      else {
        const A4 = (A5) => {
          const {range: I4} = A5;
          if (C3 >= I4[0] && C3 < I4[1]) {
            const A6 = i3.getGeom(C3);
            A6 ? this.geomParam.value = A6 : console.warn("Geom not loaded:", this.getName()), i3.removeListenerById("rangeLoaded", g4);
          }
        }, g4 = i3.on("rangeLoaded", A4);
      }
      if (4 & I3 && (this.geomOffsetXfoParam.value = new m(A3.loadFloat32Vec3(), A3.loadFloat32Quat(), A3.loadFloat32Vec3())), g3.versions["zea-engine"].compare([0, 0, 4]) < 0) {
        if (I3 & 8) {
          const I4 = g3.assetItem.getMaterialLibrary(), C4 = A3.loadStr();
          let i4 = I4.getMaterial(C4);
          i4 || (console.warn("Geom :'" + this.__name + "' Material not found:" + C4), i4 = I4.getMaterial("Default")), this.materialParam.loadValue(i4);
        } else
          this.materialParam.loadValue(g3.assetItem.getMaterialLibrary().getMaterial("Default"));
      }
      g3.versions["zea-engine"].compare([3, 0, 0]) < 0 ? A3.loadFloat32Vec2() : this.geomBBox = new b(A3.loadFloat32Vec3(), A3.loadFloat32Vec3());
    }
    toString(A3) {
      return JSON.stringify(this.toJSON(A3), null, 2);
    }
    clone(A3) {
      const g3 = new kI();
      return g3.copyFrom(this, A3), g3;
    }
    copyFrom(A3, g3) {
      if (super.copyFrom(A3, g3), !A3.geomParam.value && A3.geomIndex != -1) {
        const g4 = A3.assetItem.getGeometryLibrary();
        this.assetItem = A3.assetItem, this.geomIndex = A3.geomIndex, this.geomBBox = A3.geomBBox;
        const I3 = (A4) => {
          const {range: I4} = A4;
          if (this.geomIndex >= I4[0] && this.geomIndex < I4[1]) {
            const A5 = g4.getGeom(this.geomIndex);
            A5 ? this.geomParam.value = A5 : console.warn("Geom not loaded:", this.getName()), g4.removeListenerById("rangeLoaded", this.listenerIDs.rangeLoaded);
          }
        };
        this.listenerIDs.rangeLoaded = g4.on("rangeLoaded", I3);
      }
      this.geomMatParam.setDirty(0);
    }
    static setCalculatePreciseBoundingBoxes(A3) {
      UI = A3;
    }
  };
  e.register("GeomItem", kI);
  var xI = class extends ag {
    constructor(A3) {
      super(A3), this.itemsParam = new dg("Items", (A4) => A4 instanceof ag), this.__itemsEventHandlers = [], this.addParameter(this.itemsParam), this.__itemsParam = this.itemsParam, this.itemsParam.on("itemAdded", (A4) => {
        this.bindItem(A4.item, A4.index);
      }), this.itemsParam.on("itemRemoved", (A4) => {
        this.unbindItem(A4.item, A4.index);
      });
    }
    setSearchRoot(A3) {
      this.searchRoot = A3;
    }
    setOwner(A3) {
      this.searchRoot && this.searchRoot != this.getOwner() || (this.searchRoot = A3), super.setOwner(A3);
    }
    bindItem(A3, g3) {
      if (!(A3 instanceof ag))
        return;
      const I3 = {};
      I3.pointerDown = A3.on("pointerDown", (A4) => {
        this.onPointerDown(A4);
      }), I3.pointerUp = A3.on("pointerUp", (A4) => {
        this.onPointerUp(A4);
      }), I3.pointerMove = A3.on("pointerMove", (A4) => {
        this.onPointerMove(A4);
      }), I3.pointerEnter = A3.on("pointerEnter", (A4) => {
        this.onPointerEnter(A4);
      }), I3.pointerLeave = A3.on("pointerLeave", (A4) => {
        this.onPointerLeave(A4);
      }), this.__itemsEventHandlers.splice(g3, 0, I3);
    }
    unbindItem(A3, g3) {
      if (!(A3 instanceof ag))
        return;
      const I3 = this.__itemsEventHandlers[g3];
      for (let g4 in I3) {
        const C3 = g4.split(".");
        if (C3.length > 1) {
          const i3 = A3.getParameter(C3[0]);
          i3 && i3.removeListenerById(C3[1], I3[g4]);
        } else
          A3.removeListenerById(g4, I3[g4]);
      }
      this.__itemsEventHandlers.splice(g3, 1);
    }
    addItem(A3, g3 = true) {
      A3 ? this.itemsParam.addItem(A3, g3) : console.warn("Error adding item to group. Item is null");
    }
    removeItem(A3, g3 = true) {
      const I3 = this.itemsParam.value;
      if (!I3)
        return;
      const C3 = Array.from(I3).indexOf(A3);
      C3 && this.itemsParam.removeItem(C3, g3);
    }
    clearItems(A3 = true) {
      const g3 = this.itemsParam.value;
      if (!g3)
        return;
      const I3 = Array.from(g3);
      for (let A4 = I3.length - 1; A4 >= 0; A4--)
        this.unbindItem(I3[A4], A4);
      this.itemsParam.clearItems(A3);
    }
    getItems() {
      return this.itemsParam.value;
    }
    setItems(A3) {
      this.clearItems(false), this.itemsParam.setItems(A3);
    }
    toJSON(A3) {
      const g3 = super.toJSON(A3), I3 = this.itemsParam.value;
      if (I3) {
        const C3 = Array.from(I3), i3 = [];
        C3.forEach((g4) => {
          const I4 = g4.getPath();
          i3.push(A3 ? A3.makeRelative(I4) : I4);
        }), g3.treeItems = i3;
      }
      return g3;
    }
    fromJSON(A3, g3) {
      if (super.fromJSON(A3, g3), !A3.treeItems)
        return void console.warn("Invalid Parameter JSON");
      if (!g3)
        throw new Error("Unable to load JSON on a BaseGroup without a load context");
      let I3 = A3.treeItems.length;
      const C3 = (A4) => {
        g3.resolvePath(A4, (A5) => {
          this.addItem(A5), I3--, I3 == 0 && this.loadDone();
        }, () => {
          console.warn("BaseGroup: '" + this.getName() + "'. Unable to load item:" + A4);
        });
      };
      for (const g4 of A3.treeItems)
        C3(g4);
    }
    loadDone() {
    }
  };
  var zI = class extends xI {
    constructor(A3) {
      super(A3), this.highlightedParam = new fA("Highlighted", false), this.highlightColorParam = new xA("HighlightColor", new l(0.5, 0.5, 1)), this.highlightFillParam = new JA("HighlightFill", 0, [0, 1]), this.addParameter(this.highlightedParam), this.highlightedParam.on("valueChanged", () => {
        this.updateHighlight();
      }), this.addParameter(this.highlightColorParam), this.highlightColorParam.on("valueChanged", () => {
        this.updateHighlight();
      }), this.addParameter(this.highlightFillParam), this.highlightFillParam.on("valueChanged", () => {
        this.updateHighlight();
      });
    }
    updateVisibility() {
      if (super.updateVisibility()) {
        const A3 = this.isVisible();
        return Array.from(this.itemsParam.value).forEach((g3) => {
          g3 instanceof ag && g3.propagateVisibility(A3 ? 1 : -1);
        }), true;
      }
      return false;
    }
    updateHighlight() {
      this.__updateHighlightHelper();
    }
    __updateHighlightHelper() {
      let A3, g3 = false;
      (this.highlightedParam.value || this.isSelected()) && (g3 = true, A3 = this.highlightColorParam.value, A3.a = this.highlightFillParam.value);
      const I3 = "groupItemHighlight" + this.getId();
      Array.from(this.itemsParam.value).forEach((C3) => {
        C3 instanceof ag && (g3 ? C3.addHighlight(I3, A3, true) : C3.removeHighlight(I3, true));
      });
    }
    setSelected(A3) {
      super.setSelected(A3), this.updateHighlight();
    }
    bindItem(A3, g3) {
      super.bindItem(A3, g3);
      const I3 = this.__itemsEventHandlers[g3];
      if (A3 instanceof ag) {
        if (A3 instanceof ag && this.highlightedParam.value) {
          const g4 = this.highlightColorParam.value;
          g4.a = this.highlightFillParam.value, A3.addHighlight("groupItemHighlight" + this.getId(), g4, true);
        }
        this.isVisible() || A3.propagateVisibility(-1), I3["BoundingBox.valueChanged"] = A3.boundingBoxParam.on("valueChanged", (A4) => {
          this.setBoundingBoxDirty();
        });
      }
    }
    unbindItem(A3, g3) {
      super.unbindItem(A3, g3), A3 instanceof ag && (this.highlightedParam.value && A3.removeHighlight("groupItemHighlight" + this.getId(), true), this.isVisible() || A3.propagateVisibility(1), A3.traverse((A4) => {
        A4 instanceof LI && A4.setCutawayEnabled(false);
      }, true));
    }
    clone(A3) {
      const g3 = new zI(this.__name + " clone");
      return g3.copyFrom(this, A3), g3;
    }
  };
  e.register("SelectionSet", zI);
  var TI = ZA("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICAgJ3VzZSBzdHJpY3QnOwoKICAgIC8qKgogICAgICogU3RyaW5nIGZ1bmN0aW9ucwogICAgICoKICAgICAqLwogICAgY2xhc3MgU3RyaW5nRnVuY3Rpb25zIHsKICAgICAgICAvKioKICAgICAgICAgKiBSZXBsYWNlcyBhbGwgbWF0Y2hlcyBpbiBhIHN0cmluZy4KICAgICAgICAgKgogICAgICAgICAqIEBzdGF0aWMKICAgICAgICAgKiBAcGFyYW0gc3RyIC0KICAgICAgICAgKiBAcGFyYW0gcGF0dGVybiAtCiAgICAgICAgICogQHBhcmFtIHJlcGxhY2VtZW50IC0KICAgICAgICAgKiBAcmV0dXJuIC0KICAgICAgICAgKi8KICAgICAgICBzdGF0aWMgcmVwbGFjZUFsbChzdHIsIHBhdHRlcm4sIHJlcGxhY2VtZW50KSB7CiAgICAgICAgICAgIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKHBhdHRlcm4sICdnJyksIHJlcGxhY2VtZW50KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyBKU09OIG9iamVjdCBhcyBhIGZvcm1hdHRlZCBzdHJpbmcsIGJ1dCB0aGUgbnVtZXJpYyB2YWx1ZXMgYXJlIGZpeGVkIHRvIHRoZSBzcGVjaWZpZWQgcHJlY2lzaW9uLgogICAgICAgICAqCiAgICAgICAgICogQHN0YXRpYwogICAgICAgICAqIEBwYXJhbSB2YWwgLQogICAgICAgICAqIEBwYXJhbSBzcGFjZSAtCiAgICAgICAgICogQHBhcmFtIHByZWNpc2lvbiAtCiAgICAgICAgICogQHJldHVybiAtCiAgICAgICAgICovCiAgICAgICAgc3RhdGljIHN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odmFsLCBzcGFjZSA9IDAsIHByZWNpc2lvbiA9IDUpIHsKICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCwgKF8sIHZhbCkgPT4gewogICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA/ICh2YWwudG9GaXhlZCA/IE51bWJlcih2YWwudG9GaXhlZChwcmVjaXNpb24pKSA6IHZhbCkgOiB2YWw7CiAgICAgICAgICAgIH0sIHNwYWNlKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVHJhbnNmb3JtcyB0aGUgZ2l2ZW4gc3RyaW5nIGludG8gYSBudW1lcmljIHZhbHVlLgogICAgICAgICAqCiAgICAgICAgICogQHN0YXRpYwogICAgICAgICAqIEBwYXJhbSBzdHIgLQogICAgICAgICAqIEByZXR1cm4gLQogICAgICAgICAqLwogICAgICAgIHN0YXRpYyBoYXNoU3RyKHN0cikgewogICAgICAgICAgICBsZXQgaGFzaCA9IDA7CiAgICAgICAgICAgIGxldCBpOwogICAgICAgICAgICBsZXQgY2hyOwogICAgICAgICAgICBsZXQgbGVuOwogICAgICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkKICAgICAgICAgICAgICAgIHJldHVybiBoYXNoOwogICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHsKICAgICAgICAgICAgICAgIGNociA9IHN0ci5jaGFyQ29kZUF0KGkpOwogICAgICAgICAgICAgICAgaGFzaCA9IChoYXNoIDw8IDUpIC0gaGFzaCArIGNocjsKICAgICAgICAgICAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyCiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGhhc2gpOwogICAgICAgIH0KICAgIH0KCiAgICAvKioKICAgICAqIFJlcHJlc2VudGluZyBhIFZlYzIodHdvLWRpbWVuc2lvbmFsIGZsb2F0aW5nIHBvaW50IHZlY3RvcikuIEEgVmVjMiBpcyBmb3IgcmVwcmVzZW50aW5nIDIgZGltZW5zaW9uYWwgdmFsdWVzLCBzdWNoIGFzIHNjcmVlbiBjb29yZGluYXRlcyBvciBwaXhlbCBjb29yZGluYXRlcyB3aXRoaW4gYW4gaW1hZ2UuCiAgICAgKgogICAgICogTWF0aCB0eXBlcyBpbnRlcm5hbGx5IHN0b3JlIHZhbHVlcyBpbiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRmxvYXQzMkFycmF5fEZsb2F0MzJBcnJheX0gYW5kCiAgICAgKiBleHBvc2UgZ2V0dGVycyBhbmQgc2V0dGVycyBmb3IgdGhlIGNvbXBvbmVudCB2YWx1ZXMuCiAgICAgKgogICAgICovCiAgICBjbGFzcyBWZWMyIHsKICAgICAgICAvKioKICAgICAgICAgKiBDcmVhdGVzIGEgVmVjMi4KICAgICAgICAgKgogICAgICAgICAqIFRoZSB0eXBlIG9mIHZhbHVlcyBvZiB0aGUgYCh4LCB5KWAgY29vcmRpbmF0ZXMgY2FuIGJlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GbG9hdDMyQXJyYXl8RmxvYXQzMkFycmF5fSwKICAgICAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvVWludDMyQXJyYXl8VWludDMyQXJyYXl9LAogICAgICAgICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9JbnQzMkFycmF5fEludDMyQXJyYXl9IGFuZAogICAgICAgICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lcy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jaWEvT2JqZXRvc19nbG9iYWxlcy9BcnJheUJ1ZmZlcnxBcnJheUJ1ZmZlcn0uCiAgICAgICAgICoKICAgICAgICAgKgogICAgICAgICAqIGBgYGphdmFzY3JpcHQKICAgICAgICAgKiAgY29uc3QgbXlWZWMyID0gbmV3IFZlYzIoMS4yLCAzLjQpCiAgICAgICAgICogYGBgCiAgICAgICAgICoKICAgICAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBmbG9hdHMsIGNyZWF0ZSBhIFZlYzIgdGhhdCB3cmFwcyBzb21lIHBhcnQgb2YgaXQuCiAgICAgICAgICogYGBgamF2YXNjcmlwdAogICAgICAgICAqICBjb25zdCBmbG9hdEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSg2KQogICAgICAgICAqICBmbG9hdEFycmF5WzBdID0gMS4yCiAgICAgICAgICogIGZsb2F0QXJyYXlbMV0gPSAzLjQKICAgICAgICAgKiAgY29uc3QgbXlWZWMyID0gbmV3IFZlYzIoZmxvYXRBcnJheSkKICAgICAgICAgKiAgY29uc29sZS5sb2cobXlWZWMyLnRvSlNPTigpKQogICAgICAgICAqIGBgYAogICAgICAgICAqIFRoZSByZXN1bHRpbmcgb3V0cHV0CiAgICAgICAgICogYGBganNvbgogICAgICAgICAqICA+IHsgeDoxLjIsIHk6My40IH0KICAgICAgICAgKiBgYGAKICAgICAgICAgKgogICAgICAgICAqIEdpdmVuIGFuIGFycmF5IG9mIGZsb2F0cywgY3JlYXRlIGEgVmVjMiB0aGF0IHdyYXBzIHNvbWUgcGFydCBvZiBpdC4KICAgICAgICAgKiBgYGBqYXZhc2NyaXB0CiAgICAgICAgICogIGNvbnN0IGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KDYpCiAgICAgICAgICogIGZsb2F0QXJyYXlbMF0gPSAxLjIKICAgICAgICAgKiAgZmxvYXRBcnJheVsxXSA9IDMuNAogICAgICAgICAqICBmbG9hdEFycmF5WzJdID0gNS42CiAgICAgICAgICogIGZsb2F0QXJyYXlbM10gPSA3LjgKICAgICAgICAgKiAgZmxvYXRBcnJheVs0XSA9IDkuMAogICAgICAgICAqICBmbG9hdEFycmF5WzVdID0gMS45CiAgICAgICAgICogIGNvbnN0IG15VmVjMiA9IG5ldyBWZWMyKGZsb2F0QXJyYXkuYnVmZmVyLCA4KQogICAgICAgICAqICBjb25zb2xlLmxvZyhteVZlYzIudG9KU09OKCkpCiAgICAgICAgICogYGBgCiAgICAgICAgICogVGhlIHJlc3VsdGluZyBvdXRwdXQKICAgICAgICAgKiBgYGBqc29uCiAgICAgICAgICogID4geyB4OjUuNiwgeTo3LjggfQogICAgICAgICAqIGBgYAogICAgICAgICAqCiAgICAgICAgICogWW91IGNhbiBhbHNvIHBhc3Mgb25lIEpTT04gb2JqZWN0IHBhcmFtZXRlci4KICAgICAgICAgKiBgYGBqYXZhc2NyaXB0CiAgICAgICAgICogIGNvbnN0IG15VmVjMiA9IG5ldyBWZWMyKHsgeDoxLjIsIHk6My40IH0pCiAgICAgICAgICogYGBgCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0geCAtIFRoZSB4IHZhbHVlLiBEZWZhdWx0IGlzIDAuCiAgICAgICAgICogQHBhcmFtIHkgLSBUaGUgeSB2YWx1ZS4gRGVmYXVsdCBpcyAwLgogICAgICAgICAqLwogICAgICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCkgewogICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fCB4IGluc3RhbmNlb2YgVWludDMyQXJyYXkgfHwgeCBpbnN0YW5jZW9mIEludDMyQXJyYXkpIHsKICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhID0geDsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgeCA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgeSA9PSAnbnVtYmVyJykgewogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDIpOwogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbMF0gPSB4OwogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbMV0gPSB5OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB4ID09ICdvYmplY3QnKSB7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7CiAgICAgICAgICAgICAgICB0aGlzLmZyb21KU09OKHgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDIpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3IgYHhgIGNvbXBvbmVudC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgeCBjb21wb25lbnQuCiAgICAgICAgICovCiAgICAgICAgZ2V0IHgoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVswXTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZvciBgeGAgY29tcG9uZW50LgogICAgICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIHNldCB4KHZhbCkgewogICAgICAgICAgICB0aGlzLl9fZGF0YVswXSA9IHZhbDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2V0dGVyIGZvciBgeWAgY29tcG9uZW50LgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSB5IGNvbXBvbmVudC4KICAgICAgICAgKi8KICAgICAgICBnZXQgeSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzFdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIGB5YCBjb21wb25lbnQuCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IHkodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzFdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZnJvbSBzY2FsYXIgY29tcG9uZW50cy4KICAgICAgICAgKiBAcGFyYW0geCAtIFRoZSB4IGNvbXBvbmVudC4KICAgICAgICAgKiBAcGFyYW0geSAgLSBUaGUgeSBjb21wb25lbnQuCiAgICAgICAgICovCiAgICAgICAgc2V0KHgsIHkpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMF0gPSB4OwogICAgICAgICAgICB0aGlzLl9fZGF0YVsxXSA9IHk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJlcGxhY2VzIHRoaXMgVmVjMiBkYXRhIHdpdGggdGhlIFZlYzIgZGF0YSBwYXNzZWQgYXMgcGFyYW1ldGVyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gc2V0IGZyb20uCiAgICAgICAgICovCiAgICAgICAgc2V0RnJvbU90aGVyKG90aGVyKSB7CiAgICAgICAgICAgIHRoaXMueCA9IG90aGVyLng7CiAgICAgICAgICAgIHRoaXMueSA9IG90aGVyLnk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENoZWNrcyBpZiB0aGlzIFZlYzIgY29udGFpbnMgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZSBvdGhlciBWZWMyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gY29tcGFyZSB3aXRoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGB0cnVlYCBpZiBhcmUgdGhlIHNhbWUgVmVjdG9yLCBvdGhlcndpc2UsIGBmYWxzZWAuCiAgICAgICAgICovCiAgICAgICAgaXNFcXVhbChvdGhlcikgewogICAgICAgICAgICByZXR1cm4gdGhpcy54ID09IG90aGVyLnggJiYgdGhpcy55ID09IG90aGVyLnk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENoZWNrcyBpZiB0aGlzIFZlYzIgaXMgZGlmZmVyZW50IGZyb20gYW5vdGhlciBWZWMyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gY29tcGFyZSB3aXRoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgVmVjMnMgYXJlIGRpZmZlcmVudCwgb3RoZXJ3aXNlLCBgZmFsc2VgLgogICAgICAgICAqLwogICAgICAgIG5vdEVxdWFsKG90aGVyKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnggIT0gb3RoZXIueCAmJiB0aGlzLnkgIT0gb3RoZXIueTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgVmVjMiBpcyBhcHByb3hpbWF0ZWx5IHRoZSBzYW1lIGFzIG90aGVyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gY29tcGFyZSB3aXRoLgogICAgICAgICAqIEBwYXJhbSBwcmVjaXNpb24gLSBUaGUgcHJlY2lzaW9uIHRvIHdoaWNoIHRoZSB2YWx1ZXMgbXVzdCBtYXRjaC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0cnVlIG9yIGZhbHNlLgogICAgICAgICAqLwogICAgICAgIGFwcHJveEVxdWFsKG90aGVyLCBwcmVjaXNpb24gPSBOdW1iZXIuRVBTSUxPTikgewogICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54IC0gb3RoZXIueCkgPCBwcmVjaXNpb24gJiYgTWF0aC5hYnModGhpcy55IC0gb3RoZXIueSkgPCBwcmVjaXNpb247CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEFkZHMgb3RoZXIgdG8gdGhpcyBWZWMyIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMi4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGFkZC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMyLgogICAgICAgICAqLwogICAgICAgIGFkZChvdGhlcikgewogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy54ICsgb3RoZXIueCwgdGhpcy55ICsgb3RoZXIueSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEFkZHMgYSBWZWMyIHRvIHRoaXMgVmVjMi4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGFkZC4KICAgICAgICAgKi8KICAgICAgICBhZGRJblBsYWNlKG90aGVyKSB7CiAgICAgICAgICAgIHRoaXMueCArPSBvdGhlci54OwogICAgICAgICAgICB0aGlzLnkgKz0gb3RoZXIueTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU3VidHJhY3RzIGEgVmVjMiBmcm9tIHRoaXMgVmVjMiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMiB0byBzdWJ0cmFjdC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMyLgogICAgICAgICAqLwogICAgICAgIHN1YnRyYWN0KG90aGVyKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnggLSBvdGhlci54LCB0aGlzLnkgLSBvdGhlci55KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU3VidHJhY3RzIGEgVmVjMiBmcm9tIHRoaXMgVmVjMi4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIHN1YnRyYWN0LgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzIuCiAgICAgICAgICovCiAgICAgICAgc3VidHJhY3RJblBsYWNlKG90aGVyKSB7CiAgICAgICAgICAgIHRoaXMueCAtPSBvdGhlci54OwogICAgICAgICAgICB0aGlzLnkgLT0gb3RoZXIueTsKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNjYWxlcyB0aGlzIFZlYzIgYnkgc2NhbGFyIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMi4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzIuCiAgICAgICAgICovCiAgICAgICAgc2NhbGUoc2NhbGFyKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLnggKiBzY2FsYXIsIHRoaXMueSAqIHNjYWxhcik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNjYWxlcyB0aGlzIFZlYzIgYnkgc2NhbGFyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2NhbGVJblBsYWNlKHNjYWxhcikgewogICAgICAgICAgICB0aGlzLnggKj0gc2NhbGFyOwogICAgICAgICAgICB0aGlzLnkgKj0gc2NhbGFyOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBJbnZlcnRzIHRoaXMgVmVjMiBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzIuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMyLgogICAgICAgICAqLwogICAgICAgIGludmVydCgpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMyKDEuMCAvIHRoaXMueCwgMS4wIC8gdGhpcy55KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogSW52ZXJ0cyB0aGlzIFZlYzIuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBpbnZlcnRJblBsYWNlKCkgewogICAgICAgICAgICB0aGlzLnggPSAxLjAgLyB0aGlzLng7CiAgICAgICAgICAgIHRoaXMueSA9IDEuMCAvIHRoaXMueTsKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIE11bHRpcGxpZXMgYSBWZWMyIHdpdGggdGhpcyBWZWMyIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMi4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIG11bHRpcGx5IHdpdGguCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgVmVjMi4KICAgICAgICAgKi8KICAgICAgICBtdWx0aXBseShvdGhlcikgewogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy54ICogb3RoZXIueCwgdGhpcy55ICogb3RoZXIueSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIE11bHRpcGxpZXMgYSBWZWMyIHdpdGggdGhpcyBWZWMyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gbXVsdGlwbHkgd2l0aC4KICAgICAgICAgKi8KICAgICAgICBtdWx0aXBseUluUGxhY2Uob3RoZXIpIHsKICAgICAgICAgICAgdGhpcy54ICo9IG90aGVyLng7CiAgICAgICAgICAgIHRoaXMueSAqPSBvdGhlci55OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiB0aGlzIFZlYzIuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgbGVuZ3RoIHNxdWFyZWQuCiAgICAgICAgICovCiAgICAgICAgbGVuZ3RoU3F1YXJlZCgpIHsKICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdOwogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV07CiAgICAgICAgICAgIHJldHVybiB4ICogeCArIHkgKiB5OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhpcyBWZWMyLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGxlbmd0aC4KICAgICAgICAgKi8KICAgICAgICBsZW5ndGgoKSB7CiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcXVhcmVkKCkpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSB0byBhbm90aGVyIHZlY3Rvci4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciB2YWx1ZS4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB2ZWN0b3JzLgogICAgICAgICAqLwogICAgICAgIGRpc3RhbmNlVG8ob3RoZXIpIHsKICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdIC0gb3RoZXIueDsKICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuX19kYXRhWzFdIC0gb3RoZXIueTsKICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogTm9ybWFsaXplcyB0aGUgVmVjMiBhbmQgcmV0dXJucyBpdCBhcyBhIG5ldyBWZWMyLgogICAgICAgICAqIE11bHRpcGxpZXMgY29vcmRpbmF0ZXMgdmFsdWUgYnkgdGhlIGludmVyc2Ugb2YgdGhlIHZlY3RvciBsZW5ndGguCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgVmVjMiBub3JtYWxpemVkLgogICAgICAgICAqLwogICAgICAgIG5vcm1hbGl6ZSgpIHsKICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdOwogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV07CiAgICAgICAgICAgIGxldCBsZW4gPSB4ICogeCArIHkgKiB5OwogICAgICAgICAgICBpZiAobGVuIDwgTnVtYmVyLkVQU0lMT04pIHsKICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMigpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vIFRPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlPwogICAgICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih4ICogbGVuLCB5ICogbGVuKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogTm9ybWFsaXplcyB0aGlzIFZlYzIgbXVsdGlwbHlpbmcgY29vcmRpbmF0ZSB2YWx1ZXMgYnkgdGhlIGludmVyc2Ugb2YgdGhlIHZlY3RvciBsZW5ndGguCiAgICAgICAgICovCiAgICAgICAgbm9ybWFsaXplSW5QbGFjZSgpIHsKICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdOwogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV07CiAgICAgICAgICAgIGxldCBsZW4gPSB4ICogeCArIHkgKiB5OwogICAgICAgICAgICBpZiAobGVuIDwgTnVtYmVyLkVQU0lMT04pIHsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7CiAgICAgICAgICAgIHRoaXMuc2V0KHggKiBsZW4sIHkgKiBsZW4pOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0aGlzIFZlYzIgYWdhaW5zdCBhbm90aGVyIFZlYzIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMiB0byBjb21wYXJlIHdpdGguCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGRvdCBwcm9kdWN0LgogICAgICAgICAqLwogICAgICAgIGRvdChvdGhlcikgewogICAgICAgICAgICByZXR1cm4gdGhpcy54ICogb3RoZXIueCArIHRoaXMueSAqIG90aGVyLnk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhpcyBWZWMyIGFnYWluc3QgYW5vdGhlciBWZWMyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gY29tcGFyZSB3aXRoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBjcm9zcyBwcm9kdWN0LgogICAgICAgICAqLwogICAgICAgIGNyb3NzKG90aGVyKSB7CiAgICAgICAgICAgIC8vIGp1c3QgY2FsY3VsYXRlIHRoZSB6LWNvbXBvbmVudAogICAgICAgICAgICByZXR1cm4gdGhpcy54ICogb3RoZXIueSAtIHRoaXMueSAqIG90aGVyLng7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHMgdGhlIGFuZ2xlIGJldHdlZW4gdGhpcyBWZWMyIGFuZCBvdGhlciBhc3N1bWluZyBib3RoIGFyZSBub3JtYWxpemVkIHZlY3RvcnMuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMiB0byBjb21wYXJlIHdpdGguCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGFuZ2xlIGluIHJhZGlhbnMuCiAgICAgICAgICovCiAgICAgICAgYW5nbGVUbyhvdGhlcikgewogICAgICAgICAgICBjb25zdCBjb3NpbmUgPSB0aGlzLm5vcm1hbGl6ZSgpLmRvdChvdGhlci5ub3JtYWxpemUoKSk7CiAgICAgICAgICAgIGlmIChjb3NpbmUgPiAxLjApCiAgICAgICAgICAgICAgICByZXR1cm4gMC4wOwogICAgICAgICAgICBlbHNlIGlmIChjb3NpbmUgPCAtMS4wKQogICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguUEk7CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2V0cyB0aGUgYW5nbGUgYmV0d2VlbiB0aGlzIFZlYzIgYW5kIG90aGVyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzIgdG8gY29tcGFyZSB3aXRoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBhbmdsZSBpbiByYWRpYW5zLgogICAgICAgICAqLwogICAgICAgIHNpZ25lZEFuZ2xlVG8ob3RoZXIpIHsKICAgICAgICAgICAgY29uc3QgYW5nbGUgPSB0aGlzLmFuZ2xlVG8ob3RoZXIpOwogICAgICAgICAgICBpZiAodGhpcy5jcm9zcyhvdGhlcikgPCAwLjApCiAgICAgICAgICAgICAgICByZXR1cm4gLWFuZ2xlOwogICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICByZXR1cm4gYW5nbGU7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJvdGF0ZXMgYSBWZWMyIGluIGEgY2xvY2t3aXNlIGRpcmVjdGlvbiBhbmQgcmV0dXJucyBhIG5ldyByb3RhdGVkIFZlYzIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gYW5nbGUgLSBUaGUgYW5nbGUgb2Ygcm90YXRpb24uCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIHJvdGF0ZWQgdmVjdG9yLgogICAgICAgICAqLwogICAgICAgIHJvdGF0ZShhbmdsZSkgewogICAgICAgICAgICBjb25zdCBjb3NBID0gTWF0aC5jb3MoYW5nbGUpOwogICAgICAgICAgICBjb25zdCBzaW5BID0gTWF0aC5zaW4oYW5nbGUpOwogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIodGhpcy54ICogY29zQSAtIHRoaXMueSAqIHNpbkEsIHRoaXMueCAqIHNpbkEgKyB0aGlzLnkgKiBjb3NBKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHRoaXMgVmVjMiBhbmQgb3RoZXIgVmVjMi4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMyIHRvIGludGVycG9sYXRlIGJldHdlZW4uCiAgICAgICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzIuCiAgICAgICAgICovCiAgICAgICAgbGVycChvdGhlciwgdCkgewogICAgICAgICAgICBjb25zdCBheCA9IHRoaXMueDsKICAgICAgICAgICAgY29uc3QgYXkgPSB0aGlzLnk7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMihheCArIHQgKiAob3RoZXIueCAtIGF4KSwgYXkgKyB0ICogKG90aGVyLnkgLSBheSkpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHNjYWxlIC0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWQuCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0UmFuZG9tRGlyKHNjYWxlID0gMS4wKSB7CiAgICAgICAgICAgIGNvbnN0IHIgPSBNYXRoLnJhbmRvbSgpICogMi4wICogTWF0aC5QSTsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlOwogICAgICAgICAgICB0aGlzLl9fZGF0YVsxXSA9IE1hdGguc2luKHIpICogc2NhbGU7CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSYW5kb21pemVzIHRoZSBzY2FsZSBvZiB0aGlzIFZlYzIgY29vcmRpbmF0ZXMuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gc2NhbGUgLSBUaGUgc2NhbGUgdmFsdWUuCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0UmFuZG9tKHNjYWxlID0gMS4wKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzBdID0gTWF0aC5yYW5kb20oKSAqIHNjYWxlOwogICAgICAgICAgICB0aGlzLl9fZGF0YVsxXSA9IE1hdGgucmFuZG9tKCkgKiBzY2FsZTsKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENsb25lcyB0aGlzIFZlYzIgYW5kIHJldHVybnMgYSBuZXcgVmVjMi4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzIuCiAgICAgICAgICovCiAgICAgICAgY2xvbmUoKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih0aGlzLl9fZGF0YVswXSwgdGhpcy5fX2RhdGFbMV0pOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIGN1cnJlbnQgVmVjMiBkYXRhIGFzIGFycmF5LiBPZnRlbiB1c2VkIHRvIHBhc3MgdHlwZXMgdG8gdGhlIEdQVS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGFzIGFuIGFycmF5LgogICAgICAgICAqLwogICAgICAgIGFzQXJyYXkoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YTsKICAgICAgICB9CiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCiAgICAgICAgLy8gUGVyc2lzdGVuY2UKICAgICAgICAvKioKICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFZlYzMgdG8gYSBzdHJpbmcgaW4gSlNPTiBmb3JtYXQuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICB0b1N0cmluZygpIHsKICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXAKICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0Z1bmN0aW9ucy5zdHJpbmdpZnlKU09OV2l0aEZpeGVkUHJlY2lzaW9uKHRoaXMudG9KU09OKCkpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBFbmNvZGVzIFZlYzIgQ2xhc3MgYXMgYSBKU09OIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIGpzb24gb2JqZWN0LgogICAgICAgICAqLwogICAgICAgIHRvSlNPTigpIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIHg6IHRoaXMueCwKICAgICAgICAgICAgICAgIHk6IHRoaXMueSwKICAgICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogRGVjb2RlcyBhIEpTT04gb2JqZWN0IHRvIHNldCB0aGUgc3RhdGUgb2YgdGhpcyBjbGFzcy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBqIC0gVGhlIGpzb24gb2JqZWN0LgogICAgICAgICAqLwogICAgICAgIGZyb21KU09OKGopIHsKICAgICAgICAgICAgdGhpcy54ID0gai54OwogICAgICAgICAgICB0aGlzLnkgPSBqLnk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIExvYWRzIHRoZSBzdGF0ZSBvZiB0aGUgdmFsdWUgZnJvbSBhIGJpbmFyeSByZWFkZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICByZWFkQmluYXJ5KHJlYWRlcikgewogICAgICAgICAgICB0aGlzLnggPSByZWFkZXIubG9hZEZsb2F0MzIoKTsKICAgICAgICAgICAgdGhpcy55ID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENhbGN1bGF0ZSB0aGUgaW50ZXJzZWN0aW9uIHBvaW50IG9mIDIgMmQgbGluZXMsIHJldHVybmluZyB0aGUgcGFyYW1ldGVycyB2YWx1ZXMgZm9yIGVhY2ggbGluZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBwMCAtIFRoZSBwb2ludCBvZiB0aGUgZmlyc3QgbGluZQogICAgICAgICAqIEBwYXJhbSBkMCAtIFRoZSBkaXJlY3Rpb24gb2YgdGhlIGZpcnN0IGxpbmUKICAgICAgICAgKiBAcGFyYW0gcDEgLSBUaGUgcG9pbnQgb2YgdGhlIHNlY29uZCBsaW5lCiAgICAgICAgICogQHBhcmFtIGQxIC0gVGhlIGRpcmVjdGlvbiBvZiB0aGUgc2Vjb25kIGxpbmUKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIDIgcGFyYW1ldGVyIHZhbHVlcyBmb3IgdGhlIDIgbGluZXMuCiAgICAgICAgICovCiAgICAgICAgc3RhdGljIGludGVyc2VjdGlvbk9mTGluZXMocDEsIHAyLCBwMywgcDQpIHsKICAgICAgICAgICAgLy8gaHR0cHM6Ly9kaXJhc2suY29tL3Bvc3RzL0phdmFTY3JpcHQtaG93LXRvLWNhbGN1bGF0ZS1pbnRlcnNlY3Rpb24tcG9pbnQtb2YtdHdvLWxpbmVzLWZvci1naXZlbi00LXBvaW50cy1WanZuQWoKICAgICAgICAgICAgLy8gZG93biBwYXJ0IG9mIGludGVyc2VjdGlvbiBwb2ludCBmb3JtdWxhCiAgICAgICAgICAgIGNvbnN0IGQxID0gKHAxLnggLSBwMi54KSAqIChwMy55IC0gcDQueSk7IC8vICh4MSAtIHgyKSAqICh5MyAtIHk0KQogICAgICAgICAgICBjb25zdCBkMiA9IChwMS55IC0gcDIueSkgKiAocDMueCAtIHA0LngpOyAvLyAoeTEgLSB5MikgKiAoeDMgLSB4NCkKICAgICAgICAgICAgY29uc3QgZCA9IGQxIC0gZDI7CiAgICAgICAgICAgIGlmIChkID09IDApIHsKICAgICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vIHVwcGVyIHBhcnQgb2YgaW50ZXJzZWN0aW9uIHBvaW50IGZvcm11bGEKICAgICAgICAgICAgY29uc3QgdTEgPSBwMS54ICogcDIueSAtIHAxLnkgKiBwMi54OyAvLyAoeDEgKiB5MiAtIHkxICogeDIpCiAgICAgICAgICAgIGNvbnN0IHU0ID0gcDMueCAqIHA0LnkgLSBwMy55ICogcDQueDsgLy8gKHgzICogeTQgLSB5MyAqIHg0KQogICAgICAgICAgICBjb25zdCB1MnggPSBwMy54IC0gcDQueDsgLy8gKHgzIC0geDQpCiAgICAgICAgICAgIGNvbnN0IHUzeCA9IHAxLnggLSBwMi54OyAvLyAoeDEgLSB4MikKICAgICAgICAgICAgY29uc3QgdTJ5ID0gcDMueSAtIHA0Lnk7IC8vICh5MyAtIHk0KQogICAgICAgICAgICBjb25zdCB1M3kgPSBwMS55IC0gcDIueTsgLy8gKHkxIC0geTIpCiAgICAgICAgICAgIC8vIGludGVyc2VjdGlvbiBwb2ludCBmb3JtdWxhCiAgICAgICAgICAgIGNvbnN0IHB4ID0gKHUxICogdTJ4IC0gdTN4ICogdTQpIC8gZDsKICAgICAgICAgICAgY29uc3QgcHkgPSAodTEgKiB1MnkgLSB1M3kgKiB1NCkgLyBkOwogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIocHgsIHB5KTsKICAgICAgICB9CiAgICAgICAgaXNWYWxpZCgpIHsKICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRoaXMuX19kYXRhKSB7CiAgICAgICAgICAgICAgICBpZiAodiA9PSBJbmZpbml0eSB8fCBpc05hTih2KSkKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgfQoKICAgIC8qKgogICAgICogUmVwcmVzZW50cyBhIHRocmVlIGRpbWVuc2lvbmFsIGNvb3JkaW5hdGUsIHN1Y2ggYXMgM0Qgc2NlbmUgdmFsdWVzLCBvciBtZXNoIHZlcnRleCBwb3NpdGlvbnMuCiAgICAgKgogICAgICogTWF0aCB0eXBlcyBpbnRlcm5hbGx5IHN0b3JlIHZhbHVlcyBpbiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRmxvYXQzMkFycmF5fEZsb2F0MzJBcnJheX0gYW5kCiAgICAgKiBleHBvc2UgZ2V0dGVycyBhbmQgc2V0dGVycyBmb3IgdGhlIGNvbXBvbmVudCB2YWx1ZXMuCiAgICAgKi8KICAgIGNsYXNzIFZlYzMgewogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZXMgYSBWZWMzLgogICAgICAgICAqCiAgICAgICAgICogVGhlIHR5cGUgb2YgdmFsdWVzIG9mIHRoZSBgKHgsIHksIHopYCBjb29yZGluYXRlcyBjYW4gYmUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Zsb2F0MzJBcnJheXxGbG9hdDMyQXJyYXl9LAogICAgICAgICAqIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9VaW50MzJBcnJheXxVaW50MzJBcnJheX0sCiAgICAgICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0ludDMyQXJyYXl8SW50MzJBcnJheX0gYW5kCiAgICAgICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VzL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNpYS9PYmpldG9zX2dsb2JhbGVzL0FycmF5QnVmZmVyfEFycmF5QnVmZmVyfS4KICAgICAgICAgKgogICAgICAgICAqIFlvdSBjYW4gYWxzbyBwYXNzIG9uZSBKU09OIG9iamVjdCBwYXJhbWV0ZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0geCAtIFRoZSB4IHZhbHVlLiBEZWZhdWx0IGlzIDAuCiAgICAgICAgICogQHBhcmFtIHkgLSBUaGUgeSB2YWx1ZS4gRGVmYXVsdCBpcyAwLgogICAgICAgICAqIEBwYXJhbSB6IC0gVGhlIHogdmFsdWUuIERlZmF1bHQgaXMgMC4KICAgICAgICAgKi8KICAgICAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwKSB7CiAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8IHggaW5zdGFuY2VvZiBVaW50MzJBcnJheSkgewogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGEgPSB4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgaWYgKHggaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgewogICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIG5ldyBWZWMzKG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCAzKSlgKTsKICAgICAgICAgICAgICAgIGNvbnN0IGJ1ZmZlciA9IHg7CiAgICAgICAgICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0geTsKICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB4ID09ICdudW1iZXInICYmIHR5cGVvZiB5ID09ICdudW1iZXInICYmIHR5cGVvZiB6ID09ICdudW1iZXInKSB7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVswXSA9IHg7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVsxXSA9IHk7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVsyXSA9IHo7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSBpZiAoeCAhPSBudWxsICYmIHR5cGVvZiB4ID09ICdvYmplY3QnKSB7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7CiAgICAgICAgICAgICAgICB0aGlzLmZyb21KU09OKHgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDMpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3IgYHhgIGNvbXBvbmVudC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSB4IGNvbXBvbmVudC4KICAgICAgICAgKi8KICAgICAgICBnZXQgeCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzBdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIGB4YCBjb21wb25lbnQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmFsIC0gVGhlIHZhbCBwYXJhbS4KICAgICAgICAgKi8KICAgICAgICBzZXQgeCh2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMF0gPSB2YWw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3IgYHlgIGNvbXBvbmVudC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSB5IGNvbXBvbmVudC4KICAgICAgICAgKi8KICAgICAgICBnZXQgeSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzFdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIGB5YCBjb21wb25lbnQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmFsIC0gVGhlIHZhbCBwYXJhbS4KICAgICAgICAgKi8KICAgICAgICBzZXQgeSh2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMV0gPSB2YWw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3IgYHpgIGNvbXBvbmVudC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSB6IGNvbXBvbmVudC4KICAgICAgICAgKi8KICAgICAgICBnZXQgeigpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzJdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIGB6YCBjb21wb25lbnQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmFsIC0gVGhlIHZhbCBwYXJhbS4KICAgICAgICAgKi8KICAgICAgICBzZXQgeih2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMl0gPSB2YWw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3IgYHh5YCBzd2l6emVsLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIHh5IGNvbXBvbmVudHMgYXMgYSBWZWMyLgogICAgICAgICAqLwogICAgICAgIGdldCB4eSgpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMuX19kYXRhWzBdLCB0aGlzLl9fZGF0YVsxXSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3IgYHl6YCBzd2l6emVsLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIHl6IGNvbXBvbmVudHMgYXMgYSBWZWMyLgogICAgICAgICAqLwogICAgICAgIGdldCB5eigpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMyKHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmcm9tIHNjYWxhciBjb21wb25lbnRzLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHggLSBUaGUgeCBjb21wb25lbnQuCiAgICAgICAgICogQHBhcmFtIHkgLSBUaGUgeSBjb21wb25lbnQuCiAgICAgICAgICogQHBhcmFtIHogLSBUaGUgeSBjb21wb25lbnQuCiAgICAgICAgICovCiAgICAgICAgc2V0KHgsIHksIHopIHsKICAgICAgICAgICAgdGhpcy54ID0geDsKICAgICAgICAgICAgdGhpcy55ID0geSAhPT0gdW5kZWZpbmVkID8geSA6IHg7CiAgICAgICAgICAgIHRoaXMueiA9IHogIT09IHVuZGVmaW5lZCA/IHogOiB4OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiBhIFZlYzMgT2JqZWN0LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIGZsb2F0MzJBcnJheSAtIFRoZSBmbG9hdDMyQXJyYXkgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0RGF0YUFycmF5KGZsb2F0MzJBcnJheSkgewogICAgICAgICAgICB0aGlzLl9fZGF0YSA9IGZsb2F0MzJBcnJheTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyB0aGUgc3RhdGUgb2YgYSBWZWMzIE9iamVjdCBmcm9tIGFub3RoZXIgVmVjMy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIHNldCBmcm9tLgogICAgICAgICAqLwogICAgICAgIHNldEZyb21PdGhlcihvdGhlcikgewogICAgICAgICAgICB0aGlzLnggPSBvdGhlci54OwogICAgICAgICAgICB0aGlzLnkgPSBvdGhlci55OwogICAgICAgICAgICB0aGlzLnogPSBvdGhlci56OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGNvb3JkaW5hdGVzIG9mIHRoaXMgVmVjMyBhcmUgMCAwIDAuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvb3JkaW5hdGVzIGFyZSgwLCAwLCAwKSwgb3RoZXJ3aXNlLCBgZmFsc2VgLgogICAgICAgICAqLwogICAgICAgIGlzTnVsbCgpIHsKICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueCkgPCBOdW1iZXIuRVBTSUxPTiAmJiBNYXRoLmFicyh0aGlzLnkpIDwgTnVtYmVyLkVQU0lMT04gJiYgTWF0aC5hYnModGhpcy56KSA8IE51bWJlci5FUFNJTE9OOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDaGVja3MgaWYgdGhlIGNvb3JkaW5hdGVzIG9mIHRoaXMgVmVjMyBhcmUgMSAxIDEuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGNvb3JkaW5hdGVzIGFyZSgxLCAxLCAxKSwgb3RoZXJ3aXNlLCBgZmFsc2VgLgogICAgICAgICAqLwogICAgICAgIGlzMTExKCkgewogICAgICAgICAgICByZXR1cm4gKE1hdGguYWJzKDEuMCAtIHRoaXMueCkgPCBOdW1iZXIuRVBTSUxPTiAmJgogICAgICAgICAgICAgICAgTWF0aC5hYnMoMS4wIC0gdGhpcy55KSA8IE51bWJlci5FUFNJTE9OICYmCiAgICAgICAgICAgICAgICBNYXRoLmFicygxLjAgLSB0aGlzLnopIDwgTnVtYmVyLkVQU0lMT04pOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDaGVja3MgaWYgdGhpcyBWZWMzIGNvbnRhaW5zIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGUgb3RoZXIgVmVjMy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIGNvbXBhcmUgd2l0aC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgdGhlIHNhbWUsIG90aGVyd2lzZSwgYGZhbHNlYC4KICAgICAgICAgKi8KICAgICAgICBpc0VxdWFsKG90aGVyKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnggPT0gb3RoZXIueCAmJiB0aGlzLnkgPT0gb3RoZXIueSAmJiB0aGlzLnogPT0gb3RoZXIuejsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ2hlY2tzIGlmIHRoaXMgVmVjMiBpcyBkaWZmZXJlbnQgZnJvbSBhbm90aGVyIFZlYzIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjb21wYXJlIHdpdGguCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYHRydWVgIGlmIHRoZSBWZWMzcyBhcmUgZGlmZmVyZW50LCBvdGhlcndpc2UsIGBmYWxzZWAuCiAgICAgICAgICovCiAgICAgICAgbm90RXF1YWwob3RoZXIpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAhPSBvdGhlci54ICYmIHRoaXMueSAhPSBvdGhlci55ICYmIHRoaXMueiAhPSBvdGhlci56OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBWZWMyIGlzIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgYXMgb3RoZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjb21wYXJlIHdpdGguCiAgICAgICAgICogQHBhcmFtIHByZWNpc2lvbiAtIFRoZSBwcmVjaXNpb24gdG8gd2hpY2ggdGhlIHZhbHVlcyBtdXN0IG1hdGNoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuCiAgICAgICAgICovCiAgICAgICAgYXBwcm94RXF1YWwob3RoZXIsIHByZWNpc2lvbiA9IE51bWJlci5FUFNJTE9OKSB7CiAgICAgICAgICAgIHJldHVybiAoTWF0aC5hYnModGhpcy54IC0gb3RoZXIueCkgPCBwcmVjaXNpb24gJiYKICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMueSAtIG90aGVyLnkpIDwgcHJlY2lzaW9uICYmCiAgICAgICAgICAgICAgICBNYXRoLmFicyh0aGlzLnogLSBvdGhlci56KSA8IHByZWNpc2lvbik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEFkZHMgb3RoZXIgdG8gdGhpcyBWZWMzIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gYWRkLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzMuCiAgICAgICAgICovCiAgICAgICAgYWRkKG90aGVyKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLnggKyBvdGhlci54LCB0aGlzLnkgKyBvdGhlci55LCB0aGlzLnogKyBvdGhlci56KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQWRkcyBvdGhlciB0byB0aGlzIFZlYzMuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBhZGQuCiAgICAgICAgICovCiAgICAgICAgYWRkSW5QbGFjZShvdGhlcikgewogICAgICAgICAgICB0aGlzLnggKz0gb3RoZXIueDsKICAgICAgICAgICAgdGhpcy55ICs9IG90aGVyLnk7CiAgICAgICAgICAgIHRoaXMueiArPSBvdGhlci56OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTdWJ0cmFjdHMgb3RoZXIgZnJvbSB0aGlzIFZlYzMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzMgdG8gc3VidHJhY3QuCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgVmVjMy4KICAgICAgICAgKi8KICAgICAgICBzdWJ0cmFjdChvdGhlcikgewogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy54IC0gb3RoZXIueCwgdGhpcy55IC0gb3RoZXIueSwgdGhpcy56IC0gb3RoZXIueik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFN1YnRyYWN0cyBvdGhlciBmcm9tIHRoaXMgVmVjMy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIHN1YnRyYWN0LgogICAgICAgICAqLwogICAgICAgIHN1YnRyYWN0SW5QbGFjZShvdGhlcikgewogICAgICAgICAgICB0aGlzLnggLT0gb3RoZXIueDsKICAgICAgICAgICAgdGhpcy55IC09IG90aGVyLnk7CiAgICAgICAgICAgIHRoaXMueiAtPSBvdGhlci56OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBNdWx0aXBsaWVzIHR3byBWZWMzcyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzMuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBtdWx0aXBseSB3aXRoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzMuCiAgICAgICAgICovCiAgICAgICAgbXVsdGlwbHkob3RoZXIpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMueCAqIG90aGVyLngsIHRoaXMueSAqIG90aGVyLnksIHRoaXMueiAqIG90aGVyLnopOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBNdWx0aXBsaWVzIHR3byBWZWMzcy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIG11bHRpcGx5IHdpdGguCiAgICAgICAgICovCiAgICAgICAgbXVsdGlwbHlJblBsYWNlKG90aGVyKSB7CiAgICAgICAgICAgIHRoaXMueCAqPSBvdGhlci54OwogICAgICAgICAgICB0aGlzLnkgKj0gb3RoZXIueTsKICAgICAgICAgICAgdGhpcy56ICo9IG90aGVyLno7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIERpdmlkZXMgdHdvIFZlYzNzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB2ZWMzIC0gVGhlIG90aGVyIFZlYzMgdG8gZGl2aWRlIGJ5LgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzMuCiAgICAgICAgICovCiAgICAgICAgZGl2aWRlKHZlYzMpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMueCAvIHZlYzMueCwgdGhpcy55IC8gdmVjMy55LCB0aGlzLnogLyB2ZWMzLnopOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBEaXZpZGVzIHR3byBWZWMzcy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB2ZWMzIC0gVGhlIG90aGVyIFZlYzMgdG8gZGl2aWRlIGJ5LgogICAgICAgICAqLwogICAgICAgIGRpdmlkZUluUGxhY2UodmVjMykgewogICAgICAgICAgICB0aGlzLnggLz0gdmVjMy54OwogICAgICAgICAgICB0aGlzLnkgLz0gdmVjMy55OwogICAgICAgICAgICB0aGlzLnogLz0gdmVjMy56OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTY2FsZXMgdGhpcyBWZWMzIGJ5IHNjYWxhciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzMuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIC0gVGhlIHNjYWxhciB2YWx1ZS4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMzLgogICAgICAgICAqLwogICAgICAgIHNjYWxlKHNjYWxhcikgewogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy54ICogc2NhbGFyLCB0aGlzLnkgKiBzY2FsYXIsIHRoaXMueiAqIHNjYWxhcik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNjYWxlcyB0aGlzIFZlYzMgYnkgc2NhbGFyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2NhbGVJblBsYWNlKHNjYWxhcikgewogICAgICAgICAgICB0aGlzLnggKj0gc2NhbGFyOwogICAgICAgICAgICB0aGlzLnkgKj0gc2NhbGFyOwogICAgICAgICAgICB0aGlzLnogKj0gc2NhbGFyOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBOZWdhdGVzIHRoaXMgVmVjMyAoeCA9IC14LCB5ID0gLXkgYW5kIHogPSAteiksIGJ1dCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMy4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzMuCiAgICAgICAgICovCiAgICAgICAgbmVnYXRlKCkgewogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMoLXRoaXMueCwgLXRoaXMueSwgLXRoaXMueik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIGludmVyc2Ugb2YgdGhpcyBWZWMzLCBidXQgcmV0dXJucy4gdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMzLgogICAgICAgICAqLwogICAgICAgIGludmVyc2UoKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMygxLjAgLyB0aGlzLngsIDEuMCAvIHRoaXMueSwgMS4wIC8gdGhpcy56KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgdGhpcyBWZWMzLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGxlbmd0aC4KICAgICAgICAgKi8KICAgICAgICBsZW5ndGhTcXVhcmVkKCkgewogICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5fX2RhdGFbMF07CiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLl9fZGF0YVsxXTsKICAgICAgICAgICAgY29uc3QgeiA9IHRoaXMuX19kYXRhWzJdOwogICAgICAgICAgICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhpcyBWZWMzLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGxlbmd0aC4KICAgICAgICAgKi8KICAgICAgICBsZW5ndGgoKSB7CiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5sZW5ndGhTcXVhcmVkKCkpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSB0byBhbm90aGVyIFZlYzMuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIHRvLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHZlY3RvcnMuCiAgICAgICAgICovCiAgICAgICAgZGlzdGFuY2VUbyhvdGhlcikgewogICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5fX2RhdGFbMF0gLSBvdGhlci54OwogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV0gLSBvdGhlci55OwogICAgICAgICAgICBjb25zdCB6ID0gdGhpcy5fX2RhdGFbMl0gLSBvdGhlci56OwogICAgICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIE5vcm1hbGl6ZXMgdGhlIFZlYzMgYW5kIHJldHVybnMgaXQgYXMgYSBuZXcgVmVjMy4KICAgICAgICAgKiBNdWx0aXBsaWVzIGNvb3JkaW5hdGVzIHZhbHVlIGJ5IHRoZSBpbnZlcnNlIG9mIHRoZSB2ZWN0b3IgbGVuZ3RoLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIFZlYzMgbm9ybWFsaXplZC4KICAgICAgICAgKi8KICAgICAgICBub3JtYWxpemUoKSB7CiAgICAgICAgICAgIGxldCBsZW4gPSB0aGlzLl9fZGF0YVswXSAqIHRoaXMuX19kYXRhWzBdICsgdGhpcy5fX2RhdGFbMV0gKiB0aGlzLl9fZGF0YVsxXSArIHRoaXMuX19kYXRhWzJdICogdGhpcy5fX2RhdGFbMl07CiAgICAgICAgICAgIGlmIChsZW4gPCBOdW1iZXIuRVBTSUxPTikgewogICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/CiAgICAgICAgICAgIGxlbiA9IDEuMCAvIE1hdGguc3FydChsZW4pOwogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy5fX2RhdGFbMF0gKiBsZW4sIHRoaXMuX19kYXRhWzFdICogbGVuLCB0aGlzLl9fZGF0YVsyXSAqIGxlbik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIE5vcm1hbGl6ZXMgdGhpcyBWZWMzIG11bHRpcGx5aW5nIGNvb3JkaW5hdGUgdmFsdWVzIGJ5IHRoZSBpbnZlcnNlIG9mIHRoZSB2ZWN0b3IgbGVuZ3RoLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgbm9ybWFsaXplSW5QbGFjZSgpIHsKICAgICAgICAgICAgbGV0IGxlbiA9IHRoaXMuX19kYXRhWzBdICogdGhpcy5fX2RhdGFbMF0gKyB0aGlzLl9fZGF0YVsxXSAqIHRoaXMuX19kYXRhWzFdICsgdGhpcy5fX2RhdGFbMl0gKiB0aGlzLl9fZGF0YVsyXTsKICAgICAgICAgICAgaWYgKGxlbiA8IE51bWJlci5FUFNJTE9OKSB7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbGVuID0gTWF0aC5zcXJ0KGxlbik7CiAgICAgICAgICAgIGNvbnN0IHRtcCA9IDEuMCAvIGxlbjsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMF0gKj0gdG1wOwogICAgICAgICAgICB0aGlzLl9fZGF0YVsxXSAqPSB0bXA7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzJdICo9IHRtcDsKICAgICAgICAgICAgcmV0dXJuIGxlbjsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIG5ldyBWZWMzIHdpdGggdGhlIG5ldyBjb29yZGluYXRlcyhjYWxjdWxhdGVkIHdpdGggdGhpcyBWZWMzIGNvb3JkaW5hdGVzIGFuZCB0aGUgc3BlY2lmaWVkIGxlbmd0aCkuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gbGVuZ3RoIC0gVGhlIGxlbmd0aCB2YWx1ZS4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICByZXNpemUobGVuZ3RoKSB7CiAgICAgICAgICAgIGNvbnN0IGN1cnJMZW4gPSB0aGlzLl9fZGF0YVswXSAqIHRoaXMuX19kYXRhWzBdICsgdGhpcy5fX2RhdGFbMV0gKiB0aGlzLl9fZGF0YVsxXSArIHRoaXMuX19kYXRhWzJdICogdGhpcy5fX2RhdGFbMl07CiAgICAgICAgICAgIGlmIChjdXJyTGVuIDwgTnVtYmVyLkVQU0lMT04pIHsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBzY2wgPSBsZW5ndGggLyBNYXRoLnNxcnQoY3Vyckxlbik7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh0aGlzLl9fZGF0YVswXSAqIHNjbCwgdGhpcy5fX2RhdGFbMV0gKiBzY2wsIHRoaXMuX19kYXRhWzJdICogc2NsKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogTW9kaWZpZXMgY3VycmVudCBjb29yZGluYXRlcyB1c2luZyB0aGUgc3BlY2lmaWVkIGxlbmd0aC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBsZW5ndGggLSBUaGUgbGVuZ3RoIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHJlc2l6ZUluUGxhY2UobGVuZ3RoKSB7CiAgICAgICAgICAgIGNvbnN0IGN1cnJMZW4gPSB0aGlzLl9fZGF0YVswXSAqIHRoaXMuX19kYXRhWzBdICsgdGhpcy5fX2RhdGFbMV0gKiB0aGlzLl9fZGF0YVsxXSArIHRoaXMuX19kYXRhWzJdICogdGhpcy5fX2RhdGFbMl07CiAgICAgICAgICAgIGlmIChjdXJyTGVuIDwgTnVtYmVyLkVQU0lMT04pIHsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBzY2wgPSBsZW5ndGggLyBNYXRoLnNxcnQoY3Vyckxlbik7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzBdICo9IHNjbDsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMV0gKj0gc2NsOwogICAgICAgICAgICB0aGlzLl9fZGF0YVsyXSAqPSBzY2w7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHRoaXMgVmVjMyBhZ2FpbnN0IGFub3RoZXIgVmVjMy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIGNvbXBhcmUgd2l0aC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgZG90IHByb2R1Y3QuCiAgICAgICAgICovCiAgICAgICAgZG90KG90aGVyKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiBvdGhlci54ICsgdGhpcy55ICogb3RoZXIueSArIHRoaXMueiAqIG90aGVyLno7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIFZlYzNzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIGNhbGN1bGF0ZSB3aXRoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBjcm9zcyBwcm9kdWN0IGFzIGEgbmV3IFZlYzMuCiAgICAgICAgICovCiAgICAgICAgY3Jvc3Mob3RoZXIpIHsKICAgICAgICAgICAgY29uc3QgYXggPSB0aGlzLng7CiAgICAgICAgICAgIGNvbnN0IGF5ID0gdGhpcy55OwogICAgICAgICAgICBjb25zdCBheiA9IHRoaXMuejsKICAgICAgICAgICAgY29uc3QgYnggPSBvdGhlci54OwogICAgICAgICAgICBjb25zdCBieSA9IG90aGVyLnk7CiAgICAgICAgICAgIGNvbnN0IGJ6ID0gb3RoZXIuejsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKGF5ICogYnogLSBheiAqIGJ5LCBheiAqIGJ4IC0gYXggKiBieiwgYXggKiBieSAtIGF5ICogYngpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXRzIHRoZSBhbmdsZSBiZXR3ZWVuIHRoaXMgVmVjMyBhbmQgYi4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWMzIHRvIGNvbXBhcmUgd2l0aC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgYW5nbGUgaW4gcmFkaWFucy4KICAgICAgICAgKi8KICAgICAgICBhbmdsZVRvKG90aGVyKSB7CiAgICAgICAgICAgIGNvbnN0IGNvc2luZSA9IHRoaXMuZG90KG90aGVyKTsKICAgICAgICAgICAgaWYgKGNvc2luZSA+IDEuMCkgewogICAgICAgICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5hY29zKGNvc2luZSk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHRoaXMgVmVjMyBhbmQgb3RoZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjMyB0byBpbnRlcnBvbGF0ZSBiZXR3ZWVuLgogICAgICAgICAqIEBwYXJhbSB0IC0gSW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0cy4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMzLgogICAgICAgICAqLwogICAgICAgIGxlcnAob3RoZXIsIHQpIHsKICAgICAgICAgICAgY29uc3QgYXggPSB0aGlzLng7CiAgICAgICAgICAgIGNvbnN0IGF5ID0gdGhpcy55OwogICAgICAgICAgICBjb25zdCBheiA9IHRoaXMuejsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKGF4ICsgdCAqIChvdGhlci54IC0gYXgpLCBheSArIHQgKiAob3RoZXIueSAtIGF5KSwgYXogKyB0ICogKG90aGVyLnogLSBheikpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IFZlYzMgd2hvc2UgY29tcG9uZW50IHZhbHVlcyBhcmUgdGhlIGFicyBvZiB0aGlzIFZlYzNzIGNvbXBvbmVudCB2YWx1ZXMuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMzLgogICAgICAgICAqLwogICAgICAgIGFicygpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKE1hdGguYWJzKHRoaXMueCksIE1hdGguYWJzKHRoaXMueSksIE1hdGguYWJzKHRoaXMueikpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHRoZSB2ZWN0b3IgYSByYW5kb20gdmVjdG9yIG9uIHRoZSBzdXJmYWNlIG9mIGEgc3BoZXJlIHdpdGggdGhlIHJhZGl1cyBvZiB0aGUgZ2l2ZW4gc2NhbGUgdmFsdWUuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gc2NhbGUgLSBUaGUgcmFkaXVzIG9mIHRoZSBzdXJmYWNlIHNwaGVyZS4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJhbmRvbSBWZWMzLgogICAgICAgICAqLwogICAgICAgIHNldFJhbmRvbURpcihzY2FsZSA9IDEuMCkgewogICAgICAgICAgICBjb25zdCByID0gTWF0aC5yYW5kb20oKSAqIDIuMCAqIE1hdGguUEk7CiAgICAgICAgICAgIGNvbnN0IHogPSBNYXRoLnJhbmRvbSgpICogMi4wIC0gMS4wOwogICAgICAgICAgICBjb25zdCB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wIC0geiAqIHopICogc2NhbGU7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGU7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGU7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzJdID0geiAqIHNjYWxlOwogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciBhbnl3aGVyZSBpbiB0aGUgc3BoZXJlIGRlZmluZWQgYnkgdGhlIHByb3ZpZGVkIHNjYWxlIHZhbHVlLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHNjYWxlIC0gVGhlIHJhZGl1cyBvZiB0aGUgYm91bmRpbmcgc3BoZXJlLgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmFuZG9tIFZlYzMuCiAgICAgICAgICovCiAgICAgICAgc2V0UmFuZG9tKHNjYWxlID0gMS4wKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzBdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogc2NhbGU7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzFdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogc2NhbGU7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzJdID0gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogc2NhbGU7CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDbG9uZXMgdGhpcyBWZWMzIGFuZCByZXR1cm5zIGEgbmV3IFZlYzMuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMzLgogICAgICAgICAqLwogICAgICAgIGNsb25lKCkgewogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIHR5cGUgYXMgYW4gYXJyYXkuIE9mdGVuIHVzZWQgdG8gcGFzcyB0eXBlcyB0byB0aGUgR1BVLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYXMgYW4gYXJyYXkuCiAgICAgICAgICovCiAgICAgICAgYXNBcnJheSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhOyAvLyBUT0RPOiByZXR1cm4gdHlwZSArIGNhc3QgaXMgYSB0ZW1wIGZpeAogICAgICAgIH0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8KICAgICAgICAvLyBQZXJzaXN0ZW5jZQogICAgICAgIC8qKgogICAgICAgICAqIENvbnZlcnRzIHRoaXMgVmVjMyB0byBhIHN0cmluZyBpbiBKU09OIGZvcm1hdC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHRvU3RyaW5nKCkgewogICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcAogICAgICAgICAgICByZXR1cm4gU3RyaW5nRnVuY3Rpb25zLnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEVuY29kZXMgVmVjMyBDbGFzcyBhcyBhIEpTT04gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUganNvbiBvYmplY3QuCiAgICAgICAgICovCiAgICAgICAgdG9KU09OKCkgewogICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgeDogdGhpcy54LAogICAgICAgICAgICAgICAgeTogdGhpcy55LAogICAgICAgICAgICAgICAgejogdGhpcy56LAogICAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBEZWNvZGVzIGEgSlNPTiBvYmplY3QgdG8gc2V0IHRoZSBzdGF0ZSBvZiB0aGlzIGNsYXNzLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIGogLSBUaGUganNvbiBvYmplY3QuCiAgICAgICAgICovCiAgICAgICAgZnJvbUpTT04oaikgewogICAgICAgICAgICB0aGlzLnggPSBqLng7CiAgICAgICAgICAgIHRoaXMueSA9IGoueTsKICAgICAgICAgICAgdGhpcy56ID0gai56OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBMb2FkcyB0aGUgc3RhdGUgb2YgdGhlIHZhbHVlIGZyb20gYSBiaW5hcnkgcmVhZGVyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIpIHsKICAgICAgICAgICAgdGhpcy54ID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7CiAgICAgICAgICAgIHRoaXMueSA9IHJlYWRlci5sb2FkRmxvYXQzMigpOwogICAgICAgICAgICB0aGlzLnogPSByZWFkZXIubG9hZEZsb2F0MzIoKTsKICAgICAgICB9CiAgICAgICAgaXNWYWxpZCgpIHsKICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHRoaXMuX19kYXRhKSB7CiAgICAgICAgICAgICAgICBpZiAodiA9PSBJbmZpbml0eSB8fCBpc05hTih2KSkKICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgfQogICAgfQoKICAgIC8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi8KICAgIC8qKgogICAgICogUmVwcmVzZW50cyBhIGZvdXItZGltZW5zaW9uYWwgY29vcmRpbmF0ZS4KICAgICAqIE1hdGggdHlwZXMgaW50ZXJuYWxseSBzdG9yZSB2YWx1ZXMgaW4ge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Zsb2F0MzJBcnJheXxGbG9hdDMyQXJyYXl9IGFuZAogICAgICogZXhwb3NlIGdldHRlcnMgYW5kIHNldHRlcnMgZm9yIHRoZSBjb21wb25lbnQgdmFsdWVzLgogICAgICoKICAgICAqLwogICAgY2xhc3MgVmVjNCB7CiAgICAgICAgLyoqCiAgICAgICAgICogQ3JlYXRlcyBhIFZlYzQuCiAgICAgICAgICoKICAgICAgICAgKiBUaGUgdHlwZSBvZiB2YWx1ZXMgb2YgdGhlIGAoeCwgeSwgeiwgdClgIGNvb3JkaW5hdGVzIGNhbiBiZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvRmxvYXQzMkFycmF5fEZsb2F0MzJBcnJheX0sCiAgICAgICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1VpbnQzMkFycmF5fFVpbnQzMkFycmF5fSwKICAgICAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvSW50MzJBcnJheXxJbnQzMkFycmF5fSBhbmQKICAgICAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZXMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2lhL09iamV0b3NfZ2xvYmFsZXMvQXJyYXlCdWZmZXJ8QXJyYXlCdWZmZXJ9LgogICAgICAgICAqCiAgICAgICAgICogWW91IGNhbiBhbHNvIHBhc3Mgb25lIEpTT04gb2JqZWN0IHBhcmFtZXRlci4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB4IC0gVGhlIHggdmFsdWUuIERlZmF1bHQgaXMgMC4KICAgICAgICAgKiBAcGFyYW0geSAtIFRoZSB5IHZhbHVlLiBEZWZhdWx0IGlzIDAuCiAgICAgICAgICogQHBhcmFtIHogLSBUaGUgeSB2YWx1ZS4gRGVmYXVsdCBpcyAwLgogICAgICAgICAqIEBwYXJhbSB0IC0gVGhlIHQgdmFsdWUuIERlZmF1bHQgaXMgMC4KICAgICAgICAgKi8KICAgICAgICBjb25zdHJ1Y3Rvcih4ID0gMCwgeSA9IDAsIHogPSAwLCB0ID0gMCkgewogICAgICAgICAgICBpZiAoeCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fCB4IGluc3RhbmNlb2YgVWludDMyQXJyYXkpIHsKICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhID0geDsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmICh4IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBuZXcgVmVjNChuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCkpYCk7CiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSB4OwogICAgICAgICAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IHk7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCA0KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgeCA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgeSA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgeiA9PSAnbnVtYmVyJyAmJiB0eXBlb2YgdCA9PSAnbnVtYmVyJykgewogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDQpOwogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbMF0gPSB4OwogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbMV0gPSB5OwogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbMl0gPSB6OwogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbM10gPSB0OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgaWYgKHggIT0gbnVsbCAmJiB0eXBlb2YgeCA9PSAnb2JqZWN0JykgewogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDQpOwogICAgICAgICAgICAgICAgdGhpcy5mcm9tSlNPTih4KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheSg0KTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIGB4YCB2YWx1ZS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSB4IHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldCB4KCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbMF07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3IgYHhgIHZhbHVlLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IHgodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzBdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIGB5YCB2YWx1ZS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSB5IHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldCB5KCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbMV07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3IgYHlgIHZhbHVlLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IHkodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzFdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIGB6YCB2YWx1ZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIGdldCB6KCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbMl07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3IgYHpgIHZhbHVlLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IHoodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzJdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIGB0YCB2YWx1ZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIGdldCB0KCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbM107CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3IgYHRgIHZhbHVlLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IHQodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzNdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIGB3YCB2YWx1ZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIGdldCB3KCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbM107CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3IgYHdgIHZhbHVlLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IHcodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzNdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIGB4eXpgIHN3aXp6ZWwuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgeiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXQgeHl6KCkgewogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmcm9tIHNjYWxhciBjb21wb25lbnRzLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHggLSBUaGUgeCB2YWx1ZS4KICAgICAgICAgKiBAcGFyYW0geSAgLSBUaGUgeSB2YWx1ZS4KICAgICAgICAgKiBAcGFyYW0geiAgLSBUaGUgeSB2YWx1ZS4KICAgICAgICAgKiBAcGFyYW0gdCAgLSBUaGUgdCB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzZXQoeCwgeSwgeiwgdCkgewogICAgICAgICAgICB0aGlzLnggPSB4OwogICAgICAgICAgICB0aGlzLnkgPSB5OwogICAgICAgICAgICB0aGlzLnogPSB6OwogICAgICAgICAgICB0aGlzLnQgPSB0OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiBhIFZlYzQgT2JqZWN0IGZyb20gYW5vdGhlciBWZWM0LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gc2V0IGZyb20uCiAgICAgICAgICovCiAgICAgICAgc2V0RnJvbU90aGVyKG90aGVyKSB7CiAgICAgICAgICAgIHRoaXMueCA9IG90aGVyLng7CiAgICAgICAgICAgIHRoaXMueSA9IG90aGVyLnk7CiAgICAgICAgICAgIHRoaXMueiA9IG90aGVyLno7CiAgICAgICAgICAgIHRoaXMudCA9IG90aGVyLnQ7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENoZWNrcyBpZiB0aGlzIFZlYzQgY29udGFpbnMgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZSBvdGhlciBWZWM0LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gY29tcGFyZSB3aXRoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuCiAgICAgICAgICovCiAgICAgICAgaXNFcXVhbChvdGhlcikgewogICAgICAgICAgICByZXR1cm4gdGhpcy54ID09IG90aGVyLnggJiYgdGhpcy55ID09IG90aGVyLnkgJiYgdGhpcy56ID09IG90aGVyLnogJiYgdGhpcy50ID09IG90aGVyLnQ7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENoZWNrcyBpZiB0aGlzIFZlYzQgaXMgZGlmZmVyZW50IGZyb20gYW5vdGhlciBWZWM0LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gY29tcGFyZSB3aXRoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuCiAgICAgICAgICovCiAgICAgICAgbm90RXF1YWwob3RoZXIpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMueCAhPSBvdGhlci54ICYmIHRoaXMueSAhPSBvdGhlci55ICYmIHRoaXMueiAhPSBvdGhlci56ICYmIHRoaXMudCAhPSBvdGhlci50OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBWZWM0IGlzIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgYXMgb3RoZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBjb21wYXJlIHdpdGguCiAgICAgICAgICogQHBhcmFtIHByZWNpc2lvbiAtIFRoZSBwcmVjaXNpb24gdG8gd2hpY2ggdGhlIHZhbHVlcyBtdXN0IG1hdGNoLgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGFwcHJveEVxdWFsKG90aGVyLCBwcmVjaXNpb24gPSBOdW1iZXIuRVBTSUxPTikgewogICAgICAgICAgICByZXR1cm4gKE1hdGguYWJzKHRoaXMueCAtIG90aGVyLngpIDwgcHJlY2lzaW9uICYmCiAgICAgICAgICAgICAgICBNYXRoLmFicyh0aGlzLnkgLSBvdGhlci55KSA8IHByZWNpc2lvbiAmJgogICAgICAgICAgICAgICAgTWF0aC5hYnModGhpcy56IC0gb3RoZXIueikgPCBwcmVjaXNpb24gJiYKICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMudCAtIG90aGVyLnQpIDwgcHJlY2lzaW9uKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQWRkcyBvdGhlciB0byB0aGlzIFZlYzQgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWM0LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gYWRkLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzQuCiAgICAgICAgICovCiAgICAgICAgYWRkKG90aGVyKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjNCh0aGlzLnggKyBvdGhlci54LCB0aGlzLnkgKyBvdGhlci55LCB0aGlzLnogKyBvdGhlci56LCB0aGlzLnQgKyBvdGhlci50KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQWRkcyBvdGhlciB0byB0aGlzIFZlYzQgbXV0YXRpbmcgdGhlIHZhbHVlcyBvZiB0aGlzIGluc3RhbmNlCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBhZGQuCiAgICAgICAgICovCiAgICAgICAgYWRkSW5QbGFjZShvdGhlcikgewogICAgICAgICAgICB0aGlzLnggKz0gb3RoZXIueDsKICAgICAgICAgICAgdGhpcy55ICs9IG90aGVyLnk7CiAgICAgICAgICAgIHRoaXMueiArPSBvdGhlci56OwogICAgICAgICAgICB0aGlzLnQgKz0gb3RoZXIudDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU3VidHJhY3RzIG90aGVyIGZyb20gdGhpcyBWZWM0IGFuZCByZXR1cm5zIHRoZW4gcmVzdWx0IGFzIGEgbmV3IFZlYzQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBzdWJ0cmFjdC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWM0LgogICAgICAgICAqLwogICAgICAgIHN1YnRyYWN0KG90aGVyKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjNCh0aGlzLnggLSBvdGhlci54LCB0aGlzLnkgLSBvdGhlci55LCB0aGlzLnogLSBvdGhlci56LCB0aGlzLnQgLSBvdGhlci50KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU3VidHJhY3RzIG90aGVyIGZyb20gdGhpcyBWZWM0IG11dGF0aW5nIHRoZSB2YWx1ZXMgb2YgdGhpcyBpbnN0YW5jZQogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gc3VidHJhY3QuCiAgICAgICAgICovCiAgICAgICAgc3VidHJhY3RJblBsYWNlKG90aGVyKSB7CiAgICAgICAgICAgIHRoaXMueCAtPSBvdGhlci54OwogICAgICAgICAgICB0aGlzLnkgLT0gb3RoZXIueTsKICAgICAgICAgICAgdGhpcy56IC09IG90aGVyLno7CiAgICAgICAgICAgIHRoaXMudCAtPSBvdGhlci50OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBNdWx0aXBsaWVzIHR3byBWZWM0cyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBtdWx0aXBseSB3aXRoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzQuCiAgICAgICAgICovCiAgICAgICAgbXVsdGlwbHkob3RoZXIpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWM0KHRoaXMueCAqIG90aGVyLngsIHRoaXMueSAqIG90aGVyLnksIHRoaXMueiAqIG90aGVyLnosIHRoaXMudCAqIG90aGVyLnQpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBNdWx0aXBsaWVzIHR3byBWZWM0cyBtdXRhdGluZyB0aGUgdmFsdWVzIG9mIHRoaXMgaW5zdGFuY2UKICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIG11bHRpcGx5IHdpdGguCiAgICAgICAgICovCiAgICAgICAgbXVsdGlwbHlJblBsYWNlKG90aGVyKSB7CiAgICAgICAgICAgIHRoaXMueCAqPSBvdGhlci54OwogICAgICAgICAgICB0aGlzLnkgKj0gb3RoZXIueTsKICAgICAgICAgICAgdGhpcy56ICo9IG90aGVyLno7CiAgICAgICAgICAgIHRoaXMudCAqPSBvdGhlci50OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBEaXZpZGVzIHR3byBWZWM0cyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBkaXZpZGUgYnkuCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgVmVjNC4KICAgICAgICAgKi8KICAgICAgICBkaXZpZGUob3RoZXIpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWM0KHRoaXMueCAvIG90aGVyLngsIHRoaXMueSAvIG90aGVyLnksIHRoaXMueiAvIG90aGVyLnosIHRoaXMudCAvIG90aGVyLnQpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBEaXZpZGVzIHR3byBWZWM0cy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGRpdmlkZSBieS4KICAgICAgICAgKi8KICAgICAgICBkaXZpZGVJblBsYWNlKG90aGVyKSB7CiAgICAgICAgICAgIHRoaXMueCAvPSBvdGhlci54OwogICAgICAgICAgICB0aGlzLnkgLz0gb3RoZXIueTsKICAgICAgICAgICAgdGhpcy56IC89IG90aGVyLno7CiAgICAgICAgICAgIHRoaXMudCAvPSBvdGhlci50OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTY2FsZXMgdGhpcyBWZWM0IGJ5IHNjYWxhciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIC0gVGhlIHNjYWxhciB2YWx1ZS4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzY2FsZShzY2FsYXIpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWM0KHRoaXMueCAqIHNjYWxhciwgdGhpcy55ICogc2NhbGFyLCB0aGlzLnogKiBzY2FsYXIsIHRoaXMudCAqIHNjYWxhcik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNjYWxlcyB0aGlzIFZlYzQgYnkgc2NhbGFyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2NhbGVJblBsYWNlKHNjYWxhcikgewogICAgICAgICAgICB0aGlzLnNldCh0aGlzLnggKiBzY2FsYXIsIHRoaXMueSAqIHNjYWxhciwgdGhpcy56ICogc2NhbGFyLCB0aGlzLnQgKiBzY2FsYXIpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgdGhpcyBWZWM0LgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGxlbmd0aC4KICAgICAgICAgKi8KICAgICAgICBsZW5ndGgoKSB7CiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLl9fZGF0YVswXTsKICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuX19kYXRhWzFdOwogICAgICAgICAgICBjb25zdCB6ID0gdGhpcy5fX2RhdGFbMl07CiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLl9fZGF0YVsyXTsKICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHogKyB0ICogdCk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIHRoaXMgVmVjNC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBsZW5ndGguCiAgICAgICAgICovCiAgICAgICAgbGVuZ3RoU3F1YXJlZCgpIHsKICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdOwogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV07CiAgICAgICAgICAgIGNvbnN0IHogPSB0aGlzLl9fZGF0YVsyXTsKICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMuX19kYXRhWzNdOwogICAgICAgICAgICByZXR1cm4geCAqIHggKyB5ICogeSArIHogKiB6ICsgdCAqIHQ7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIE5vcm1hbGl6ZXMgdGhlIFZlYzQgYW5kIHJldHVybnMgaXQgYXMgYSBuZXcgVmVjNC4KICAgICAgICAgKiBNdWx0aXBsaWVzIGNvb3JkaW5hdGVzIHZhbHVlIGJ5IHRoZSBpbnZlcnNlIG9mIHRoZSB2ZWN0b3IgbGVuZ3RoLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIFZlYzQgbm9ybWFsaXplZC4KICAgICAgICAgKi8KICAgICAgICBub3JtYWxpemUoKSB7CiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLl9fZGF0YVswXTsKICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuX19kYXRhWzFdOwogICAgICAgICAgICBjb25zdCB6ID0gdGhpcy5fX2RhdGFbMl07CiAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLl9fZGF0YVszXTsKICAgICAgICAgICAgbGV0IGxlbiA9IHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHQgKiB0OwogICAgICAgICAgICBpZiAobGVuIDwgTnVtYmVyLkVQU0lMT04pIHsKICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjNCgpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vIFRPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlPwogICAgICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjNCh4ICogbGVuLCB5ICogbGVuLCB6ICogbGVuKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogTm9ybWFsaXplcyB0aGlzIFZlYzQgbXVsdGlwbHlpbmcgY29vcmRpbmF0ZSB2YWx1ZXMgYnkgdGhlIGludmVyc2Ugb2YgdGhlIHZlY3RvciBsZW5ndGguCiAgICAgICAgICovCiAgICAgICAgbm9ybWFsaXplSW5QbGFjZSgpIHsKICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdOwogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV07CiAgICAgICAgICAgIGNvbnN0IHogPSB0aGlzLl9fZGF0YVsyXTsKICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMuX19kYXRhWzNdOwogICAgICAgICAgICBsZXQgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6ICsgdCAqIHQ7CiAgICAgICAgICAgIGlmIChsZW4gPCBOdW1iZXIuRVBTSUxPTikgewogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTsKICAgICAgICAgICAgdGhpcy5zZXQoeCAqIGxlbiwgeSAqIGxlbiwgeiAqIGxlbiwgdCAqIGxlbik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHRoaXMgVmVjNCBhZ2FpbnN0IGFub3RoZXIgVmVjNC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGNvbXBhcmUgd2l0aC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgZG90IHByb2R1Y3QuCiAgICAgICAgICovCiAgICAgICAgZG90KG90aGVyKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiBvdGhlci54ICsgdGhpcy55ICogb3RoZXIueSArIHRoaXMueiAqIG90aGVyLnogKyB0aGlzLnQgKiBvdGhlci50OyAvLyBUT0RPOiBvdGhlci50IHVzZWQgdG8gYmUgYi50PwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byBWZWM0cyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFZlYzQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgVmVjNCB0byBjYWxjdWxhdGUgd2l0aC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgY3Jvc3MgcHJvZHVjdCBhcyBhIG5ldyBWZWM0LgogICAgICAgICAqLwogICAgICAgIGNyb3NzKG90aGVyKSB7CiAgICAgICAgICAgIGNvbnN0IGF4ID0gdGhpcy54OwogICAgICAgICAgICBjb25zdCBheSA9IHRoaXMueTsKICAgICAgICAgICAgY29uc3QgYXogPSB0aGlzLno7CiAgICAgICAgICAgIGNvbnN0IGF0ID0gdGhpcy50OwogICAgICAgICAgICBjb25zdCBieCA9IG90aGVyLng7CiAgICAgICAgICAgIGNvbnN0IGJ5ID0gb3RoZXIueTsKICAgICAgICAgICAgY29uc3QgYnogPSBvdGhlci56OwogICAgICAgICAgICBjb25zdCBidCA9IG90aGVyLnQ7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjNChheSAqIGJ6IC0gYXogKiBieSwgYXogKiBidCAtIGF0ICogYnosIGF0ICogYnggLSBheCAqIGJ0LCBheCAqIGJ5IC0gYXkgKiBieCk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHMgdGhlIGFuZ2xlIGJldHdlZW4gdGhpcyBWZWM0IGFuZCBiLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFZlYzQgdG8gY29tcGFyZSB3aXRoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBhbmdsZSBpbiByYWRpYW5zLgogICAgICAgICAqLwogICAgICAgIGFuZ2xlVG8ob3RoZXIpIHsKICAgICAgICAgICAgY29uc3QgdGVtcEEgPSB0aGlzLm5vcm1hbGl6ZSgpOwogICAgICAgICAgICBjb25zdCB0ZW1wQiA9IG90aGVyLm5vcm1hbGl6ZSgpOwogICAgICAgICAgICBjb25zdCBjb3NpbmUgPSB0ZW1wQS5kb3QodGVtcEIpOwogICAgICAgICAgICBpZiAoY29zaW5lID4gMS4wKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gMDsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdGhpcyBWZWM0IGFuZCBvdGhlci4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBWZWM0IHRvIGludGVycG9sYXRlIGJldHdlZW4uCiAgICAgICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzQuCiAgICAgICAgICovCiAgICAgICAgbGVycChvdGhlciwgdCkgewogICAgICAgICAgICBjb25zdCBheCA9IHRoaXMueDsKICAgICAgICAgICAgY29uc3QgYXkgPSB0aGlzLnk7CiAgICAgICAgICAgIGNvbnN0IGF6ID0gdGhpcy56OwogICAgICAgICAgICBjb25zdCBhdCA9IHRoaXMudDsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWM0KGF4ICsgdCAqIChvdGhlci54IC0gYXgpLCBheSArIHQgKiAob3RoZXIueSAtIGF5KSwgYXogKyB0ICogKG90aGVyLnogLSBheiksIGF0ICsgdCAqIChvdGhlci50IC0gYXQpKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBzY2FsZSAtIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkLgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIC8vIHJhbmRvbShzY2FsZSA9IDEuMCkgewogICAgICAgIC8vICAgY29uc3QgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSQogICAgICAgIC8vICAgY29uc3QgeiA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wIC0gMS4wCiAgICAgICAgLy8gICBjb25zdCB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wIC0geiAqIHopICogc2NhbGUKICAgICAgICAvLyAgIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlCiAgICAgICAgLy8gICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZQogICAgICAgIC8vICAgb3V0WzJdID0geiAqIHNjYWxlCiAgICAgICAgLy8gICByZXR1cm4gb3V0CiAgICAgICAgLy8gfQogICAgICAgIC8qKgogICAgICAgICAqIENsb25lcyB0aGlzIFZlYzQgYW5kIHJldHVybnMgYSBuZXcgVmVjNC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzQuCiAgICAgICAgICovCiAgICAgICAgY2xvbmUoKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjNCh0aGlzLl9fZGF0YVswXSwgdGhpcy5fX2RhdGFbMV0sIHRoaXMuX19kYXRhWzJdLCB0aGlzLl9fZGF0YVszXSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENvbnZlcnRzIHRoaXMgVmVjNCBpbnRvIGEgVmVjMy4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSB2YWx1ZSBhcyBhIG5ldyBWZWMzLgogICAgICAgICAqLwogICAgICAgIHRvVmVjMygpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMuX19kYXRhWzBdLCB0aGlzLl9fZGF0YVsxXSwgdGhpcy5fX2RhdGFbMl0pOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRoZSB0eXBlIGFzIGFuIGFycmF5LiBPZnRlbiB1c2VkIHRvIHBhc3MgdHlwZXMgdG8gdGhlIEdQVS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGFzIGFuIGFycmF5LgogICAgICAgICAqLwogICAgICAgIGFzQXJyYXkoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YTsKICAgICAgICB9CiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCiAgICAgICAgLy8gUGVyc2lzdGVuY2UKICAgICAgICAvKioKICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFZlYzMgdG8gYSBzdHJpbmcgaW4gSlNPTiBmb3JtYXQuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICB0b1N0cmluZygpIHsKICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXAKICAgICAgICAgICAgcmV0dXJuIFN0cmluZ0Z1bmN0aW9ucy5zdHJpbmdpZnlKU09OV2l0aEZpeGVkUHJlY2lzaW9uKHRoaXMudG9KU09OKCkpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIGpzb24gb2JqZWN0LgogICAgICAgICAqLwogICAgICAgIHRvSlNPTigpIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIHg6IHRoaXMueCwKICAgICAgICAgICAgICAgIHk6IHRoaXMueSwKICAgICAgICAgICAgICAgIHo6IHRoaXMueiwKICAgICAgICAgICAgICAgIHQ6IHRoaXMudCwKICAgICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogRGVjb2RlcyBhIEpTT04gb2JqZWN0IHRvIHNldCB0aGUgc3RhdGUgb2YgdGhpcyBjbGFzcy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBqIC0gVGhlIGpzb24gb2JqZWN0LgogICAgICAgICAqLwogICAgICAgIGZyb21KU09OKGopIHsKICAgICAgICAgICAgdGhpcy54ID0gai54OwogICAgICAgICAgICB0aGlzLnkgPSBqLnk7CiAgICAgICAgICAgIHRoaXMueiA9IGouejsKICAgICAgICAgICAgdGhpcy50ID0gai50OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBMb2FkcyB0aGUgc3RhdGUgb2YgdGhlIHZhbHVlIGZyb20gYSBiaW5hcnkgcmVhZGVyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgcmVhZEJpbmFyeShyZWFkZXIpIHsKICAgICAgICAgICAgdGhpcy54ID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7CiAgICAgICAgICAgIHRoaXMueSA9IHJlYWRlci5sb2FkRmxvYXQzMigpOwogICAgICAgICAgICB0aGlzLnogPSByZWFkZXIubG9hZEZsb2F0MzIoKTsKICAgICAgICAgICAgdGhpcy50ID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFZlcmlmaWVzIGlmIHRoZSB2YWx1ZXMgc3RvcmVkIGluIHRoaXMgTWF0aCB0eXBlIGFyZSB2YWxpZCBudW1lcmljIHZhbHVlcy4KICAgICAgICAgKiBSZXR1cm5zIGBmYWxzZWAgSWYgYXQgbGVhc3Qgb25lIG9mIHRoZSB2YWx1ZXMgaXMgZWl0aGVyIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jaWEvT2JqZXRvc19nbG9iYWxlcy9JbmZpbml0eXxJbmZpbml0eX0gb3IKICAgICAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2lhL09iamV0b3NfZ2xvYmFsZXMvTmFOfE5hTn0uCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgYm9vbGVhbi4KICAgICAgICAgKi8KICAgICAgICBpc1ZhbGlkKCkgewogICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdGhpcy5fX2RhdGEpIHsKICAgICAgICAgICAgICAgIGlmICh2ID09IEluZmluaXR5IHx8IGlzTmFOKHYpKQogICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CiAgICB9CgogICAgLyoqCiAgICAgKiBDbGFzcyByZXByZXNlbnRpbmcgYSBjb2xvciBhcyA0IGZsb2F0aW5nIHBvaW50IHZhbHVlcy4KICAgICAqLwogICAgY2xhc3MgQ29sb3IgewogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZXMgYSBgQ29sb3JgIG9iamVjdCB3aXRoIGFuIFJHQkEgc3RydWN0dXJlLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHIgLSBUaGUgcmVkIGNoYW5uZWwgb2YgYSBjb2xvci4KICAgICAgICAgKiBAcGFyYW0gZyAtIFRoZSBncmVlbiBjaGFubmVsIG9mIGEgY29sb3IuCiAgICAgICAgICogQHBhcmFtIGIgLSBUaGUgYmx1ZSBjaGFubmVsIG9mIGEgY29sb3IuCiAgICAgICAgICogQHBhcmFtIGEgLSBUaGUgYWxwaGEgKHRyYW5zcGFyZW5jeSkgY2hhbm5lbCBvZiBhIGNvbG9yLgogICAgICAgICAqLwogICAgICAgIGNvbnN0cnVjdG9yKHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAxLjApIHsKICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHsKICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhID0gcjsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmIChyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBuZXcgVmVjNChuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCkpYCk7CiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSByOwogICAgICAgICAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IGc7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoYnVmZmVyLCBieXRlT2Zmc2V0LCA0KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheSg0KTsKICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgciA9PSAnc3RyaW5nJykgewogICAgICAgICAgICAgICAgICAgIGlmIChyLnN0YXJ0c1dpdGgoJyMnKSkgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEZyb21IZXgocik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEZyb21DU1NDb2xvck5hbWUocik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbMF0gPSByOwogICAgICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhWzFdID0gZzsKICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVsyXSA9IGI7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbM10gPSBhOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3IgcmVkIGNoYW5uZWwuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgcmVkIGNoYW5uZWwuCiAgICAgICAgICovCiAgICAgICAgZ2V0IHIoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVswXTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZvciByZWQgY2hhbm5lbC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIHNldCByKHZhbCkgewogICAgICAgICAgICB0aGlzLl9fZGF0YVswXSA9IHZhbDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2V0dGVyIGZvciBncmVlbiBjaGFubmVsLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGdyZWVuIGNoYW5uZWwuCiAgICAgICAgICovCiAgICAgICAgZ2V0IGcoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVsxXTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZvciBncmVlbiBjaGFubmVsLgogICAgICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIHNldCBnKHZhbCkgewogICAgICAgICAgICB0aGlzLl9fZGF0YVsxXSA9IHZhbDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2V0dGVyIGZvciBibHVlIGNoYW5uZWwuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgYmx1ZSBjaGFubmVsLgogICAgICAgICAqLwogICAgICAgIGdldCBiKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbMl07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3IgYmx1ZSBjaGFubmVsLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IGIodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzJdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIGFscGhhIGNoYW5uZWwuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgYWxwaGEgY2hhbm5lbC4KICAgICAgICAgKi8KICAgICAgICBnZXQgYSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzNdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIGFscGhhIHZhbHVlLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IGEodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzNdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZnJvbSBzY2FsYXIgY29tcG9uZW50cy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSByIC0gVGhlIHJlZCBjaGFubmVsLgogICAgICAgICAqIEBwYXJhbSBnICAtIFRoZSBncmVlbiBjaGFubmVsLgogICAgICAgICAqIEBwYXJhbSBiICAtIFRoZSBibHVlIGNoYW5uZWwuCiAgICAgICAgICogQHBhcmFtIGEgIC0gVGhlIGFscGhhIGNoYW5uZWwuCiAgICAgICAgICovCiAgICAgICAgc2V0KHIsIGcsIGIsIGEgPSAxLjApIHsKICAgICAgICAgICAgdGhpcy5yID0gcjsKICAgICAgICAgICAgdGhpcy5nID0gZzsKICAgICAgICAgICAgdGhpcy5iID0gYjsKICAgICAgICAgICAgdGhpcy5hID0gYTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyBjdXJyZW50IGNvbG9yIHN0YXRlIHdpdGggYW5vdGhlciBgQ29sb3JgIG9iamVjdC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBjb2xvciB0byBzZXQgZnJvbS4KICAgICAgICAgKi8KICAgICAgICBzZXRGcm9tT3RoZXIob3RoZXIpIHsKICAgICAgICAgICAgdGhpcy5yID0gb3RoZXIucjsKICAgICAgICAgICAgdGhpcy5nID0gb3RoZXIuZzsKICAgICAgICAgICAgdGhpcy5iID0gb3RoZXIuYjsKICAgICAgICAgICAgdGhpcy5hID0gb3RoZXIuYTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZyb20gYSBzY2FsYXIgYXJyYXkuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmFscyAtIFRoZSB2YWxzIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIHNldEZyb21TY2FsYXJBcnJheSh2YWxzKSB7CiAgICAgICAgICAgIHRoaXMuciA9IHZhbHNbMF07CiAgICAgICAgICAgIHRoaXMuZyA9IHZhbHNbMV07CiAgICAgICAgICAgIHRoaXMuYiA9IHZhbHNbMl07CiAgICAgICAgICAgIHRoaXMuYSA9IHZhbHMubGVuZ3RoID09IDQgPyB2YWxzWzNdIDogMS4wOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZnJvbSBhbiBSR0IgYXJyYXkuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXRBc1JHQkFycmF5KCkgewogICAgICAgICAgICByZXR1cm4gW3RoaXMuciAqIDI1NSwgdGhpcy5nICogMjU1LCB0aGlzLmIgKiAyNTVdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZnJvbSBhbiBSR0IgZGljdC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldEFzUkdCRGljdCgpIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIHI6IHRoaXMuciAqIDI1NSwKICAgICAgICAgICAgICAgIGc6IHRoaXMuZyAqIDI1NSwKICAgICAgICAgICAgICAgIGI6IHRoaXMuYiAqIDI1NSwKICAgICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZyb20gYSBSR0IgdmFsdWUuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gciAtIFRoZSByZWQgY2hhbm5lbC4KICAgICAgICAgKiBAcGFyYW0gZyAgLSBUaGUgZ3JlZW4gY2hhbm5lbC4KICAgICAgICAgKiBAcGFyYW0gYiAgLSBUaGUgYmx1ZSBjaGFubmVsLgogICAgICAgICAqIEBwYXJhbSBhICAtIFRoZSBhbHBoYSBjaGFubmVsLgogICAgICAgICAqLwogICAgICAgIHNldEZyb21SR0IociwgZywgYiwgYSkgewogICAgICAgICAgICB0aGlzLnIgPSByIC8gMjU1OwogICAgICAgICAgICB0aGlzLmcgPSBnIC8gMjU1OwogICAgICAgICAgICB0aGlzLmIgPSBiIC8gMjU1OwogICAgICAgICAgICB0aGlzLmEgPSBhID8gYSAvIDI1NSA6IDEuMDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZyb20gYW4gUkdCIGFycmF5LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbHMgLSBUaGUgdmFscyBwYXJhbS4KICAgICAgICAgKi8KICAgICAgICBzZXRGcm9tUkdCQXJyYXkodmFscykgewogICAgICAgICAgICB0aGlzLnIgPSB2YWxzWzBdIC8gMjU1OwogICAgICAgICAgICB0aGlzLmcgPSB2YWxzWzFdIC8gMjU1OwogICAgICAgICAgICB0aGlzLmIgPSB2YWxzWzJdIC8gMjU1OwogICAgICAgICAgICB0aGlzLmEgPSB2YWxzLmxlbmd0aCA9PSA0ID8gdmFsc1szXSAvIDI1NSA6IDEuMDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZyb20gYW4gUkdCIGRpY3QuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmFscyAtIFRoZSB2YWxzIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIHNldEZyb21SR0JEaWN0KHZhbHMpIHsKICAgICAgICAgICAgdGhpcy5yID0gdmFscy5yIC8gMjU1OwogICAgICAgICAgICB0aGlzLmcgPSB2YWxzLmcgLyAyNTU7CiAgICAgICAgICAgIHRoaXMuYiA9IHZhbHMuYiAvIDI1NTsKICAgICAgICAgICAgdGhpcy5hID0gdmFscy5hID09IDQgPyB2YWxzLmEgLyAyNTUgOiAxLjA7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmcm9tIGEgaGV4YWRlY2ltYWwgdmFsdWUuCiAgICAgICAgICogRS5nLiAjZmYwMDAwCiAgICAgICAgICogQHBhcmFtIGhleCAtIFRoZSBoZXggdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0RnJvbUhleChoZXgpIHsKICAgICAgICAgICAgZnVuY3Rpb24gaGV4VG9SZ2IoaGV4KSB7CiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSAvXiM/KFthLWZcZF17Mn0pKFthLWZcZF17Mn0pKFthLWZcZF17Mn0pJC9pLmV4ZWMoaGV4KTsKICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQKICAgICAgICAgICAgICAgICAgICA/IHsKICAgICAgICAgICAgICAgICAgICAgICAgcjogcGFyc2VJbnQocmVzdWx0WzFdLCAxNiksCiAgICAgICAgICAgICAgICAgICAgICAgIGc6IHBhcnNlSW50KHJlc3VsdFsyXSwgMTYpLAogICAgICAgICAgICAgICAgICAgICAgICBiOiBwYXJzZUludChyZXN1bHRbM10sIDE2KSwKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgOiBudWxsOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IHJnYiA9IGhleFRvUmdiKGhleCk7CiAgICAgICAgICAgIGlmICghcmdiKSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgaGV4IGNvZGU6JyArIGhleCk7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5zZXRGcm9tUkdCKHJnYi5yLCByZ2IuZywgcmdiLmIpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHRoZSBDb2xvciB2YWx1ZXMgZnJvbSBhIENTUyBjb2xvciBuYW1lLgogICAgICAgICAqIEUuZy4gInJlZCIKICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBDU1MgY29sb3IgbmFtZS4KICAgICAgICAgKi8KICAgICAgICBzZXRGcm9tQ1NTQ29sb3JOYW1lKG5hbWUpIHsKICAgICAgICAgICAgY29uc3QgY29sb3VyTmFtZVRvSGV4ID0gKGNvbG91cikgPT4gewogICAgICAgICAgICAgICAgY29uc3QgY29sb3JzID0gewogICAgICAgICAgICAgICAgICAgIGFsaWNlYmx1ZTogJyNmMGY4ZmYnLAogICAgICAgICAgICAgICAgICAgIGFudGlxdWV3aGl0ZTogJyNmYWViZDcnLAogICAgICAgICAgICAgICAgICAgIGFxdWE6ICcjMDBmZmZmJywKICAgICAgICAgICAgICAgICAgICBhcXVhbWFyaW5lOiAnIzdmZmZkNCcsCiAgICAgICAgICAgICAgICAgICAgYXp1cmU6ICcjZjBmZmZmJywKICAgICAgICAgICAgICAgICAgICBiZWlnZTogJyNmNWY1ZGMnLAogICAgICAgICAgICAgICAgICAgIGJpc3F1ZTogJyNmZmU0YzQnLAogICAgICAgICAgICAgICAgICAgIGJsYWNrOiAnIzAwMDAwMCcsCiAgICAgICAgICAgICAgICAgICAgYmxhbmNoZWRhbG1vbmQ6ICcjZmZlYmNkJywKICAgICAgICAgICAgICAgICAgICBibHVlOiAnIzAwMDBmZicsCiAgICAgICAgICAgICAgICAgICAgYmx1ZXZpb2xldDogJyM4YTJiZTInLAogICAgICAgICAgICAgICAgICAgIGJyb3duOiAnI2E1MmEyYScsCiAgICAgICAgICAgICAgICAgICAgYnVybHl3b29kOiAnI2RlYjg4NycsCiAgICAgICAgICAgICAgICAgICAgY2FkZXRibHVlOiAnIzVmOWVhMCcsCiAgICAgICAgICAgICAgICAgICAgY2hhcnRyZXVzZTogJyM3ZmZmMDAnLAogICAgICAgICAgICAgICAgICAgIGNob2NvbGF0ZTogJyNkMjY5MWUnLAogICAgICAgICAgICAgICAgICAgIGNvcmFsOiAnI2ZmN2Y1MCcsCiAgICAgICAgICAgICAgICAgICAgY29ybmZsb3dlcmJsdWU6ICcjNjQ5NWVkJywKICAgICAgICAgICAgICAgICAgICBjb3Juc2lsazogJyNmZmY4ZGMnLAogICAgICAgICAgICAgICAgICAgIGNyaW1zb246ICcjZGMxNDNjJywKICAgICAgICAgICAgICAgICAgICBjeWFuOiAnIzAwZmZmZicsCiAgICAgICAgICAgICAgICAgICAgZGFya2JsdWU6ICcjMDAwMDhiJywKICAgICAgICAgICAgICAgICAgICBkYXJrY3lhbjogJyMwMDhiOGInLAogICAgICAgICAgICAgICAgICAgIGRhcmtnb2xkZW5yb2Q6ICcjYjg4NjBiJywKICAgICAgICAgICAgICAgICAgICBkYXJrZ3JheTogJyNhOWE5YTknLAogICAgICAgICAgICAgICAgICAgIGRhcmtncmVlbjogJyMwMDY0MDAnLAogICAgICAgICAgICAgICAgICAgIGRhcmtraGFraTogJyNiZGI3NmInLAogICAgICAgICAgICAgICAgICAgIGRhcmttYWdlbnRhOiAnIzhiMDA4YicsCiAgICAgICAgICAgICAgICAgICAgZGFya29saXZlZ3JlZW46ICcjNTU2YjJmJywKICAgICAgICAgICAgICAgICAgICBkYXJrb3JhbmdlOiAnI2ZmOGMwMCcsCiAgICAgICAgICAgICAgICAgICAgZGFya29yY2hpZDogJyM5OTMyY2MnLAogICAgICAgICAgICAgICAgICAgIGRhcmtyZWQ6ICcjOGIwMDAwJywKICAgICAgICAgICAgICAgICAgICBkYXJrc2FsbW9uOiAnI2U5OTY3YScsCiAgICAgICAgICAgICAgICAgICAgZGFya3NlYWdyZWVuOiAnIzhmYmM4ZicsCiAgICAgICAgICAgICAgICAgICAgZGFya3NsYXRlYmx1ZTogJyM0ODNkOGInLAogICAgICAgICAgICAgICAgICAgIGRhcmtzbGF0ZWdyYXk6ICcjMmY0ZjRmJywKICAgICAgICAgICAgICAgICAgICBkYXJrdHVycXVvaXNlOiAnIzAwY2VkMScsCiAgICAgICAgICAgICAgICAgICAgZGFya3Zpb2xldDogJyM5NDAwZDMnLAogICAgICAgICAgICAgICAgICAgIGRlZXBwaW5rOiAnI2ZmMTQ5MycsCiAgICAgICAgICAgICAgICAgICAgZGVlcHNreWJsdWU6ICcjMDBiZmZmJywKICAgICAgICAgICAgICAgICAgICBkaW1ncmF5OiAnIzY5Njk2OScsCiAgICAgICAgICAgICAgICAgICAgZG9kZ2VyYmx1ZTogJyMxZTkwZmYnLAogICAgICAgICAgICAgICAgICAgIGZpcmVicmljazogJyNiMjIyMjInLAogICAgICAgICAgICAgICAgICAgIGZsb3JhbHdoaXRlOiAnI2ZmZmFmMCcsCiAgICAgICAgICAgICAgICAgICAgZm9yZXN0Z3JlZW46ICcjMjI4YjIyJywKICAgICAgICAgICAgICAgICAgICBmdWNoc2lhOiAnI2ZmMDBmZicsCiAgICAgICAgICAgICAgICAgICAgZ2FpbnNib3JvOiAnI2RjZGNkYycsCiAgICAgICAgICAgICAgICAgICAgZ2hvc3R3aGl0ZTogJyNmOGY4ZmYnLAogICAgICAgICAgICAgICAgICAgIGdvbGQ6ICcjZmZkNzAwJywKICAgICAgICAgICAgICAgICAgICBnb2xkZW5yb2Q6ICcjZGFhNTIwJywKICAgICAgICAgICAgICAgICAgICBncmF5OiAnIzgwODA4MCcsCiAgICAgICAgICAgICAgICAgICAgZ3JlZW46ICcjMDA4MDAwJywKICAgICAgICAgICAgICAgICAgICBncmVlbnllbGxvdzogJyNhZGZmMmYnLAogICAgICAgICAgICAgICAgICAgIGhvbmV5ZGV3OiAnI2YwZmZmMCcsCiAgICAgICAgICAgICAgICAgICAgaG90cGluazogJyNmZjY5YjQnLAogICAgICAgICAgICAgICAgICAgICdpbmRpYW5yZWQgJzogJyNjZDVjNWMnLAogICAgICAgICAgICAgICAgICAgIGluZGlnbzogJyM0YjAwODInLAogICAgICAgICAgICAgICAgICAgIGl2b3J5OiAnI2ZmZmZmMCcsCiAgICAgICAgICAgICAgICAgICAga2hha2k6ICcjZjBlNjhjJywKICAgICAgICAgICAgICAgICAgICBsYXZlbmRlcjogJyNlNmU2ZmEnLAogICAgICAgICAgICAgICAgICAgIGxhdmVuZGVyYmx1c2g6ICcjZmZmMGY1JywKICAgICAgICAgICAgICAgICAgICBsYXduZ3JlZW46ICcjN2NmYzAwJywKICAgICAgICAgICAgICAgICAgICBsZW1vbmNoaWZmb246ICcjZmZmYWNkJywKICAgICAgICAgICAgICAgICAgICBsaWdodGJsdWU6ICcjYWRkOGU2JywKICAgICAgICAgICAgICAgICAgICBsaWdodGNvcmFsOiAnI2YwODA4MCcsCiAgICAgICAgICAgICAgICAgICAgbGlnaHRjeWFuOiAnI2UwZmZmZicsCiAgICAgICAgICAgICAgICAgICAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6ICcjZmFmYWQyJywKICAgICAgICAgICAgICAgICAgICBsaWdodGdyZXk6ICcjZDNkM2QzJywKICAgICAgICAgICAgICAgICAgICBsaWdodGdyZWVuOiAnIzkwZWU5MCcsCiAgICAgICAgICAgICAgICAgICAgbGlnaHRwaW5rOiAnI2ZmYjZjMScsCiAgICAgICAgICAgICAgICAgICAgbGlnaHRzYWxtb246ICcjZmZhMDdhJywKICAgICAgICAgICAgICAgICAgICBsaWdodHNlYWdyZWVuOiAnIzIwYjJhYScsCiAgICAgICAgICAgICAgICAgICAgbGlnaHRza3libHVlOiAnIzg3Y2VmYScsCiAgICAgICAgICAgICAgICAgICAgbGlnaHRzbGF0ZWdyYXk6ICcjNzc4ODk5JywKICAgICAgICAgICAgICAgICAgICBsaWdodHN0ZWVsYmx1ZTogJyNiMGM0ZGUnLAogICAgICAgICAgICAgICAgICAgIGxpZ2h0eWVsbG93OiAnI2ZmZmZlMCcsCiAgICAgICAgICAgICAgICAgICAgbGltZTogJyMwMGZmMDAnLAogICAgICAgICAgICAgICAgICAgIGxpbWVncmVlbjogJyMzMmNkMzInLAogICAgICAgICAgICAgICAgICAgIGxpbmVuOiAnI2ZhZjBlNicsCiAgICAgICAgICAgICAgICAgICAgbWFnZW50YTogJyNmZjAwZmYnLAogICAgICAgICAgICAgICAgICAgIG1hcm9vbjogJyM4MDAwMDAnLAogICAgICAgICAgICAgICAgICAgIG1lZGl1bWFxdWFtYXJpbmU6ICcjNjZjZGFhJywKICAgICAgICAgICAgICAgICAgICBtZWRpdW1ibHVlOiAnIzAwMDBjZCcsCiAgICAgICAgICAgICAgICAgICAgbWVkaXVtb3JjaGlkOiAnI2JhNTVkMycsCiAgICAgICAgICAgICAgICAgICAgbWVkaXVtcHVycGxlOiAnIzkzNzBkOCcsCiAgICAgICAgICAgICAgICAgICAgbWVkaXVtc2VhZ3JlZW46ICcjM2NiMzcxJywKICAgICAgICAgICAgICAgICAgICBtZWRpdW1zbGF0ZWJsdWU6ICcjN2I2OGVlJywKICAgICAgICAgICAgICAgICAgICBtZWRpdW1zcHJpbmdncmVlbjogJyMwMGZhOWEnLAogICAgICAgICAgICAgICAgICAgIG1lZGl1bXR1cnF1b2lzZTogJyM0OGQxY2MnLAogICAgICAgICAgICAgICAgICAgIG1lZGl1bXZpb2xldHJlZDogJyNjNzE1ODUnLAogICAgICAgICAgICAgICAgICAgIG1pZG5pZ2h0Ymx1ZTogJyMxOTE5NzAnLAogICAgICAgICAgICAgICAgICAgIG1pbnRjcmVhbTogJyNmNWZmZmEnLAogICAgICAgICAgICAgICAgICAgIG1pc3R5cm9zZTogJyNmZmU0ZTEnLAogICAgICAgICAgICAgICAgICAgIG1vY2Nhc2luOiAnI2ZmZTRiNScsCiAgICAgICAgICAgICAgICAgICAgbmF2YWpvd2hpdGU6ICcjZmZkZWFkJywKICAgICAgICAgICAgICAgICAgICBuYXZ5OiAnIzAwMDA4MCcsCiAgICAgICAgICAgICAgICAgICAgb2xkbGFjZTogJyNmZGY1ZTYnLAogICAgICAgICAgICAgICAgICAgIG9saXZlOiAnIzgwODAwMCcsCiAgICAgICAgICAgICAgICAgICAgb2xpdmVkcmFiOiAnIzZiOGUyMycsCiAgICAgICAgICAgICAgICAgICAgb3JhbmdlOiAnI2ZmYTUwMCcsCiAgICAgICAgICAgICAgICAgICAgb3JhbmdlcmVkOiAnI2ZmNDUwMCcsCiAgICAgICAgICAgICAgICAgICAgb3JjaGlkOiAnI2RhNzBkNicsCiAgICAgICAgICAgICAgICAgICAgcGFsZWdvbGRlbnJvZDogJyNlZWU4YWEnLAogICAgICAgICAgICAgICAgICAgIHBhbGVncmVlbjogJyM5OGZiOTgnLAogICAgICAgICAgICAgICAgICAgIHBhbGV0dXJxdW9pc2U6ICcjYWZlZWVlJywKICAgICAgICAgICAgICAgICAgICBwYWxldmlvbGV0cmVkOiAnI2Q4NzA5MycsCiAgICAgICAgICAgICAgICAgICAgcGFwYXlhd2hpcDogJyNmZmVmZDUnLAogICAgICAgICAgICAgICAgICAgIHBlYWNocHVmZjogJyNmZmRhYjknLAogICAgICAgICAgICAgICAgICAgIHBlcnU6ICcjY2Q4NTNmJywKICAgICAgICAgICAgICAgICAgICBwaW5rOiAnI2ZmYzBjYicsCiAgICAgICAgICAgICAgICAgICAgcGx1bTogJyNkZGEwZGQnLAogICAgICAgICAgICAgICAgICAgIHBvd2RlcmJsdWU6ICcjYjBlMGU2JywKICAgICAgICAgICAgICAgICAgICBwdXJwbGU6ICcjODAwMDgwJywKICAgICAgICAgICAgICAgICAgICByZWJlY2NhcHVycGxlOiAnIzY2MzM5OScsCiAgICAgICAgICAgICAgICAgICAgcmVkOiAnI2ZmMDAwMCcsCiAgICAgICAgICAgICAgICAgICAgcm9zeWJyb3duOiAnI2JjOGY4ZicsCiAgICAgICAgICAgICAgICAgICAgcm95YWxibHVlOiAnIzQxNjllMScsCiAgICAgICAgICAgICAgICAgICAgc2FkZGxlYnJvd246ICcjOGI0NTEzJywKICAgICAgICAgICAgICAgICAgICBzYWxtb246ICcjZmE4MDcyJywKICAgICAgICAgICAgICAgICAgICBzYW5keWJyb3duOiAnI2Y0YTQ2MCcsCiAgICAgICAgICAgICAgICAgICAgc2VhZ3JlZW46ICcjMmU4YjU3JywKICAgICAgICAgICAgICAgICAgICBzZWFzaGVsbDogJyNmZmY1ZWUnLAogICAgICAgICAgICAgICAgICAgIHNpZW5uYTogJyNhMDUyMmQnLAogICAgICAgICAgICAgICAgICAgIHNpbHZlcjogJyNjMGMwYzAnLAogICAgICAgICAgICAgICAgICAgIHNreWJsdWU6ICcjODdjZWViJywKICAgICAgICAgICAgICAgICAgICBzbGF0ZWJsdWU6ICcjNmE1YWNkJywKICAgICAgICAgICAgICAgICAgICBzbGF0ZWdyYXk6ICcjNzA4MDkwJywKICAgICAgICAgICAgICAgICAgICBzbm93OiAnI2ZmZmFmYScsCiAgICAgICAgICAgICAgICAgICAgc3ByaW5nZ3JlZW46ICcjMDBmZjdmJywKICAgICAgICAgICAgICAgICAgICBzdGVlbGJsdWU6ICcjNDY4MmI0JywKICAgICAgICAgICAgICAgICAgICB0YW46ICcjZDJiNDhjJywKICAgICAgICAgICAgICAgICAgICB0ZWFsOiAnIzAwODA4MCcsCiAgICAgICAgICAgICAgICAgICAgdGhpc3RsZTogJyNkOGJmZDgnLAogICAgICAgICAgICAgICAgICAgIHRvbWF0bzogJyNmZjYzNDcnLAogICAgICAgICAgICAgICAgICAgIHR1cnF1b2lzZTogJyM0MGUwZDAnLAogICAgICAgICAgICAgICAgICAgIHZpb2xldDogJyNlZTgyZWUnLAogICAgICAgICAgICAgICAgICAgIHdoZWF0OiAnI2Y1ZGViMycsCiAgICAgICAgICAgICAgICAgICAgd2hpdGU6ICcjZmZmZmZmJywKICAgICAgICAgICAgICAgICAgICB3aGl0ZXNtb2tlOiAnI2Y1ZjVmNScsCiAgICAgICAgICAgICAgICAgICAgeWVsbG93OiAnI2ZmZmYwMCcsCiAgICAgICAgICAgICAgICAgICAgeWVsbG93Z3JlZW46ICcjOWFjZDMyJywKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICByZXR1cm4gY29sb3JzW2NvbG91ci50b0xvd2VyQ2FzZSgpXTsKICAgICAgICAgICAgICAgIC8vICBpZiAodHlwZW9mIGNvbG9yc1tjb2xvdXIudG9Mb3dlckNhc2UoKV0gIT0gJ3VuZGVmaW5lZCcpIHJldHVybiBjb2xvcnNbY29sb3VyLnRvTG93ZXJDYXNlKCldCiAgICAgICAgICAgICAgICAvLyByZXR1cm4gZmFsc2UKICAgICAgICAgICAgfTsKICAgICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnIycpKSB7CiAgICAgICAgICAgICAgICB0aGlzLnNldEZyb21IZXgobmFtZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBjb25zdCBoZXhDb2xvciA9IGNvbG91ck5hbWVUb0hleChuYW1lKTsKICAgICAgICAgICAgICAgIGlmIChoZXhDb2xvcikKICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEZyb21IZXgoaGV4Q29sb3IpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIGhleGFkZWNpbWFsIHZhbHVlIG9mIHRoaXMgY29sb3IsIGluY2x1ZGluZyB0aGUgbGVhZGluZyAiIyIgY2hhcmFjdGVyLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGhleCB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICB0b0hleCgpIHsKICAgICAgICAgICAgZnVuY3Rpb24gY29tcG9uZW50VG9IZXgoYykgewogICAgICAgICAgICAgICAgY29uc3QgaW50ID0gTWF0aC5yb3VuZChjICogMjU1KTsKICAgICAgICAgICAgICAgIGNvbnN0IGhleCA9IGludC50b1N0cmluZygxNik7CiAgICAgICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PSAxID8gJzAnICsgaGV4IDogaGV4OwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiAnIycgKyBjb21wb25lbnRUb0hleCh0aGlzLnIpICsgY29tcG9uZW50VG9IZXgodGhpcy5nKSArIGNvbXBvbmVudFRvSGV4KHRoaXMuYik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENoZWNrcyBpZiB0aGlzIENvbG9yICBjb250YWlucyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlIG90aGVyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIENvbG9yIHRvIGNvbXBhcmUgd2l0aC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgdGhlIHNhbWUsIG90aGVyd2lzZSwgYGZhbHNlYC4KICAgICAgICAgKi8KICAgICAgICBpc0VxdWFsKG90aGVyKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnIgPT0gb3RoZXIuciAmJiB0aGlzLmcgPT0gb3RoZXIuZyAmJiB0aGlzLmIgPT0gb3RoZXIuYiAmJiB0aGlzLmEgPT0gb3RoZXIuYTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY29sb3IgaXMgTk9UIGV4YWN0bHkgdGhlIHNhbWUgYXMgb3RoZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgY29sb3IgdG8gY29tcGFyZSB3aXRoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuCiAgICAgICAgICovCiAgICAgICAgbm90RXF1YWxzKG90aGVyKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnIgIT0gb3RoZXIuciAmJiB0aGlzLmcgIT0gb3RoZXIuZyAmJiB0aGlzLmIgIT0gb3RoZXIuYiAmJiB0aGlzLmEgIT0gb3RoZXIuYTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY29sb3IgaXMgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBhcyBvdGhlci4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBjb2xvciB0byBjb21wYXJlIHdpdGguCiAgICAgICAgICogQHBhcmFtIHByZWNpc2lvbiAtIFRoZSBwcmVjaXNpb24gdG8gd2hpY2ggdGhlIHZhbHVlcyBtdXN0IG1hdGNoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuCiAgICAgICAgICovCiAgICAgICAgYXBwcm94RXF1YWwob3RoZXIsIHByZWNpc2lvbiA9IE51bWJlci5FUFNJTE9OKSB7CiAgICAgICAgICAgIHJldHVybiAoTWF0aC5hYnModGhpcy5yIC0gb3RoZXIucikgPCBwcmVjaXNpb24gJiYKICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMuZyAtIG90aGVyLmcpIDwgcHJlY2lzaW9uICYmCiAgICAgICAgICAgICAgICBNYXRoLmFicyh0aGlzLmIgLSBvdGhlci5iKSA8IHByZWNpc2lvbiAmJgogICAgICAgICAgICAgICAgTWF0aC5hYnModGhpcy5hIC0gb3RoZXIuYSkgPCBwcmVjaXNpb24pOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIGEgbmV3IENvbG9yIHdoaWNoIGlzIHRoaXMgQ29sb3IgYWRkZWQgdG8gb3RoZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgY29sb3IgdG8gYWRkLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IGNvbG9yLgogICAgICAgICAqLwogICAgICAgIGFkZChvdGhlcikgewogICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMuciArIG90aGVyLnIsIHRoaXMuZyArIG90aGVyLmcsIHRoaXMuYiArIG90aGVyLmIsIHRoaXMuYSArIG90aGVyLmEpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBVcGRhdGVzIHRoaXMgQ29sb3IgYnkgYWRkaW5nIHRoZSB2YWx1ZXMgZnJvbSB0aGUgb3RoZXIgY29sb3IuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgY29sb3IgdG8gYWRkLgogICAgICAgICAqLwogICAgICAgIGFkZEluUGxhY2Uob3RoZXIpIHsKICAgICAgICAgICAgdGhpcy5yICs9IG90aGVyLnI7CiAgICAgICAgICAgIHRoaXMuZyArPSBvdGhlci5nOwogICAgICAgICAgICB0aGlzLmIgKz0gb3RoZXIuYjsKICAgICAgICAgICAgdGhpcy5hICs9IG90aGVyLmE7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgYSBuZXcgY29sb3Igd2hpY2ggaXMgdGhpcyBjb2xvciBzdWJ0cmFjdGVkIGZyb20gb3RoZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgY29sb3IgdG8gc3VidHJhY3QuCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgY29sb3IuCiAgICAgICAgICovCiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnIgLSBvdGhlci5yLCB0aGlzLmcgLSBvdGhlci5nLCB0aGlzLmIgLSBvdGhlci5iLCB0aGlzLmEgLSBvdGhlci5hKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2NhbGVzIHRoaXMgY29sb3IgYnkgc2NhbGFyIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWM0LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUuCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgY29sb3IuCiAgICAgICAgICovCiAgICAgICAgc2NhbGUoc2NhbGFyKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yICogc2NhbGFyLCB0aGlzLmcgKiBzY2FsYXIsIHRoaXMuYiAqIHNjYWxhciwgdGhpcy5hICogc2NhbGFyKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2NhbGVzIHRoaXMgY29sb3IgYnkgc2NhbGFyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHNjYWxhciAtIFRoZSBzY2FsYXIgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2NhbGVJblBsYWNlKHNjYWxhcikgewogICAgICAgICAgICB0aGlzLnIgKj0gc2NhbGFyOwogICAgICAgICAgICB0aGlzLmcgKj0gc2NhbGFyOwogICAgICAgICAgICB0aGlzLmIgKj0gc2NhbGFyOwogICAgICAgICAgICB0aGlzLmEgKj0gc2NhbGFyOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBBcHBseSBnYW1tYSBjb3JyZWN0aW9uIHRvIHRoaXMgY29sb3IKICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBnYW1tYSAtIFRoZSBnYW1tYSB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBhcHBseUdhbW1hKGdhbW1hKSB7CiAgICAgICAgICAgIHRoaXMuc2V0KE1hdGgucG93KHRoaXMuciwgZ2FtbWEpLCBNYXRoLnBvdyh0aGlzLmcsIGdhbW1hKSwgTWF0aC5wb3codGhpcy5iLCBnYW1tYSksIHRoaXMuYSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENvbnZlcnRzIHRvIGxpbmVhciBjb2xvciBzcGFjZSBhbmQgcmV0dXJucyBhIG5ldyBjb2xvcgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIGdhbW1hIC0gVGhlIGdhbW1hIHZhbHVlLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IGNvbG9yLgogICAgICAgICAqLwogICAgICAgIHRvTGluZWFyKGdhbW1hID0gMi4yKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IoTWF0aC5wb3codGhpcy5yLCBnYW1tYSksIE1hdGgucG93KHRoaXMuZywgZ2FtbWEpLCBNYXRoLnBvdyh0aGlzLmIsIGdhbW1hKSwgdGhpcy5hKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogcmV0dXJucyBhIG5ldyBjb2xvciB2YWx1ZSB2YWx1ZSBpcyBtYXBwZWQgaW50byBhIGdhbW1hIGN1cnZlCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gZ2FtbWEgLSBUaGUgZ2FtbWEgdmFsdWUuCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgY29sb3IuCiAgICAgICAgICovCiAgICAgICAgdG9HYW1tYShnYW1tYSA9IDIuMikgewogICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKE1hdGgucG93KHRoaXMuciwgMS4wIC8gZ2FtbWEpLCBNYXRoLnBvdyh0aGlzLmcsIDEuMCAvIGdhbW1hKSwgTWF0aC5wb3codGhpcy5iLCAxLjAgLyBnYW1tYSksIHRoaXMuYSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENhbGN1bGF0ZXMgYW5kIHJldHVybnMgdGhlIGx1bWluYW5jZSBvZiB0aGUgbGluZWFyIFJHQiBjb21wb25lbnRzLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgbHVtaW5hbmNlKCkgewogICAgICAgICAgICByZXR1cm4gMC4yMTI2ICogdGhpcy5yICsgMC43MTUyICogdGhpcy5nICsgMC4wNzIyICogdGhpcy5iOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdGhpcyBjb2xvciBhbmQgb3RoZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgY29sb3IgdG8gaW50ZXJwb2xhdGUgYmV0d2Vlbi4KICAgICAgICAgKiBAcGFyYW0gdCAtIEludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHMuCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgY29sb3IuCiAgICAgICAgICovCiAgICAgICAgbGVycChvdGhlciwgdCkgewogICAgICAgICAgICBjb25zdCBhciA9IHRoaXMucjsKICAgICAgICAgICAgY29uc3QgYWcgPSB0aGlzLmc7CiAgICAgICAgICAgIGNvbnN0IGFiID0gdGhpcy5iOwogICAgICAgICAgICBjb25zdCBhYSA9IHRoaXMuYTsKICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihhciArIHQgKiAob3RoZXIuciAtIGFyKSwgYWcgKyB0ICogKG90aGVyLmcgLSBhZyksIGFiICsgdCAqIChvdGhlci5iIC0gYWIpLCBhYSArIHQgKiAob3RoZXIuYSAtIGFhKSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZXMgYSByYW5kb20gY29sb3IuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gZ2FtbWFPZmZzZXQgLSBUaGUgZ2FtbWEgb2Zmc2V0LiBWYWx1ZXMgYmV0d2VlbiAwIGFuZCAxIGluY3JlYXNlIHRoZSBhdmVyYWdlIGJyaWdodG5lc3Mgb2YgdGhlIGdlbmVyYXRlZCBjb2xvci4gVmFsdWVzIGJldHdlZW4gMCBhbmQgLTEgZGFya2VuIHRoZSBnZW5lcmF0ZWQgY29sb3IgdmFsdWVzLgogICAgICAgICAqIEBwYXJhbSByYW5kb21BbHBoYSAtIERldGVybWluZXMgd2hldGhlciB0aGUgYWxwaGEgY2hhbm5lbCBpcyByYW5kb20uIElmIG5vdCwgdGhlIGFscGhhIHZhbHVlcyB3aWxsIGJlIDEuMC4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIG5ldyByYW5kb20gY29sb3IuCiAgICAgICAgICovCiAgICAgICAgc3RhdGljIHJhbmRvbShnYW1tYU9mZnNldCA9IDAuMCwgcmFuZG9tQWxwaGEgPSBmYWxzZSkgewogICAgICAgICAgICBpZiAoZ2FtbWFPZmZzZXQgPiAwLjApIHsKICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IoZ2FtbWFPZmZzZXQgKyBNYXRoLnJhbmRvbSgpICogKDEuMCAtIGdhbW1hT2Zmc2V0KSwgZ2FtbWFPZmZzZXQgKyBNYXRoLnJhbmRvbSgpICogKDEuMCAtIGdhbW1hT2Zmc2V0KSwgZ2FtbWFPZmZzZXQgKyBNYXRoLnJhbmRvbSgpICogKDEuMCAtIGdhbW1hT2Zmc2V0KSwgcmFuZG9tQWxwaGEgPyBnYW1tYU9mZnNldCArIE1hdGgucmFuZG9tKCkgKiAoMS4wIC0gZ2FtbWFPZmZzZXQpIDogMS4wKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZ2FtbWFPZmZzZXQgPCAwLjApIHsKICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IoTWF0aC5yYW5kb20oKSAqICgxLjAgKyBnYW1tYU9mZnNldCksIE1hdGgucmFuZG9tKCkgKiAoMS4wICsgZ2FtbWFPZmZzZXQpLCBNYXRoLnJhbmRvbSgpICogKDEuMCArIGdhbW1hT2Zmc2V0KSwgcmFuZG9tQWxwaGEgPyBNYXRoLnJhbmRvbSgpICogKDEuMCArIGdhbW1hT2Zmc2V0KSA6IDEuMCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpLCByYW5kb21BbHBoYSA/IE1hdGgucmFuZG9tKCkgOiAxLjApOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDbG9uZXMgdGhpcyBjb2xvciBhbmQgcmV0dXJucyBhIG5ldyBjb2xvci4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IGNvbG9yLgogICAgICAgICAqLwogICAgICAgIGNsb25lKCkgewogICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMuX19kYXRhWzBdLCB0aGlzLl9fZGF0YVsxXSwgdGhpcy5fX2RhdGFbMl0sIHRoaXMuX19kYXRhWzNdKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0aGUgdHlwZSBhcyBhbiBhcnJheS4gT2Z0ZW4gdXNlZCB0byBwYXNzIHR5cGVzIHRvIHRoZSBHUFUuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhcyBhbiBhcnJheS4KICAgICAgICAgKi8KICAgICAgICBhc0FycmF5KCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGE7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIHR5cGUgYXMgYSAzIGNvbXBvbmVudCBhcnJheS4gT2Z0ZW4gdXNlZCB0byBwYXNzIHR5cGVzIHRvIHRoZSBHUFUuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhcyBhIDMgY29tcG9uZW50IGFycmF5LgogICAgICAgICAqIEBwcml2YXRlCiAgICAgICAgICovCiAgICAgICAgYXMzQ29tcG9uZW50QXJyYXkoKSB7CiAgICAgICAgICAgIHJldHVybiBbdGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXV07CiAgICAgICAgfQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8KICAgICAgICAvLyBQZXJzaXN0ZW5jZQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSBqc29uIG9iamVjdC4KICAgICAgICAgKi8KICAgICAgICB0b0pTT04oKSB7CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICByOiB0aGlzLnIsCiAgICAgICAgICAgICAgICBnOiB0aGlzLmcsCiAgICAgICAgICAgICAgICBiOiB0aGlzLmIsCiAgICAgICAgICAgICAgICBhOiB0aGlzLmEsCiAgICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gaiAtIFRoZSBqc29uIG9iamVjdC4KICAgICAgICAgKi8KICAgICAgICBmcm9tSlNPTihqKSB7CiAgICAgICAgICAgIHRoaXMuciA9IGoucjsKICAgICAgICAgICAgdGhpcy5nID0gai5nOwogICAgICAgICAgICB0aGlzLmIgPSBqLmI7CiAgICAgICAgICAgIHRoaXMuYSA9IGouYTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogTG9hZHMgdGhlIHN0YXRlIG9mIHRoZSB2YWx1ZSBmcm9tIGEgYmluYXJ5IHJlYWRlci4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHJlYWRCaW5hcnkocmVhZGVyKSB7CiAgICAgICAgICAgIHRoaXMuciA9IHJlYWRlci5sb2FkRmxvYXQzMigpOwogICAgICAgICAgICB0aGlzLmcgPSByZWFkZXIubG9hZEZsb2F0MzIoKTsKICAgICAgICAgICAgdGhpcy5iID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7CiAgICAgICAgICAgIHRoaXMuYSA9IHJlYWRlci5sb2FkRmxvYXQzMigpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRoZSBDU1MgcmdiYSBzdHJpbmcuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICB0b0NTU1N0cmluZygpIHsKICAgICAgICAgICAgcmV0dXJuICgncmdiYSgnICsKICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5yICogMjU1KSArCiAgICAgICAgICAgICAgICAnLCAnICsKICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5nICogMjU1KSArCiAgICAgICAgICAgICAgICAnLCAnICsKICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGhpcy5iICogMjU1KSArCiAgICAgICAgICAgICAgICAnLCAnICsKICAgICAgICAgICAgICAgIHRoaXMuYSArCiAgICAgICAgICAgICAgICAnKScpOwogICAgICAgIH0KICAgIH0KCiAgICAvKioKICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBldWxlciBhbmdsZXMuIEV1bGVyIGFuZ2xlcyBkZXNjcmliZSByb3RhdGluZyBhbiBvYmplY3QKICAgICAqIGFyb3VuZCBpdHMgdmFyaW91cyBheGlzIGluIGEgc3BlY2lmaWVkIGF4aXMgb3JkZXIuCiAgICAgKgogICAgICovCiAgICBjbGFzcyBFdWxlckFuZ2xlcyB7CiAgICAgICAgLyoqCiAgICAgICAgICogQ3JlYXRlIGEgZXVsZXIgYW5nbGUuIFJlY2VpdmVzIHRoZSB4eXogdmFsdWVzIGluIHJhZGlhbnMgYW5kIHRoZSBvcmRlciB0aGF0IHRoZSByb3RhdGlvbnMgYXJlIGFwcGxpZWQuCiAgICAgICAgICoKICAgICAgICAgKiBPcmRlciBwYXJhbWV0ZXIgdmFsdWVzOiBgWFlaOiAwYCwgYFlaWDogMWAsIGBaWFk6IDJgLCBgWFpZOiAzYCwgYFpZWDogNGAsIGBZWFo6IDVgCiAgICAgICAgICoKICAgICAgICAgKiBJdCBjb3VsZCBiZSBlaXRoZXIgdGhlIGBzdHJpbmdgIG9yIHRoZSBgbnVtYmVyYCB2YWx1ZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB4IC0gVGhlIGFuZ2xlIG9mIHRoZSB4IGF4aXMgaW4gZGVncmVlcy4gRGVmYXVsdCBpcyAwLgogICAgICAgICAqIEBwYXJhbSB5IC0gVGhlIGFuZ2xlIG9mIHRoZSB5IGF4aXMgaW4gZGVncmVlcy4gRGVmYXVsdCBpcyAwLgogICAgICAgICAqIEBwYXJhbSB6IC0gVGhlIGFuZ2xlIG9mIHRoZSB6IGF4aXMgaW4gZGVncmVlcy4gRGVmYXVsdCBpcyAwLgogICAgICAgICAqIEBwYXJhbSBvcmRlciAtIFRoZSBvcmRlciBpbiB3aGljaCB0aGUgcm90YXRpb25zIGFyZSBhcHBsaWVkLgogICAgICAgICAqLwogICAgICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDAsIG9yZGVyID0gMCkgewogICAgICAgICAgICBpZiAodHlwZW9mIG9yZGVyID09PSAnbnVtYmVyJyAmJiAhaXNOYU4ob3JkZXIpKQogICAgICAgICAgICAgICAgdGhpcy5vcmRlciA9IG9yZGVyOwogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHN3aXRjaCAob3JkZXIpIHsKICAgICAgICAgICAgICAgICAgICBjYXNlICdYWVonOgogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9yZGVyID0gMDsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWVpYJzoKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmRlciA9IDE7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNhc2UgJ1pYWSc6CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3JkZXIgPSAyOwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICBjYXNlICdYWlknOgogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9yZGVyID0gMzsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgY2FzZSAnWllYJzoKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcmRlciA9IDQ7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNhc2UgJ1lYWic6CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3JkZXIgPSA1OwogICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgRXVsZXIgQW5nbGVzIE9yZGVyOicgKyBvcmRlcik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHggaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgewogICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0geDsKICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSB5OwogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVswXSA9IHg7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVsxXSA9IHk7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVsyXSA9IHo7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2V0dGVyIGZvciB4IGF4aXMgcm90YXRpb24uCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgeCBheGlzIHJvdGF0aW9uLgogICAgICAgICAqLwogICAgICAgIGdldCB4KCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbMF07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3IgeCBheGlzIHJvdGF0aW9uLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IHgodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzBdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIHkgYXhpcyByb3RhdGlvbi4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSB5IGF4aXMgcm90YXRpb24uCiAgICAgICAgICovCiAgICAgICAgZ2V0IHkoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVsxXTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZvciB5IGF4aXMgcm90YXRpb24uCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmFsIC0gVGhlIHZhbCBwYXJhbS4KICAgICAgICAgKi8KICAgICAgICBzZXQgeSh2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMV0gPSB2YWw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3IgeiBheGlzIHJvdGF0aW9uLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIHogYXhpcyByb3RhdGlvbi4KICAgICAgICAgKi8KICAgICAgICBnZXQgeigpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzJdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIHogYXhpcyByb3RhdGlvbi4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIHNldCB6KHZhbCkgewogICAgICAgICAgICB0aGlzLl9fZGF0YVsyXSA9IHZhbDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyB0aGUgRXVsZXJBbmdsZXMKICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB4IC0gVGhlIHggYXhpcyByb3RhdGlvbiBpbiByYWRpYW5zLgogICAgICAgICAqIEBwYXJhbSB5IC0gVGhlIHkgYXhpcyByb3RhdGlvbiBpbiByYWRpYW5zLgogICAgICAgICAqIEBwYXJhbSB6IC0gVGhlIHogYXhpcyByb3RhdGlvbiBpbiByYWRpYW5zLgogICAgICAgICAqLwogICAgICAgIHNldCh4LCB5LCB6KSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzBdID0geDsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMV0gPSB5OwogICAgICAgICAgICB0aGlzLl9fZGF0YVsyXSA9IHo7CiAgICAgICAgfQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogICAgICAgIC8vIFBlcnNpc3RlbmNlCiAgICAgICAgLyoqCiAgICAgICAgICogQ29udmVydHMgdGhpcyBWZWMzIHRvIGEgc3RyaW5nIGluIEpTT04gZm9ybWF0LgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgdG9TdHJpbmcoKSB7CiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwCiAgICAgICAgICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKTsKICAgICAgICB9CiAgICAgICAgdG9KU09OKCkgewogICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgeDogdGhpcy5fX2RhdGFbMF0sCiAgICAgICAgICAgICAgICB5OiB0aGlzLl9fZGF0YVsxXSwKICAgICAgICAgICAgICAgIHo6IHRoaXMuX19kYXRhWzJdLAogICAgICAgICAgICAgICAgb3JkZXI6IHRoaXMub3JkZXIsCiAgICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIGZyb21KU09OKGpzb24pIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMF0gPSBqc29uLng7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzFdID0ganNvbi55OwogICAgICAgICAgICB0aGlzLl9fZGF0YVsyXSA9IGpzb24uejsKICAgICAgICAgICAgdGhpcy5vcmRlciA9IGpzb24ub3JkZXI7CiAgICAgICAgfQogICAgfQoKICAgIC8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi8KICAgIC8qKgogICAgICogQSBjbGFzcyByZXByZXNlbnRpbmcgYSAzeDMgbWF0cml4LgogICAgICogVGhpcyBtYXRyaXggY2xhc3MgaXMgYmFzZWQgb24gR0xNLCBhbmQgaXMgY29sdW1uIG1ham9yLgogICAgICoKICAgICAqLwogICAgY2xhc3MgTWF0MyB7CiAgICAgICAgLyoqCiAgICAgICAgICogSW5pdGlhbGl6ZXMgdGhlIE1hdDMgY2xhc3Mgd2l0aCBnaXZlbiBkYXRhLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG0wMCAtIFJvdyAwLCBjb2x1bW4gMC4KICAgICAgICAgKiBAcGFyYW0gbTAxIC0gUm93IDAsIGNvbHVtbiAxLgogICAgICAgICAqIEBwYXJhbSBtMDIgLSBSb3cgMCwgY29sdW1uIDIuCiAgICAgICAgICogQHBhcmFtIG0xMCAtIFJvdyAxLCBjb2x1bW4gMC4KICAgICAgICAgKiBAcGFyYW0gbTExIC0gUm93IDEsIGNvbHVtbiAxLgogICAgICAgICAqIEBwYXJhbSBtMTIgLSBSb3cgMSwgY29sdW1uIDIuCiAgICAgICAgICogQHBhcmFtIG0yMCAtIFJvdyAyLCBjb2x1bW4gMC4KICAgICAgICAgKiBAcGFyYW0gbTIxIC0gUm93IDIsIGNvbHVtbiAxLgogICAgICAgICAqIEBwYXJhbSBtMjIgLSBSb3cgMiwgY29sdW1uIDIuCiAgICAgICAgICovCiAgICAgICAgY29uc3RydWN0b3IobTAwID0gMSwgbTAxID0gMCwgbTAyID0gMCwgbTEwID0gMCwgbTExID0gMSwgbTEyID0gMCwgbTIwID0gMCwgbTIxID0gMCwgbTIyID0gMSkgewogICAgICAgICAgICBpZiAobTAwIGluc3RhbmNlb2YgVmVjMyAmJiBtMDEgaW5zdGFuY2VvZiBWZWMzICYmIG0wMiBpbnN0YW5jZW9mIFZlYzMpIHsKICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheSg5KTsKICAgICAgICAgICAgICAgIHRoaXMuc2V0KG0wMC54LCBtMDAueSwgbTAwLnosIG0wMS54LCBtMDEueSwgbTAxLnosIG0wMi54LCBtMDIueSwgbTAyLnopOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgaWYgKG0wMCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSkgewogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGEgPSBtMDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSBpZiAobTAwIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBuZXcgVmVjMyhuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgOSkpYCk7CiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBtMDA7CiAgICAgICAgICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gbTAxOwogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgOSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7CiAgICAgICAgICAgICAgICB0aGlzLnNldChtMDAsIG0wMSwgbTAyLCBtMTAsIG0xMSwgbTEyLCBtMjAsIG0yMSwgbTIyKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogICAgICAgIC8vIHByb3BlcnRpZXMKICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIHJvdyAwLCBjb2x1bW4gMC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgbTAwIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldCBtMDAoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVswXTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDAuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmFsIC0gVGhlIHZhbCBwYXJhbS4KICAgICAgICAgKi8KICAgICAgICBzZXQgbTAwKHZhbCkgewogICAgICAgICAgICB0aGlzLl9fZGF0YVswXSA9IHZhbDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDEuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgbTAxIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldCBtMDEoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVsxXTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDEuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmFsIC0gVGhlIHZhbCBwYXJhbS4KICAgICAgICAgKi8KICAgICAgICBzZXQgbTAxKHZhbCkgewogICAgICAgICAgICB0aGlzLl9fZGF0YVsxXSA9IHZhbDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDIuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgbTAyIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldCBtMDIoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVsyXTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZvciByb3cgMCwgY29sdW1uIDIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmFsIC0gVGhlIHZhbCBwYXJhbS4KICAgICAgICAgKi8KICAgICAgICBzZXQgbTAyKHZhbCkgewogICAgICAgICAgICB0aGlzLl9fZGF0YVsyXSA9IHZhbDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDAuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgbTEwIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldCBtMTAoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVszXTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDAuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmFsIC0gVGhlIHZhbCBwYXJhbS4KICAgICAgICAgKi8KICAgICAgICBzZXQgbTEwKHZhbCkgewogICAgICAgICAgICB0aGlzLl9fZGF0YVszXSA9IHZhbDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2V0dGVyIGZvciByb3cgMSwgY29sdW1uIDEKICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBtMTEgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZ2V0IG0xMSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzRdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIHJvdyAxLCBjb2x1bW4gMS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIHNldCBtMTEodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzRdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIHJvdyAxLCBjb2x1bW4gMi4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBtMTIgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZ2V0IG0xMigpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzVdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIHJvdyAxLCBjb2x1bW4gMi4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIHNldCBtMTIodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzVdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBtMjAgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZ2V0IG0yMCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzZdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIHNldCBtMjAodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzZdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBtMjEgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZ2V0IG0yMSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzddOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIHNldCBtMjEodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzddID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMi4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBtMjIgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZ2V0IG0yMigpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzhdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMi4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIHNldCBtMjIodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzhdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIHRoZSBgeGAgYXhpcy4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBgeGAgYXhpcyBhcyBhIFZlYzMuCiAgICAgICAgICovCiAgICAgICAgZ2V0IHhBeGlzKCkgewogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMobmV3IEZsb2F0MzJBcnJheSh0aGlzLl9fZGF0YS5idWZmZXIsIDAsIDMpKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZvciB0aGUgYHhgIGF4aXMuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmVjMyAtIFRoZSB2ZWMzIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHNldCB4QXhpcyh2ZWMzKSB7CiAgICAgICAgICAgIHRoaXMueEF4aXMuc2V0KHZlYzMueCwgdmVjMy55LCB2ZWMzLnopOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIHRoZSBgeWAgYXhpcy4KICAgICAgICAgKiAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBgeWAgYXhpcyBhcyBhIFZlYzMuCiAgICAgICAgICovCiAgICAgICAgZ2V0IHlBeGlzKCkgewogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMobmV3IEZsb2F0MzJBcnJheSh0aGlzLl9fZGF0YS5idWZmZXIsIDMgKiA0LCAzKSk7IC8vIDQgYnl0ZXMgcGVyIDMyYml0IGZsb2F0CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3IgdGhlIGB5YCBheGlzLgogICAgICAgICAqIEBwYXJhbSB2ZWMzIC0gVGhlIHZlYzMgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0IHlBeGlzKHZlYzMpIHsKICAgICAgICAgICAgdGhpcy55QXhpcy5zZXQodmVjMy54LCB2ZWMzLnksIHZlYzMueik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3IgdGhlIGB6YCBheGlzLgogICAgICAgICAqICogQHJldHVybiAtIFJldHVybnMgdGhlIGB6YCBheGlzIGFzIGEgVmVjMy4KICAgICAgICAgKi8KICAgICAgICBnZXQgekF4aXMoKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyhuZXcgRmxvYXQzMkFycmF5KHRoaXMuX19kYXRhLmJ1ZmZlciwgNiAqIDQsIDMpKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZvciB0aGUgYHpgIGF4aXMuCiAgICAgICAgICogQHBhcmFtIHZlYzMgLSBUaGUgdmVjMyB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzZXQgekF4aXModmVjMykgewogICAgICAgICAgICB0aGlzLnpBeGlzLnNldCh2ZWMzLngsIHZlYzMueSwgdmVjMy56KTsKICAgICAgICB9CiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8KICAgICAgICAvLyBTZXR0ZXJzCiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIE1hdDMgY2xhc3MKICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBtMDAgLSBSb3cgMCwgY29sdW1uIDAuCiAgICAgICAgICogQHBhcmFtIG0wMSAtIFJvdyAwLCBjb2x1bW4gMS4KICAgICAgICAgKiBAcGFyYW0gbTAyIC0gUm93IDAsIGNvbHVtbiAyLgogICAgICAgICAqIEBwYXJhbSBtMTAgLSBSb3cgMSwgY29sdW1uIDAuCiAgICAgICAgICogQHBhcmFtIG0xMSAtIFJvdyAxLCBjb2x1bW4gMS4KICAgICAgICAgKiBAcGFyYW0gbTEyIC0gUm93IDEsIGNvbHVtbiAyLgogICAgICAgICAqIEBwYXJhbSBtMjAgLSBSb3cgMiwgY29sdW1uIDAuCiAgICAgICAgICogQHBhcmFtIG0yMSAtIFJvdyAyLCBjb2x1bW4gMS4KICAgICAgICAgKiBAcGFyYW0gbTIyIC0gUm93IDIsIGNvbHVtbiAyLgogICAgICAgICAqLwogICAgICAgIHNldChtMDAgPSAxLCBtMDEgPSAwLCBtMDIgPSAwLCBtMTAgPSAwLCBtMTEgPSAxLCBtMTIgPSAwLCBtMjAgPSAwLCBtMjEgPSAwLCBtMjIgPSAxKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzBdID0gbTAwOwogICAgICAgICAgICB0aGlzLl9fZGF0YVsxXSA9IG0wMTsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMl0gPSBtMDI7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzNdID0gbTEwOwogICAgICAgICAgICB0aGlzLl9fZGF0YVs0XSA9IG0xMTsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbNV0gPSBtMTI7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzZdID0gbTIwOwogICAgICAgICAgICB0aGlzLl9fZGF0YVs3XSA9IG0yMTsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbOF0gPSBtMjI7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHMgc3RhdGUgb2YgdGhlIE1hdDMgd2l0aCB0aGUgaWRlbnRpdHkgIE1hdHJpeAogICAgICAgICAqLwogICAgICAgIHNldElkZW50aXR5KCkgewogICAgICAgICAgICB0aGlzLnNldCgpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHN0YXRlIG9mIHRoZSBNYXQzIGZyb20gYW5vdGhlciBNYXQzCiAgICAgICAgICoKICAgICAgICAgKiBOb3RlOiB3b3JrcyB3aXRoIGVpdGhlciBNYXQzIG9yIE1hdDQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gbWF0IC0gVGhlIG1hdCB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzZXRGcm9tTWF0KG1hdCkgewogICAgICAgICAgICB0aGlzLl9fZGF0YVswXSA9IG1hdC5tMDA7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzFdID0gbWF0Lm0wMTsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMl0gPSBtYXQubTAyOwogICAgICAgICAgICB0aGlzLl9fZGF0YVszXSA9IG1hdC5tMTA7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzRdID0gbWF0Lm0xMTsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbNV0gPSBtYXQubTEyOwogICAgICAgICAgICB0aGlzLl9fZGF0YVs2XSA9IG1hdC5tMjA7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzddID0gbWF0Lm0yMTsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbOF0gPSBtYXQubTIyOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTY2FsZXMgYW5kIGNhbGN1bGF0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdGhlIGBWZWMzYCBhbmQgc2V0cyB0aGUgcmVzdWx0IGluIHRoZSBNYXQzCiAgICAgICAgICogTm90ZTogdGhlIHJlc3VsdGluZyBtYXRyaXggK1ogYXhpcyBpcyBhbGlnbmVkIHdpdGggdGhlIHByb3ZpZGVkIGRpcmVjdGlvbiB2YWx1ZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBkaXIgLSBUaGUgZGlyIHZhbHVlLgogICAgICAgICAqIEBwYXJhbSB1cCAtIFRoZSB1cCB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzZXRGcm9tRGlyZWN0aW9uQW5kVXB2ZWN0b3IoZGlyLCB1cCkgewogICAgICAgICAgICBjb25zdCB6QXhpcyA9IGRpcjsKICAgICAgICAgICAgY29uc3QgekxlbiA9IHpBeGlzLmxlbmd0aCgpOwogICAgICAgICAgICBpZiAoekxlbiA8IE51bWJlci5FUFNJTE9OKSB7CiAgICAgICAgICAgICAgICB0aGlzLnNldElkZW50aXR5KCk7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgekF4aXMuc2NhbGVJblBsYWNlKDEgLyB6TGVuKTsKICAgICAgICAgICAgY29uc3QgeEF4aXMgPSB1cC5jcm9zcyh6QXhpcyk7CiAgICAgICAgICAgIGNvbnN0IHhMZW4gPSB4QXhpcy5sZW5ndGgoKTsKICAgICAgICAgICAgaWYgKHhMZW4gPiBOdW1iZXIuRVBTSUxPTikKICAgICAgICAgICAgICAgIHhBeGlzLnNjYWxlSW5QbGFjZSgxIC8geExlbik7CiAgICAgICAgICAgIGNvbnN0IHlBeGlzID0gekF4aXMuY3Jvc3MoeEF4aXMpOwogICAgICAgICAgICBjb25zdCB5TGVuID0geUF4aXMubGVuZ3RoKCk7CiAgICAgICAgICAgIGlmICh5TGVuID4gTnVtYmVyLkVQU0lMT04pCiAgICAgICAgICAgICAgICB5QXhpcy5zY2FsZUluUGxhY2UoMSAvIHlMZW4pOwogICAgICAgICAgICB0aGlzLnNldCh4QXhpcy54LCB4QXhpcy55LCB4QXhpcy56LCB5QXhpcy54LCB5QXhpcy55LCB5QXhpcy56LCB6QXhpcy54LCB6QXhpcy55LCB6QXhpcy56KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogSW52ZXJ0cyBhIE1hdDMgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBpbnN0YW5jZS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IE1hdDMuCiAgICAgICAgICovCiAgICAgICAgaW52ZXJzZSgpIHsKICAgICAgICAgICAgY29uc3QgYTAwID0gdGhpcy5fX2RhdGFbMF07CiAgICAgICAgICAgIGNvbnN0IGEwMSA9IHRoaXMuX19kYXRhWzFdOwogICAgICAgICAgICBjb25zdCBhMDIgPSB0aGlzLl9fZGF0YVsyXTsKICAgICAgICAgICAgY29uc3QgYTEwID0gdGhpcy5fX2RhdGFbM107CiAgICAgICAgICAgIGNvbnN0IGExMSA9IHRoaXMuX19kYXRhWzRdOwogICAgICAgICAgICBjb25zdCBhMTIgPSB0aGlzLl9fZGF0YVs1XTsKICAgICAgICAgICAgY29uc3QgYTIwID0gdGhpcy5fX2RhdGFbNl07CiAgICAgICAgICAgIGNvbnN0IGEyMSA9IHRoaXMuX19kYXRhWzddOwogICAgICAgICAgICBjb25zdCBhMjIgPSB0aGlzLl9fZGF0YVs4XTsKICAgICAgICAgICAgY29uc3QgYjAxID0gYTIyICogYTExIC0gYTEyICogYTIxOwogICAgICAgICAgICBjb25zdCBiMTEgPSAtYTIyICogYTEwICsgYTEyICogYTIwOwogICAgICAgICAgICBjb25zdCBiMjEgPSBhMjEgKiBhMTAgLSBhMTEgKiBhMjA7CiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQKICAgICAgICAgICAgbGV0IGRldCA9IGEwMCAqIGIwMSArIGEwMSAqIGIxMSArIGEwMiAqIGIyMTsKICAgICAgICAgICAgaWYgKCFkZXQpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGludmVydCBNYXQzJyk7CiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1hdDMoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7CiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0MyhiMDEgKiBkZXQsICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldCwgKGExMiAqIGEwMSAtIGEwMiAqIGExMSkgKiBkZXQsIGIxMSAqIGRldCwgKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQsICgtYTEyICogYTAwICsgYTAyICogYTEwKSAqIGRldCwgYjIxICogZGV0LCAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQsIChhMTEgKiBhMDAgLSBhMDEgKiBhMTApICogZGV0KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogSW52ZXJ0cyBhIE1hdDMgaW4gcGxhY2UgbW9kaWZ5aW5nIGl0cyB2YWx1ZXMuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBpbnZlcnRJblBsYWNlKCkgewogICAgICAgICAgICBjb25zdCBhMDAgPSB0aGlzLl9fZGF0YVswXTsKICAgICAgICAgICAgY29uc3QgYTAxID0gdGhpcy5fX2RhdGFbMV07CiAgICAgICAgICAgIGNvbnN0IGEwMiA9IHRoaXMuX19kYXRhWzJdOwogICAgICAgICAgICBjb25zdCBhMTAgPSB0aGlzLl9fZGF0YVszXTsKICAgICAgICAgICAgY29uc3QgYTExID0gdGhpcy5fX2RhdGFbNF07CiAgICAgICAgICAgIGNvbnN0IGExMiA9IHRoaXMuX19kYXRhWzVdOwogICAgICAgICAgICBjb25zdCBhMjAgPSB0aGlzLl9fZGF0YVs2XTsKICAgICAgICAgICAgY29uc3QgYTIxID0gdGhpcy5fX2RhdGFbN107CiAgICAgICAgICAgIGNvbnN0IGEyMiA9IHRoaXMuX19kYXRhWzhdOwogICAgICAgICAgICBjb25zdCBiMDEgPSBhMjIgKiBhMTEgLSBhMTIgKiBhMjE7CiAgICAgICAgICAgIGNvbnN0IGIxMSA9IC1hMjIgKiBhMTAgKyBhMTIgKiBhMjA7CiAgICAgICAgICAgIGNvbnN0IGIyMSA9IGEyMSAqIGExMCAtIGExMSAqIGEyMDsKICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudAogICAgICAgICAgICBsZXQgZGV0ID0gYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxOwogICAgICAgICAgICBpZiAoIWRldCkgewogICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gaW52ZXJ0IE1hdDMnKTsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7CiAgICAgICAgICAgIHRoaXMuc2V0KGIwMSAqIGRldCwgKC1hMjIgKiBhMDEgKyBhMDIgKiBhMjEpICogZGV0LCAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGRldCwgYjExICogZGV0LCAoYTIyICogYTAwIC0gYTAyICogYTIwKSAqIGRldCwgKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogZGV0LCBiMjEgKiBkZXQsICgtYTIxICogYTAwICsgYTAxICogYTIwKSAqIGRldCwgKGExMSAqIGEwMCAtIGEwMSAqIGExMCkgKiBkZXQpOwogICAgICAgICAgICByZXR1cm4gdHJ1ZTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVHJhbnNwb3NlcyAoZXhjaGFuZ2VzIGNvbHVtbnMgd2l0aCByb3dzKSB0aGlzIG1hdHJpeAogICAgICAgICAqIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgaW5zdGFuY2UuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJuIGEgbmV3IHRyYW5zcG9zZWQgTWF0My4KICAgICAgICAgKi8KICAgICAgICB0cmFuc3Bvc2UoKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0Myh0aGlzLl9fZGF0YVswXSwgdGhpcy5fX2RhdGFbM10sIHRoaXMuX19kYXRhWzZdLCB0aGlzLl9fZGF0YVsxXSwgdGhpcy5fX2RhdGFbNF0sIHRoaXMuX19kYXRhWzddLCB0aGlzLl9fZGF0YVsyXSwgdGhpcy5fX2RhdGFbNV0sIHRoaXMuX19kYXRhWzhdKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVHJhbnNwb3NlcyAoZXhjaGFuZ2VzIGNvbHVtbnMgd2l0aCByb3dzKSB0aGlzIG1hdHJpeCBtb2RpZnlpbmcgaXRzIHZhbHVlcy4KICAgICAgICAgKi8KICAgICAgICB0cmFuc3Bvc2VJblBsYWNlKCkgewogICAgICAgICAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzCiAgICAgICAgICAgIGNvbnN0IGEwMSA9IHRoaXMuX19kYXRhWzFdOwogICAgICAgICAgICBjb25zdCBhMDIgPSB0aGlzLl9fZGF0YVsyXTsKICAgICAgICAgICAgY29uc3QgYTEyID0gdGhpcy5fX2RhdGFbNV07CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzFdID0gdGhpcy5fX2RhdGFbM107CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzJdID0gdGhpcy5fX2RhdGFbNl07CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzNdID0gYTAxOwogICAgICAgICAgICB0aGlzLl9fZGF0YVs1XSA9IHRoaXMuX19kYXRhWzddOwogICAgICAgICAgICB0aGlzLl9fZGF0YVs2XSA9IGEwMjsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbN10gPSBhMTI7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRyYW5zZm9ybXMgdGhlIFZlYzMgd2l0aCBhIE1hdDMuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmVjMyAtIFRoZSB2ZWMzIHZhbHVlLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm4gdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzLgogICAgICAgICAqLwogICAgICAgIHRyYW5zZm9ybVZlYzModmVjMykgewogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModGhpcy5fX2RhdGFbMF0gKiB2ZWMzLnggKyB0aGlzLl9fZGF0YVsxXSAqIHZlYzMueSArIHRoaXMuX19kYXRhWzJdICogdmVjMy56LCB0aGlzLl9fZGF0YVszXSAqIHZlYzMueCArIHRoaXMuX19kYXRhWzRdICogdmVjMy55ICsgdGhpcy5fX2RhdGFbNV0gKiB2ZWMzLnosIHRoaXMuX19kYXRhWzZdICogdmVjMy54ICsgdGhpcy5fX2RhdGFbN10gKiB2ZWMzLnkgKyB0aGlzLl9fZGF0YVs4XSAqIHZlYzMueik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENsb25lcyB0aGlzIE1hdDMgcmV0dXJuaW5nIGEgbmV3IGluc3RhbmNlLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgTWF0My4KICAgICAgICAgKi8KICAgICAgICBjbG9uZSgpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXQzKHRoaXMuX19kYXRhWzBdLCB0aGlzLl9fZGF0YVsxXSwgdGhpcy5fX2RhdGFbMl0sIHRoaXMuX19kYXRhWzNdLCB0aGlzLl9fZGF0YVs0XSwgdGhpcy5fX2RhdGFbNV0sIHRoaXMuX19kYXRhWzZdLCB0aGlzLl9fZGF0YVs3XSwgdGhpcy5fX2RhdGFbOF0pOwogICAgICAgIH0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8KICAgICAgICAvLyBQZXJzaXN0ZW5jZQogICAgICAgIC8qKgogICAgICAgICAqIExvYWRzIHRoZSBzdGF0ZSBvZiB0aGUgdmFsdWUgZnJvbSBhIGJpbmFyeSByZWFkZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICByZWFkQmluYXJ5KHJlYWRlcikgewogICAgICAgICAgICB0aGlzLl9fZGF0YSA9IHJlYWRlci5sb2FkRmxvYXQzMkFycmF5KDkpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4KICAgICAgICAgKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IC0gVGhlIGpzb24gb2JqZWN0LgogICAgICAgICAqLwogICAgICAgIHRvSlNPTigpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIGpzb24gLSBUaGUganNvbiBwYXJhbS4KICAgICAgICAgKi8KICAgICAgICBmcm9tSlNPTihqc29uKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheShqc29uKTsKICAgICAgICB9CiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCiAgICAgICAgLy8gRGVidWdnaW5nCiAgICAgICAgLyoqCiAgICAgICAgICogQ29udmVydHMgdGhpcyBWZWMzIHRvIGEgc3RyaW5nIGluIEpTT04gZm9ybWF0LgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgdG9TdHJpbmcoKSB7CiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwCiAgICAgICAgICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyBjdXJyZW50IE1hdGggdHlwZSBkYXRhIGFzIGFycmF5LiBPZnRlbiB1c2VkIHRvIHBhc3MgdHlwZXMgdG8gdGhlIEdQVS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSByZXN1bHQgYXMgYW4gYXJyYXkuCiAgICAgICAgICovCiAgICAgICAgYXNBcnJheSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhOwogICAgICAgIH0KICAgIH0KCiAgICAvKioKICAgICAqIEEgY2xhc3MgcmVwcmVzZW50aW5nIGEgNHg0IG1hdHJpeC4KICAgICAqIFRoaXMgbWF0cml4IGNsYXNzIGlzIGJhc2VkIG9uIEdMTSwgYW5kIGlzIGNvbHVtbiBtYWpvci4KICAgICAqCiAgICAgKi8KICAgIGNsYXNzIE1hdDQgewogICAgICAgIC8qKgogICAgICAgICAqIEluaXRpYWxpemVzIHRoZSBNYXQzIGNsYXNzIHdpdGggZ2l2ZW4gZGF0YS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBtMDAgLSBSb3cgMCwgY29sdW1uIDAuCiAgICAgICAgICogQHBhcmFtIG0wMSAtIFJvdyAwLCBjb2x1bW4gMS4KICAgICAgICAgKiBAcGFyYW0gbTAyIC0gUm93IDAsIGNvbHVtbiAyLgogICAgICAgICAqIEBwYXJhbSBtMDMgLSBSb3cgMCwgY29sdW1uIDMuCiAgICAgICAgICogQHBhcmFtIG0xMCAtIFJvdyAxLCBjb2x1bW4gMC4KICAgICAgICAgKiBAcGFyYW0gbTExIC0gUm93IDEsIGNvbHVtbiAxLgogICAgICAgICAqIEBwYXJhbSBtMTIgLSBSb3cgMSwgY29sdW1uIDIuCiAgICAgICAgICogQHBhcmFtIG0xMyAtIFJvdyAxLCBjb2x1bW4gMy4KICAgICAgICAgKiBAcGFyYW0gbTIwIC0gUm93IDIsIGNvbHVtbiAwLgogICAgICAgICAqIEBwYXJhbSBtMjEgLSBSb3cgMiwgY29sdW1uIDEuCiAgICAgICAgICogQHBhcmFtIG0yMiAtIFJvdyAyLCBjb2x1bW4gMi4KICAgICAgICAgKiBAcGFyYW0gbTIzIC0gUm93IDIsIGNvbHVtbiAzLgogICAgICAgICAqIEBwYXJhbSBtMzAgLSBSb3cgMywgY29sdW1uIDAuCiAgICAgICAgICogQHBhcmFtIG0zMSAtIFJvdyAzLCBjb2x1bW4gMS4KICAgICAgICAgKiBAcGFyYW0gbTMyIC0gUm93IDMsIGNvbHVtbiAyLgogICAgICAgICAqIEBwYXJhbSBtMzMgLSBSb3cgMywgY29sdW1uIDMuCiAgICAgICAgICovCiAgICAgICAgY29uc3RydWN0b3IobTAwID0gMSwgbTAxID0gMCwgbTAyID0gMCwgbTAzID0gMCwgbTEwID0gMCwgbTExID0gMSwgbTEyID0gMCwgbTEzID0gMCwgbTIwID0gMCwgbTIxID0gMCwgbTIyID0gMSwgbTIzID0gMCwgbTMwID0gMCwgbTMxID0gMCwgbTMyID0gMCwgbTMzID0gMSkgewogICAgICAgICAgICBpZiAobTAwIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YSA9IG0wMDsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmIChtMDAgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgewogICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbTAwOwogICAgICAgICAgICAgICAgY29uc3QgYnl0ZU9mZnNldCA9IG0wMTsKICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDE2KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgxNik7CiAgICAgICAgICAgICAgICB0aGlzLnNldChtMDAsIG0wMSwgbTAyLCBtMDMsIG0xMCwgbTExLCBtMTIsIG0xMywgbTIwLCBtMjEsIG0yMiwgbTIzLCBtMzAsIG0zMSwgbTMyLCBtMzMpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCiAgICAgICAgLy8gcHJvcGVydGllcwogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3Igcm93IDAsIGNvbHVtbiAwLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIG0wMCB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXQgbTAwKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbMF07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3Igcm93IDAsIGNvbHVtbiAwLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IG0wMCh2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMF0gPSB2YWw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3Igcm93IDAsIGNvbHVtbiAxLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIG0wMSB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXQgbTAxKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbMV07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3Igcm93IDAsIGNvbHVtbiAxLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IG0wMSh2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMV0gPSB2YWw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3Igcm93IDAsIGNvbHVtbiAyLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIG0wMiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXQgbTAyKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbMl07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3Igcm93IDAsIGNvbHVtbiAyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IG0wMih2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMl0gPSB2YWw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3Igcm93IDAsIGNvbHVtbiAzLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIG0wMyB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXQgbTAzKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbM107CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3Igcm93IDAsIGNvbHVtbiAzLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IG0wMyh2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbM10gPSB2YWw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3Igcm93IDEsIGNvbHVtbiAwLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIG0xMCB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXQgbTEwKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbNF07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3Igcm93IDEsIGNvbHVtbiAwLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IG0xMCh2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbNF0gPSB2YWw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3Igcm93IDEsIGNvbHVtbiAxLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIG0xMSB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXQgbTExKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbNV07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3Igcm93IDEsIGNvbHVtbiAxLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IG0xMSh2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbNV0gPSB2YWw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3Igcm93IDEsIGNvbHVtbiAyLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIG0xMiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXQgbTEyKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbNl07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3Igcm93IDEsIGNvbHVtbiAyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IG0xMih2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbNl0gPSB2YWw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3Igcm93IDEsIGNvbHVtbiAzLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIG0xMyB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXQgbTEzKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbN107CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3Igcm93IDEsIGNvbHVtbiAzLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IG0xMyh2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbN10gPSB2YWw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3Igcm93IDIsIGNvbHVtbiAwLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIG0yMCB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXQgbTIwKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbOF07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3Igcm93IDIsIGNvbHVtbiAwLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IG0yMCh2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbOF0gPSB2YWw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3Igcm93IDIsIGNvbHVtbiAxLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIG0yMSB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXQgbTIxKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbOV07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3Igcm93IDIsIGNvbHVtbiAxCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmFsIC0gVGhlIHZhbCBwYXJhbS4KICAgICAgICAgKi8KICAgICAgICBzZXQgbTIxKHZhbCkgewogICAgICAgICAgICB0aGlzLl9fZGF0YVs5XSA9IHZhbDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2V0dGVyIGZvciByb3cgMiwgY29sdW1uIDIuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgbTIyIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldCBtMjIoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVsxMF07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3Igcm93IDIsIGNvbHVtbiAyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IG0yMih2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMTBdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIHJvdyAyLCBjb2x1bW4gMy4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBtMjMgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZ2V0IG0yMygpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzExXTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZvciByb3cgMiwgY29sdW1uIDMuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmFsIC0gVGhlIHZhbCBwYXJhbS4KICAgICAgICAgKi8KICAgICAgICBzZXQgbTIzKHZhbCkgewogICAgICAgICAgICB0aGlzLl9fZGF0YVsxMV0gPSB2YWw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3Igcm93IDMsIGNvbHVtbiAwCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgbTMwIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldCBtMzAoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVsxMl07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3Igcm93IDMsIGNvbHVtbiAwLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IG0zMCh2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMTJdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIHJvdyAzLCBjb2x1bW4gMS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBtMzEgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZ2V0IG0zMSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzEzXTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZvciByb3cgMywgY29sdW1uIDEuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmFsIC0gVGhlIHZhbCBwYXJhbS4KICAgICAgICAgKi8KICAgICAgICBzZXQgbTMxKHZhbCkgewogICAgICAgICAgICB0aGlzLl9fZGF0YVsxM10gPSB2YWw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3Igcm93IDMsIGNvbHVtbiAyLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIG0zMiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXQgbTMyKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbMTRdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIHJvdyAzLCBjb2x1bW4gMi4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIHNldCBtMzIodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzE0XSA9IHZhbDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2V0dGVyIGZvciByb3cgMywgY29sdW1uIDMuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgbTMzIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldCBtMzMoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVsxNV07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3Igcm93IDMsIGNvbHVtbiAzLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IG0zMyh2YWwpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMTVdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIHRoZSBgeGAgYXhpcy4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBgeGAgYXhpcyBhcyBhIFZlYzMuCiAgICAgICAgICovCiAgICAgICAgZ2V0IHhBeGlzKCkgewogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMobmV3IEZsb2F0MzJBcnJheSh0aGlzLl9fZGF0YS5idWZmZXIsIDAsIDMpKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZvciB0aGUgYHhgIGF4aXMuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmVjMyAtIFRoZSB2ZWMzIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHNldCB4QXhpcyh2ZWMzKSB7CiAgICAgICAgICAgIHRoaXMueEF4aXMuc2V0KHZlYzMueCwgdmVjMy55LCB2ZWMzLnopOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIHRoZSBgeWAgYXhpcy4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBgeWAgYXhpcyBhcyBhIFZlYzMuCiAgICAgICAgICovCiAgICAgICAgZ2V0IHlBeGlzKCkgewogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMobmV3IEZsb2F0MzJBcnJheSh0aGlzLl9fZGF0YS5idWZmZXIsIDQgKiA0LCAzKSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3IgdGhlIGB5YCBheGlzLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZlYzMgLSBUaGUgdmVjMyB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzZXQgeUF4aXModmVjMykgewogICAgICAgICAgICB0aGlzLnlBeGlzLnNldCh2ZWMzLngsIHZlYzMueSwgdmVjMy56KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2V0dGVyIGZvciB0aGUgYHpgIGF4aXMuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgYHpgIGF4aXMgYXMgYSBWZWMzLgogICAgICAgICAqLwogICAgICAgIGdldCB6QXhpcygpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fX2RhdGEuYnVmZmVyLCA4ICogNCwgMykpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIHRoZSBgemAgYXhpcy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB2ZWMzIC0gVGhlIHZlYzMgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0IHpBeGlzKHZlYzMpIHsKICAgICAgICAgICAgdGhpcy56QXhpcy5zZXQodmVjMy54LCB2ZWMzLnksIHZlYzMueik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3IgdGhlIHRyYW5zbGF0aW9uIG9mIHRoZSBtYXRyaXguIEFzc3VtZXMgdGhlIHRyYW5zbGF0aW9uIHZhbHVlcyBhcmUgMTIsIDEzLCAmIDE0LgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIHRyYW5zbGF0aW9uLgogICAgICAgICAqLwogICAgICAgIGdldCB0cmFuc2xhdGlvbigpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKG5ldyBGbG9hdDMyQXJyYXkodGhpcy5fX2RhdGEuYnVmZmVyLCAxMiAqIDQsIDMpKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZvciB0aGUgdHJhbnNsYXRpb24gb2YgdGhlIG1hdHJpeC4gQXNzdW1lcyB0aGUgdHJhbnNsYXRpb24gdmFsdWVzIGFyZSAxMiwgMTMsICYgMTQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmVjMyAtIFRoZSB0cmFuc2xhdGlvbi4KICAgICAgICAgKi8KICAgICAgICBzZXQgdHJhbnNsYXRpb24odmVjMykgewogICAgICAgICAgICB0aGlzLnRyYW5zbGF0aW9uLnNldCh2ZWMzLngsIHZlYzMueSwgdmVjMy56KTsKICAgICAgICB9CiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8KICAgICAgICAvLyBTZXR0ZXJzCiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIE1hdDQgY2xhc3MKICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBtMDAgLSBSb3cgMCwgY29sdW1uIDAuCiAgICAgICAgICogQHBhcmFtIG0wMSAtIFJvdyAwLCBjb2x1bW4gMS4KICAgICAgICAgKiBAcGFyYW0gbTAyIC0gUm93IDAsIGNvbHVtbiAyLgogICAgICAgICAqIEBwYXJhbSBtMDMgLSBSb3cgMCwgY29sdW1uIDMuCiAgICAgICAgICogQHBhcmFtIG0xMCAtIFJvdyAxLCBjb2x1bW4gMC4KICAgICAgICAgKiBAcGFyYW0gbTExIC0gUm93IDEsIGNvbHVtbiAxLgogICAgICAgICAqIEBwYXJhbSBtMTIgLSBSb3cgMSwgY29sdW1uIDIuCiAgICAgICAgICogQHBhcmFtIG0xMyAtIFJvdyAxLCBjb2x1bW4gMy4KICAgICAgICAgKiBAcGFyYW0gbTIwIC0gUm93IDIsIGNvbHVtbiAwLgogICAgICAgICAqIEBwYXJhbSBtMjEgLSBSb3cgMiwgY29sdW1uIDEuCiAgICAgICAgICogQHBhcmFtIG0yMiAtIFJvdyAyLCBjb2x1bW4gMi4KICAgICAgICAgKiBAcGFyYW0gbTIzIC0gUm93IDIsIGNvbHVtbiAzLgogICAgICAgICAqIEBwYXJhbSBtMzAgLSBSb3cgMywgY29sdW1uIDAuCiAgICAgICAgICogQHBhcmFtIG0zMSAtIFJvdyAzLCBjb2x1bW4gMS4KICAgICAgICAgKiBAcGFyYW0gbTMyIC0gUm93IDMsIGNvbHVtbiAyLgogICAgICAgICAqIEBwYXJhbSBtMzMgLSBSb3cgMywgY29sdW1uIDMuCiAgICAgICAgICovCiAgICAgICAgc2V0KG0wMCA9IDEsIG0wMSA9IDAsIG0wMiA9IDAsIG0wMyA9IDAsIG0xMCA9IDAsIG0xMSA9IDEsIG0xMiA9IDAsIG0xMyA9IDAsIG0yMCA9IDAsIG0yMSA9IDAsIG0yMiA9IDEsIG0yMyA9IDAsIG0zMCA9IDAsIG0zMSA9IDAsIG0zMiA9IDAsIG0zMyA9IDEpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMF0gPSBtMDA7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzFdID0gbTAxOwogICAgICAgICAgICB0aGlzLl9fZGF0YVsyXSA9IG0wMjsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbM10gPSBtMDM7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzRdID0gbTEwOwogICAgICAgICAgICB0aGlzLl9fZGF0YVs1XSA9IG0xMTsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbNl0gPSBtMTI7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzddID0gbTEzOwogICAgICAgICAgICB0aGlzLl9fZGF0YVs4XSA9IG0yMDsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbOV0gPSBtMjE7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzEwXSA9IG0yMjsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMTFdID0gbTIzOwogICAgICAgICAgICB0aGlzLl9fZGF0YVsxMl0gPSBtMzA7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzEzXSA9IG0zMTsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMTRdID0gbTMyOwogICAgICAgICAgICB0aGlzLl9fZGF0YVsxNV0gPSBtMzM7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHMgc3RhdGUgb2YgdGhlIE1hdDQgd2l0aCB0aGUgaWRlbnRpdHkgIE1hdHJpeAogICAgICAgICAqLwogICAgICAgIHNldElkZW50aXR5KCkgewogICAgICAgICAgICB0aGlzLnNldCgpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgTWF0NCBPYmplY3QuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gZmxvYXQzMkFycmF5IC0gVGhlIGZsb2F0MzJBcnJheSB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzZXREYXRhQXJyYXkoZmxvYXQzMkFycmF5KSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhID0gZmxvYXQzMkFycmF5OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHN0YXRlIG9mIHRoZSBNYXQ0IGZyb20gYW5vdGhlciBNYXQ0CiAgICAgICAgICoKICAgICAgICAgKiBOb3RlOiB3b3JrcyB3aXRoIGVpdGhlciBNYXQzIG9yIE1hdDQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gbWF0NCAtIFRoZSBtYXQ0IHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHNldEZyb21NYXQ0KG1hdDQpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMF0gPSBtYXQ0Lm0wMDsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMV0gPSBtYXQ0Lm0wMTsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMl0gPSBtYXQ0Lm0wMjsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbM10gPSBtYXQ0Lm0wMzsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbNF0gPSBtYXQ0Lm0xMDsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbNV0gPSBtYXQ0Lm0xMTsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbNl0gPSBtYXQ0Lm0xMjsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbN10gPSBtYXQ0Lm0xMzsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbOF0gPSBtYXQ0Lm0yMDsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbOV0gPSBtYXQ0Lm0yMTsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMTBdID0gbWF0NC5tMjI7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzExXSA9IG1hdDQubTIzOwogICAgICAgICAgICB0aGlzLl9fZGF0YVsxMl0gPSBtYXQ0Lm0zMDsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMTNdID0gbWF0NC5tMzE7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzE0XSA9IG1hdDQubTMyOwogICAgICAgICAgICB0aGlzLl9fZGF0YVsxNV0gPSBtYXQ0Lm0zMzsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ29udmVydHMgYSBNYXQ0IHRvIGEgTWF0My4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IE1hdDMuCiAgICAgICAgICovCiAgICAgICAgdG9NYXQzKCkgewogICAgICAgICAgICByZXR1cm4gbmV3IE1hdDModGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXSwgdGhpcy5fX2RhdGFbNF0sIHRoaXMuX19kYXRhWzVdLCB0aGlzLl9fZGF0YVs2XSwgdGhpcy5fX2RhdGFbOF0sIHRoaXMuX19kYXRhWzldLCB0aGlzLl9fZGF0YVsxMF0pOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUcmFuc3Bvc2VzIChleGNoYW5nZXMgY29sdW1ucyB3aXRoIHJvd3MpIHRoaXMgbWF0cml4LgogICAgICAgICAqLwogICAgICAgIHRyYW5zcG9zZUluUGxhY2UoKSB7CiAgICAgICAgICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXMKICAgICAgICAgICAgY29uc3QgYTAxID0gdGhpcy5fX2RhdGFbMV07CiAgICAgICAgICAgIGNvbnN0IGEwMiA9IHRoaXMuX19kYXRhWzJdOwogICAgICAgICAgICBjb25zdCBhMDMgPSB0aGlzLl9fZGF0YVszXTsKICAgICAgICAgICAgY29uc3QgYTEyID0gdGhpcy5fX2RhdGFbNl07CiAgICAgICAgICAgIGNvbnN0IGExMyA9IHRoaXMuX19kYXRhWzddOwogICAgICAgICAgICBjb25zdCBhMjMgPSB0aGlzLl9fZGF0YVsxMV07CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzFdID0gdGhpcy5fX2RhdGFbNF07CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzJdID0gdGhpcy5fX2RhdGFbOF07CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzNdID0gdGhpcy5fX2RhdGFbMTJdOwogICAgICAgICAgICB0aGlzLl9fZGF0YVs0XSA9IGEwMTsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbNl0gPSB0aGlzLl9fZGF0YVs5XTsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbN10gPSB0aGlzLl9fZGF0YVsxM107CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzhdID0gYTAyOwogICAgICAgICAgICB0aGlzLl9fZGF0YVs5XSA9IGExMjsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMTFdID0gdGhpcy5fX2RhdGFbMTRdOwogICAgICAgICAgICB0aGlzLl9fZGF0YVsxMl0gPSBhMDM7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzEzXSA9IGExMzsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMTRdID0gYTIzOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUcmFuc3Bvc2VzIChleGNoYW5nZXMgY29sdW1ucyB3aXRoIHJvd3MpIHRoaXMgbWF0cml4CiAgICAgICAgICogYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBpbnN0YW5jZS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm4gYSBuZXcgdHJhbnNwb3NlZCBNYXQ0LgogICAgICAgICAqLwogICAgICAgIHRyYW5zcG9zZSgpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXQ0KHRoaXMuX19kYXRhWzBdLCB0aGlzLl9fZGF0YVs0XSwgdGhpcy5fX2RhdGFbOF0sIHRoaXMuX19kYXRhWzEyXSwgdGhpcy5fX2RhdGFbMV0sIHRoaXMuX19kYXRhWzVdLCB0aGlzLl9fZGF0YVs5XSwgdGhpcy5fX2RhdGFbMTNdLCB0aGlzLl9fZGF0YVsyXSwgdGhpcy5fX2RhdGFbNl0sIHRoaXMuX19kYXRhWzEwXSwgdGhpcy5fX2RhdGFbMTRdLCB0aGlzLl9fZGF0YVszXSwgdGhpcy5fX2RhdGFbN10sIHRoaXMuX19kYXRhWzExXSwgdGhpcy5fX2RhdGFbMTVdKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogSW52ZXJ0cyBhIE1hdDQgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBpbnN0YW5jZS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IE1hdDQuCiAgICAgICAgICovCiAgICAgICAgaW52ZXJzZSgpIHsKICAgICAgICAgICAgY29uc3QgYTAwID0gdGhpcy5fX2RhdGFbMF07CiAgICAgICAgICAgIGNvbnN0IGEwMSA9IHRoaXMuX19kYXRhWzFdOwogICAgICAgICAgICBjb25zdCBhMDIgPSB0aGlzLl9fZGF0YVsyXTsKICAgICAgICAgICAgY29uc3QgYTAzID0gdGhpcy5fX2RhdGFbM107CiAgICAgICAgICAgIGNvbnN0IGExMCA9IHRoaXMuX19kYXRhWzRdOwogICAgICAgICAgICBjb25zdCBhMTEgPSB0aGlzLl9fZGF0YVs1XTsKICAgICAgICAgICAgY29uc3QgYTEyID0gdGhpcy5fX2RhdGFbNl07CiAgICAgICAgICAgIGNvbnN0IGExMyA9IHRoaXMuX19kYXRhWzddOwogICAgICAgICAgICBjb25zdCBhMjAgPSB0aGlzLl9fZGF0YVs4XTsKICAgICAgICAgICAgY29uc3QgYTIxID0gdGhpcy5fX2RhdGFbOV07CiAgICAgICAgICAgIGNvbnN0IGEyMiA9IHRoaXMuX19kYXRhWzEwXTsKICAgICAgICAgICAgY29uc3QgYTIzID0gdGhpcy5fX2RhdGFbMTFdOwogICAgICAgICAgICBjb25zdCBhMzAgPSB0aGlzLl9fZGF0YVsxMl07CiAgICAgICAgICAgIGNvbnN0IGEzMSA9IHRoaXMuX19kYXRhWzEzXTsKICAgICAgICAgICAgY29uc3QgYTMyID0gdGhpcy5fX2RhdGFbMTRdOwogICAgICAgICAgICBjb25zdCBhMzMgPSB0aGlzLl9fZGF0YVsxNV07CiAgICAgICAgICAgIGNvbnN0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDsKICAgICAgICAgICAgY29uc3QgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwOwogICAgICAgICAgICBjb25zdCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7CiAgICAgICAgICAgIGNvbnN0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTsKICAgICAgICAgICAgY29uc3QgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExOwogICAgICAgICAgICBjb25zdCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7CiAgICAgICAgICAgIGNvbnN0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDsKICAgICAgICAgICAgY29uc3QgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwOwogICAgICAgICAgICBjb25zdCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7CiAgICAgICAgICAgIGNvbnN0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTsKICAgICAgICAgICAgY29uc3QgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxOwogICAgICAgICAgICBjb25zdCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7CiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQKICAgICAgICAgICAgbGV0IGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjsKICAgICAgICAgICAgaWYgKCFkZXQpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGludmVydCBNYXQ0Jyk7CiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICAgICAgfQogICAgICAgICAgICBkZXQgPSAxLjAgLyBkZXQ7CiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0NCgoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldCwgKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQsIChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0LCAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldCwgKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQsIChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0LCAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldCwgKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQsIChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0LCAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldCwgKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQsIChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0LCAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldCwgKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQsIChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0LCAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldCk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEludmVydHMgYSBNYXQ0LgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgaW52ZXJ0SW5QbGFjZSgpIHsKICAgICAgICAgICAgY29uc3QgYTAwID0gdGhpcy5fX2RhdGFbMF07CiAgICAgICAgICAgIGNvbnN0IGEwMSA9IHRoaXMuX19kYXRhWzFdOwogICAgICAgICAgICBjb25zdCBhMDIgPSB0aGlzLl9fZGF0YVsyXTsKICAgICAgICAgICAgY29uc3QgYTAzID0gdGhpcy5fX2RhdGFbM107CiAgICAgICAgICAgIGNvbnN0IGExMCA9IHRoaXMuX19kYXRhWzRdOwogICAgICAgICAgICBjb25zdCBhMTEgPSB0aGlzLl9fZGF0YVs1XTsKICAgICAgICAgICAgY29uc3QgYTEyID0gdGhpcy5fX2RhdGFbNl07CiAgICAgICAgICAgIGNvbnN0IGExMyA9IHRoaXMuX19kYXRhWzddOwogICAgICAgICAgICBjb25zdCBhMjAgPSB0aGlzLl9fZGF0YVs4XTsKICAgICAgICAgICAgY29uc3QgYTIxID0gdGhpcy5fX2RhdGFbOV07CiAgICAgICAgICAgIGNvbnN0IGEyMiA9IHRoaXMuX19kYXRhWzEwXTsKICAgICAgICAgICAgY29uc3QgYTIzID0gdGhpcy5fX2RhdGFbMTFdOwogICAgICAgICAgICBjb25zdCBhMzAgPSB0aGlzLl9fZGF0YVsxMl07CiAgICAgICAgICAgIGNvbnN0IGEzMSA9IHRoaXMuX19kYXRhWzEzXTsKICAgICAgICAgICAgY29uc3QgYTMyID0gdGhpcy5fX2RhdGFbMTRdOwogICAgICAgICAgICBjb25zdCBhMzMgPSB0aGlzLl9fZGF0YVsxNV07CiAgICAgICAgICAgIGNvbnN0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDsKICAgICAgICAgICAgY29uc3QgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwOwogICAgICAgICAgICBjb25zdCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7CiAgICAgICAgICAgIGNvbnN0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTsKICAgICAgICAgICAgY29uc3QgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExOwogICAgICAgICAgICBjb25zdCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7CiAgICAgICAgICAgIGNvbnN0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDsKICAgICAgICAgICAgY29uc3QgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwOwogICAgICAgICAgICBjb25zdCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7CiAgICAgICAgICAgIGNvbnN0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTsKICAgICAgICAgICAgY29uc3QgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxOwogICAgICAgICAgICBjb25zdCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7CiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQKICAgICAgICAgICAgbGV0IGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjsKICAgICAgICAgICAgaWYgKCFkZXQpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGludmVydCBNYXQ0Jyk7CiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZGV0ID0gMS4wIC8gZGV0OwogICAgICAgICAgICB0aGlzLnNldCgoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldCwgKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQsIChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0LCAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldCwgKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQsIChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0LCAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldCwgKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQsIChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0LCAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldCwgKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQsIChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0LCAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldCwgKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQsIChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0LCAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldCk7CiAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHRoaXMgbWF0cml4IGFzIHRoZSBpbnZlcnNlIG9mIHRoZSBnaXZlbiBNYXQ0LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG1hdDQgLSBUaGUgbWF0NCB2YWx1ZS4KICAgICAgICAgKiBAcmV0dXJuIC0gSW4gY2FzZSB0aGUgYGRldGVybWluYW50YCBjYW4ndCBiZSBjYWxjdWxhdGVkLCBhIGBudWxsYCB3aWxsIGJlIHJldHVybmVkLCBvdGhlcndpc2UsIG5vdGhpbmcgaXMgcmV0dXJuZWQKICAgICAgICAgKi8KICAgICAgICBzZXRJbnZlcnNlKG1hdDQpIHsKICAgICAgICAgICAgY29uc3QgYTAwID0gbWF0NC5fX2RhdGFbMF07CiAgICAgICAgICAgIGNvbnN0IGEwMSA9IG1hdDQuX19kYXRhWzFdOwogICAgICAgICAgICBjb25zdCBhMDIgPSBtYXQ0Ll9fZGF0YVsyXTsKICAgICAgICAgICAgY29uc3QgYTAzID0gbWF0NC5fX2RhdGFbM107CiAgICAgICAgICAgIGNvbnN0IGExMCA9IG1hdDQuX19kYXRhWzRdOwogICAgICAgICAgICBjb25zdCBhMTEgPSBtYXQ0Ll9fZGF0YVs1XTsKICAgICAgICAgICAgY29uc3QgYTEyID0gbWF0NC5fX2RhdGFbNl07CiAgICAgICAgICAgIGNvbnN0IGExMyA9IG1hdDQuX19kYXRhWzddOwogICAgICAgICAgICBjb25zdCBhMjAgPSBtYXQ0Ll9fZGF0YVs4XTsKICAgICAgICAgICAgY29uc3QgYTIxID0gbWF0NC5fX2RhdGFbOV07CiAgICAgICAgICAgIGNvbnN0IGEyMiA9IG1hdDQuX19kYXRhWzEwXTsKICAgICAgICAgICAgY29uc3QgYTIzID0gbWF0NC5fX2RhdGFbMTFdOwogICAgICAgICAgICBjb25zdCBhMzAgPSBtYXQ0Ll9fZGF0YVsxMl07CiAgICAgICAgICAgIGNvbnN0IGEzMSA9IG1hdDQuX19kYXRhWzEzXTsKICAgICAgICAgICAgY29uc3QgYTMyID0gbWF0NC5fX2RhdGFbMTRdOwogICAgICAgICAgICBjb25zdCBhMzMgPSBtYXQ0Ll9fZGF0YVsxNV07CiAgICAgICAgICAgIGNvbnN0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDsKICAgICAgICAgICAgY29uc3QgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwOwogICAgICAgICAgICBjb25zdCBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTA7CiAgICAgICAgICAgIGNvbnN0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTsKICAgICAgICAgICAgY29uc3QgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExOwogICAgICAgICAgICBjb25zdCBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTI7CiAgICAgICAgICAgIGNvbnN0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDsKICAgICAgICAgICAgY29uc3QgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwOwogICAgICAgICAgICBjb25zdCBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzA7CiAgICAgICAgICAgIGNvbnN0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTsKICAgICAgICAgICAgY29uc3QgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxOwogICAgICAgICAgICBjb25zdCBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7CiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQKICAgICAgICAgICAgbGV0IGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjsKICAgICAgICAgICAgaWYgKCFkZXQpIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGludmVydCBNYXQ0Jyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZGV0ID0gMS4wIC8gZGV0OwogICAgICAgICAgICB0aGlzLnNldCgoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldCwgKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQsIChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0LCAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldCwgKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQsIChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0LCAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldCwgKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQsIChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0LCAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldCwgKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQsIChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0LCAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldCwgKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQsIChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0LCAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldCk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIE11bHRpcGxpZXMgdHdvIE1hdDRzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgaW5zdGFuY2UuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgTWF0NCB0byBtdWx0aXBseSB3aXRoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IE1hdDQuCiAgICAgICAgICovCiAgICAgICAgbXVsdGlwbHkob3RoZXIpIHsKICAgICAgICAgICAgY29uc3QgYTAwID0gdGhpcy5fX2RhdGFbMF07CiAgICAgICAgICAgIGNvbnN0IGEwMSA9IHRoaXMuX19kYXRhWzFdOwogICAgICAgICAgICBjb25zdCBhMDIgPSB0aGlzLl9fZGF0YVsyXTsKICAgICAgICAgICAgY29uc3QgYTAzID0gdGhpcy5fX2RhdGFbM107CiAgICAgICAgICAgIGNvbnN0IGExMCA9IHRoaXMuX19kYXRhWzRdOwogICAgICAgICAgICBjb25zdCBhMTEgPSB0aGlzLl9fZGF0YVs1XTsKICAgICAgICAgICAgY29uc3QgYTEyID0gdGhpcy5fX2RhdGFbNl07CiAgICAgICAgICAgIGNvbnN0IGExMyA9IHRoaXMuX19kYXRhWzddOwogICAgICAgICAgICBjb25zdCBhMjAgPSB0aGlzLl9fZGF0YVs4XTsKICAgICAgICAgICAgY29uc3QgYTIxID0gdGhpcy5fX2RhdGFbOV07CiAgICAgICAgICAgIGNvbnN0IGEyMiA9IHRoaXMuX19kYXRhWzEwXTsKICAgICAgICAgICAgY29uc3QgYTIzID0gdGhpcy5fX2RhdGFbMTFdOwogICAgICAgICAgICBjb25zdCBhMzAgPSB0aGlzLl9fZGF0YVsxMl07CiAgICAgICAgICAgIGNvbnN0IGEzMSA9IHRoaXMuX19kYXRhWzEzXTsKICAgICAgICAgICAgY29uc3QgYTMyID0gdGhpcy5fX2RhdGFbMTRdOwogICAgICAgICAgICBjb25zdCBhMzMgPSB0aGlzLl9fZGF0YVsxNV07CiAgICAgICAgICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeAogICAgICAgICAgICBjb25zdCBiID0gb3RoZXIuYXNBcnJheSgpOwogICAgICAgICAgICBsZXQgYjAgPSBiWzBdOwogICAgICAgICAgICBsZXQgYjEgPSBiWzFdOwogICAgICAgICAgICBsZXQgYjIgPSBiWzJdOwogICAgICAgICAgICBsZXQgYjMgPSBiWzNdOwogICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgTWF0NCgpOwogICAgICAgICAgICByZXN1bHQubTAwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7CiAgICAgICAgICAgIHJlc3VsdC5tMDEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTsKICAgICAgICAgICAgcmVzdWx0Lm0wMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyOwogICAgICAgICAgICByZXN1bHQubTAzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7CiAgICAgICAgICAgIGIwID0gYls0XTsKICAgICAgICAgICAgYjEgPSBiWzVdOwogICAgICAgICAgICBiMiA9IGJbNl07CiAgICAgICAgICAgIGIzID0gYls3XTsKICAgICAgICAgICAgcmVzdWx0Lm0xMCA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwOwogICAgICAgICAgICByZXN1bHQubTExID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7CiAgICAgICAgICAgIHJlc3VsdC5tMTIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsKICAgICAgICAgICAgcmVzdWx0Lm0xMyA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzOwogICAgICAgICAgICBiMCA9IGJbOF07CiAgICAgICAgICAgIGIxID0gYls5XTsKICAgICAgICAgICAgYjIgPSBiWzEwXTsKICAgICAgICAgICAgYjMgPSBiWzExXTsKICAgICAgICAgICAgcmVzdWx0Lm0yMCA9IGIwICogYTAwICsgYjEgKiBhMTAgKyBiMiAqIGEyMCArIGIzICogYTMwOwogICAgICAgICAgICByZXN1bHQubTIxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7CiAgICAgICAgICAgIHJlc3VsdC5tMjIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsKICAgICAgICAgICAgcmVzdWx0Lm0yMyA9IGIwICogYTAzICsgYjEgKiBhMTMgKyBiMiAqIGEyMyArIGIzICogYTMzOwogICAgICAgICAgICBiMCA9IGJbMTJdOwogICAgICAgICAgICBiMSA9IGJbMTNdOwogICAgICAgICAgICBiMiA9IGJbMTRdOwogICAgICAgICAgICBiMyA9IGJbMTVdOwogICAgICAgICAgICByZXN1bHQubTMwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7CiAgICAgICAgICAgIHJlc3VsdC5tMzEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTsKICAgICAgICAgICAgcmVzdWx0Lm0zMiA9IGIwICogYTAyICsgYjEgKiBhMTIgKyBiMiAqIGEyMiArIGIzICogYTMyOwogICAgICAgICAgICByZXN1bHQubTMzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7CiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIE11bHRpcGxpZXMgdHdvIE1hdDRzIGluIHBsYWNlIGV4cGxpY2l0bHkgbm90IHVzaW5nIFNJTUQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgTWF0NCB0byBtdWx0aXBseSB3aXRoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IE1hdDQuCiAgICAgICAgICovCiAgICAgICAgbXVsdGlwbHlJblBsYWNlKG90aGVyKSB7CiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLmFzQXJyYXkoKTsKICAgICAgICAgICAgY29uc3QgYTAwID0gYVswXTsKICAgICAgICAgICAgY29uc3QgYTAxID0gYVsxXTsKICAgICAgICAgICAgY29uc3QgYTAyID0gYVsyXTsKICAgICAgICAgICAgY29uc3QgYTAzID0gYVszXTsKICAgICAgICAgICAgY29uc3QgYTEwID0gYVs0XTsKICAgICAgICAgICAgY29uc3QgYTExID0gYVs1XTsKICAgICAgICAgICAgY29uc3QgYTEyID0gYVs2XTsKICAgICAgICAgICAgY29uc3QgYTEzID0gYVs3XTsKICAgICAgICAgICAgY29uc3QgYTIwID0gYVs4XTsKICAgICAgICAgICAgY29uc3QgYTIxID0gYVs5XTsKICAgICAgICAgICAgY29uc3QgYTIyID0gYVsxMF07CiAgICAgICAgICAgIGNvbnN0IGEyMyA9IGFbMTFdOwogICAgICAgICAgICBjb25zdCBhMzAgPSBhWzEyXTsKICAgICAgICAgICAgY29uc3QgYTMxID0gYVsxM107CiAgICAgICAgICAgIGNvbnN0IGEzMiA9IGFbMTRdOwogICAgICAgICAgICBjb25zdCBhMzMgPSBhWzE1XTsKICAgICAgICAgICAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4CiAgICAgICAgICAgIGNvbnN0IGIgPSBvdGhlci5hc0FycmF5KCk7CiAgICAgICAgICAgIGxldCBiMCA9IGJbMF07CiAgICAgICAgICAgIGxldCBiMSA9IGJbMV07CiAgICAgICAgICAgIGxldCBiMiA9IGJbMl07CiAgICAgICAgICAgIGxldCBiMyA9IGJbM107CiAgICAgICAgICAgIHRoaXMubTAwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7CiAgICAgICAgICAgIHRoaXMubTAxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7CiAgICAgICAgICAgIHRoaXMubTAyID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7CiAgICAgICAgICAgIHRoaXMubTAzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7CiAgICAgICAgICAgIGIwID0gYls0XTsKICAgICAgICAgICAgYjEgPSBiWzVdOwogICAgICAgICAgICBiMiA9IGJbNl07CiAgICAgICAgICAgIGIzID0gYls3XTsKICAgICAgICAgICAgdGhpcy5tMTAgPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDsKICAgICAgICAgICAgdGhpcy5tMTEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTsKICAgICAgICAgICAgdGhpcy5tMTIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsKICAgICAgICAgICAgdGhpcy5tMTMgPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMzsKICAgICAgICAgICAgYjAgPSBiWzhdOwogICAgICAgICAgICBiMSA9IGJbOV07CiAgICAgICAgICAgIGIyID0gYlsxMF07CiAgICAgICAgICAgIGIzID0gYlsxMV07CiAgICAgICAgICAgIHRoaXMubTIwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7CiAgICAgICAgICAgIHRoaXMubTIxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7CiAgICAgICAgICAgIHRoaXMubTIyID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7CiAgICAgICAgICAgIHRoaXMubTIzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7CiAgICAgICAgICAgIGIwID0gYlsxMl07CiAgICAgICAgICAgIGIxID0gYlsxM107CiAgICAgICAgICAgIGIyID0gYlsxNF07CiAgICAgICAgICAgIGIzID0gYlsxNV07CiAgICAgICAgICAgIHRoaXMubTMwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7CiAgICAgICAgICAgIHRoaXMubTMxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7CiAgICAgICAgICAgIHRoaXMubTMyID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7CiAgICAgICAgICAgIHRoaXMubTMzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBQb3N0IG11bHRpcGxpZXMgdHdvIE1hdDRzIGluIHBsYWNlIGV4cGxpY2l0bHkgbm90IHVzaW5nIFNJTUQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgTWF0NCB0byBtdWx0aXBseSB3aXRoLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgTWF0NC4KICAgICAgICAgKi8KICAgICAgICBwb3N0TXVsdGlwbHlJblBsYWNlKG90aGVyKSB7CiAgICAgICAgICAgIGNvbnN0IGEgPSBvdGhlci5hc0FycmF5KCk7CiAgICAgICAgICAgIGNvbnN0IGEwMCA9IGFbMF07CiAgICAgICAgICAgIGNvbnN0IGEwMSA9IGFbMV07CiAgICAgICAgICAgIGNvbnN0IGEwMiA9IGFbMl07CiAgICAgICAgICAgIGNvbnN0IGEwMyA9IGFbM107CiAgICAgICAgICAgIGNvbnN0IGExMCA9IGFbNF07CiAgICAgICAgICAgIGNvbnN0IGExMSA9IGFbNV07CiAgICAgICAgICAgIGNvbnN0IGExMiA9IGFbNl07CiAgICAgICAgICAgIGNvbnN0IGExMyA9IGFbN107CiAgICAgICAgICAgIGNvbnN0IGEyMCA9IGFbOF07CiAgICAgICAgICAgIGNvbnN0IGEyMSA9IGFbOV07CiAgICAgICAgICAgIGNvbnN0IGEyMiA9IGFbMTBdOwogICAgICAgICAgICBjb25zdCBhMjMgPSBhWzExXTsKICAgICAgICAgICAgY29uc3QgYTMwID0gYVsxMl07CiAgICAgICAgICAgIGNvbnN0IGEzMSA9IGFbMTNdOwogICAgICAgICAgICBjb25zdCBhMzIgPSBhWzE0XTsKICAgICAgICAgICAgY29uc3QgYTMzID0gYVsxNV07CiAgICAgICAgICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeAogICAgICAgICAgICBjb25zdCBiID0gdGhpcy5hc0FycmF5KCk7CiAgICAgICAgICAgIGxldCBiMCA9IGJbMF07CiAgICAgICAgICAgIGxldCBiMSA9IGJbMV07CiAgICAgICAgICAgIGxldCBiMiA9IGJbMl07CiAgICAgICAgICAgIGxldCBiMyA9IGJbM107CiAgICAgICAgICAgIHRoaXMubTAwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7CiAgICAgICAgICAgIHRoaXMubTAxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7CiAgICAgICAgICAgIHRoaXMubTAyID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7CiAgICAgICAgICAgIHRoaXMubTAzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7CiAgICAgICAgICAgIGIwID0gYls0XTsKICAgICAgICAgICAgYjEgPSBiWzVdOwogICAgICAgICAgICBiMiA9IGJbNl07CiAgICAgICAgICAgIGIzID0gYls3XTsKICAgICAgICAgICAgdGhpcy5tMTAgPSBiMCAqIGEwMCArIGIxICogYTEwICsgYjIgKiBhMjAgKyBiMyAqIGEzMDsKICAgICAgICAgICAgdGhpcy5tMTEgPSBiMCAqIGEwMSArIGIxICogYTExICsgYjIgKiBhMjEgKyBiMyAqIGEzMTsKICAgICAgICAgICAgdGhpcy5tMTIgPSBiMCAqIGEwMiArIGIxICogYTEyICsgYjIgKiBhMjIgKyBiMyAqIGEzMjsKICAgICAgICAgICAgdGhpcy5tMTMgPSBiMCAqIGEwMyArIGIxICogYTEzICsgYjIgKiBhMjMgKyBiMyAqIGEzMzsKICAgICAgICAgICAgYjAgPSBiWzhdOwogICAgICAgICAgICBiMSA9IGJbOV07CiAgICAgICAgICAgIGIyID0gYlsxMF07CiAgICAgICAgICAgIGIzID0gYlsxMV07CiAgICAgICAgICAgIHRoaXMubTIwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7CiAgICAgICAgICAgIHRoaXMubTIxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7CiAgICAgICAgICAgIHRoaXMubTIyID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7CiAgICAgICAgICAgIHRoaXMubTIzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7CiAgICAgICAgICAgIGIwID0gYlsxMl07CiAgICAgICAgICAgIGIxID0gYlsxM107CiAgICAgICAgICAgIGIyID0gYlsxNF07CiAgICAgICAgICAgIGIzID0gYlsxNV07CiAgICAgICAgICAgIHRoaXMubTMwID0gYjAgKiBhMDAgKyBiMSAqIGExMCArIGIyICogYTIwICsgYjMgKiBhMzA7CiAgICAgICAgICAgIHRoaXMubTMxID0gYjAgKiBhMDEgKyBiMSAqIGExMSArIGIyICogYTIxICsgYjMgKiBhMzE7CiAgICAgICAgICAgIHRoaXMubTMyID0gYjAgKiBhMDIgKyBiMSAqIGExMiArIGIyICogYTIyICsgYjMgKiBhMzI7CiAgICAgICAgICAgIHRoaXMubTMzID0gYjAgKiBhMDMgKyBiMSAqIGExMyArIGIyICogYTIzICsgYjMgKiBhMzM7CiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUcmFuc2xhdGUgYSBNYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3Igbm90IHVzaW5nIFNJTUQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdjMgLSBUaGUgZ2l2ZW4gdmVjdG9yIHRvIHRyYW5zbGF0ZSBhbG9uZy4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICB0cmFuc2xhdGVJblBsYWNlKHYzKSB7CiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLl9fZGF0YTsKICAgICAgICAgICAgY29uc3QgeCA9IHYzLng7CiAgICAgICAgICAgIGNvbnN0IHkgPSB2My55OwogICAgICAgICAgICBjb25zdCB6ID0gdjMuejsKICAgICAgICAgICAgYVsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTsKICAgICAgICAgICAgYVsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTsKICAgICAgICAgICAgYVsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07CiAgICAgICAgICAgIGFbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdOwogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpcy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBwb3MgLSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyLgogICAgICAgICAqIEBwYXJhbSB0YXJnZXQgLSBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXQuCiAgICAgICAgICogQHBhcmFtIHVwIC0gVmVjMyBwb2ludGluZyB1cC4KICAgICAgICAgKi8KICAgICAgICBzZXRMb29rQXQocG9zLCB0YXJnZXQsIHVwKSB7CiAgICAgICAgICAgIGNvbnN0IHpBeGlzID0gcG9zLnN1YnRyYWN0KHRhcmdldCk7CiAgICAgICAgICAgIGNvbnN0IHpMZW4gPSB6QXhpcy5sZW5ndGgoKTsKICAgICAgICAgICAgaWYgKHpMZW4gPCBOdW1iZXIuRVBTSUxPTikgewogICAgICAgICAgICAgICAgdGhpcy5zZXRJZGVudGl0eSgpOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHpBeGlzLnNjYWxlSW5QbGFjZSgxLjAgLyB6TGVuKTsKICAgICAgICAgICAgY29uc3QgeEF4aXMgPSB1cC5jcm9zcyh6QXhpcyk7CiAgICAgICAgICAgIGNvbnN0IHhMZW4gPSB4QXhpcy5sZW5ndGgoKTsKICAgICAgICAgICAgaWYgKHhMZW4gPiBOdW1iZXIuRVBTSUxPTikKICAgICAgICAgICAgICAgIHhBeGlzLnNjYWxlSW5QbGFjZSgxLjAgLyB4TGVuKTsKICAgICAgICAgICAgY29uc3QgeUF4aXMgPSB6QXhpcy5jcm9zcyh4QXhpcyk7CiAgICAgICAgICAgIGNvbnN0IHlMZW4gPSB5QXhpcy5sZW5ndGgoKTsKICAgICAgICAgICAgaWYgKHlMZW4gPiBOdW1iZXIuRVBTSUxPTikKICAgICAgICAgICAgICAgIHlBeGlzLnNjYWxlSW5QbGFjZSgxLjAgLyB5TGVuKTsKICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIqLwogICAgICAgICAgICB0aGlzLnNldCh4QXhpcy54LCB4QXhpcy55LCB4QXhpcy56LCAwLCB5QXhpcy54LCB5QXhpcy55LCB5QXhpcy56LCAwLCB6QXhpcy54LCB6QXhpcy55LCB6QXhpcy56LCAwLCBwb3MueCwgcG9zLnksIHBvcy56LCAxKTsKICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmV0dGllci9wcmV0dGllciovCiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlIGFyb3VuZCBhIGdpdmVuIGF4aXMuCiAgICAgICAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6CiAgICAgICAgICoKICAgICAgICAgKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTsKICAgICAgICAgKiAgICAgbWF0NC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkLCBheGlzKTsKICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBheGlzIC0gVGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZC4KICAgICAgICAgKiBAcGFyYW0gcmFkIC0gVGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5LgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHNldFJvdGF0aW9uKGF4aXMsIHJhZCkgewogICAgICAgICAgICBjb25zdCBsZW4gPSBheGlzLmxlbmd0aCgpOwogICAgICAgICAgICBpZiAoTWF0aC5hYnMobGVuKSA8IE51bWJlci5FUFNJTE9OKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCB4ID0gYXhpcy54IC8gbGVuOwogICAgICAgICAgICBjb25zdCB5ID0gYXhpcy55IC8gbGVuOwogICAgICAgICAgICBjb25zdCB6ID0gYXhpcy56IC8gbGVuOwogICAgICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4ocmFkKTsKICAgICAgICAgICAgY29uc3QgYyA9IE1hdGguY29zKHJhZCk7CiAgICAgICAgICAgIGNvbnN0IHQgPSAxIC0gYzsKICAgICAgICAgICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb24KICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMuX19kYXRhOwogICAgICAgICAgICBhWzBdID0geCAqIHggKiB0ICsgYzsKICAgICAgICAgICAgYVsxXSA9IHkgKiB4ICogdCArIHogKiBzOwogICAgICAgICAgICBhWzJdID0geiAqIHggKiB0IC0geSAqIHM7CiAgICAgICAgICAgIGFbM10gPSAwOwogICAgICAgICAgICBhWzRdID0geCAqIHkgKiB0IC0geiAqIHM7CiAgICAgICAgICAgIGFbNV0gPSB5ICogeSAqIHQgKyBjOwogICAgICAgICAgICBhWzZdID0geiAqIHkgKiB0ICsgeCAqIHM7CiAgICAgICAgICAgIGFbN10gPSAwOwogICAgICAgICAgICBhWzhdID0geCAqIHogKiB0ICsgeSAqIHM7CiAgICAgICAgICAgIGFbOV0gPSB5ICogeiAqIHQgLSB4ICogczsKICAgICAgICAgICAgYVsxMF0gPSB6ICogeiAqIHQgKyBjOwogICAgICAgICAgICBhWzExXSA9IDA7CiAgICAgICAgICAgIGFbMTJdID0gMDsKICAgICAgICAgICAgYVsxM10gPSAwOwogICAgICAgICAgICBhWzE0XSA9IDA7CiAgICAgICAgICAgIGFbMTVdID0gMTsKICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXMuCiAgICAgICAgICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6CiAgICAgICAgICoKICAgICAgICAgKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTsKICAgICAgICAgKiAgICAgbWF0NC5yb3RhdGVYKGRlc3QsIGRlc3QsIHJhZCk7CiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gcmFkIC0gVGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5LgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHNldFhSb3RhdGlvbihyYWQpIHsKICAgICAgICAgICAgY29uc3QgcyA9IE1hdGguc2luKHJhZCk7CiAgICAgICAgICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhyYWQpOwogICAgICAgICAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uCiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLl9fZGF0YTsKICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIqLwogICAgICAgICAgICBhWzBdID0gMTsKICAgICAgICAgICAgYVsxXSA9IDA7CiAgICAgICAgICAgIGFbMl0gPSAwOwogICAgICAgICAgICBhWzNdID0gMDsKICAgICAgICAgICAgYVs0XSA9IDA7CiAgICAgICAgICAgIGFbNV0gPSBjOwogICAgICAgICAgICBhWzZdID0gczsKICAgICAgICAgICAgYVs3XSA9IDA7CiAgICAgICAgICAgIGFbOF0gPSAwOwogICAgICAgICAgICBhWzldID0gLXM7CiAgICAgICAgICAgIGFbMTBdID0gYzsKICAgICAgICAgICAgYVsxMV0gPSAwOwogICAgICAgICAgICBhWzEyXSA9IDA7CiAgICAgICAgICAgIGFbMTNdID0gMDsKICAgICAgICAgICAgYVsxNF0gPSAwOwogICAgICAgICAgICBhWzE1XSA9IDE7CiAgICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgcHJldHRpZXIvcHJldHRpZXIqLwogICAgICAgICAgICByZXR1cm4gdGhpczsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpcy4KICAgICAgICAgKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKToKICAgICAgICAgKgogICAgICAgICAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpOwogICAgICAgICAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKTsKICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSByYWQgLSBUaGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnkuCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0WVJvdGF0aW9uKHJhZCkgewogICAgICAgICAgICBjb25zdCBzID0gTWF0aC5zaW4ocmFkKTsKICAgICAgICAgICAgY29uc3QgYyA9IE1hdGguY29zKHJhZCk7CiAgICAgICAgICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb24KICAgICAgICAgICAgY29uc3QgYSA9IHRoaXMuX19kYXRhOwogICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmV0dGllci9wcmV0dGllciovCiAgICAgICAgICAgIGFbMF0gPSBjOwogICAgICAgICAgICBhWzFdID0gMDsKICAgICAgICAgICAgYVsyXSA9IC1zOwogICAgICAgICAgICBhWzNdID0gMDsKICAgICAgICAgICAgYVs0XSA9IDA7CiAgICAgICAgICAgIGFbNV0gPSAxOwogICAgICAgICAgICBhWzZdID0gMDsKICAgICAgICAgICAgYVs3XSA9IDA7CiAgICAgICAgICAgIGFbOF0gPSBzOwogICAgICAgICAgICBhWzldID0gMDsKICAgICAgICAgICAgYVsxMF0gPSBjOwogICAgICAgICAgICBhWzExXSA9IDA7CiAgICAgICAgICAgIGFbMTJdID0gMDsKICAgICAgICAgICAgYVsxM10gPSAwOwogICAgICAgICAgICBhWzE0XSA9IDA7CiAgICAgICAgICAgIGFbMTVdID0gMTsKICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmV0dGllci9wcmV0dGllciovCiAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzLgogICAgICAgICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOgogICAgICAgICAqCiAgICAgICAgICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7CiAgICAgICAgICogICAgIG1hdDQucm90YXRlWihkZXN0LCBkZXN0LCByYWQpOwogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHJhZCAtIFRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieS4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzZXRaUm90YXRpb24ocmFkKSB7CiAgICAgICAgICAgIGNvbnN0IHMgPSBNYXRoLnNpbihyYWQpOwogICAgICAgICAgICBjb25zdCBjID0gTWF0aC5jb3MocmFkKTsKICAgICAgICAgICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvbgogICAgICAgICAgICBjb25zdCBhID0gdGhpcy5fX2RhdGE7CiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHByZXR0aWVyL3ByZXR0aWVyKi8KICAgICAgICAgICAgYVswXSA9IGM7CiAgICAgICAgICAgIGFbMV0gPSBzOwogICAgICAgICAgICBhWzJdID0gMDsKICAgICAgICAgICAgYVszXSA9IDA7CiAgICAgICAgICAgIGFbNF0gPSAtczsKICAgICAgICAgICAgYVs1XSA9IGM7CiAgICAgICAgICAgIGFbNl0gPSAwOwogICAgICAgICAgICBhWzddID0gMDsKICAgICAgICAgICAgYVs4XSA9IDA7CiAgICAgICAgICAgIGFbOV0gPSAwOwogICAgICAgICAgICBhWzEwXSA9IDE7CiAgICAgICAgICAgIGFbMTFdID0gMDsKICAgICAgICAgICAgYVsxMl0gPSAwOwogICAgICAgICAgICBhWzEzXSA9IDA7CiAgICAgICAgICAgIGFbMTRdID0gMDsKICAgICAgICAgICAgYVsxNV0gPSAxOwogICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIHByZXR0aWVyL3ByZXR0aWVyKi8KICAgICAgICAgICAgcmV0dXJuIHRoaXM7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRyYW5zZm9ybXMgdGhlIFZlYzQgd2l0aCBhIE1hdDQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmVjIC0gVGhlIHZlYyB2YWx1ZS4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJuIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjNC4KICAgICAgICAgKi8KICAgICAgICB0cmFuc2Zvcm1WZWM0KHZlYykgewogICAgICAgICAgICBjb25zdCBhID0gdGhpcy5fX2RhdGE7CiAgICAgICAgICAgIGNvbnN0IHggPSB2ZWMueDsKICAgICAgICAgICAgY29uc3QgeSA9IHZlYy55OwogICAgICAgICAgICBjb25zdCB6ID0gdmVjLno7CiAgICAgICAgICAgIGNvbnN0IHcgPSB2ZWMudDsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWM0KGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdICogdywgYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM10gKiB3LCBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF0gKiB3LCBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV0gKiB3KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVHJhbnNmb3JtcyB0aGUgVmVjMyB3aXRoIGEgTWF0NC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB2ZWMgLSBUaGUgdmVjIHZhbHVlLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm4gdGhlIHJlc3VsdCBhcyBhIG5ldyBWZWMzLgogICAgICAgICAqLwogICAgICAgIHRyYW5zZm9ybVZlYzModmVjKSB7CiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLl9fZGF0YTsKICAgICAgICAgICAgY29uc3QgeCA9IHZlYy54OwogICAgICAgICAgICBjb25zdCB5ID0gdmVjLnk7CiAgICAgICAgICAgIGNvbnN0IHogPSB2ZWMuejsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdLCBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXSwgYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUm90YXRlcyBhIGdpdmVuIGBWZWMzYCBhbmQgdGhlIHJlc3VsdCBpcyByZXR1cm5lZCBhcyBhIG5ldyBgVmVjM2AsIGFwcGx5aW5nIG9ubHkgdGhlIHRvcCBsZWZ0IGNvbXBvbmVudHMgb2YgdGhlIG1hdHJpeCwgc28gbm90IGFwcGx5aW5nIGFueSB0cmFuc2xhdGlvbi4KICAgICAgICAgKiBAcGFyYW0gdmVjIC0gVGhlIHZlYyB2YWx1ZS4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJuIHRoZSByZXN1bHQgYXMgYSBuZXcgVmVjMy4KICAgICAgICAgKi8KICAgICAgICByb3RhdGVWZWMzKHZlYykgewogICAgICAgICAgICBjb25zdCBhID0gdGhpcy5fX2RhdGE7CiAgICAgICAgICAgIGNvbnN0IHggPSB2ZWMueDsKICAgICAgICAgICAgY29uc3QgeSA9IHZlYy55OwogICAgICAgICAgICBjb25zdCB6ID0gdmVjLno7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyhhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHosIGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiwgYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldCB0aGUgcGVyc3BlY3RpdmUgZnJvbSBhIE1hdDQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gZm92WSAtIFRoZSBmb3ZZIHZhbHVlLgogICAgICAgICAqIEBwYXJhbSBhc3BlY3QgLSBUaGUgYXNwZWN0IHZhbHVlLgogICAgICAgICAqIEBwYXJhbSBuZWFyIC0gVGhlIG5lYXIgdmFsdWUuCiAgICAgICAgICogQHBhcmFtIGZhciAtIFRoZSBmYXIgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0UGVyc3BlY3RpdmVNYXRyaXgoZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHsKICAgICAgICAgICAgY29uc3QgZiA9IE1hdGgudGFuKE1hdGguUEkgKiAwLjUgLSAwLjUgKiBmb3Z5KTsKICAgICAgICAgICAgY29uc3QgcmFuZ2VJbnYgPSAxLjAgLyAobmVhciAtIGZhcik7CiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIHByZXR0aWVyL3ByZXR0aWVyKi8KICAgICAgICAgICAgdGhpcy5zZXQoZiAvIGFzcGVjdCwgMCwgMCwgMCwgMCwgZiwgMCwgMCwgMCwgMCwgKG5lYXIgKyBmYXIpICogcmFuZ2VJbnYsIC0xLCAwLCAwLCBuZWFyICogZmFyICogcmFuZ2VJbnYgKiAyLCAwKTsKICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmV0dGllci9wcmV0dGllciovCiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENhbGN1bGF0ZXMgdGhlIG9ydGhvZ3JhcGhpYyBtYXRyaXggYW5kIHNldHMgdGhlIHN0YXRlIG9mIHRoZSBNYXQ0IGNsYXNzCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gbGVmdCAtIFRoZSBsZWZ0IHZhbHVlLgogICAgICAgICAqIEBwYXJhbSByaWdodCAtIFRoZSByaWdodCB2YWx1ZS4KICAgICAgICAgKiBAcGFyYW0gYm90dG9tIC0gVGhlIGJvdHRvbSB2YWx1ZS4KICAgICAgICAgKiBAcGFyYW0gdG9wIC0gVGhlIHRvcCB2YWx1ZS4KICAgICAgICAgKiBAcGFyYW0gbmVhciAtIFRoZSBuZWFyIHZhbHVlLgogICAgICAgICAqIEBwYXJhbSBmYXIgLSBUaGUgZmFyIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHNldE9ydGhvZ3JhcGhpY01hdHJpeChsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikgewogICAgICAgICAgICBjb25zdCBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KTsKICAgICAgICAgICAgY29uc3QgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCk7CiAgICAgICAgICAgIGNvbnN0IG5mID0gMSAvIChuZWFyIC0gZmFyKTsKICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIqLwogICAgICAgICAgICB0aGlzLnNldCgtMiAqIGxyLCAwLCAwLCAwLCAwLCAtMiAqIGJ0LCAwLCAwLCAwLCAwLCAyICogbmYsIDAsIChsZWZ0ICsgcmlnaHQpICogbHIsICh0b3AgKyBib3R0b20pICogYnQsIChmYXIgKyBuZWFyKSAqIG5mLCAxKTsKICAgICAgICAgICAgLyogZXNsaW50LWVuYWJsZSBwcmV0dGllci9wcmV0dGllciovCiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldCB0aGUgTWF0cml4IHRvIGJlIGEgc2NhbGUgbWF0cml4LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHggLSBUaGUgeCB2YWx1ZS4KICAgICAgICAgKiBAcGFyYW0geSAtIFRoZSB5IHZhbHVlLgogICAgICAgICAqIEBwYXJhbSB6IC0gVGhlIHogdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0U2NhbGUoeCwgeSwgeikgewogICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBwcmV0dGllci9wcmV0dGllciovCiAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgVmVjMykgewogICAgICAgICAgICAgICAgdGhpcy5zZXQoeC54LCAwLCAwLCAwLCAwLCB4LnksIDAsIDAsIDAsIDAsIHgueiwgMCwgMCwgMCwgMCwgMSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLnNldCh4LCAwLCAwLCAwLCAwLCB5LCAwLCAwLCAwLCAwLCB6LCAwLCAwLCAwLCAwLCAxKTsKICAgICAgICAgICAgfQogICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIHByZXR0aWVyL3ByZXR0aWVyKi8KICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVHJhbnNmb3JtcyBhIDN4NCBtYXRyaXggaW50byBhIDR4NCBtYXRyaXggYW5kIHNldCB0aGUgcmVzdWx0IHRvIHRoZSBNYXRoNCBzdGF0ZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBtM3g0IC0gVGhlIG0zeDQgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0RnJvbU1hdDN4NEFycmF5KG0zeDQpIHsKICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgcHJldHRpZXIvcHJldHRpZXIqLwogICAgICAgICAgICB0aGlzLnNldChtM3g0WzBdLCBtM3g0WzFdLCBtM3g0WzJdLCAwLCBtM3g0WzNdLCBtM3g0WzRdLCBtM3g0WzVdLCAwLCBtM3g0WzZdLCBtM3g0WzddLCBtM3g0WzhdLCAwLCBtM3g0WzldLCBtM3g0WzEwXSwgbTN4NFsxMV0sIDEpOwogICAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlIHByZXR0aWVyL3ByZXR0aWVyKi8KICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ2xvbmVzIHRoaXMgTWF0NCByZXR1cm5pbmcgYSBuZXcgaW5zdGFuY2UuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBNYXQ0LgogICAgICAgICAqLwogICAgICAgIGNsb25lKCkgewogICAgICAgICAgICByZXR1cm4gbmV3IE1hdDQodGhpcy5fX2RhdGFbMF0sIHRoaXMuX19kYXRhWzFdLCB0aGlzLl9fZGF0YVsyXSwgdGhpcy5fX2RhdGFbM10sIHRoaXMuX19kYXRhWzRdLCB0aGlzLl9fZGF0YVs1XSwgdGhpcy5fX2RhdGFbNl0sIHRoaXMuX19kYXRhWzddLCB0aGlzLl9fZGF0YVs4XSwgdGhpcy5fX2RhdGFbOV0sIHRoaXMuX19kYXRhWzEwXSwgdGhpcy5fX2RhdGFbMTFdLCB0aGlzLl9fZGF0YVsxMl0sIHRoaXMuX19kYXRhWzEzXSwgdGhpcy5fX2RhdGFbMTRdLCB0aGlzLl9fZGF0YVsxNV0pOwogICAgICAgIH0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8KICAgICAgICAvLyBQZXJzaXN0ZW5jZQogICAgICAgIC8qKgogICAgICAgICAqIENvbnZlcnRzIHRoaXMgVmVjMyB0byBhIHN0cmluZyBpbiBKU09OIGZvcm1hdC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHRvU3RyaW5nKCkgewogICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcAogICAgICAgICAgICByZXR1cm4gU3RyaW5nRnVuY3Rpb25zLnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiB7RmxvYXQzMkFycmF5fSAtIFRoZSBqc29uIG9iamVjdC4KICAgICAgICAgKi8KICAgICAgICB0b0pTT04oKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBqc29uIC0gVGhlIGpzb24gcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgZnJvbUpTT04oanNvbikgewogICAgICAgICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoanNvbik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIExvYWRzIHRoZSBzdGF0ZSBvZiB0aGUgdmFsdWUgZnJvbSBhIGJpbmFyeSByZWFkZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICByZWFkQmluYXJ5KHJlYWRlcikgewogICAgICAgICAgICB0aGlzLl9fZGF0YSA9IHJlYWRlci5sb2FkRmxvYXQzMkFycmF5KDE2KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyBjdXJyZW50IE1hdGggdHlwZSBkYXRhIGFzIGFycmF5LiBPZnRlbiB1c2VkIHRvIHBhc3MgdHlwZXMgdG8gdGhlIEdQVS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSByZXN1bHQgYXMgYW4gYXJyYXkuCiAgICAgICAgICovCiAgICAgICAgYXNBcnJheSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhOwogICAgICAgIH0KICAgIH0KCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqLwogICAgLyoqCiAgICAgKiBDbGFzcyByZXByZXNlbnRpbmcgYSBxdWF0ZXJuaW9uLiBRdWF0ZXJuaW9ucyBhcmUgdXNlZCB0byByZXByZXNlbnQgMyBkaW1lbnNpb25hbCByb3RhdGlvbnMuCiAgICAgKgogICAgICogV2hpbGUgUXVhdGVybmlvbnMgYXJlIGRpZmZpY3VsdCB0byB1bmRlcnN0YW5kIHRoZXkgaGF2ZSBpbXBvcnRhbnQgbWF0aGVtYXRpY2FsIHByb3BlcnRpZXMgdGhhdCBtYWtlIHRoZW0gdmVyeSB1c2VmdWwgaW4gM2QgZW5naW5lcy4KICAgICAqIFRoZXkgY2FuIGJlIGRpcmVjdGx5IG11bHRpcGxpZWQgdG9nZXRoZXIgaW4gdGhlIHNhbWUgd2FzIGFzIG1hdHJpY2VzLgogICAgICogVGhleSBjYW4gYmUgaW50ZXJwb2xhdGVkIGZyb20gb25lIHZhbHVlIHRvIGFub3RoZXIgd2hpbGUgbWFpbnRhaW5pbmcgY29uc3RhbnQgYW5ndWxhciB2ZWxvY2l0eS4KICAgICAqIFRoZXkgY2FuIGJlIGNvbnZlcnRlZCB0byBvdGhlciBtb3JlIGVhc2lseSB1bmRlcnN0b29kIHJlcHJlc2VudGF0aW9ucyBzdWNoIGFzIEV1bGVyQW5nbGVzIG9yIE1hdHJpY2VzLgogICAgICoKCiAgICAgKi8KICAgIGNsYXNzIFF1YXQgewogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZXMgYSBxdWF0ZXJuaW9uLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHggLSBUaGUgYW5nbGUgb2YgdGhlIHggYXhpcy4gRGVmYXVsdCBpcyAwLgogICAgICAgICAqIEBwYXJhbSB5IC0gVGhlIGFuZ2xlIG9mIHRoZSB5IGF4aXMuIERlZmF1bHQgaXMgMC4KICAgICAgICAgKiBAcGFyYW0geiAtIFRoZSBhbmdsZSBvZiB0aGUgeiBheGlzLiBEZWZhdWx0IGlzIDAuCiAgICAgICAgICogQHBhcmFtIHcgLSBUaGUgdyB2YWx1ZS4gRGVmYXVsdCBpcyAxLgogICAgICAgICAqLwogICAgICAgIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgeiA9IDAsIHcgPSAxKSB7CiAgICAgICAgICAgIGlmICh4IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YSA9IHg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSBpZiAoeCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgbmV3IFZlYzQobmV3IEZsb2F0MzJBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIDQpKWApOwogICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0geDsKICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVPZmZzZXQgPSB5OwogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KGJ1ZmZlciwgYnl0ZU9mZnNldCwgNCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7CiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbMF0gPSAwOwogICAgICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhWzFdID0gMDsKICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVsyXSA9IDA7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbM10gPSAxOwogICAgICAgICAgICAgICAgICAgIHRoaXMuZnJvbUpTT04oeCk7CiAgICAgICAgICAgICAgICAgICAgLy8gIGZvciAoY29uc3Qga2V5IGluIHgpIHsKICAgICAgICAgICAgICAgICAgICAvLyAgaWYgKEFycmF5LmlzQXJyYXkoeFtrZXldKSkgdGhpc1trZXldLmNhbGwodGhpcywgLi4ueFtrZXldKQogICAgICAgICAgICAgICAgICAgIC8vICBlbHNlIHRoaXNba2V5XS5jYWxsKHRoaXMsIHhba2V5XSkKICAgICAgICAgICAgICAgICAgICAvL30KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhWzBdID0geDsKICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVsxXSA9IHk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbMl0gPSB6OwogICAgICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhWzNdID0gdzsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIGB4YCBheGlzIHJvdGF0aW9uLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIHggYXhpcyByb3RhdGlvbi4KICAgICAgICAgKi8KICAgICAgICBnZXQgeCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzBdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIGB4YCBheGlzIHJvdGF0aW9uLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IHgodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzBdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIGB5YCBheGlzIHJvdGF0aW9uLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIHkgYXhpcyByb3RhdGlvbi4KICAgICAgICAgKi8KICAgICAgICBnZXQgeSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzFdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIGB5YCBheGlzIHJvdGF0aW9uLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IHkodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzFdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIGB6YCBheGlzIHJvdGF0aW9uLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIHogYXhpcyByb3RhdGlvbi4KICAgICAgICAgKi8KICAgICAgICBnZXQgeigpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhWzJdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXR0ZXIgZm9yIGB6YCBheGlzIHJvdGF0aW9uLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHZhbCAtIFRoZSB2YWwgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0IHoodmFsKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzJdID0gdmFsOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIGB3YCB2YWx1ZS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSB3IHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldCB3KCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbM107CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmb3IgYHdgLgogICAgICAgICAqIEBwYXJhbSB2YWwgLSBUaGUgdmFsIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIHNldCB3KHZhbCkgewogICAgICAgICAgICB0aGlzLl9fZGF0YVszXSA9IHZhbDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0dGVyIGZyb20gc2NhbGFyIGNvbXBvbmVudHMuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0geCAtIFRoZSB4IGF4aXMgcm90YXRpb24uCiAgICAgICAgICogQHBhcmFtIHkgIC0gVGhlIHkgYXhpcyByb3RhdGlvbi4KICAgICAgICAgKiBAcGFyYW0geiAgLSBUaGUgeiBheGlzIHJvdGF0aW9uLgogICAgICAgICAqIEBwYXJhbSB3ICAtIFRoZSB3IHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHNldCh4LCB5LCB6LCB3KSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzBdID0geDsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMV0gPSB5OwogICAgICAgICAgICB0aGlzLl9fZGF0YVsyXSA9IHo7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzNdID0gdzsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIFF1YXQgY2xhc3MgdXNpbmcgYSBGbG9hdDMyQXJyYXkuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gZmxvYXQzMkFycmF5IC0gVGhlIGZsb2F0MzJBcnJheSB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzZXREYXRhQXJyYXkoZmxvYXQzMkFycmF5KSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhID0gZmxvYXQzMkFycmF5OyAvLyBUT0RPOiBhZGRlZCBjYXN0CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHRlciBmcm9tIGFub3RoZXIgdmVjdG9yLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIHZlY3RvciB0byBzZXQgZnJvbS4KICAgICAgICAgKi8KICAgICAgICBzZXRGcm9tT3RoZXIob3RoZXIpIHsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMF0gPSBvdGhlci54OwogICAgICAgICAgICB0aGlzLl9fZGF0YVsxXSA9IG90aGVyLnk7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzJdID0gb3RoZXIuejsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbM10gPSBvdGhlci53OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXQgdGhpcyBRdWF0IGZyb20gYSBldWxlciByb3RhdGlvbi4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBldWxlckFuZ2xlcyAtIFRoZSBldWxlciBhbmdsZXMgcm90YXRpb24uCiAgICAgICAgICovCiAgICAgICAgc2V0RnJvbUV1bGVyQW5nbGVzKGV1bGVyQW5nbGVzKSB7CiAgICAgICAgICAgIGNvbnN0IG9yZGVyZWQgPSBuZXcgVmVjMygpOwogICAgICAgICAgICBzd2l0Y2ggKGV1bGVyQW5nbGVzLm9yZGVyKSB7CiAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgLy8gJ1hZWicKICAgICAgICAgICAgICAgICAgICBvcmRlcmVkLnNldChldWxlckFuZ2xlcy54LCAtZXVsZXJBbmdsZXMueSwgZXVsZXJBbmdsZXMueik7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgICAgICAgLy8gJ1laWCcKICAgICAgICAgICAgICAgICAgICBvcmRlcmVkLnNldChldWxlckFuZ2xlcy55LCAtZXVsZXJBbmdsZXMueiwgZXVsZXJBbmdsZXMueCk7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgICAgICAgLy8gJ1pYWScKICAgICAgICAgICAgICAgICAgICBvcmRlcmVkLnNldChldWxlckFuZ2xlcy56LCAtZXVsZXJBbmdsZXMueCwgZXVsZXJBbmdsZXMueSk7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlIDM6CiAgICAgICAgICAgICAgICAgICAgLy8gJ1haWScKICAgICAgICAgICAgICAgICAgICBvcmRlcmVkLnNldChldWxlckFuZ2xlcy54LCBldWxlckFuZ2xlcy56LCBldWxlckFuZ2xlcy55KTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICAgICAgICAvLyAnWllYJwogICAgICAgICAgICAgICAgICAgIG9yZGVyZWQuc2V0KGV1bGVyQW5nbGVzLnosIGV1bGVyQW5nbGVzLnksIGV1bGVyQW5nbGVzLngpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSA1OgogICAgICAgICAgICAgICAgICAgIC8vICdZWFonCiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZC5zZXQoZXVsZXJBbmdsZXMueSwgZXVsZXJBbmdsZXMueCwgZXVsZXJBbmdsZXMueik7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBFdWxlckFuZ2xlcyBvcmRlcjogJHtldWxlckFuZ2xlcy5vcmRlcn1gKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCB0aSA9IG9yZGVyZWQueCAqIDAuNTsKICAgICAgICAgICAgY29uc3QgdGogPSBvcmRlcmVkLnkgKiAwLjU7CiAgICAgICAgICAgIGNvbnN0IHRrID0gb3JkZXJlZC56ICogMC41OwogICAgICAgICAgICBjb25zdCBjaSA9IE1hdGguY29zKHRpKTsKICAgICAgICAgICAgY29uc3QgY2ogPSBNYXRoLmNvcyh0aik7CiAgICAgICAgICAgIGNvbnN0IGNrID0gTWF0aC5jb3ModGspOwogICAgICAgICAgICBjb25zdCBzaSA9IE1hdGguc2luKHRpKTsKICAgICAgICAgICAgY29uc3Qgc2ogPSBNYXRoLnNpbih0aik7CiAgICAgICAgICAgIGNvbnN0IHNrID0gTWF0aC5zaW4odGspOwogICAgICAgICAgICBjb25zdCBjYyA9IGNpICogY2s7CiAgICAgICAgICAgIGNvbnN0IGNzID0gY2kgKiBzazsKICAgICAgICAgICAgY29uc3Qgc2MgPSBzaSAqIGNrOwogICAgICAgICAgICBjb25zdCBzcyA9IHNpICogc2s7CiAgICAgICAgICAgIGNvbnN0IGFpID0gY2ogKiBzYyAtIHNqICogY3M7CiAgICAgICAgICAgIGNvbnN0IGFqID0gY2ogKiBzcyArIHNqICogY2M7CiAgICAgICAgICAgIGNvbnN0IGFrID0gY2ogKiBjcyAtIHNqICogc2M7CiAgICAgICAgICAgIHRoaXMudyA9IGNqICogY2MgKyBzaiAqIHNzOwogICAgICAgICAgICBzd2l0Y2ggKGV1bGVyQW5nbGVzLm9yZGVyKSB7CiAgICAgICAgICAgICAgICBjYXNlIDA6CiAgICAgICAgICAgICAgICAgICAgLy8gJyBYWVonCiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gYWk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy55ID0gLWFqOwogICAgICAgICAgICAgICAgICAgIHRoaXMueiA9IGFrOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgIC8vICdZWlgnCiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gYWs7CiAgICAgICAgICAgICAgICAgICAgdGhpcy55ID0gYWk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy56ID0gLWFqOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICAgIC8vICdaWFknCiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gLWFqOwogICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IGFrOwogICAgICAgICAgICAgICAgICAgIHRoaXMueiA9IGFpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAzOgogICAgICAgICAgICAgICAgICAgIC8vICdYWlknCiAgICAgICAgICAgICAgICAgICAgdGhpcy54ID0gYWk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy55ID0gYWs7CiAgICAgICAgICAgICAgICAgICAgdGhpcy56ID0gYWo7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlIDQ6CiAgICAgICAgICAgICAgICAgICAgLy8gJ1pZWCcKICAgICAgICAgICAgICAgICAgICB0aGlzLnggPSBhazsKICAgICAgICAgICAgICAgICAgICB0aGlzLnkgPSBhajsKICAgICAgICAgICAgICAgICAgICB0aGlzLnogPSBhaTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgNToKICAgICAgICAgICAgICAgICAgICAvLyAnWVhaJwogICAgICAgICAgICAgICAgICAgIHRoaXMueCA9IGFqOwogICAgICAgICAgICAgICAgICAgIHRoaXMueSA9IGFpOwogICAgICAgICAgICAgICAgICAgIHRoaXMueiA9IGFrOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgRXVsZXJBbmdsZXMgb3JkZXI6ICR7ZXVsZXJBbmdsZXMub3JkZXJ9YCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ29udmVydHMgUXVhdCB0byBhbiBFdWxlckFuZ2xlcwogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHJvdGF0aW9uT3JkZXIgLSBUaGUgb3JkZXIgaW4gd2hpY2ggdGhlIHJvdGF0aW9ucyBhcmUgYXBwbGllZC4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICB0b0V1bGVyQW5nbGVzKHJvdGF0aW9uT3JkZXIpIHsKICAgICAgICAgICAgY29uc3Qgb3JkZXJlZCA9IG5ldyBWZWMzKCk7CiAgICAgICAgICAgIHN3aXRjaCAocm90YXRpb25PcmRlcikgewogICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIC8qICcgWFlaJyAqLwogICAgICAgICAgICAgICAgICAgIG9yZGVyZWQuc2V0KHRoaXMueiwgdGhpcy54LCB0aGlzLnkpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgIC8qICdZWlgnICovCiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZC5zZXQodGhpcy54LCB0aGlzLnksIHRoaXMueik7CiAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgICAgICAgLyogJ1pYWScgKi8KICAgICAgICAgICAgICAgICAgICBvcmRlcmVkLnNldCh0aGlzLnksIHRoaXMueiwgdGhpcy54KTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgICAgICAvKiAnWFpZJyAqLwogICAgICAgICAgICAgICAgICAgIG9yZGVyZWQuc2V0KHRoaXMueSwgLXRoaXMueCwgdGhpcy56KTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgNDoKICAgICAgICAgICAgICAgICAgICAvKiAnWllYJyAqLwogICAgICAgICAgICAgICAgICAgIG9yZGVyZWQuc2V0KHRoaXMueCwgLXRoaXMueiwgdGhpcy55KTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgNToKICAgICAgICAgICAgICAgICAgICAvKiAnWVhaJyAqLwogICAgICAgICAgICAgICAgICAgIG9yZGVyZWQuc2V0KHRoaXMueiwgLXRoaXMueSwgdGhpcy54KTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGRlZmF1bHQ6CiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJvdGF0aW9uIG9yZGVyOicgKyByb3RhdGlvbk9yZGVyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBldWxlciA9IG5ldyBWZWMzKCk7CiAgICAgICAgICAgIGNvbnN0IHRlc3QgPSBvcmRlcmVkLnggKiBvcmRlcmVkLnkgKyBvcmRlcmVkLnogKiB0aGlzLnc7CiAgICAgICAgICAgIGlmICh0ZXN0ID4gMC40OTk5OSkgewogICAgICAgICAgICAgICAgLy8gc2luZ3VsYXJpdHkgYXQgbm9ydGggcG9sZQogICAgICAgICAgICAgICAgZXVsZXIueSA9IDIuMCAqIE1hdGguYXRhbjIob3JkZXJlZC54LCB0aGlzLncpOwogICAgICAgICAgICAgICAgZXVsZXIueiA9IE1hdGguUEkgKiAwLjU7CiAgICAgICAgICAgICAgICBldWxlci54ID0gMC4wOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgaWYgKHRlc3QgPCAtMC40OTk5OSkgewogICAgICAgICAgICAgICAgLy8gc2luZ3VsYXJpdHkgYXQgc291dGggcG9sZQogICAgICAgICAgICAgICAgZXVsZXIueSA9IC0yLjAgKiBNYXRoLmF0YW4yKG9yZGVyZWQueCwgdGhpcy53KTsKICAgICAgICAgICAgICAgIGV1bGVyLnogPSBNYXRoLlBJICogLTAuNTsKICAgICAgICAgICAgICAgIGV1bGVyLnggPSAwLjA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBjb25zdCBzcXggPSBvcmRlcmVkLnggKiBvcmRlcmVkLng7CiAgICAgICAgICAgICAgICBjb25zdCBzcXkgPSBvcmRlcmVkLnkgKiBvcmRlcmVkLnk7CiAgICAgICAgICAgICAgICBjb25zdCBzcXogPSBvcmRlcmVkLnogKiBvcmRlcmVkLno7CiAgICAgICAgICAgICAgICBldWxlci55ID0gTWF0aC5hdGFuMigyLjAgKiBvcmRlcmVkLnkgKiB0aGlzLncgLSAyLjAgKiBvcmRlcmVkLnggKiBvcmRlcmVkLnosIDEuMCAtIDIuMCAqIHNxeSAtIDIuMCAqIHNxeik7CiAgICAgICAgICAgICAgICBldWxlci56ID0gTWF0aC5hc2luKDIuMCAqIHRlc3QpOwogICAgICAgICAgICAgICAgZXVsZXIueCA9IE1hdGguYXRhbjIoMi4wICogb3JkZXJlZC54ICogdGhpcy53IC0gMi4wICogb3JkZXJlZC55ICogb3JkZXJlZC56LCAxLjAgLSAyLjAgKiBzcXggLSAyLjAgKiBzcXopOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHN3aXRjaCAocm90YXRpb25PcmRlcikgewogICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIC8qICcgWFlaJyAqLwogICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXVsZXJBbmdsZXMoZXVsZXIueSwgZXVsZXIueiwgZXVsZXIueCwgcm90YXRpb25PcmRlcik7CiAgICAgICAgICAgICAgICBjYXNlIDE6CiAgICAgICAgICAgICAgICAgICAgLyogJ1laWCcgKi8KICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV1bGVyQW5nbGVzKGV1bGVyLngsIGV1bGVyLnksIGV1bGVyLnosIHJvdGF0aW9uT3JkZXIpOwogICAgICAgICAgICAgICAgY2FzZSAyOgogICAgICAgICAgICAgICAgICAgIC8qICdaWFknICovCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdWxlckFuZ2xlcyhldWxlci56LCBldWxlci54LCBldWxlci55LCByb3RhdGlvbk9yZGVyKTsKICAgICAgICAgICAgICAgIGNhc2UgMzoKICAgICAgICAgICAgICAgICAgICAvKiAnWFpZJyAqLwogICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXVsZXJBbmdsZXMoLWV1bGVyLnksIGV1bGVyLngsIGV1bGVyLnosIHJvdGF0aW9uT3JkZXIpOwogICAgICAgICAgICAgICAgY2FzZSA0OgogICAgICAgICAgICAgICAgICAgIC8qICdaWVgnICovCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBFdWxlckFuZ2xlcyhldWxlci54LCBldWxlci56LCAtZXVsZXIueSwgcm90YXRpb25PcmRlcik7CiAgICAgICAgICAgICAgICBjYXNlIDU6CiAgICAgICAgICAgICAgICAgICAgLyogJ1lYWicgKi8KICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV1bGVyQW5nbGVzKGV1bGVyLnosIC1ldWxlci55LCBldWxlci54LCByb3RhdGlvbk9yZGVyKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXQgdGhpcyBRdWF0IHRvIGEgcm90YXRpb24gZGVmaW5lZCBieSBhbiBheGlzIGFuZCBhbiBhbmdsZSAoaW4gcmFkaWFucykuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gYXhpcyAtIFRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGUuCiAgICAgICAgICogQHBhcmFtIGFuZ2xlIC0gVGhlIGFuZ2xlIHRvIHJvdGF0ZQogICAgICAgICAqLwogICAgICAgIHNldEZyb21BeGlzQW5kQW5nbGUoYXhpcywgYW5nbGUpIHsKICAgICAgICAgICAgY29uc3QgaGFsZkFuZ2xlID0gYW5nbGUgLyAyLjA7CiAgICAgICAgICAgIGNvbnN0IHZlYyA9IGF4aXMubm9ybWFsaXplKCkuc2NhbGUoTWF0aC5zaW4oaGFsZkFuZ2xlKSk7CiAgICAgICAgICAgIHRoaXMuc2V0KHZlYy54LCB2ZWMueSwgdmVjLnosIE1hdGguY29zKGhhbGZBbmdsZSkpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgUXVhdCB0byBsb29rIGluIGEgcGFydGljdWxhciBkaXJlY3Rpb24gYWxvbmcgdGhlIHogYXhpcy4KICAgICAgICAgKiA+IFRoZSBjYW1lcmEgbG9va3MgZG93biB0aGUgbmVnYXRpdmUgeiBheGlzLCBzbyB0byBzZXQgYSByb3RhdGlvbiB2YWx1ZQogICAgICAgICAqID4gZm9yIHRoZSBjYW1lcmEsIHJlbWVtYmVyIHRvIG5lZ2F0ZSB0aGUgZGlyZWN0aW9uIHZlY3Rvci4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBkaXIgLSBUaGUgZGlyZWN0aW9uIHZhbHVlLgogICAgICAgICAqIEBwYXJhbSB1cCAtIFRoZSB1cCB2ZWN0b3IuCiAgICAgICAgICovCiAgICAgICAgc2V0RnJvbURpcmVjdGlvbkFuZFVwdmVjdG9yKGRpciwgdXApIHsKICAgICAgICAgICAgY29uc3QgbWF0MyA9IG5ldyBNYXQzKCk7CiAgICAgICAgICAgIG1hdDMuc2V0RnJvbURpcmVjdGlvbkFuZFVwdmVjdG9yKGRpciwgdXApOwogICAgICAgICAgICB0aGlzLnNldEZyb21NYXQzKG1hdDMpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgYFF1YXRgIGZyb20gdHdvIGBWZWMzYC4gVGhlIHF1YXRlcm5pb24gd291bGQgdGhlbiByZXByZXNlbnQgdGhlIHJvdGF0aW9uIGZyb20gdjAgdG8gdjEgaW4gM2Qgc3BhY2UuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdjAgLSBUaGUgdjAgdW5pdCB2ZWN0b3IuCiAgICAgICAgICogQHBhcmFtIHYxIC0gVGhlIHYxIHVuaXQgdmVjdG9yLgogICAgICAgICAqLwogICAgICAgIHNldEZyb20yVmVjdG9ycyh2MCwgdjEpIHsKICAgICAgICAgICAgY29uc3QgYyA9IHYwLmNyb3NzKHYxKTsKICAgICAgICAgICAgY29uc3QgZCA9IHYwLmRvdCh2MSk7CiAgICAgICAgICAgIGNvbnN0IHMgPSBNYXRoLnNxcnQoKDEgKyBkKSAqIDIpOwogICAgICAgICAgICAvLyB0aGlzLnNldCggcy8yLCBjLnggLyBzLCBjLnkgLyBzLCBjLnogLyBzICk7CiAgICAgICAgICAgIHRoaXMuc2V0KGMueCAvIHMsIGMueSAvIHMsIGMueiAvIHMsIHMgLyAyKTsKICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVJblBsYWNlKCk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldCB0aGUgUXVhdCBmcm9tIGEgTWF0My4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBtYXQzIC0gVGhlIG1hdDMgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0RnJvbU1hdDMobWF0MykgewogICAgICAgICAgICAvLyBBbGdvcml0aG0gaW4gS2VuIFNob2VtYWtlJ3MgYXJ0aWNsZSBpbiAxOTg3IFNJR0dSQVBIIGNvdXJzZSBub3RlcwogICAgICAgICAgICAvLyBhcnRpY2xlICJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvbiIuCiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBtYXQzLmFzQXJyYXkoKTsKICAgICAgICAgICAgY29uc3QgZlRyYWNlID0gZGF0YVswXSArIGRhdGFbNF0gKyBkYXRhWzhdOwogICAgICAgICAgICBsZXQgZlJvb3Q7CiAgICAgICAgICAgIGlmIChmVHJhY2UgPiAwLjApIHsKICAgICAgICAgICAgICAgIC8vIHx3fCA+IDEvMiwgbWF5IGFzIHdlbGwgY2hvb3NlIHcgPiAxLzIKICAgICAgICAgICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KGZUcmFjZSArIDEpOyAvLyAydwogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbM10gPSAwLjUgKiBmUm9vdDsKICAgICAgICAgICAgICAgIGZSb290ID0gMC41IC8gZlJvb3Q7IC8vIDEvKDR3KQogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbMF0gPSAoZGF0YVs1XSAtIGRhdGFbN10pICogZlJvb3Q7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVsxXSA9IChkYXRhWzZdIC0gZGF0YVsyXSkgKiBmUm9vdDsKICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhWzJdID0gKGRhdGFbMV0gLSBkYXRhWzNdKSAqIGZSb290OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgLy8gfHd8IDw9IDEvMgogICAgICAgICAgICAgICAgbGV0IGkgPSAwOwogICAgICAgICAgICAgICAgaWYgKGRhdGFbNF0gPiBkYXRhWzBdKQogICAgICAgICAgICAgICAgICAgIGkgPSAxOwogICAgICAgICAgICAgICAgaWYgKGRhdGFbOF0gPiBkYXRhW2kgKiAzICsgaV0pCiAgICAgICAgICAgICAgICAgICAgaSA9IDI7CiAgICAgICAgICAgICAgICBjb25zdCBqID0gKGkgKyAxKSAlIDM7CiAgICAgICAgICAgICAgICBjb25zdCBrID0gKGkgKyAyKSAlIDM7CiAgICAgICAgICAgICAgICBmUm9vdCA9IE1hdGguc3FydChkYXRhW2kgKiAzICsgaV0gLSBkYXRhW2ogKiAzICsgal0gLSBkYXRhW2sgKiAzICsga10gKyAxLjApOwogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbaV0gPSAwLjUgKiBmUm9vdDsKICAgICAgICAgICAgICAgIGZSb290ID0gMC41IC8gZlJvb3Q7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVszXSA9IChkYXRhW2ogKiAzICsga10gLSBkYXRhW2sgKiAzICsgal0pICogZlJvb3Q7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVtqXSA9IChkYXRhW2ogKiAzICsgaV0gKyBkYXRhW2kgKiAzICsgal0pICogZlJvb3Q7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVtrXSA9IChkYXRhW2sgKiAzICsgaV0gKyBkYXRhW2kgKiAzICsga10pICogZlJvb3Q7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVJblBsYWNlKCk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldCB0aGUgUXVhdCBmcm9tIGEgTWF0NC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBtYXQ0IC0gVGhlIG1hdDQgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0RnJvbU1hdDQobWF0NCkgewogICAgICAgICAgICAvLyBBbGdvcml0aG0gaW4gS2VuIFNob2VtYWtlJ3MgYXJ0aWNsZSBpbiAxOTg3IFNJR0dSQVBIIGNvdXJzZSBub3RlcwogICAgICAgICAgICAvLyBhcnRpY2xlICJRdWF0ZXJuaW9uIENhbGN1bHVzIGFuZCBGYXN0IEFuaW1hdGlvbiIuCiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBtYXQ0LmFzQXJyYXkoKTsKICAgICAgICAgICAgY29uc3QgZlRyYWNlID0gZGF0YVswXSArIGRhdGFbNV0gKyBkYXRhWzEwXTsKICAgICAgICAgICAgbGV0IGZSb290OwogICAgICAgICAgICBpZiAoZlRyYWNlID4gMC4wKSB7CiAgICAgICAgICAgICAgICAvLyB8d3wgPiAxLzIsIG1heSBhcyB3ZWxsIGNob29zZSB3ID4gMS8yCiAgICAgICAgICAgICAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxKTsgLy8gMncKICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhWzNdID0gMC41ICogZlJvb3Q7CiAgICAgICAgICAgICAgICBmUm9vdCA9IDAuNSAvIGZSb290OyAvLyAxLyg0dykKICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhWzBdID0gKGRhdGFbNl0gLSBkYXRhWzldKSAqIGZSb290OwogICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbMV0gPSAoZGF0YVs4XSAtIGRhdGFbMl0pICogZlJvb3Q7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVsyXSA9IChkYXRhWzFdIC0gZGF0YVs0XSkgKiBmUm9vdDsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIC8vIHx3fCA8PSAxLzIKICAgICAgICAgICAgICAgIGxldCBpID0gMDsKICAgICAgICAgICAgICAgIGlmIChkYXRhWzVdID4gZGF0YVswXSkKICAgICAgICAgICAgICAgICAgICBpID0gMTsKICAgICAgICAgICAgICAgIGlmIChkYXRhWzEwXSA+IGRhdGFbaSAqIDQgKyBpXSkKICAgICAgICAgICAgICAgICAgICBpID0gMjsKICAgICAgICAgICAgICAgIGNvbnN0IGogPSAoaSArIDEpICUgMzsKICAgICAgICAgICAgICAgIGNvbnN0IGsgPSAoaSArIDIpICUgMzsKICAgICAgICAgICAgICAgIGZSb290ID0gTWF0aC5zcXJ0KGRhdGFbaSAqIDQgKyBpXSAtIGRhdGFbaiAqIDQgKyBqXSAtIGRhdGFbayAqIDQgKyBrXSArIDEuMCk7CiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVtpXSA9IDAuNSAqIGZSb290OwogICAgICAgICAgICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdDsKICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhWzNdID0gKGRhdGFbaiAqIDQgKyBrXSAtIGRhdGFbayAqIDQgKyBqXSkgKiBmUm9vdDsKICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhW2pdID0gKGRhdGFbaiAqIDQgKyBpXSArIGRhdGFbaSAqIDQgKyBqXSkgKiBmUm9vdDsKICAgICAgICAgICAgICAgIHRoaXMuX19kYXRhW2tdID0gKGRhdGFbayAqIDQgKyBpXSArIGRhdGFbaSAqIDQgKyBrXSkgKiBmUm9vdDsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZUluUGxhY2UoKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ2hlY2tzIGlmIHRoZSBhbmdsZSBvZiB0aGUgUXVhdCBpcyBsZXNzIHRoYXQgYCBOdW1iZXIuRVBTSUxPTmAKICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRydWUgb3IgZmFsc2UuCiAgICAgICAgICovCiAgICAgICAgaXNJZGVudGl0eSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QW5nbGUoKSA8IE51bWJlci5FUFNJTE9OOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm4gdGhlIGFuZ2xlIG9mIHRoZSBRdWF0LgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZ2V0QW5nbGUoKSB7CiAgICAgICAgICAgIHJldHVybiBNYXRoLmFjb3ModGhpcy53KSAqIDIuMDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ2hlY2tzIGlmIHRoaXMgUXVhdCBjb250YWlucyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlIG90aGVyIFF1YXQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBjb21wYXJlIHdpdGguCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYHRydWVgIGlmIGFyZSB0aGUgc2FtZSBWZWN0b3IsIG90aGVyd2lzZSwgYGZhbHNlYC4KICAgICAgICAgKi8KICAgICAgICBpc0VxdWFsKG90aGVyKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnggPT0gb3RoZXIueCAmJiB0aGlzLnkgPT0gb3RoZXIueSAmJiB0aGlzLnogPT0gb3RoZXIueiAmJiB0aGlzLncgPT0gb3RoZXIudzsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgUXVhdCBpcyBOT1QgZXhhY3RseSB0aGUgc2FtZSBvdGhlci4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIGNvbXBhcmUgd2l0aC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0cnVlIG9yIGZhbHNlLgogICAgICAgICAqLwogICAgICAgIG5vdEVxdWFscyhvdGhlcikgewogICAgICAgICAgICByZXR1cm4gdGhpcy54ICE9IG90aGVyLnggJiYgdGhpcy55ICE9IG90aGVyLnkgJiYgdGhpcy56ICE9IG90aGVyLnogJiYgdGhpcy53ICE9IG90aGVyLnc7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIFF1YXQgaXMgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBhcyBvdGhlcgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFF1YXQgdG8gY29tcGFyZSB3aXRoLgogICAgICAgICAqIEBwYXJhbSBwcmVjaXNpb24gLSBUaGUgcHJlY2lzaW9uIHRvIHdoaWNoIHRoZSB2YWx1ZXMgbXVzdCBtYXRjaC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0cnVlIG9yIGZhbHNlLgogICAgICAgICAqLwogICAgICAgIGFwcHJveEVxdWFsKG90aGVyLCBwcmVjaXNpb24gPSBOdW1iZXIuRVBTSUxPTikgewogICAgICAgICAgICByZXR1cm4gKE1hdGguYWJzKHRoaXMueCAtIG90aGVyLngpIDwgcHJlY2lzaW9uICYmCiAgICAgICAgICAgICAgICBNYXRoLmFicyh0aGlzLnkgLSBvdGhlci55KSA8IHByZWNpc2lvbiAmJgogICAgICAgICAgICAgICAgTWF0aC5hYnModGhpcy56IC0gb3RoZXIueikgPCBwcmVjaXNpb24gJiYKICAgICAgICAgICAgICAgIE1hdGguYWJzKHRoaXMudyAtIG90aGVyLncpIDwgcHJlY2lzaW9uKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQWRkcyBvdGhlciB0byB0aGlzIFF1YXQgYW5kIHJldHVybiB0aGUgcmVzdWx0IGFzIGEgbmV3IFF1YXQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBhZGQuCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgUXVhdC4KICAgICAgICAgKi8KICAgICAgICBhZGQob3RoZXIpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWF0KHRoaXMueCArIG90aGVyLngsIHRoaXMueSArIG90aGVyLnksIHRoaXMueiArIG90aGVyLnosIHRoaXMudyArIG90aGVyLncpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBBZGRzIG90aGVyIHRvIHRoaXMgUXVhdC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIGFkZC4KICAgICAgICAgKi8KICAgICAgICBhZGRJblBsYWNlKG90aGVyKSB7CiAgICAgICAgICAgIHRoaXMueCArPSBvdGhlci54OwogICAgICAgICAgICB0aGlzLnkgKz0gb3RoZXIueTsKICAgICAgICAgICAgdGhpcy56ICs9IG90aGVyLno7CiAgICAgICAgICAgIHRoaXMudyArPSBvdGhlci53OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTdWJ0cmFjdHMgb3RoZXIgZnJvbSB0aGlzIFF1YXQgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBhcyBhIG5ldyBRdWF0LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFF1YXQgdG8gc3VidHJhY3QuCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgUXVhdC4KICAgICAgICAgKi8KICAgICAgICBzdWJ0cmFjdChvdGhlcikgewogICAgICAgICAgICByZXR1cm4gbmV3IFF1YXQodGhpcy54IC0gb3RoZXIueCwgdGhpcy55IC0gb3RoZXIueSwgdGhpcy56IC0gb3RoZXIueiwgdGhpcy53IC0gb3RoZXIudyk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNjYWxlcyB0aGlzIFF1YXQgYnkgc2NhbGFyIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSBuZXcgUXVhdC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzMuCiAgICAgICAgICovCiAgICAgICAgc2NhbGUoc2NhbGFyKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgUXVhdCh0aGlzLnggKiBzY2FsYXIsIHRoaXMueSAqIHNjYWxhciwgdGhpcy56ICogc2NhbGFyLCB0aGlzLncgKiBzY2FsYXIpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTY2FsZXMgdGhpcyBRdWF0IGJ5IHNjYWxhci4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBzY2FsYXIgLSBUaGUgc2NhbGFyIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHNjYWxlSW5QbGFjZShzY2FsYXIpIHsKICAgICAgICAgICAgdGhpcy54ICo9IHNjYWxhcjsKICAgICAgICAgICAgdGhpcy55ICo9IHNjYWxhcjsKICAgICAgICAgICAgdGhpcy56ICo9IHNjYWxhcjsKICAgICAgICAgICAgdGhpcy53ICo9IHNjYWxhcjsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoaXMgUXVhdC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBsZW5ndGguCiAgICAgICAgICovCiAgICAgICAgbGVuZ3RoKCkgewogICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5fX2RhdGFbMF07CiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLl9fZGF0YVsxXTsKICAgICAgICAgICAgY29uc3QgeiA9IHRoaXMuX19kYXRhWzJdOwogICAgICAgICAgICBjb25zdCB3ID0gdGhpcy5fX2RhdGFbM107CiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHcpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiB0aGlzIFF1YXQuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgbGVuZ3RoLgogICAgICAgICAqLwogICAgICAgIGxlbmd0aFNxdWFyZWQoKSB7CiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLl9fZGF0YVswXTsKICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMuX19kYXRhWzFdOwogICAgICAgICAgICBjb25zdCB6ID0gdGhpcy5fX2RhdGFbMl07CiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLl9fZGF0YVszXTsKICAgICAgICAgICAgcmV0dXJuIHggKiB4ICsgeSAqIHkgKyB6ICogeiArIHcgKiB3OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBOb3JtYWxpemVzIHRoZSBRdWF0IGFuZCByZXR1cm5zIGl0IGFzIGEgbmV3IFF1YXQuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgUXVhdCBub3JtYWxpemVkLgogICAgICAgICAqLwogICAgICAgIG5vcm1hbGl6ZSgpIHsKICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMuX19kYXRhWzBdOwogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5fX2RhdGFbMV07CiAgICAgICAgICAgIGNvbnN0IHogPSB0aGlzLl9fZGF0YVsyXTsKICAgICAgICAgICAgY29uc3QgdyA9IHRoaXMuX19kYXRhWzNdOwogICAgICAgICAgICBsZXQgbGVuID0geCAqIHggKyB5ICogeSArIHogKiB6ICsgdyAqIHc7CiAgICAgICAgICAgIGlmIChsZW4gPCBOdW1iZXIuRVBTSUxPTikgewogICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWF0KCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/CiAgICAgICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTsKICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWF0KHggKiBsZW4sIHkgKiBsZW4sIHogKiBsZW4sIHcgKiBsZW4pOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBOb3JtYWxpemVzIHRoZSBRdWF0LCBtb2RpZnlpbmcgaXRzIHZhbHVlcyBpbiBwbGFjZS4KICAgICAgICAgKi8KICAgICAgICBub3JtYWxpemVJblBsYWNlKCkgewogICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5fX2RhdGFbMF07CiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLl9fZGF0YVsxXTsKICAgICAgICAgICAgY29uc3QgeiA9IHRoaXMuX19kYXRhWzJdOwogICAgICAgICAgICBjb25zdCB3ID0gdGhpcy5fX2RhdGFbM107CiAgICAgICAgICAgIGxldCBsZW4gPSB4ICogeCArIHkgKiB5ICsgeiAqIHogKyB3ICogdzsKICAgICAgICAgICAgaWYgKGxlbiA8IE51bWJlci5FUFNJTE9OKSB7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pOwogICAgICAgICAgICB0aGlzLnNldCh4ICogbGVuLCB5ICogbGVuLCB6ICogbGVuLCB3ICogbGVuKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdGhpcyBxdWF0IGFnYWluc3QgYW5vdGhlci4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIGNvbXBhcmUgd2l0aC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgZG90IHByb2R1Y3QuCiAgICAgICAgICovCiAgICAgICAgZG90KG90aGVyKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiBvdGhlci54ICsgdGhpcy55ICogb3RoZXIueSArIHRoaXMueiAqIG90aGVyLnogKyB0aGlzLncgKiBvdGhlci53OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byBRdWF0cyBhbmQgcmV0dXJucyB0aGUgcmVzdWx0IGFzIGEgbmV3IFF1YXQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBjYWxjdWxhdGUgd2l0aC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgY3Jvc3MgcHJvZHVjdCBhcyBhIG5ldyBRdWF0LgogICAgICAgICAqLwogICAgICAgIGNyb3NzKG90aGVyKSB7CiAgICAgICAgICAgIGNvbnN0IGF4ID0gdGhpcy54OwogICAgICAgICAgICBjb25zdCBheSA9IHRoaXMueTsKICAgICAgICAgICAgY29uc3QgYXogPSB0aGlzLno7CiAgICAgICAgICAgIGNvbnN0IGF0ID0gdGhpcy53OwogICAgICAgICAgICBjb25zdCBieCA9IG90aGVyLng7CiAgICAgICAgICAgIGNvbnN0IGJ5ID0gb3RoZXIueTsKICAgICAgICAgICAgY29uc3QgYnogPSBvdGhlci56OwogICAgICAgICAgICBjb25zdCBidCA9IG90aGVyLnc7CiAgICAgICAgICAgIHJldHVybiBuZXcgUXVhdChheSAqIGJ6IC0gYXogKiBieSwgYXogKiBidCAtIGF0ICogYnosIGF0ICogYnggLSBheCAqIGJ0LCBheCAqIGJ5IC0gYXkgKiBieCk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIHJvdGF0aW9uYWwgY29uanVnYXRlIG9mIHRoaXMgUXVhdC4KICAgICAgICAgKiBDb25qdWdhdGlvbiByZXByZXNlbnRzIHRoZSBzYW1lIHJvdGF0aW9uIG9mIHRoZSBRdWF0IGJ1dAogICAgICAgICAqIGluIHRoZSBvcHBvc2l0ZSBkaXJlY3Rpb24gYXJvdW5kIHRoZSByb3RhdGlvbmFsIGF4aXMuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gdGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBjb25qdWdhdGUoKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgUXVhdCgtdGhpcy54LCAtdGhpcy55LCAtdGhpcy56LCB0aGlzLncpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm4gdGhlIGludmVyc2Ugb2YgdGhlIGBRdWF0YAogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgUXVhdC4KICAgICAgICAgKi8KICAgICAgICBpbnZlcnNlKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5jb25qdWdhdGUoKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQWxpZ25zIHRoaXMgcXVhdGVybmlvbiB3aXRoIGFub3RoZXIgb25lIGVuc3VyaW5nIHRoYXQgdGhlIGRlbHRhIGJldHdlZW4KICAgICAgICAgKiB0aGUgUXVhdCB2YWx1ZXMgaXMgdGhlIHNob3J0ZXN0IHBhdGggb3ZlciB0aGUgaHlwZXItc3BoZXJlLgogICAgICAgICAqCiAgICAgICAgICogIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIGRpdmlkZSBieS4KICAgICAgICAgKi8KICAgICAgICBhbGlnbldpdGgob3RoZXIpIHsKICAgICAgICAgICAgaWYgKHRoaXMuZG90KG90aGVyKSA8IDAuMCkgewogICAgICAgICAgICAgICAgdGhpcy5zZXQoLXRoaXMueCwgLXRoaXMueSwgLXRoaXMueiwgLXRoaXMudyk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogTXVsdGlwbGllcyB0d28gdGhpcyBxdWF0IGJ5IGFub3RoZXIgcmV0dXJuaW5nIHRoZSByZXN1bHQgYXMgYSBuZXcgUXVhdC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBvdGhlciAtIFRoZSBvdGhlciBRdWF0IHRvIG11bHRpcGx5LgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFF1YXQuCiAgICAgICAgICovCiAgICAgICAgbXVsdGlwbHkob3RoZXIpIHsKICAgICAgICAgICAgY29uc3QgYXggPSB0aGlzLl9fZGF0YVswXTsKICAgICAgICAgICAgY29uc3QgYXkgPSB0aGlzLl9fZGF0YVsxXTsKICAgICAgICAgICAgY29uc3QgYXogPSB0aGlzLl9fZGF0YVsyXTsKICAgICAgICAgICAgY29uc3QgYXcgPSB0aGlzLl9fZGF0YVszXTsKICAgICAgICAgICAgY29uc3QgYnggPSBvdGhlci5fX2RhdGFbMF07CiAgICAgICAgICAgIGNvbnN0IGJ5ID0gb3RoZXIuX19kYXRhWzFdOwogICAgICAgICAgICBjb25zdCBieiA9IG90aGVyLl9fZGF0YVsyXTsKICAgICAgICAgICAgY29uc3QgYncgPSBvdGhlci5fX2RhdGFbM107CiAgICAgICAgICAgIHJldHVybiBuZXcgUXVhdChheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5LCBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6LCBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LCBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogTXVsdGlwbGllcyB0aGlzIHF1YXQgYnkgYW5vdGhlciwgbW9kaWZ5aW5nIGl0cyB2YWx1ZXMgaW4gcGxhY2UuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gb3RoZXIgLSBUaGUgb3RoZXIgUXVhdCB0byBtdWx0aXBseS4KICAgICAgICAgKi8KICAgICAgICBtdWx0aXBseUluUGxhY2Uob3RoZXIpIHsKICAgICAgICAgICAgY29uc3QgYXggPSB0aGlzLl9fZGF0YVswXTsKICAgICAgICAgICAgY29uc3QgYXkgPSB0aGlzLl9fZGF0YVsxXTsKICAgICAgICAgICAgY29uc3QgYXogPSB0aGlzLl9fZGF0YVsyXTsKICAgICAgICAgICAgY29uc3QgYXcgPSB0aGlzLl9fZGF0YVszXTsKICAgICAgICAgICAgY29uc3QgYnggPSBvdGhlci5fX2RhdGFbMF07CiAgICAgICAgICAgIGNvbnN0IGJ5ID0gb3RoZXIuX19kYXRhWzFdOwogICAgICAgICAgICBjb25zdCBieiA9IG90aGVyLl9fZGF0YVsyXTsKICAgICAgICAgICAgY29uc3QgYncgPSBvdGhlci5fX2RhdGFbM107CiAgICAgICAgICAgIHRoaXMuc2V0KGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnksIGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYnosIGF6ICogYncgKyBhdyAqIGJ6ICsgYXggKiBieSAtIGF5ICogYngsIGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYnopOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSb3RhdGVzIGEgdmVjdG9yIGJ5IHRoaXMgcXVhdGVybmlvbi4KICAgICAgICAgKiBEb24ndCBmb3JnZXQgdG8gbm9ybWFsaXplIHRoZSBxdWF0ZXJuaW9uIHVubGVzcwogICAgICAgICAqIHlvdSB3YW50IGF4aWFsIHRyYW5zbGF0aW9uIGFzIHdlbGwgYXMgcm90YXRpb24uCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmVjMyAtIFRoZSB2ZWMzIHZhbHVlLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFZlYzMuCiAgICAgICAgICovCiAgICAgICAgcm90YXRlVmVjMyh2ZWMzKSB7CiAgICAgICAgICAgIGNvbnN0IHZxID0gbmV3IFF1YXQodmVjMy54LCB2ZWMzLnksIHZlYzMueiwgMC4wKTsKICAgICAgICAgICAgY29uc3QgcHEgPSB0aGlzLm11bHRpcGx5KHZxKS5tdWx0aXBseSh0aGlzLmNvbmp1Z2F0ZSgpKTsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHBxLngsIHBxLnksIHBxLnopOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHRoaXMgcXVhdGVybmlvbiB0byBhIHJvdGF0aW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhYm91dCB0aGUgWCBheGlzLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHJhZCAtIEFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGUuCiAgICAgICAgICovCiAgICAgICAgcm90YXRlWChyYWQpIHsKICAgICAgICAgICAgcmFkICo9IDAuNTsKICAgICAgICAgICAgY29uc3QgYXggPSB0aGlzLng7CiAgICAgICAgICAgIGNvbnN0IGF5ID0gdGhpcy55OwogICAgICAgICAgICBjb25zdCBheiA9IHRoaXMuejsKICAgICAgICAgICAgY29uc3QgYXcgPSB0aGlzLnc7CiAgICAgICAgICAgIGNvbnN0IGJ4ID0gTWF0aC5zaW4ocmFkKTsKICAgICAgICAgICAgY29uc3QgYncgPSBNYXRoLmNvcyhyYWQpOwogICAgICAgICAgICB0aGlzLnggPSBheCAqIGJ3ICsgYXcgKiBieDsKICAgICAgICAgICAgdGhpcy55ID0gYXkgKiBidyArIGF6ICogYng7CiAgICAgICAgICAgIHRoaXMueiA9IGF6ICogYncgLSBheSAqIGJ4OwogICAgICAgICAgICB0aGlzLncgPSBhdyAqIGJ3IC0gYXggKiBieDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyB0aGlzIHF1YXRlcm5pb24gdG8gYSByb3RhdGlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYWJvdXQgdGhlIFkgYXhpcy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSByYWQgLSBBbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlLgogICAgICAgICAqLwogICAgICAgIHJvdGF0ZVkocmFkKSB7CiAgICAgICAgICAgIHJhZCAqPSAwLjU7CiAgICAgICAgICAgIGNvbnN0IGF4ID0gdGhpcy54OwogICAgICAgICAgICBjb25zdCBheSA9IHRoaXMueTsKICAgICAgICAgICAgY29uc3QgYXogPSB0aGlzLno7CiAgICAgICAgICAgIGNvbnN0IGF3ID0gdGhpcy53OwogICAgICAgICAgICBjb25zdCBieSA9IE1hdGguc2luKHJhZCk7CiAgICAgICAgICAgIGNvbnN0IGJ3ID0gTWF0aC5jb3MocmFkKTsKICAgICAgICAgICAgdGhpcy54ID0gYXggKiBidyAtIGF6ICogYnk7CiAgICAgICAgICAgIHRoaXMueSA9IGF5ICogYncgKyBhdyAqIGJ5OwogICAgICAgICAgICB0aGlzLnogPSBheiAqIGJ3ICsgYXggKiBieTsKICAgICAgICAgICAgdGhpcy53ID0gYXcgKiBidyAtIGF5ICogYnk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHMgdGhpcyBxdWF0ZXJuaW9uIHRvIGEgcm90YXRpb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXMuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gcmFkIC0gQW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZS4KICAgICAgICAgKi8KICAgICAgICByb3RhdGVaKHJhZCkgewogICAgICAgICAgICByYWQgKj0gMC41OwogICAgICAgICAgICBjb25zdCBheCA9IHRoaXMueDsKICAgICAgICAgICAgY29uc3QgYXkgPSB0aGlzLnk7CiAgICAgICAgICAgIGNvbnN0IGF6ID0gdGhpcy56OwogICAgICAgICAgICBjb25zdCBhdyA9IHRoaXMudzsKICAgICAgICAgICAgY29uc3QgYnogPSBNYXRoLnNpbihyYWQpOwogICAgICAgICAgICBjb25zdCBidyA9IE1hdGguY29zKHJhZCk7CiAgICAgICAgICAgIHRoaXMueCA9IGF4ICogYncgKyBheSAqIGJ6OwogICAgICAgICAgICB0aGlzLnkgPSBheSAqIGJ3IC0gYXggKiBiejsKICAgICAgICAgICAgdGhpcy56ID0gYXogKiBidyArIGF3ICogYno7CiAgICAgICAgICAgIHRoaXMudyA9IGF3ICogYncgLSBheiAqIGJ6OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFF1YXQgdG8gYSBNYXQzIChhIDN4MyBtYXRyaXgpLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRSZXR1cm5zIGEgbmV3IE1hdDMuCiAgICAgICAgICovCiAgICAgICAgdG9NYXQzKCkgewogICAgICAgICAgICBjb25zdCB4ID0gdGhpcy54OwogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy55OwogICAgICAgICAgICBjb25zdCB6ID0gdGhpcy56OwogICAgICAgICAgICBjb25zdCB3ID0gdGhpcy53OwogICAgICAgICAgICBjb25zdCB4MiA9IHggKyB4OwogICAgICAgICAgICBjb25zdCB5MiA9IHkgKyB5OwogICAgICAgICAgICBjb25zdCB6MiA9IHogKyB6OwogICAgICAgICAgICBjb25zdCB4eCA9IHggKiB4MjsKICAgICAgICAgICAgY29uc3QgeXggPSB5ICogeDI7CiAgICAgICAgICAgIGNvbnN0IHl5ID0geSAqIHkyOwogICAgICAgICAgICBjb25zdCB6eCA9IHogKiB4MjsKICAgICAgICAgICAgY29uc3QgenkgPSB6ICogeTI7CiAgICAgICAgICAgIGNvbnN0IHp6ID0geiAqIHoyOwogICAgICAgICAgICBjb25zdCB3eCA9IHcgKiB4MjsKICAgICAgICAgICAgY29uc3Qgd3kgPSB3ICogeTI7CiAgICAgICAgICAgIGNvbnN0IHd6ID0gdyAqIHoyOwogICAgICAgICAgICBjb25zdCBtYXQzID0gbmV3IE1hdDMoKTsKICAgICAgICAgICAgbWF0My5tMDAgPSAxIC0geXkgLSB6ejsKICAgICAgICAgICAgbWF0My5tMTAgPSB5eCAtIHd6OwogICAgICAgICAgICBtYXQzLm0yMCA9IHp4ICsgd3k7CiAgICAgICAgICAgIG1hdDMubTAxID0geXggKyB3ejsKICAgICAgICAgICAgbWF0My5tMTEgPSAxIC0geHggLSB6ejsKICAgICAgICAgICAgbWF0My5tMjEgPSB6eSAtIHd4OwogICAgICAgICAgICBtYXQzLm0wMiA9IHp4IC0gd3k7CiAgICAgICAgICAgIG1hdDMubTEyID0genkgKyB3eDsKICAgICAgICAgICAgbWF0My5tMjIgPSAxIC0geHggLSB5eTsKICAgICAgICAgICAgcmV0dXJuIG1hdDM7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENhbGN1bGF0ZXMgYSBWZWMzIHZhbHVlIGFsaWduZWQgd2l0aCB0aGUgWCBheGlzIG9mIHRoaXMgcXVhdGVybmlvbi4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmVzdWx0aW5nIFZlYzMgdmFsdWUKICAgICAgICAgKi8KICAgICAgICBnZXRYYXhpcygpIHsKICAgICAgICAgICAgY29uc3QgeHkgPSB0aGlzLnggKiB0aGlzLnk7CiAgICAgICAgICAgIGNvbnN0IHh6ID0gdGhpcy54ICogdGhpcy56OwogICAgICAgICAgICBjb25zdCB5eSA9IHRoaXMueSAqIHRoaXMueTsKICAgICAgICAgICAgY29uc3QgeXcgPSB0aGlzLnkgKiB0aGlzLnc7CiAgICAgICAgICAgIGNvbnN0IHp6ID0gdGhpcy56ICogdGhpcy56OwogICAgICAgICAgICBjb25zdCB6dyA9IHRoaXMueiAqIHRoaXMudzsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKDEuMCAtIDIuMCAqICh6eiArIHl5KSwgMi4wICogKHh5ICsgencpLCAyLjAgKiAoeHogLSB5dykpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxjdWxhdGVzIGEgVmVjMyB2YWx1ZSBhbGlnbmVkIHdpdGggdGhlIFkgYXhpcyBvZiB0aGlzIHF1YXRlcm5pb24uCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJlc3VsdGluZyBWZWMzIHZhbHVlCiAgICAgICAgICovCiAgICAgICAgZ2V0WWF4aXMoKSB7CiAgICAgICAgICAgIGNvbnN0IHh4ID0gdGhpcy54ICogdGhpcy54OwogICAgICAgICAgICBjb25zdCB4eSA9IHRoaXMueCAqIHRoaXMueTsKICAgICAgICAgICAgY29uc3QgeHcgPSB0aGlzLnggKiB0aGlzLnc7CiAgICAgICAgICAgIGNvbnN0IHl6ID0gdGhpcy55ICogdGhpcy56OwogICAgICAgICAgICBjb25zdCB6eiA9IHRoaXMueiAqIHRoaXMuejsKICAgICAgICAgICAgY29uc3QgencgPSB0aGlzLnogKiB0aGlzLnc7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMygyLjAgKiAoeHkgLSB6dyksIDEuMCAtIDIuMCAqICh6eiArIHh4KSwgMi4wICogKHl6ICsgeHcpKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ2FsY3VsYXRlcyBhIFZlYzMgdmFsdWUgYWxpZ25lZCB3aXRoIHRoZSBaIGF4aXMgb2YgdGhpcyBxdWF0ZXJuaW9uLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXN1bHRpbmcgVmVjMyB2YWx1ZQogICAgICAgICAqLwogICAgICAgIGdldFpheGlzKCkgewogICAgICAgICAgICBjb25zdCB4eCA9IHRoaXMueCAqIHRoaXMueDsKICAgICAgICAgICAgY29uc3QgeHogPSB0aGlzLnggKiB0aGlzLno7CiAgICAgICAgICAgIGNvbnN0IHh3ID0gdGhpcy54ICogdGhpcy53OwogICAgICAgICAgICBjb25zdCB5eSA9IHRoaXMueSAqIHRoaXMueTsKICAgICAgICAgICAgY29uc3QgeXogPSB0aGlzLnkgKiB0aGlzLno7CiAgICAgICAgICAgIGNvbnN0IHl3ID0gdGhpcy55ICogdGhpcy53OwogICAgICAgICAgICAvLyBjb25zdCB0ZW1wID0gbmV3IFZlYzMoKQogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzMoMi4wICogKHl3ICsgeHopLCAyLjAgKiAoeXogLSB4dyksIDEuMCAtIDIuMCAqICh5eSArIHh4KSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJlZmxlY3RzIHRoaXMgcXVhdGVybmlvbiBhY2NvcmRpbmcgdG8gdGhlIGF4aXMgcHJvdmlkZWQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gYXhpc0luZGV4IC0gQW4gaW50ZWdlciB3aXRoIHZhbHVlIG9mIDAgZm9yIHRoZSBYIGF4aXMsIDEgZm9yIHRoZSBZIGF4aXMsIGFuZCAyIGZvciB0aGUgWiBheGlzLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFF1YXQuCiAgICAgICAgICovCiAgICAgICAgbWlycm9yKGF4aXNJbmRleCkgewogICAgICAgICAgICBzd2l0Y2ggKGF4aXNJbmRleCkgewogICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUXVhdCh0aGlzLnosIHRoaXMudywgdGhpcy54LCB0aGlzLnkpOwogICAgICAgICAgICAgICAgY2FzZSAxOgogICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUXVhdCgtdGhpcy53LCB0aGlzLnosIHRoaXMueSwgLXRoaXMueCk7CiAgICAgICAgICAgICAgICBjYXNlIDI6CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWF0KHRoaXMueCwgdGhpcy55LCB0aGlzLnosIC10aGlzLncpOwogICAgICAgICAgICAgICAgY2FzZSAwOgogICAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFF1YXQodGhpcy56LCB0aGlzLncsIHRoaXMueCwgdGhpcy55KTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIFF1YXQgdG8gYSBNYXQ0IChhIDR4NCBtYXRyaXgpLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgTWF0NC4KICAgICAgICAgKi8KICAgICAgICB0b01hdDQoKSB7CiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLng7CiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLnk7CiAgICAgICAgICAgIGNvbnN0IHogPSB0aGlzLno7CiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLnc7CiAgICAgICAgICAgIGNvbnN0IHgyID0geCArIHg7CiAgICAgICAgICAgIGNvbnN0IHkyID0geSArIHk7CiAgICAgICAgICAgIGNvbnN0IHoyID0geiArIHo7CiAgICAgICAgICAgIGNvbnN0IHh4ID0geCAqIHgyOwogICAgICAgICAgICBjb25zdCB5eCA9IHkgKiB4MjsKICAgICAgICAgICAgY29uc3QgeXkgPSB5ICogeTI7CiAgICAgICAgICAgIGNvbnN0IHp4ID0geiAqIHgyOwogICAgICAgICAgICBjb25zdCB6eSA9IHogKiB5MjsKICAgICAgICAgICAgY29uc3QgenogPSB6ICogejI7CiAgICAgICAgICAgIGNvbnN0IHd4ID0gdyAqIHgyOwogICAgICAgICAgICBjb25zdCB3eSA9IHcgKiB5MjsKICAgICAgICAgICAgY29uc3Qgd3ogPSB3ICogejI7CiAgICAgICAgICAgIC8vIFNldCB0aGUgY29sdW1ucwogICAgICAgICAgICBjb25zdCBtYXQ0ID0gbmV3IE1hdDQoKTsKICAgICAgICAgICAgbWF0NC5tMDAgPSAxIC0geXkgLSB6ejsKICAgICAgICAgICAgbWF0NC5tMTAgPSB5eCAtIHd6OwogICAgICAgICAgICBtYXQ0Lm0yMCA9IHp4ICsgd3k7CiAgICAgICAgICAgIG1hdDQubTAxID0geXggKyB3ejsKICAgICAgICAgICAgbWF0NC5tMTEgPSAxIC0geHggLSB6ejsKICAgICAgICAgICAgbWF0NC5tMjEgPSB6eSAtIHd4OwogICAgICAgICAgICBtYXQ0Lm0wMiA9IHp4IC0gd3k7CiAgICAgICAgICAgIG1hdDQubTEyID0genkgKyB3eDsKICAgICAgICAgICAgbWF0NC5tMjIgPSAxIC0geHggLSB5eTsKICAgICAgICAgICAgcmV0dXJuIG1hdDQ7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gb2YgdGhpcyBRdWF0IHRvd2FyZHMgYW5vdGhlciBRdWF0LCByZXR1cm5pbmcgdGhlIHJlc3VsdCBhcyBhIG5ldyBRdWF0LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyICAtIFRoZSBvdGhlciBRdWF0IHRvIGludGVycG9sYXRlIHRvd2FyZHMuCiAgICAgICAgICogQHBhcmFtIHQgLSBJbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFF1YXQuCiAgICAgICAgICovCiAgICAgICAgbGVycChvdGhlciwgdCkgewogICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgUXVhdCh0aGlzLnggKyB0ICogKG90aGVyLnggLSB0aGlzLngpLCB0aGlzLnkgKyB0ICogKG90aGVyLnkgLSB0aGlzLnkpLCB0aGlzLnogKyB0ICogKG90aGVyLnogLSB0aGlzLnopLCB0aGlzLncgKyB0ICogKG90aGVyLncgLSB0aGlzLncpKTsKICAgICAgICAgICAgcmVzdWx0Lm5vcm1hbGl6ZUluUGxhY2UoKTsKICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUGVyZm9ybXMgYSBzcGhlcmljYWwgbGluZWFyIGludGVycG9sYXRpb24gb2YgdGhpcyBRdWF0IHRvd2FyZHMgYW5vdGhlciBRdWF0LCByZXR1cm5pbmcgdGhlIHJlc3VsdCBhcyBhIG5ldyBRdWF0LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG90aGVyIC0gVGhlIG90aGVyIFF1YXQgdG8gaW50ZXJwb2xhdGUgdG93YXJkcy4KICAgICAgICAgKiBAcGFyYW0gdCAtIEludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHMuCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgUXVhdC4KICAgICAgICAgKi8KICAgICAgICBzbGVycChvdGhlciwgbGFtYmRhKSB7CiAgICAgICAgICAgIC8vLyBodHRwczovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vRG9jdW1lbnRhdGlvbi9GYXN0QW5kQWNjdXJhdGVTbGVycC5wZGYKICAgICAgICAgICAgY29uc3QgZG90UHJvZHVjdCA9IHRoaXMuZG90KG90aGVyKTsKICAgICAgICAgICAgaWYgKGRvdFByb2R1Y3QgPiAwLjk5OSkKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOwogICAgICAgICAgICAvLyBhbGdvcml0aG0gYWRhcHRlZCBmcm9tIFNob2VtYWtlJ3MgcGFwZXIKICAgICAgICAgICAgLy8gbGFtYmRhIGlzIGluICgwLCDPgC8yXQogICAgICAgICAgICBjb25zdCB0aGV0YSA9IE1hdGguYWNvcyhkb3RQcm9kdWN0KTsKICAgICAgICAgICAgY29uc3Qgc3QgPSBNYXRoLnNpbih0aGV0YSk7CiAgICAgICAgICAgIGNvbnN0IHN1dCA9IE1hdGguc2luKGxhbWJkYSAqIHRoZXRhKTsKICAgICAgICAgICAgY29uc3Qgc291dCA9IE1hdGguc2luKCgxIC0gbGFtYmRhKSAqIHRoZXRhKTsKICAgICAgICAgICAgY29uc3QgY29lZmYxID0gc291dCAvIHN0OwogICAgICAgICAgICBjb25zdCBjb2VmZjIgPSBzdXQgLyBzdDsKICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFF1YXQoY29lZmYxICogdGhpcy54ICsgY29lZmYyICogb3RoZXIueCwgY29lZmYxICogdGhpcy55ICsgY29lZmYyICogb3RoZXIueSwgY29lZmYxICogdGhpcy56ICsgY29lZmYyICogb3RoZXIueiwgY29lZmYxICogdGhpcy53ICsgY29lZmYyICogb3RoZXIudyk7CiAgICAgICAgICAgIHJlc3VsdC5ub3JtYWxpemVJblBsYWNlKCk7CiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENsb25lcyB0aGlzIFF1YXQgYW5kIHJldHVybnMgYSBuZXcgUXVhdC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IFF1YXQuCiAgICAgICAgICovCiAgICAgICAgY2xvbmUoKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgUXVhdCh0aGlzLl9fZGF0YVswXSwgdGhpcy5fX2RhdGFbMV0sIHRoaXMuX19kYXRhWzJdLCB0aGlzLl9fZGF0YVszXSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIHR5cGUgYXMgYW4gYXJyYXkuIE9mdGVuIHVzZWQgdG8gcGFzcyB0eXBlcyB0byB0aGUgR1BVLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYXMgYW4gYXJyYXkuCiAgICAgICAgICovCiAgICAgICAgYXNBcnJheSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhOwogICAgICAgIH0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8KICAgICAgICAvLyBQZXJzaXN0ZW5jZQogICAgICAgIC8qKgogICAgICAgICAqIENvbnZlcnRzIHRoaXMgVmVjMyB0byBhIHN0cmluZyBpbiBKU09OIGZvcm1hdC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHRvU3RyaW5nKCkgewogICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcAogICAgICAgICAgICByZXR1cm4gU3RyaW5nRnVuY3Rpb25zLnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSBqc29uIG9iamVjdC4KICAgICAgICAgKi8KICAgICAgICB0b0pTT04oKSB7CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICB4OiB0aGlzLngsCiAgICAgICAgICAgICAgICB5OiB0aGlzLnksCiAgICAgICAgICAgICAgICB6OiB0aGlzLnosCiAgICAgICAgICAgICAgICB3OiB0aGlzLncsCiAgICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gaiAtIFRoZSBqc29uIG9iamVjdC4KICAgICAgICAgKi8KICAgICAgICBmcm9tSlNPTihqKSB7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzBdID0gai54OwogICAgICAgICAgICB0aGlzLl9fZGF0YVsxXSA9IGoueTsKICAgICAgICAgICAgdGhpcy5fX2RhdGFbMl0gPSBqLno7CiAgICAgICAgICAgIHRoaXMuX19kYXRhWzNdID0gai53OwogICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZUluUGxhY2UoKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogTG9hZHMgdGhlIHN0YXRlIG9mIHRoZSB2YWx1ZSBmcm9tIGEgYmluYXJ5IHJlYWRlci4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHJlYWRCaW5hcnkocmVhZGVyKSB7CiAgICAgICAgICAgIHRoaXMueCA9IHJlYWRlci5sb2FkRmxvYXQzMigpOwogICAgICAgICAgICB0aGlzLnkgPSByZWFkZXIubG9hZEZsb2F0MzIoKTsKICAgICAgICAgICAgdGhpcy56ID0gcmVhZGVyLmxvYWRGbG9hdDMyKCk7CiAgICAgICAgICAgIHRoaXMudyA9IHJlYWRlci5sb2FkRmxvYXQzMigpOwogICAgICAgIH0KICAgIH0KCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovCiAgICAvKioKICAgICAqIE1hdGggRnVuY3Rpb25zCiAgICAgKi8KICAgIGNsYXNzIE1hdGhGdW5jdGlvbnMgewogICAgICAgIC8qKgogICAgICAgICAqIENvbnZlcnRzIFJhZGlhbnMgdG8gRGVncmVlcwogICAgICAgICAqCiAgICAgICAgICogQHN0YXRpYwogICAgICAgICAqIEBwYXJhbSByYWQgLSBSYWRpYW5zIHZhbHVlCiAgICAgICAgICogQHJldHVybiAtIERlZ3JlZXMgZXF1aXZhbGVudAogICAgICAgICAqLwogICAgICAgIHN0YXRpYyByYWRUb0RlZyhyYWQpIHsKICAgICAgICAgICAgcmV0dXJuIHJhZCAvIChNYXRoLlBJIC8gMTgwKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ29udmVydHMgRGVncmVlcyB0byBSYWRpYW50cwogICAgICAgICAqCiAgICAgICAgICogQHN0YXRpYwogICAgICAgICAqIEBwYXJhbSBkZWcgLSBEZWdyZWVzIHZhbHVlCiAgICAgICAgICogQHJldHVybiAtICBSYWRpYW5zIGVxdWl2YWxlbnQKICAgICAgICAgKi8KICAgICAgICBzdGF0aWMgZGVnVG9SYWQoZGVnKSB7CiAgICAgICAgICAgIHJldHVybiBkZWcgKiAoTWF0aC5QSSAvIDE4MCk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFZlcmlmaWVzIGlmIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVyIGlzIG51bWVyaWMuCiAgICAgICAgICoKICAgICAgICAgKiBAc3RhdGljCiAgICAgICAgICogQHBhcmFtIG51bWJlciAtIE51bWJlciB0byB0ZXN0CiAgICAgICAgICogQHJldHVybiAtIGB0cnVlYCB3aGVuIGlzIGEgdmFsaWQgbnVtYmVyCiAgICAgICAgICovCiAgICAgICAgc3RhdGljIGlzTnVtZXJpYyhudW1iZXIpIHsKICAgICAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG51bWJlcikpICYmIGlzRmluaXRlKG51bWJlcik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdlbmVyYXRlcyBhbmQgcmV0dXJucyBhIHJhbmRvbSBpbnRlZ2VyIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHJhbmdlLgogICAgICAgICAqCiAgICAgICAgICogQHN0YXRpYwogICAgICAgICAqIEBwYXJhbSBtaW4gLSBMb3dlciB2YWx1ZSByYW5kb20gaW50IGNhbiBiZS4KICAgICAgICAgKiBAcGFyYW0gbWF4IC0gSGlnaGVzdCB2YWx1ZSByYW5kb20gaW50IGNhbiBiZS4KICAgICAgICAgKiBAcmV0dXJuIC0gUmFuZG9tIG51bWJlciBpbnNpZGUgcmFuZ2UuCiAgICAgICAgICovCiAgICAgICAgc3RhdGljIHJhbmRvbUludChtaW4sIG1heCkgewogICAgICAgICAgICBtaW4gPSBNYXRoLmNlaWwobWluKTsKICAgICAgICAgICAgbWF4ID0gTWF0aC5mbG9vcihtYXgpOwogICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikpICsgbWluOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxjdWxhdGVzIGEgbGluZWFsIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gaW5wdXRzIGZvciB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcih0KS4KICAgICAgICAgKgogICAgICAgICAqIEBzdGF0aWMKICAgICAgICAgKiBAcGFyYW0gdjAgLQogICAgICAgICAqIEBwYXJhbSB2MSAtCiAgICAgICAgICogQHBhcmFtIHQgLQogICAgICAgICAqIEByZXR1cm4gLQogICAgICAgICAqLwogICAgICAgIHN0YXRpYyBsZXJwKHYwLCB2MSwgdCkgewogICAgICAgICAgICByZXR1cm4gdjAgKyB0ICogKHYxIC0gdjApOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXN0cmljdHMgdGhlIHNwZWNpZmllZCB2YWx1ZSBiZXR3ZWVuIHR3byBudW1iZXJzCiAgICAgICAgICoKICAgICAgICAgKiBAc3RhdGljCiAgICAgICAgICogQHBhcmFtIHZhbHVlCiAgICAgICAgICogQHBhcmFtIG1pbgogICAgICAgICAqIEBwYXJhbSBtYXgKICAgICAgICAgKiBAcmV0dXJuCiAgICAgICAgICovCiAgICAgICAgc3RhdGljIGNsYW1wKHZhbHVlLCBtaW4sIG1heCkgewogICAgICAgICAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgodmFsdWUsIG1pbiksIG1heCk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIG5lYXJlc3QgcG93IG9mIHR3byB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIG51bWJlci4KICAgICAgICAgKgogICAgICAgICAqIEBzdGF0aWMKICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLQogICAgICAgICAqIEByZXR1cm4gLQogICAgICAgICAqLwogICAgICAgIHN0YXRpYyBuZWFyZXN0UG93Mih2YWx1ZSkgewogICAgICAgICAgICByZXR1cm4gTWF0aC5wb3coMiwgTWF0aC5yb3VuZChNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLmxvZygyKSkpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRoZSBuZWFyZXN0IHBvdyBvZiB0ZW4gdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBudW1iZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAc3RhdGljCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0KICAgICAgICAgKiBAcmV0dXJuIC0KICAgICAgICAgKi8KICAgICAgICBzdGF0aWMgbmVhcmVzdFBvdzEwKHZhbHVlKSB7CiAgICAgICAgICAgIHJldHVybiBNYXRoLnBvdygxMCwgTWF0aC5yb3VuZChNYXRoLmxvZzEwKHZhbHVlKSAvIE1hdGgubG9nMTAoMTApKSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIG5leHQgcG93IG9mIHR3byB2YWx1ZSBvZiB0aGUgc3BlY2lmaWVkIG51bWJlci4KICAgICAgICAgKgogICAgICAgICAqIEBzdGF0aWMKICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLQogICAgICAgICAqIEByZXR1cm4gLQogICAgICAgICAqLwogICAgICAgIHN0YXRpYyBuZXh0UG93Mih2YWx1ZSkgewogICAgICAgICAgICBpZiAodGhpcy5mcmFjdChNYXRoLmxvZzIodmFsdWUpKSA9PSAwKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbGV0IGV4cCA9IDA7CiAgICAgICAgICAgIHdoaWxlICh2YWx1ZSA+IDApIHsKICAgICAgICAgICAgICAgIGV4cCsrOwogICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSA+PiAxOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiAxIDw8IGV4cDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0aGUgZnJhY3Rpb25hbCBjb21wb25lbnQgb2YgYSBudW1iZXIKICAgICAgICAgKgogICAgICAgICAqIEBzdGF0aWMKICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLQogICAgICAgICAqIEByZXR1cm4gLQogICAgICAgICAqLwogICAgICAgIHN0YXRpYyBmcmFjdCh2YWx1ZSkgewogICAgICAgICAgICBpZiAodmFsdWUgPT0gMCkKICAgICAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgICAgICBpZiAodmFsdWUgPCAwKSB7CiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiAtMS4wKQogICAgICAgICAgICAgICAgICAgIHJldHVybiAtdmFsdWU7CiAgICAgICAgICAgICAgICByZXR1cm4gLXZhbHVlICUgTWF0aC5mbG9vcigtdmFsdWUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDEuMCkKICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTsKICAgICAgICAgICAgcmV0dXJuIHZhbHVlICUgTWF0aC5mbG9vcih2YWx1ZSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIE1vdmVzIHRoZSBzcGVjaWZpZWQgdmFsdWUgZnJvbSBvbmUgbnVtZXJpYyBkb21haW4ocmFuZ2UpIHRvIGFub3RoZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAc3RhdGljCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0KICAgICAgICAgKiBAcGFyYW0gc3RhcnQxIC0KICAgICAgICAgKiBAcGFyYW0gZW5kMSAtCiAgICAgICAgICogQHBhcmFtIHN0YXJ0MiAtCiAgICAgICAgICogQHBhcmFtIGVuZDIgLQogICAgICAgICAqIEByZXR1cm4gLQogICAgICAgICAqLwogICAgICAgIHN0YXRpYyByZW1hcCh2YWx1ZSwgc3RhcnQxLCBlbmQxLCBzdGFydDIsIGVuZDIpIHsKICAgICAgICAgICAgcmV0dXJuIHN0YXJ0MiArIChlbmQyIC0gc3RhcnQyKSAqICgodmFsdWUgLSBzdGFydDEpIC8gKGVuZDEgLSBzdGFydDEpKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUGVyZm9ybSBIZXJtaXRlIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmFsdWVzCiAgICAgICAgICoKICAgICAgICAgKiBAc3RhdGljCiAgICAgICAgICogQHBhcmFtIGVkZ2UwIC0KICAgICAgICAgKiBAcGFyYW0gZWRnZTEgLQogICAgICAgICAqIEBwYXJhbSB4IC0KICAgICAgICAgKiBAcmV0dXJuIC0KICAgICAgICAgKi8KICAgICAgICBzdGF0aWMgc21vb3RoU3RlcChlZGdlMCwgZWRnZTEsIHgpIHsKICAgICAgICAgICAgY29uc3QgdCA9IHRoaXMuY2xhbXAoKHggLSBlZGdlMCkgLyAoZWRnZTEgLSBlZGdlMCksIDAuMCwgMS4wKTsKICAgICAgICAgICAgcmV0dXJuIHQgKiB0ICogKDMuMCAtIDIuMCAqIHQpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBQZXJmb3JtcyAtIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmFsdWVzCiAgICAgICAgICoKICAgICAgICAgKiBAc3RhdGljCiAgICAgICAgICogQHBhcmFtIGVkZ2UwIC0KICAgICAgICAgKiBAcGFyYW0gZWRnZTEgLQogICAgICAgICAqIEBwYXJhbSB4IC0KICAgICAgICAgKiBAcmV0dXJuIC0KICAgICAgICAgKi8KICAgICAgICBzdGF0aWMgbGluU3RlcChlZGdlMCwgZWRnZTEsIHgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xhbXAoKHggLSBlZGdlMCkgLyAoZWRnZTEgLSBlZGdlMCksIDAuMCwgMS4wKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogRGVjb2RlcyBhIEZsb2F0MTYgZnJvbSB0d28gdW5zaWduZWQgSW50OAogICAgICAgICAqCiAgICAgICAgICogQHN0YXRpYwogICAgICAgICAqIEBwYXJhbSBjIC0gQXJyYXkgd2l0aCB0aGUgdHdvIFVJbnQ4CiAgICAgICAgICogQHJldHVybiAtIERlY29kZWQgRmxvYXQxNgogICAgICAgICAqLwogICAgICAgIHN0YXRpYyBkZWNvZGUxNkJpdEZsb2F0RnJvbTJ4VUludDgoYykgewogICAgICAgICAgICBjb25zdCBpeCA9IGNbMF07IC8vIDFzdCBieXRlOiAxIGJpdCBzaWduZWQgbnVtLCA0IGJpdHMgZXhwb25lbnQsIDMgYml0cyBtYW50aXNzYSAoTVNCKQogICAgICAgICAgICBjb25zdCBpeSA9IGNbMV07IC8vIDJuZCBieXRlOiA4IGJpdCBtYW50aXNzYSAoTFNCKQogICAgICAgICAgICBjb25zdCBzID0gaXggJiAweDgwID8gMSA6IC0xOyAvLyBnZXQgYml0IDgKICAgICAgICAgICAgY29uc3QgaWV4cCA9IChpeCAmIDB4NzgpID4+IDM7IC8vIG1hc2sgYml0cyA3LTQKICAgICAgICAgICAgY29uc3QgbXNiID0gaXggJiAweDc7IC8vIG1hc2sgYml0cyAzLTEKICAgICAgICAgICAgbGV0IG5vcm0gPSBpZXhwID09IDAgPyAwIDogMjA0ODsgLy8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBub3JtYWxpemVkIGFuZCBzdWItbm9ybWFsaXplZCBudW1iZXJzCiAgICAgICAgICAgIGNvbnN0IG1hbnRpc3NhID0gbm9ybSArIChtc2IgPDwgOCkgKyBpeTsgLy8gaW1wbGljaXQgcHJlY2VkaW5nIDEgb3IgMCBhZGRlZCBoZXJlCiAgICAgICAgICAgIG5vcm0gPSBpZXhwID09IDAgPyAxIDogMDsgLy8gbm9ybWFsaXphdGlvbiB0b2dnbGUKICAgICAgICAgICAgY29uc3QgZXhwb25lbnQgPSBNYXRoLnBvdygyLCBpZXhwICsgbm9ybSAtIDE2KTsgLy8gLTUgZm9yIHRoZSB0aGUgZXhwb25lbnQgYmlhcyBmcm9tIDJeLTUgdG8gMl4xMCBwbHVzIGFub3RoZXIgLTExIGZvciB0aGUgbm9ybWFsaXplZCAxMiBiaXQgbWFudGlzc2EKICAgICAgICAgICAgY29uc3QgdiA9IHMgKiBtYW50aXNzYSAqIGV4cG9uZW50OwogICAgICAgICAgICByZXR1cm4gdjsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogRW5jb2RlcyBhbiBhcnJheSBvZiB0d28gdW5zaWduZWQgSW50OCB0byBhIEZsb2F0MTYKICAgICAgICAgKgogICAgICAgICAqIEBzdGF0aWMKICAgICAgICAgKiBAcGFyYW0gdiAtIEZsb2F0MTYgbnVtYmVyCiAgICAgICAgICogQHJldHVybiAtIEVuY29kZWQgVW5zaWduZWQgSW50OCBhcnJheQogICAgICAgICAqLwogICAgICAgIHN0YXRpYyBlbmNvZGUxNkJpdEZsb2F0SW50bzJ4VUludDgodikgewogICAgICAgICAgICBjb25zdCBjID0gbmV3IFVpbnQ4QXJyYXkoMik7CiAgICAgICAgICAgIC8vIGNvbnN0IGMgPSBbMCwgMF07CiAgICAgICAgICAgIGNvbnN0IHNpZ251bSA9IHYgPj0gMCA/IDEyOCA6IDA7CiAgICAgICAgICAgIHYgPSBNYXRoLmFicyh2KTsKICAgICAgICAgICAgbGV0IGV4cG9uZW50ID0gMTU7CiAgICAgICAgICAgIGxldCBsaW1pdCA9IDEwMjQ7IC8vIGNvbnNpZGVyaW5nIHRoZSBiaWFzIGZyb20gMl4tNSB0byAyXjEwICg9PTEwMjQpCiAgICAgICAgICAgIGZvciAobGV0IGV4cCA9IDE1OyBleHAgPiAwOyBleHAtLSkgewogICAgICAgICAgICAgICAgaWYgKHYgPCBsaW1pdCkgewogICAgICAgICAgICAgICAgICAgIGxpbWl0IC89IDI7CiAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQtLTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBsZXQgcmVzdDsKICAgICAgICAgICAgaWYgKGV4cG9uZW50ID09IDApIHsKICAgICAgICAgICAgICAgIHJlc3QgPSB2IC8gbGltaXQgLyAyOyAvLyAic3ViLW5vcm1hbGl6ZSIgaW1wbGljaXQgcHJlY2VkaW5nIDAuCiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICByZXN0ID0gKHYgLSBsaW1pdCkgLyBsaW1pdDsgLy8gbm9ybWFsaXplIGFjY29yZGluZ2x5IHRvIGltcGxpY2l0IHByZWNlZGluZyAxLgogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IG1hbnRpc3NhID0gTWF0aC5yb3VuZChyZXN0ICogMjA0OCk7IC8vIDIwNDggPSAyXjExIGZvciB0aGUgKHNwbGl0KSAxMSBiaXQgbWFudGlzc2EKICAgICAgICAgICAgY29uc3QgbXNiID0gbWFudGlzc2EgLyAyNTY7IC8vIHRoZSBtb3N0IHNpZ25pZmljYW50IDMgYml0cyBnbyBpbnRvIHRoZSBsb3dlciBwYXJ0IG9mIHRoZSBmaXJzdCBieXRlCiAgICAgICAgICAgIGNvbnN0IGxzYiA9IG1hbnRpc3NhIC0gbXNiICogMjU2OyAvLyB0aGVyZSBnbyB0aGUgb3RoZXIgOCBiaXQgb2YgdGhlIGxvd2VyIHNpZ25pZmljYW5jZQogICAgICAgICAgICBjWzBdID0gc2lnbnVtICsgZXhwb25lbnQgKiA4ICsgbXNiOyAvLyBjb2xvciBub3JtYWxpemF0aW9uIGZvciB0ZXh0dXJlMkQKICAgICAgICAgICAgY1sxXSA9IGxzYjsKICAgICAgICAgICAgaWYgKHYgPj0gMjA0OCkgewogICAgICAgICAgICAgICAgY1swXSA9IDI1NTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gYzsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVHJhbnNmb3JtcyBhIDE2IGJpdCBmbG9hdCB0byBhbiBlbmNvZGVkIGludGVnZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAc3RhdGljCiAgICAgICAgICogQHBhcmFtIHYgLSBGbG9hdDE2IG51bWJlciB0byBlbmNvZGUKICAgICAgICAgKiBAcmV0dXJuIC0gRW5jb2RlZCBudW1iZXIKICAgICAgICAgKi8KICAgICAgICBzdGF0aWMgZW5jb2RlMTZCaXRGbG9hdCh2KSB7CiAgICAgICAgICAgIGNvbnN0IGZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7CiAgICAgICAgICAgIGZsb2F0MzJBcnJheVswXSA9IHY7CiAgICAgICAgICAgIGNvbnN0IGludDMyVmlldyA9IG5ldyBJbnQzMkFycmF5KGZsb2F0MzJBcnJheS5idWZmZXIpOwogICAgICAgICAgICBjb25zdCB0b1VJbnQxNiA9ICh4KSA9PiB7CiAgICAgICAgICAgICAgICBsZXQgYml0cyA9ICh4ID4+IDE2KSAmIDB4ODAwMDsgLyogR2V0IHRoZSBzaWduICovCiAgICAgICAgICAgICAgICBsZXQgbSA9ICh4ID4+IDEyKSAmIDB4MDdmZjsgLyogS2VlcCBvbmUgZXh0cmEgYml0IGZvciByb3VuZGluZyAqLwogICAgICAgICAgICAgICAgY29uc3QgZSA9ICh4ID4+IDIzKSAmIDB4ZmY7IC8qIFVzaW5nIGludCBpcyBmYXN0ZXIgaGVyZSAqLwogICAgICAgICAgICAgICAgLyogSWYgemVybywgb3IgZGUtbm9ybWFsLCBvciBleHBvbmVudCB1bmRlcmZsb3dzIHRvbyBtdWNoIGZvciBhIGRlLW5vcm1hbAogICAgICAgICAgICAgICAgICogaGFsZiwgcmV0dXJuIHNpZ25lZCB6ZXJvLiAqLwogICAgICAgICAgICAgICAgaWYgKGUgPCAxMDMpIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gYml0czsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIC8qIElmIE5hTiwgcmV0dXJuIE5hTi4gSWYgSW5mIG9yIGV4cG9uZW50IG92ZXJmbG93LCByZXR1cm4gSW5mLiAqLwogICAgICAgICAgICAgICAgaWYgKGUgPiAxNDIpIHsKICAgICAgICAgICAgICAgICAgICBiaXRzIHw9IDB4N2MwMDsKICAgICAgICAgICAgICAgICAgICAvKiBJZiBleHBvbmVudCB3YXMgMHhmZiBhbmQgb25lIG1hbnRpc3NhIGJpdCB3YXMgc2V0LCBpdCBtZWFucyBOYU4sCiAgICAgICAgICAgICAgICAgICAgICogbm90IEluZiwgc28gbWFrZSBzdXJlIHdlIHNldCBvbmUgbWFudGlzc2EgYml0IHRvby4gKi8KICAgICAgICAgICAgICAgICAgICBiaXRzIHw9IChlID09IDI1NSA/IDAgOiAxKSAmJiB4ICYgMHgwMDdmZmZmZjsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gYml0czsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIC8qIElmIGV4cG9uZW50IHVuZGVyZmxvd3MgYnV0IG5vdCB0b28gbXVjaCwgcmV0dXJuIGEgZGUtbm9ybWFsICovCiAgICAgICAgICAgICAgICBpZiAoZSA8IDExMykgewogICAgICAgICAgICAgICAgICAgIG0gfD0gMHgwODAwOwogICAgICAgICAgICAgICAgICAgIC8qIEV4dHJhIHJvdW5kaW5nIG1heSBvdmVyZmxvdyBhbmQgc2V0IG1hbnRpc3NhIHRvIDAgYW5kIGV4cG9uZW50CiAgICAgICAgICAgICAgICAgICAgICogdG8gMSwgd2hpY2ggaXMgT0suICovCiAgICAgICAgICAgICAgICAgICAgYml0cyB8PSAobSA+PiAoMTE0IC0gZSkpICsgKChtID4+ICgxMTMgLSBlKSkgJiAxKTsKICAgICAgICAgICAgICAgICAgICByZXR1cm4gYml0czsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGJpdHMgfD0gKChlIC0gMTEyKSA8PCAxMCkgfCAobSA+PiAxKTsKICAgICAgICAgICAgICAgIC8qIEV4dHJhIHJvdW5kaW5nLiBBbiBvdmVyZmxvdyB3aWxsIHNldCBtYW50aXNzYSB0byAwIGFuZCBpbmNyZW1lbnQKICAgICAgICAgICAgICAgICAqIHRoZSBleHBvbmVudCwgd2hpY2ggaXMgT0suICovCiAgICAgICAgICAgICAgICBiaXRzICs9IG0gJiAxOwogICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIHJldHVybiB0b1VJbnQxNihpbnQzMlZpZXdbMF0pOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBBcyBvcHBvc2l0ZSBvZiB0aGUgYGVuY29kZTE2Qml0RmxvYXRgIG1ldGhvZCwgdGhpcyB0YWtlcyBhbiBlbmNvZGVkIGludGVnZXIgdmFsdWUsCiAgICAgICAgICogYW5kIHJldHVybnMgdGhlIDE2IGJpdCBmbG9hdC4KICAgICAgICAgKgogICAgICAgICAqIEBzdGF0aWMKICAgICAgICAgKiBAcGFyYW0gaCAtIEVuY29kZWQgaW50ZWdlcgogICAgICAgICAqIEByZXR1cm4gLSBEZWNvZGVkIDE2IGJpdCBmbG9hdC4KICAgICAgICAgKi8KICAgICAgICBzdGF0aWMgZGVjb2RlMTZCaXRGbG9hdChoKSB7CiAgICAgICAgICAgIGNvbnN0IHMgPSAoaCAmIDB4ODAwMCkgPj4gMTU7CiAgICAgICAgICAgIGNvbnN0IGUgPSAoaCAmIDB4N2MwMCkgPj4gMTA7CiAgICAgICAgICAgIGNvbnN0IGYgPSBoICYgMHgwM2ZmOwogICAgICAgICAgICBpZiAoZSA9PSAwKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gKHMgPyAtMSA6IDEpICogTWF0aC5wb3coMiwgLTE0KSAqIChmIC8gTWF0aC5wb3coMiwgMTApKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmIChlID09IDB4MWYpIHsKICAgICAgICAgICAgICAgIHJldHVybiBmID8gTmFOIDogKHMgPyAtMSA6IDEpICogSW5maW5pdHk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIChzID8gLTEgOiAxKSAqIE1hdGgucG93KDIsIGUgLSAxNSkgKiAoMSArIGYgLyBNYXRoLnBvdygyLCAxMCkpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUcmFuc2Zvcm1zIGFuIGFycmF5IG9mIEZsb2F0IDMyIHRvIGFuIGFycmF5IG9mIHVuc2lnbmVkIEludDE2LgogICAgICAgICAqCiAgICAgICAgICogQHN0YXRpYwogICAgICAgICAqIEBwYXJhbSBmbG9hdDMyQXJyYXkgLQogICAgICAgICAqIEByZXR1cm4gLSBVbnNpZ25lZCBJbnQxNiBhcnJheSByZXByZXNlbnRhdGl2ZSBvZiB0aGUgRmxvYXQzMkFycmF5CiAgICAgICAgICovCiAgICAgICAgc3RhdGljIGNvbnZlcnRGbG9hdDMyQXJyYXlUb1VJbnQxNkFycmF5KGZsb2F0MzJBcnJheSkgewogICAgICAgICAgICBjb25zdCB1bml0MTZzID0gbmV3IFVpbnQxNkFycmF5KGZsb2F0MzJBcnJheS5sZW5ndGgpOwogICAgICAgICAgICBjb25zdCBpbnQzMlZpZXcgPSBuZXcgSW50MzJBcnJheShmbG9hdDMyQXJyYXkuYnVmZmVyKTsKICAgICAgICAgICAgY29uc3QgdG9VSW50MTYgPSAoeCkgPT4gewogICAgICAgICAgICAgICAgbGV0IGJpdHMgPSAoeCA+PiAxNikgJiAweDgwMDA7IC8qIEdldCB0aGUgc2lnbiAqLwogICAgICAgICAgICAgICAgbGV0IG0gPSAoeCA+PiAxMikgJiAweDA3ZmY7IC8qIEtlZXAgb25lIGV4dHJhIGJpdCBmb3Igcm91bmRpbmcgKi8KICAgICAgICAgICAgICAgIGNvbnN0IGUgPSAoeCA+PiAyMykgJiAweGZmOyAvKiBVc2luZyBpbnQgaXMgZmFzdGVyIGhlcmUgKi8KICAgICAgICAgICAgICAgIC8qIElmIHplcm8sIG9yIGRlLW5vcm1hbCwgb3IgZXhwb25lbnQgdW5kZXJmbG93cyB0b28gbXVjaCBmb3IgYSBkZS1ub3JtYWwKICAgICAgICAgICAgICAgICAqIGhhbGYsIHJldHVybiBzaWduZWQgemVyby4gKi8KICAgICAgICAgICAgICAgIGlmIChlIDwgMTAzKSB7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAvKiBJZiBOYU4sIHJldHVybiBOYU4uIElmIEluZiBvciBleHBvbmVudCBvdmVyZmxvdywgcmV0dXJuIEluZi4gKi8KICAgICAgICAgICAgICAgIGlmIChlID4gMTQyKSB7CiAgICAgICAgICAgICAgICAgICAgYml0cyB8PSAweDdjMDA7CiAgICAgICAgICAgICAgICAgICAgLyogSWYgZXhwb25lbnQgd2FzIDB4ZmYgYW5kIG9uZSBtYW50aXNzYSBiaXQgd2FzIHNldCwgaXQgbWVhbnMgTmFOLAogICAgICAgICAgICAgICAgICAgICAqIG5vdCBJbmYsIHNvIG1ha2Ugc3VyZSB3ZSBzZXQgb25lIG1hbnRpc3NhIGJpdCB0b28uICovCiAgICAgICAgICAgICAgICAgICAgYml0cyB8PSAoZSA9PSAyNTUgPyAwIDogMSkgJiYgeCAmIDB4MDA3ZmZmZmY7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAvKiBJZiBleHBvbmVudCB1bmRlcmZsb3dzIGJ1dCBub3QgdG9vIG11Y2gsIHJldHVybiBhIGRlLW5vcm1hbCAqLwogICAgICAgICAgICAgICAgaWYgKGUgPCAxMTMpIHsKICAgICAgICAgICAgICAgICAgICBtIHw9IDB4MDgwMDsKICAgICAgICAgICAgICAgICAgICAvKiBFeHRyYSByb3VuZGluZyBtYXkgb3ZlcmZsb3cgYW5kIHNldCBtYW50aXNzYSB0byAwIGFuZCBleHBvbmVudAogICAgICAgICAgICAgICAgICAgICAqIHRvIDEsIHdoaWNoIGlzIE9LLiAqLwogICAgICAgICAgICAgICAgICAgIGJpdHMgfD0gKG0gPj4gKDExNCAtIGUpKSArICgobSA+PiAoMTEzIC0gZSkpICYgMSk7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJpdHM7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBiaXRzIHw9ICgoZSAtIDExMikgPDwgMTApIHwgKG0gPj4gMSk7CiAgICAgICAgICAgICAgICAvKiBFeHRyYSByb3VuZGluZy4gQW4gb3ZlcmZsb3cgd2lsbCBzZXQgbWFudGlzc2EgdG8gMCBhbmQgaW5jcmVtZW50CiAgICAgICAgICAgICAgICAgKiB0aGUgZXhwb25lbnQsIHdoaWNoIGlzIE9LLiAqLwogICAgICAgICAgICAgICAgYml0cyArPSBtICYgMTsKICAgICAgICAgICAgICAgIHJldHVybiBiaXRzOwogICAgICAgICAgICB9OwogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZsb2F0MzJBcnJheS5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgdW5pdDE2c1tpXSA9IHRvVUludDE2KGludDMyVmlld1tpXSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHVuaXQxNnM7CiAgICAgICAgfQogICAgfQoKICAgIC8qKgogICAgICogUmVwcmVzZW50cyBhIGJveCBpbiAyRCBzcGFjZS4gTmVlZGluZyB0d28gVmVjMiB2ZWN0b3JzIGRlc2NyaWJpbmcgdGhlIGNvcm5lcnMKICAgICAqLwogICAgY2xhc3MgQm94MiB7CiAgICAgICAgLyoqCiAgICAgICAgICogQ3JlYXRlcyBhIEJveDIgb2JqZWN0IHVzaW5nIFZlYzJzLgogICAgICAgICAqIEluIGNhc2UgdGhlIHBhcmFtZXRlcnMgYXJlIG5vdCBwYXNzZWQgYnksIHRoZWlyIHZhbHVlcyBhcmUgcHJlLWRlZmluZWQ6CiAgICAgICAgICoKICAgICAgICAgKiBwMCBpcyBhIFZlYzIgd2l0aCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL1BPU0lUSVZFX0lORklOSVRZfGBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlgfQogICAgICAgICAqCiAgICAgICAgICogcDEgaXMgYSBWZWMyIHdpdGgge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9ORUdBVElWRV9JTkZJTklUWXxgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZYH0KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBwMCAtIEEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIGEgMkQgYm94LgogICAgICAgICAqIEBwYXJhbSBwMSAtIEEgcG9pbnQgcmVwcmVzZW50aW5nIHRoZSBjb3JuZXJzIG9mIGEgMkQgYm94LgogICAgICAgICAqLwogICAgICAgIGNvbnN0cnVjdG9yKHAwLCBwMSkgewogICAgICAgICAgICBpZiAocDAgaW5zdGFuY2VvZiBWZWMyKSB7CiAgICAgICAgICAgICAgICB0aGlzLnAwID0gcDA7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLnAwID0gbmV3IFZlYzIoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChwMSBpbnN0YW5jZW9mIFZlYzIpIHsKICAgICAgICAgICAgICAgIHRoaXMucDEgPSBwMTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMucDEgPSBuZXcgVmVjMihOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyBib3RoIFZlYzIgcG9pbnRzCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gcDAgLSBBIHBvaW50IHJlcHJlc2VudGluZyB0aGUgY29ybmVycyBvZiBhIDJEIGJveC4KICAgICAgICAgKiBAcGFyYW0gcDEgLSBBIHBvaW50IHJlcHJlc2VudGluZyB0aGUgY29ybmVycyBvZiBhIDJEIGJveC4KICAgICAgICAgKi8KICAgICAgICBzZXQocDAsIHAxKSB7CiAgICAgICAgICAgIHRoaXMucDAgPSBwMDsKICAgICAgICAgICAgdGhpcy5wMSA9IHAxOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXNldHMgdGhlIGJveDIgYmFjayB0byBhbiB1bmluaXRpYWxpemVkIHN0YXRlLgogICAgICAgICAqCiAgICAgICAgICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL1BPU0lUSVZFX0lORklOSVRZfGBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlgfQogICAgICAgICAqIGFuZCB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTnVtYmVyL05FR0FUSVZFX0lORklOSVRZfGBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlgfQogICAgICAgICAqLwogICAgICAgIHJlc2V0KCkgewogICAgICAgICAgICB0aGlzLnAwLnggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7CiAgICAgICAgICAgIHRoaXMucDEueCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTsKICAgICAgICAgICAgdGhpcy5wMC55ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOwogICAgICAgICAgICB0aGlzLnAxLnkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBib3ggaGFzIGJlZW4gZXhwYW5kZWQgdG8gY29udGFpbiBhIHBvaW50LgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgaXNWYWxpZCgpIHsKICAgICAgICAgICAgcmV0dXJuICh0aGlzLnAwLnggIT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmCiAgICAgICAgICAgICAgICB0aGlzLnAxLnggIT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZICYmCiAgICAgICAgICAgICAgICB0aGlzLnAwLnkgIT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmCiAgICAgICAgICAgICAgICB0aGlzLnAxLnkgIT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogRXhwYW5kcyB0aGUgQm94MiB0byBjb250YWluIHRoZSBuZXcgcG9pbnQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gcG9pbnQgLSBBIHBvaW50IHJlcHJlc2VudHMgdGhlIGNvcm5lcnMgb2YgYSAyRCBib3guCiAgICAgICAgICovCiAgICAgICAgYWRkUG9pbnQocG9pbnQpIHsKICAgICAgICAgICAgaWYgKHRoaXMucDAueCA9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgfHwgcG9pbnQueCA8IHRoaXMucDAueCkKICAgICAgICAgICAgICAgIHRoaXMucDAueCA9IHBvaW50Lng7CiAgICAgICAgICAgIGlmICh0aGlzLnAwLnkgPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8IHBvaW50LnkgPCB0aGlzLnAwLnkpCiAgICAgICAgICAgICAgICB0aGlzLnAwLnkgPSBwb2ludC55OwogICAgICAgICAgICBpZiAodGhpcy5wMS55ID09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSB8fCBwb2ludC54ID4gdGhpcy5wMS54KQogICAgICAgICAgICAgICAgdGhpcy5wMS54ID0gcG9pbnQueDsKICAgICAgICAgICAgaWYgKHRoaXMucDEueSA9PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkgfHwgcG9pbnQueSA+IHRoaXMucDEueSkKICAgICAgICAgICAgICAgIHRoaXMucDEueSA9IHBvaW50Lnk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgZGlhZ29uYWwgb2YgdGhlIGJveC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBkaXN0YW5jZS4KICAgICAgICAgKi8KICAgICAgICBzaXplKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5wMS5kaXN0YW5jZVRvKHRoaXMucDApOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIGEgQm94MiAtIHRoZSBzYW1lIGFzIHNpemUoKS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgVmVjMi4KICAgICAgICAgKi8KICAgICAgICBkaWFnb25hbCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMucDEuc3VidHJhY3QodGhpcy5wMCk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIGNlbnRlciBwb2ludCBvZiBhIEJveDIuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIFZlYzIuCiAgICAgICAgICovCiAgICAgICAgY2VudGVyKCkgewogICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnAxLnN1YnRyYWN0KHRoaXMucDApOwogICAgICAgICAgICByZXN1bHQuc2NhbGVJblBsYWNlKDAuNSk7CiAgICAgICAgICAgIHJlc3VsdC5hZGRJblBsYWNlKHRoaXMucDApOwogICAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDbG9uZXMgdGhpcyBWZWMyIGFuZCByZXR1cm5zIGEgbmV3IFZlYzIuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBWZWMyLgogICAgICAgICAqLwogICAgICAgIGNsb25lKCkgewogICAgICAgICAgICByZXR1cm4gbmV3IEJveDIodGhpcy5wMC5jbG9uZSgpLCB0aGlzLnAxLmNsb25lKCkpOwogICAgICAgIH0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCiAgICAgICAgLy8gUGVyc2lzdGVuY2UKICAgICAgICAvKioKICAgICAgICAgKiBFbmNvZGVzIGBCb3gyYCBDbGFzcyBhcyBhIEpTT04gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUganNvbiBvYmplY3QuCiAgICAgICAgICovCiAgICAgICAgdG9KU09OKCkgewogICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgcDA6IHRoaXMucDAudG9KU09OKCksCiAgICAgICAgICAgICAgICBwMTogdGhpcy5wMS50b0pTT04oKSwKICAgICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ2FsbHMgYHRvSlNPTmAgbWV0aG9kIGFuZCBzdHJpbmdpZmllcyBpdC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHRvU3RyaW5nKCkgewogICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbmV3LWNhcAogICAgICAgICAgICByZXR1cm4gU3RyaW5nRnVuY3Rpb25zLnN0cmluZ2lmeUpTT05XaXRoRml4ZWRQcmVjaXNpb24odGhpcy50b0pTT04oKSk7CiAgICAgICAgfQogICAgfQoKICAgIC8qIGVzbGludC1kaXNhYmxlIG5ldy1jYXAgKi8KICAgIC8qKgogICAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbWF0aGVtYXRpY2FsIHNwaGVyZSwgYXMgb3Bwb3NlZCB0byB0aGUgU3BoZXJlIGNsYXNzIGRlcml2ZWQgZnJvbSBQcm9jZWR1cmFsTWVzaC4KICAgICAqCiAgICAgKi8KICAgIGNsYXNzIFNwaGVyZVR5cGUgewogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZSBhIHNwaGVyZS4KICAgICAgICAgKiBAcGFyYW0gcG9zIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBzcGhlcmUuCiAgICAgICAgICogQHBhcmFtIHJhZGl1cyAtIFRoZSByYWRpdXMgb2YgdGhlIHNwaGVyZS4KICAgICAgICAgKi8KICAgICAgICBjb25zdHJ1Y3Rvcihwb3MgPSBuZXcgVmVjMygpLCByYWRpdXMgPSAwKSB7CiAgICAgICAgICAgIGlmIChwb3MgaW5zdGFuY2VvZiBWZWMzKSB7CiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IHBvczsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMucG9zID0gbmV3IFZlYzMoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1czsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ2xvbmVzIHRoaXMgc3BoZXJlIGFuZCByZXR1cm5zIGEgbmV3IHNwaGVyZS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgbmV3IHNwaGVyZS4KICAgICAgICAgKi8KICAgICAgICBjbG9uZSgpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBTcGhlcmVUeXBlKHRoaXMucG9zLmNsb25lKCksIHRoaXMucmFkaXVzKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ2hlY2tzIGlmIHRoaXMgc3BoZXJlIGludGVyc2VjdHMgYSBib3guCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gYm94IC0gVGhlIGJveCB2YWx1ZS4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBpbnRlcnNlY3RzQm94KGJveCkgewogICAgICAgICAgICByZXR1cm4gYm94LmludGVyc2VjdHNTcGhlcmUodGhpcyk7CiAgICAgICAgfQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogICAgICAgIC8vIFBlcnNpc3RlbmNlCiAgICAgICAgLyoqCiAgICAgICAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIGpzb24gb2JqZWN0LgogICAgICAgICAqLwogICAgICAgIHRvSlNPTigpIHsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIHBvczogdGhpcy5wb3MudG9KU09OKCksCiAgICAgICAgICAgICAgICByYWRpdXM6IHRoaXMucmFkaXVzLAogICAgICAgICAgICB9OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxscyBgdG9KU09OYCBtZXRob2QgYW5kIHN0cmluZ2lmaWVzIGl0LgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgdG9TdHJpbmcoKSB7CiAgICAgICAgICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKTsKICAgICAgICB9CiAgICB9CgogICAgLyoqCiAgICAgKiBDbGFzcyByZXByZXNlbnRpbmcgYSBib3ggaW4gM0Qgc3BhY2UuCiAgICAgKiBSZXByZXNlbnRzIGEgYm94IGluIDNEIHNwYWNlIGRlZmluZWQgYnkgdHdvIFZlYzMgdmFsdWVzIHdoaWNoIGRlZmluZSBvcHBvc2luZyBjb3JuZXJzIG9mIHRoZSBib3guCiAgICAgKi8KICAgIGNsYXNzIEJveDMgewogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZXMgYSBCb3gzIG9iamVjdCB1c2luZyBWZWMzcy4KICAgICAgICAgKiBJbiBjYXNlIHRoZSBwYXJhbWV0ZXJzIGFyZSBub3QgcGFzc2VkIGJ5LCB0aGVpciB2YWx1ZXMgYXJlIHByZS1kZWZpbmVkOgogICAgICAgICAqCiAgICAgICAgICogcDAgaXMgYSBWZWMyIHdpdGgge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9QT1NJVElWRV9JTkZJTklUWXxgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZYH0KICAgICAgICAgKgogICAgICAgICAqIHAxIGlzIGEgVmVjMiB3aXRoIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvTkVHQVRJVkVfSU5GSU5JVFl8YE51bWJlci5ORUdBVElWRV9JTkZJTklUWWB9CiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gcDAgLSBBIHBvaW50IHJlcHJlc2VudGluZyB0aGUgY29ybmVycyBvZiBhIDNEIGJveC4KICAgICAgICAgKiBAcGFyYW0gcDEgLSBBIHBvaW50IHJlcHJlc2VudGluZyB0aGUgY29ybmVycyBvZiBhIDNEIGJveC4KICAgICAgICAgKi8KICAgICAgICBjb25zdHJ1Y3RvcihwMCwgcDEpIHsKICAgICAgICAgICAgaWYgKHAwIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7CiAgICAgICAgICAgICAgICB0aGlzLnAwID0gbmV3IFZlYzMobmV3IEZsb2F0MzJBcnJheShwMC5idWZmZXIsIHAwLmJ5dGVPZmZzZXQsIDMpKTsKICAgICAgICAgICAgICAgIHRoaXMucDEgPSBuZXcgVmVjMyhuZXcgRmxvYXQzMkFycmF5KHAwLmJ1ZmZlciwgcDAuYnl0ZU9mZnNldCArIDEyLCAzKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBpZiAocDAgaW5zdGFuY2VvZiBWZWMzKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5wMCA9IHAwOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5wMCA9IG5ldyBWZWMzKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHAxIGluc3RhbmNlb2YgVmVjMykgewogICAgICAgICAgICAgICAgICAgIHRoaXMucDEgPSBwMTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgIHRoaXMucDEgPSBuZXcgVmVjMyhOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBHZXR0ZXIgZm9yIHRoZSBsb3dlciAoeCwgeSwgeikgYm91bmRhcnkgb2YgdGhlIGJveC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBtaW5pbXVtIFZlYzMuCiAgICAgICAgICovCiAgICAgICAgZ2V0IG1pbigpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMucDA7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHRlciBmb3IgdGhlIHVwcGVyICh4LCB5LCB6KSBib3VuZGFyeSBvZiB0aGUgYm94LgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIG1heGltdW0gVmVjMy4KICAgICAgICAgKi8KICAgICAgICBnZXQgbWF4KCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5wMTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyBib3RoIFZlYzMgcG9pbnRzCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gcDAgLSBBIHBvaW50IHJlcHJlc2VudGluZyB0aGUgY29ybmVycyBvZiBhIDNEIGJveC4KICAgICAgICAgKiBAcGFyYW0gcDEgLSBBIHBvaW50IHJlcHJlc2VudGluZyB0aGUgY29ybmVycyBvZiBhIDNEIGJveC4KICAgICAgICAgKi8KICAgICAgICBzZXQocDAsIHAxKSB7CiAgICAgICAgICAgIHRoaXMucDAgPSBwMDsKICAgICAgICAgICAgdGhpcy5wMSA9IHAxOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXNldHMgdGhlIGJveDMgYmFjayB0byBhbiB1bmluaXRpYWxpemVkIHN0YXRlLgogICAgICAgICAqLwogICAgICAgIHJlc2V0KCkgewogICAgICAgICAgICB0aGlzLnAwLnggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7CiAgICAgICAgICAgIHRoaXMucDAueSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTsKICAgICAgICAgICAgdGhpcy5wMC56ID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZOwogICAgICAgICAgICB0aGlzLnAxLnggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7CiAgICAgICAgICAgIHRoaXMucDEueSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTsKICAgICAgICAgICAgdGhpcy5wMS56ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYm94IGhhcyBiZWVuIGV4cGFuZGVkIHRvIGNvbnRhaW4gYSBwb2ludC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGlzVmFsaWQoKSB7CiAgICAgICAgICAgIHJldHVybiAodGhpcy5wMC54ICE9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJgogICAgICAgICAgICAgICAgdGhpcy5wMS54ICE9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSAmJgogICAgICAgICAgICAgICAgdGhpcy5wMC55ICE9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJgogICAgICAgICAgICAgICAgdGhpcy5wMS55ICE9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSAmJgogICAgICAgICAgICAgICAgdGhpcy5wMC56ICE9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJgogICAgICAgICAgICAgICAgdGhpcy5wMS56ICE9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEV4cGFuZHMgdGhlIEJveDMgdG8gY29udGFpbiB0aGUgbmV3IHBvaW50LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHBvaW50IC0gQSBwb2ludCByZXByZXNlbnRzIHRoZSBjb3JuZXJzIG9mIGEgM0QgYm94LgogICAgICAgICAqLwogICAgICAgIGFkZFBvaW50KHBvaW50KSB7CiAgICAgICAgICAgIGlmIChwb2ludC54ICE9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJiBwb2ludC54ICE9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkgewogICAgICAgICAgICAgICAgaWYgKHBvaW50LnggPCB0aGlzLnAwLngpCiAgICAgICAgICAgICAgICAgICAgdGhpcy5wMC54ID0gcG9pbnQueDsKICAgICAgICAgICAgICAgIGlmIChwb2ludC54ID4gdGhpcy5wMS54KQogICAgICAgICAgICAgICAgICAgIHRoaXMucDEueCA9IHBvaW50Lng7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHBvaW50LnkgIT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmIHBvaW50LnkgIT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSB7CiAgICAgICAgICAgICAgICBpZiAocG9pbnQueSA8IHRoaXMucDAueSkKICAgICAgICAgICAgICAgICAgICB0aGlzLnAwLnkgPSBwb2ludC55OwogICAgICAgICAgICAgICAgaWYgKHBvaW50LnkgPiB0aGlzLnAxLnkpCiAgICAgICAgICAgICAgICAgICAgdGhpcy5wMS55ID0gcG9pbnQueTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocG9pbnQueiAhPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgJiYgcG9pbnQueiAhPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHsKICAgICAgICAgICAgICAgIGlmIChwb2ludC56IDwgdGhpcy5wMC56KQogICAgICAgICAgICAgICAgICAgIHRoaXMucDAueiA9IHBvaW50Lno7CiAgICAgICAgICAgICAgICBpZiAocG9pbnQueiA+IHRoaXMucDEueikKICAgICAgICAgICAgICAgICAgICB0aGlzLnAxLnogPSBwb2ludC56OwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEFkZHMgYEJveDNgIHRvIHRoaXMgYEJveDNgLCBvZiB0aGUgWGZvIGluc3RhbmNlIGlzIHBhc3NlZCBpbiB0aGUgcGFyYW1ldGVycwogICAgICAgICAqIGl0IHByb2NlZWRzIHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gZm9yIHRoZSBWZWMzLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIGJveDMgLSBBIDNEIGJveC4KICAgICAgICAgKiBAcGFyYW0geGZvIC0gQSAzRCB0cmFuc2Zvcm0uCiAgICAgICAgICovCiAgICAgICAgYWRkQm94Myhib3gzLCB0cmFuc2Zvcm0pIHsKICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkgewogICAgICAgICAgICAgICAgLy8gVHJhbnNmb3JtIGVhY2ggY29ybmVyIG9mIHRoZSBCb3gzIGludG8gdGhlIG5ldyBjb29yZGluYXRlIHN5c3RlbS4KICAgICAgICAgICAgICAgIHRoaXMuYWRkUG9pbnQodHJhbnNmb3JtLnRyYW5zZm9ybVZlYzMoYm94My5wMCkpOwogICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludCh0cmFuc2Zvcm0udHJhbnNmb3JtVmVjMyhuZXcgVmVjMyhib3gzLnAwLngsIGJveDMucDAueSwgYm94My5wMS56KSkpOwogICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludCh0cmFuc2Zvcm0udHJhbnNmb3JtVmVjMyhuZXcgVmVjMyhib3gzLnAwLngsIGJveDMucDEueSwgYm94My5wMC56KSkpOwogICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludCh0cmFuc2Zvcm0udHJhbnNmb3JtVmVjMyhuZXcgVmVjMyhib3gzLnAxLngsIGJveDMucDAueSwgYm94My5wMC56KSkpOwogICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludCh0cmFuc2Zvcm0udHJhbnNmb3JtVmVjMyhuZXcgVmVjMyhib3gzLnAwLngsIGJveDMucDEueSwgYm94My5wMS56KSkpOwogICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludCh0cmFuc2Zvcm0udHJhbnNmb3JtVmVjMyhuZXcgVmVjMyhib3gzLnAxLngsIGJveDMucDAueSwgYm94My5wMS56KSkpOwogICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludCh0cmFuc2Zvcm0udHJhbnNmb3JtVmVjMyhuZXcgVmVjMyhib3gzLnAxLngsIGJveDMucDEueSwgYm94My5wMC56KSkpOwogICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludCh0cmFuc2Zvcm0udHJhbnNmb3JtVmVjMyhib3gzLnAxKSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLmFkZFBvaW50KGJveDMucDApOwogICAgICAgICAgICAgICAgdGhpcy5hZGRQb2ludChib3gzLnAxKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGRpYWdvbmFsIG9mIHRoZSBib3guCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgZGlzdGFuY2UuCiAgICAgICAgICovCiAgICAgICAgc2l6ZSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMucDEuZGlzdGFuY2VUbyh0aGlzLnAwKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0aGUgZGlhZ29uYWwgdmVjdG9yIG9mIHRoZSBCPWJveCBmcm9tIHAwIHRvIHAxLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBCb3gzLgogICAgICAgICAqLwogICAgICAgIGRpYWdvbmFsKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5wMS5zdWJ0cmFjdCh0aGlzLnAwKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0aGUgY2VudGVyIHBvaW50IG9mIGEgQm94My4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgVmVjMy4KICAgICAgICAgKi8KICAgICAgICBjZW50ZXIoKSB7CiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucDEuc3VidHJhY3QodGhpcy5wMCk7CiAgICAgICAgICAgIHJlc3VsdC5zY2FsZUluUGxhY2UoMC41KTsKICAgICAgICAgICAgcmVzdWx0LmFkZEluUGxhY2UodGhpcy5wMCk7CiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENvbnZlcnRzIHRoaXMgQm94MyB0byBhIE1hdDQgKGEgNHg0IG1hdHJpeCkuIFRoZSByZXR1cm5lZCBtYXQ0IHdvdWxkIHRyYW5zZm9ybSBhIHVuaXQgY3ViZSBpbnRvIHRoZSBzaGFwZSBvZiB0aGUgQm91bmRpbmcgYm94LgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBuZXcgTWF0NC4KICAgICAgICAgKi8KICAgICAgICB0b01hdDQoKSB7CiAgICAgICAgICAgIGNvbnN0IHNjeCA9IHRoaXMucDEueCAtIHRoaXMucDAueDsKICAgICAgICAgICAgY29uc3Qgc2N5ID0gdGhpcy5wMS55IC0gdGhpcy5wMC55OwogICAgICAgICAgICBjb25zdCBzY3ogPSB0aGlzLnAxLnogLSB0aGlzLnAwLno7CiAgICAgICAgICAgIHJldHVybiBuZXcgTWF0NChzY3gsIDAsIDAsIDAsIDAsIHNjeSwgMCwgMCwgMCwgMCwgc2N6LCAwLCB0aGlzLnAwLngsIHRoaXMucDAueSwgdGhpcy5wMC56LCAxLjApOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxjdWxhdGVzIGFuZCByZXR1cm5zIHRoZSBib3VuZGluZyBTcGhlcmUgb2YgdGhlIEJveDMKICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldEJvdW5kaW5nU3BoZXJlKCkgewogICAgICAgICAgICByZXR1cm4gbmV3IFNwaGVyZVR5cGUodGhpcy5jZW50ZXIoKSwgdGhpcy5kaWFnb25hbCgpLmxlbmd0aCgpICogMC41KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogRGV0ZXJtaW5lcyBpZiB0aGlzIEJveDMgaW50ZXJzZWN0cyBhIGdpdmVuIGJveCB2YWx1ZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBib3ggLSBUaGUgYm94IHRvIGNoZWNrIGZvciBpbnRlcnNlY3Rpb24gYWdhaW5zdC4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0cnVlIGlmIHRoZSBzaGFwZXMgaW50ZXJzZWN0LgogICAgICAgICAqLwogICAgICAgIGludGVyc2VjdHNCb3goYm94KSB7CiAgICAgICAgICAgIC8vIFVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLgogICAgICAgICAgICByZXR1cm4gYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fAogICAgICAgICAgICAgICAgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fAogICAgICAgICAgICAgICAgYm94Lm1heC55IDwgdGhpcy5taW4ueSB8fAogICAgICAgICAgICAgICAgYm94Lm1pbi55ID4gdGhpcy5tYXgueSB8fAogICAgICAgICAgICAgICAgYm94Lm1heC56IDwgdGhpcy5taW4ueiB8fAogICAgICAgICAgICAgICAgYm94Lm1pbi56ID4gdGhpcy5tYXguegogICAgICAgICAgICAgICAgPyBmYWxzZQogICAgICAgICAgICAgICAgOiB0cnVlOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIHRoaXMgQm94MyBpbnRlcnNlY3RzIGEgc3BoZXJlLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHNwaGVyZSAtIFRoZSBzcGhlcmUgdG8gY2hlY2sgZm9yIGludGVyc2VjdGlvbiBhZ2FpbnN0LgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRydWUgaWYgdGhlIHNoYXBlcyBpbnRlcnNlY3QuCiAgICAgICAgICovCiAgICAgICAgaW50ZXJzZWN0c1NwaGVyZShzcGhlcmUpIHsKICAgICAgICAgICAgbGV0IGNsb3Nlc3RQb2ludCA9IG5ldyBWZWMzKCk7CiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHBvaW50IG9uIHRoZSBBQUJCIGNsb3Nlc3QgdG8gdGhlIHNwaGVyZSBjZW50ZXIuCiAgICAgICAgICAgIC8vIHRoaXMuY2xhbXBQb2ludCggc3BoZXJlLmNlbnRlciwgY2xvc2VzdFBvaW50ICk7CiAgICAgICAgICAgIC8vIElmIHRoYXQgcG9pbnQgaXMgaW5zaWRlIHRoZSBzcGhlcmUsIHRoZSBBQUJCIGFuZCBzcGhlcmUgaW50ZXJzZWN0LgogICAgICAgICAgICByZXR1cm4gY2xvc2VzdFBvaW50LmRpc3RhbmNlVG8oc3BoZXJlLnBvcykgPD0gc3BoZXJlLnJhZGl1cyAqIHNwaGVyZS5yYWRpdXM7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIERldGVybWluZXMgaWYgdGhpcyBCb3gzIGludGVyc2VjdHMgYSBwbGFuZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBwbGFuZSAtIFRoZSBwbGFuZSB0byBjaGVjayBmb3IgaW50ZXJzZWN0aW9uIGFnYWluc3QuCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgaW50ZXJzZWN0c1BsYW5lKHBsYW5lKSB7CiAgICAgICAgICAgIC8vIFdlIGNvbXB1dGUgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gZG90IHByb2R1Y3QgdmFsdWVzLiBJZiB0aG9zZSB2YWx1ZXMKICAgICAgICAgICAgLy8gYXJlIG9uIHRoZSBzYW1lIHNpZGUgKGJhY2sgb3IgZnJvbnQpIG9mIHRoZSBwbGFuZSwgdGhlbiB0aGVyZSBpcyBubyBpbnRlcnNlY3Rpb24uCiAgICAgICAgICAgIGxldCBtaW47CiAgICAgICAgICAgIGxldCBtYXg7CiAgICAgICAgICAgIGlmIChwbGFuZS5ub3JtYWwueCA+IDApIHsKICAgICAgICAgICAgICAgIG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDsKICAgICAgICAgICAgICAgIG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDsKICAgICAgICAgICAgICAgIG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5taW4ueDsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAocGxhbmUubm9ybWFsLnkgPiAwKSB7CiAgICAgICAgICAgICAgICBtaW4gKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55OwogICAgICAgICAgICAgICAgbWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7CiAgICAgICAgICAgICAgICBtYXggKz0gcGxhbmUubm9ybWFsLnkgKiB0aGlzLm1pbi55OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChwbGFuZS5ub3JtYWwueiA+IDApIHsKICAgICAgICAgICAgICAgIG1pbiArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7CiAgICAgICAgICAgICAgICBtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgbWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejsKICAgICAgICAgICAgICAgIG1heCArPSBwbGFuZS5ub3JtYWwueiAqIHRoaXMubWluLno7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIG1pbiA8PSAtcGxhbmUudyAmJiBtYXggPj0gLXBsYW5lLnc7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENsb25lcyB0aGlzIEJveDMgYW5kIHJldHVybnMgYSBuZXcgQm94My4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIG5ldyBCb3gzLgogICAgICAgICAqLwogICAgICAgIGNsb25lKCkgewogICAgICAgICAgICByZXR1cm4gbmV3IEJveDModGhpcy5wMC5jbG9uZSgpLCB0aGlzLnAxLmNsb25lKCkpOwogICAgICAgIH0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCiAgICAgICAgLy8gUGVyc2lzdGVuY2UKICAgICAgICAvKioKICAgICAgICAgKiBFbmNvZGVzIGBCb3gzYCBDbGFzcyBhcyBhIEpTT04gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUganNvbiBvYmplY3QuCiAgICAgICAgICovCiAgICAgICAgdG9KU09OKCkgewogICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgcDA6IHRoaXMucDAudG9KU09OKCksCiAgICAgICAgICAgICAgICBwMTogdGhpcy5wMS50b0pTT04oKSwKICAgICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogRGVjb2RlcyBhIEpTT04gb2JqZWN0IHRvIHNldCB0aGUgc3RhdGUgb2YgdGhpcyBjbGFzcy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBqIC0gVGhlIGpzb24gb2JqZWN0LgogICAgICAgICAqLwogICAgICAgIGZyb21KU09OKGopIHsKICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB2ZXJpZnkgdGhhdCBwMCBhbmQgcDEgYXhlcyBhcmUgbnVtZXJpYywgc28gaW4gY2FzZSB0aGV5IGFyZSBub3QsIHdlIHJlc3RvcmUgdGhlbSB0byB0aGVpciBkZWZhdWx0IHZhbHVlcy4KICAgICAgICAgICAgLy8gVGhpcywgYmVjYXVzZSAnSW5maW5pdHknIGFuZCAnLUluZmluaXR5JyBhcmUgc3RyaW5naWZpZWQgYXMgJ251bGwnLgogICAgICAgICAgICBjb25zdCBwMCA9IHsKICAgICAgICAgICAgICAgIHg6IE1hdGhGdW5jdGlvbnMuaXNOdW1lcmljKGoucDAueCkgPyBqLnAwLnggOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksCiAgICAgICAgICAgICAgICB5OiBNYXRoRnVuY3Rpb25zLmlzTnVtZXJpYyhqLnAwLnkpID8gai5wMC55IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLAogICAgICAgICAgICAgICAgejogTWF0aEZ1bmN0aW9ucy5pc051bWVyaWMoai5wMC56KSA/IGoucDAueiA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwKICAgICAgICAgICAgfTsKICAgICAgICAgICAgY29uc3QgcDEgPSB7CiAgICAgICAgICAgICAgICB4OiBNYXRoRnVuY3Rpb25zLmlzTnVtZXJpYyhqLnAxLngpID8gai5wMS54IDogTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLAogICAgICAgICAgICAgICAgeTogTWF0aEZ1bmN0aW9ucy5pc051bWVyaWMoai5wMS55KSA/IGoucDEueSA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwKICAgICAgICAgICAgICAgIHo6IE1hdGhGdW5jdGlvbnMuaXNOdW1lcmljKGoucDEueikgPyBqLnAxLnogOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksCiAgICAgICAgICAgIH07CiAgICAgICAgICAgIHRoaXMucDAuZnJvbUpTT04ocDApOwogICAgICAgICAgICB0aGlzLnAxLmZyb21KU09OKHAxKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVGhlIHNldEZyb21GbG9hdDMyQXJyYXkgbWV0aG9kLgogICAgICAgICAqIEBwYXJhbSBmbG9hdDMyYXJyYXkgLSBUaGUgZmxvYXQzMmFycmF5IHZhbHVlLgogICAgICAgICAqIEBwcml2YXRlCiAgICAgICAgICovCiAgICAgICAgc2V0RnJvbUZsb2F0MzJBcnJheShmbG9hdDMyYXJyYXkpIHsKICAgICAgICAgICAgdGhpcy5wMCA9IG5ldyBWZWMzKGZsb2F0MzJhcnJheS5idWZmZXIsIGZsb2F0MzJhcnJheS5ieXRlT2Zmc2V0KTsKICAgICAgICAgICAgdGhpcy5wMSA9IG5ldyBWZWMzKGZsb2F0MzJhcnJheS5idWZmZXIsIGZsb2F0MzJhcnJheS5ieXRlT2Zmc2V0ICsgMTIpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxscyBgdG9KU09OYCBtZXRob2QgYW5kIHN0cmluZ2lmaWVzIGl0LgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgdG9TdHJpbmcoKSB7CiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwCiAgICAgICAgICAgIHJldHVybiBTdHJpbmdGdW5jdGlvbnMuc3RyaW5naWZ5SlNPTldpdGhGaXhlZFByZWNpc2lvbih0aGlzLnRvSlNPTigpKTsKICAgICAgICB9CiAgICB9CgogICAgbGV0IHJlZ2lzdGVyZWRDbGFzc2VzID0ge307CiAgICBsZXQgY2xhc3NOYW1lcyA9IHt9OwogICAgbGV0IGNsYXNzRGVmaW5pdGlvbnMgPSBbXTsKICAgIC8qKgogICAgICogUmVnaXN0cnkgaXMgYSBzdGF0aWMgZmFjdG9yeSB0aGF0IGhhbmRsZXMgcmVnaXN0cmF0aW9uL3JlY29uc3RydWN0aW9uIG9mCiAgICAgKiBjbGFzc2VzIGJhc2VzIG9uIEJhc2VDbGFzcy4gUmVnaXN0ZXJlZCBjbGFzc2VzIGNhbiB0aGVuIGJlIGNvbnN0cnVjdGVkIGJ5IHRoZSBSZWdpc3RyeSBieSBuYW1lLgogICAgICoKICAgICAqIE5vdGU6IGNsYXNzTmFtZSBpcyByZXF1aXJlZCBiZWNhdXNlIG9uIG1pbmlmaWNhdGlvbiBwcm9jZXNzCiAgICAgKiB0aGUgbmFtZSBvZiBjbGFzc2VzIGNoYW5nZSBhbmQgd2UgY2FuJ3Qgc2ltcGx5IHVzZSAnLi4uLmNvbnN0cnVjdG9yLm5hbWUnLgogICAgICogU28sIHdlIG5lZWQgYSB3YXkgb2YgcmVsYXRpbmcgbWluaWZpZWQgY2xhc3MgbmFtZXMgdG8gdGhlIG9uZSBzdG9yZWQgZm9yIHBlcnNpc3RlbmN5LgogICAgICoKICAgICAqIGkuZS4KICAgICAqIGBgYGphdmFzY3JpcHQKICAgICAqIC8vIEltcG9ydCByZWdpc3RyeSBjbGFzcwogICAgICogY2xhc3MgRm9vKCkgZXh0ZW5kcyBCYXNlQ2xhc3Mge30KICAgICAqCiAgICAgKiBSZWdpc3RyeS5yZWdpc3RlcignRm9vJywgRm9vKQogICAgICogLy8gSW4gY2FzZSAnRm9vJyBjbGFzcyBnZXRzIGl0cyBuYW1lIGNoYW5nZWQgdG8gJ2MnIG9uIG1pbmlmaWNhdGlvbiwKICAgICAqIC8vIGFuZCB0aGUgcGVyc2lzdGVkIGRhdGEgdHlwZSBpcyAnRm9vJywgd2Ugd291bGQga25vdyBob3cgdG8gcmVsYXRlIHRoZW0uCiAgICAgKiBgYGAKICAgICAqCiAgICAgKiBAc3RhdGljCiAgICAgKiBAY2xhc3MgUmVnaXN0cnkKICAgICAqLwogICAgY2xhc3MgUmVnaXN0cnkgewogICAgICAgIC8qKgogICAgICAgICAqIFJlZ2lzdGVycyBhIG5ldyBjbGFzcyB0byB0aGUgZmFjdG9yeS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBjbGFzc05hbWUgLSBOYW1lIG9mIHRoZSByZWdpc3RlcmVkIGNsYXNzCiAgICAgICAgICogQHBhcmFtIGNsYXNzRGVmIC0gQ2xhc3MgcmVwcmVzZW50YXRpb24oQ2xhc3MgZnVuY3Rpb24sIHR5cGUpCiAgICAgICAgICovCiAgICAgICAgc3RhdGljIHJlZ2lzdGVyKGNsYXNzTmFtZSwgY2xhc3NEZWYpIHsKICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSBpbiByZWdpc3RlcmVkQ2xhc3NlcykgewogICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBUaGVyZSdzIGEgY2xhc3MgcmVnaXN0ZXJlZCB3aXRoICcke2NsYXNzTmFtZX0nIG5hbWUuIFNlY29uZCByZWdpc3RyYXRpb24gZmFpbGVkLmApOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vIE5vdGU6IFRvIHByb3ZpZGUgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIHNhbWUgY2xhc3NEZWYgY2FuIGJlIHN0b3JlZCB1bmRlciBtdWx0aXBsZSBuYW1lcy4KICAgICAgICAgICAgLy8gVGhhdHMgdGhlIHJlYXNvbiBiZWhpbmQgdXNpbmcgaW5kZXhlcyBpbnN0ZWFkIG9mIHRoZSBjbGFzc0RlZi4KICAgICAgICAgICAgY29uc3QgaW5kZXggPSBjbGFzc0RlZmluaXRpb25zLmxlbmd0aDsKICAgICAgICAgICAgY2xhc3NEZWZpbml0aW9ucy5wdXNoKGNsYXNzRGVmKTsKICAgICAgICAgICAgY2xhc3NOYW1lc1tpbmRleF0gPSBjbGFzc05hbWU7CiAgICAgICAgICAgIHJlZ2lzdGVyZWRDbGFzc2VzW2NsYXNzTmFtZV0gPSBpbmRleDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyBjbGFzcyBkZWZpbml0aW9uIHVzaW5nIHRoZSBuYW1lIGl0IHdhcyByZWdpc3RlcmVkIHdpdGguCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gY2xhc3NOYW1lIC0gTmFtZSBvZiB0aGUgcmVnaXN0ZXJlZCBjbGFzcwogICAgICAgICAqIEByZXR1cm4gLSBDbGFzcyByZXByZXNlbnRhdGlvbihDbGFzcyBmdW5jdGlvbiwgdHlwZSkKICAgICAgICAgKi8KICAgICAgICBzdGF0aWMgZ2V0Q2xhc3NEZWZpbml0aW9uKGNsYXNzTmFtZSkgewogICAgICAgICAgICBpZiAoIShjbGFzc05hbWUgaW4gcmVnaXN0ZXJlZENsYXNzZXMpKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NsYXNzTmFtZX0gY2xhc3MgaXMgbm90IHJlZ2lzdGVyZWRgKTsKICAgICAgICAgICAgcmV0dXJuIGNsYXNzRGVmaW5pdGlvbnNbcmVnaXN0ZXJlZENsYXNzZXNbY2xhc3NOYW1lXV07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgY2xhc3MgbmFtZSByZWdpc3RlcmVkIGZvciB0aGUgaW5zdGFudGlhdGVkIG9iamVjdC4KICAgICAgICAgKiBAcGFyYW0gY2xhc3NEZWZpbml0aW9uIC0gQ2xhc3MgdHlwZSBkZWZpbml0aW9uLgogICAgICAgICAqIEByZXR1cm4gLSBOYW1lIG9mIHRoZSByZWdpc3RlcmVkIGNsYXNzCiAgICAgICAgICovCiAgICAgICAgc3RhdGljIGdldENsYXNzTmFtZShjbGFzc0RlZmluaXRpb24pIHsKICAgICAgICAgICAgY29uc3QgY2xhc3NJZCA9IGNsYXNzRGVmaW5pdGlvbnMuaW5kZXhPZihjbGFzc0RlZmluaXRpb24pOwogICAgICAgICAgICBpZiAoY2xhc3NJZCA+PSAwICYmIGNsYXNzTmFtZXNbY2xhc3NJZF0pCiAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NOYW1lc1tjbGFzc0lkXTsKICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjbGFzcyBpcyBub3QgcmVnaXN0ZXJlZGApOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgZmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNvbnN0cnVjdCB0aGUgY2xhc3MgcmVnaXN0ZXJlZCB1bmRlciB0aGUgZ2l2ZW4gbmFtZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBjbGFzc05hbWUgLSBOYW1lIG9mIHRoZSByZWdpc3RlcmVkIGNsYXNzCiAgICAgICAgICogQHJldHVybiAtIEluc3RhbnRpYXRlZCBvYmplY3Qgb2YgdGhlIHNwZWNpZmllZCBjbGFzcwogICAgICAgICAqLwogICAgICAgIHN0YXRpYyBjb25zdHJ1Y3RDbGFzcyhjbGFzc05hbWUpIHsKICAgICAgICAgICAgY29uc3QgY2xhc3NEZWZpbml0aW9uID0gY2xhc3NEZWZpbml0aW9uc1tyZWdpc3RlcmVkQ2xhc3Nlc1tjbGFzc05hbWVdXTsKICAgICAgICAgICAgaWYgKCFjbGFzc0RlZmluaXRpb24pCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y2xhc3NOYW1lfSBjbGFzcyBpcyBub3QgcmVnaXN0ZXJlZGApOwogICAgICAgICAgICByZXR1cm4gbmV3IGNsYXNzRGVmaW5pdGlvbigpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBGb3IgdGVzdGluZyBwdXJwb3NlIG9ubHksIG5ldmVyIGNhbGwgdGhpcyBvdXRzaWRlIG9mIHRoZSB0ZXN0IHNjb3BlLgogICAgICAgICAqCiAgICAgICAgICogQHByaXZhdGUKICAgICAgICAgKi8KICAgICAgICBzdGF0aWMgZmx1c2goKSB7CiAgICAgICAgICAgIHJlZ2lzdGVyZWRDbGFzc2VzID0ge307CiAgICAgICAgICAgIGNsYXNzTmFtZXMgPSB7fTsKICAgICAgICAgICAgY2xhc3NEZWZpbml0aW9ucyA9IFtdOwogICAgICAgIH0KICAgIH0KCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovCiAgICBsZXQgY291bnRlciA9IDA7CiAgICAvKioKICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBhIEJhc2VDbGFzcy4KICAgICAqIFRoZSBCYXNlQ2xhc3MgaXMgdGhlIGZvdW5kYXRpb24gY2xhc3Mgb2YgdGhlIFNjZW5lVHJlZSwgYXMgYWxtb3N0IGFsbCBjbGFzc2VzIGRlcml2ZSBmcm9tIGl0LgogICAgICovCiAgICBjbGFzcyBCYXNlQ2xhc3MgewogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZSBhbiBCYXNlQ2xhc3MuCiAgICAgICAgICovCiAgICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgICAgIHRoaXMuX19pZCA9ICsrY291bnRlcjsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogRXZlcnkgaW5zdGFuY2Ugb2YgZWFjaCBjbGFzcyBiYXNlZCBvbiBCYXNlQ2xhc3MgaXMgYXNzaWduZWQgYSB1bmlxdWUgbnVtYmVyLgogICAgICAgICAqIFRoaXMgbnVtYmVyIGlzIG5vdCBwZXJzaXN0ZW50IGluIGJldHdlZW4gZGlmZmVyZW50IGxvYWRzIG9mIGEgc2NlbmUuCiAgICAgICAgICogUmV0dXJucyB0aGUgdW5pcXVlIGlkIG9mIHRoZSBvYmplY3QuCiAgICAgICAgICogQHJldHVybiAtIFRoZSBJZCBvZiB0aGUgb2JqZWN0LgogICAgICAgICAqLwogICAgICAgIGdldElkKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2lkOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bm1hbmdsZWQgbmFtZSBvZiB0aGUgY2xhc3MuCiAgICAgICAgICogQHJldHVybiAtIFRoZSBuYW1lIG9mIHRoZSBjbGFzcyBkZWZpbml0aW9uLgogICAgICAgICAqLwogICAgICAgIGdldENsYXNzTmFtZSgpIHsKICAgICAgICAgICAgcmV0dXJuIFJlZ2lzdHJ5LmdldENsYXNzTmFtZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOwogICAgICAgIH0KICAgIH0KCiAgICAvKiogQ2xhc3MgcmVwcmVzZW50aW5nIGEgQmFzZUV2ZW50LiAqLwogICAgY2xhc3MgQmFzZUV2ZW50IHsKICAgICAgICAvKioKICAgICAgICAgKiBDcmVhdGUgYW4gQmFzZUV2ZW50LgogICAgICAgICAqLwogICAgICAgIGNvbnN0cnVjdG9yKCkgeyB9CiAgICB9CgogICAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqLwogICAgLyoqCiAgICAgKiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVtaXR0aW5nIGV2ZW50cyB1bmRlciBnaXZlbiBuYW1lcywgYW5kIHJlZ2lzdGVyaW5nIGxpc3RlbmVycyB0byB0aG9zZSBldmVudHMuCiAgICAgKiBUaGlzIGlzIGEgYmFzZSBjbGFzcyBmb3IgbW9zdCBjbGFzc2VzIGluIHRoZSBTY2VuZSBUcmVlIGFuZCBSZW5kZXJlciwgZW5hYmxpbmcgb2JzZXJ2ZXJzIHRvIGxpc3RlbiB0byBjaGFuZ2VzIHRocm91Z2hvdXQgdGhlIHN5c3RlbS4KICAgICAqIFRoZSBpbnRlcmZhY2UgZXhwb3NlZCBpcyBzaW1pbGFyIHRvIFtFdmVudEVtaXR0ZXJdKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2NsYXNzX2V2ZW50ZW1pdHRlcikgaW4gTm9kZS4KICAgICAqCiAgICAgKiBTaW1pbGFyIHRvIGhvdyB0aGUgRE9NIGV2ZW50IHN5c3RlbSBpbiB0aGUgYnJvd3NlciB3b3JrcywgZXZlbnRzIGFyZSByZWdpc3RlcmVkIGJ5IG5hbWUuCiAgICAgKiBFeGFtcGxlOiBSZWdpc3RlcmluZyBhIGxpc3RlbmVyIGZvciBhIGN1c3RvbSBldmVudCwgYW5kIHRoZW4gZW1pdHRpbmcgdGhhdCBldmVudC4KICAgICAqIGBgYGphdmFzY3JpcHQKICAgICAqICBjb25zdCBlZSA9IG5ldyBFdmVudEVtaXR0ZXIoKQogICAgICoKICAgICAqICBjb25zdCBldmVudElEID0gZWUub24oJ215RXZlbnQnLCAoZXZlbnQpID0+IHsKICAgICAqICAgIGNvbnNvbGUubG9nKCdNeSBFdmVudCB3YXMgZW1pdHRlZDonLCBldmVudCkKICAgICAqICB9KQogICAgICoKICAgICAqICBlZS5lbWl0KCdteUV2ZW50JywgeyBkYXRhOiA0MiB9KQogICAgICogIC8vIFdlIG5vIGxvbmdlciB3YW50IHRvIGxpc3RlbiB0byB0aGlzIGV2ZW50LCBzbyBsZXQncyByZW1vdmUgdGhlIGxpc3RlbmVyLgogICAgICogIGVlLnJlbW92ZUxpc3RlbmVyQnlJZCgnbXlFdmVudCcsIGV2ZW50SUQpCiAgICAgKiBgYGAKICAgICAqCiAgICAgKgogICAgICovCiAgICBjbGFzcyBFdmVudEVtaXR0ZXIgZXh0ZW5kcyBCYXNlQ2xhc3MgewogICAgICAgIC8qKgogICAgICAgICAqIEluaXRpYWxpemVzIGFuIGVtcHR5IGBsaXN0ZW5lcnNgIG1hcCB0aGF0IHdpbGwgaG9zdCBhbGwgdGhlIGV2ZW50cywKICAgICAgICAgKiB3aGljaCBpbXBsaWVzIHRoYXQgaXQgZG9lc24ndCBhbGxvdyBtdWx0aXBsZSBldmVudHMgd2l0aCB0aGUgc2FtZSBuYW1lLgogICAgICAgICAqCiAgICAgICAgICovCiAgICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgICAgIHN1cGVyKCk7CiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiBmb3IgYSBnaXZlbiBldmVudCBuYW1lLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC4KICAgICAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24oY2FsbGJhY2spLgogICAgICAgICAqIEByZXR1cm4gLSB0aGUgaWQgdGhhdCBjYW4gYmUgdXNlZCB0byByZW1vdmUgdGhlIGxpc3RlbmVyLgogICAgICAgICAqLwogICAgICAgIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHsKICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcikgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGxpc3RlbmVyLicpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSkgewogICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSA9IFtdOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV07CiAgICAgICAgICAgIGlmIChsaXN0ZW5lcnMuaW5jbHVkZXMobGlzdGVuZXIpKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpc3RlbmVyICIke2xpc3RlbmVyLm5hbWV9IiBhbHJlYWR5IGNvbm5lY3RlZCB0byBldmVudCAiJHtldmVudE5hbWV9Ii5gKTsKICAgICAgICAgICAgfQogICAgICAgICAgICAvLyBUT0RPOiBEZXByZWNhdGUgYWxvbmdzaWRlICNhZGRMaXN0ZW5lci4KICAgICAgICAgICAgY29uc3QgaWQgPSBsaXN0ZW5lcnMubGVuZ3RoOwogICAgICAgICAgICBsaXN0ZW5lcnNbaWRdID0gbGlzdGVuZXI7CiAgICAgICAgICAgIHJldHVybiBpZDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2ltaWxhciB0byB0aGUgYG9uYCBtZXRob2Qgd2l0aCB0aGUgZGlmZmVyZW5jZSB0aGF0IHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZCwKICAgICAgICAgKiBpdCBpcyBhdXRvbWF0aWNhbGx5IHVucmVnaXN0ZXJlZCBtZWFuaW5nIHRoYXQgdGhlIGV2ZW50IGxpc3RlbmVyIHdpbGwgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25lIHRpbWUuCiAgICAgICAgICoKICAgICAgICAgKiBVc2VmdWwgZm9yIGV2ZW50cyB0aGF0IHdlIGV4cGVjdCB0byB0cmlnZ2VyIG9uZSB0aW1lLCBzdWNoIGFzIHdoZW4gYXNzZXRzIGxvYWQuCiAgICAgICAgICogYGBgamF2YXNjcmlwdAogICAgICAgICAqIGNvbnN0IGFzc2V0ID0gbmV3IEFzc2V0KCk7CiAgICAgICAgICogYXNzZXQub25jZSgnbG9hZGVkJywgKCkgPT4gewogICAgICAgICAqICAgY29uc29sZS5sb2coIllheSEgdGhlIGFzc2V0IGlzIGxvYWRlZCIpCiAgICAgICAgICogfSkKICAgICAgICAgKiBgYGAKICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBldmVudE5hbWUgLSBUaGUgZXZlbnROYW1lIHZhbHVlCiAgICAgICAgICogQHBhcmFtIGxpc3RlbmVyIC0gVGhlIGxpc3RlbmVyIHZhbHVlCiAgICAgICAgICogQHJldHVybiAtIHRoZSBpZCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIuCiAgICAgICAgICovCiAgICAgICAgb25jZShldmVudE5hbWUsIGxpc3RlbmVyKSB7CiAgICAgICAgICAgIGNvbnN0IGNiID0gKGV2ZW50KSA9PiB7CiAgICAgICAgICAgICAgICBsaXN0ZW5lcihldmVudCk7CiAgICAgICAgICAgICAgICB0aGlzLm9mZihldmVudE5hbWUsIGNiKTsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgcmV0dXJuIHRoaXMub24oZXZlbnROYW1lLCBjYik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmdW5jdGlvbiBmcm9tIHRoZSBzcGVjaWZpZWQgZXZlbnQsIHVzaW5nIGVpdGhlciB0aGUgZnVuY3Rpb24gb3IgdGhlIGluZGV4IGlkLiBEZXBlbmRzIG9uIHdoYXQgaXMgcGFzc2VkIGluLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIGV2ZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBldmVudC4KICAgICAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgbGlzdGVuZXIgZnVuY3Rpb24gb3IgdGhlIGlkIG51bWJlci4KICAgICAgICAgKi8KICAgICAgICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikgewogICAgICAgICAgICBpZiAoIWxpc3RlbmVyKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgY2FsbGJhY2sgZnVuY3Rpb24gKGxpc3RlbmVyKS4nKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09ICdudW1iZXInKSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0ZWQuIFVuLXJlZ2lzdGVyIHVzaW5nIHRoZSBvcmlnaW5hbCBsaXN0ZW5lciBpbnN0ZWFkLicpOwogICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lckJ5SWQoZXZlbnROYW1lLCBsaXN0ZW5lcik7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNbZXZlbnROYW1lXSB8fCBbXTsKICAgICAgICAgICAgY29uc3QgaWRzID0gW107CiAgICAgICAgICAgIGxpc3RlbmVycy5mb3JFYWNoKChlLCBpKSA9PiB7CiAgICAgICAgICAgICAgICBpZiAoZSA9PT0gbGlzdGVuZXIpIHsKICAgICAgICAgICAgICAgICAgICBpZHMucHVzaChpKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGlmIChpZHMubGVuZ3RoID09IDApIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlzdGVuZXIgIiR7bGlzdGVuZXIubmFtZX0iIGlzIG5vdCBjb25uZWN0ZWQgdG8gIiR7ZXZlbnROYW1lfSIgZXZlbnRgKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIC8vIE5vdGU6IGRvIG5vdCBzcGxpY2UgdGhlIGFycmF5IGFzIHRoYXQgd291bGQgY2hhbmdlIHRoZSBpbmRleGVzIG9mIGV4aXN0aW5nIGxpc3RlbmVycy4KICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7CiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW2lkXSA9IG51bGw7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogcmVtb3ZlIGxpc3RlbmVyIGJ5IElEIHJldHVybmVkIGZyb20gI29uCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50LgogICAgICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCByZXR1cm5lZCBieSBhZGRMaXN0ZW5lcgogICAgICAgICAqLwogICAgICAgIHJlbW92ZUxpc3RlbmVyQnlJZChldmVudE5hbWUsIGlkKSB7CiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzW2V2ZW50TmFtZV07CiAgICAgICAgICAgIGlmICghbGlzdGVuZXJzKSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2NhbGxiYWNrIDonICsgaWQgKyAnIHdhcyBub3QgY29ubmVjdGVkIHRvIHRoaXMgZXZlbnQ6JyArIGV2ZW50TmFtZSk7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcnNbaWRdKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElEJyk7CiAgICAgICAgICAgIC8vIE5vdGU6IGRvIG5vdCBzcGxpY2UgdGhlIGFycmF5IGFzIHRoYXQgd291bGQgY2hhbmdlIHRoZSBpbmRleGVzIG9mIGV4aXN0aW5nIGxpc3RlbmVycy4KICAgICAgICAgICAgbGlzdGVuZXJzW2lkXSA9IG51bGw7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRyaWdnZXJzIGFsbCBsaXN0ZW5lciBmdW5jdGlvbnMgaW4gYW4gZXZlbnQuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50LgogICAgICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBkYXRhIHlvdSB3YW50IHRvIHBhc3MgZG93biB0byBhbGwgbGlzdGVuZXIgZnVuY3Rpb25zIGFzIHBhcmFtZXRlci4KICAgICAgICAgKgogICAgICAgICAqLwogICAgICAgIGVtaXQoZXZlbnROYW1lLCBldmVudCA9IG5ldyBCYXNlRXZlbnQoKSkgewogICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmxpc3RlbmVyc1tldmVudE5hbWVdIHx8IFtdOwogICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaCgoZm4pID0+IHsKICAgICAgICAgICAgICAgIC8vIFNraXAgZGlzY29ubmVjdGVkIGxpc3RlbmVycy4KICAgICAgICAgICAgICAgIGlmIChmbikgewogICAgICAgICAgICAgICAgICAgIGZuKGV2ZW50KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgfQogICAgfQoKICAgIGNsYXNzIFBhcmFtZXRlckFkZGVkRXZlbnQgZXh0ZW5kcyBCYXNlRXZlbnQgewogICAgICAgIGNvbnN0cnVjdG9yKG5hbWUpIHsKICAgICAgICAgICAgc3VwZXIoKTsKICAgICAgICAgICAgdGhpcy5uYW1lID0gbmFtZTsKICAgICAgICB9CiAgICB9CgogICAgY2xhc3MgUGFyYW1ldGVyUmVtb3ZlZEV2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHsKICAgICAgICBjb25zdHJ1Y3RvcihuYW1lKSB7CiAgICAgICAgICAgIHN1cGVyKCk7CiAgICAgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7CiAgICAgICAgfQogICAgfQoKICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqLwogICAgLyoqCiAgICAgKiBDbGFzcyB0aGF0IGFsbG93cyBvdGhlciBjbGFzc2VzIHRvIGJlIHBhcmFtZXRlcml6ZWQgYnkgYFBhcmFtZXRlcmAgdHlwZSBvZiBvYmplY3RzLgogICAgICogTm90IG9ubHkgaG9zdGluZyBwYXJhbWV0ZXJzLCBidXQgdGhlaXIgZXZlbnRzLgogICAgICoKICAgICAqIEBleHRlbmRzIHtFdmVudEVtaXR0ZXJ9CiAgICAgKi8KICAgIGNsYXNzIFBhcmFtZXRlck93bmVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHsKICAgICAgICAvKioKICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIFBhcmFtZXRlck93bmVyIGJ5IGluaXRpYWxpemluZyBwYXJhbWV0ZXIgaG9zdGluZyBtYXBwaW5ncyBhbmQgZXZlbnRzLgogICAgICAgICAqCiAgICAgICAgICogRXZlcnkgT2JqZWN0IGhhcyBhIHVuaXF1ZSBpZGVudGlmaWVyIHdoaWNoIGlzIGJhc2VkIG9uIGEgY291bnRlciB0aGF0IGlzIGluY3JlbWVudGVkLgogICAgICAgICAqLwogICAgICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgICAgICBzdXBlcigpOwogICAgICAgICAgICB0aGlzLnBhcmFtRXZlbnRMaXN0ZW5lcklEcyA9IHt9OwogICAgICAgICAgICB0aGlzLnBhcmFtTWFwcGluZyA9IHt9OwogICAgICAgICAgICB0aGlzLnBhcmFtcyA9IFtdOwogICAgICAgICAgICB0aGlzLmRlcHJlY2F0ZWRQYXJhbU1hcHBpbmcgPSB7fTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgY3VycmVudCBvYmplY3QgaGFzLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIEFtb3VudCBvZiBwYXJhbWV0ZXJzIGluIGN1cnJlbnQgb2JqZWN0LgogICAgICAgICAqLwogICAgICAgIGdldE51bVBhcmFtZXRlcnMoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5sZW5ndGg7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgYWxsIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBvYmplY3QuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUGFyYW1ldGVyIExpc3QKICAgICAgICAgKi8KICAgICAgICBnZXRQYXJhbWV0ZXJzKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXM7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIGEgcGFyYW1ldGVyIGluIHBhcmFtZXRlciBsaXN0LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHBhcmFtTmFtZSAtIE5hbWUgb2YgdGhlIHBhcmFtZXRlci4KICAgICAgICAgKiBAcmV0dXJuIC0gUG9zaXRpb24gaW4gdGhlIGFycmF5CiAgICAgICAgICovCiAgICAgICAgZ2V0UGFyYW1ldGVySW5kZXgocGFyYW1OYW1lKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmFtTWFwcGluZ1twYXJhbU5hbWVdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIGBQYXJhbWV0ZXJgIG9iamVjdCBpbiBhIGdpdmVuIGluZGV4CiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBQb3NpdGlvbiBvZiB0aGUgcGFyYW1ldGVyIGluIHRoZSBhcnJheQogICAgICAgICAqIEByZXR1cm4gLSBQYXJhbWV0ZXIgb2JqZWN0IHZhbHVlCiAgICAgICAgICovCiAgICAgICAgZ2V0UGFyYW1ldGVyQnlJbmRleChpbmRleCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXNbaW5kZXhdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBWYWxpZGF0ZXMgaWYgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXIgZXhpc3RzIGluIHRoZSBvYmplY3QuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gcGFyYW1OYW1lIC0gVGhlIHBhcmFtZXRlciBuYW1lLgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGhhc1BhcmFtZXRlcihwYXJhbU5hbWUpIHsKICAgICAgICAgICAgcmV0dXJuIHBhcmFtTmFtZSBpbiB0aGlzLnBhcmFtTWFwcGluZzsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQWRkIGEgbWFwcGluZyBmcm9tIG9uZSBuYW1lIHRvIGEgbmV3IHBhcmFtZXRlci4KICAgICAgICAgKiBUaGlzIGlzIHVzZWQgdG8gaGFuZGxlIG1pZ3JhdGluZyBwYXJhbWV0ZXJzIHRvIG5ldyBuYW1lcy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBrZXkgLSBUaGUgcGFyYW1ldGVyIG5hbWUuCiAgICAgICAgICogQHBhcmFtIHBhcmFtTmFtZSAtIFRoZSBwYXJhbWV0ZXIgbmFtZS4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBhZGRQYXJhbWV0ZXJEZXByZWNhdGlvbk1hcHBpbmcoa2V5LCBwYXJhbU5hbWUpIHsKICAgICAgICAgICAgdGhpcy5kZXByZWNhdGVkUGFyYW1NYXBwaW5nW2tleV0gPSBwYXJhbU5hbWU7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgYFBhcmFtZXRlcmAgb2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBuYW1lCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gcGFyYW1OYW1lIC0gVGhlIHBhcmFtZXRlciBuYW1lLgogICAgICAgICAqIEByZXR1cm4gLSBQYXJhbWV0ZXIgb2JqZWN0IHZhbHVlCiAgICAgICAgICovCiAgICAgICAgZ2V0UGFyYW1ldGVyKHBhcmFtTmFtZSkgewogICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLnBhcmFtTWFwcGluZ1twYXJhbU5hbWVdOwogICAgICAgICAgICBpZiAoaW5kZXggPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICBjb25zdCBuZXdQYXJhbU5hbWUgPSB0aGlzLmRlcHJlY2F0ZWRQYXJhbU1hcHBpbmdbcGFyYW1OYW1lXTsKICAgICAgICAgICAgICAgIGlmICghbmV3UGFyYW1OYW1lKSB7CiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogU2hvdWxkIHRoaXMgbWV0aG9kIG5vdCByZXR1cm4gbnVsbD8KICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyBFcnJvcihgTm8gUGFyYW1ldGVyIHdpdGggdGhhdCBuYW1lIGV4aXN0czogJHtwYXJhbU5hbWV9IGApCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYFBhcmFtZXRlciBuYW1lICR7cGFyYW1OYW1lfSBpcyBub3cgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAke25ld1BhcmFtTmFtZX0gaW5zdGVhZC5gKTsKICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHRoaXMucGFyYW1NYXBwaW5nW25ld1BhcmFtTmFtZV07CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zW2luZGV4XTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gaW4gZGVyaXZlZCBjbGFzc2VzCiAgICAgICAgICogdG8gcGVyZm9ybSBnZW5lcmFsIHVwZGF0ZXMgKHNlZSBHTFBhc3Mgb3IgQmFzZUl0ZW0pLgogICAgICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgZW1pdHRlZCBieSB0aGUgcGFyYW1ldGVyLgogICAgICAgICAqIEBwcml2YXRlCiAgICAgICAgICovCiAgICAgICAgcGFyYW1ldGVyVmFsdWVDaGFuZ2VkKGV2ZW50KSB7CiAgICAgICAgICAgIHRoaXMuZW1pdCgncGFyYW1ldGVyVmFsdWVDaGFuZ2VkJywgZXZlbnQpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBBZGRzIGBQYXJhbWV0ZXJgIG9iamVjdCB0byB0aGUgb3duZXIncyBwYXJhbWV0ZXIgbGlzdC4KICAgICAgICAgKgogICAgICAgICAqIEBlbWl0cyBgcGFyYW1ldGVyQWRkZWRgIHdpdGggdGhlIG5hbWUgb2YgdGhlIHBhcmFtLgogICAgICAgICAqIEBwYXJhbSBwYXJhbSAtIFRoZSBwYXJhbWV0ZXIgdG8gYWRkLgogICAgICAgICAqIEByZXR1cm4gLSBXaXRoIGBvd25lcmAgYW5kIGB2YWx1ZUNoYW5nZWRgIGV2ZW50IHNldC4KICAgICAgICAgKi8KICAgICAgICBhZGRQYXJhbWV0ZXIocGFyYW0pIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0UGFyYW1ldGVyKHBhcmFtLCB0aGlzLnBhcmFtcy5sZW5ndGgpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBBZGRzIGBQYXJhbWV0ZXJgIG9iamVjdCB0byB0aGUgb3duZXIncyBwYXJhbWV0ZXIgbGlzdCB1c2luZyB0aGUgaW5kZXguCiAgICAgICAgICogSXQgcmVwbGFjZXMgdGhlIGV2ZW50IGluIHRoZSBzcGVjaWZpZWQgaW5kZXguCiAgICAgICAgICoKICAgICAgICAgKgogICAgICAgICAqIEBlbWl0cyBgcGFyYW1ldGVyQWRkZWRgIHdpdGggdGhlIG5hbWUgb2YgdGhlIHBhcmFtLgogICAgICAgICAqIEBwYXJhbSBwYXJhbSAtIFRoZSBwYXJhbWV0ZXIgdG8gaW5zZXJ0LgogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS4KICAgICAgICAgKiBAcmV0dXJuIC0gV2l0aCBgb3duZXJgIGFuZCBgdmFsdWVDaGFuZ2VkYCBldmVudCBzZXQuCiAgICAgICAgICovCiAgICAgICAgaW5zZXJ0UGFyYW1ldGVyKHBhcmFtLCBpbmRleCkgewogICAgICAgICAgICBjb25zdCBuYW1lID0gcGFyYW0uZ2V0TmFtZSgpOwogICAgICAgICAgICBpZiAodGhpcy5wYXJhbU1hcHBpbmdbbmFtZV0gIT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1JlcGxhY2luZyBQYXJhbWV0ZXI6JyArIG5hbWUpOwogICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVQYXJhbWV0ZXIobmFtZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcGFyYW0uc2V0T3duZXIodGhpcyk7CiAgICAgICAgICAgIHRoaXMucGFyYW1FdmVudExpc3RlbmVySURzW25hbWVdID0gcGFyYW0ub24oJ3ZhbHVlQ2hhbmdlZCcsIChldmVudCkgPT4gewogICAgICAgICAgICAgICAgLy8gTm90ZTogc3ByZWFkIG9wZXJhdG9ycyBjYXVzZSBlcnJvcnMgb24gaU9TIDExLgogICAgICAgICAgICAgICAgY29uc3QgbmV3RXZlbnQgPSB7IHBhcmFtIH07CiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBldmVudCkKICAgICAgICAgICAgICAgICAgICBuZXdFdmVudFtrZXldID0gZXZlbnRba2V5XTsKICAgICAgICAgICAgICAgIHRoaXMucGFyYW1ldGVyVmFsdWVDaGFuZ2VkKG5ld0V2ZW50KTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHRoaXMucGFyYW1zLnNwbGljZShpbmRleCwgMCwgcGFyYW0pOwogICAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXg7IGkgPCB0aGlzLnBhcmFtcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgdGhpcy5wYXJhbU1hcHBpbmdbdGhpcy5wYXJhbXNbaV0uZ2V0TmFtZSgpXSA9IGk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgUGFyYW1ldGVyQWRkZWRFdmVudChuYW1lKTsKICAgICAgICAgICAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJBZGRlZCcsIGV2ZW50KTsKICAgICAgICAgICAgcmV0dXJuIHBhcmFtOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZW1vdmVzIGBQYXJhbWV0ZXJgIGZyb20gb3duZXIsIGJ5IHVzaW5nIHBhcmFtZXRlcidzIG5hbWUuCiAgICAgICAgICogQGVtaXRzIGBwYXJhbWV0ZXJSZW1vdmVkYCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBwYXJhbS4KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBwYXJhbWV0ZXIgbmFtZS4KICAgICAgICAgKi8KICAgICAgICByZW1vdmVQYXJhbWV0ZXIobmFtZSkgewogICAgICAgICAgICBpZiAodGhpcy5wYXJhbU1hcHBpbmdbbmFtZV0gPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByZW1vdmUgUGFyYW1ldGVyOicgKyBuYW1lKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucGFyYW1NYXBwaW5nW25hbWVdOwogICAgICAgICAgICBjb25zdCBwYXJhbSA9IHRoaXMucGFyYW1zW3RoaXMucGFyYW1NYXBwaW5nW25hbWVdXTsKICAgICAgICAgICAgcGFyYW0ucmVtb3ZlTGlzdGVuZXJCeUlkKCd2YWx1ZUNoYW5nZWQnLCB0aGlzLnBhcmFtRXZlbnRMaXN0ZW5lcklEc1tuYW1lXSk7CiAgICAgICAgICAgIHRoaXMucGFyYW1zLnNwbGljZShpbmRleCwgMSk7CiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBhcmFtTWFwcGluZ1tuYW1lXTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgdGhpcy5wYXJhbXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgIHRoaXMucGFyYW1NYXBwaW5nW3RoaXMucGFyYW1zW2ldLmdldE5hbWUoKV0gPSBpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IFBhcmFtZXRlclJlbW92ZWRFdmVudChuYW1lKTsKICAgICAgICAgICAgdGhpcy5lbWl0KCdwYXJhbWV0ZXJSZW1vdmVkJywgZXZlbnQpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXBsYWNlcyBvbGQgYFBhcmFtZXRlcmAgYnkgcGFzc2luZyBhIG5ldyBvbmUgd2l0aCB0aGUgc2FtZSBuYW1lLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHBhcmFtIC0gVGhlIHBhcmFtZXRlciB0byByZXBsYWNlLgogICAgICAgICAqIEByZXR1cm4gLSBgUGFyYW1ldGVyYCB3aXRoIGB2YWx1ZUNoYW5nZWRgIGV2ZW50IHNldC4KICAgICAgICAgKi8KICAgICAgICByZXBsYWNlUGFyYW1ldGVyKHBhcmFtKSB7CiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBwYXJhbS5nZXROYW1lKCk7CiAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtTWFwcGluZ1tuYW1lXSA9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHJlcGxhY2UgUGFyYW1ldGVyOicgKyBuYW1lKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucGFyYW1NYXBwaW5nW25hbWVdOwogICAgICAgICAgICB0aGlzLnJlbW92ZVBhcmFtZXRlcihuYW1lKTsKICAgICAgICAgICAgdGhpcy5pbnNlcnRQYXJhbWV0ZXIocGFyYW0sIGluZGV4KTsKICAgICAgICAgICAgcmV0dXJuIHBhcmFtOwogICAgICAgIH0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCiAgICAgICAgLy8gUGVyc2lzdGVuY2UKICAgICAgICAvKioKICAgICAgICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGpzb24gb2JqZWN0LgogICAgICAgICAqLwogICAgICAgIHRvSlNPTihjb250ZXh0KSB7CiAgICAgICAgICAgIGNvbnN0IGpzb24gPSB7CiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLmdldENsYXNzTmFtZSgpLAogICAgICAgICAgICB9OwogICAgICAgICAgICBjb25zdCBwYXJhbXNKU09OID0ge307CiAgICAgICAgICAgIGxldCBzYXZlZFBhcmFtcyA9IDA7CiAgICAgICAgICAgIGZvciAoY29uc3QgcGFyYW0gb2YgdGhpcy5wYXJhbXMpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtSlNPTiA9IHBhcmFtLnRvSlNPTihjb250ZXh0KTsKICAgICAgICAgICAgICAgIGlmIChwYXJhbUpTT04pIHsKICAgICAgICAgICAgICAgICAgICBwYXJhbXNKU09OW3BhcmFtLmdldE5hbWUoKV0gPSBwYXJhbUpTT047CiAgICAgICAgICAgICAgICAgICAgc2F2ZWRQYXJhbXMrKzsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoc2F2ZWRQYXJhbXMgPiAwKQogICAgICAgICAgICAgICAganNvbi5wYXJhbXMgPSBwYXJhbXNKU09OOwogICAgICAgICAgICByZXR1cm4ganNvbjsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBqc29uIC0gVGhlIGpzb24gb2JqZWN0IHRoaXMgaXRlbSBtdXN0IGRlY29kZS4KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGZyb21KU09OKGpzb24sIGNvbnRleHQpIHsKICAgICAgICAgICAgaWYgKGpzb24ucGFyYW1zKSB7CiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBqc29uLnBhcmFtcykgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IHBqID0ganNvbi5wYXJhbXNba2V5XTsKICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbSA9IHRoaXMuZ2V0UGFyYW1ldGVyKGtleSk7CiAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJhbSkKICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJhbSBub3QgZm91bmQ6JyArIGtleSk7CiAgICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwai5wYXJhbVBhdGgpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5yZXNvbHZlUGF0aChwai5wYXJhbVBhdGgsIChwYXJhbSkgPT4gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVBhcmFtZXRlcihwYXJhbSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAoKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gcmVzb2x2ZSBzaGFyZWQgcGFyYW1ldGVyOicgKyBwai5wYXJhbVBhdGgpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5mcm9tSlNPTihwaiwgY29udGV4dCk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVXNlcyBwYXNzZWQgaW4gQmluUmVhZGVyIG9iamVjdChjb250YWluaW5nIGFuIEludDMyIGFycmF5IHdpdGggYWxsIHRoZSBwYXJhbWV0ZXJzKSB0byByZWNvbnN0cnVjdCBhbGwgcGFyYW1ldGVycyBzdGF0ZS4KICAgICAgICAgKgogICAgICAgICAqIEluIGVhY2ggaXRlcmF0aW9uIG9mIHRoZSBhcnJheSwgcHJvcFR5cGUgYW5kIHByb3BOYW1lIGFyZSBleHRyYWN0ZWQgYW5kCiAgICAgICAgICogdXNlZCB0byBidWlsZCB0aGUgcmlnaHQgYFBhcmFtZXRlcmAgY2xhc3MuIFRoZW4gYWxsIG9mIHRoZW0gYXJlIGFkZGVkIHRvIHRoZSBvYmplY3QuCiAgICAgICAgICoKICAgICAgICAgKiBAZW1pdHMgYHBhcmFtZXRlckFkZGVkYCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBwYXJhbS4KICAgICAgICAgKiBAcGFyYW0gcmVhZGVyIC0gVGhlIHJlYWRlciB2YWx1ZS4KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHJlYWRCaW5hcnkocmVhZGVyLCBjb250ZXh0KSB7CiAgICAgICAgICAgIC8vIFRPRE86IG1ha2UgdGhpcyB3b3JrCiAgICAgICAgICAgIGlmICgoY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LnZlcnNpb25zWyd6ZWEtZW5naW5lJ10uY29tcGFyZShbMCwgMCwgM10pKSA+PSAwKSB7CiAgICAgICAgICAgICAgICBjb25zdCBudW1Qcm9wcyA9IHJlYWRlci5sb2FkVUludDMyKCk7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVByb3BzOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wVHlwZSA9IHJlYWRlci5sb2FkU3RyKCk7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSByZWFkZXIubG9hZFN0cigpOwogICAgICAgICAgICAgICAgICAgIGxldCBwYXJhbSA9IHRoaXMuZ2V0UGFyYW1ldGVyKHByb3BOYW1lKTsKICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtID0gUmVnaXN0cnkuY29uc3RydWN0Q2xhc3MocHJvcFR5cGUpOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmFtKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmFibGUgdG8gY29uc3RydWN0IHByb3A6JyArIHByb3BOYW1lICsgJyBvZiB0eXBlOicgKyBwcm9wVHlwZSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBwYXJhbS5zZXROYW1lKHByb3BOYW1lKTsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRQYXJhbWV0ZXIocGFyYW0pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBwYXJhbS5yZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ29udmVydHMgb2JqZWN0J3MgSlNPTiB2YWx1ZSBhbmQgY29udmVydHMgaXQgdG8gYSBzdHJpbmcuCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQKICAgICAgICAgKiBAcmV0dXJuIC0gU3RyaW5nIG9mIG9iamVjdCdzIHBhcmFtZXRlciBsaXN0IHN0YXRlLgogICAgICAgICAqLwogICAgICAgIHRvU3RyaW5nKGNvbnRleHQpIHsKICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCksIG51bGwsIDIpOwogICAgICAgIH0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCiAgICAgICAgLy8gQ2xvbmUgYW5kIERlc3Ryb3kKICAgICAgICAvKioKICAgICAgICAgKiBDb3BpZXMgUGFyYW1ldGVycyBmcm9tIGFub3RoZXIgYFBhcmFtZXRlck93bmVyYCB0byBjdXJyZW50IG9iamVjdC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBzcmMgLSBUaGUgUGFyYW1ldGVyT3duZXIgY29weSBmcm9tLgogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUKICAgICAgICAgKi8KICAgICAgICBjb3B5RnJvbShzcmMsIGNvbnRleHQpIHsKICAgICAgICAgICAgLy8gTm90ZTogTG9vcCBvdmVyIHRoZSBwYXJhbWV0ZXJzIGluIHJldmVyc2Ugb3JkZXIsCiAgICAgICAgICAgIC8vIHRoaXMgaXMgYmVjYXVzZSBvZnRlbiwgcGFyYW1ldGVyIGRlcGVuZGVuY2llcwogICAgICAgICAgICAvLyBhcmUgYm90dG9tIHRvIHRvcCAoYm90dG9tIHBhcmFtcyBkZXBlbmRlbnQgb24gaGlnaGVyIHBhcmFtcykuCiAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCBhcyBhIHBhcmFtZXRlciBpcyBzZXQgd2l0aCBhIG5ldyB2YWx1ZQogICAgICAgICAgICAvLyBpdCB3aWxsIGRpcnR5IHRoZSBwYXJhbXMgYmVsb3cgaXQuCiAgICAgICAgICAgIGxldCBpID0gc3JjLmdldE51bVBhcmFtZXRlcnMoKTsKICAgICAgICAgICAgd2hpbGUgKGktLSkgewogICAgICAgICAgICAgICAgY29uc3Qgc3JjUGFyYW0gPSBzcmMuZ2V0UGFyYW1ldGVyQnlJbmRleChpKTsKICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXIoc3JjUGFyYW0uZ2V0TmFtZSgpKTsKICAgICAgICAgICAgICAgIGlmIChwYXJhbSkgewogICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHdlIGFyZSBub3QgY2xvbmluZyB0aGUgdmFsdWVzLgogICAgICAgICAgICAgICAgICAgIHBhcmFtLmNvcHlGcm9tKHNyY1BhcmFtKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUGFyYW1ldGVyKHNyY1BhcmFtLmNsb25lKCkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQoKICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi8KICAgIGZ1bmN0aW9uIGFwcHJveEVxdWFsKGEsIGIpIHsKICAgICAgICByZXR1cm4gIWEuc29tZSgodmFsdWUsIGluZGV4KSA9PiBNYXRoLmFicyhiW2luZGV4XSAtIHZhbHVlKSA+IDAuMDAxKTsKICAgIH0KICAgIGZ1bmN0aW9uIGlzSW5pdGlhbGl6ZWQoYSkgewogICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykgewogICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihhW2ldKSkKICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZmFsc2U7CiAgICB9CiAgICBjbGFzcyBBdHRyaWJ1dGUgZXh0ZW5kcyBCYXNlQ2xhc3MgewogICAgICAgIGNvbnN0cnVjdG9yKGRhdGFUeXBlTmFtZSwgc3RyaWRlKSB7CiAgICAgICAgICAgIHN1cGVyKCk7CiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMCk7CiAgICAgICAgICAgIHRoaXMuZGF0YVR5cGVOYW1lID0gZGF0YVR5cGVOYW1lOwogICAgICAgICAgICB0aGlzLnN0cmlkZSA9IHN0cmlkZTsKICAgICAgICAgICAgdGhpcy5pbml0UmFuZ2UoMCk7CiAgICAgICAgICAgIHRoaXMuc3BsaXRzID0ge307CiAgICAgICAgICAgIHRoaXMuc3BsaXRWYWx1ZXMgPSBbXTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyB0aGUgTWVzaCByZWZlcmVuY2UgdG8gdGhlIFZlcnRleEF0dHJpYnV0ZS4gVGhpcyBpcyBuZWVkZWQgZm9yIGF0dHJpYnV0ZXMKICAgICAgICAgKiBhc3NpZ25lZCB0byBtZXNoZXMsIGFuZCBpcyB1c2VkIHRvIGNhbGN1bGF0ZSBmYWNlIHZlcnRleCBpbmRpY2VzLgogICAgICAgICAqID4gTm90ZTogdGhlIG1lc2ggYXV0b21hdGljYWxseSBjYWxscyB0aGlzIG1ldGhvZCB3aGVuIGEgdmVydGV4IGF0dHJpYnV0ZSBpcyBhc3NpZ25lZC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBtZXNoIC0gVGhlIG1lc2ggb2JqZWN0CiAgICAgICAgICovCiAgICAgICAgc2V0TWVzaChtZXNoKSB7CiAgICAgICAgICAgIHRoaXMubWVzaCA9IG1lc2g7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIGJhY2tpbmcgYXJyYXkgZm9yIHRoaXMgYXR0cmlidXRlCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBhc0FycmF5KCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBtYXRoIHR5cGUgdGhpcyBhdHRyaWJ1dGUgc3RvcmVzLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZ2V0RGF0YVR5cGVOYW1lKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhVHlwZU5hbWU7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIGNvdW50IG9mIGF0dHJpYnV0ZSB2YWx1ZXMgaW4gdGhlIGRhdGEuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXRDb3VudCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGggLyB0aGlzLnN0cmlkZTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyB0aGUgY291bnQgb2YgYXR0cmlidXRlIHZhbHVlcyBpbiB0aGUgZGF0YS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBzaXplIC0gVGhlIHNpemUgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0Q291bnQoY291bnQpIHsKICAgICAgICAgICAgY29uc3QgcHJldkxlbmd0aCA9IHRoaXMuZGF0YS5sZW5ndGg7CiAgICAgICAgICAgIGNvbnN0IG5ld0xlbmd0aCA9IGNvdW50ICogdGhpcy5zdHJpZGU7CiAgICAgICAgICAgIGlmIChuZXdMZW5ndGggPiBwcmV2TGVuZ3RoKSB7CiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheShuZXdMZW5ndGgpOwogICAgICAgICAgICAgICAgZGF0YS5zZXQodGhpcy5kYXRhLCAwKTsKICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7CiAgICAgICAgICAgICAgICB0aGlzLmluaXRSYW5nZShwcmV2TGVuZ3RoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmIChuZXdMZW5ndGggPCBwcmV2TGVuZ3RoKSB7CiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmRhdGEuc2xpY2UoMCwgbmV3TGVuZ3RoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIDsKICAgICAgICAgICAgdGhpcy5zcGxpdHMgPSB7fTsKICAgICAgICAgICAgdGhpcy5zcGxpdFZhbHVlcyA9IFtdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBGaWxscyB1cCBkYXRhIHZhbHVlcyB3aXRoIGRlZmF1bHQgb25lcyBzdGFydGluZyBmcm9tIHRoZSBzcGVjaWZpZWQgaW5kZXguCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gc3RhcnQgLSBUaGUgc3RhcnQgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgaW5pdFJhbmdlKHN0YXJ0KSB7CiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHZhbHVlcyB0byBpbnZhbGlkIHZhbHVlcy4KICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSBOdW1iZXIuTmFOOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBlbGVtZW50cyBzdG9yZWQgaW4gZWFjaCBgVGAuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXQgbnVtRWxlbWVudHMoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmlkZTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyBkYXRhIHZhbHVlIG9mIHRoZSBzcGVjaWZpZWQgaW5kZXguCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggdmFsdWUuCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZ2V0RmxvYXQzMlZhbHVlKGluZGV4KSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbaW5kZXhdOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIGRhdGEgdmFsdWUgaW4gdGhlIHNwZWNpZmllZCBpbmRleC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS4KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0RmxvYXQzMlZhbHVlKGluZGV4LCB2YWx1ZSkgewogICAgICAgICAgICB0aGlzLmRhdGFbaW5kZXhdID0gdmFsdWU7CiAgICAgICAgfQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCiAgICAgICAgLy8gRmFjZSBWZXJ0ZXggVmFsdWVzCiAgICAgICAgLyoqCiAgICAgICAgICogVGhlIGdldFNwbGl0cyBtZXRob2QuCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZ2V0U3BsaXRzKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5zcGxpdHM7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIGEgY29ybmVyIHZlcnRleCBvZiBhIGZhY2UuCiAgICAgICAgICogQHBhcmFtIGZhY2UgLSBUaGUgZmFjZSBpbmRleC4KICAgICAgICAgKiBAcGFyYW0gZmFjZVZlcnRleCAtIFRoZSBpbmRleCBvZiB2ZXJ0ZXggd2l0aGluIHRoZSBmYWNlLiBbMC4uLiBudW0gZmFjZSB2ZXJ0aWNlc10KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXRGYWNlVmVydGV4VmFsdWVSZWZfYXJyYXkoZmFjZSwgZmFjZVZlcnRleCkgewogICAgICAgICAgICBjb25zdCB2ZXJ0ZXggPSB0aGlzLm1lc2guZ2V0RmFjZVZlcnRleEluZGV4KGZhY2UsIGZhY2VWZXJ0ZXgpOwogICAgICAgICAgICBpZiAodmVydGV4IGluIHRoaXMuc3BsaXRzICYmIGZhY2UgaW4gdGhpcy5zcGxpdHNbdmVydGV4XSkgewogICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXRWYWx1ZXNbdGhpcy5zcGxpdHNbdmVydGV4XVtmYWNlXV07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zdWJhcnJheSh2ZXJ0ZXggKiB0aGlzLnN0cmlkZSwgKHZlcnRleCArIDEpICogdGhpcy5zdHJpZGUpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIGNvcm5lciB2ZXJ0ZXggb2YgYSBmYWNlLgogICAgICAgICAqIEBwYXJhbSBmYWNlIC0gVGhlIGZhY2UgaW5kZXguCiAgICAgICAgICogQHBhcmFtIGZhY2VWZXJ0ZXggLSBUaGUgaW5kZXggb2YgdmVydGV4IHdpdGhpbiB0aGUgZmFjZS4gWzAuLi4gbnVtIGZhY2UgdmVydGljZXNdCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHNldEZhY2VWZXJ0ZXhWYWx1ZV9hcnJheShmYWNlLCBmYWNlVmVydGV4LCB2YWx1ZSkgewogICAgICAgICAgICBjb25zdCB2ZXJ0ZXggPSB0aGlzLm1lc2guZ2V0RmFjZVZlcnRleEluZGV4KGZhY2UsIGZhY2VWZXJ0ZXgpOwogICAgICAgICAgICB0aGlzLnNldEZhY2VWZXJ0ZXhWYWx1ZV9CeVZlcnRleEluZGV4KGZhY2UsIHZlcnRleCwgdmFsdWUpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgc2V0RmFjZVZlcnRleFZhbHVlX0J5VmVydGV4SW5kZXggbWV0aG9kLgogICAgICAgICAqIEBwYXJhbSBmYWNlIC0gVGhlIGZhY2UgaW5kZXguCiAgICAgICAgICogQHBhcmFtIHZlcnRleCAtIFRoZSB2ZXJ0ZXggdmFsdWUuCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHNldEZhY2VWZXJ0ZXhWYWx1ZV9CeVZlcnRleEluZGV4KGZhY2UsIHZlcnRleCwgdmFsdWUpIHsKICAgICAgICAgICAgY29uc3QgY3VyclZhbHVlID0gdGhpcy5kYXRhLnN1YmFycmF5KHZlcnRleCAqIHRoaXMuc3RyaWRlLCAodmVydGV4ICsgMSkgKiB0aGlzLnN0cmlkZSk7CiAgICAgICAgICAgIGlmICghaXNJbml0aWFsaXplZChjdXJyVmFsdWUpKSB7CiAgICAgICAgICAgICAgICAvLyB0aGUgdmFsdWUgaXMgdW5pbml0aWFsaXplZC4gSW5pdGlhbGl6ZSBpdC4KICAgICAgICAgICAgICAgIGN1cnJWYWx1ZS5zZXQodmFsdWUpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgaWYgKGFwcHJveEVxdWFsKGN1cnJWYWx1ZSwgdmFsdWUpKSA7CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgLy8gVGhlIG5ldyB2YWx1ZSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZXhpc3RpbmcgdmFsdWUKICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggaW4gdGhpcy5zcGxpdHMpIHsKICAgICAgICAgICAgICAgICAgICAvLyBOb3cgY2hlY2sgaWYgYW55IGV4aXN0aW5nIHNwbGl0cyBmb3IgdGhpcyB2ZXJ0ZXggbWF0Y2ggdGhlIHZhbHVlIGJlaW5nIHNldC4KICAgICAgICAgICAgICAgICAgICAvLyBpLmUuIGZvciBmYWNlcyBhcm91bmQgYSB2ZXJ0ZXgsIHRoZXJlIHdpbGwgb2Z0ZW4gYmUgYSBzZWFtIGFsb25nIDIgZWRnZXMKICAgICAgICAgICAgICAgICAgICAvLyB3aGVyZSB0aGUgdmFsdWVzIGRpZmZlci4gT24gZWFjaCBzaWRlIG9mIHRoZSBzZWFtLCBhbGwgZmFjZXMgY2FuIHVzZSB0aGUgc2FtZQogICAgICAgICAgICAgICAgICAgIC8vIHZhbHVlLiBXZSBzaG91bGQgc2VlIHRoZW4gb25seSBvbmUgc3BsaXQgdmFsdWUgZm9yIHRoZSB2ZXJ0ZXguCiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVydGV4U3BsaXRJZHMgPSB0aGlzLnNwbGl0c1t2ZXJ0ZXhdOwogICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmlkIGluIHZlcnRleFNwbGl0SWRzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwbGl0SWQgPSB2ZXJ0ZXhTcGxpdElkc1tmaWRdOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXBwcm94RXF1YWwodGhpcy5zcGxpdFZhbHVlc1tzcGxpdElkXSwgdmFsdWUpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZS11c2UgdGhpcyBzcGxpdCB2YWx1ZQogICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVydGV4U3BsaXRJZHNbZmFjZV0gPSBzcGxpdElkOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIC8vIElmIGEgc3BsaXQgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgZmFjZSwgcmUtdXNlIGl0LgogICAgICAgICAgICAgICAgICAgIGlmIChmYWNlIGluIHRoaXMuc3BsaXRzW3ZlcnRleF0pIHsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdFZhbHVlc1t0aGlzLnNwbGl0c1t2ZXJ0ZXhdW2ZhY2VdXSA9IHZhbHVlOwogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdHNbdmVydGV4XSA9IHt9OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy5zcGxpdHNbdmVydGV4XVtmYWNlXSA9IHRoaXMuc3BsaXRWYWx1ZXMubGVuZ3RoOwogICAgICAgICAgICAgICAgdGhpcy5zcGxpdFZhbHVlcy5wdXNoKHZhbHVlKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgc2V0U3BsaXRWZXJ0ZXhWYWx1ZSBtZXRob2QuCiAgICAgICAgICogQHBhcmFtIHZlcnRleCAtIFRoZSB2ZXJ0ZXggdmFsdWUuCiAgICAgICAgICogQHBhcmFtIGZhY2UgLSBUaGUgZmFjZSBpbmRleC4KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0U3BsaXRWZXJ0ZXhWYWx1ZV9hcnJheSh2ZXJ0ZXgsIGZhY2UsIHZhbHVlKSB7CiAgICAgICAgICAgIGlmICghKHZlcnRleCBpbiB0aGlzLnNwbGl0cykpCiAgICAgICAgICAgICAgICB0aGlzLnNwbGl0c1t2ZXJ0ZXhdID0ge307CiAgICAgICAgICAgIGlmIChmYWNlIGluIHRoaXMuc3BsaXRzW3ZlcnRleF0pIHsKICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJWYWx1ZSA9IHRoaXMuc3BsaXRWYWx1ZXNbdGhpcy5zcGxpdHNbdmVydGV4XVtmYWNlXV07CiAgICAgICAgICAgICAgICBpZiAoYXBwcm94RXF1YWwoY3VyclZhbHVlLCB2YWx1ZSkpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdGYWNlIFZlcnRleCBBbHJlYWR5IFNwbGl0IHdpdGggZGlmZmVyZW50IHZhbHVlJyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5zcGxpdHNbdmVydGV4XVtmYWNlXSA9IHRoaXMuc3BsaXRWYWx1ZXMubGVuZ3RoOwogICAgICAgICAgICB0aGlzLnNwbGl0VmFsdWVzLnB1c2godmFsdWUpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgc2V0U3BsaXRWZXJ0ZXhWYWx1ZXMgbWV0aG9kLgogICAgICAgICAqIEBwYXJhbSB2ZXJ0ZXggLSBUaGUgdmVydGV4IHZhbHVlLgogICAgICAgICAqIEBwYXJhbSBmYWNlR3JvdXAgLSBUaGUgZmFjZUdyb3VwIHZhbHVlLgogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzZXRTcGxpdFZlcnRleFZhbHVlcyh2ZXJ0ZXgsIGZhY2VHcm91cCwgdmFsdWUpIHsKICAgICAgICAgICAgaWYgKCEodmVydGV4IGluIHRoaXMuc3BsaXRzKSkKICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRzW3ZlcnRleF0gPSB7fTsKICAgICAgICAgICAgY29uc3Qgc3BsaXRJbmRleCA9IHRoaXMuc3BsaXRWYWx1ZXMubGVuZ3RoOwogICAgICAgICAgICB0aGlzLnNwbGl0VmFsdWVzLnB1c2godmFsdWUpOwogICAgICAgICAgICBmb3IgKGNvbnN0IGZhY2Ugb2YgZmFjZUdyb3VwKSB7CiAgICAgICAgICAgICAgICAvLyBpZiAoZmFjZSBpbiB0aGlzLnNwbGl0c1t2ZXJ0ZXhdKSB7CiAgICAgICAgICAgICAgICAvLyAgICAgbGV0IGN1cnJWYWx1ZSA9IHRoaXMuc3BsaXRWYWx1ZXNbdGhpcy5zcGxpdHNbdmVydGV4XVtmYWNlXV07CiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKGN1cnJWYWx1ZS5hcHByb3hFcXVhbCh2YWx1ZSkpCiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgIC8vICAgICBjb25zb2xlLndhcm4oIkZhY2UgVmVydGV4IEFscmVhZHkgU3BsaXQgd2l0aCBkaWZmZXJlbnQgdmFsdWUiKTsKICAgICAgICAgICAgICAgIC8vIH0KICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRzW3ZlcnRleF1bZmFjZV0gPSBzcGxpdEluZGV4OwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBnZW5lcmF0ZVNwbGl0VmFsdWVzIG1ldGhvZC4KICAgICAgICAgKiBAcGFyYW0gc3BsaXRJbmRpY2VzIC0gVGhlIHNwbGl0SW5kaWNlcyB2YWx1ZS4KICAgICAgICAgKiBAcGFyYW0gc3BsaXRDb3VudCAtIFRoZSBzcGxpdENvdW50IHZhbHVlLgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdlbmVyYXRlU3BsaXRWYWx1ZXMoc3BsaXRJbmRpY2VzLCBzcGxpdENvdW50KSB7CiAgICAgICAgICAgIGlmIChzcGxpdENvdW50ID09IDApCiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhOwogICAgICAgICAgICBjb25zdCBudW1VblNwbGl0VmFsdWVzID0gdGhpcy5nZXRDb3VudCgpOwogICAgICAgICAgICBjb25zdCBkYXRhID0gbmV3IEZsb2F0MzJBcnJheSgobnVtVW5TcGxpdFZhbHVlcyArIHNwbGl0Q291bnQpICogdGhpcy5zdHJpZGUpOwogICAgICAgICAgICBkYXRhLnNldCh0aGlzLmRhdGEpOwogICAgICAgICAgICAvLyBOb3cgZHVwbGljYXRlIHRoZSBzcGxpdCB2YWx1ZXMgdG8gZ2VuZXJhdGUgYW4gYXR0cmlidXRlcyBhcnJheQogICAgICAgICAgICAvLyB1c2luZyB0aGUgc2hhcmVkIHNwbGl0cyBhY3Jvc3MgYWxsIGF0dHJpYnV0ZXMuCiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW4KICAgICAgICAgICAgZm9yIChjb25zdCB2ZXJ0ZXggaW4gc3BsaXRJbmRpY2VzKSB7CiAgICAgICAgICAgICAgICBjb25zdCBmYWNlcyA9IHNwbGl0SW5kaWNlc1t2ZXJ0ZXhdOwogICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGd1YXJkLWZvci1pbgogICAgICAgICAgICAgICAgZm9yIChjb25zdCBmYWNlIGluIGZhY2VzKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGd0ID0gbnVtVW5TcGxpdFZhbHVlcyArIGZhY2VzW2ZhY2VdOwogICAgICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggaW4gdGhpcy5zcGxpdHMgJiYgZmFjZSBpbiB0aGlzLnNwbGl0c1t2ZXJ0ZXhdKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgYXR0cmlidXRlIGhhcyBhIHNwbGl0IHZhbHVlIGluIGl0cyBhcnJheS4KICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgbXVzdCB1c2UgdGhhdCB2YWx1ZS4uLgogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcmMgPSB0aGlzLnNwbGl0c1t2ZXJ0ZXhdW2ZhY2VdOwogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwbGl0VmFsdWVzW3NyY10uZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3RndCAqIHRoaXMuc3RyaWRlICsgaW5kZXhdID0gdmFsdWU7CiAgICAgICAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBlYWNoIHNjYWxhciB2YWx1ZSB0byB0aGUgbmV3IHBsYWNlIGluIHRoZSBhcnJheS4KICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3JjID0gcGFyc2VJbnQodmVydGV4KTsKICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCB0aGlzLnN0cmlkZTsgZSsrKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhW3RndCAqIHRoaXMuc3RyaWRlICsgZV0gPSB0aGlzLmRhdGFbc3JjICogdGhpcy5zdHJpZGUgKyBlXTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gZGF0YTsKICAgICAgICB9CiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogICAgICAgIC8vIFBlcnNpc3RlbmNlCiAgICAgICAgLyoqCiAgICAgICAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBqc29uIG9iamVjdC4KICAgICAgICAgKi8KICAgICAgICB0b0pTT04oY29udGV4dCkgewogICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLAogICAgICAgICAgICAgICAgZGF0YVR5cGU6IHRoaXMuZGF0YVR5cGVOYW1lLAogICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLmRhdGEubGVuZ3RoIC8gdGhpcy5zdHJpZGUsCiAgICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gaiAtIFRoZSBqc29uIG9iamVjdCB0aGlzIGl0ZW0gbXVzdCBkZWNvZGUuCiAgICAgICAgICovCiAgICAgICAgZnJvbUpTT04oaikgewogICAgICAgICAgICBjb25zdCBkYXRhID0gai5kYXRhLm1hcCgoZGF0YUVsZW1lbnQpID0+IE1hdGhGdW5jdGlvbnMuaXNOdW1lcmljKGRhdGFFbGVtZW50KSA/IGRhdGFFbGVtZW50IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTsKICAgICAgICAgICAgdGhpcy5kYXRhID0gRmxvYXQzMkFycmF5LmZyb20oZGF0YSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBsb2FkU3BsaXRWYWx1ZXMgbWV0aG9kLgogICAgICAgICAqIEBwYXJhbSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGxvYWRTcGxpdFZhbHVlcyhyZWFkZXIpIHsKICAgICAgICAgICAgY29uc3Qgc3BsaXRJbmRpY2VzID0gcmVhZGVyLmxvYWRVSW50MzJBcnJheSgpOwogICAgICAgICAgICBpZiAoc3BsaXRJbmRpY2VzLmxlbmd0aCA9PSAwKQogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDsKICAgICAgICAgICAgbGV0IG51bVNwbGl0VmFsdWVzID0gMDsKICAgICAgICAgICAgd2hpbGUgKHRydWUpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRleElkID0gc3BsaXRJbmRpY2VzW29mZnNldCsrXTsKICAgICAgICAgICAgICAgIGNvbnN0IG51bVNwbGl0cyA9IHNwbGl0SW5kaWNlc1tvZmZzZXQrK107CiAgICAgICAgICAgICAgICBjb25zdCBzcGxpdHMgPSB7fTsKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU3BsaXRzOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBmYWNlSWQgPSBzcGxpdEluZGljZXNbb2Zmc2V0KytdOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IHNwbGl0SWQgPSBzcGxpdEluZGljZXNbb2Zmc2V0KytdOwogICAgICAgICAgICAgICAgICAgIHNwbGl0c1tmYWNlSWRdID0gc3BsaXRJZDsKICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXRJZCA+PSBudW1TcGxpdFZhbHVlcykKICAgICAgICAgICAgICAgICAgICAgICAgbnVtU3BsaXRWYWx1ZXMgPSBzcGxpdElkICsgMTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRzW3ZlcnRleElkXSA9IHNwbGl0czsKICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgPj0gc3BsaXRJbmRpY2VzLmxlbmd0aCkKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBkaW0gPSB0aGlzLnN0cmlkZTsKICAgICAgICAgICAgY29uc3Qgc3BsaXRWYWx1ZXMgPSByZWFkZXIubG9hZEZsb2F0MzJBcnJheShudW1TcGxpdFZhbHVlcyAqIGRpbSk7CiAgICAgICAgICAgIHRoaXMuc3BsaXRWYWx1ZXMgPSBbXTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TcGxpdFZhbHVlczsgaSsrKSB7CiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBzcGxpdFZhbHVlcy5zbGljZShpICogZGltLCBpICogZGltICsgZGltKTsKICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRWYWx1ZXMucHVzaCh2YWwpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0J3Mgc3RhdGUuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICB0b1N0cmluZygpIHsKICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMudG9KU09OKCksIG51bGwsIDIpOwogICAgICAgIH0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCiAgICAgICAgLy8gTWVtb3J5CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB2ZXJ0ZXggYXR0cmlidXRlcyBidWZmZXJzIGFuZCBpdHMgY291bnQuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZW5CdWZmZXIoKSB7CiAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICB2YWx1ZXM6IHRoaXMuZGF0YSwKICAgICAgICAgICAgICAgIGNvdW50OiB0aGlzLmdldENvdW50KCksCiAgICAgICAgICAgICAgICBkYXRhVHlwZTogdGhpcy5kYXRhVHlwZU5hbWUsCiAgICAgICAgICAgICAgICBub3JtYWxpemVkOiB0aGlzLm5vcm1hbGl6ZWQsCiAgICAgICAgICAgIH07CiAgICAgICAgfQogICAgfQoKICAgIC8qKgogICAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGF0dHJpYnV0ZS4KICAgICAqLwogICAgY2xhc3MgVmVjM0F0dHJpYnV0ZSBleHRlbmRzIEF0dHJpYnV0ZSB7CiAgICAgICAgLyoqCiAgICAgICAgICogQ3JlYXRlIGEgVmVjMkF0dHJpYnV0ZS4KICAgICAgICAgKi8KICAgICAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICAgICAgc3VwZXIoJ1ZlYzMnLCAzKTsKICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVkID0gZmFsc2U7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIFZlYzMgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4KICAgICAgICAgKgogICAgICAgICAqID4gTm90ZTogJ1JlZicgbWVhbnMgdGhhdCB0aGUgdmFsdWUgY29udGFpbnMgYSByZWZlcmVuY2UgdG8gdGhlIGRhdGEgaW4gdGhlIGF0dHJpYnV0ZS4KICAgICAgICAgKiA+IFRoZSBjb21wb25lbnRzIG9mIHRoZSB2YWx1ZSBjYW4gYmUgY2hhbmdlZCBjYXVzaW5nIHRoZSBhdHRyaWJ1dGVzIGRhdGEgaXMgY2hhbmdlZC4KICAgICAgICAgKiA+IE5vIG5lZWQgdG8gY2FsbCAnc2V0VmFsdWUnLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHZhbHVlLgogICAgICAgICAqIEByZXR1cm5zIFZlYzMgLSBUaGUgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4KICAgICAgICAgKi8KICAgICAgICBnZXRWYWx1ZVJlZihpbmRleCkgewogICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5kYXRhLmxlbmd0aCAvIHRoaXMuc3RyaWRlKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnRleCBpbmRleDonICsgaW5kZXggKyAnLiBOdW0gVmVydGljZXM6JyArIHRoaXMuZGF0YS5sZW5ndGggLyAzKTsKICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaW5kZXggKiB0aGlzLnN0cmlkZTsKICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhID0gdGhpcy5kYXRhLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5zdHJpZGUpOwogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModmFsdWVEYXRhKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhlIFZlYzMgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS4KICAgICAgICAgKiBAcmV0dXJuIFZlYzMgLSBUaGUgdmFsdWUgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4KICAgICAgICAgKi8KICAgICAgICBnZXRWYWx1ZShpbmRleCkgewogICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5kYXRhLmxlbmd0aCAvIHRoaXMuc3RyaWRlKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnRleCBpbmRleDonICsgaW5kZXggKyAnLiBOdW0gVmVydGljZXM6JyArIHRoaXMuZGF0YS5sZW5ndGggLyAzKTsKICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaW5kZXggKiB0aGlzLnN0cmlkZTsKICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhID0gdGhpcy5kYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgdGhpcy5zdHJpZGUpOwogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzModmFsdWVEYXRhKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyBWZWMzIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggdmFsdWUuCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIHNldFZhbHVlKGluZGV4LCB2YWx1ZSkgewogICAgICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5kYXRhLmxlbmd0aCAvIHRoaXMuc3RyaWRlKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZlcnRleCBpbmRleDonICsgaW5kZXggKyAnLiBOdW0gVmVydGljZXM6JyArIHRoaXMuZGF0YS5sZW5ndGggLyAzKTsKICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaW5kZXggKiB0aGlzLnN0cmlkZTsKICAgICAgICAgICAgdGhpcy5kYXRhLnNldCh2YWx1ZS5hc0FycmF5KCksIG9mZnNldCk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIGEgY29ybmVyIHZlcnRleCBvZiBhIGZhY2UuCiAgICAgICAgICogPiBOb3RlOiAnUmVmJyBtZWFucyB0aGF0IHRoZSB2YWx1ZSBjb250YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgZGF0YSBpbiB0aGUgYXR0cmlidXRlLgogICAgICAgICAqID4gVGhlIGNvbXBvbmVudHMgb2YgdGhlIHZhbHVlIGNhbiBiZSBjaGFuZ2VkIGNhdXNpbmcgdGhlIGF0dHJpYnV0ZXMgZGF0YSBpcyBjaGFuZ2VkLgogICAgICAgICAqID4gTm8gbmVlZCB0byBjYWxsICdzZXRGYWNlVmVydGV4VmFsdWUnLgogICAgICAgICAqIEBwYXJhbSBmYWNlIC0gVGhlIGZhY2UgaW5kZXguCiAgICAgICAgICogQHBhcmFtIGZhY2VWZXJ0ZXggLSBUaGUgaW5kZXggb2YgdmVydGV4IHdpdGhpbiB0aGUgZmFjZS4gWzAuLi4gbnVtIGZhY2UgdmVydGljZXNdCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZ2V0RmFjZVZlcnRleFZhbHVlUmVmKGZhY2UsIGZhY2VWZXJ0ZXgpIHsKICAgICAgICAgICAgY29uc3QgYXJyYXkgPSB0aGlzLmdldEZhY2VWZXJ0ZXhWYWx1ZVJlZl9hcnJheShmYWNlLCBmYWNlVmVydGV4KTsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKGFycmF5KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyB0aGUgdmFsdWUgb2YgYSBjb3JuZXIgdmVydGV4IG9mIGEgZmFjZS4KICAgICAgICAgKiBAcGFyYW0gZmFjZSAtIFRoZSBmYWNlIGluZGV4LgogICAgICAgICAqIEBwYXJhbSBmYWNlVmVydGV4IC0gVGhlIGluZGV4IG9mIHZlcnRleCB3aXRoaW4gdGhlIGZhY2UuIFswLi4uIG51bSBmYWNlIHZlcnRpY2VzXQogICAgICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzZXRGYWNlVmVydGV4VmFsdWUoZmFjZSwgZmFjZVZlcnRleCwgdmFsdWUpIHsKICAgICAgICAgICAgdGhpcy5zZXRGYWNlVmVydGV4VmFsdWVfYXJyYXkoZmFjZSwgZmFjZVZlcnRleCwgdmFsdWUuYXNBcnJheSgpKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVGhlIHNldFNwbGl0VmVydGV4VmFsdWUgbWV0aG9kLgogICAgICAgICAqIEBwYXJhbSB2ZXJ0ZXggLSBUaGUgdmVydGV4IHZhbHVlLgogICAgICAgICAqIEBwYXJhbSBmYWNlIC0gVGhlIGZhY2UgaW5kZXguCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHNldFNwbGl0VmVydGV4VmFsdWUodmVydGV4LCBmYWNlLCB2YWx1ZSkgewogICAgICAgICAgICB0aGlzLnNldFNwbGl0VmVydGV4VmFsdWVfYXJyYXkodmVydGV4LCBmYWNlLCB2YWx1ZS5hc0FycmF5KCkpOwogICAgICAgIH0KICAgIH0KICAgIFJlZ2lzdHJ5LnJlZ2lzdGVyKCdWZWMzQXR0cmlidXRlJywgVmVjM0F0dHJpYnV0ZSk7CgogICAgLyoqCiAgICAgKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gYXR0cmlidXRlLgogICAgICovCiAgICBjbGFzcyBWZWMyQXR0cmlidXRlIGV4dGVuZHMgQXR0cmlidXRlIHsKICAgICAgICAvKioKICAgICAgICAgKiBDcmVhdGUgYSBWZWMyQXR0cmlidXRlLgogICAgICAgICAqLwogICAgICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgICAgICBzdXBlcignVmVjMicsIDIpOwogICAgICAgICAgICB0aGlzLm5vcm1hbGl6ZWQgPSBmYWxzZTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0aGUgVmVjMiB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LgogICAgICAgICAqCiAgICAgICAgICogPiBOb3RlOiAnUmVmJyBtZWFucyB0aGF0IHRoZSB2YWx1ZSBjb250YWlucyBhIHJlZmVyZW5jZSB0byB0aGUgZGF0YSBpbiB0aGUgYXR0cmlidXRlLgogICAgICAgICAqID4gVGhlIGNvbXBvbmVudHMgb2YgdGhlIHZhbHVlIGNhbiBiZSBjaGFuZ2VkIGNhdXNpbmcgdGhlIGF0dHJpYnV0ZXMgZGF0YSBpcyBjaGFuZ2VkLgogICAgICAgICAqID4gTm8gbmVlZCB0byBjYWxsICdzZXRWYWx1ZScuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggdmFsdWUuCiAgICAgICAgICogQHJldHVybnMgVmVjMiAtIFRoZSB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LgogICAgICAgICAqLwogICAgICAgIGdldFZhbHVlUmVmKGluZGV4KSB7CiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmRhdGEubGVuZ3RoIC8gdGhpcy5zdHJpZGUpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVydGV4IGluZGV4OicgKyBpbmRleCArICcuIE51bSBWZXJ0aWNlczonICsgdGhpcy5kYXRhLmxlbmd0aCAvIDMpOwogICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAqIHRoaXMuc3RyaWRlOwogICAgICAgICAgICBjb25zdCB2YWx1ZURhdGEgPSB0aGlzLmRhdGEuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLnN0cmlkZSk7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih2YWx1ZURhdGEpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRoZSBWZWMyIGZyb20gdGhlIHNwZWNpZmllZCBpbmRleC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS4KICAgICAgICAgKiBAcmV0dXJuIFZlYzIgLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldFZhbHVlKGluZGV4KSB7CiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmRhdGEubGVuZ3RoIC8gdGhpcy5zdHJpZGUpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVydGV4IGluZGV4OicgKyBpbmRleCArICcuIE51bSBWZXJ0aWNlczonICsgdGhpcy5kYXRhLmxlbmd0aCAvIDMpOwogICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAqIHRoaXMuc3RyaWRlOwogICAgICAgICAgICBjb25zdCB2YWx1ZURhdGEgPSB0aGlzLmRhdGEuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyB0aGlzLnN0cmlkZSk7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih2YWx1ZURhdGEpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIFZlYzIgYXQgdGhlIHNwZWNpZmllZCBpbmRleC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBpbmRleCAtIFRoZSBpbmRleCB2YWx1ZS4KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgcGFyYW0uCiAgICAgICAgICovCiAgICAgICAgc2V0VmFsdWUoaW5kZXgsIHZhbHVlKSB7CiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmRhdGEubGVuZ3RoIC8gdGhpcy5zdHJpZGUpCiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmVydGV4IGluZGV4OicgKyBpbmRleCArICcuIE51bSBWZXJ0aWNlczonICsgdGhpcy5kYXRhLmxlbmd0aCAvIDMpOwogICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBpbmRleCAqIHRoaXMuc3RyaWRlOwogICAgICAgICAgICB0aGlzLmRhdGEuc2V0KHZhbHVlLmFzQXJyYXkoKSwgb2Zmc2V0KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2V0cyB0aGUgdmFsdWUgb2YgYSBjb3JuZXIgdmVydGV4IG9mIGEgZmFjZS4KICAgICAgICAgKiA+IE5vdGU6ICdSZWYnIG1lYW5zIHRoYXQgdGhlIHZhbHVlIGNvbnRhaW5zIGEgcmVmZXJlbmNlIHRvIHRoZSBkYXRhIGluIHRoZSBhdHRyaWJ1dGUuCiAgICAgICAgICogPiBUaGUgY29tcG9uZW50cyBvZiB0aGUgdmFsdWUgY2FuIGJlIGNoYW5nZWQgY2F1c2luZyB0aGUgYXR0cmlidXRlcyBkYXRhIGlzIGNoYW5nZWQuCiAgICAgICAgICogPiBObyBuZWVkIHRvIGNhbGwgJ3NldEZhY2VWZXJ0ZXhWYWx1ZScuCiAgICAgICAgICogQHBhcmFtIGZhY2UgLSBUaGUgZmFjZSBpbmRleC4KICAgICAgICAgKiBAcGFyYW0gZmFjZVZlcnRleCAtIFRoZSBpbmRleCBvZiB2ZXJ0ZXggd2l0aGluIHRoZSBmYWNlLiBbMC4uLiBudW0gZmFjZSB2ZXJ0aWNlc10KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXRGYWNlVmVydGV4VmFsdWVSZWYoZmFjZSwgZmFjZVZlcnRleCkgewogICAgICAgICAgICBjb25zdCBhcnJheSA9IHRoaXMuZ2V0RmFjZVZlcnRleFZhbHVlUmVmX2FycmF5KGZhY2UsIGZhY2VWZXJ0ZXgpOwogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIoYXJyYXkpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIGNvcm5lciB2ZXJ0ZXggb2YgYSBmYWNlLgogICAgICAgICAqIEBwYXJhbSBmYWNlIC0gVGhlIGZhY2UgaW5kZXguCiAgICAgICAgICogQHBhcmFtIGZhY2VWZXJ0ZXggLSBUaGUgaW5kZXggb2YgdmVydGV4IHdpdGhpbiB0aGUgZmFjZS4gWzAuLi4gbnVtIGZhY2UgdmVydGljZXNdCiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHNldEZhY2VWZXJ0ZXhWYWx1ZShmYWNlLCBmYWNlVmVydGV4LCB2YWx1ZSkgewogICAgICAgICAgICB0aGlzLnNldEZhY2VWZXJ0ZXhWYWx1ZV9hcnJheShmYWNlLCBmYWNlVmVydGV4LCB2YWx1ZS5hc0FycmF5KCkpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgc2V0U3BsaXRWZXJ0ZXhWYWx1ZSBtZXRob2QuCiAgICAgICAgICogQHBhcmFtIHZlcnRleCAtIFRoZSB2ZXJ0ZXggdmFsdWUuCiAgICAgICAgICogQHBhcmFtIGZhY2UgLSBUaGUgZmFjZSBpbmRleC4KICAgICAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0U3BsaXRWZXJ0ZXhWYWx1ZSh2ZXJ0ZXgsIGZhY2UsIHZhbHVlKSB7CiAgICAgICAgICAgIHRoaXMuc2V0U3BsaXRWZXJ0ZXhWYWx1ZV9hcnJheSh2ZXJ0ZXgsIGZhY2UsIHZhbHVlLmFzQXJyYXkoKSk7CiAgICAgICAgfQogICAgfQogICAgUmVnaXN0cnkucmVnaXN0ZXIoJ1ZlYzJBdHRyaWJ1dGUnLCBWZWMyQXR0cmlidXRlKTsKCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovCiAgICBjb25zdCBwYXJzZThCaXRQb3NpdGlvbnNBcnJheSA9IChyYW5nZSwgb2Zmc2V0LCBzY2xWZWMsIHBvc2l0aW9uc19xdWFudGl6ZWQsIHBvc2l0aW9uc0F0dHIpID0+IHsKICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2VbMF07IGkgPCByYW5nZVsxXTsgaSsrKSB7CiAgICAgICAgICAgIGNvbnN0IHBvcyA9IG5ldyBWZWMzKHBvc2l0aW9uc19xdWFudGl6ZWRbaSAqIDMgKyAwXSAvIDI1NS4wLCBwb3NpdGlvbnNfcXVhbnRpemVkW2kgKiAzICsgMV0gLyAyNTUuMCwgcG9zaXRpb25zX3F1YW50aXplZFtpICogMyArIDJdIC8gMjU1LjApOwogICAgICAgICAgICBwb3MubXVsdGlwbHlJblBsYWNlKHNjbFZlYyk7CiAgICAgICAgICAgIHBvcy5hZGRJblBsYWNlKG9mZnNldCk7CiAgICAgICAgICAgIHBvc2l0aW9uc0F0dHIuc2V0VmFsdWUoaSwgcG9zKTsKICAgICAgICB9CiAgICB9OwogICAgY29uc3QgcGFyc2UxNkJpdFBvc2l0aW9uc0FycmF5ID0gKHJhbmdlLCBvZmZzZXQsIHNjbFZlYywgcG9zaXRpb25zX3F1YW50aXplZCwgcG9zaXRpb25zQXR0cikgPT4gewogICAgICAgIGZvciAobGV0IGkgPSByYW5nZVswXTsgaSA8IHJhbmdlWzFdOyBpKyspIHsKICAgICAgICAgICAgY29uc3QgcG9zID0gbmV3IFZlYzMocG9zaXRpb25zX3F1YW50aXplZFtpICogMyArIDBdIC8gNjU1MzUuMCwgcG9zaXRpb25zX3F1YW50aXplZFtpICogMyArIDFdIC8gNjU1MzUuMCwgcG9zaXRpb25zX3F1YW50aXplZFtpICogMyArIDJdIC8gNjU1MzUuMCk7CiAgICAgICAgICAgIHBvcy5tdWx0aXBseUluUGxhY2Uoc2NsVmVjKTsKICAgICAgICAgICAgcG9zLmFkZEluUGxhY2Uob2Zmc2V0KTsKICAgICAgICAgICAgcG9zaXRpb25zQXR0ci5zZXRWYWx1ZShpLCBwb3MpOwogICAgICAgIH0KICAgIH07CiAgICBjb25zdCBwYXJzZThCaXROb3JtYWxzQXJyYXkgPSAocmFuZ2UsIG9mZnNldCwgc2NsVmVjLCBub3JtYWxzX3F1YW50aXplZCwgbm9ybWFsc0F0dHIpID0+IHsKICAgICAgICBpZiAoc2NsVmVjLmlzTnVsbCgpKQogICAgICAgICAgICBzY2xWZWMuc2V0KDEsIDEsIDEpOwogICAgICAgIGZvciAobGV0IGkgPSByYW5nZVswXTsgaSA8IHJhbmdlWzFdOyBpKyspIHsKICAgICAgICAgICAgY29uc3Qgbm9ybWFsID0gbmV3IFZlYzMobm9ybWFsc19xdWFudGl6ZWRbaSAqIDMgKyAwXSAvIDI1NS4wLCBub3JtYWxzX3F1YW50aXplZFtpICogMyArIDFdIC8gMjU1LjAsIG5vcm1hbHNfcXVhbnRpemVkW2kgKiAzICsgMl0gLyAyNTUuMCk7CiAgICAgICAgICAgIG5vcm1hbC5tdWx0aXBseUluUGxhY2Uoc2NsVmVjKTsKICAgICAgICAgICAgbm9ybWFsLmFkZEluUGxhY2Uob2Zmc2V0KTsKICAgICAgICAgICAgbm9ybWFsLm5vcm1hbGl6ZUluUGxhY2UoKTsKICAgICAgICAgICAgbm9ybWFsc0F0dHIuc2V0VmFsdWUoaSwgbm9ybWFsKTsKICAgICAgICB9CiAgICB9OwogICAgY29uc3QgcGFyc2U4Qml0VGV4dHVyZUNvb3Jkc0FycmF5ID0gKHJhbmdlLCBvZmZzZXQsIHNjbFZlYywgdGV4Q29vcmRzX3F1YW50aXplZCwgdGV4Q29vcmRzQXR0cikgPT4gewogICAgICAgIC8vIGlmIChzY2xWZWMuaXNOdWxsKCkpCiAgICAgICAgLy8gICAgIHNjbFZlYy5zZXQoMSwgMSwgMSk7CiAgICAgICAgZm9yIChsZXQgaSA9IHJhbmdlWzBdOyBpIDwgcmFuZ2VbMV07IGkrKykgewogICAgICAgICAgICBjb25zdCB0ZXh0dXJlQ29vcmQgPSBuZXcgVmVjMih0ZXhDb29yZHNfcXVhbnRpemVkW2kgKiAyICsgMF0gLyAyNTUuMCwgdGV4Q29vcmRzX3F1YW50aXplZFtpICogMiArIDFdIC8gMjU1LjApOwogICAgICAgICAgICB0ZXh0dXJlQ29vcmQubXVsdGlwbHlJblBsYWNlKHNjbFZlYyk7CiAgICAgICAgICAgIHRleHR1cmVDb29yZC5hZGRJblBsYWNlKG9mZnNldCk7CiAgICAgICAgICAgIHRleENvb3Jkc0F0dHIuc2V0VmFsdWUoaSwgdGV4dHVyZUNvb3JkKTsKICAgICAgICB9CiAgICB9OwogICAgY29uc3QgcGFyc2UxNkJpdFRleHR1cmVDb29yZHNBcnJheSA9IChyYW5nZSwgb2Zmc2V0LCBzY2xWZWMsIHRleENvb3Jkc19xdWFudGl6ZWQsIHRleENvb3Jkc0F0dHIpID0+IHsKICAgICAgICAvLyBpZiAoc2NsVmVjLmlzTnVsbCgpKQogICAgICAgIC8vICAgICBzY2xWZWMuc2V0KDEsIDEsIDEpOwogICAgICAgIGZvciAobGV0IGkgPSByYW5nZVswXTsgaSA8IHJhbmdlWzFdOyBpKyspIHsKICAgICAgICAgICAgY29uc3QgdGV4dHVyZUNvb3JkID0gbmV3IFZlYzIodGV4Q29vcmRzX3F1YW50aXplZFtpICogMiArIDBdIC8gNjU1MzUuMCwgdGV4Q29vcmRzX3F1YW50aXplZFtpICogMiArIDFdIC8gNjU1MzUuMCk7CiAgICAgICAgICAgIHRleHR1cmVDb29yZC5tdWx0aXBseUluUGxhY2Uoc2NsVmVjKTsKICAgICAgICAgICAgdGV4dHVyZUNvb3JkLmFkZEluUGxhY2Uob2Zmc2V0KTsKICAgICAgICAgICAgdGV4Q29vcmRzQXR0ci5zZXRWYWx1ZShpLCB0ZXh0dXJlQ29vcmQpOwogICAgICAgIH0KICAgIH07CiAgICAvKioKICAgICAqIFJlcHJlc2VudHMgYSBiYXNlIGNsYXNzIGZvciAzRCBnZW9tZXRyeSBpdGVtcy4KICAgICAqCiAgICAgKiAqKkV2ZW50cyoqCiAgICAgKiAqICoqYm91bmRpbmdCb3hDaGFuZ2VkOioqIFRyaWdnZXJlZCB3aGVuIHRoZSBib3VuZGluZyBib3ggY2hhbmdlcy4KICAgICAqICogKipnZW9tRGF0YUNoYW5nZWQ6KiogRW1pdHRlZCB3aGVuIHRoZSBnZW9tZXRyeSBhdHRyaWJ1dGVzIGhhdmUgY2hhbmdlZC4gVGhlIHRvcG9sb2d5IGRpZCBub3QgY2hhbmdlLiBUaGUgUmVuZGVyZXIgd2lsbCB1cGxvYWQgdGhlIG5ldyBhdHRyaWJ1dGVzIHRvIHRoZSBHUFUuCiAgICAgKiAqICoqZ2VvbURhdGFUb3BvbG9neUNoYW5nZWQ6KiogRW1pdHRlZCB3aGVuIHRoZSBnZW9tZXRyeSBhdHRyaWJ1dGVzIGFuZCB0b3BvbG9neSBoYXZlIGNoYW5nZWQuICBUaGUgUmVuZGVyZXIgd2lsbCB1cGxvYWQgdGhlIG5ldyBhdHRyaWJ1dGVzIGFuZCB0b3BvbG9neSB0byB0aGUgR1BVLgogICAgICoKICAgICAqIEBleHRlbmRzIFBhcmFtZXRlck93bmVyCiAgICAgKi8KICAgIGNsYXNzIEJhc2VHZW9tIGV4dGVuZHMgUGFyYW1ldGVyT3duZXIgewogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZSBhIGJhc2UgZ2VvbS4KICAgICAgICAgKi8KICAgICAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICAgICAgc3VwZXIoKTsKICAgICAgICAgICAgdGhpcy5fX2JvdW5kaW5nQm94ID0gbmV3IEJveDMoKTsKICAgICAgICAgICAgdGhpcy5fX2JvdW5kaW5nQm94RGlydHkgPSB0cnVlOwogICAgICAgICAgICB0aGlzLl9fbWV0YURhdGEgPSBuZXcgTWFwKCk7CiAgICAgICAgICAgIHRoaXMuX19uYW1lID0gJyc7CiAgICAgICAgICAgIHRoaXMuX19udW1WZXJ0aWNlcyA9IDA7CiAgICAgICAgICAgIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzID0gbmV3IE1hcCgpOwogICAgICAgICAgICB0aGlzLmRlYnVnQ29sb3IgPSBuZXcgQ29sb3IoMSwgMCwgMCwgMSk7CiAgICAgICAgICAgIHRoaXMubmFtZSA9ICcnOwogICAgICAgICAgICB0aGlzLmFkZFZlcnRleEF0dHJpYnV0ZSgncG9zaXRpb25zJywgbmV3IFZlYzNBdHRyaWJ1dGUoKSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBjbGVhciBtZXRob2QuCiAgICAgICAgICovCiAgICAgICAgY2xlYXIoKSB7CiAgICAgICAgICAgIHRoaXMuc2V0TnVtVmVydGljZXMoMCk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEVzdGFibGlzaGVzIGEgbmFtZSBmb3IgdGhlIGdlb21ldHJ5LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgZGVidWcgbmFtZSB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzZXREZWJ1Z05hbWUobmFtZSkgewogICAgICAgICAgICB0aGlzLm5hbWUgPSBuYW1lOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBBZGRzIGEgbmV3IHZlcnRleCBhdHRyaWJ1dGUgdG8gdGhlIGdlb21ldHJ5LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgdmVydGV4IGF0dHJpYnV0ZS4KICAgICAgICAgKiBAcGFyYW0gZGF0YVR5cGUgLSBUaGUgZGF0YVR5cGUgdmFsdWUuIC8vIFRPRE86IGlzIGFueSBvayB2cy4gQXR0clZhbHVlIHwgbnVtYmVyLiBVbnN1cmUgYWJvdXQgaG93IGRhdGFUeXBlIGlzIHVzZWQKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhbiBhdHRyaWJ1dGUuCiAgICAgICAgICovCiAgICAgICAgYWRkVmVydGV4QXR0cmlidXRlKG5hbWUsIGF0dHIpIHsKICAgICAgICAgICAgYXR0ci5zZXRDb3VudCh0aGlzLl9fbnVtVmVydGljZXMpOwogICAgICAgICAgICB0aGlzLl9fdmVydGV4QXR0cmlidXRlcy5zZXQobmFtZSwgYXR0cik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENoZWNrcyBpZiB0aGUgdGhlIGdlb21ldHJ5IGhhcyBhbiBhdHRyaWJ1dGUgd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB2ZXJ0ZXggYXR0cmlidXRlLgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGhhc1ZlcnRleEF0dHJpYnV0ZShuYW1lKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fdmVydGV4QXR0cmlidXRlcy5oYXMobmFtZSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdmVydGV4IGF0dHJpYnV0ZSB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHZlcnRleCBhdHRyaWJ1dGUuCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZ2V0VmVydGV4QXR0cmlidXRlKG5hbWUpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzLmdldChuYW1lKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyBhbGwgdmVydGV4IGF0dHJpYnV0ZXMgaW4gYW4gb2JqZWN0IHdpdGggdGhlaXIgbmFtZXMuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXRWZXJ0ZXhBdHRyaWJ1dGVzKCkgewogICAgICAgICAgICBjb25zdCB2ZXJ0ZXhBdHRyaWJ1dGVzID0ge307CiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgYXR0cl0gb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZW50cmllcygpKQogICAgICAgICAgICAgICAgdmVydGV4QXR0cmlidXRlc1trZXldID0gYXR0cjsKICAgICAgICAgICAgcmV0dXJuIHZlcnRleEF0dHJpYnV0ZXM7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgJ3Bvc2l0aW9ucycgdmVydGV4IGF0dHJpYnV0ZS4KICAgICAgICAgKi8KICAgICAgICBnZXQgcG9zaXRpb25zKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZ2V0KCdwb3NpdGlvbnMnKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHZlcnRleCBhdHRyaWJ1dGVzLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgbnVtVmVydGljZXMoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fbnVtVmVydGljZXM7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiB2ZXJ0ZXggYXR0cmlidXRlcy4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldE51bVZlcnRpY2VzKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX251bVZlcnRpY2VzOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgdmVydGljZXMgdGhlIGdlb21ldHJ5IGhhcy4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBjb3VudCAtIFRoZSBjb3VudCB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzZXROdW1WZXJ0aWNlcyhjb3VudCkgewogICAgICAgICAgICB0aGlzLl9fbnVtVmVydGljZXMgPSBjb3VudDsKICAgICAgICAgICAgLy8gUmVzaXplcyBlYWNoIG9mIHRoZSB2ZXJ0ZXggYXR0cmlidXRlcyB0byBtYXRjaCB0aGUgbmV3IGNvdW50LgogICAgICAgICAgICB0aGlzLl9fdmVydGV4QXR0cmlidXRlcy5mb3JFYWNoKChhdHRyKSA9PiBhdHRyLnNldENvdW50KHRoaXMuX19udW1WZXJ0aWNlcykpOwogICAgICAgICAgICB0aGlzLnNldEJvdW5kaW5nQm94RGlydHkoKTsKICAgICAgICB9CiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogICAgICAgIC8vIEJvdW5kaW5nQm94CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IGZvciBnZW9tZXRyeS4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXRCb3VuZGluZ0JveCgpIHsKICAgICAgICAgICAgaWYgKHRoaXMuX19ib3VuZGluZ0JveERpcnR5KQogICAgICAgICAgICAgICAgdGhpcy51cGRhdGVCb3VuZGluZ0JveCgpOwogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2JvdW5kaW5nQm94OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgc2V0Qm91bmRpbmdCb3hEaXJ0eSBtZXRob2QuCiAgICAgICAgICovCiAgICAgICAgc2V0Qm91bmRpbmdCb3hEaXJ0eSgpIHsKICAgICAgICAgICAgdGhpcy5fX2JvdW5kaW5nQm94RGlydHkgPSB0cnVlOwogICAgICAgICAgICB0aGlzLmVtaXQoJ2JvdW5kaW5nQm94Q2hhbmdlZCcpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgdXBkYXRlQm91bmRpbmdCb3ggbWV0aG9kLgogICAgICAgICAqLwogICAgICAgIHVwZGF0ZUJvdW5kaW5nQm94KCkgewogICAgICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSB0aGlzLnBvc2l0aW9uczsKICAgICAgICAgICAgY29uc3QgYmJveCA9IG5ldyBCb3gzKCk7CiAgICAgICAgICAgIGlmIChwb3NpdGlvbnMpIHsKICAgICAgICAgICAgICAgIGNvbnN0IG51bVZlcnRzID0gcG9zaXRpb25zLmdldENvdW50KCk7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZlcnRzOyBpKyspCiAgICAgICAgICAgICAgICAgICAgYmJveC5hZGRQb2ludChwb3NpdGlvbnMuZ2V0VmFsdWVSZWYoaSkpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuX19ib3VuZGluZ0JveCA9IGJib3g7CiAgICAgICAgICAgIHRoaXMuX19ib3VuZGluZ0JveERpcnR5ID0gZmFsc2U7CiAgICAgICAgfQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8KICAgICAgICAvLyBNZXRhZGF0YQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgbWV0YWRhdGEgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBuYW1lLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdmFsdWUuCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZ2V0TWV0YWRhdGEoa2V5KSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fbWV0YURhdGEuZ2V0KGtleSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFZlcmlmaWVzIGlmIGdlb21ldHJ5J3MgbWV0YWRhdGEgY29udGFpbnMgYSB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdmFsdWUuCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgaGFzTWV0YWRhdGEoa2V5KSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fbWV0YURhdGEuaGFzKGtleSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFNldHMgbWV0YWRhdGEgdmFsdWUgdG8gdGhlIGdlb21ldHJ5LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdmFsdWUuCiAgICAgICAgICogQHBhcmFtIG1ldGFEYXRhIC0gVGhlIG1ldGFEYXRhIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIHNldE1ldGFkYXRhKGtleSwgbWV0YURhdGEpIHsKICAgICAgICAgICAgdGhpcy5fX21ldGFEYXRhLnNldChrZXksIG1ldGFEYXRhKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmVtb3ZlcyBtZXRhZGF0YSB2YWx1ZSBmcm9tIHRoZSBnZW9tZXRyeSB3aXRoIHRoZSBzcGVjaWZpZWQga2V5LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIGtleSAtIFRoZSBrZXkgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZGVsZXRlTWV0YWRhdGEoa2V5KSB7CiAgICAgICAgICAgIHRoaXMuX19tZXRhRGF0YS5kZWxldGUoa2V5KTsKICAgICAgICB9CiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogICAgICAgIC8vIE1lbW9yeQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdmVydGV4IGF0dHJpYnV0ZXMgYnVmZmVycyBhbmQgaXRzIGNvdW50LgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdlbkJ1ZmZlcnMob3B0cykgewogICAgICAgICAgICBjb25zdCBhdHRyQnVmZmVycyA9IHt9OwogICAgICAgICAgICBmb3IgKGNvbnN0IFthdHRyTmFtZSwgYXR0cl0gb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMpIHsKICAgICAgICAgICAgICAgIGF0dHJCdWZmZXJzW2F0dHJOYW1lXSA9IGF0dHIuZ2VuQnVmZmVyKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIG51bVZlcnRpY2VzOiB0aGlzLm51bVZlcnRpY2VzKCksCiAgICAgICAgICAgICAgICBhdHRyQnVmZmVycywKICAgICAgICAgICAgfTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogT25jZSB0aGUgYnVmZmVycyBoYXZlIGJlZW4gdXBsb2FkZWQgdG8gdGhlIEdQVSwgd2UgYXJlIGZyZWUgdG8gcmVsZWFzZSB0aGVtLgogICAgICAgICAqIFRoZSBHTEdlb21MaWJyYXJ5IG1heSBjYWxsIHRoaXMgZnVuY3Rpb24gdG8gbGV0IHRoZSBnZW9tZXRyeSBrbm93IGl0IGNhbiByZWxlYXNlIGFueSBoYW5kbGVzLgogICAgICAgICAqLwogICAgICAgIGZyZWVCdWZmZXJzKCkgeyB9CiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogICAgICAgIC8vIFBlcnNpc3RlbmNlCiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyBzdGF0ZSBvZiBjdXJyZW50IEdlb21ldHJ5KEluY2x1ZGluZyBWZXJ0aWNlcyBhbmQgQm91bmRpbmcgQm94KSB1c2luZyBhIGJpbmFyeSByZWFkZXIgb2JqZWN0LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgbG9hZEJhc2VHZW9tQmluYXJ5KHJlYWRlciwgY29udGV4dCkgewogICAgICAgICAgICB0aGlzLm5hbWUgPSByZWFkZXIubG9hZFN0cigpOwogICAgICAgICAgICBjb25zdCBmbGFncyA9IHJlYWRlci5sb2FkVUludDgoKTsKICAgICAgICAgICAgdGhpcy5kZWJ1Z0NvbG9yID0gcmVhZGVyLmxvYWRSR0JGbG9hdDMyQ29sb3IoKTsKICAgICAgICAgICAgY29uc3QgbnVtVmVydHMgPSByZWFkZXIubG9hZFVJbnQzMigpOwogICAgICAgICAgICB0aGlzLl9fYm91bmRpbmdCb3guc2V0KHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKSwgcmVhZGVyLmxvYWRGbG9hdDMyVmVjMygpKTsKICAgICAgICAgICAgdGhpcy5zZXROdW1WZXJ0aWNlcyhudW1WZXJ0cyk7CiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uc0F0dHIgPSB0aGlzLnBvc2l0aW9uczsKICAgICAgICAgICAgbGV0IG5vcm1hbHNBdHRyOwogICAgICAgICAgICBsZXQgdGV4Q29vcmRzQXR0cjsKICAgICAgICAgICAgaWYgKGZsYWdzICYgKDEgPDwgMSkpIHsKICAgICAgICAgICAgICAgIG5vcm1hbHNBdHRyID0gdGhpcy5nZXRWZXJ0ZXhBdHRyaWJ1dGUoJ25vcm1hbHMnKTsKICAgICAgICAgICAgICAgIGlmICghbm9ybWFsc0F0dHIpIHsKICAgICAgICAgICAgICAgICAgICBub3JtYWxzQXR0ciA9IG5ldyBWZWMzQXR0cmlidXRlKCk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRWZXJ0ZXhBdHRyaWJ1dGUoJ25vcm1hbHMnLCBub3JtYWxzQXR0cik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKGZsYWdzICYgKDEgPDwgMikpIHsKICAgICAgICAgICAgICAgIHRleENvb3Jkc0F0dHIgPSB0aGlzLmdldFZlcnRleEF0dHJpYnV0ZSgndGV4Q29vcmRzJyk7CiAgICAgICAgICAgICAgICBpZiAoIXRleENvb3Jkc0F0dHIpIHsKICAgICAgICAgICAgICAgICAgICB0ZXhDb29yZHNBdHRyID0gbmV3IFZlYzJBdHRyaWJ1dGUoKTsKICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZFZlcnRleEF0dHJpYnV0ZSgndGV4Q29vcmRzJywgdGV4Q29vcmRzQXR0cik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgbnVtQ2x1c3RlcnMgPSByZWFkZXIubG9hZFVJbnQzMigpOwogICAgICAgICAgICBpZiAobnVtQ2x1c3RlcnMgPT0gMSkgewogICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IGJveDMgPSB0aGlzLl9fYm91bmRpbmdCb3g7CiAgICAgICAgICAgICAgICAgICAgLy8gRnJvbSAzLjkuMSwgdmVydGV4IGRhdGEgaXMgYSBtaXggb2YgMTZiaXQgYW5kIDggYml0IHF1YW5pdGl6YXRpb24KICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC52ZXJzaW9uc1snemVhLWVuZ2luZSddLmNvbXBhcmUoWzMsIDksIDFdKSA+PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uc19xdWFudGl6ZWQgPSByZWFkZXIubG9hZFVJbnQxNkFycmF5KG51bVZlcnRzICogMyk7CiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlMTZCaXRQb3NpdGlvbnNBcnJheShbMCwgbnVtVmVydHNdLCBib3gzLnAwLCBib3gzLmRpYWdvbmFsKCksIHBvc2l0aW9uc19xdWFudGl6ZWQsIHBvc2l0aW9uc0F0dHIpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25zX3F1YW50aXplZCA9IHJlYWRlci5sb2FkVUludDhBcnJheShudW1WZXJ0cyAqIDMpOwogICAgICAgICAgICAgICAgICAgICAgICBwYXJzZThCaXRQb3NpdGlvbnNBcnJheShbMCwgbnVtVmVydHNdLCBib3gzLnAwLCBib3gzLmRpYWdvbmFsKCksIHBvc2l0aW9uc19xdWFudGl6ZWQsIHBvc2l0aW9uc0F0dHIpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmIChub3JtYWxzQXR0cikgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IGJveDMgPSBuZXcgQm94MyhyZWFkZXIubG9hZEZsb2F0MzJWZWMzKCksIHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKSk7CiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsc19xdWFudGl6ZWQgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkobnVtVmVydHMgKiAzKTsKICAgICAgICAgICAgICAgICAgICBwYXJzZThCaXROb3JtYWxzQXJyYXkoWzAsIG51bVZlcnRzXSwgYm94My5wMCwgYm94My5kaWFnb25hbCgpLCBub3JtYWxzX3F1YW50aXplZCwgbm9ybWFsc0F0dHIpOwogICAgICAgICAgICAgICAgICAgIG5vcm1hbHNBdHRyLmxvYWRTcGxpdFZhbHVlcyhyZWFkZXIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgaWYgKHRleENvb3Jkc0F0dHIpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBib3gyID0gbmV3IEJveDIocmVhZGVyLmxvYWRGbG9hdDMyVmVjMigpLCByZWFkZXIubG9hZEZsb2F0MzJWZWMyKCkpOwogICAgICAgICAgICAgICAgICAgIC8vIEZyb20gMy45LjEsIHZlcnRleCBkYXRhIGlzIGEgbWl4IG9mIDE2Yml0IGFuZCA4IGJpdCBxdWFuaXRpemF0aW9uCiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQudmVyc2lvbnNbJ3plYS1lbmdpbmUnXS5jb21wYXJlKFszLCA5LCAxXSkgPj0gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXhDb29yZHNfcXVhbnRpemVkID0gcmVhZGVyLmxvYWRVSW50MTZBcnJheShudW1WZXJ0cyAqIDIpOwogICAgICAgICAgICAgICAgICAgICAgICBwYXJzZTE2Qml0VGV4dHVyZUNvb3Jkc0FycmF5KFswLCBudW1WZXJ0c10sIGJveDIucDAsIGJveDIuZGlhZ29uYWwoKSwgdGV4Q29vcmRzX3F1YW50aXplZCwgdGV4Q29vcmRzQXR0cik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXhDb29yZHNfcXVhbnRpemVkID0gcmVhZGVyLmxvYWRVSW50OEFycmF5KG51bVZlcnRzICogMik7CiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlOEJpdFRleHR1cmVDb29yZHNBcnJheShbMCwgbnVtVmVydHNdLCBib3gyLnAwLCBib3gyLmRpYWdvbmFsKCksIHRleENvb3Jkc19xdWFudGl6ZWQsIHRleENvb3Jkc0F0dHIpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB0ZXhDb29yZHNBdHRyLmxvYWRTcGxpdFZhbHVlcyhyZWFkZXIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgY29uc3QgY2x1c3RlcnMgPSBbXTsKICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwOwogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DbHVzdGVyczsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSByZWFkZXIubG9hZFVJbnQzMigpOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXJEYXRhID0gewogICAgICAgICAgICAgICAgICAgICAgICByYW5nZTogW29mZnNldCwgb2Zmc2V0ICsgY291bnRdLAogICAgICAgICAgICAgICAgICAgICAgICBiYm94OiBuZXcgQm94MyhyZWFkZXIubG9hZEZsb2F0MzJWZWMzKCksIHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKSksCiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbHNSYW5nZTogbmV3IEJveDMoKSwKICAgICAgICAgICAgICAgICAgICAgICAgdGV4Q29vcmRzUmFuZ2U6IG5ldyBCb3gyKCksCiAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICBpZiAobm9ybWFsc0F0dHIpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY2x1c3RlckRhdGEubm9ybWFsc1JhbmdlLnNldChyZWFkZXIubG9hZEZsb2F0MzJWZWMzKCksIHJlYWRlci5sb2FkRmxvYXQzMlZlYzMoKSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmICh0ZXhDb29yZHNBdHRyKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJEYXRhLnRleENvb3Jkc1JhbmdlLnNldChyZWFkZXIubG9hZEZsb2F0MzJWZWMyKCksIHJlYWRlci5sb2FkRmxvYXQzMlZlYzIoKSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJzLnB1c2goY2x1c3RlckRhdGEpOwogICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBjb3VudDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIC8vIEZyb20gMy45LjEsIHZlcnRleCBkYXRhIGlzIGEgbWl4IG9mIDE2Yml0IGFuZCA4IGJpdCBxdWFuaXRpemF0aW9uCiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb25zX3F1YW50aXplZDsKICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnZlcnNpb25zWyd6ZWEtZW5naW5lJ10uY29tcGFyZShbMywgOSwgMV0pID49IDApIHsKICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnNfcXVhbnRpemVkID0gcmVhZGVyLmxvYWRVSW50MTZBcnJheShudW1WZXJ0cyAqIDMpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zX3F1YW50aXplZCA9IHJlYWRlci5sb2FkVUludDhBcnJheShudW1WZXJ0cyAqIDMpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgbGV0IG5vcm1hbHNfcXVhbnRpemVkID0gbnVsbDsKICAgICAgICAgICAgICAgIGxldCB0ZXhDb29yZHNfcXVhbnRpemVkID0gbnVsbDsKICAgICAgICAgICAgICAgIGlmIChub3JtYWxzQXR0cikgewogICAgICAgICAgICAgICAgICAgIG5vcm1hbHNfcXVhbnRpemVkID0gcmVhZGVyLmxvYWRVSW50OEFycmF5KG51bVZlcnRzICogMyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAodGV4Q29vcmRzQXR0cikgewogICAgICAgICAgICAgICAgICAgIHRleENvb3Jkc19xdWFudGl6ZWQgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkobnVtVmVydHMgKiAyKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2x1c3RlcnM7IGkrKykgewogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYm94MyA9IGNsdXN0ZXJzW2ldLmJib3g7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZyb20gMy45LjEsIHZlcnRleCBkYXRhIGlzIGEgbWl4IG9mIDE2Yml0IGFuZCA4IGJpdCBxdWFuaXRpemF0aW9uCiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnZlcnNpb25zWyd6ZWEtZW5naW5lJ10uY29tcGFyZShbMywgOSwgMV0pID49IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlMTZCaXRQb3NpdGlvbnNBcnJheShjbHVzdGVyc1tpXS5yYW5nZSwgYm94My5wMCwgYm94My5kaWFnb25hbCgpLCBwb3NpdGlvbnNfcXVhbnRpemVkLCBwb3NpdGlvbnNBdHRyKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlOEJpdFBvc2l0aW9uc0FycmF5KGNsdXN0ZXJzW2ldLnJhbmdlLCBib3gzLnAwLCBib3gzLmRpYWdvbmFsKCksIHBvc2l0aW9uc19xdWFudGl6ZWQsIHBvc2l0aW9uc0F0dHIpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChub3JtYWxzX3F1YW50aXplZCkgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBib3gzID0gY2x1c3RlcnNbaV0ubm9ybWFsc1JhbmdlOwogICAgICAgICAgICAgICAgICAgICAgICBwYXJzZThCaXROb3JtYWxzQXJyYXkoY2x1c3RlcnNbaV0ucmFuZ2UsIGJveDMucDAsIGJveDMuZGlhZ29uYWwoKSwgbm9ybWFsc19xdWFudGl6ZWQsIG5vcm1hbHNBdHRyKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKHRleENvb3Jkc19xdWFudGl6ZWQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYm94MiA9IGNsdXN0ZXJzW2ldLnRleENvb3Jkc1JhbmdlOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC52ZXJzaW9uc1snemVhLWVuZ2luZSddLmNvbXBhcmUoWzMsIDksIDFdKSA+PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZTE2Qml0VGV4dHVyZUNvb3Jkc0FycmF5KFswLCBudW1WZXJ0c10sIGJveDIucDAsIGJveDIuZGlhZ29uYWwoKSwgdGV4Q29vcmRzX3F1YW50aXplZCwgdGV4Q29vcmRzQXR0cik7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZThCaXRUZXh0dXJlQ29vcmRzQXJyYXkoY2x1c3RlcnNbaV0ucmFuZ2UsIGJveDIucDAsIGJveDIuZGlhZ29uYWwoKSwgdGV4Q29vcmRzX3F1YW50aXplZCwgdGV4Q29vcmRzQXR0cik7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAobm9ybWFsc0F0dHIpIHsKICAgICAgICAgICAgICAgICAgICBub3JtYWxzQXR0ci5sb2FkU3BsaXRWYWx1ZXMocmVhZGVyKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGlmICh0ZXhDb29yZHNBdHRyKSB7CiAgICAgICAgICAgICAgICAgICAgdGV4Q29vcmRzQXR0ci5sb2FkU3BsaXRWYWx1ZXMocmVhZGVyKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgdG9KU09OIG1ldGhvZCBlbmNvZGVzIHRoaXMgdHlwZSBhcyBhIGpzb24gb2JqZWN0IGZvciBwZXJzaXN0ZW5jZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBjb250ZXh0IC0gVGhlIGNvbnRleHQgdmFsdWUuCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIGpzb24gb2JqZWN0LgogICAgICAgICAqLwogICAgICAgIHRvSlNPTihjb250ZXh0KSB7CiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBzdXBlci50b0pTT04oY29udGV4dCk7CiAgICAgICAgICAgIGlmICghY29udGV4dCB8fCAhY29udGV4dC5za2lwVG9wb2xvZ3kpIHsKICAgICAgICAgICAgICAgIGpzb24ubnVtVmVydGljZXMgPSB0aGlzLl9fbnVtVmVydGljZXMgfHwgMDsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCB2ZXJ0ZXhBdHRyaWJ1dGVzID0ge307CiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgYXR0cl0gb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZW50cmllcygpKSB7CiAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQgfHwgISgnc2tpcEF0dHJpYnV0ZXMnIGluIGNvbnRleHQpIHx8ICFjb250ZXh0LnNraXBBdHRyaWJ1dGVzLmluY2x1ZGVzKGtleSkpCiAgICAgICAgICAgICAgICAgICAgdmVydGV4QXR0cmlidXRlc1trZXldID0gYXR0ci50b0pTT04oY29udGV4dCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAganNvbi52ZXJ0ZXhBdHRyaWJ1dGVzID0gdmVydGV4QXR0cmlidXRlczsKICAgICAgICAgICAgcmV0dXJuIGpzb247CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBmcm9tSlNPTiBtZXRob2QgZGVjb2RlcyBhIGpzb24gb2JqZWN0IGZvciB0aGlzIHR5cGUuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0ganNvbiAtIFRoZSBqc29uIG9iamVjdCB0aGlzIGl0ZW0gbXVzdCBkZWNvZGUuCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBmcm9tSlNPTihqc29uLCBjb250ZXh0KSB7CiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTsKICAgICAgICAgICAgc3VwZXIuZnJvbUpTT04oanNvbiwgY29udGV4dCk7CiAgICAgICAgICAgIHRoaXMuc2V0TnVtVmVydGljZXMoanNvbi5udW1WZXJ0aWNlcyk7CiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBqc29uLnZlcnRleEF0dHJpYnV0ZXMpIHsKICAgICAgICAgICAgICAgIGxldCBhdHRyID0gdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMuZ2V0KG5hbWUpOwogICAgICAgICAgICAgICAgY29uc3QgYXR0ckpTT04gPSBqc29uLnZlcnRleEF0dHJpYnV0ZXNbbmFtZV07CiAgICAgICAgICAgICAgICBpZiAoYXR0cikgewogICAgICAgICAgICAgICAgICAgIGF0dHIuZnJvbUpTT04oYXR0ckpTT04pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdhdHRyIHVuZGVmaW5lZCwgY2Fubm90IGV4ZWN1dGUgZnJvbUpTT04oKScpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuZW1pdCgnZ2VvbURhdGFUb3BvbG9neUNoYW5nZWQnKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyBnZW9tZXRyeSBkYXRhIHZhbHVlIGluIGpzb24gZm9ybWF0LgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgdG9TdHJpbmcoKSB7CiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpLCBudWxsLCAyKTsKICAgICAgICB9CiAgICB9CgogICAgLyoqCiAgICAgKiBDbGFzcyByZXByZXNlbnRpbmcgYSBwb2ludCBwcmltaXRpdmUgZHJhd2luZyB0eXBlLCBldmVyeSB2ZXJ0ZXggc3BlY2lmaWVkIGlzIGEgcG9pbnQuCiAgICAgKgogICAgICogYGBgCiAgICAgKiBjb25zdCBwb2ludHMgPSBuZXcgUG9pbnRzKCkKICAgICAqIGBgYAogICAgICoKICAgICAqICogKipFdmVudHMqKgogICAgICogKiAqKmJvdW5kaW5nQm94Q2hhbmdlZDoqKiBUcmlnZ2VyZWQgd2hlbiB0aGUgYm91bmRpbmcgYm94IGNoYW5nZXMuCiAgICAgKgogICAgICogQGV4dGVuZHMgQmFzZUdlb20KICAgICAqLwogICAgY2xhc3MgUG9pbnRzIGV4dGVuZHMgQmFzZUdlb20gewogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZSBwb2ludHMuCiAgICAgICAgICovCiAgICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgICAgIHN1cGVyKCk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBjbGVhciBtZXRob2QuCiAgICAgICAgICovCiAgICAgICAgY2xlYXIoKSB7CiAgICAgICAgICAgIHRoaXMuc2V0TnVtVmVydGljZXMoMCk7CiAgICAgICAgICAgIHRoaXMuZW1pdCgnZ2VvbURhdGFUb3BvbG9neUNoYW5nZWQnKTsKICAgICAgICB9CiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogICAgICAgIC8vIFBlcnNpc3RlbmNlCiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyBzdGF0ZSBvZiBjdXJyZW50IGdlb21ldHJ5KEluY2x1ZGluZyBsaW5lIHNlZ21lbnRzKSB1c2luZyBhIGJpbmFyeSByZWFkZXIgb2JqZWN0LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICByZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCkgewogICAgICAgICAgICBzdXBlci5sb2FkQmFzZUdlb21CaW5hcnkocmVhZGVyLCBjb250ZXh0KTsKICAgICAgICAgICAgLy8gdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpOwogICAgICAgICAgICB0aGlzLmVtaXQoJ2dlb21EYXRhQ2hhbmdlZCcpOwogICAgICAgIH0KICAgIH0KICAgIFJlZ2lzdHJ5LnJlZ2lzdGVyKCdQb2ludHMnLCBQb2ludHMpOwoKICAgIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqLwogICAgLyoqCiAgICAgKgogICAgICogQ2xhc3MgcmVwcmVzZW50aW5nIGxpbmVzIHByaW1pdGl2ZSBkcmF3aW5nIHR5cGUsIGNvbm5lY3RpbmcgdmVydGljZXMgdXNpbmcgdGhlIHNwZWNpZmllZCBpbmRpY2VzLgogICAgICogaS5lLiBXZSBoYXZlIDQgcG9pbnRzKHZlcnRpY2VzKSBidXQgd2UgZG9uJ3Qga25vdyBob3cgdGhleSBjb25uZWN0IHRvIGVhY2ggb3RoZXIsCiAgICAgKiBhbmQgdGhhdCdzIHdoeSB3ZSBuZWVkIGluZGljZXMoTnVtYmVycyBpbmRpY2F0aW5nIHdoaWNoIHZlcnRleCBjb25uZWN0cyB0byB3aGljaCkuCiAgICAgKiBJbiB0aGlzIGNhc2UgaWYgd2Ugc2F5IHRoYXQgYGluZGljZXNgIGlzIGBbMCwxLDIsM11gLCBpdCB3b3VsZCBjb25uZWN0IHRoZSBmaXJzdCB2ZXJ0ZXggdG8gdGhlIHNlY29uZCwKICAgICAqIGFuZCB0aGUgdGhpcmQgdG8gdGhlIGZvdXJ0aC4KICAgICAqCiAgICAgKiBgYGAKICAgICAqIGNvbnN0IGxpbmVzID0gbmV3IExpbmVzKCkKICAgICAqIGBgYAogICAgICoKICAgICAqICoqRXZlbnRzKioKICAgICAqICogKipnZW9tRGF0YUNoYW5nZWQ6KiogVHJpZ2dlcmVkIHdoZW4gdGhlIGRhdGEgdmFsdWUgb2YgdGhlIGdlb21ldHJ5IGlzIHNldChUaGlzIGluY2x1ZGVzIHJlYWRpbmcgYmluYXJ5KQogICAgICoKICAgICAqIEBleHRlbmRzIEJhc2VHZW9tCiAgICAgKi8KICAgIGNsYXNzIExpbmVzIGV4dGVuZHMgQmFzZUdlb20gewogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZSBsaW5lcy4KICAgICAgICAgKi8KICAgICAgICBjb25zdHJ1Y3RvcigpIHsKICAgICAgICAgICAgc3VwZXIoKTsKICAgICAgICAgICAgdGhpcy5fX2luZGljZXMgPSBuZXcgVWludDMyQXJyYXkoKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVGhlIGNsZWFyIG1ldGhvZC4KICAgICAgICAgKi8KICAgICAgICBjbGVhcigpIHsKICAgICAgICAgICAgdGhpcy5zZXROdW1TZWdtZW50cygwKTsKICAgICAgICAgICAgdGhpcy5zZXROdW1WZXJ0aWNlcygwKTsKICAgICAgICAgICAgdGhpcy5lbWl0KCdnZW9tRGF0YVRvcG9sb2d5Q2hhbmdlZCcpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRoZSBzcGVjaWZpZWQgaW5kaWNlcyhWZXJ0ZXggY29ubmVjdG9ycykKICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgaW5kaWNlcyBpbmRleCBhcnJheS4KICAgICAgICAgKi8KICAgICAgICBnZXRJbmRpY2VzKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5fX2luZGljZXM7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBsaW5lIHNlZ21lbnRzLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIG51bWJlciBvZiBzZWdtZW50cy4KICAgICAgICAgKi8KICAgICAgICBnZXROdW1TZWdtZW50cygpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19pbmRpY2VzLmxlbmd0aCAvIDI7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBsaW5lIHNlZ21lbnRzLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgdGhlIG51bWJlciBvZiBzZWdtZW50cy4KICAgICAgICAgKi8KICAgICAgICBnZXROdW1MaW5lU2VnbWVudHMoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9faW5kaWNlcy5sZW5ndGggLyAyOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHRoZSBudW1iZXIgb2YgbGluZSBzZWdtZW50cyBpbiB0aGUgbGluZXMgZ2VvbWV0cnkuCiAgICAgICAgICogKipJbXBvcnRhbnQ6KiogSXQgcmVzZXRzIGluZGljZXMgdmFsdWVzLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIG51bU9mU2VnbWVudHMgLSBUaGUgY291bnQgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgc2V0TnVtU2VnbWVudHMobnVtT2ZTZWdtZW50cykgewogICAgICAgICAgICBpZiAobnVtT2ZTZWdtZW50cyA+IHRoaXMuZ2V0TnVtU2VnbWVudHMoKSkgewogICAgICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheShudW1PZlNlZ21lbnRzICogMik7CiAgICAgICAgICAgICAgICBpbmRpY2VzLnNldCh0aGlzLl9faW5kaWNlcyk7CiAgICAgICAgICAgICAgICB0aGlzLl9faW5kaWNlcyA9IGluZGljZXM7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICB0aGlzLl9faW5kaWNlcyA9IHRoaXMuX19pbmRpY2VzLnNsaWNlKDAsIG51bU9mU2VnbWVudHMgKiAyKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBTZXRzIHNlZ21lbnQgdmFsdWVzIGluIHRoZSBzcGVjaWZpZWQgaW5kZXguCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggdmFsdWUuCiAgICAgICAgICogQHBhcmFtIHAwIC0gVGhlIHAwIHZhbHVlLgogICAgICAgICAqIEBwYXJhbSBwMSAtIFRoZSBwMSB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzZXRTZWdtZW50VmVydGV4SW5kaWNlcyhpbmRleCwgcDAsIHAxKSB7CiAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLl9faW5kaWNlcy5sZW5ndGggLyAyKQogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpbmUgaW5kZXg6JyArIGluZGV4ICsgJy4gTnVtIFNlZ21lbnRzOicgKyB0aGlzLl9faW5kaWNlcy5sZW5ndGggLyAyKTsKICAgICAgICAgICAgdGhpcy5fX2luZGljZXNbaW5kZXggKiAyICsgMF0gPSBwMDsKICAgICAgICAgICAgdGhpcy5fX2luZGljZXNbaW5kZXggKiAyICsgMV0gPSBwMTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVGhlIGdldFNlZ21lbnRWZXJ0ZXhJbmRleCBtZXRob2QuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gbGluZSAtIFRoZSBsaW5lIHZhbHVlLgogICAgICAgICAqIEBwYXJhbSBsaW5lVmVydGV4IC0gVGhlIGxpbmVWZXJ0ZXggdmFsdWUuCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICogQHByaXZhdGUKICAgICAgICAgKi8KICAgICAgICBnZXRTZWdtZW50VmVydGV4SW5kZXgobGluZSwgbGluZVZlcnRleCkgewogICAgICAgICAgICBjb25zdCBudW1TZWdtZW50cyA9IHRoaXMuZ2V0TnVtU2VnbWVudHMoKTsKICAgICAgICAgICAgaWYgKGxpbmUgPCBudW1TZWdtZW50cykKICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9faW5kaWNlc1tsaW5lICogMiArIGxpbmVWZXJ0ZXhdOwogICAgICAgICAgICByZXR1cm4gLTE7CiAgICAgICAgfQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8KICAgICAgICAvLyBNZW1vcnkKICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHZlcnRleCBhdHRyaWJ1dGVzIGJ1ZmZlcnMgYW5kIGl0cyBjb3VudC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdlbkJ1ZmZlcnMob3B0cykgewogICAgICAgICAgICBjb25zdCBidWZmZXJzID0gc3VwZXIuZ2VuQnVmZmVycygpOwogICAgICAgICAgICBsZXQgaW5kaWNlczsKICAgICAgICAgICAgaWYgKGJ1ZmZlcnMubnVtVmVydGljZXMgPCBNYXRoLnBvdygyLCA4KSkgewogICAgICAgICAgICAgICAgaW5kaWNlcyA9IG5ldyBVaW50OEFycmF5KHRoaXMuX19pbmRpY2VzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIGlmIChidWZmZXJzLm51bVZlcnRpY2VzIDwgTWF0aC5wb3coMiwgMTYpKSB7CiAgICAgICAgICAgICAgICBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuX19pbmRpY2VzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIGluZGljZXMgPSB0aGlzLl9faW5kaWNlczsKICAgICAgICAgICAgfQogICAgICAgICAgICBidWZmZXJzLmluZGljZXMgPSBpbmRpY2VzOwogICAgICAgICAgICByZXR1cm4gYnVmZmVyczsKICAgICAgICB9CiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogICAgICAgIC8vIFBlcnNpc3RlbmNlCiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyBzdGF0ZSBvZiBjdXJyZW50IGdlb21ldHJ5KEluY2x1ZGluZyBsaW5lIHNlZ21lbnRzKSB1c2luZyBhIGJpbmFyeSByZWFkZXIgb2JqZWN0LgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICByZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCkgewogICAgICAgICAgICBzdXBlci5sb2FkQmFzZUdlb21CaW5hcnkocmVhZGVyLCBjb250ZXh0KTsKICAgICAgICAgICAgdGhpcy5zZXROdW1TZWdtZW50cyhyZWFkZXIubG9hZFVJbnQzMigpKTsKICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSByZWFkZXIubG9hZFVJbnQ4KCk7CiAgICAgICAgICAgIGlmIChieXRlcyA9PSAxKQogICAgICAgICAgICAgICAgdGhpcy5fX2luZGljZXMgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkoKTsKICAgICAgICAgICAgZWxzZSBpZiAoYnl0ZXMgPT0gMikKICAgICAgICAgICAgICAgIHRoaXMuX19pbmRpY2VzID0gcmVhZGVyLmxvYWRVSW50MTZBcnJheSgpOwogICAgICAgICAgICBlbHNlIGlmIChieXRlcyA9PSA0KQogICAgICAgICAgICAgICAgdGhpcy5fX2luZGljZXMgPSByZWFkZXIubG9hZFVJbnQzMkFycmF5KCk7CiAgICAgICAgICAgIHRoaXMuZW1pdCgnZ2VvbURhdGFDaGFuZ2VkJyk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSB0b0pTT04gbWV0aG9kIGVuY29kZXMgdGhpcyB0eXBlIGFzIGEganNvbiBvYmplY3QgZm9yIHBlcnNpc3RlbmNlLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUganNvbiBvYmplY3QuCiAgICAgICAgICovCiAgICAgICAgdG9KU09OKGNvbnRleHQpIHsKICAgICAgICAgICAgY29uc3QgaiA9IHN1cGVyLnRvSlNPTihjb250ZXh0KTsKICAgICAgICAgICAgaWYgKCFjb250ZXh0IHx8ICFjb250ZXh0LnNraXBUb3BvbG9neSkKICAgICAgICAgICAgICAgIGouaW5kaWNlcyA9IEFycmF5LmZyb20odGhpcy5fX2luZGljZXMpOwogICAgICAgICAgICByZXR1cm4gajsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVGhlIGZyb21KU09OIG1ldGhvZCBkZWNvZGVzIGEganNvbiBvYmplY3QgZm9yIHRoaXMgdHlwZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBqIC0gVGhlIGpzb24gb2JqZWN0IHRoaXMgaXRlbSBtdXN0IGRlY29kZS4KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGZyb21KU09OKGosIGNvbnRleHQpIHsKICAgICAgICAgICAgc3VwZXIuZnJvbUpTT04oaiwgY29udGV4dCk7CiAgICAgICAgICAgIGlmIChqLmluZGljZXMpCiAgICAgICAgICAgICAgICB0aGlzLl9faW5kaWNlcyA9IFVpbnQzMkFycmF5LmZyb20oai5pbmRpY2VzKTsKICAgICAgICB9CiAgICB9CiAgICBSZWdpc3RyeS5yZWdpc3RlcignTGluZXMnLCBMaW5lcyk7CgogICAgLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLXJlc3QtcGFyYW1zICovCiAgICAvKioKICAgICAqIFRoZSBNZXNoIGNsYXNzIHByb3ZpZGVzIGEgZmxleGlibGUgYW5kIGZhc3QgcG9seWdvbiBtZXNoIHJlcHJlc2VudGF0aW9uLiBJdCBzdXBwb3J0cyBwb2x5Z29ucyBvZiBhcmJpdHJhcnkgY29tcGxleGl0eSwKICAgICAqIGZyb20gYmFzaWMgdHJpYW5nbGVzIGFuZCBxdWFkcyB0byBwZW50YWdvbnMgbW9yZS4KICAgICAqIEl0IHN1cHBvcnRzIHN0b3JpbmcgcGVyIGZhY2UgYXR0cmlidXRlcywgYW5kIHBlciBlZGdlIGF0dHJpYnV0ZXMuCiAgICAgKiBUaGUgTWVzaCBjbGFzcyBoYW5kbGVzIGNvbnZlcnRpbmcgaXRzIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIHBvbHlnb25zIGludG8gYSBzaW1wbGVyIHRyaWFuZ2xlcyByZXByZXNlbnRhdGlvbiBmb3IgcmVuZGVyaW5nLgogICAgICoKICAgICAqIGBgYAogICAgICogY29uc3QgbWVzaCA9IG5ldyBNZXNoKCkKICAgICAqIGBgYAogICAgICoKICAgICAqICoqRXZlbnRzKioKICAgICAqICogKipnZW9tRGF0YVRvcG9sb2d5Q2hhbmdlZDoqKiBUcmlnZ2VyZWQgd2hlbiB0aGUgdG9wb2xvZ3kgb2YgdGhlIG1lc2ggaGFzIGJlZW4gY2hhbmdlZC4KICAgICAqICogKipnZW9tRGF0YUNoYW5nZWQ6KiogVHJpZ2dlcmVkIHdoZW4gdGhlIHZlcnRpY2VzIG9mIHRoZSBtZXNoIGhhdmUgY2hhbmdlZCwgYnV0IG5vdCBuZWNlc3NhcmlseSB0aGUgdG9wb2xvZ3kuCiAgICAgKgogICAgICogQGV4dGVuZHMgQmFzZUdlb20KICAgICAqLwogICAgY2xhc3MgTWVzaCBleHRlbmRzIEJhc2VHZW9tIHsKICAgICAgICAvKioKICAgICAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIE1lc2guCiAgICAgICAgICovCiAgICAgICAgY29uc3RydWN0b3IoKSB7CiAgICAgICAgICAgIHN1cGVyKCk7CiAgICAgICAgICAgIHRoaXMuZWRnZUZhY2VzID0gW107CiAgICAgICAgICAgIHRoaXMuZmFjZUVkZ2VzID0gW1tdXTsKICAgICAgICAgICAgdGhpcy5mYWNlQ291bnRzID0gW107CiAgICAgICAgICAgIHRoaXMuX19mYWNlVmVydGV4SW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheSgpOwogICAgICAgICAgICB0aGlzLl9fbG9nVG9wb2xvZ3lXYXJuaW5ncyA9IGZhbHNlOwogICAgICAgICAgICB0aGlzLl9fZWRnZUF0dHJpYnV0ZXMgPSBuZXcgTWFwKCk7CiAgICAgICAgICAgIHRoaXMuX19mYWNlQXR0cmlidXRlcyA9IG5ldyBNYXAoKTsKICAgICAgICAgICAgdGhpcy5udW1FZGdlcyA9IDA7CiAgICAgICAgICAgIHRoaXMuZWRnZVZlcnRzID0gW107CiAgICAgICAgICAgIHRoaXMudmVydGV4RWRnZXMgPSBbXTsKICAgICAgICAgICAgdGhpcy5lZGdlQW5nbGVzID0gbmV3IEZsb2F0MzJBcnJheSgpOwogICAgICAgICAgICB0aGlzLmVkZ2VWZWNzID0gW107CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBjbGVhciBtZXRob2QuCiAgICAgICAgICovCiAgICAgICAgY2xlYXIoKSB7CiAgICAgICAgICAgIHN1cGVyLmNsZWFyKCk7CiAgICAgICAgICAgIC8vdGhpcy5pbml0KCkKICAgICAgICAgICAgLy90aGlzLnNldE51bVZlcnRpY2VzKDApCiAgICAgICAgICAgIC8vIGNsZWFyIGVkZ2UgYW5kIGZhY2Ugbm9ybWFscy4KICAgICAgICAgICAgdGhpcy5lZGdlVmVydHMgPSBbXTsKICAgICAgICAgICAgdGhpcy52ZXJ0ZXhFZGdlcyA9IFtdOwogICAgICAgICAgICB0aGlzLm51bUVkZ2VzID0gMDsKICAgICAgICAgICAgdGhpcy5lZGdlQW5nbGVzID0gbmV3IEZsb2F0MzJBcnJheSgpOwogICAgICAgICAgICB0aGlzLmVtaXQoJ2dlb21EYXRhVG9wb2xvZ3lDaGFuZ2VkJyk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIEFkZHMgYSBuZXcgdmVydGV4IGF0dHJpYnV0ZSB0byB0aGUgZ2VvbWV0cnkuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSB2ZXJ0ZXggYXR0cmlidXRlLgogICAgICAgICAqIEBwYXJhbSBhdHRyIC0gVGhlIGF0dHJpYnV0ZSB0byBhZGQgdG8gdGhlIGdlb21ldHJ5CiAgICAgICAgICovCiAgICAgICAgYWRkVmVydGV4QXR0cmlidXRlKG5hbWUsIGF0dHIpIHsKICAgICAgICAgICAgc3VwZXIuYWRkVmVydGV4QXR0cmlidXRlKG5hbWUsIGF0dHIpOwogICAgICAgICAgICBhdHRyLnNldE1lc2godGhpcyk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBnZXRGYWNlQ291bnRzIG1ldGhvZC4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXRGYWNlQ291bnRzKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5mYWNlQ291bnRzOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgZ2V0TnVtRmFjZXMgbWV0aG9kLgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldE51bUZhY2VzKCkgewogICAgICAgICAgICByZXR1cm4gdGhpcy5mYWNlQ291bnRzLmxlbmd0aCA9PSAwID8gMCA6IHRoaXMuZmFjZUNvdW50cy5yZWR1Y2UoKG51bUZhY2VzLCBmYykgPT4gKG51bUZhY2VzICs9IGZjKSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBnZXROdW1UcmlhbmdsZXMgbWV0aG9kLgogICAgICAgICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldE51bVRyaWFuZ2xlcygpIHsKICAgICAgICAgICAgbGV0IG51bVRyaWFuZ2xlcyA9IDA7CiAgICAgICAgICAgIGxldCBudW1UcmlzUGVyRmFjZSA9IDE7CiAgICAgICAgICAgIGZvciAoY29uc3QgZmMgb2YgdGhpcy5mYWNlQ291bnRzKSB7CiAgICAgICAgICAgICAgICBudW1UcmlhbmdsZXMgKz0gZmMgKiBudW1UcmlzUGVyRmFjZTsKICAgICAgICAgICAgICAgIG51bVRyaXNQZXJGYWNlKys7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIG51bVRyaWFuZ2xlczsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIGZhY2VzIG9uIHRoZSBtZXNoIHVzaW5nIGFuIGFycmF5IHNwZWNpZnlpbmcgdGhlIGNvdW50cyBwZXIgcG9seWdvbiBzaXplLgogICAgICAgICAqIFRoZSBmaXJzdCBpdGVtIGluIHRoZSBhcnJheSBzcGVjaWZpZXMgdGhlIG51bWJlciBvZiB0cmlhbmdsZXMsIHRoZSBzZWNvbmQsIHRoZSBudW1iZXIgb2YgcXVhZHMsIHRoZSAzcmQsIHRoZSBudW1iZXIgb2YgNSBzaWRlZCBwb2x5Z29ucyBldGMuLgogICAgICAgICAqIGUuZy4gdG8gc3BlY2lmeSAyIHRyaWFuZ2xlcywgYW5kIDcgcXVhZHMsIHdlIHdvdWxkIHBhc3MgWzIsIDddCiAgICAgICAgICogQHBhcmFtIGZhY2VDb3VudHMgLSBUaGUgZmFjZUNvdW50cyB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzZXRGYWNlQ291bnRzKGZhY2VDb3VudHMpIHsKICAgICAgICAgICAgLy8gbGV0IG51bUZhY2VzID0gMAogICAgICAgICAgICBsZXQgbnVtRmFjZXNWZXJ0aWNlcyA9IDA7CiAgICAgICAgICAgIGxldCBudW1WZXJ0c1BlckZhY2UgPSAzOwogICAgICAgICAgICBmb3IgKGNvbnN0IGZjIG9mIGZhY2VDb3VudHMpIHsKICAgICAgICAgICAgICAgIC8vIG51bUZhY2VzICs9IGZjCiAgICAgICAgICAgICAgICBudW1GYWNlc1ZlcnRpY2VzICs9IGZjICogbnVtVmVydHNQZXJGYWNlOwogICAgICAgICAgICAgICAgbnVtVmVydHNQZXJGYWNlKys7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgcHJldk51bUZhY2VzID0gdGhpcy5nZXROdW1GYWNlcygpOwogICAgICAgICAgICBpZiAocHJldk51bUZhY2VzID09IDApIHsKICAgICAgICAgICAgICAgIHRoaXMuX19mYWNlVmVydGV4SW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheShudW1GYWNlc1ZlcnRpY2VzKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIGNvbnN0IGZhY2VWZXJ0ZXhJbmRpY2VzID0gbmV3IFVpbnQzMkFycmF5KG51bUZhY2VzVmVydGljZXMpOwogICAgICAgICAgICAgICAgLy8gTm93IHdlIHByZXNlcnZlIHRoZSBleGlzdGluZyBpbmRpY2VzIGlmIHRoZXkgZml0IHdpdGhpbiB0aGUgbmV3IGZhY2VWZXJ0ZXhJbmRpY2VzIGFycmF5LgogICAgICAgICAgICAgICAgbGV0IHN0YXJ0U3JjID0gMDsKICAgICAgICAgICAgICAgIGxldCBzdGFydFRndCA9IDA7CiAgICAgICAgICAgICAgICBudW1GYWNlc1ZlcnRpY2VzID0gMDsKICAgICAgICAgICAgICAgIG51bVZlcnRzUGVyRmFjZSA9IDM7CiAgICAgICAgICAgICAgICBmYWNlQ291bnRzLmZvckVhY2goKGZjLCBpbmRleCkgPT4gewogICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZFNyYyA9IHN0YXJ0U3JjICsgTWF0aC5taW4oZmMsIHRoaXMuZmFjZUNvdW50c1tpbmRleF0pICogbnVtVmVydHNQZXJGYWNlOwogICAgICAgICAgICAgICAgICAgIGZhY2VWZXJ0ZXhJbmRpY2VzLnNldCh0aGlzLl9fZmFjZVZlcnRleEluZGljZXMuc2xpY2Uoc3RhcnRTcmMsIGVuZFNyYyksIHN0YXJ0VGd0KTsKICAgICAgICAgICAgICAgICAgICBzdGFydFNyYyArPSB0aGlzLmZhY2VDb3VudHNbaW5kZXhdICogbnVtVmVydHNQZXJGYWNlOwogICAgICAgICAgICAgICAgICAgIHN0YXJ0VGd0ICs9IGZjICogbnVtVmVydHNQZXJGYWNlOwogICAgICAgICAgICAgICAgICAgIG51bVZlcnRzUGVyRmFjZSsrOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB0aGlzLl9fZmFjZVZlcnRleEluZGljZXMgPSBmYWNlVmVydGV4SW5kaWNlczsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLmZhY2VDb3VudHMgPSBmYWNlQ291bnRzOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgdmVydGljZXMgaW5kZXhlZCBieSB0aGlzIGZhY2UKICAgICAgICAgKiBAcGFyYW0gZmFjZUluZGV4IC0gVGhlIGZhY2VJbmRleCB2YWx1ZS4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXRGYWNlVmVydGV4Q291bnQoZmFjZUluZGV4KSB7CiAgICAgICAgICAgIGxldCBpZHggPSAwOwogICAgICAgICAgICBsZXQgY291bnQgPSAwOwogICAgICAgICAgICB0aGlzLmZhY2VDb3VudHMuc29tZSgoZmMsIGluZGV4KSA9PiB7CiAgICAgICAgICAgICAgICBpZHggKz0gZmM7CiAgICAgICAgICAgICAgICBpZiAoaWR4ID4gZmFjZUluZGV4KSB7CiAgICAgICAgICAgICAgICAgICAgY291bnQgPSBpbmRleCArIDM7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICByZXR1cm4gY291bnQ7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIG9mZnNldCBvZiB0aGUgZmFjZSBpbmRpY2VzIHdpdGhpbiB0aGUgZW50aXJlIGluZGV4IGFycmF5LgogICAgICAgICAqIEBwYXJhbSBmYWNlSW5kZXggLSBUaGUgZmFjZUluZGV4IHZhbHVlLgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGdldEZhY2VWZXJ0ZXhPZmZzZXQoZmFjZUluZGV4KSB7CiAgICAgICAgICAgIGxldCBpZHggPSAwOwogICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDsKICAgICAgICAgICAgdGhpcy5mYWNlQ291bnRzLnNvbWUoKGZjLCBpbmRleCkgPT4gewogICAgICAgICAgICAgICAgaWYgKGlkeCArIGZjID4gZmFjZUluZGV4KSB7CiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IChmYWNlSW5kZXggLSBpZHgpICogKGluZGV4ICsgMyk7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZHggKz0gZmM7CiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZmMgKiAoaW5kZXggKyAzKTsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBzZXRGYWNlVmVydGV4SW5kaWNlcyBtZXRob2QuCiAgICAgICAgICogQHBhcmFtIGZhY2VJbmRleCAtIFRoZSBmYWNlSW5kZXggdmFsdWUuCiAgICAgICAgICogQHBhcmFtIHZlcnRleEluZGljZXMgLSBUaGUgYXJyYXkgb2YgdmVydGV4IGluZGljZXMgZm9yIHRoaXMgZmFjZSB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBzZXRGYWNlVmVydGV4SW5kaWNlcyhmYWNlSW5kZXgsIHZlcnRleEluZGljZXMpIHsKICAgICAgICAgICAgY29uc3QgZmFjZVZlcnRleENvdW50ID0gdGhpcy5nZXRGYWNlVmVydGV4Q291bnQoZmFjZUluZGV4KTsKICAgICAgICAgICAgaWYgKHZlcnRleEluZGljZXMubGVuZ3RoICE9IGZhY2VWZXJ0ZXhDb3VudCkgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGluZGljZXMgZm9yIGZhY2U6JHtmYWNlSW5kZXh9IHZlcnRleEluZGljZXM6JHt2ZXJ0ZXhJbmRpY2VzfS4gRXhwZWN0ZWQgJHtmYWNlVmVydGV4Q291bnR9IGluZGljZXNgKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmdldEZhY2VWZXJ0ZXhPZmZzZXQoZmFjZUluZGV4KTsKICAgICAgICAgICAgdGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzLnNldCh2ZXJ0ZXhJbmRpY2VzLCBvZmZzZXQpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBBZGRzIGEgbmV3IGZhY2UgdG8gdGhlIG1lc2gKICAgICAgICAgKiBAcGFyYW0gdmVydGV4SW5kaWNlcyAtIFRoZSB2ZXJ0ZXggaW5kaWNlcyBvZiB0aGUgZmFjZS4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIGluZGV4IG9mIHRoZSBmYWNlIGluIHRoZSBtZXNoLgogICAgICAgICAqLwogICAgICAgIGFkZEZhY2UodmVydGV4SW5kaWNlcykgewogICAgICAgICAgICBjb25zdCBmYWNlQ291bnRzID0gWy4uLnRoaXMuZmFjZUNvdW50c107CiAgICAgICAgICAgIGlmIChmYWNlQ291bnRzLmxlbmd0aCA8PSB2ZXJ0ZXhJbmRpY2VzLmxlbmd0aCAtIDMpIHsKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBmYWNlQ291bnRzLmxlbmd0aDsgaSA8IHZlcnRleEluZGljZXMubGVuZ3RoIC0gMzsgaSsrKQogICAgICAgICAgICAgICAgICAgIGZhY2VDb3VudHNbaV0gPSAwOwogICAgICAgICAgICAgICAgZmFjZUNvdW50c1t2ZXJ0ZXhJbmRpY2VzLmxlbmd0aCAtIDNdID0gMTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIGZhY2VDb3VudHNbdmVydGV4SW5kaWNlcy5sZW5ndGggLSAzXSsrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuc2V0RmFjZUNvdW50cyhmYWNlQ291bnRzKTsKICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBvZmZzZXQgaW4gdGhlIGZhY2VWZXJ0ZXhJbmRpY2VzIG9mIHRoaXMgbmV3IGZhY2UuCiAgICAgICAgICAgIGxldCBmYWNlSW5kZXggPSAwOwogICAgICAgICAgICBsZXQgb2Zmc2V0ID0gMDsKICAgICAgICAgICAgdGhpcy5mYWNlQ291bnRzLnNvbWUoKGZjLCBpbmRleCkgPT4gewogICAgICAgICAgICAgICAgaWYgKGluZGV4ICsgMyA9PSB2ZXJ0ZXhJbmRpY2VzLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgIGZhY2VJbmRleCArPSBmYyAtIDE7CiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ICs9IChmYyAtIDEpICogKGluZGV4ICsgMyk7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmYWNlSW5kZXggKz0gZmM7CiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZmMgKiAoaW5kZXggKyAzKTsKICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHRoaXMuX19mYWNlVmVydGV4SW5kaWNlcy5zZXQodmVydGV4SW5kaWNlcywgb2Zmc2V0KTsKICAgICAgICAgICAgcmV0dXJuIGZhY2VJbmRleDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0aGUgdmVydGV4IGluZGljZXMgb2YgdGhlIHNwZWNpZmllZCBmYWNlLgogICAgICAgICAqIEBwYXJhbSBmYWNlSW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIHNwZWNpZmllZCBmYWNlCiAgICAgICAgICogQHJldHVybiAtIEFuIGFycmF5IG9mIGluZGljZXMgaW50byB0aGUgdmVydGV4IGF0dHJpYnV0ZXMKICAgICAgICAgKi8KICAgICAgICBnZXRGYWNlVmVydGV4SW5kaWNlcyhmYWNlSW5kZXgpIHsKICAgICAgICAgICAgY29uc3QgdmVydGV4SW5kaWNlcyA9IFtdOwogICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmdldEZhY2VWZXJ0ZXhPZmZzZXQoZmFjZUluZGV4KTsKICAgICAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmdldEZhY2VWZXJ0ZXhDb3VudChmYWNlSW5kZXgpOwogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHsKICAgICAgICAgICAgICAgIHZlcnRleEluZGljZXMucHVzaCh0aGlzLl9fZmFjZVZlcnRleEluZGljZXNbb2Zmc2V0ICsgaV0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB2ZXJ0ZXhJbmRpY2VzOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIGEgc2luZ2xlIHZlcnRleCBpbmRleCBmb3IgYSBnaXZlbiBmYWNlIGFuZCBmYWNlVmVydGV4LgogICAgICAgICAqIEBwYXJhbSBmYWNlSW5kZXggLSBUaGUgZmFjZUluZGV4IHZhbHVlLgogICAgICAgICAqIEBwYXJhbSBmYWNlVmVydGV4IC0gVGhlIGZhY2UgdmVydGV4IGlzIHRoZSBpbmRleCB3aXRoaW4gdGhlIGZhY2UuIFNvIHRoZSBmaXJzdCB2ZXJ0ZXggaW5kZXggaXMgMC4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHZlcnRleCBpbmRleAogICAgICAgICAqLwogICAgICAgIGdldEZhY2VWZXJ0ZXhJbmRleChmYWNlSW5kZXgsIGZhY2VWZXJ0ZXgpIHsKICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5nZXRGYWNlVmVydGV4T2Zmc2V0KGZhY2VJbmRleCk7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZmFjZVZlcnRleEluZGljZXNbb2Zmc2V0ICsgZmFjZVZlcnRleF07CiAgICAgICAgfQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogICAgICAgIC8vIEZhY2UgQXR0cmlidXRlcwogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBhZGRGYWNlQXR0cmlidXRlIG1ldGhvZC4KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmYWNlIGF0dHJpYnV0ZSB0byBhZGQuCiAgICAgICAgICogQHBhcmFtIGF0dHIgLSBUaGUgYXR0ciB2YWx1ZQogICAgICAgICAqLwogICAgICAgIGFkZEZhY2VBdHRyaWJ1dGUobmFtZSwgYXR0cikgewogICAgICAgICAgICBhdHRyLnNldENvdW50KHRoaXMuZ2V0TnVtRmFjZXMoKSk7CiAgICAgICAgICAgIHRoaXMuX19mYWNlQXR0cmlidXRlcy5zZXQobmFtZSwgYXR0cik7CiAgICAgICAgICAgIHJldHVybiBhdHRyOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgaGFzRmFjZUF0dHJpYnV0ZSBtZXRob2QuCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmFjZSBhdHRyaWJ1dGUuCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgaGFzRmFjZUF0dHJpYnV0ZShuYW1lKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZmFjZUF0dHJpYnV0ZXMuaGFzKG5hbWUpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgZ2V0RmFjZUF0dHJpYnV0ZSBtZXRob2QuCiAgICAgICAgICogQHBhcmFtIG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZmFjZSBhdHRyaWJ1dGUuCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgZ2V0RmFjZUF0dHJpYnV0ZShuYW1lKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZmFjZUF0dHJpYnV0ZXMuZ2V0KG5hbWUpOwogICAgICAgIH0KICAgICAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCiAgICAgICAgLy8gRWRnZSBBdHRyaWJ1dGVzCiAgICAgICAgLyoqCiAgICAgICAgICogVGhlIGFkZEVkZ2VBdHRyaWJ1dGUgbWV0aG9kLgogICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVkZ2UgYXR0cmlidXRlIHRvIGFkZC4KICAgICAgICAgKiBAcGFyYW0gYXR0ciAtIFRoZSBhdHRyIHZhbHVlCiAgICAgICAgICovCiAgICAgICAgYWRkRWRnZUF0dHJpYnV0ZShuYW1lLCBhdHRyKSB7CiAgICAgICAgICAgIGF0dHIuc2V0Q291bnQodGhpcy5udW1FZGdlcyk7CiAgICAgICAgICAgIHRoaXMuX19lZGdlQXR0cmlidXRlcy5zZXQobmFtZSwgYXR0cik7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBoYXNFZGdlQXR0cmlidXRlIG1ldGhvZC4KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBlZGdlIGF0dHJpYnV0ZS4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBoYXNFZGdlQXR0cmlidXRlKG5hbWUpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19lZGdlQXR0cmlidXRlcy5oYXMobmFtZSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBnZXRFZGdlQXR0cmlidXRlIG1ldGhvZC4KICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBlZGdlIGF0dHJpYnV0ZS4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZXRFZGdlQXR0cmlidXRlKG5hbWUpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19lZGdlQXR0cmlidXRlcy5nZXQobmFtZSk7CiAgICAgICAgfQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogICAgICAgIC8qKgogICAgICAgICAqIFRoZSBnZW5Ub3BvbG9neUluZm8gbWV0aG9kLgogICAgICAgICAqLwogICAgICAgIGdlblRvcG9sb2d5SW5mbygpIHsKICAgICAgICAgICAgbGV0IGNvbm5lY3RlZFZlcnRpY2VzID0ge307IC8vIGFjY2VsZXJhdGlvbiBzdHJ1Y3R1cmUuCiAgICAgICAgICAgIHRoaXMudmVydGV4RWRnZXMgPSBbXTsgLy8gMmQgYXJyYXkgb2YgdmVydGV4IHRvIGVkZ2VzLgogICAgICAgICAgICAvLyB0aGlzLnZlcnRleEZhY2VzID0gW107IC8vIDJkIGFycmF5IG9mIHZlcnRleCB0byBmYWNlcy4KICAgICAgICAgICAgdGhpcy5lZGdlRmFjZXMgPSBbXTsgLy8gZmxhdCBhcnJheSBvZiAyIGZhY2UgaW5kaWNlcyBwZXIgZWRnZQogICAgICAgICAgICB0aGlzLmVkZ2VWZXJ0cyA9IFtdOyAvLyBmbGF0IGFycmF5IG9mIDIgdmVydCBpbmRpY2VzIHBlciBlZGdlCiAgICAgICAgICAgIHRoaXMuZmFjZUVkZ2VzID0gW107IC8vIHRoZSBlZGdlcyBib3JkZXJpbmcgZWFjaCBmYWNlLgogICAgICAgICAgICB0aGlzLm51bUVkZ2VzID0gMDsKICAgICAgICAgICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5wb3NpdGlvbnM7CiAgICAgICAgICAgIGNvbnN0IGdldEVkZ2VJbmRleCA9ICh2MCwgdjEpID0+IHsKICAgICAgICAgICAgICAgIGxldCB0bXAwID0gdjA7CiAgICAgICAgICAgICAgICBsZXQgdG1wMSA9IHYxOwogICAgICAgICAgICAgICAgaWYgKHRtcDEgPCB0bXAwKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG1wID0gdG1wMDsKICAgICAgICAgICAgICAgICAgICB0bXAwID0gdG1wMTsKICAgICAgICAgICAgICAgICAgICB0bXAxID0gdG1wOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gdG1wMCArICc+JyArIHRtcDE7CiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIGNvbm5lY3RlZFZlcnRpY2VzKSB7CiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coa2V5ICsgJzonICsgY29ubmVjdGVkVmVydGljZXNba2V5XSArICIgZmFjZToiICsgKCB2MCA8IHYxID8gMCA6IDEpICk7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RlZFZlcnRpY2VzW2tleV07CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBjb25zdCBwMCA9IHBvc2l0aW9ucy5nZXRWYWx1ZVJlZih0bXAwKTsKICAgICAgICAgICAgICAgIGNvbnN0IHAxID0gcG9zaXRpb25zLmdldFZhbHVlUmVmKHRtcDEpOwogICAgICAgICAgICAgICAgY29uc3QgZWRnZVZlYyA9IHAxLnN1YnRyYWN0KHAwKTsKICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VJbmRleCA9IHRoaXMuZWRnZUZhY2VzLmxlbmd0aCAvIDI7CiAgICAgICAgICAgICAgICBjb25zdCBlZGdlRGF0YSA9IHsKICAgICAgICAgICAgICAgICAgICBlZGdlSW5kZXg6IGVkZ2VJbmRleCwKICAgICAgICAgICAgICAgICAgICBlZGdlVmVjOiBlZGdlVmVjLAogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgIGNvbm5lY3RlZFZlcnRpY2VzW2tleV0gPSBlZGdlRGF0YTsKICAgICAgICAgICAgICAgIHRoaXMuZWRnZUZhY2VzLnB1c2goLTEpOwogICAgICAgICAgICAgICAgdGhpcy5lZGdlRmFjZXMucHVzaCgtMSk7CiAgICAgICAgICAgICAgICB0aGlzLmVkZ2VWZXJ0cy5wdXNoKHRtcDApOwogICAgICAgICAgICAgICAgdGhpcy5lZGdlVmVydHMucHVzaCh0bXAxKTsKICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGtleSArICc6JyArIGNvbm5lY3RlZFZlcnRpY2VzW2tleV0gKyAiIGZhY2U6IiArICggdjAgPCB2MSA/IDAgOiAxKSk7CiAgICAgICAgICAgICAgICB0aGlzLm51bUVkZ2VzKys7CiAgICAgICAgICAgICAgICByZXR1cm4gZWRnZURhdGE7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGNvbnN0IGFkZEVkZ2UgPSAodjAsIHYxLCBmYWNlSW5kZXgpID0+IHsKICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdhZGRFZGdlOicgKyB2MCArICIgOiIgKyB2MSArICIgZmFjZUluZGV4OiIgKyBmYWNlSW5kZXggKTsKICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VEYXRhID0gZ2V0RWRnZUluZGV4KHYwLCB2MSk7CiAgICAgICAgICAgICAgICBjb25zdCBlZGdlSW5kZXggPSBlZGdlRGF0YS5lZGdlSW5kZXg7CiAgICAgICAgICAgICAgICBpZiAodjEgPCB2MCkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VGYWNlSW5kZXggPSBlZGdlSW5kZXggKiAyICsgMDsKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fX2xvZ1RvcG9sb2d5V2FybmluZ3MgJiYgdGhpcy5lZGdlRmFjZXNbZWRnZUZhY2VJbmRleF0gIT0gLTEpCiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRWRnZSBwb2x5IDAgYWxyZWFkeSBzZXQuIE1lc2ggaXMgbm9uLW1hbmlmb2xkLicpOwogICAgICAgICAgICAgICAgICAgIHRoaXMuZWRnZUZhY2VzW2VkZ2VGYWNlSW5kZXhdID0gZmFjZUluZGV4OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWRnZUZhY2VJbmRleCA9IGVkZ2VJbmRleCAqIDIgKyAxOwogICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9fbG9nVG9wb2xvZ3lXYXJuaW5ncyAmJiB0aGlzLmVkZ2VGYWNlc1tlZGdlRmFjZUluZGV4XSAhPSAtMSkKICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdFZGdlIHBvbHkgMSBhbHJlYWR5IHNldC4gTWVzaCBpcyBub24tbWFuaWZvbGQuJyk7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGdlRmFjZXNbZWRnZUZhY2VJbmRleF0gPSBmYWNlSW5kZXg7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoIShmYWNlSW5kZXggaW4gdGhpcy5mYWNlRWRnZXMpKQogICAgICAgICAgICAgICAgICAgIHRoaXMuZmFjZUVkZ2VzW2ZhY2VJbmRleF0gPSBbXTsKICAgICAgICAgICAgICAgIHRoaXMuZmFjZUVkZ2VzW2ZhY2VJbmRleF0ucHVzaChlZGdlSW5kZXgpOwogICAgICAgICAgICAgICAgLy8gUHVzaCB0aGUgZWRnZSBpbmRleCBvbnRvIGJvdGggdmVydGV4IGVkZ2UgbGlzdHMuCiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgU2V0cyB0byBhdm9pZCBhZGRpbmcgdGhlIHNhbWUgZWRnZSAyeCB0byB0aGUgc2FtZSB2ZXJ0ZXguCiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJ0ZXhFZGdlc1t2MF0gPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhFZGdlc1t2MF0gPSBuZXcgU2V0KCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJ0ZXhFZGdlc1t2MV0gPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy52ZXJ0ZXhFZGdlc1t2MV0gPSBuZXcgU2V0KCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB0aGlzLnZlcnRleEVkZ2VzW3YwXS5hZGQoZWRnZUluZGV4KTsKICAgICAgICAgICAgICAgIHRoaXMudmVydGV4RWRnZXNbdjFdLmFkZChlZGdlSW5kZXgpOwogICAgICAgICAgICAgICAgLy8gaWYgKHRoaXMudmVydGV4RmFjZXNbdjBdID09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgLy8gICAgIHRoaXMudmVydGV4RmFjZXNbdjBdID0gW107CiAgICAgICAgICAgICAgICAvLyB9CiAgICAgICAgICAgICAgICAvLyB0aGlzLnZlcnRleEZhY2VzW3YwXS5wdXNoKGZhY2VJbmRleCk7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIGNvbnN0IG51bUZhY2VzID0gdGhpcy5nZXROdW1GYWNlcygpOwogICAgICAgICAgICBmb3IgKGxldCBmYWNlSW5kZXggPSAwOyBmYWNlSW5kZXggPCBudW1GYWNlczsgZmFjZUluZGV4KyspIHsKICAgICAgICAgICAgICAgIGNvbnN0IGZhY2VWZXJ0cyA9IHRoaXMuZ2V0RmFjZVZlcnRleEluZGljZXMoZmFjZUluZGV4KTsKICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmFjZVZlcnRzLmxlbmd0aDsgaisrKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgdjAgPSBmYWNlVmVydHNbal07CiAgICAgICAgICAgICAgICAgICAgY29uc3QgdjEgPSBmYWNlVmVydHNbKGogKyAxKSAlIGZhY2VWZXJ0cy5sZW5ndGhdOwogICAgICAgICAgICAgICAgICAgIGFkZEVkZ2UodjAsIHYxLCBmYWNlSW5kZXgpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENvbXB1dGVzIGEgbm9ybWFsIHZhbHVlIHBlciBmYWNlIGJ5IGF2ZXJhZ2luZyB0aGUgdHJpYW5nbGUgbm9ybWFscyBvZiB0aGUgZmFjZS4KICAgICAgICAgKi8KICAgICAgICBjb21wdXRlRmFjZU5vcm1hbHMoKSB7CiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9ucyA9IHRoaXMucG9zaXRpb25zOwogICAgICAgICAgICBjb25zdCBmYWNlTm9ybWFscyA9IG5ldyBWZWMzQXR0cmlidXRlKCk7CiAgICAgICAgICAgIHRoaXMuYWRkRmFjZUF0dHJpYnV0ZSgnbm9ybWFscycsIGZhY2VOb3JtYWxzKTsKICAgICAgICAgICAgY29uc3QgbnVtRmFjZXMgPSB0aGlzLmdldE51bUZhY2VzKCk7CiAgICAgICAgICAgIGZvciAobGV0IGZhY2VJbmRleCA9IDA7IGZhY2VJbmRleCA8IG51bUZhY2VzOyBmYWNlSW5kZXgrKykgewogICAgICAgICAgICAgICAgY29uc3QgZmFjZVZlcnRzID0gdGhpcy5nZXRGYWNlVmVydGV4SW5kaWNlcyhmYWNlSW5kZXgpOwogICAgICAgICAgICAgICAgY29uc3QgcDAgPSBwb3NpdGlvbnMuZ2V0VmFsdWVSZWYoZmFjZVZlcnRzWzBdKTsKICAgICAgICAgICAgICAgIGNvbnN0IHAxID0gcG9zaXRpb25zLmdldFZhbHVlUmVmKGZhY2VWZXJ0c1sxXSk7CiAgICAgICAgICAgICAgICBsZXQgcHJldiA9IHAxOwogICAgICAgICAgICAgICAgY29uc3QgZmFjZU5vcm1hbCA9IG5ldyBWZWMzKCk7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMjsgaiA8IGZhY2VWZXJ0cy5sZW5ndGg7IGorKykgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IHBuID0gcG9zaXRpb25zLmdldFZhbHVlUmVmKGZhY2VWZXJ0c1tqXSk7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgdjAgPSBwcmV2LnN1YnRyYWN0KHAwKTsKICAgICAgICAgICAgICAgICAgICBjb25zdCB2MSA9IHBuLnN1YnRyYWN0KHAwKTsKICAgICAgICAgICAgICAgICAgICBmYWNlTm9ybWFsLmFkZEluUGxhY2UodjAuY3Jvc3ModjEpLm5vcm1hbGl6ZSgpKTsKICAgICAgICAgICAgICAgICAgICBwcmV2ID0gcG47CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoZmFjZU5vcm1hbC5sZW5ndGhTcXVhcmVkKCkgPCBOdW1iZXIuRVBTSUxPTikgOwogICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgZmFjZU5vcm1hbHMuc2V0VmFsdWUoZmFjZUluZGV4LCBmYWNlTm9ybWFsLm5vcm1hbGl6ZSgpKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDYWxjdWxhdGVzIHRoZSBhbmdsZXMgYXQgZWFjaCBlZGdlIGJldHdlZW4gdGhlIGFkam9pbmluZyBmYWNlcwogICAgICAgICAqLwogICAgICAgIGNhbGN1bGF0ZUVkZ2VBbmdsZXMoKSB7CiAgICAgICAgICAgIGlmICh0aGlzLnZlcnRleEVkZ2VzLmxlbmd0aCA9PSAwKQogICAgICAgICAgICAgICAgdGhpcy5nZW5Ub3BvbG9neUluZm8oKTsKICAgICAgICAgICAgdGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTsKICAgICAgICAgICAgY29uc3QgcG9zaXRpb25zID0gdGhpcy5wb3NpdGlvbnM7CiAgICAgICAgICAgIGNvbnN0IGZhY2VOb3JtYWxzID0gdGhpcy5nZXRGYWNlQXR0cmlidXRlKCdub3JtYWxzJyk7CiAgICAgICAgICAgIHRoaXMuZWRnZVZlY3MgPSBbXTsKICAgICAgICAgICAgdGhpcy5lZGdlQW5nbGVzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLm51bUVkZ2VzKTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmVkZ2VGYWNlcy5sZW5ndGg7IGkgKz0gMikgewogICAgICAgICAgICAgICAgY29uc3QgdjAgPSB0aGlzLmVkZ2VWZXJ0c1tpXTsKICAgICAgICAgICAgICAgIGNvbnN0IHYxID0gdGhpcy5lZGdlVmVydHNbaSArIDFdOwogICAgICAgICAgICAgICAgY29uc3QgZWRnZVZlYyA9IHBvc2l0aW9ucy5nZXRWYWx1ZVJlZih2MSkuc3VidHJhY3QocG9zaXRpb25zLmdldFZhbHVlUmVmKHYwKSk7CiAgICAgICAgICAgICAgICBlZGdlVmVjLm5vcm1hbGl6ZUluUGxhY2UoKTsKICAgICAgICAgICAgICAgIHRoaXMuZWRnZVZlY3MucHVzaChlZGdlVmVjKTsKICAgICAgICAgICAgICAgIGNvbnN0IHAwID0gdGhpcy5lZGdlRmFjZXNbaV07CiAgICAgICAgICAgICAgICBjb25zdCBwMSA9IHRoaXMuZWRnZUZhY2VzW2kgKyAxXTsKICAgICAgICAgICAgICAgIGlmIChwMCA9PSAtMSB8fCBwMSA9PSAtMSkgewogICAgICAgICAgICAgICAgICAgIC8vIEZsYWcgdGhlIGVkZ2UgYXMgYSBib3JkZXIgZWRnZS4uLi4KICAgICAgICAgICAgICAgICAgICB0aGlzLmVkZ2VBbmdsZXNbaSAvIDJdID0gTWF0aC5QSSAqIDIuMDsKICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNvbnN0IG4wID0gZmFjZU5vcm1hbHMuZ2V0VmFsdWVSZWYocDApOwogICAgICAgICAgICAgICAgY29uc3QgbjEgPSBmYWNlTm9ybWFscy5nZXRWYWx1ZVJlZihwMSk7CiAgICAgICAgICAgICAgICB0aGlzLmVkZ2VBbmdsZXNbaSAvIDJdID0gbjAuYW5nbGVUbyhuMSk7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ29tcHV0ZSB2ZXJ0ZXggbm9ybWFscy4KICAgICAgICAgKiBAcGFyYW0gaGFyZEFuZ2xlIC0gVGhlIGhhcmRBbmdsZSB2YWx1ZSBpbiByYWRpYW5zLgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGNvbXB1dGVWZXJ0ZXhOb3JtYWxzKGhhcmRBbmdsZSA9IDEuMCAvKiByYWRpYW5zICovKSB7CiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlRWRnZUFuZ2xlcygpOwogICAgICAgICAgICBjb25zdCBmYWNlTm9ybWFscyA9IHRoaXMuZ2V0RmFjZUF0dHJpYnV0ZSgnbm9ybWFscycpOwogICAgICAgICAgICBjb25zdCBub3JtYWxzQXR0ciA9IG5ldyBWZWMzQXR0cmlidXRlKCk7CiAgICAgICAgICAgIHRoaXMuYWRkVmVydGV4QXR0cmlidXRlKCdub3JtYWxzJywgbm9ybWFsc0F0dHIpOwogICAgICAgICAgICAvLyB0aGVzZSBtZXRob2RzIGFyZSBmYXN0ZXIgdmVyc2lvbnMgdGhhbiB1c2luZyB0aGUgbWV0aG9kcwogICAgICAgICAgICAvLyBwcm92aWRlZCBvbiB0aGUgYXR0cmlidXRlcy4gV2UgY2FjaGUgdmFsdWVzIGFuZCB1c2UgaGFyZCBjb2RlZCBjb25zdGFudHMuCiAgICAgICAgICAgIC8vIGNvbnN0IGZhY2VOb3JtYWxzQnVmZmVyID0gZmFjZU5vcm1hbHMuZGF0YS5idWZmZXIKICAgICAgICAgICAgY29uc3QgZ2V0RmFjZU5vcm1hbCA9IChpbmRleCkgPT4gewogICAgICAgICAgICAgICAgcmV0dXJuIGZhY2VOb3JtYWxzLmdldFZhbHVlUmVmKGluZGV4KTsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgY29uc3Qgc2V0VmVydGV4Tm9ybWFsID0gKGluZGV4LCB2YWx1ZSkgPT4gewogICAgICAgICAgICAgICAgbm9ybWFsc0F0dHIuc2V0VmFsdWUoaW5kZXgsIHZhbHVlKTsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgY29uc3QgZ2V0Q29ubmVjdGVkRWRnZVZlY3MgPSAoZmFjZUluZGV4LCB2ZXJ0ZXhJbmRleCkgPT4gewogICAgICAgICAgICAgICAgbGV0IGUwOwogICAgICAgICAgICAgICAgbGV0IGUxOwogICAgICAgICAgICAgICAgY29uc3QgZmFjZUVkZ2VzID0gdGhpcy5mYWNlRWRnZXNbZmFjZUluZGV4XTsKICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBmYWNlRWRnZXMpIHsKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lZGdlVmVydHNbZSAqIDJdID09IHZlcnRleEluZGV4KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZTApCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMCA9IHRoaXMuZWRnZVZlY3NbZV07CiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUxID0gdGhpcy5lZGdlVmVjc1tlXTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5lZGdlVmVydHNbZSAqIDIgKyAxXSA9PSB2ZXJ0ZXhJbmRleCkgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWUwKQogICAgICAgICAgICAgICAgICAgICAgICAgICAgZTAgPSB0aGlzLmVkZ2VWZWNzW2VdOwogICAgICAgICAgICAgICAgICAgICAgICBlbHNlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlMSA9IHRoaXMuZWRnZVZlY3NbZV07CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuIFtlMCwgZTFdOwogICAgICAgICAgICB9OwogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVydGV4RWRnZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgZmFjZSBpbmRleGluZyBkb2Vzbid0IHN0YXJ0IGF0IDAsIHRoZW4gdGhlIHZlcnRleEVkZ2VzIGRvbid0IGVpdGhlci4KICAgICAgICAgICAgICAgIGlmICh0aGlzLnZlcnRleEVkZ2VzW2ldID09IHVuZGVmaW5lZCkKICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VzID0gdGhpcy52ZXJ0ZXhFZGdlc1tpXTsKICAgICAgICAgICAgICAgIC8vIEdyb3VwcyBvZiBmYWNlcyBoYXZpbmcgYSBzbW9vdGggbm9ybWFsIGF0IHRoZSBjdXJyZW50IHZlcnRleC4KICAgICAgICAgICAgICAgIGNvbnN0IGZhY2VHcm91cHMgPSBbXTsKICAgICAgICAgICAgICAgIGNvbnN0IGFkZEZhY2VUb0dyb3VwID0gKGZhY2UpID0+IHsKICAgICAgICAgICAgICAgICAgICBsZXQgaW5Hcm91cCA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmFjZUdyb3VwIG9mIGZhY2VHcm91cHMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgaW5Hcm91cCA9IGZhY2VHcm91cC5pbmNsdWRlcyhmYWNlKTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluR3JvdXApCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbkdyb3VwKQogICAgICAgICAgICAgICAgICAgICAgICBmYWNlR3JvdXBzLnB1c2goW2ZhY2VdKTsKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZWRnZXMpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBmMCA9IHRoaXMuZWRnZUZhY2VzW2UgKiAyXTsKICAgICAgICAgICAgICAgICAgICBjb25zdCBmMSA9IHRoaXMuZWRnZUZhY2VzW2UgKiAyICsgMV07CiAgICAgICAgICAgICAgICAgICAgaWYgKGYwICE9IC0xICYmIGYxICE9IC0xICYmIHRoaXMuZWRnZUFuZ2xlc1tlXSA8IGhhcmRBbmdsZSkgewogICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAoZjAgIT0gLTEgJiYgZjEgPT0gLTEgJiYgdGhpcy5lZGdlQW5nbGVzW2VdIDwgaGFyZEFuZ2xlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmMGdyb3VwSW5kZXggPSAtMTsKICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGYxZ3JvdXBJbmRleCA9IC0xOwogICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBncm91cEluZGV4ID0gMDsgZ3JvdXBJbmRleCA8IGZhY2VHcm91cHMubGVuZ3RoOyBncm91cEluZGV4KyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmMGdyb3VwSW5kZXggPT0gLTEgJiYgZmFjZUdyb3Vwc1tncm91cEluZGV4XS5pbmNsdWRlcyhmMCkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZjBncm91cEluZGV4ID0gZ3JvdXBJbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmMWdyb3VwSW5kZXggPT0gLTEgJiYgZmFjZUdyb3Vwc1tncm91cEluZGV4XS5pbmNsdWRlcyhmMSkpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZjFncm91cEluZGV4ID0gZ3JvdXBJbmRleDsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZjBncm91cEluZGV4ID09IC0xICYmIGYxZ3JvdXBJbmRleCA9PSAtMSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUdyb3Vwcy5wdXNoKFtmMCwgZjFdKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChmMGdyb3VwSW5kZXggIT0gLTEgJiYgZjFncm91cEluZGV4ICE9IC0xKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZjBncm91cEluZGV4ICE9IGYxZ3JvdXBJbmRleCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1lcmdlIHRoZSAyIGdyb3VwcyB0aGF0IHRoZSBzbW9vdGggZWRnZSBqb2lucy4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlR3JvdXBzW2YwZ3JvdXBJbmRleF0gPSBmYWNlR3JvdXBzW2YwZ3JvdXBJbmRleF0uY29uY2F0KGZhY2VHcm91cHNbZjFncm91cEluZGV4XSk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUdyb3Vwcy5zcGxpY2UoZjFncm91cEluZGV4LCAxKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmMGdyb3VwSW5kZXggPT0gLTEpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlR3JvdXBzW2YxZ3JvdXBJbmRleF0ucHVzaChmMCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZjFncm91cEluZGV4ID09IC0xKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFjZUdyb3Vwc1tmMGdyb3VwSW5kZXhdLnB1c2goZjEpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgaGFyZCBlZGdlIG9yIGEgYm9yZGVyIGVkZ2UuLi4gQWRkIGZhY2VzIHNlcGFyYXRlbHkgZ3JvdXAuCiAgICAgICAgICAgICAgICAgICAgaWYgKGYwICE9IC0xKQogICAgICAgICAgICAgICAgICAgICAgICBhZGRGYWNlVG9Hcm91cChmMCk7CiAgICAgICAgICAgICAgICAgICAgaWYgKGYxICE9IC0xKQogICAgICAgICAgICAgICAgICAgICAgICBhZGRGYWNlVG9Hcm91cChmMSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAvLyBTb3J0IHRoZSBncm91cHMgdG8gaGF2ZSB0aGUgYmlnZ2VzdCBncm91cCBmaXJzdC4KICAgICAgICAgICAgICAgIGZhY2VHcm91cHMuc29ydCgoYSwgYikgPT4gKGEubGVuZ3RoIDwgYi5sZW5ndGggPyAxIDogYS5sZW5ndGggPiBiLmxlbmd0aCA/IC0xIDogMCkpOwogICAgICAgICAgICAgICAgbGV0IGZpcnN0VmVydGV4ID0gdHJ1ZTsKICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmFjZUdyb3VwIG9mIGZhY2VHcm91cHMpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBub3JtYWwgPSBuZXcgVmVjMygpOwogICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmFjZUluZGV4IG9mIGZhY2VHcm91cCkgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmYWNlRWRnZXMgPSBnZXRDb25uZWN0ZWRFZGdlVmVjcyhmYWNlSW5kZXgsIGkpOwogICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2VpZ2h0OwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmFjZUVkZ2VzWzBdICYmIGZhY2VFZGdlc1sxXSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0ID0gZmFjZUVkZ2VzWzBdLmFuZ2xlVG8oZmFjZUVkZ2VzWzFdKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbC5hZGRJblBsYWNlKGdldEZhY2VOb3JtYWwoZmFjZUluZGV4KS5zY2FsZSh3ZWlnaHQpKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigndmFyaWFibGUgd2VpZ2h0IGlzIHVuZGVmaW5lZCBiZWNhdXNlIGZhY2VFZGdlc1swXSBvciBmYWNlRWRnZXNbMV0gaXMgdW5kZWZpbmVkJyk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKGkgPT0gMSkKICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKCJGYWNlTm9ybWFsOiIgKyBmYWNlSW5kZXggKyAiOiIgKyBnZXRGYWNlTm9ybWFsKGZhY2VJbmRleCkudG9TdHJpbmcoKSk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIG5vcm1hbC5ub3JtYWxpemVJblBsYWNlKCk7CiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0VmVydGV4KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZlcnRleE5vcm1hbChpLCBub3JtYWwpOwogICAgICAgICAgICAgICAgICAgICAgICBmaXJzdFZlcnRleCA9IGZhbHNlOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsc0F0dHIuc2V0U3BsaXRWZXJ0ZXhWYWx1ZXMoaSwgZmFjZUdyb3VwLCBub3JtYWwuYXNBcnJheSgpKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIG5vcm1hbHNBdHRyOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgY29tcHV0ZUhhcmRFZGdlc0luZGljZXMgbWV0aG9kLgogICAgICAgICAqIEBwYXJhbSBoYXJkQW5nbGUgLSBUaGUgaGFyZEFuZ2xlIHZhbHVlIGluIHJhZGlhbnMuCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgY29tcHV0ZUhhcmRFZGdlc0luZGljZXMoaGFyZEFuZ2xlID0gMS4wKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmVkZ2VWZXJ0cy5sZW5ndGggPT0gMCkKICAgICAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlRWRnZUFuZ2xlcygpOwogICAgICAgICAgICBjb25zdCBoYXJkRWRnZXMgPSBbXTsKICAgICAgICAgICAgY29uc3QgYWRkRWRnZSA9IChpbmRleCkgPT4gewogICAgICAgICAgICAgICAgaGFyZEVkZ2VzLnB1c2godGhpcy5lZGdlVmVydHNbaW5kZXhdKTsKICAgICAgICAgICAgICAgIGhhcmRFZGdlcy5wdXNoKHRoaXMuZWRnZVZlcnRzW2luZGV4ICsgMV0pOwogICAgICAgICAgICB9OwogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZWRnZUFuZ2xlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgaWYgKHRoaXMuZWRnZUFuZ2xlc1tpXSA+IGhhcmRBbmdsZSkgewogICAgICAgICAgICAgICAgICAgIGFkZEVkZ2UoaSAqIDIpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBVaW50MzJBcnJheS5mcm9tKGhhcmRFZGdlcyk7CiAgICAgICAgfQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8KICAgICAgICAvLyBSZW5kZXJpbmcKICAgICAgICAvKioKICAgICAgICAgKiBUaGUgZ2VuQnVmZmVycyBtZXRob2QuCiAgICAgICAgICogQHBhcmFtIG9wdHMgLSBUaGUgb3B0cyB2YWx1ZS4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBnZW5CdWZmZXJzKG9wdHMpIHsKICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbm9ybWFscyBvbiBkZW1hbmQuCiAgICAgICAgICAgIC8vIGlmICghKCdub3JtYWxzJyBpbiB0aGlzLl9fdmVydGV4QXR0cmlidXRlcykpIHsKICAgICAgICAgICAgLy8gICAgIC8vIHRoaXMuX19nZW9tLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7CiAgICAgICAgICAgIC8vICAgICB0aGlzLmFkZFZlcnRleEF0dHJpYnV0ZSgibm9ybWFscyIsIFZlYzMsIDAuMCk7CiAgICAgICAgICAgIC8vIH0KICAgICAgICAgICAgY29uc3Qgc3BsaXRJbmRpY2VzID0ge307CiAgICAgICAgICAgIGxldCBzcGxpdENvdW50ID0gMDsKICAgICAgICAgICAgZm9yIChjb25zdCBbLCBhdHRyXSBvZiB0aGlzLl9fdmVydGV4QXR0cmlidXRlcykgewogICAgICAgICAgICAgICAgY29uc3QgYXR0clNwbGl0cyA9IGF0dHIuZ2V0U3BsaXRzKCk7CiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvbHlnb24gaW4gYXR0clNwbGl0cykgewogICAgICAgICAgICAgICAgICAgIGlmICghKHBvbHlnb24gaW4gc3BsaXRJbmRpY2VzKSkKICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRJbmRpY2VzW3BvbHlnb25dID0ge307CiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVydGljZXMgPSBhdHRyU3BsaXRzW3BvbHlnb25dOwogICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBpbiB2ZXJ0aWNlcykgewogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZXJ0ZXggPSBwYXJzZUludCh2KTsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodmVydGV4IGluIHNwbGl0SW5kaWNlc1twb2x5Z29uXSkpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0SW5kaWNlc1twb2x5Z29uXVt2ZXJ0ZXhdID0gc3BsaXRDb3VudDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0Q291bnQrKzsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSB0aGlzLnBvc2l0aW9uczsKICAgICAgICAgICAgY29uc3QgbnVtVW5TcGxpdFZlcnRpY2VzID0gcG9zaXRpb25zLmdldENvdW50KCk7CiAgICAgICAgICAgIGNvbnN0IHRvdGFsTnVtVmVydGljZXMgPSBudW1VblNwbGl0VmVydGljZXMgKyBzcGxpdENvdW50OwogICAgICAgICAgICBsZXQgaW5kaWNlczsKICAgICAgICAgICAgaWYgKCFvcHRzIHx8IG9wdHMuaW5jbHVkZUluZGljZXMgIT0gZmFsc2UpIHsKICAgICAgICAgICAgICAgIGluZGljZXMgPSB0aGlzLmdlbmVyYXRlVHJpYW5ndWxhdGVkSW5kaWNlcyh0b3RhbE51bVZlcnRpY2VzLCBudW1VblNwbGl0VmVydGljZXMsIHNwbGl0SW5kaWNlcyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gbGV0IG1heEluZGV4OwogICAgICAgICAgICAvLyBpZiAoZGVidWdBdHRyVmFsdWVzKQogICAgICAgICAgICAvLyAgICAgbWF4SW5kZXggPSBNYXRoLm1heCguLi5pbmRpY2VzKTsKICAgICAgICAgICAgY29uc3QgYXR0ckJ1ZmZlcnMgPSB7fTsKICAgICAgICAgICAgZm9yIChjb25zdCBbYXR0ck5hbWUsIGF0dHJdIG9mIHRoaXMuX192ZXJ0ZXhBdHRyaWJ1dGVzKSB7CiAgICAgICAgICAgICAgICBsZXQgdmFsdWVzOwogICAgICAgICAgICAgICAgaWYgKHNwbGl0Q291bnQgPT0gMCkKICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBhdHRyLmFzQXJyYXkoKTsKICAgICAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBhdHRyLmdlbmVyYXRlU3BsaXRWYWx1ZXMoc3BsaXRJbmRpY2VzLCBzcGxpdENvdW50KTsKICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IGF0dHIuc3RyaWRlOwogICAgICAgICAgICAgICAgY29uc3QgY291bnQgPSB2YWx1ZXMubGVuZ3RoIC8gZGltZW5zaW9uOwogICAgICAgICAgICAgICAgLy8gaWYgKGRlYnVnQXR0clZhbHVlcykgewogICAgICAgICAgICAgICAgLy8gICAgIGlmIChjb3VudCA8PSBtYXhJbmRleCkKICAgICAgICAgICAgICAgIC8vICAgICAgICAgY29uc29sZS53YXJuKCJJbnZhbGlkIGluZGV4aW5nLiBBdHRyIHZhbHVlIGlzIGluc3VmZmljaWVudCBmb3IgaW5kZXhpbmc6IiArIGF0dHJOYW1lICsgIi4gTWF4IEluZGV4OiIgKyBtYXhJbmRleCArICIgQXR0ciBTaXplOiIgKyBjb3VudCk7CiAgICAgICAgICAgICAgICAvLyB9CiAgICAgICAgICAgICAgICBhdHRyQnVmZmVyc1thdHRyTmFtZV0gPSB7CiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXMsCiAgICAgICAgICAgICAgICAgICAgY291bnQ6IGNvdW50LAogICAgICAgICAgICAgICAgICAgIGRpbWVuc2lvbjogZGltZW5zaW9uLAogICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IGF0dHJOYW1lID09ICdub3JtYWxzJywKICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogYXR0ci5nZXREYXRhVHlwZU5hbWUoKSwKICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gewogICAgICAgICAgICAgICAgbnVtVmVydGljZXM6IHRoaXMubnVtVmVydGljZXMoKSwKICAgICAgICAgICAgICAgIG51bVJlbmRlclZlcnRzOiB0b3RhbE51bVZlcnRpY2VzLAogICAgICAgICAgICAgICAgaW5kaWNlcywKICAgICAgICAgICAgICAgIGF0dHJCdWZmZXJzLAogICAgICAgICAgICB9OwogICAgICAgICAgICAvKiBEaXNhYmxlZCBkdXJpbmcgVFMgbWlncmF0aW9uLgogICAgICAgICAgICBpZiAob3B0cyAmJiBvcHRzLmluY2x1ZGVWZXJ0ZXhOZWlnaGJvcnMpIHsKICAgICAgICAgICAgICBpZiAodGhpcy52ZXJ0ZXhFZGdlcyA9PSB1bmRlZmluZWQpIHRoaXMuZ2VuVG9wb2xvZ3lJbmZvKCkKICAgICAgICAKICAgICAgICAgICAgICBsZXQgY291bnQgPSAwCiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZlcnRleEVkZ2VzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGZhY2UgaW5kZXhpbmcgZG9lc24ndCBzdGFydCBhdCAwLCB0aGVuIHRoZSB2ZXJ0ZXhFZGdlcyBkb24ndCBlaXRoZXIuCiAgICAgICAgICAgICAgICBpZiAodGhpcy52ZXJ0ZXhFZGdlc1tpXSkgY291bnQgKz0gdGhpcy52ZXJ0ZXhFZGdlc1tpXS5zaXplCiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIC8vIFRoZSBhcnJheSB3aWxsIGJlIHN0cnVjdHVyZWQgYXMgYSBzdGFydCtvZmZzZXQgZm9yIGVhY2ggdmVydGV4LCBmb2xsb3dlZAogICAgICAgICAgICAgIC8vIGJ5IGEgMmQgYXJyYXkgb2YgbmVpZ2hib3IgaW5kaWNlcy4KICAgICAgICAgICAgICBjb25zdCB2ZXJ0ZXhOZWlnaGJvcnMgPSBuZXcgVWludDMyQXJyYXkodGhpcy52ZXJ0ZXhFZGdlcy5sZW5ndGggKiAyICsgY291bnQpCiAgICAgICAgICAgICAgY29uc3Qgc29ydEZhbkVkZ2VzID0gKGZhbkVkZ2VzOiBhbnkpID0+IHsKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmFuRWRnZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgICAgY29uc3QgZmVBID0gZmFuRWRnZXNbaV0KICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpOyBqKyspIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBmZUIgPSBmYW5FZGdlc1tqXQogICAgICAgICAgICAgICAgICAgIGlmIChmZUFbMF0gIT0gLTEgJiYgZmVBWzBdID09IGZlQlsxXSkgewogICAgICAgICAgICAgICAgICAgICAgLy8gIG1vdmUgZmVBIGFmdGVyIGZlQjsKICAgICAgICAgICAgICAgICAgICAgIGlmIChpICE9IGogKyAxKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGZhbkVkZ2VzLnNwbGljZShpLCAxKQogICAgICAgICAgICAgICAgICAgICAgICBmYW5FZGdlcy5zcGxpY2UoaiArIDEsIDAsIGZlQSkKICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIGJyZWFrCiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGlmIChmZUFbMV0gIT0gLTEgJiYgZmVBWzFdID09IGZlQlswXSkgewogICAgICAgICAgICAgICAgICAgICAgLy8gIG1vdmUgZmVBIGJlZm9yZSBmZUI7CiAgICAgICAgICAgICAgICAgICAgICBmYW5FZGdlcy5zcGxpY2UoaSwgMSkKICAgICAgICAgICAgICAgICAgICAgIGZhbkVkZ2VzLnNwbGljZShqLCAwLCBmZUEpCiAgICAgICAgICAgICAgICAgICAgICBicmVhawogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjb25zdCBjaGVja0ZhbkVkZ2VzID0gKGZhbkVkZ2VzOiBhbnkpID0+IHsKICAgICAgICAgICAgICAgIC8vIG5vdyBjaGVjayB0aGF0IHRoZSBmYWNlcyBhbGwgYnVpbGQgYSBmYW4uIE1heWJlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgd2l0aCAtMQogICAgICAgICAgICAgICAgaWYgKGZhbkVkZ2VzWzBdWzBdID09IC0xIHx8IGZhbkVkZ2VzW2ZhbkVkZ2VzLmxlbmd0aCAtIDFdWzFdID09IC0xKSB7CiAgICAgICAgICAgICAgICAgIGlmIChmYW5FZGdlc1swXVswXSAhPSAtMSB8fCBmYW5FZGdlc1tmYW5FZGdlcy5sZW5ndGggLSAxXVsxXSAhPSAtMSkgewogICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWYgZmFuIHN0YXJ0cyB3aXRoIC0xLCBpdCBtdXN0IGFsc28gZW5kIHdpdGggLTEnKQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZhbkVkZ2VzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICAgIGNvbnN0IGZlID0gZmFuRWRnZXNbaV0KICAgICAgICAgICAgICAgICAgaWYgKGZlWzBdID09IC0xIHx8IGZlWzFdID09IC0xKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gMCAmJiBpICE9IGZhbkVkZ2VzLmxlbmd0aCAtIDEpIHsKICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignLTEgb25seSBhbGxvd2VkIGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIGZhbi4nKQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoZmVbMF0gIT0gLTEpIHsKICAgICAgICAgICAgICAgICAgICBsZXQgcHJldiA9IGkgLSAxCiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYgPCAwKSBwcmV2ICs9IGZhbkVkZ2VzLmxlbmd0aAogICAgICAgICAgICAgICAgICAgIGlmIChmZVswXSAhPSBmYW5FZGdlc1twcmV2XVsxXSkgewogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWNlcyBhcmUgbm90IHNlcXVlbnRpYWwnKQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoZmVbMV0gIT0gLTEpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gKGkgKyAxKSAlIGZhbkVkZ2VzLmxlbmd0aAogICAgICAgICAgICAgICAgICAgIGlmIChmZVsxXSAhPSBmYW5FZGdlc1tuZXh0XVswXSkgewogICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWNlcyBhcmUgbm90IHNlcXVlbnRpYWwnKQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0KICAgICAgICAKICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSB0aGUgc3RhcnQgYW5kIG9mZnNldCB2YWx1ZXMuCiAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMudmVydGV4RWRnZXMubGVuZ3RoICogMgogICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZXJ0ZXhFZGdlcy5sZW5ndGg7IGkrKykgewogICAgICAgICAgICAgICAgaWYgKHRoaXMudmVydGV4RWRnZXNbaV0gPT0gdW5kZWZpbmVkKSBjb250aW51ZQogICAgICAgICAgICAgICAgY29uc3QgZWRnZXMgPSB0aGlzLnZlcnRleEVkZ2VzW2ldCiAgICAgICAgCiAgICAgICAgICAgICAgICAvLyBCdWlsZCBhIHNvcnRlZCBsaXN0IG9mIGZhY2VzIGJhc2VkIG9uIGEgZmFuIGFyb3VuZAogICAgICAgICAgICAgICAgLy8gdGhlIHZlcnRleC4KICAgICAgICAgICAgICAgIGNvbnN0IGZhbkVkZ2VzID0gW10KICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlZGdlcykgewogICAgICAgICAgICAgICAgICBjb25zdCB2MCA9IHRoaXMuZWRnZVZlcnRzW2UgKiAyXQogICAgICAgICAgICAgICAgICBjb25zdCB2MSA9IHRoaXMuZWRnZVZlcnRzW2UgKiAyICsgMV0KICAgICAgICAgICAgICAgICAgbGV0IGYwID0gdGhpcy5lZGdlRmFjZXNbZSAqIDJdCiAgICAgICAgICAgICAgICAgIGxldCBmMSA9IHRoaXMuZWRnZUZhY2VzW2UgKiAyICsgMV0KICAgICAgICAgICAgICAgICAgbGV0IG5laWdWZXJ0CiAgICAgICAgICAgICAgICAgIGlmICh2MCA9PSBpKSB7CiAgICAgICAgICAgICAgICAgICAgbmVpZ1ZlcnQgPSB2MQogICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHYxID09IGkpIHsKICAgICAgICAgICAgICAgICAgICBuZWlnVmVydCA9IHYwCiAgICAgICAgICAgICAgICAgICAgLy8gc3dhcCB0aGUgZmFjZXMKICAgICAgICAgICAgICAgICAgICBjb25zdCB0bXAgPSBmMAogICAgICAgICAgICAgICAgICAgIGYwID0gZjEKICAgICAgICAgICAgICAgICAgICBmMSA9IHRtcAogICAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0b3BvbG9neScpCiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgZmFuRWRnZXMucHVzaChbZjAsIGYxLCBuZWlnVmVydF0pCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBzb3J0RmFuRWRnZXMoZmFuRWRnZXMpCiAgICAgICAgICAgICAgICBjaGVja0ZhbkVkZ2VzKGZhbkVkZ2VzKQogICAgICAgICAgICAgICAgY29uc3QgY2xvc2VkID0gZmFuRWRnZXNbMF1bMF0gIT0gLTEgfHwgZmFuRWRnZXNbZmFuRWRnZXMubGVuZ3RoIC0gMV1bMV0gIT0gLTEKICAgICAgICAgICAgICAgIGxldCBmbGFncyA9IDAKICAgICAgICAgICAgICAgIGlmIChjbG9zZWQpIGZsYWdzICs9IDEKICAgICAgICAgICAgICAgIHZlcnRleE5laWdoYm9yc1tpICogMl0gPSBvZmZzZXQKICAgICAgICAgICAgICAgIHZlcnRleE5laWdoYm9yc1tpICogMiArIDFdID0gZWRnZXMuc2l6ZSArIChmbGFncyA8PCA4KQogICAgICAgICAgICAgICAgZm9yIChjb25zdCBmZSBvZiBmYW5FZGdlcykgewogICAgICAgICAgICAgICAgICB2ZXJ0ZXhOZWlnaGJvcnNbb2Zmc2V0XSA9IGZlWzJdCiAgICAgICAgICAgICAgICAgIG9mZnNldCsrCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIDsocmVzdWx0IGFzIGFueSkudmVydGV4TmVpZ2hib3JzID0gdmVydGV4TmVpZ2hib3JzCiAgICAgICAgICAgIH0KICAgICAgICAgICAgKi8KICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ29tcHV0ZSB0aGUgbnVtYmVyIG9mIHRyaWFuZ2xlcy4gRm9yIGhpZ2hlciBkZWdyZWUgcG9seWdvbnMsIHRoZXkgYXJlIGRpdmlkZWQgaW50byBtdWx0aXBsZSB0cmlhbmdsZXMgZm9yIHJlbmRlcmluZy4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRyaWFuZ2xlcy4KICAgICAgICAgKi8KICAgICAgICBjb21wdXRlTnVtVHJpYW5nbGVzKCkgewogICAgICAgICAgICBsZXQgbnVtVmVydHNQZXJGYWNlID0gMzsKICAgICAgICAgICAgbGV0IHRyaXNDb3VudCA9IDA7CiAgICAgICAgICAgIGZvciAoY29uc3QgZmMgb2YgdGhpcy5mYWNlQ291bnRzKSB7CiAgICAgICAgICAgICAgICB0cmlzQ291bnQgKz0gZmMgKiAobnVtVmVydHNQZXJGYWNlIC0gMik7CiAgICAgICAgICAgICAgICBudW1WZXJ0c1BlckZhY2UrKzsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdHJpc0NvdW50OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUbyBwcmVwYXJlIGRhdGEgZm9yIHJlbmRlcmluZywgdGhlIGluZGljZXMgZm9yIHRoZSBwb2x5Z29ucyBpcyB1c2VkIHRvIGNvbXB1dGUgYSBuZXcgaW5kZXggYnVmZmVyIGJhc2VkIG9uCiAgICAgICAgICogb25seSB0cmlhbmdsZXMuIFRoaXMgaXMgdXNlZCBkdXJpbmcgcmVuZGVyaW5nIGFuZCB0aGUgcmVzdWx0aW5nIGluZGljZXMgdXBsb2FkZWQgb3QgdGhlIEdQVSAgYnkgR0xNZXNoIGNsYXNzLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHRvdGFsTnVtVmVydGljZXMgLSBUaGUgdG90YWwgbnVtYmVyIG9mIHZlcnRpY2VzLgogICAgICAgICAqIEBwYXJhbSBudW1VblNwbGl0VmVydGljZXMgLSBUaGUgdG90YWwgbnVtYmVyIG9mIHVuLXNwbGl0IHZlcnRpY2VzLgogICAgICAgICAqIEBwYXJhbSBzcGxpdEluZGljZXMgLSBUaGUgc3BsaXRJbmRpY2VzIHZhbHVlLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgdHlwZWQgYXJyYXkgY29udGFpbmluZyB0aGUgdHJpYW5ndWxhdGVkIGluZGljZXMuCiAgICAgICAgICovCiAgICAgICAgZ2VuZXJhdGVUcmlhbmd1bGF0ZWRJbmRpY2VzKHRvdGFsTnVtVmVydGljZXMsIG51bVVuU3BsaXRWZXJ0aWNlcywgc3BsaXRJbmRpY2VzKSB7CiAgICAgICAgICAgIGNvbnN0IHRyaXNDb3VudCA9IHRoaXMuY29tcHV0ZU51bVRyaWFuZ2xlcygpOwogICAgICAgICAgICBsZXQgdHJpYW5ndWxhdGVkSW5kaWNlczsKICAgICAgICAgICAgaWYgKHRvdGFsTnVtVmVydGljZXMgPCBNYXRoLnBvdygyLCA4KSkKICAgICAgICAgICAgICAgIHRyaWFuZ3VsYXRlZEluZGljZXMgPSBuZXcgVWludDhBcnJheSh0cmlzQ291bnQgKiAzKTsKICAgICAgICAgICAgZWxzZSBpZiAodG90YWxOdW1WZXJ0aWNlcyA8IE1hdGgucG93KDIsIDE2KSkKICAgICAgICAgICAgICAgIHRyaWFuZ3VsYXRlZEluZGljZXMgPSBuZXcgVWludDE2QXJyYXkodHJpc0NvdW50ICogMyk7CiAgICAgICAgICAgIGVsc2UKICAgICAgICAgICAgICAgIHRyaWFuZ3VsYXRlZEluZGljZXMgPSBuZXcgVWludDMyQXJyYXkodHJpc0NvdW50ICogMyk7CiAgICAgICAgICAgIGxldCB0cmlhbmdsZVZlcnRleCA9IDA7CiAgICAgICAgICAgIGNvbnN0IGFkZFRyaWFuZ2xlVmVydGV4SW5kZXggPSBmdW5jdGlvbiAodmVydGV4LCBmYWNlSW5kZXgpIHsKICAgICAgICAgICAgICAgIGlmICh2ZXJ0ZXggaW4gc3BsaXRJbmRpY2VzICYmIGZhY2VJbmRleCBpbiBzcGxpdEluZGljZXNbdmVydGV4XSkKICAgICAgICAgICAgICAgICAgICB2ZXJ0ZXggPSBudW1VblNwbGl0VmVydGljZXMgKyBzcGxpdEluZGljZXNbdmVydGV4XVtmYWNlSW5kZXhdOwogICAgICAgICAgICAgICAgdHJpYW5ndWxhdGVkSW5kaWNlc1t0cmlhbmdsZVZlcnRleF0gPSB2ZXJ0ZXg7CiAgICAgICAgICAgICAgICB0cmlhbmdsZVZlcnRleCsrOwogICAgICAgICAgICB9OwogICAgICAgICAgICBjb25zdCBudW1GYWNlcyA9IHRoaXMuZ2V0TnVtRmFjZXMoKTsKICAgICAgICAgICAgZm9yIChsZXQgZmFjZUluZGV4ID0gMDsgZmFjZUluZGV4IDwgbnVtRmFjZXM7IGZhY2VJbmRleCsrKSB7CiAgICAgICAgICAgICAgICBjb25zdCBmYWNlVmVydHMgPSB0aGlzLmdldEZhY2VWZXJ0ZXhJbmRpY2VzKGZhY2VJbmRleCk7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGZhY2VWZXJ0cy5sZW5ndGg7IGorKykgewogICAgICAgICAgICAgICAgICAgIGlmIChqID49IDMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggYWRkaXRpb25hbCB0cmlhbmdsZSwgd2UgaGF2ZSB0byBhZGQgMiBpbmRpY2VzLgogICAgICAgICAgICAgICAgICAgICAgICBhZGRUcmlhbmdsZVZlcnRleEluZGV4KGZhY2VWZXJ0c1swXSwgZmFjZUluZGV4KTsKICAgICAgICAgICAgICAgICAgICAgICAgYWRkVHJpYW5nbGVWZXJ0ZXhJbmRleChmYWNlVmVydHNbaiAtIDFdLCBmYWNlSW5kZXgpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBhZGRUcmlhbmdsZVZlcnRleEluZGV4KGZhY2VWZXJ0c1tqXSwgZmFjZUluZGV4KTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gdHJpYW5ndWxhdGVkSW5kaWNlczsKICAgICAgICB9CiAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogICAgICAgIC8vIFBlcnNpc3RlbmNlCiAgICAgICAgLyoqCiAgICAgICAgICogUmVzdG9yZXMgbWVzaCBwcm9wZXJ0aWVzIGZyb20gYSBiaW5hcnkgcmVhZGVyLgogICAgICAgICAqCiAgICAgICAgICogQHBhcmFtIHJlYWRlciAtIFRoZSByZWFkZXIgdmFsdWUuCiAgICAgICAgICogQHBhcmFtIGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICByZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCkgewogICAgICAgICAgICBzdXBlci5sb2FkQmFzZUdlb21CaW5hcnkocmVhZGVyLCBjb250ZXh0KTsKICAgICAgICAgICAgdGhpcy5zZXRGYWNlQ291bnRzKEFycmF5LmZyb20ocmVhZGVyLmxvYWRVSW50MzJBcnJheSgpKSk7CiAgICAgICAgICAgIGNvbnN0IG51bUZhY2VzID0gdGhpcy5nZXROdW1GYWNlcygpOwogICAgICAgICAgICAvLyBOb3RlOiB3ZSBjYW4gcmVtb3ZlIHRoaXMuIFdlIGNhbiBpbmZlciB0aGlzIGZyb20gdGhlIGFib3ZlIGZhY2VDb3VudHMgYXJyYXkuCiAgICAgICAgICAgIGNvbnN0IGZhY2VWZXJ0ZXhDb3VudHMgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkobnVtRmFjZXMpOwogICAgICAgICAgICBjb25zdCBvZmZzZXRSYW5nZSA9IHJlYWRlci5sb2FkU0ludDMyVmVjMigpOwogICAgICAgICAgICBjb25zdCBieXRlcyA9IHJlYWRlci5sb2FkVUludDgoKTsKICAgICAgICAgICAgbGV0IGZhY2VWZXJ0ZXhJbmRleERlbHRhczsKICAgICAgICAgICAgaWYgKGJ5dGVzID09IDEpCiAgICAgICAgICAgICAgICBmYWNlVmVydGV4SW5kZXhEZWx0YXMgPSByZWFkZXIubG9hZFVJbnQ4QXJyYXkoKTsKICAgICAgICAgICAgZWxzZSBpZiAoYnl0ZXMgPT0gMikKICAgICAgICAgICAgICAgIGZhY2VWZXJ0ZXhJbmRleERlbHRhcyA9IHJlYWRlci5sb2FkVUludDE2QXJyYXkoKTsKICAgICAgICAgICAgZWxzZSBpZiAoYnl0ZXMgPT0gNCkKICAgICAgICAgICAgICAgIGZhY2VWZXJ0ZXhJbmRleERlbHRhcyA9IHJlYWRlci5sb2FkVUludDMyQXJyYXkoKTsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignZmFjZVZlcnRleEluZGV4RGVsdGFzIHVuZGVmaW5lZCcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogICAgICAgICAgICAvLyBOb3RlOiBUaGUgTWVzaCBjb21wcmVzc2lvbiBzeXN0ZW0gbmVlZHMgYSB0aG9yb3VnaCByZXZpZXcuCiAgICAgICAgICAgIC8vIFRoZSBDKysgY2xhc3NlcyBhcmUgbm90IHN0b3JpbmcgZmFjZSBpbmRpY2VzIGluIGEgc29ydGVkIG1hbm5lci4KICAgICAgICAgICAgLy8gU28gcXVhZHMgcHJlY2VkZSB0cmlhbmdsZXMgaW4gdGhlIGluZGV4aW5nLCB3aGljaCBpc24ndCBzdXBwb3NlZCB0byBoYXBwZW4uCiAgICAgICAgICAgIC8vIFdlIHNob3VsZCBmb3JjZSB0aGUgQysrIGNvZGUgdG8gc3RvcmUgcXVhZHMgYW5kIHRyaWFuZ2xlcyBpbiBvcmRlci4KICAgICAgICAgICAgLy8gZS5nLiBpbXBsZW1lbnQgdGhlICdhZGRGYWNlJyBtZXRob2QgaW4gQysrIHNvIGl0IGF1dG9tYXRpY2FsbHkgZG9lcyB0aGlzLgogICAgICAgICAgICBsZXQgbnVtRmFjZVZlcnRzID0gMzsKICAgICAgICAgICAgbGV0IG9mZnNldCA9IDA7CiAgICAgICAgICAgIGNvbnN0IGZhY2VPZmZzZXRzQnlDb3VudCA9IHRoaXMuZmFjZUNvdW50cy5tYXAoKGZjLCBpbmRleCkgPT4gewogICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb2Zmc2V0OwogICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZjICogbnVtRmFjZVZlcnRzOwogICAgICAgICAgICAgICAgbnVtRmFjZVZlcnRzKys7CiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgbGV0IHNyY09mZnNldCA9IDA7CiAgICAgICAgICAgIGxldCBwcmV2Q291bnQgPSAwOwogICAgICAgICAgICBjb25zdCBmYWNlT2Zmc2V0cyA9IFtdOwogICAgICAgICAgICBmb3IgKGxldCBmYWNlSW5kZXggPSAwOyBmYWNlSW5kZXggPCBudW1GYWNlczsgZmFjZUluZGV4KyspIHsKICAgICAgICAgICAgICAgIGNvbnN0IGZjID0gZmFjZVZlcnRleENvdW50c1tmYWNlSW5kZXhdOwogICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gZmFjZU9mZnNldHNCeUNvdW50W2ZjXTsKICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gZmMgKyAzOwogICAgICAgICAgICAgICAgZmFjZU9mZnNldHNbZmFjZUluZGV4XSA9IG9mZnNldDsKICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY291bnQ7IGorKykgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IHNyY0ZhY2VWZXJ0ZXggPSBzcmNPZmZzZXQgKyBqOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IGZhY2VWZXJ0ZXggPSBvZmZzZXQgKyBqOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZmFjZVZlcnRleEluZGV4RGVsdGFzW3NyY0ZhY2VWZXJ0ZXhdICsgb2Zmc2V0UmFuZ2UueDsKICAgICAgICAgICAgICAgICAgICBpZiAoZmFjZUluZGV4ID09IDApCiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX19mYWNlVmVydGV4SW5kaWNlc1tmYWNlVmVydGV4XSA9IGRlbHRhOwogICAgICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJldkZhY2VWZXJ0ZXggPSBmYWNlT2Zmc2V0c1tmYWNlSW5kZXggLSAxXTsKICAgICAgICAgICAgICAgICAgICAgICAgcHJldkZhY2VWZXJ0ZXggKz0gaiA8IHByZXZDb3VudCA/IGogOiBwcmV2Q291bnQgLSAxOwogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9fZmFjZVZlcnRleEluZGljZXNbZmFjZVZlcnRleF0gPSB0aGlzLl9fZmFjZVZlcnRleEluZGljZXNbcHJldkZhY2VWZXJ0ZXhdICsgZGVsdGE7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgc3JjT2Zmc2V0ICs9IGNvdW50OwogICAgICAgICAgICAgICAgZmFjZU9mZnNldHNCeUNvdW50W2ZjXSArPSBjb3VudDsKICAgICAgICAgICAgICAgIHByZXZDb3VudCA9IGNvdW50OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICghdGhpcy5oYXNWZXJ0ZXhBdHRyaWJ1dGUoJ25vcm1hbHMnKSkgewogICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vIHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTsKICAgICAgICAgICAgdGhpcy5lbWl0KCdnZW9tRGF0YUNoYW5nZWQnKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogVGhlIHRvSlNPTiBtZXRob2QgZW5jb2RlcyB0aGlzIHR5cGUgYXMgYSBqc29uIG9iamVjdCBmb3IgcGVyc2lzdGVuY2UuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIHRoZSBqc29uIG9iamVjdC4KICAgICAgICAgKi8KICAgICAgICB0b0pTT04oY29udGV4dCkgewogICAgICAgICAgICBjb25zdCBqID0gc3VwZXIudG9KU09OKGNvbnRleHQpOwogICAgICAgICAgICBpZiAoIWNvbnRleHQgfHwgIWNvbnRleHQuc2tpcFRvcG9sb2d5KSB7CiAgICAgICAgICAgICAgICBqLmZhY2VDb3VudHMgPSBBcnJheS5mcm9tKHRoaXMuZmFjZUNvdW50cyk7CiAgICAgICAgICAgICAgICBqLmZhY2VWZXJ0ZXhJbmRpY2VzID0gQXJyYXkuZnJvbSh0aGlzLl9fZmFjZVZlcnRleEluZGljZXMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBqOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBUaGUgZnJvbUpTT04gbWV0aG9kIGRlY29kZXMgYSBqc29uIG9iamVjdCBmb3IgdGhpcyB0eXBlLgogICAgICAgICAqCiAgICAgICAgICogZS5nLiB0byBsb2FkIGRhdGEgaW50byB0aGUgbWVzaCBjbGFzcywgcHJvdmlkZSBhIGpzb24gc3RydWN0dXJlIHNpbWlsYXIgdG8gdGhlIGZvbGxvd2luZy4KICAgICAgICAgKiBOb3RlOiBmYWNlQ291bnRzIGlzIGFuIGFycmF5IG9mIGNvdW50IHZhbHVlcywgc3RhcnRpbmcgd2l0aCB0aGUgbnVtYmVyIG9mIHRyaWFuZ2xlcywgdGhlbiB0aGUgbnVtYmVyIG9mIHF1YWRzLiBTZWUgI3NldEZhY2VDb3VudHMKICAgICAgICAgKiBUaGUgZmFjZVZlcnRleEluZGljZXMgYXJyYXkgc2hvdWxkIGFsc28gYmUgc29ydGVkIHRvIGNvbnRhaW4gYWxsIHRoZSB0cmlhbmdsZXMgZmlyc3QsIGZvbGxvd2VkIGJ5IHRoZSBxdWFkcywgYW5kIHRoZW4gdGhlIHBlbnRhZ29ucyBldGMuLgogICAgICAgICAqIGBgYGpzb24KICAgICAgICAgKiAvLyBUaGlzIGNvZGUgd2lsbCBkZWZpbmUgYSBtZXNoIG1hZGUgdXAgb2YgMiB0cmlhbmdsZXMgYW5kIHRoZW4gYSBxdWFkLgogICAgICAgICAqIGNvbnN0IG1lc2ggPSBuZXcgTWVzaCgpCiAgICAgICAgICogbWVzaC5mcm9tSlNPTih7CiAgICAgICAgICogICBmYWNlQ291bnRzOlsyLCAxXSwKICAgICAgICAgKiAgIGZhY2VWZXJ0ZXhJbmRpY2VzOiBbMCwgMSwgMiwgMCwgMiwgMywgMywgMiwgNCwgNV0sCiAgICAgICAgICogICBudW1WZXJ0aWNlczogNiwKICAgICAgICAgKiAgIHZlcnRleEF0dHJpYnV0ZXM6IHsKICAgICAgICAgKiAgICAgcG9zaXRpb25zOiB7CiAgICAgICAgICogICAgICAgZGF0YVR5cGU6ICdWZWMzJwogICAgICAgICAqICAgICAgIGRlZmF1bHRTY2FsYXJWYWx1ZTogMC4wLAogICAgICAgICAqICAgICAgIGRhdGE6IFswLDAsMCwgMCwgMSwgMCwgMSwgMSwgMCwgMSwgMCwgMCwgMiwgMSwgMCwgMiwgMCwgMF0KICAgICAgICAgKiAgICAgfQogICAgICAgICAqICAgfQogICAgICAgICAqIH0KICAgICAgICAgKiBgYGAKICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBqIC0gVGhlIGpzb24gb2JqZWN0IHRoaXMgaXRlbSBtdXN0IGRlY29kZS4KICAgICAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGZyb21KU09OKGosIGNvbnRleHQpIHsKICAgICAgICAgICAgc3VwZXIuZnJvbUpTT04oaiwgY29udGV4dCk7CiAgICAgICAgICAgIGlmIChqLmZhY2VDb3VudHMpCiAgICAgICAgICAgICAgICB0aGlzLmZhY2VDb3VudHMgPSBqLmZhY2VDb3VudHM7CiAgICAgICAgICAgIGlmIChqLmZhY2VWZXJ0ZXhJbmRpY2VzKQogICAgICAgICAgICAgICAgdGhpcy5fX2ZhY2VWZXJ0ZXhJbmRpY2VzID0gVWludDMyQXJyYXkuZnJvbShqLmZhY2VWZXJ0ZXhJbmRpY2VzKTsKICAgICAgICB9CiAgICB9CiAgICBSZWdpc3RyeS5yZWdpc3RlcignTWVzaCcsIE1lc2gpOwoKICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovCiAgICAvKioKICAgICAqIFJlYWRzIGJpbmFyeSBkYXRhIGluIGEgc3BlY2lmaWMgZW5jb2RpbmcuIFVzZWQgaW4gbG9hZGluZyBiaW5hcnkgZGF0YSBzdWNoIGFzIHpjYWQgZmlsZXMuCiAgICAgKi8KICAgIGNsYXNzIEJpblJlYWRlciB7CiAgICAgICAgLyoqCiAgICAgICAgICogQ3JlYXRlIGEgYmluIHJlYWRlci4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgYnVmZmVyLgogICAgICAgICAqIEBwYXJhbSBieXRlT2Zmc2V0IC0gVGhlIGJ5dGUgb2Zmc2V0IHZhbHVlIHRvIHN0YXJ0IHJlYWRpbmcgdGhlIGJ1ZmZlci4KICAgICAgICAgKiBAcGFyYW0gaXNNb2JpbGVEZXZpY2UgLSBUaGUgaXNNb2JpbGVEZXZpY2UgdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgY29uc3RydWN0b3IoZGF0YSwgYnl0ZU9mZnNldCA9IDAsIGlzTW9iaWxlRGV2aWNlID0gdHJ1ZSkgewogICAgICAgICAgICB0aGlzLl9fZGF0YSA9IGRhdGE7CiAgICAgICAgICAgIHRoaXMuX19ieXRlT2Zmc2V0ID0gYnl0ZU9mZnNldDsKICAgICAgICAgICAgdGhpcy5fX2RhdGFWaWV3ID0gbmV3IERhdGFWaWV3KHRoaXMuX19kYXRhKTsKICAgICAgICAgICAgdGhpcy5fX2lzTW9iaWxlRGV2aWNlID0gaXNNb2JpbGVEZXZpY2U7CiAgICAgICAgICAgIHRoaXMudXRmOGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyBzdGF0ZSBvZiB3aGV0aGVyIG9yIG5vdCB0aGUgYEJpblJlYWRlcmAgb2JqZWN0IHdhcyBpbnN0YW50aWF0ZWQgZnJvbSBhIG1vYmlsZSBkZXZpY2UuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyB0cnVlIGlzIGEgbW9iaWxlIGRldmljZSBpcyBkZXRlY3RlZC4KICAgICAgICAgKi8KICAgICAgICBnZXQgaXNNb2JpbGVEZXZpY2UoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9faXNNb2JpbGVEZXZpY2U7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIGRhdGEgYnVmZmVyIHdlJ3JlIHJlYWRpbmcgZnJvbS4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgZGF0YSBidWZmZXIgd2UgYXJlIHJlYWRpbmcgZnJvbSwKICAgICAgICAgKi8KICAgICAgICBnZXQgZGF0YSgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGJ1ZmZlci4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgdG90YWwgbGVuZ3RoIG9mIHRoZSBidWZmZXIKICAgICAgICAgKi8KICAgICAgICBnZXQgYnl0ZUxlbmd0aCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhVmlldy5ieXRlTGVuZ3RoOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHJlbWFpbmluZyBsZW5ndGggb2YgdGhlIGJ1ZmZlciB0byByZWFkLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZW1haW5pbmcgbGVuZ3RoIG9mIHRoZSBidWZmZXIgdG8gcmVhZC4KICAgICAgICAgKi8KICAgICAgICBnZXQgcmVtYWluaW5nQnl0ZUxlbmd0aCgpIHsKICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhVmlldy5ieXRlTGVuZ3RoIC0gdGhpcy5fX2J5dGVPZmZzZXQ7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgY3VycmVudCBieXRlIG9mZnNldCBpbiB0aGUgYnVmZmVyLgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgY3VycmVudCBvZmZzZXQgaW4gdGhlIGJpbmFyeSBidWZmZXIKICAgICAgICAgKi8KICAgICAgICBwb3MoKSB7CiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fYnl0ZU9mZnNldDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogU2V0cyB0aGUgYnl0ZSBvZmZzZXQgdmFsdWUuCiAgICAgICAgICogQHBhcmFtIGJ5dGVPZmZzZXQgLSBUaGUgYnl0ZU9mZnNldCBwYXJhbS4KICAgICAgICAgKi8KICAgICAgICBzZWVrKGJ5dGVPZmZzZXQpIHsKICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgPSBieXRlT2Zmc2V0OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBBZGRzIG9mZnNldCBieXRlcyB0byBjdXJyZW50IG9mZnNldCB2YWx1ZS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBieXRlT2Zmc2V0IC0gVGhlIGJ5dGUgT2Zmc2V0IGFtb3VudC4KICAgICAgICAgKi8KICAgICAgICBhZHZhbmNlKGJ5dGVPZmZzZXQpIHsKICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gYnl0ZU9mZnNldDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0aGUgdW5zaWduZWQgVWludDggdmFsdWUgYXQgY3VycmVudCBieXRlIG9mZnNldCBwb3NpdGlvbiwKICAgICAgICAgKiBhbmQgYWRkcyBvbmUgYnl0ZSB0byB0aGUgb2Zmc2V0LgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgbG9hZFVJbnQ4KCkgewogICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9fZGF0YVZpZXcuZ2V0VWludDgodGhpcy5fX2J5dGVPZmZzZXQpOwogICAgICAgICAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSAxOwogICAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bnNpZ25lZCBVaW50MTYgdmFsdWUgYXQgY3VycmVudCBieXRlIG9mZnNldCBwb3NpdGlvbiwKICAgICAgICAgKiBhbmQgYWRkcyB0d28gYnl0ZXMgdG8gdGhlIG9mZnNldC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGxvYWRVSW50MTYoKSB7CiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX19kYXRhVmlldy5nZXRVaW50MTYodGhpcy5fX2J5dGVPZmZzZXQsIHRydWUpOwogICAgICAgICAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSAyOwogICAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRoZSB1bnNpZ25lZCBVaW50MzIgdmFsdWUgYXQgY3VycmVudCBieXRlIG9mZnNldCBwb3NpdGlvbiwKICAgICAgICAgKiBhbmQgYWRkcyBmb3VyIGJ5dGVzIHRvIHRoZSBvZmZzZXQuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBsb2FkVUludDMyKCkgewogICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9fZGF0YVZpZXcuZ2V0VWludDMyKHRoaXMuX19ieXRlT2Zmc2V0LCB0cnVlKTsKICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gNDsKICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0aGUgc2lnbmVkIEludDMyIHZhbHVlIGF0IGN1cnJlbnQgYnl0ZSBvZmZzZXQgcG9zaXRpb24sCiAgICAgICAgICogYW5kIGFkZHMgZm91ciBieXRlcyB0byB0aGUgb2Zmc2V0LgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgbG9hZFNJbnQzMigpIHsKICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fX2RhdGFWaWV3LmdldEludDMyKHRoaXMuX19ieXRlT2Zmc2V0LCB0cnVlKTsKICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gNDsKICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyB0aGUgRmxvYXQxNiB2YWx1ZSBhdCBjdXJyZW50IGJ5dGUgb2Zmc2V0IHBvc2l0aW9uLAogICAgICAgICAqIGFuZCBhZGRzIGZvdXIgYnl0ZXMgdG8gdGhlIG9mZnNldC4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGxvYWRGbG9hdDE2KCkgewogICAgICAgICAgICBjb25zdCB1aW50MTYgPSB0aGlzLmxvYWRVSW50MTYoKTsKICAgICAgICAgICAgcmV0dXJuIE1hdGhGdW5jdGlvbnMuZGVjb2RlMTZCaXRGbG9hdCh1aW50MTYpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIHRoZSBGbG9hdDE2IHZhbHVlIGF0IGN1cnJlbnQgYnl0ZSBvZmZzZXQgcG9zaXRpb24sCiAgICAgICAgICogYW5kIGFkZHMgdHdvIGJ5dGVzIHRvIHRoZSBvZmZzZXQuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBsb2FkVUZsb2F0MTYoKSB7CiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMubG9hZEZsb2F0MTYoKTsKICAgICAgICAgICAgaWYgKHJlc3VsdCA8IDAuMCkgewogICAgICAgICAgICAgICAgcmV0dXJuIDIwNDguMCAtIHJlc3VsdDsgLy8gTm90ZTogc3VidHJhY3QgYSBuZWdhdGl2ZSBudW1iZXIgdG8gYWRkIGl0LgogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZXR1cm5zIGEgc2luZ2xlIHNpZ25lZCBGbG9hdDE2IHZhbHVlIGF0IGN1cnJlbnQgYnl0ZSBvZmZzZXQgcG9zaXRpb24gZnJvbSAyIHVuc2lnbmVkIEludDggdmFsdWVzLAogICAgICAgICAqIGFuZCBhZGRzIHR3byBieXRlcyB0byB0aGUgb2Zmc2V0LgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgbG9hZEZsb2F0MTZGcm9tMnhVSW50OCgpIHsKICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ2xvYWRGbG9hdDE2RnJvbTJ4VUludDggbm90IGltcGxlbWVudGVkIScpOwogICAgICAgICAgICAvLyBjb25zdCByZXN1bHQgPSB0aGlzLl9fZGF0YVZpZXcuZ2V0RmxvYXQxNih0aGlzLl9fYnl0ZU9mZnNldCwgdHJ1ZSkKICAgICAgICAgICAgLy8gY29uc3QgdWludDhzID0gdGhpcy5sb2FkVUludDhBcnJheSgyKTsKICAgICAgICAgICAgLy8gcmV0dXJuIE1hdGguZGVjb2RlMTZCaXRGbG9hdCh1aW50OHMpOwogICAgICAgICAgICAvLyB0aGlzLl9fYnl0ZU9mZnNldCArPSAyCiAgICAgICAgICAgIC8vIHJldHVybiByZXN1bHQKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogTG9hZHMgYW5kIHJldHVybnMgYSBzaW5nbGUgU2lnbmVkIGludGVnZXIgdmFsdWUgZnJvbSAyIFVuc2lnbmVkIEZsb2F0MTYgdmFsdWVzLgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGxvYWRVSW50MzJGcm9tMnhVRmxvYXQxNigpIHsKICAgICAgICAgICAgY29uc3QgcGFydEEgPSB0aGlzLmxvYWRVRmxvYXQxNigpOwogICAgICAgICAgICBjb25zdCBwYXJ0QiA9IHRoaXMubG9hZFVGbG9hdDE2KCk7CiAgICAgICAgICAgIHJldHVybiBwYXJ0QSArIHBhcnRCICogNDA5NjsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogTG9hZHMgYW5kIHJldHVybnMgYSBzaW5nbGUgU2lnbmVkIGludGVnZXIgdmFsdWUgZnJvbSAyIHNpZ25lZCBGbG9hdDE2IHZhbHVlcy4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBsb2FkU0ludDMyRnJvbTJ4RmxvYXQxNigpIHsKICAgICAgICAgICAgY29uc3QgcGFydEEgPSB0aGlzLmxvYWRGbG9hdDE2KCk7CiAgICAgICAgICAgIGNvbnN0IHBhcnRCID0gdGhpcy5sb2FkRmxvYXQxNigpOwogICAgICAgICAgICByZXR1cm4gcGFydEEgKyBwYXJ0QiAqIDIwNDg7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgdGhlIEZsb2F0MzIgdmFsdWUgYXQgY3VycmVudCBieXRlIG9mZnNldCBwb3NpdGlvbiwKICAgICAgICAgKiBhbmQgYWRkcyBmb3VyIGJ5dGVzIHRvIHRoZSBvZmZzZXQuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBsb2FkRmxvYXQzMigpIHsKICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fX2RhdGFWaWV3LmdldEZsb2F0MzIodGhpcy5fX2J5dGVPZmZzZXQsIHRydWUpOwogICAgICAgICAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSA0OwogICAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZWFkcyBidWZmZXIgYW5kIHJldHVybiBhbiB1bnNpZ25lZCBJbnQ4IGFycmF5IHdpdGggdGhlIHNwZWNpZmllZCBzaXplLAogICAgICAgICAqIHN0YXJ0aW5nIGZyb20gY3VycmVudCBieXRlIG9mZnNldC4KICAgICAgICAgKiBCeXRlIG9mZnNldCBpcyBpbmNyZWFzZWQgYnkgdGhlIHNwZWNpZmllZCBieXRlIHNpemUuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gc2l6ZSAtIFRoZSBzaXplIHBhcmFtLgogICAgICAgICAqIEBwYXJhbSBjbG9uZSAtIFRoZSBjbG9uZSBwYXJhbS4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBsb2FkVUludDhBcnJheShzaXplLCBjbG9uZSA9IGZhbHNlKSB7CiAgICAgICAgICAgIGlmIChzaXplID09IHVuZGVmaW5lZCkKICAgICAgICAgICAgICAgIHNpemUgPSB0aGlzLmxvYWRVSW50MzIoKTsKICAgICAgICAgICAgbGV0IHJlc3VsdDsKICAgICAgICAgICAgaWYgKGNsb25lKSB7CiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0aGlzLl9fZGF0YS5zbGljZSh0aGlzLl9fYnl0ZU9mZnNldCwgdGhpcy5fX2J5dGVPZmZzZXQgKyBzaXplKSk7CiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPSBzaXplKQogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdicm9rZW4nKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHRoaXMuX19kYXRhLCB0aGlzLl9fYnl0ZU9mZnNldCwgc2l6ZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gc2l6ZTsKICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmVhZHMgYnVmZmVyIGFuZCByZXR1cm4gYW4gdW5zaWduZWQgSW50MTYgYXJyYXkgd2l0aCB0aGUgc3BlY2lmaWVkIHNpemUsCiAgICAgICAgICogc3RhcnRpbmcgZnJvbSBjdXJyZW50IGJ5dGUgb2Zmc2V0LgogICAgICAgICAqIEJ5dGUgb2Zmc2V0IGlzIGluY3JlYXNlZCBieSB0aGUgc3BlY2lmaWVkIGJ5dGUgc2l6ZSB4IDIuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gc2l6ZSAtIFRoZSBzaXplIHBhcmFtLgogICAgICAgICAqIEBwYXJhbSBjbG9uZSAtIFRoZSBjbG9uZSBwYXJhbS4KICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBsb2FkVUludDE2QXJyYXkoc2l6ZSwgY2xvbmUgPSBmYWxzZSkgewogICAgICAgICAgICBpZiAoc2l6ZSA9PSB1bmRlZmluZWQpCiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy5sb2FkVUludDMyKCk7CiAgICAgICAgICAgIGlmIChzaXplID09IDApCiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQxNkFycmF5KCk7CiAgICAgICAgICAgIHRoaXMucmVhZFBhZCgyKTsKICAgICAgICAgICAgbGV0IHJlc3VsdDsKICAgICAgICAgICAgaWYgKHRoaXMuX19pc01vYmlsZURldmljZSkgewogICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQxNkFycmF5KHNpemUpOwogICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSB0aGlzLl9fZGF0YVZpZXcuZ2V0VWludDE2KHRoaXMuX19ieXRlT2Zmc2V0LCB0cnVlKTsKICAgICAgICAgICAgICAgICAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSAyOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgaWYgKGNsb25lKSB7CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuX19kYXRhLnNsaWNlKHRoaXMuX19ieXRlT2Zmc2V0LCB0aGlzLl9fYnl0ZU9mZnNldCArIHNpemUgKiAyKSk7CiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggIT0gc2l6ZSkKICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Jyb2tlbicpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuX19kYXRhLCB0aGlzLl9fYnl0ZU9mZnNldCwgc2l6ZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSBzaXplICogMjsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBSZWFkcyBidWZmZXIgYW5kIHJldHVybiBhbiB1bnNpZ25lZCBJbnQzMiBhcnJheSB3aXRoIHRoZSBzcGVjaWZpZWQgc2l6ZSwKICAgICAgICAgKiBzdGFydGluZyBmcm9tIGN1cnJlbnQgYnl0ZSBvZmZzZXQuCiAgICAgICAgICogQnl0ZSBvZmZzZXQgaXMgaW5jcmVhc2VkIGJ5IHRoZSBzcGVjaWZpZWQgYnl0ZSBzaXplIHggNC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBzaXplIC0gVGhlIHNpemUgcGFyYW0uCiAgICAgICAgICogQHBhcmFtIGNsb25lIC0gVGhlIGNsb25lIHBhcmFtLgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGxvYWRVSW50MzJBcnJheShzaXplLCBjbG9uZSA9IGZhbHNlKSB7CiAgICAgICAgICAgIGlmIChzaXplID09IHVuZGVmaW5lZCkKICAgICAgICAgICAgICAgIHNpemUgPSB0aGlzLmxvYWRVSW50MzIoKTsKICAgICAgICAgICAgaWYgKHNpemUgPT0gMCkKICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkoKTsKICAgICAgICAgICAgdGhpcy5yZWFkUGFkKDQpOwogICAgICAgICAgICBsZXQgcmVzdWx0OwogICAgICAgICAgICBpZiAodGhpcy5fX2lzTW9iaWxlRGV2aWNlKSB7CiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVWludDMyQXJyYXkoc2l6ZSk7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykgewogICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuX19kYXRhVmlldy5nZXRVaW50MzIodGhpcy5fX2J5dGVPZmZzZXQsIHRydWUpOwogICAgICAgICAgICAgICAgICAgIHRoaXMuX19ieXRlT2Zmc2V0ICs9IDQ7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICBpZiAoY2xvbmUpIHsKICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVWludDMyQXJyYXkodGhpcy5fX2RhdGEuc2xpY2UodGhpcy5fX2J5dGVPZmZzZXQsIHRoaXMuX19ieXRlT2Zmc2V0ICsgc2l6ZSAqIDQpKTsKICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCAhPSBzaXplKQogICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnYnJva2VuJyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVWludDMyQXJyYXkodGhpcy5fX2RhdGEsIHRoaXMuX19ieXRlT2Zmc2V0LCBzaXplKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHRoaXMuX19ieXRlT2Zmc2V0ICs9IHNpemUgKiA0OwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJlYWRzIGJ1ZmZlciBhbmQgcmV0dXJuIGEgRmxvYXQzMiBhcnJheSB3aXRoIHRoZSBzcGVjaWZpZWQgc2l6ZSwKICAgICAgICAgKiBzdGFydGluZyBmcm9tIGN1cnJlbnQgYnl0ZSBvZmZzZXQuCiAgICAgICAgICogQnl0ZSBvZmZzZXQgaXMgaW5jcmVhc2VkIGJ5IHRoZSBzcGVjaWZpZWQgYnl0ZSBzaXplIHggNC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBzaXplIC0gVGhlIHNpemUgcGFyYW0uCiAgICAgICAgICogQHBhcmFtIGNsb25lIC0gVGhlIGNsb25lIHBhcmFtLgogICAgICAgICAqIEByZXR1cm4gLSBUaGUgcmV0dXJuIHZhbHVlLgogICAgICAgICAqLwogICAgICAgIGxvYWRGbG9hdDMyQXJyYXkoc2l6ZSwgY2xvbmUgPSBmYWxzZSkgewogICAgICAgICAgICBpZiAoc2l6ZSA9PSB1bmRlZmluZWQpCiAgICAgICAgICAgICAgICBzaXplID0gdGhpcy5sb2FkVUludDMyKCk7CiAgICAgICAgICAgIGlmIChzaXplID09IDApCiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSgpOwogICAgICAgICAgICB0aGlzLnJlYWRQYWQoNCk7CiAgICAgICAgICAgIGxldCByZXN1bHQ7CiAgICAgICAgICAgIGlmICh0aGlzLl9faXNNb2JpbGVEZXZpY2UpIHsKICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykgewogICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuX19kYXRhVmlldy5nZXRGbG9hdDMyKHRoaXMuX19ieXRlT2Zmc2V0LCB0cnVlKTsKICAgICAgICAgICAgICAgICAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSA0OwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgaWYgKGNsb25lKSB7CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl9fZGF0YS5zbGljZSh0aGlzLl9fYnl0ZU9mZnNldCwgdGhpcy5fX2J5dGVPZmZzZXQgKyBzaXplICogNCkpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLl9fZGF0YSwgdGhpcy5fX2J5dGVPZmZzZXQsIHNpemUpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gc2l6ZSAqIDQ7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUmV0dXJucyBuZXh0IHN0cmluZy4KICAgICAgICAgKiBGaXJzdCBsb29rcyBmb3IgdGhlIHN0cmluZyBsZW5ndGggZGVzY3JpcHRpb24gaW4gdGhlIG5leHQgZm91ciBieXRlcyBpbiB0aGUgYnVmZmVyKFN0YXJ0aW5nIGZyb20gYnl0ZSBvZmZzZXQpLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFRoZSByZXR1cm4gdmFsdWUuCiAgICAgICAgICovCiAgICAgICAgbG9hZFN0cigpIHsKICAgICAgICAgICAgY29uc3QgbnVtQ2hhcnMgPSB0aGlzLmxvYWRVSW50MzIoKTsKICAgICAgICAgICAgY29uc3QgY2hhcnMgPSBuZXcgVWludDhBcnJheSh0aGlzLl9fZGF0YSwgdGhpcy5fX2J5dGVPZmZzZXQsIG51bUNoYXJzKTsKICAgICAgICAgICAgdGhpcy5fX2J5dGVPZmZzZXQgKz0gbnVtQ2hhcnM7CiAgICAgICAgICAgIHJldHVybiB0aGlzLnV0ZjhkZWNvZGVyLmRlY29kZShjaGFycyk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2Ygc3RyaW5ncy4KICAgICAgICAgKiBGaXJzdCByZWFkaW5nIHRoZSBzaXplIG9mIHRoZSBhcnJheSB0aGVuIHJlYWRpbmcgZWFjaCBzdHJpbmcuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gVGhlIHJldHVybiB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBsb2FkU3RyQXJyYXkoKSB7CiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmxvYWRVSW50MzIoKTsKICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107CiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7CiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSB0aGlzLmxvYWRTdHIoKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gcmVzdWx0OwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYFZlYzJgIG9iamVjdCB3aXRoIHRoZSBuZXh0IHR3byBzaWduZWQgSW50MzIgdmFsdWVzIGluIHRoZSBidWZmZXIuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIFZlYzIuCiAgICAgICAgICovCiAgICAgICAgbG9hZFNJbnQzMlZlYzIoKSB7CiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmxvYWRTSW50MzIoKTsKICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMubG9hZFNJbnQzMigpOwogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBgVmVjMmAgb2JqZWN0IHdpdGggdGhlIG5leHQgdHdvIHVuc2lnbmVkIEludDMyIHZhbHVlcyBpbiB0aGUgYnVmZmVyLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgVmVjMi4KICAgICAgICAgKi8KICAgICAgICBsb2FkVUludDMyVmVjMigpIHsKICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMubG9hZFVJbnQzMigpOwogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5sb2FkVUludDMyKCk7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih4LCB5KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBWZWMyYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCB0d28gRmxvYXQxNiB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgVmVjMi4KICAgICAgICAgKi8KICAgICAgICBsb2FkRmxvYXQxNlZlYzIoKSB7CiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmxvYWRGbG9hdDE2KCk7CiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLmxvYWRGbG9hdDE2KCk7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMih4LCB5KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBWZWMyYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCB0d28gRmxvYXQzMiB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIFZlYzIuCiAgICAgICAgICovCiAgICAgICAgbG9hZEZsb2F0MzJWZWMyKCkgewogICAgICAgICAgICBjb25zdCB4ID0gdGhpcy5sb2FkRmxvYXQzMigpOwogICAgICAgICAgICBjb25zdCB5ID0gdGhpcy5sb2FkRmxvYXQzMigpOwogICAgICAgICAgICByZXR1cm4gbmV3IFZlYzIoeCwgeSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBgVmVjM2Agb2JqZWN0IHdpdGggdGhlIG5leHQgdGhyZWUgRmxvYXQxNiB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgVmVjMy4KICAgICAgICAgKi8KICAgICAgICBsb2FkRmxvYXQxNlZlYzMoKSB7CiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmxvYWRGbG9hdDE2KCk7CiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLmxvYWRGbG9hdDE2KCk7CiAgICAgICAgICAgIGNvbnN0IHogPSB0aGlzLmxvYWRGbG9hdDE2KCk7CiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjMyh4LCB5LCB6KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBWZWMzYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCB0aHJlZSBGbG9hdDMyIHZhbHVlcyBpbiB0aGUgYnVmZmVyLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBWZWMzLgogICAgICAgICAqLwogICAgICAgIGxvYWRGbG9hdDMyVmVjMygpIHsKICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMubG9hZEZsb2F0MzIoKTsKICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMubG9hZEZsb2F0MzIoKTsKICAgICAgICAgICAgY29uc3QgeiA9IHRoaXMubG9hZEZsb2F0MzIoKTsKICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWMzKHgsIHksIHopOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYFF1YXRgIG9iamVjdCB3aXRoIHRoZSBuZXh0IGZvdXIgRmxvYXQxNiB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgUXVhdC4KICAgICAgICAgKi8KICAgICAgICBsb2FkRmxvYXQxNlF1YXQoKSB7CiAgICAgICAgICAgIGNvbnN0IHggPSB0aGlzLmxvYWRGbG9hdDE2KCk7CiAgICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLmxvYWRGbG9hdDE2KCk7CiAgICAgICAgICAgIGNvbnN0IHogPSB0aGlzLmxvYWRGbG9hdDE2KCk7CiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLmxvYWRGbG9hdDE2KCk7CiAgICAgICAgICAgIHJldHVybiBuZXcgUXVhdCh4LCB5LCB6LCB3KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBRdWF0YCBvYmplY3Qgd2l0aCB0aGUgbmV4dCBmb3VyIEZsb2F0MzIgdmFsdWVzIGluIHRoZSBidWZmZXIuCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBRdWF0LgogICAgICAgICAqLwogICAgICAgIGxvYWRGbG9hdDMyUXVhdCgpIHsKICAgICAgICAgICAgY29uc3QgeCA9IHRoaXMubG9hZEZsb2F0MzIoKTsKICAgICAgICAgICAgY29uc3QgeSA9IHRoaXMubG9hZEZsb2F0MzIoKTsKICAgICAgICAgICAgY29uc3QgeiA9IHRoaXMubG9hZEZsb2F0MzIoKTsKICAgICAgICAgICAgY29uc3QgdyA9IHRoaXMubG9hZEZsb2F0MzIoKTsKICAgICAgICAgICAgcmV0dXJuIG5ldyBRdWF0KHgsIHksIHosIHcpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYENvbG9yYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCB0aHJlZSBGbG9hdDMyIHZhbHVlcyBpbiB0aGUgYnVmZmVyLgogICAgICAgICAqCiAgICAgICAgICogQHJldHVybiAtIFJldHVybnMgYSBDb2xvci4KICAgICAgICAgKi8KICAgICAgICBsb2FkUkdCRmxvYXQzMkNvbG9yKCkgewogICAgICAgICAgICBjb25zdCByID0gdGhpcy5sb2FkRmxvYXQzMigpOwogICAgICAgICAgICBjb25zdCBnID0gdGhpcy5sb2FkRmxvYXQzMigpOwogICAgICAgICAgICBjb25zdCBiID0gdGhpcy5sb2FkRmxvYXQzMigpOwogICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgUkdCQSBgQ29sb3JgIG9iamVjdCB3aXRoIHRoZSBuZXh0IGZvdXIgRmxvYXQzMiB2YWx1ZXMgaW4gdGhlIGJ1ZmZlci4KICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIENvbG9yLgogICAgICAgICAqLwogICAgICAgIGxvYWRSR0JBRmxvYXQzMkNvbG9yKCkgewogICAgICAgICAgICBjb25zdCByID0gdGhpcy5sb2FkRmxvYXQzMigpOwogICAgICAgICAgICBjb25zdCBnID0gdGhpcy5sb2FkRmxvYXQzMigpOwogICAgICAgICAgICBjb25zdCBiID0gdGhpcy5sb2FkRmxvYXQzMigpOwogICAgICAgICAgICBjb25zdCBhID0gdGhpcy5sb2FkRmxvYXQzMigpOwogICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIsIGEpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYENvbG9yYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCB0aHJlZSB1bnNpZ25lZCBJbnQ4IHZhbHVlcyBpbiB0aGUgYnVmZmVyLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgQ29sb3IuCiAgICAgICAgICovCiAgICAgICAgbG9hZFJHQlVJbnQ4Q29sb3IoKSB7CiAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLmxvYWRVSW50OCgpOwogICAgICAgICAgICBjb25zdCBnID0gdGhpcy5sb2FkVUludDgoKTsKICAgICAgICAgICAgY29uc3QgYiA9IHRoaXMubG9hZFVJbnQ4KCk7CiAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IociAvIDI1NSwgZyAvIDI1NSwgYiAvIDI1NSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBSR0JBIGBDb2xvcmAgb2JqZWN0IHdpdGggdGhlIG5leHQgZm91ciB1bnNpZ25lZCBJbnQ4IHZhbHVlcyBpbiB0aGUgYnVmZmVyLgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgQ29sb3IuCiAgICAgICAgICovCiAgICAgICAgbG9hZFJHQkFVSW50OENvbG9yKCkgewogICAgICAgICAgICBjb25zdCByID0gdGhpcy5sb2FkVUludDgoKTsKICAgICAgICAgICAgY29uc3QgZyA9IHRoaXMubG9hZFVJbnQ4KCk7CiAgICAgICAgICAgIGNvbnN0IGIgPSB0aGlzLmxvYWRVSW50OCgpOwogICAgICAgICAgICBjb25zdCBhID0gdGhpcy5sb2FkVUludDgoKTsKICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyIC8gMjU1LCBnIC8gMjU1LCBiIC8gMjU1LCBhIC8gMjU1KTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGBCb3gyYCBvYmplY3Qgd2l0aCB0aGUgbmV4dCBmb3VyIEZsb2F0MzIgdmFsdWVzIGluIHRoZSBidWZmZXIuCiAgICAgICAgICogTmV4dCBmb3VyIGJlY2F1c2UgaXQgY3JlYXRlcyB0d28gVmVjMi4KICAgICAgICAgKgogICAgICAgICAqIEByZXR1cm4gLSBSZXR1cm5zIGEgQm94Mi4KICAgICAgICAgKi8KICAgICAgICBsb2FkQm94MigpIHsKICAgICAgICAgICAgcmV0dXJuIG5ldyBCb3gyKHRoaXMubG9hZEZsb2F0MzJWZWMyKCksIHRoaXMubG9hZEZsb2F0MzJWZWMyKCkpOwogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgYEJveDJgIG9iamVjdCB3aXRoIHRoZSBuZXh0IHNpeCBGbG9hdDMyIHZhbHVlcyBpbiB0aGUgYnVmZmVyLgogICAgICAgICAqIE5leHQgZm91ciBiZWNhdXNlIGl0IGNyZWF0ZXMgdHdvIFZlYzMuCiAgICAgICAgICoKICAgICAgICAgKiBAcmV0dXJuIC0gUmV0dXJucyBhIEJveDMuCiAgICAgICAgICovCiAgICAgICAgbG9hZEJveDMoKSB7CiAgICAgICAgICAgIHJldHVybiBuZXcgQm94Myh0aGlzLmxvYWRGbG9hdDMyVmVjMygpLCB0aGlzLmxvYWRGbG9hdDMyVmVjMygpKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogR2l2ZW4gYSBzdHJpZGVlIHZhbHVlLCBhZHZhbmNlIHRoZSBwb2ludGVyIHRvIHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgc3RyaWRlLgogICAgICAgICAqIEBwYXJhbSBzdHJpZGUgLSBUaGUgc3RyaWRlIHBhcmFtLgogICAgICAgICAqLwogICAgICAgIHJlYWRQYWQoc3RyaWRlKSB7CiAgICAgICAgICAgIGNvbnN0IHBhZCA9IHRoaXMuX19ieXRlT2Zmc2V0ICUgc3RyaWRlOwogICAgICAgICAgICBpZiAocGFkICE9IDApCiAgICAgICAgICAgICAgICB0aGlzLl9fYnl0ZU9mZnNldCArPSBzdHJpZGUgLSBwYWQ7CiAgICAgICAgfQogICAgfQoKICAgIC8qKgogICAgICogQ2xhc3MgZGVzaWduZWQgdG8gc3RvcmUgdmVyc2lvbiBkYXRhLiBXaWRlbHkgdXNlZCBpbiB0aGUgemVhIGVuZ2luZSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuCiAgICAgKi8KICAgIGNsYXNzIFZlcnNpb24gewogICAgICAgIC8qKgogICAgICAgICAqIENyZWF0ZXMgYSB2ZXJzaW9uLgogICAgICAgICAqIFRoZSB2ZXJzaW9uIHN0cmluZyBzaG91bGQgaGF2ZSB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZToKICAgICAgICAgKiBtYWpvciwgbWlub3IgYW5kIHBhdGNoIHNlcGFyYXRlZCBieSBhIGRvdChgLmApIGFuZCBwYXJ0cyBzZXBhcmF0ZWQgYnkgYSBkYXNoKGAtYCkuCiAgICAgICAgICoKICAgICAgICAgKiBAcGFyYW0gdmVyc2lvblN0ciAtIFRoZSB2ZXJzaW9uIHN0cmluZyB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICBjb25zdHJ1Y3Rvcih2ZXJzaW9uU3RyID0gJycpIHsKICAgICAgICAgICAgdGhpcy5icmFuY2ggPSAnJzsKICAgICAgICAgICAgaWYgKHZlcnNpb25TdHIpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gdmVyc2lvblN0ci5zcGxpdCgnLScpOwogICAgICAgICAgICAgICAgY29uc3QgbnVtYmVycyA9IHBhcnRzWzBdLnNwbGl0KCcuJyk7CiAgICAgICAgICAgICAgICB0aGlzLm1ham9yID0gcGFyc2VJbnQobnVtYmVyc1swXSk7CiAgICAgICAgICAgICAgICB0aGlzLm1pbm9yID0gcGFyc2VJbnQobnVtYmVyc1sxXSk7CiAgICAgICAgICAgICAgICB0aGlzLnBhdGNoID0gcGFyc2VJbnQobnVtYmVyc1syXSk7CiAgICAgICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID09IDIpCiAgICAgICAgICAgICAgICAgICAgdGhpcy5icmFuY2ggPSBwYXJ0c1sxXTsKICAgICAgICAgICAgfQogICAgICAgICAgICBlbHNlIHsKICAgICAgICAgICAgICAgIHRoaXMubWFqb3IgPSAwOwogICAgICAgICAgICAgICAgdGhpcy5taW5vciA9IDA7CiAgICAgICAgICAgICAgICB0aGlzLnBhdGNoID0gMDsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICAvKioKICAgICAgICAgKiBDb21wYXJlIGEgdmVyc2lvbiBvYmplY3QgYWdhaW5zdCBhIHZlcnNpb24gbnVtYmVycyBhcnJheS4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBudW1iZXJzIC0gQW4gYXJyYXkgY29udGFpbmluZyAzIHZlcnNpb24gbnVtYmVycy4gW01ham9yLCBNaW5vciwgUGF0Y2hdCiAgICAgICAgICogQHJldHVybiAtIHJldHVybiBwb3NpdGl2ZTogdjEgPiB2MiwgemVybzp2MSA9PSB2MiwgbmVnYXRpdmU6IHYxIDwgdjIKICAgICAgICAgKi8KICAgICAgICBjb21wYXJlKG51bWJlcnMpIHsKICAgICAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjgzMjU5Ni9ob3ctdG8tY29tcGFyZS1zb2Z0d2FyZS12ZXJzaW9uLW51bWJlci11c2luZy1qcy1vbmx5LW51bWJlcgogICAgICAgICAgICAvLyAybmQgYW5zd2VyLgogICAgICAgICAgICBjb25zdCB2MSA9IFt0aGlzLm1ham9yLCB0aGlzLm1pbm9yLCB0aGlzLnBhdGNoXTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHsKICAgICAgICAgICAgICAgIGlmICh2MVtpXSAhPT0gbnVtYmVyc1tpXSkKICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjFbaV0gLSBudW1iZXJzW2ldOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgIH0KICAgICAgICB0b1N0cmluZygpIHsKICAgICAgICAgICAgcmV0dXJuIGB2JHt0aGlzLm1ham9yfS4ke3RoaXMubWlub3J9LiR7dGhpcy5wYXRjaH1gICsgKHRoaXMuYnJhbmNoICE9ICcnID8gYC0ke3RoaXMuYnJhbmNofWAgOiAnJyk7CiAgICAgICAgfQogICAgfQoKICAgIC8qKgogICAgICogQHByaXZhdGUKICAgICAqIEBleHRlbmRzIEJhc2VHZW9tCiAgICAgKi8KICAgIGNsYXNzIENvbXBvdW5kR2VvbUxvYWRlciBleHRlbmRzIEJhc2VHZW9tIHsKICAgICAgICAvKioKICAgICAgICAgKiBDcmVhdGUgcG9pbnRzLgogICAgICAgICAqLwogICAgICAgIGNvbnN0cnVjdG9yKCkgewogICAgICAgICAgICBzdXBlcigpOwogICAgICAgICAgICB0aGlzLm51bVN1Ykdlb21zID0gMDsKICAgICAgICAgICAgdGhpcy5pbmRpY2VzID0gbmV3IFVpbnQ4QXJyYXkoMCk7CiAgICAgICAgICAgIHRoaXMub2Zmc2V0cyA9IHt9OwogICAgICAgICAgICB0aGlzLmNvdW50cyA9IHt9OwogICAgICAgICAgICAvLyBGb3IgZWFjaCB0eXBlIG9mIGdlb20gKFRSSUFOR0xFUywgTElORVMpCiAgICAgICAgICAgIC8vIEEgbWF0ZXJpYWwgaWQsIGFuZCBlYWNoIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGJsb2NrCiAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxTdWJHZW9tcyA9IHt9OwogICAgICAgICAgICB0aGlzLnN1Ykdlb21PZmZzZXRzID0ge307CiAgICAgICAgICAgIHRoaXMuc3ViR2VvbUNvdW50cyA9IHt9OwogICAgICAgICAgICB0aGlzLm1hdGVyaWFsTGlicmFyeUluZGljZXMgPSBuZXcgVWludDMyQXJyYXkoMCk7CiAgICAgICAgICAgIHRoaXMuc3ViR2VvbU1hdGVyaWFsSW5kaWNlcyA9IG5ldyBVaW50OEFycmF5KDApOwogICAgICAgIH0KICAgICAgICBnZW5CdWZmZXJzKCkgewogICAgICAgICAgICBjb25zdCBhdHRyQnVmZmVycyA9IHt9OwogICAgICAgICAgICBmb3IgKGNvbnN0IFthdHRyTmFtZSwgYXR0cl0gb2YgdGhpcy5fX3ZlcnRleEF0dHJpYnV0ZXMpIHsKICAgICAgICAgICAgICAgIGF0dHJCdWZmZXJzW2F0dHJOYW1lXSA9IGF0dHIuZ2VuQnVmZmVyKCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3QgbnVtVmVydGljZXMgPSB0aGlzLm51bVZlcnRpY2VzKCk7CiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsKICAgICAgICAgICAgICAgIG51bVZlcnRpY2VzLAogICAgICAgICAgICAgICAgbnVtUmVuZGVyVmVydHM6IG51bVZlcnRpY2VzLAogICAgICAgICAgICAgICAgaW5kaWNlczogdGhpcy5pbmRpY2VzLAogICAgICAgICAgICAgICAgYXR0ckJ1ZmZlcnMsCiAgICAgICAgICAgICAgICBvZmZzZXRzOiB0aGlzLm9mZnNldHMsCiAgICAgICAgICAgICAgICBjb3VudHM6IHRoaXMuY291bnRzLAogICAgICAgICAgICAgICAgc3ViR2VvbU9mZnNldHM6IHRoaXMuc3ViR2VvbU9mZnNldHMsCiAgICAgICAgICAgICAgICBzdWJHZW9tQ291bnRzOiB0aGlzLnN1Ykdlb21Db3VudHMsCiAgICAgICAgICAgICAgICBtYXRlcmlhbExpYnJhcnlJbmRpY2VzOiB0aGlzLm1hdGVyaWFsTGlicmFyeUluZGljZXMsCiAgICAgICAgICAgICAgICBzdWJHZW9tTWF0ZXJpYWxJbmRpY2VzOiB0aGlzLnN1Ykdlb21NYXRlcmlhbEluZGljZXMsCiAgICAgICAgICAgICAgICBtYXRlcmlhbFN1Ykdlb21zOiB0aGlzLm1hdGVyaWFsU3ViR2VvbXMsCiAgICAgICAgICAgIH07CiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7CiAgICAgICAgfQogICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8KICAgICAgICAvLyBQZXJzaXN0ZW5jZQogICAgICAgIC8qKgogICAgICAgICAqIFNldHMgc3RhdGUgb2YgY3VycmVudCBnZW9tZXRyeShJbmNsdWRpbmcgbGluZSBzZWdtZW50cykgdXNpbmcgYSBiaW5hcnkgcmVhZGVyIG9iamVjdC4KICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSB7QmluUmVhZGVyfSByZWFkZXIgLSBUaGUgcmVhZGVyIHZhbHVlLgogICAgICAgICAqIEBwYXJhbSB7UmVjb3JkPHN0cmluZywgdW5rbm93bj59IGNvbnRleHQgLSBUaGUgY29udGV4dCB2YWx1ZS4KICAgICAgICAgKi8KICAgICAgICByZWFkQmluYXJ5KHJlYWRlciwgY29udGV4dCkgewogICAgICAgICAgICBzdXBlci5sb2FkQmFzZUdlb21CaW5hcnkocmVhZGVyLCBjb250ZXh0KTsKICAgICAgICAgICAgY29uc3QgZ2VvbUNvdW50c0J5VHlwZSA9IHJlYWRlci5sb2FkVUludDMyQXJyYXkoMyk7CiAgICAgICAgICAgIHRoaXMub2Zmc2V0c1snVFJJQU5HTEVTJ10gPSAwOwogICAgICAgICAgICB0aGlzLmNvdW50c1snVFJJQU5HTEVTJ10gPSBnZW9tQ291bnRzQnlUeXBlWzBdOwogICAgICAgICAgICB0aGlzLm9mZnNldHNbJ0xJTkVTJ10gPSBnZW9tQ291bnRzQnlUeXBlWzBdOwogICAgICAgICAgICB0aGlzLmNvdW50c1snTElORVMnXSA9IGdlb21Db3VudHNCeVR5cGVbMV07CiAgICAgICAgICAgIHRoaXMub2Zmc2V0c1snUE9JTlRTJ10gPSBnZW9tQ291bnRzQnlUeXBlWzBdICsgZ2VvbUNvdW50c0J5VHlwZVsxXTsKICAgICAgICAgICAgdGhpcy5jb3VudHNbJ1BPSU5UUyddID0gZ2VvbUNvdW50c0J5VHlwZVsyXTsKICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSByZWFkZXIubG9hZFVJbnQ4KCk7CiAgICAgICAgICAgIGlmIChieXRlcyA9PSAxKQogICAgICAgICAgICAgICAgdGhpcy5pbmRpY2VzID0gcmVhZGVyLmxvYWRVSW50OEFycmF5KHVuZGVmaW5lZCwgdHJ1ZSk7CiAgICAgICAgICAgIGVsc2UgaWYgKGJ5dGVzID09IDIpCiAgICAgICAgICAgICAgICB0aGlzLmluZGljZXMgPSByZWFkZXIubG9hZFVJbnQxNkFycmF5KHVuZGVmaW5lZCwgdHJ1ZSk7CiAgICAgICAgICAgIGVsc2UgaWYgKGJ5dGVzID09IDQpCiAgICAgICAgICAgICAgICB0aGlzLmluZGljZXMgPSByZWFkZXIubG9hZFVJbnQzMkFycmF5KHVuZGVmaW5lZCwgdHJ1ZSk7CiAgICAgICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogICAgICAgICAgICAvLyBUUklBTkdMRVMgc3ViZ2VvbXMKICAgICAgICAgICAgY29uc3QgYnl0ZXNNZXNoU3ViR2VvbXMgPSByZWFkZXIubG9hZFVJbnQ4KCk7CiAgICAgICAgICAgIGxldCBzdWJHZW9tQ291bnRzTWVzaDsKICAgICAgICAgICAgaWYgKGJ5dGVzTWVzaFN1Ykdlb21zID09IDEpCiAgICAgICAgICAgICAgICBzdWJHZW9tQ291bnRzTWVzaCA9IHJlYWRlci5sb2FkVUludDhBcnJheSgpOwogICAgICAgICAgICBlbHNlIGlmIChieXRlc01lc2hTdWJHZW9tcyA9PSAyKQogICAgICAgICAgICAgICAgc3ViR2VvbUNvdW50c01lc2ggPSByZWFkZXIubG9hZFVJbnQxNkFycmF5KCk7CiAgICAgICAgICAgIGVsc2UgaWYgKGJ5dGVzTWVzaFN1Ykdlb21zID09IDQpCiAgICAgICAgICAgICAgICBzdWJHZW9tQ291bnRzTWVzaCA9IHJlYWRlci5sb2FkVUludDMyQXJyYXkoKTsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignc3ViR2VvbU9mZnNldHMgdW5kZWZpbmVkJyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3Qgc3ViR2VvbU9mZnNldHNNZXNoID0gbmV3IFVpbnQzMkFycmF5KHN1Ykdlb21Db3VudHNNZXNoLmxlbmd0aCk7CiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwOwogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1Ykdlb21Db3VudHNNZXNoLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgICAgICBzdWJHZW9tT2Zmc2V0c01lc2hbaV0gPSBvZmZzZXQ7CiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc3ViR2VvbUNvdW50c01lc2hbaV07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5zdWJHZW9tT2Zmc2V0c1snVFJJQU5HTEVTJ10gPSBzdWJHZW9tT2Zmc2V0c01lc2g7CiAgICAgICAgICAgIHRoaXMuc3ViR2VvbUNvdW50c1snVFJJQU5HTEVTJ10gPSBzdWJHZW9tQ291bnRzTWVzaDsKICAgICAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCiAgICAgICAgICAgIC8vIExJTkVTIHN1Ymdlb21zCiAgICAgICAgICAgIGNvbnN0IGJ5dGVzTGluZXNTdWJHZW9tcyA9IHJlYWRlci5sb2FkVUludDgoKTsKICAgICAgICAgICAgbGV0IHN1Ykdlb21Db3VudHNMaW5lczsKICAgICAgICAgICAgaWYgKGJ5dGVzTGluZXNTdWJHZW9tcyA9PSAxKQogICAgICAgICAgICAgICAgc3ViR2VvbUNvdW50c0xpbmVzID0gcmVhZGVyLmxvYWRVSW50OEFycmF5KCk7CiAgICAgICAgICAgIGVsc2UgaWYgKGJ5dGVzTGluZXNTdWJHZW9tcyA9PSAyKQogICAgICAgICAgICAgICAgc3ViR2VvbUNvdW50c0xpbmVzID0gcmVhZGVyLmxvYWRVSW50MTZBcnJheSgpOwogICAgICAgICAgICBlbHNlIGlmIChieXRlc0xpbmVzU3ViR2VvbXMgPT0gNCkKICAgICAgICAgICAgICAgIHN1Ykdlb21Db3VudHNMaW5lcyA9IHJlYWRlci5sb2FkVUludDMyQXJyYXkoKTsKICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignc3ViR2VvbU9mZnNldHMgdW5kZWZpbmVkJyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY29uc3Qgc3ViR2VvbU9mZnNldHNMaW5lcyA9IG5ldyBVaW50MzJBcnJheShzdWJHZW9tQ291bnRzTGluZXMubGVuZ3RoKTsKICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJHZW9tQ291bnRzTGluZXMubGVuZ3RoOyBpKyspIHsKICAgICAgICAgICAgICAgIHN1Ykdlb21PZmZzZXRzTGluZXNbaV0gPSBvZmZzZXQ7CiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gc3ViR2VvbUNvdW50c0xpbmVzW2ldOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuc3ViR2VvbU9mZnNldHNbJ0xJTkVTJ10gPSBzdWJHZW9tT2Zmc2V0c0xpbmVzOwogICAgICAgICAgICB0aGlzLnN1Ykdlb21Db3VudHNbJ0xJTkVTJ10gPSBzdWJHZW9tQ291bnRzTGluZXM7CiAgICAgICAgICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogICAgICAgICAgICAvLyBQT0lOVFMgc3ViZ2VvbXMKICAgICAgICAgICAgY29uc3QgbnVtUG9pbnRzU3ViR2VvbXMgPSByZWFkZXIubG9hZFVJbnQzMigpOwogICAgICAgICAgICBjb25zdCBzdWJHZW9tT2Zmc2V0c1BvaW50cyA9IG5ldyBVaW50MzJBcnJheShudW1Qb2ludHNTdWJHZW9tcyk7CiAgICAgICAgICAgIGNvbnN0IHN1Ykdlb21Db3VudHNQb2ludHMgPSBuZXcgVWludDhBcnJheShudW1Qb2ludHNTdWJHZW9tcyk7CiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtUG9pbnRzU3ViR2VvbXM7IGkrKykgewogICAgICAgICAgICAgICAgc3ViR2VvbU9mZnNldHNQb2ludHNbaV0gPSBvZmZzZXQ7CiAgICAgICAgICAgICAgICBzdWJHZW9tQ291bnRzUG9pbnRzW2ldID0gMTsKICAgICAgICAgICAgICAgIG9mZnNldCsrOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuc3ViR2VvbU9mZnNldHNbJ1BPSU5UUyddID0gc3ViR2VvbU9mZnNldHNQb2ludHM7CiAgICAgICAgICAgIHRoaXMuc3ViR2VvbUNvdW50c1snUE9JTlRTJ10gPSBzdWJHZW9tQ291bnRzUG9pbnRzOwogICAgICAgICAgICBpZiAoY29udGV4dC52ZXJzaW9uc1snemVhLWVuZ2luZSddLmNvbXBhcmUoWzMsIDExLCAwXSkgPiAwKSB7CiAgICAgICAgICAgICAgICAvLyBQb2ludHMgc3ViLWdlb21zIHdlcmUgbm90IGJlaW5nIGV4cG9ydGVkIGJlZm9yZSB0aGlzIHJlbGVhc2UuCiAgICAgICAgICAgICAgICB0aGlzLm51bVN1Ykdlb21zID0gc3ViR2VvbUNvdW50c01lc2gubGVuZ3RoICsgc3ViR2VvbUNvdW50c0xpbmVzLmxlbmd0aCArIG51bVBvaW50c1N1Ykdlb21zOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgdGhpcy5udW1TdWJHZW9tcyA9IHN1Ykdlb21Db3VudHNNZXNoLmxlbmd0aCArIHN1Ykdlb21Db3VudHNMaW5lcy5sZW5ndGg7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCiAgICAgICAgICAgIC8vIE1hdGVyaWFscwogICAgICAgICAgICBjb25zdCBudW1NYXRlcmlhbHMgPSByZWFkZXIubG9hZFVJbnQzMigpOwogICAgICAgICAgICBpZiAobnVtTWF0ZXJpYWxzID4gMCkgewogICAgICAgICAgICAgICAgdGhpcy5tYXRlcmlhbExpYnJhcnlJbmRpY2VzID0gcmVhZGVyLmxvYWRVSW50MzJBcnJheShudW1NYXRlcmlhbHMpOwogICAgICAgICAgICAgICAgdGhpcy5zdWJHZW9tTWF0ZXJpYWxJbmRpY2VzID0gcmVhZGVyLmxvYWRVSW50OEFycmF5KHRoaXMubnVtU3ViR2VvbXMpOwogICAgICAgICAgICAgICAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCiAgICAgICAgICAgICAgICAvLyBNYXRlcmlhbCBHcm91cHMKICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwOwogICAgICAgICAgICAgICAgbGV0IGN1cnJNYXRlcmlhbCA9IC05OTsKICAgICAgICAgICAgICAgIGxldCBjdXJyTWF0ZXJpYWxTdWJHZW9tID0gbnVsbDsKICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5udW1TdWJHZW9tczsgaSsrKSB7CiAgICAgICAgICAgICAgICAgICAgbGV0IGtleTsKICAgICAgICAgICAgICAgICAgICBsZXQgc3ViR2VvbU9mZnNldCA9IDA7CiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCB0aGlzLnN1Ykdlb21Db3VudHMuVFJJQU5HTEVTLmxlbmd0aCkgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0ZXJpYWxTdWJHZW9tcy5UUklBTkdMRVMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGVyaWFsU3ViR2VvbXMuVFJJQU5HTEVTID0gW107CiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9ICdUUklBTkdMRVMnOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpIDwgdGhpcy5zdWJHZW9tQ291bnRzLlRSSUFOR0xFUy5sZW5ndGggKyB0aGlzLnN1Ykdlb21Db3VudHMuTElORVMubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN1Ykdlb21PZmZzZXQgPSB0aGlzLnN1Ykdlb21Db3VudHMuVFJJQU5HTEVTLmxlbmd0aDsKICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gJ0xJTkVTJzsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hdGVyaWFsU3ViR2VvbXMuTElORVMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGVyaWFsU3ViR2VvbXMuTElORVMgPSBbXTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHN1Ykdlb21PZmZzZXQgPSB0aGlzLnN1Ykdlb21Db3VudHMuVFJJQU5HTEVTLmxlbmd0aCArIHRoaXMuc3ViR2VvbUNvdW50cy5MSU5FUy5sZW5ndGg7CiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9ICdQT0lOVFMnOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubWF0ZXJpYWxTdWJHZW9tcy5QT0lOVFMpCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGVyaWFsU3ViR2VvbXMuUE9JTlRTID0gW107CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGVyaWFsSWQgPSB0aGlzLnN1Ykdlb21NYXRlcmlhbEluZGljZXNbaV07CiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJNYXRlcmlhbCAhPSBtYXRlcmlhbElkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJNYXRlcmlhbCA9IG1hdGVyaWFsSWQ7CiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHN1Ykdlb21NYXRlcmlhbEluZGljZXMgaXMgVWludDhBcnJheSwgYW5kIDAgbWVhbnMgbm8gY3VzdG9tCiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1hdGVyaWFsIGlzIGFzc2lnbmVkIHRvIHRoZSBzdWJHZW9tLgogICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCAxIHRvIGdldCB0aGUgYWN0dWFsIG1hdGVyaWFsIGlkLgogICAgICAgICAgICAgICAgICAgICAgICBjdXJyTWF0ZXJpYWxTdWJHZW9tID0gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxJZDogbWF0ZXJpYWxJZCAtIDEsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogMCwKICAgICAgICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCB0aGlzLm51bVN1Ykdlb21zOyBpKyspIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyTWF0ZXJpYWwgIT0gdGhpcy5zdWJHZW9tTWF0ZXJpYWxJbmRpY2VzW2ldKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHdlIGdldCB0byB0aGUgZW5kIG9nIHRoaXMgZ2VvbSB0eXBlIChlLmcgLlRSSUFOR0xFUykKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGEgbmV3IHN1Ymdlb20uCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSAtIHN1Ykdlb21PZmZzZXQgPT0gdGhpcy5zdWJHZW9tQ291bnRzW2tleV0ubGVuZ3RoKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yY2UgdGhlIG1hdGVyaWFsIGluZGV4IHRvIGJlIHJlc2V0IG9uIGxpbmUgMTYyIGFib3ZlLgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJNYXRlcmlhbCA9IC05OTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJNYXRlcmlhbFN1Ykdlb20uY291bnQgKz0gdGhpcy5zdWJHZW9tQ291bnRzW2tleV1baSAtIHN1Ykdlb21PZmZzZXRdOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCArPSBjdXJyTWF0ZXJpYWxTdWJHZW9tLmNvdW50OwogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGVyaWFsU3ViR2VvbXNba2V5XS5wdXNoKGN1cnJNYXRlcmlhbFN1Ykdlb20pOwogICAgICAgICAgICAgICAgICAgICAgICBpLS07CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgdGhpcy5tYXRlcmlhbFN1Ykdlb21zWydUUklBTkdMRVMnXSA9IFsKICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGVyaWFsSWQ6IC0xLAogICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDAsCiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBnZW9tQ291bnRzQnlUeXBlWzBdLAogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICBdOwogICAgICAgICAgICAgICAgaWYgKGdlb21Db3VudHNCeVR5cGVbMV0gPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRlcmlhbFN1Ykdlb21zWydMSU5FUyddID0gWwogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbElkOiAtMSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogZ2VvbUNvdW50c0J5VHlwZVswXSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBnZW9tQ291bnRzQnlUeXBlWzFdLAogICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgIF07CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAoZ2VvbUNvdW50c0J5VHlwZVsyXSA+IDApIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGVyaWFsU3ViR2VvbXNbJ1BPSU5UUyddID0gWwogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbElkOiAtMSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogZ2VvbUNvdW50c0J5VHlwZVswXSArIGdlb21Db3VudHNCeVR5cGVbMV0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogZ2VvbUNvdW50c0J5VHlwZVsyXSwKICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICBdOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuZW1pdCgnZ2VvbURhdGFDaGFuZ2VkJywge30pOwogICAgICAgIH0KICAgIH0KCiAgICAvKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi8KICAgIC8vIGtleSwgdG9jLCBnZW9tSW5kZXhPZmZzZXQsIGdlb21zUmFuZ2UsIGlzTW9iaWxlRGV2aWNlLCBidWZmZXJTbGljZSwgZ2VuQnVmZmVyc09wdHMsIGNvbnRleHQKICAgIGNvbnN0IHBhcnNlR2VvbXNCaW5hcnkgPSAoZGF0YSwgY2FsbGJhY2spID0+IHsKICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluCiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YS5jb250ZXh0LnZlcnNpb25zKSB7CiAgICAgICAgICAgIGNvbnN0IHYgPSBkYXRhLmNvbnRleHQudmVyc2lvbnNba2V5XTsKICAgICAgICAgICAgY29uc3QgdmVyc2lvbiA9IG5ldyBWZXJzaW9uKCcnKTsKICAgICAgICAgICAgdmVyc2lvbi5tYWpvciA9IHYubWFqb3I7CiAgICAgICAgICAgIHZlcnNpb24ubWlub3IgPSB2Lm1pbm9yOwogICAgICAgICAgICB2ZXJzaW9uLnBhdGNoID0gdi5wYXRjaDsKICAgICAgICAgICAgdmVyc2lvbi5icmFuY2ggPSB2LmJyYW5jaDsKICAgICAgICAgICAgZGF0YS5jb250ZXh0LnZlcnNpb25zW2tleV0gPSB2ZXJzaW9uOwogICAgICAgIH0KICAgICAgICBjb25zdCBnZW9tRGF0YXMgPSBbXTsKICAgICAgICBjb25zdCBieXRlT2Zmc2V0ID0gZGF0YS5ieXRlT2Zmc2V0OwogICAgICAgIC8vIGNvbnNvbGUubG9nKCdieXRlT2Zmc2V0OicgKyBieXRlT2Zmc2V0KQogICAgICAgIGNvbnN0IHRyYW5zZmVyYWJsZXMgPSBbXTsKICAgICAgICBmb3IgKGxldCBpID0gZGF0YS5nZW9tc1JhbmdlWzBdOyBpIDwgZGF0YS5nZW9tc1JhbmdlWzFdOyBpKyspIHsKICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEJpblJlYWRlcihkYXRhLmJ1ZmZlclNsaWNlLCBkYXRhLnRvY1tpXSAtIGJ5dGVPZmZzZXQsIGRhdGEuaXNNb2JpbGVEZXZpY2UpOwogICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSByZWFkZXIubG9hZFN0cigpOwogICAgICAgICAgICBjb25zdCBwb3MgPSByZWFkZXIucG9zKCk7CiAgICAgICAgICAgIC8vIGNvbnN0IG5hbWUgPSByZWFkZXIubG9hZFN0cigpCiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKAogICAgICAgICAgICAvLyAgIGkgKwogICAgICAgICAgICAvLyAgICAgJzonICsKICAgICAgICAgICAgLy8gICAgIGJ5dGVPZmZzZXQgKwogICAgICAgICAgICAvLyAgICAgJyBjbGFzc05hbWU6JyArCiAgICAgICAgICAgIC8vICAgICBjbGFzc05hbWUgKwogICAgICAgICAgICAvLyAgICAgJyBuYW1lOicgKwogICAgICAgICAgICAvLyAgICAgbmFtZSAvKiArICIgcG9zOiIgKyAoZGF0YS50b2NbaV0gLSBieXRlT2Zmc2V0KSArICIgYnVmZmVyU2xpY2UuYnl0ZUxlbmd0aDoiICsgIGJ1ZmZlclNsaWNlLmJ5dGVMZW5ndGgqLwogICAgICAgICAgICAvLyApCiAgICAgICAgICAgIGxldCBnZW9tOwogICAgICAgICAgICBzd2l0Y2ggKGNsYXNzTmFtZSkgewogICAgICAgICAgICAgICAgY2FzZSAnUG9pbnRzJzoKICAgICAgICAgICAgICAgICAgICBnZW9tID0gbmV3IFBvaW50cygpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAnTGluZXMnOgogICAgICAgICAgICAgICAgICAgIGdlb20gPSBuZXcgTGluZXMoKTsKICAgICAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICAgIGNhc2UgJ01lc2gnOgogICAgICAgICAgICAgICAgICAgIGdlb20gPSBuZXcgTWVzaCgpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgY2FzZSAnQ29tcG91bmRHZW9tJzoKICAgICAgICAgICAgICAgICAgICBnZW9tID0gbmV3IENvbXBvdW5kR2VvbUxvYWRlcigpOwogICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIEdlb20gdHlwZTonICsgY2xhc3NOYW1lKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgcmVhZGVyLnNlZWsocG9zKTsgLy8gUmVzZXQgdGhlIHBvaW50ZXIgdG8gdGhlIHN0YXJ0IG9mIHRoZSBpdGVtIGRhdGEuCiAgICAgICAgICAgICAgICBnZW9tLnJlYWRCaW5hcnkocmVhZGVyLCBkYXRhLmNvbnRleHQpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIGxvYWRpbmc6JyArIGdlb20ubmFtZSArICdcbjonICsgZSk7CiAgICAgICAgICAgICAgICBnZW9tRGF0YXMucHVzaCh7fSk7CiAgICAgICAgICAgICAgICBjb250aW51ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBnZW9tQnVmZmVycyA9IGdlb20uZ2VuQnVmZmVycyhkYXRhLmdlbkJ1ZmZlcnNPcHRzKTsKICAgICAgICAgICAgaWYgKGdlb21CdWZmZXJzLmluZGljZXMpCiAgICAgICAgICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2goZ2VvbUJ1ZmZlcnMuaW5kaWNlcy5idWZmZXIpOwogICAgICAgICAgICBmb3IgKGNvbnN0IGF0dHJOYW1lIGluIGdlb21CdWZmZXJzLmF0dHJCdWZmZXJzKSB7CiAgICAgICAgICAgICAgICAvLyBOb3RlOiBUaGUgdHlwZSB2YWx1ZSBhc3NpZ25lZCB0byB0aGUgYXR0cmlidXRlIGNhbgogICAgICAgICAgICAgICAgLy8gbm90IGJlIHRyYW5zZmVycmVkIGJhY2sgdG8gdGhlIG1haW4gdGhyZWFkLiBDb252ZXJ0IHRvCiAgICAgICAgICAgICAgICAvLyB0aGUgdHlwZSBuYW1lIGhlcmUgYW5kIHNlbmQgYmFjayBhcyBhIHN0cmluZy4KICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJEYXRhID0gZ2VvbUJ1ZmZlcnMuYXR0ckJ1ZmZlcnNbYXR0ck5hbWVdOwogICAgICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGF0dHJEYXRhLnZhbHVlcy5idWZmZXIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChnZW9tQnVmZmVycy52ZXJ0ZXhOZWlnaGJvcnMpIHsKICAgICAgICAgICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChnZW9tQnVmZmVycy52ZXJ0ZXhOZWlnaGJvcnMuYnVmZmVyKTsKICAgICAgICAgICAgfQogICAgICAgICAgICAvLyBUcmFuc2ZlciB0aGUgYmJveCBwb2ludCBidWZmZXJzLgogICAgICAgICAgICBjb25zdCBiYm94ID0gZ2VvbS5nZXRCb3VuZGluZ0JveCgpOwogICAgICAgICAgICB0cmFuc2ZlcmFibGVzLnB1c2goYmJveC5wMC5fX2RhdGEuYnVmZmVyKTsKICAgICAgICAgICAgdHJhbnNmZXJhYmxlcy5wdXNoKGJib3gucDEuX19kYXRhLmJ1ZmZlcik7CiAgICAgICAgICAgIGdlb21EYXRhcy5wdXNoKHsKICAgICAgICAgICAgICAgIG5hbWU6IGdlb20ubmFtZSwKICAgICAgICAgICAgICAgIHR5cGU6IGNsYXNzTmFtZSwKICAgICAgICAgICAgICAgIGdlb21CdWZmZXJzLAogICAgICAgICAgICAgICAgYmJveCwKICAgICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIGNhbGxiYWNrKHsKICAgICAgICAgICAgdGFza0lkOiBkYXRhLnRhc2tJZCwKICAgICAgICAgICAgZ2VvbUxpYnJhcnlJZDogZGF0YS5nZW9tTGlicmFyeUlkLAogICAgICAgICAgICBnZW9tRmlsZUlEOiBkYXRhLmdlb21GaWxlSUQsCiAgICAgICAgICAgIGdlb21JbmRleE9mZnNldDogZGF0YS5nZW9tSW5kZXhPZmZzZXQsCiAgICAgICAgICAgIGdlb21zUmFuZ2U6IGRhdGEuZ2VvbXNSYW5nZSwKICAgICAgICAgICAgZ2VvbURhdGFzLAogICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpOwogICAgfTsKCiAgICBjb25zdCBoYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gKHNyY0RhdGEsIHBvc3RNZXNzYWdlKSB7CiAgICAgIHBhcnNlR2VvbXNCaW5hcnkoc3JjRGF0YSwgKHJlc3VsdERhdGEsIHRyYW5zZmVyYWJsZXMpID0+IHsKICAgICAgICBwb3N0TWVzc2FnZShyZXN1bHREYXRhLCB0cmFuc2ZlcmFibGVzKTsKICAgICAgfSk7CiAgICB9OwoKICAgIC8qIE5PREVfU1RBUlQKICAgIGV4cG9ydCB7IGhhbmRsZU1lc3NhZ2UgfQogICAgLy8gTk9ERV9FTFNFICovCiAgICBzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkgewogICAgICBpZiAoIWV2ZW50LmRhdGEpIHsKICAgICAgICAvLyBOb3RlOiB3ZSBzZWUgdGhpcyBvY2N1ciB3aGVuIGxvYWRpbmcgb25lIGxhcmdlIGFzc2V0IG1hbnkgdGltZXMuCiAgICAgICAgLy8gTGlrZSB3aGVuIGxvYWRpbmcgdGhlIHBvcnRhZmlsLgogICAgICAgIC8vIEl0IG1heSBiZSBkdWUgdG8gbWVtb3J5IGlzc3VlcywgYnV0IGl0cyBub3QgY2xlYXIuCiAgICAgICAgY29uc29sZS53YXJuKCdHZW9tTGlicmFyeSB3b3JrZXIucG9zdE1lc3NhZ2UgZmFpbGVkLiBkYXRhIHdhcyBsb3N0IG9uIHRoZSB3YXkgdG8gdGhlIHdlYiB3b3JrZXIuJyk7CiAgICAgICAgcmV0dXJuCiAgICAgIH0KICAgICAgaGFuZGxlTWVzc2FnZShldmVudC5kYXRhLCBzZWxmLnBvc3RNZXNzYWdlKTsKICAgIH07CiAgICAvLyBOT0RFX0VORAoKfSkoKTsKCg==", null, false);
  var _I = new class extends EA {
    constructor() {
      super(true);
    }
    constructWorker() {
      const A3 = new TI();
      return Promise.resolve(A3);
    }
  }();
  var PI = 0;
  var OI = class extends V {
    constructor(A3) {
      super(), this.listenerIDs = {}, this.streamInfos = {}, this.genBuffersOpts = {}, this.numGeoms = -1, this.geoms = [], this.basePath = "", this.loadedCount = 0, this.assetItem = A3, PI++;
    }
    isLoaded() {
      return this.numGeoms == -1 || this.loadedCount == this.numGeoms;
    }
    loadGeomFile(A3, g3 = false) {
      return g3 && FA.incrementWorkload(1), new Promise((I3) => {
        const C3 = this.basePath + A3 + ".zgeoms";
        FA.loadFile("archive", C3, false).then((A4) => {
          const i3 = A4[Object.keys(A4)[0]], e3 = this.on("streamFileParsed", (A5) => {
            A5.geomFileID == C3 && (g3 && FA.incrementWorkDone(1), this.removeListenerById("streamFileParsed", e3), I3());
          });
          this.readBinaryBuffer(C3, i3.buffer, this.loadContext);
        });
      });
    }
    loadGeomFilesStream(A3, g3, I3) {
      const C3 = A3.numGeomsPerFile.length;
      FA.incrementWorkload(C3), this.numGeoms = A3.numGeoms, this.basePath = g3, this.loadContext = I3;
      for (let A4 = 0; A4 < C3; A4++)
        this.loadGeomFile(A4, false);
    }
    setGenBufferOption(A3, g3) {
      this.genBuffersOpts[A3] = g3;
    }
    setNumGeoms(A3) {
      this.numGeoms = A3;
    }
    getNumGeoms() {
      return this.numGeoms;
    }
    getGeom(A3) {
      return A3 >= this.geoms.length ? null : this.geoms[A3];
    }
    readBinaryBuffer(A3, I3, C3) {
      const i3 = new YA(I3, 0, g.isMobileDevice), e3 = i3.loadUInt32(), t3 = i3.loadUInt32();
      if (this.streamInfos[A3] = {total: e3, done: 0}, e3 == 0) {
        const g3 = new z(A3, 0);
        return void this.emit("streamFileParsed", g3);
      }
      this.numGeoms == -1 && (this.numGeoms = e3);
      const B3 = i3.loadUInt32Array(e3), o3 = I3.byteLength > 2e7;
      if (PI > 1 && !o3) {
        const g3 = [0, e3], o4 = 0;
        _I.addTask({geomFileID: A3, toc: B3, byteOffset: o4, geomIndexOffset: t3, geomsRange: g3, isMobileDevice: i3.isMobileDevice, bufferSlice: I3, genBuffersOpts: this.genBuffersOpts, context: {versions: C3.versions}}, [I3]).then((A4) => {
          this.__receiveGeomDatas(A4);
        });
      } else {
        const g3 = 2e6;
        let o4 = 0;
        for (; o4 < e3; ) {
          const s3 = B3[o4];
          let a3, l3, n3 = 0, d3 = o4;
          for (; d3 < e3 && n3 < g3; )
            d3++, n3 = B3[d3] - s3;
          d3 >= e3 ? (a3 = [o4, e3], l3 = I3.byteLength) : (a3 = [o4, d3], l3 = B3[a3[1]]);
          const h3 = o4 == 0 && d3 == e3, c3 = h3 ? 0 : B3[a3[0]], r3 = h3 ? I3 : I3.slice(s3, l3);
          o4 = d3, _I.addTask({geomFileID: A3, toc: B3, byteOffset: c3, geomIndexOffset: t3, geomsRange: a3, isMobileDevice: i3.isMobileDevice, bufferSlice: r3, genBuffersOpts: this.genBuffersOpts, context: {versions: C3.versions}}, [r3]).then((A4) => {
            this.__receiveGeomDatas(A4);
          });
        }
      }
    }
    __receiveGeomDatas(A3) {
      const {geomFileID: g3, geomDatas: I3, geomIndexOffset: C3, geomsRange: i3} = A3, e3 = C3 + i3[0], t3 = [e3, C3 + i3[1]];
      for (let A4 = 0; A4 < I3.length; A4++) {
        const g4 = I3[A4];
        if (!g4.type)
          continue;
        let C4;
        switch (g4.type) {
          case "Points":
            C4 = new Ng(g4);
            break;
          case "Lines":
            C4 = new Jg(g4);
            break;
          case "Mesh":
          case "Plane":
          case "Sphere":
          case "Cone":
            C4 = new Dg(g4);
            break;
          case "CompoundGeom":
            C4 = new Mg(g4, this.assetItem.getMaterialLibrary());
            break;
          default:
            throw new Error("Unsupported Geom type:");
        }
        this.geoms[e3 + A4] = C4;
      }
      const B3 = new M(t3);
      this.emit("rangeLoaded", B3);
      const o3 = t3[1] - t3[0], s3 = this.streamInfos[g3];
      if (s3.done += o3, s3.done == s3.total) {
        const A4 = new z(g3, s3.done);
        this.emit("streamFileParsed", A4);
      }
      return this.loadedCount += o3, this.loadedCount == this.numGeoms && this.emit("loaded"), this.loadedCount == this.numGeoms;
    }
    toJSON() {
      return {numGeoms: this.geoms.length};
    }
    toString() {
      return JSON.stringify(this.toJSON(), null, 2);
    }
    loadMetadata(A3, I3) {
      const C3 = new YA(A3.buffer, 0, g.isMobileDevice), i3 = C3.loadUInt32Array();
      for (let A4 = 0; A4 < i3.length; A4++)
        try {
          const g3 = this.geoms[A4];
          g3 || console.warn("Error loading metadata for geom that was not yet loaded: ", A4), g3 instanceof Mg && (C3.seek(i3[A4]), g3.loadMetadata(C3, I3));
        } catch (g3) {
          console.warn("Error loading geom metadata: ", A4);
        }
    }
  };
  var jI = class extends V {
    constructor(A3 = "MaterialLibrary") {
      super(), this.__images = {}, this.materials = [], this.__materialsMap = {}, this.name = "", this.__name = A3;
    }
    clear() {
      this.__images = {}, this.materials = [], this.__materialsMap = {};
    }
    getPath() {
      return [this.__name];
    }
    resolvePath(A3, g3 = 0) {
      return null;
    }
    getNumMaterials() {
      return this.materials.length;
    }
    getMaterials() {
      return this.materials;
    }
    getMaterialNames() {
      const A3 = [];
      return this.materials.forEach((g3) => {
        A3.push(g3.getName());
      }), A3;
    }
    hasMaterial(A3) {
      return A3 in this.__materialsMap;
    }
    addMaterial(A3) {
      A3.setOwner(this), this.__materialsMap[A3.getName()] = this.materials.length, this.materials.push(A3);
    }
    getMaterial(A3, g3 = true) {
      const I3 = this.__materialsMap[A3];
      if (I3 == null && g3)
        throw new Error("Material:" + A3 + " not found in library:" + this.getMaterialNames());
      return this.materials[I3];
    }
    hasImage(A3) {
      return A3 in this.__images;
    }
    addImage(A3) {
      A3.setOwner(this), this.__images[A3.getName()] = A3;
    }
    getImage(A3, g3 = true) {
      const I3 = this.__images[A3];
      if (!I3 && g3)
        throw new Error("Image:" + A3 + " not found in library:" + this.getImageNames());
      return I3;
    }
    getImageNames() {
      const A3 = [];
      for (const g3 in this.__images)
        A3.push(g3);
      return A3;
    }
    load(A3) {
      const g3 = new XMLHttpRequest();
      g3.open("GET", A3, true), g3.ontimeout = () => {
        throw new Error("The request for " + A3 + " timed out.");
      }, g3.onload = () => {
        g3.readyState === 4 && (g3.status === 200 ? this.fromJSON(JSON.parse(g3.responseText)) : console.warn(g3.statusText));
      }, g3.send(null);
    }
    toJSON(A3 = {}) {
      return {numMaterials: this.getNumMaterials()};
    }
    fromJSON(A3, g3 = {}) {
      for (const g4 in A3.textures) {
        const I3 = new eI(g4);
        I3.fromJSON(A3.textures[g4]), this.__images[g4] = I3;
      }
      for (const g4 in A3.materials) {
        const I3 = new XI(g4);
        I3.fromJSON(A3.materials[g4]), this.addMaterial(I3);
      }
    }
    readBinary(A3, g3) {
      this.name = A3.loadStr();
      const I3 = A3.loadUInt32();
      for (let C4 = 0; C4 < I3; C4++) {
        const I4 = A3.loadStr(), C5 = e.constructClass(I4);
        C5.readBinary(A3, g3), this.__images[C5.getName()] = C5;
      }
      const C3 = A3.loadUInt32();
      if (C3 > 0) {
        const I4 = A3.loadUInt32Array(C3);
        for (let i3 = 0; i3 < C3; i3++) {
          let C4;
          switch (A3.loadStr()) {
            case "StandardMaterial":
            case "TransparentMaterial":
            case "StandardSurfaceShader":
              C4 = e.constructClass("StandardSurfaceMaterial");
              break;
            case "SimpleSurfaceShader":
            case "SimpleSurfaceMaterial":
              C4 = e.constructClass("SimpleSurfaceMaterial");
              break;
            case "PointsShader":
            case "PointsMaterial":
              C4 = e.constructClass("PointsMaterial");
              break;
            case "FatPointsShader":
            case "FatPointsMaterial":
              C4 = e.constructClass("FatPointsMaterial");
              break;
            case "LinesShader":
            case "LinesMaterial":
              C4 = e.constructClass("LinesMaterial");
              break;
            default:
              C4 = new XI("");
          }
          A3.seek(I4[i3]), C4.readBinary(A3, g3), this.materials[i3] = C4, this.__materialsMap[C4.getName()] = i3;
        }
      }
      this.emit("loaded");
    }
    toString() {
      return JSON.stringify(this.toJSON(), null, 2);
    }
  };
  var qI = (A3) => {
    switch (A3.toLowerCase()) {
      case "millimeters":
        return 1e-3;
      case "centimeters":
        return 0.01;
      case "decimeters":
        return 0.1;
      case "meters":
        return 1;
      case "kilometers":
        return 1e3;
      case "inches":
        return 0.0254;
      case "feet":
        return 0.3048;
      case "miles":
        return 1609.34;
    }
    return 1;
  };
  var $I = class extends ag {
    constructor(A3 = "") {
      super(A3), this.geomLibrary = new OI(this), this.materialLibrary = new jI(), this.loaded = false, this.unitsScale = 1, this.units = "meters";
    }
    load(A3) {
      return Promise.reject(`This method is not implemented for this Asset Item: ${A3}`);
    }
    isLoaded() {
      return this.loaded;
    }
    getEngineDataVersion() {
      return this.engineDataVersion;
    }
    getGeometryLibrary() {
      return this.geomLibrary;
    }
    getMaterialLibrary() {
      return this.materialLibrary;
    }
    getUnitsConversion() {
      return this.unitsScale;
    }
    readBinary(A3, g3) {
      g3.assetItem = this, g3.units || (g3.units = "meters"), g3.versions["zea-engine"] || (g3.versions["zea-engine"] = new WA(A3.loadStr())), this.engineDataVersion = g3.versions["zea-engine"];
      const I3 = () => {
        this.units = A3.loadStr(), this.addParameter(new jA("FileUnits", this.units));
        const I4 = qI(this.units), C4 = qI(g3.units);
        this.unitsScale = I4 / C4, g3.units = this.units;
        const i4 = this.localXfoParam, e4 = i4.value;
        e4.sc.scaleInPlace(this.unitsScale), i4.value = e4;
      };
      let C3;
      g3.versions["zea-engine"].compare([0, 0, 6]) > 0 && I3();
      const i3 = {};
      g3.addGeomToLayer = (A4, g4) => {
        if (!i3[g4]) {
          C3 || (C3 = new ag("Layers"), this.addChild(C3, false));
          const A5 = new zI(g4);
          C3.addChild(A5, false), i3[g4] = A5;
        }
        i3[g4].addItem(A4);
      };
      const e3 = [];
      g3.resolvePath = (A4, g4, I4) => {
        if (!A4)
          throw new Error("Path not specified");
        try {
          const I5 = this.resolvePath(A4);
          g4(I5);
        } catch (C4) {
          e3.push(() => {
            try {
              const I5 = this.resolvePath(A4);
              g4(I5);
            } catch (A5) {
              if (!I4)
                throw A5;
              I4(A5);
            }
          });
        }
      }, g3.addPLCB = (A4) => e3.push(A4), this.materialLibrary.readBinary(A3, g3), super.readBinary(A3, g3), g3.versions["zea-engine"].compare([0, 0, 5]) >= 0 && g3.versions["zea-engine"].compare([0, 0, 7]) < 0 && I3();
      for (const A4 of e3)
        A4();
      this.loaded = true;
    }
    toJSON(A3 = {}) {
      A3.makeRelative = (A4) => {
        const g3 = this.getPath(), I3 = A4.slice(0, g3.length);
        for (let C4 = 0; C4 < I3.length - 1; C4++)
          if (I3[C4] != g3[C4])
            return console.warn("Param Path is not relative to the asset. May not be able to be resolved at load time:" + A4), A4;
        const C3 = A4.slice(g3.length - 1);
        return C3[0] = ".", C3;
      }, A3.assetItem = this;
      return super.toJSON(A3);
    }
    fromJSON(A3, g3 = {}) {
      g3 || (g3 = {}), g3.assetItem = this, g3.version == null && (g3.version = 0), g3.assetItem = this;
      const I3 = [];
      g3.resolvePath = (A4, g4) => {
        if (!A4)
          throw new Error("Path not specified");
        const C3 = this.resolvePath(A4);
        C3 ? g4(C3) : I3.push(() => {
          const I4 = this.resolvePath(A4);
          I4 ? g4(I4) : console.warn("Path unable to be resolved:" + A4);
        });
      }, g3.addPLCB = (A4) => I3.push(A4), super.fromJSON(A3, g3);
      for (const A4 of I3)
        A4();
    }
    clone(A3) {
      const g3 = new $I();
      return g3.copyFrom(this, A3), g3;
    }
    copyFrom(A3, g3) {
      this.geomLibrary = A3.geomLibrary, this.materialLibrary = A3.materialLibrary, this.loaded = A3.loaded, A3.loaded || A3.once("loaded", (I3) => {
        const C3 = A3.localXfoParam.value, i3 = this.localXfoParam.value;
        i3.sc = C3.sc.clone(), this.localXfoParam.value = i3, A3.getChildren().forEach((A4) => {
          A4 && A4 != $I && this.addChild(A4.clone(g3), false, false);
        }), this.loaded = true, this.emit("loaded", I3);
      }), super.copyFrom(A3, g3);
    }
  };
  e.register("AssetItem", $I);
  var AC = class extends V {
    constructor(A3) {
      super(), this.units = "meters", this.versions = {}, this.sdk = "", this.url = "", this.folder = "", this.camera = null, this.assetItem = null, this.resources = null, this.xrefs = {}, this.xrefLoadCallback = null, this.postLoadCallbacks = [], this.asyncCount = 0, A3 && (this.units = A3.units, this.sdk = A3.sdk, this.camera = A3.camera, this.resources = A3.resources, this.xrefs = A3.xrefs, this.xrefLoadCallback = A3.xrefLoadCallback);
    }
    incrementAsync() {
      this.asyncCount++;
    }
    decrementAsync() {
      this.asyncCount--, this.asyncCount == 0 && this.emit("done");
    }
    resolvePath(A3, g3, I3) {
      try {
        const I4 = this.assetItem.resolvePath(A3);
        g3(I4);
      } catch (C3) {
        this.postLoadCallbacks.push(() => {
          try {
            const I4 = this.assetItem.resolvePath(A3);
            g3(I4);
          } catch (A4) {
            if (!I3)
              throw new Error(A4.message);
            I3(A4);
          }
        });
      }
    }
    addPLCB(A3) {
      this.postLoadCallbacks.push(A3);
    }
    clone() {
      return new AC(this);
    }
  };
  var gC = class extends ag {
    constructor(A3, g3) {
      super(A3), this.imageParam = new OA("Image"), this.pixelsPerMeterParam = new JA("PixelsPerMeter", 1e3), this.alphaParam = new JA("Alpha", 1), this.colorParam = new xA("Color", new l(1, 1, 1)), this.alignedToCameraParam = new fA("AlignedToCamera", false), this.drawOnTopParam = new fA("DrawOnTop", false), this.fixedSizeOnscreenParam = new fA("FixedSizeOnscreen", false), this.pivotParam = new MA("Pivot", new B(0.5, 0));
      const I3 = this.addParameter(this.imageParam);
      g3 && (I3.value = g3), this.addParameter(this.pixelsPerMeterParam), this.addParameter(this.alphaParam), this.addParameter(this.colorParam), this.addParameter(this.alignedToCameraParam), this.addParameter(this.drawOnTopParam), this.addParameter(this.fixedSizeOnscreenParam), this.addParameter(this.pivotParam);
    }
  };
  e.register("BillboardItem", gC);
  var IC = class extends ag {
    constructor(A3 = "Camera") {
      super(A3), this.isOrthographicParam = new JA("isOrthographic", 0), this.fovParam = new JA("fov", 1), this.nearParam = new JA("near", 0.1), this.farParam = new JA("far", 1e3), this.focalDistanceParam = new JA("focalDistance", 5), this.viewHeight = 0, this.__orthoIntervalId = -1, this.__focusIntervalId = -1, this.addParameter(this.isOrthographicParam), this.addParameter(this.fovParam), this.addParameter(this.nearParam), this.addParameter(this.farParam), this.addParameter(this.focalDistanceParam);
      const g3 = (A4) => {
        this.emit("projectionParamChanged", A4);
      };
      this.isOrthographicParam.on("valueChanged", g3), this.fovParam.on("valueChanged", g3), this.nearParam.on("valueChanged", g3), this.farParam.on("valueChanged", g3), this.setPositionAndTarget(new o(3, 3, 1.75), new o(0, 0, 1)), this.setLensFocalLength("28mm"), this.adjustNearAndFarPlanesToFocalDist = true, this.nearDistFactor = 0.01, this.farDistFactor = 100, this.frameOnBoundingSphere = false;
    }
    getNear() {
      return this.nearParam.value;
    }
    setNear(A3) {
      this.nearParam.value = A3;
    }
    getFar() {
      return this.farParam.value;
    }
    setFar(A3) {
      this.farParam.value = A3;
    }
    getFov() {
      return this.fovParam.value;
    }
    setFov(A3) {
      this.fovParam.value = A3;
    }
    getFrustumHeight() {
      return this.viewHeight;
    }
    setFrustumHeight(A3) {
      this.viewHeight = A3, this.emit("projectionParamChanged");
    }
    setLensFocalLength(A3) {
      const g3 = {"10mm": 100.4, "11mm": 95, "12mm": 90, "14mm": 81.2, "15mm": 77.3, "17mm": 70.4, "18mm": 67.4, "19mm": 64.6, "20mm": 61.9, "24mm": 53.1, "28mm": 46.4, "30mm": 43.6, "35mm": 37.8, "45mm": 29.9, "50mm": 27, "55mm": 24.6, "60mm": 22.6, "70mm": 19.5, "75mm": 18.2, "80mm": 17.1, "85mm": 16.1, "90mm": 15.2, "100mm": 13.7, "105mm": 13, "120mm": 11.4, "125mm": 11, "135mm": 10.2, "150mm": 9.1, "170mm": 8.1, "180mm": 7.6, "210mm": 6.5, "300mm": 4.6, "400mm": 3.4, "500mm": 2.7, "600mm": 2.3, "800mm": 1.7};
      A3 in g3 ? this.fovParam.value = r.degToRad(g3[A3]) : console.warn("Camera lense focal length not supported:" + A3);
    }
    getFocalDistance() {
      return this.focalDistanceParam.value;
    }
    setFocalDistance(A3) {
      A3 < 1e-4 && console.error("Never set focal distance to zero"), this.focalDistanceParam.value = A3, this.adjustNearAndFarPlanesToFocalDist && (this.nearParam.value = A3 * this.nearDistFactor, this.farParam.value = A3 * this.farDistFactor);
    }
    isOrthographic() {
      return this.isOrthographicParam.value == 1;
    }
    setIsOrthographic(A3, g3 = 0) {
      if (this.__orthoIntervalId && clearInterval(this.__orthoIntervalId), A3 > 0.5) {
        const A4 = this.fovParam.value, g4 = this.focalDistanceParam.value;
        this.viewHeight = Math.sin(0.5 * A4) * g4 * 2;
      }
      if (g3 == 0)
        this.isOrthographicParam.value = A3;
      else {
        const I3 = Math.round(g3 / 20);
        let C3 = 0;
        const i3 = this.isOrthographicParam.value, e3 = () => {
          const g4 = r.lerp(i3, A3, C3 / I3);
          this.isOrthographicParam.value = g4, C3++, C3 <= I3 ? this.__orthoIntervalId = window.setTimeout(e3, 20) : (this.__orthoIntervalId = -1, this.emit("movementFinished"));
        };
        e3();
      }
    }
    setPositionAndTarget(A3, g3) {
      this.setFocalDistance(A3.distanceTo(g3));
      const I3 = new m();
      I3.setLookAt(A3, g3, new o(0, 0, 1)), this.globalXfoParam.value = I3, this.emit("movementFinished");
    }
    getTargetPosition() {
      const A3 = this.focalDistanceParam.value, g3 = this.globalXfoParam.value, I3 = g3.ori.getZaxis();
      return I3.scaleInPlace(-A3), I3.addInPlace(g3.tr), I3;
    }
    frameView(A3, g3) {
      const I3 = this.focalDistanceParam.value, C3 = this.fovParam.value, i3 = this.globalXfoParam.value.clone(), e3 = A3.getWidth() / A3.getHeight(), t3 = 2 * Math.atan(Math.tan(0.5 * C3) * e3);
      let s3 = I3;
      if (this.frameOnBoundingSphere) {
        const A4 = new b();
        for (const I4 of g3)
          A4.addBox3(I4.boundingBoxParam.value);
        if (!A4.isValid())
          return void console.warn("Bounding box not valid.");
        const e4 = i3.ori.getZaxis().scale(-I3), t4 = i3.tr.add(e4), B3 = A4.center().subtract(t4);
        i3.tr.addInPlace(B3), s3 = A4.size() / Math.tan(C3);
      } else {
        const A4 = [];
        if (g3.forEach((g4) => {
          g4.traverse((g5) => {
            if (!(g5 instanceof ag))
              return false;
            if (g5.disableBoundingBox)
              return false;
            if (g5 instanceof kI) {
              const I5 = g5.geomParam.value;
              if (I5) {
                const C4 = I5.getBoundingBox();
                if (C4.isValid()) {
                  const I6 = g5.geomMatParam.value;
                  return A4.push(I6.transformVec3(C4.p0)), A4.push(I6.transformVec3(new o(C4.p0.x, C4.p0.y, C4.p1.z))), A4.push(I6.transformVec3(new o(C4.p0.x, C4.p1.y, C4.p0.z))), A4.push(I6.transformVec3(new o(C4.p1.x, C4.p0.y, C4.p0.z))), A4.push(I6.transformVec3(new o(C4.p0.x, C4.p1.y, C4.p1.z))), A4.push(I6.transformVec3(new o(C4.p1.x, C4.p0.y, C4.p1.z))), A4.push(I6.transformVec3(new o(C4.p1.x, C4.p1.y, C4.p0.z))), void A4.push(I6.transformVec3(C4.p1));
                }
              }
            }
            if (g5.getNumChildren() == 0) {
              const I5 = g5.boundingBoxParam.value;
              if (I5.isValid())
                return A4.push(new o(I5.p0.x, I5.p0.y, I5.p0.z)), A4.push(new o(I5.p0.x, I5.p0.y, I5.p1.z)), A4.push(new o(I5.p0.x, I5.p1.y, I5.p0.z)), A4.push(new o(I5.p1.x, I5.p0.y, I5.p0.z)), A4.push(new o(I5.p0.x, I5.p1.y, I5.p1.z)), A4.push(new o(I5.p1.x, I5.p0.y, I5.p1.z)), A4.push(new o(I5.p1.x, I5.p1.y, I5.p0.z)), void A4.push(new o(I5.p1.x, I5.p1.y, I5.p1.z));
            }
          });
        }), A4.length == 0)
          return;
        const I4 = this.isOrthographic() ? 0 : t3 / 2, a3 = this.isOrthographic() ? 0 : C3 / 2, l3 = {};
        l3.XPos = new o(Math.cos(I4), 0, Math.sin(I4)), l3.XNeg = new o(-Math.cos(I4), 0, Math.sin(I4)), l3.YPos = new o(0, Math.cos(a3), Math.sin(a3)), l3.YNeg = new o(0, -Math.cos(a3), Math.sin(a3)), l3.ZPos = new o(0, 0, 1), l3.ZNeg = new o(0, 0, -1);
        const n3 = {}, d3 = {};
        for (const A5 in l3)
          n3[A5] = i3.ori.rotateVec3(l3[A5]), d3[A5] = Number.NEGATIVE_INFINITY;
        const h3 = new o();
        A4.forEach((A5, g4) => {
          if (!Number.isFinite(A5.x) || !Number.isFinite(A5.y) || !Number.isFinite(A5.z))
            return;
          const I5 = A5.subtract(i3.tr);
          for (const A6 in l3) {
            const g5 = I5.dot(n3[A6]);
            g5 > d3[A6] && g5 != Number.POSITIVE_INFINITY && (d3[A6] = g5);
          }
          h3.addInPlace(A5);
        });
        for (const A5 in d3)
          if (d3[A5] == Number.POSITIVE_INFINITY)
            return;
        h3.scaleInPlace(1 / A4.length);
        let c3 = 0;
        if (this.isOrthographic()) {
          const A5 = new o(0.5 * (-d3.XNeg + d3.XPos), 0.5 * (-d3.YNeg + d3.YPos), 0.5 * (-d3.ZNeg + d3.ZPos)), g4 = d3.ZNeg + d3.ZPos;
          c3 = 2 * g4, A5.z = -d3.ZNeg + c3, i3.tr.addInPlace(i3.ori.rotateVec3(A5)), s3 = 2 * g4;
          const I5 = d3.XPos + d3.XNeg, C4 = d3.YPos + d3.YNeg;
          this.viewHeight = Math.max(C4, I5 / e3);
          const t4 = 0.1;
          this.viewHeight += this.viewHeight * t4;
        } else {
          const A5 = t3 / 2, g4 = C3 / 2, I5 = new B(Math.cos(A5) * d3.XPos, Math.sin(A5) * d3.XPos), e4 = I5.add(new B(Math.sin(A5), -Math.cos(A5))), a4 = new B(-Math.cos(A5) * d3.XNeg, Math.sin(A5) * d3.XNeg), l4 = a4.add(new B(-Math.sin(A5), -Math.cos(A5))), n4 = B.intersectionOfLines(I5, e4, a4, l4), r3 = new B(Math.cos(g4) * d3.YPos, Math.sin(g4) * d3.YPos), G3 = r3.add(new B(Math.sin(g4), -Math.cos(g4))), m3 = new B(-Math.cos(g4) * d3.YNeg, Math.sin(g4) * d3.YNeg), Q3 = m3.add(new B(-Math.sin(g4), -Math.cos(g4))), E3 = B.intersectionOfLines(r3, G3, m3, Q3);
          if (n4 === null || E3 === null)
            return void console.warn("xP or yP === null");
          c3 = Math.max(n4.y, E3.y);
          const b3 = new o(n4.x, E3.x, c3);
          i3.tr.addInPlace(i3.ori.rotateVec3(b3)), s3 = h3.distanceTo(i3.tr);
          const Z3 = s3 * 0.1;
          i3.tr.addInPlace(i3.ori.rotateVec3(new o(0, 0, Z3))), c3 += Z3;
        }
        if (this.adjustNearAndFarPlanesToFocalDist) {
          d3.ZPos -= c3, d3.ZNeg += c3;
          const A5 = d3.ZNeg * this.nearDistFactor, g4 = -d3.ZPos * this.farDistFactor;
          this.nearParam.value = A5, this.farParam.value = g4;
        }
      }
      this.setFocalDistance(s3), this.globalXfoParam.value = i3, this.emit("movementFinished");
    }
    updateProjectionMatrix(A3, g3) {
      const I3 = this.isOrthographicParam.value, C3 = this.fovParam.value, i3 = this.nearParam.value, e3 = this.farParam.value, t3 = new h();
      if (I3 > 0) {
        const A4 = 0.5 * this.viewHeight, I4 = -A4, C4 = A4, B3 = A4 * -g3, o3 = A4 * g3;
        t3.setOrthographicMatrix(B3, o3, I4, C4, i3, e3);
      }
      I3 < 1 && A3.setPerspectiveMatrix(C3, g3, i3, e3), I3 == 1 ? A3.setFromMat4(t3) : I3 > 0 && A3.set(r.lerp(A3.m00, t3.m00, I3), r.lerp(A3.m01, t3.m01, I3), r.lerp(A3.m02, t3.m02, I3), r.lerp(A3.m03, t3.m03, I3), r.lerp(A3.m10, t3.m10, I3), r.lerp(A3.m11, t3.m11, I3), r.lerp(A3.m12, t3.m12, I3), r.lerp(A3.m13, t3.m13, I3), r.lerp(A3.m20, t3.m20, I3), r.lerp(A3.m21, t3.m21, I3), r.lerp(A3.m22, t3.m22, I3), r.lerp(A3.m23, t3.m23, I3), r.lerp(A3.m30, t3.m30, I3), r.lerp(A3.m31, t3.m31, I3), r.lerp(A3.m32, t3.m32, I3), r.lerp(A3.m33, t3.m33, I3));
    }
  };
  e.register("Camera", IC);
  var CC = class extends eg {
    constructor(A3, g3) {
      super(), this.bindXfo = new m(), this.invBindXfo = new m(), this.groupGlobalXfo = new Bg("GroupGlobalXfo"), this.groupTransformXfo = new Cg("GroupTransformXfo"), this.groupGlobalXfo.setParam(A3), this.groupTransformXfo.setParam(g3), this.addInput(this.groupGlobalXfo), this.addOutput(this.groupTransformXfo);
    }
    setBindXfo(A3) {
      this.bindXfo = A3, this.invBindXfo = A3.inverse(), this.setDirty();
    }
    evaluate() {
      if (this.invBindXfo) {
        const A3 = this.groupGlobalXfo.getValue();
        this.groupTransformXfo.setClean(A3.multiply(this.invBindXfo));
      } else
        this.groupTransformXfo.setClean(new m());
    }
  };
  var iC = class extends eg {
    constructor(A3, g3) {
      super(), this.groupTransformXfo = new Bg("GroupTransformXfo"), this.memberGlobalXfo = new Cg("MemberGlobalXfo", KA.OP_READ_WRITE), this.groupTransformXfo.setParam(A3), this.memberGlobalXfo.setParam(g3), this.addInput(this.groupTransformXfo), this.addOutput(this.memberGlobalXfo), this._enabled = true;
    }
    disable() {
      this._enabled = false, this.setDirty();
    }
    enable() {
      this._enabled = true, this.setDirty();
    }
    evaluate() {
      const A3 = this.memberGlobalXfo.getValue();
      if (this._enabled) {
        const g3 = this.groupTransformXfo.getValue();
        this.memberGlobalXfo.setClean(g3.multiply(A3));
      } else
        this.memberGlobalXfo.setClean(A3);
    }
  };
  var eC = {disabled: 0, manual: 1, first: 2, average: 3, globalOri: 4};
  var tC = class extends xI {
    constructor(A3 = "") {
      super(A3), this.initialXfoModeParam = new DA("InitialXfoMode", eC.average, ["manual", "first", "average", "global"]), this.groupTransformParam = new PA("GroupTransform", new m()), this.calculatingGroupXfo = false, this.memberXfoOps = [], this.addParameter(this.initialXfoModeParam), this.initialXfoModeParam.on("valueChanged", () => {
        this.calcGroupXfo();
      }), this.addParameter(this.groupTransformParam), this.groupTransformOp = new CC(this.globalXfoParam, this.groupTransformParam);
    }
    static get INITIAL_XFO_MODES() {
      return eC;
    }
    updateHighlight() {
      setTimeout(() => {
        let A3, g3 = false;
        this.isSelected() && (g3 = true, A3 = this.getHighlight(), A3.a = 0.2);
        const I3 = "kinematicGroupItemHighlight" + this.getId();
        Array.from(this.itemsParam.value).forEach((C3) => {
          C3 instanceof ag && (g3 ? C3.addHighlight(I3, A3, true) : C3.removeHighlight(I3, true));
        });
      }, 1);
    }
    setSelected(A3) {
      super.setSelected(A3), this.updateHighlight();
    }
    calcGroupXfo() {
      const A3 = Array.from(this.itemsParam.value);
      if (A3.length == 0)
        return;
      this.calculatingGroupXfo = true, this.memberXfoOps.forEach((A4) => A4.disable());
      const g3 = this.initialXfoModeParam.value;
      let I3;
      if (g3 == eC.manual)
        I3 = this.globalXfoParam.value;
      else if (g3 == eC.first && A3[0] instanceof ag)
        I3 = A3[0].globalXfoParam.value;
      else if (g3 == eC.average) {
        I3 = new m(), I3.ori.set(0, 0, 0, 0);
        let g4 = 0;
        A3.forEach((A4, C3) => {
          if (A4 instanceof ag) {
            const C4 = A4.globalXfoParam.value;
            I3.tr.addInPlace(C4.tr), I3.ori.addInPlace(C4.ori), g4++;
          }
        }), I3.tr.scaleInPlace(1 / g4), I3.ori.normalizeInPlace();
      } else {
        if (g3 != eC.globalOri)
          throw new Error("Invalid GROUP_XFO_MODES.");
        {
          I3 = new m();
          let g4 = 0;
          A3.forEach((A4, C3) => {
            if (A4 instanceof ag) {
              const C4 = A4.globalXfoParam.value;
              I3.tr.addInPlace(C4.tr), g4++;
            }
          }), I3.tr.scaleInPlace(1 / g4);
        }
      }
      this.globalXfoParam.value = I3, this.groupTransformOp.setBindXfo(I3), this.memberXfoOps.forEach((A4) => A4.enable()), this.calculatingGroupXfo = false;
    }
    bindItem(A3, g3) {
      if (super.bindItem(A3, g3), A3 instanceof ag) {
        if (this.isSelected()) {
          const g4 = this.getHighlight();
          g4.a = 0.2;
          const I3 = "kinematicGroupItemHighlight" + this.getId();
          A3.addHighlight(I3, g4, true);
        }
        {
          const I3 = A3.globalXfoParam, C3 = new iC(this.groupTransformParam, I3);
          this.memberXfoOps.splice(g3, 0, C3), this.__itemsEventHandlers[g3] || (this.__itemsEventHandlers[g3] = {});
          this.__itemsEventHandlers[g3]["BoundingBox.valueChanged"] = A3.boundingBoxParam.on("valueChanged", (A4) => {
            this.setBoundingBoxDirty();
          });
        }
      }
    }
    unbindItem(A3, g3) {
      if (super.unbindItem(A3, g3), A3 instanceof ag) {
        if (this.isSelected()) {
          const g4 = "kinematicGroupItemHighlight" + this.getId();
          A3.removeHighlight(g4, true);
        }
        this.memberXfoOps[g3].detach(), this.memberXfoOps.splice(g3, 1), this.setBoundingBoxDirty();
      }
    }
    addItem(A3, g3 = true) {
      super.addItem(A3, g3), g3 && this.calcGroupXfo();
    }
    removeItem(A3, g3 = true) {
      super.removeItem(A3, g3), g3 && this.calcGroupXfo();
    }
    setItems(A3) {
      super.setItems(A3), this.calcGroupXfo();
    }
    clearItems(A3 = true) {
      super.clearItems(A3), this.memberXfoOps = [], A3 && this.calcGroupXfo();
    }
    loadDone() {
      this.calculatingGroupXfo = true, this.calcGroupXfo(), this.calculatingGroupXfo = false;
    }
    clone(A3) {
      const g3 = new tC();
      return g3.copyFrom(this, A3), g3;
    }
  };
  e.register("KinematicGroup", tC);
  var BC = class extends xI {
    constructor(A3) {
      super(A3), this.materialParam = new rg("Material"), this.__backupMaterials = {}, this.addParameter(this.materialParam), this.materialParam.on("valueChanged", () => {
        this.updateMaterial();
      });
    }
    updateHighlight() {
      this.__updateHighlightHelper();
    }
    __updateHighlightHelper() {
      let A3, g3 = false;
      this.isSelected() && (A3 = this.getHighlight(), g3 = true, A3.a = 0.2);
      const I3 = "kinematicGroupItemHighlight" + this.getId();
      Array.from(this.itemsParam.value).forEach((C3) => {
        C3 instanceof ag && (g3 ? C3.addHighlight(I3, A3, true) : C3.removeHighlight(I3, true));
      });
    }
    setSelected(A3) {
      super.setSelected(A3), this.updateHighlight();
    }
    updateOpacity() {
      super.updateOpacity(), Array.from(this.itemsParam.value).forEach((A3) => {
        A3 instanceof ag && (A3.opacityParam.value = this.opacity);
      });
    }
    updateMaterial() {
      this.updateMaterialHelper();
    }
    updateMaterialHelper() {
      const A3 = this.materialParam.value;
      Array.from(this.itemsParam.value).forEach((g3) => {
        g3.traverse((g4) => {
          if (g4 instanceof LI) {
            const I3 = g4.materialParam;
            if (A3) {
              const g5 = I3.value;
              g5 == A3 || g5 && g5.getShaderName() == "LinesShader" || (this.__backupMaterials[I3.getId()] = g5, I3.value = A3);
            } else
              this.__backupMaterials[I3.getId()] && (I3.value = this.__backupMaterials[I3.getId()]);
          }
        });
      });
    }
    bindItem(A3, g3) {
      if (super.bindItem(A3, g3), !(A3 instanceof ag))
        return;
      if (this.isSelected()) {
        const g4 = this.getHighlight();
        g4.a = 0.2;
        const I4 = "materialGroupItemHighlight" + this.getId();
        A3.addHighlight(I4, g4, true);
      }
      const I3 = this.materialParam.value;
      I3 && A3.traverse((A4) => {
        if (A4 instanceof LI) {
          const g4 = A4.materialParam;
          if (I3) {
            const A5 = g4.value;
            A5 == I3 || A5 && A5.getShaderName() == "LinesShader" || (this.__backupMaterials[g4.getId()] = A5, g4.value = I3);
          }
        }
      }, true), A3.opacityParam.value = this.opacity;
    }
    unbindItem(A3, g3) {
      if (super.unbindItem(A3, g3), A3 instanceof ag && this.isSelected()) {
        const g4 = "materialGroupItemHighlight" + this.getId();
        A3.removeHighlight(g4, true);
      }
    }
    clone(A3) {
      const g3 = new BC(this.__name + "clone");
      return g3.copyFrom(this, A3), g3;
    }
  };
  e.register("MaterialGroup", BC);
  var oC = class extends eg {
    constructor(A3, g3) {
      super(), this.groupGlobalXfo = new Bg("GroupGlobalXfo"), this.cuttingPlane = new Ig("CuttingPlane"), this.groupGlobalXfo.setParam(A3), this.cuttingPlane.setParam(g3), this.addInput(this.groupGlobalXfo), this.addOutput(this.cuttingPlane);
    }
    evaluate() {
      const A3 = this.groupGlobalXfo.getValue(), g3 = A3.ori.getZaxis(), I3 = A3.tr.dot(g3);
      this.cuttingPlane.setClean(new s(g3.x, g3.y, g3.z, -I3));
    }
  };
  var sC = class extends xI {
    constructor(A3 = "") {
      super(A3), this.cutAwayEnabledParam = new fA("CutAwayEnabled", false), this.cutPlaneParam = new UA("CutPlane", new s(1, 0, 0)), this.addParameter(this.cutAwayEnabledParam), this.addParameter(this.cutPlaneParam), this.cutPlaneOp = new oC(this.globalXfoParam, this.cutPlaneParam), this.cutAwayEnabledParam.on("valueChanged", (A4) => {
        this.updateCutaway(A4);
      }), this.cutPlaneParam.on("valueChanged", (A4) => {
        this.updateCutaway(A4);
      });
      const g3 = new XI("plane", "FlatSurfaceShader");
      g3.getParameter("BaseColor").value = new l(1, 1, 1, 0.2);
      const I3 = new kI("PlaneGeom", new AI(1, 1), g3);
      I3.setSelectable(false), this.addChild(I3);
      const C3 = new XI("border", "LinesShader");
      C3.getParameter("BaseColor").value = new l(1, 0, 0, 1);
      const i3 = new kI("BorderGeom", new xg(1, 1), C3);
      i3.setSelectable(false), this.addChild(i3);
    }
    updateCutaway(A3) {
      const g3 = this.cutAwayEnabledParam.value, I3 = this.cutPlaneParam.value, C3 = I3.xyz, i3 = I3.w;
      A3 instanceof LI ? (A3.setCutawayEnabled(g3), A3.setCutVector(C3), A3.setCutDist(i3)) : Array.from(this.itemsParam.value).forEach((A4) => {
        A4.traverse((A5) => {
          A5 instanceof LI && (A5.setCutawayEnabled(g3), A5.setCutVector(C3), A5.setCutDist(i3));
        }, true);
      });
    }
    bindItem(A3, g3) {
      if (!(A3 instanceof ag))
        return;
      this.cutAwayEnabledParam.value && this.updateCutaway(A3);
      const I3 = new b();
      Array.from(this.itemsParam.value).forEach((A4) => {
        A4 instanceof ag && I3.addBox3(A4.boundingBoxParam.value);
      });
      {
        const A4 = I3.p1.x - I3.p0.x, g4 = I3.p1.y - I3.p0.y, C3 = new m();
        C3.sc.set(A4, g4, 1), this.getChild(0).localXfoParam.value = C3, this.getChild(1).localXfoParam.value = C3;
      }
    }
    unbindItem(A3, g3) {
      A3 instanceof ag && A3.traverse((A4) => {
        A4 instanceof LI && A4.setCutawayEnabled(false);
      }, true);
    }
    clone(A3) {
      const g3 = new sC();
      return g3.copyFrom(this, A3), g3;
    }
  };
  e.register("CuttingPlane", sC);
  var aC = class extends $I {
    constructor(A3) {
      super(A3), this.cadfileVersion = new WA("0,0,0"), this.metadataLoaded = false;
    }
    clone(A3) {
      const g3 = new aC();
      return g3.copyFrom(this, A3), g3;
    }
    copyFrom(A3, g3) {
      super.copyFrom(A3, g3), A3.loaded || A3.once("geomsLoaded", (A4) => {
        this.emit("geomsLoaded", A4);
      });
    }
    getVersion() {
      return this.cadfileVersion;
    }
    readRootLevelBinary(A3, g3) {
      g3.versions = {}, g3.versions["zea-cad"] = new WA(A3.loadStr()), g3.sdk = A3.loadStr(), this.sdk = g3.sdk, this.cadfileVersion = g3.versions["zea-cad"], super.readBinary(A3, g3);
    }
    load(A3, I3 = new AC()) {
      return this.loadPromise || (this.loadPromise = new Promise((C3, i3) => {
        const e3 = A3.lastIndexOf("/") > -1 ? A3.substring(0, A3.lastIndexOf("/")) + "/" : "", t3 = A3.lastIndexOf("/") > -1 ? A3.substring(A3.lastIndexOf("/") + 1) : "", B3 = t3.substring(0, t3.lastIndexOf("."));
        this.url = A3, (I3 = I3.clone()).assetItem = this, I3.url = A3, I3.folder = e3, I3.on("done", () => {
          this.loaded = true, C3(), this.emit("loaded");
          const A4 = [];
          this.geomLibrary.isLoaded() || A4.push(new Promise((A5) => this.geomLibrary.once("loaded", A5))), this.traverse((A5) => {
            A5 instanceof aC && !A5.geomLibrary.isLoaded() && new Promise((g3) => A5.once("geomsLoaded", g3));
          }), Promise.all(A4).then(() => {
            this.emit("geomsLoaded");
          });
        }), I3.incrementAsync(), FA.incrementWorkload(1), this.geomLibrary.once("loaded", () => {
          FA.incrementWorkDone(1);
        }), FA.loadFile("archive", A3).then((C4) => {
          if (!C4.tree2 && !C4.tree)
            return console.error("Corrupt zcad file. Missing 'tree':", A3), FA.incrementWorkDone(1), void I3.decrementAsync();
          const i4 = new YA((C4.tree2 || C4.tree).buffer, 0, g.isMobileDevice), o3 = this.getName();
          if (this.readRootLevelBinary(i4, I3), o3 != "" && this.setName(o3), I3.versions["zea-cad"] = this.getVersion(), I3.versions["zea-engine"] = this.getEngineDataVersion(), C4.geoms)
            this.geomLibrary.readBinaryBuffer(t3, C4.geoms.buffer, I3), C4.geomsdata && (this.geomLibrary.loadMetadata(C4.geomsdata, I3), this.metadataLoaded = true);
          else if (C4["geomLibrary.json"]) {
            const g3 = JSON.parse(new TextDecoder("utf-8").decode(C4["geomLibrary.json"])), i5 = e3 + B3;
            g3.numGeomFiles == 0 ? (console.error("Corrupt zcad file. Missing 'geoms':", A3), FA.incrementWorkDone(1)) : this.geomLibrary.loadGeomFilesStream(g3, i5, I3);
          } else
            FA.incrementWorkDone(1);
          I3.decrementAsync();
        }, (A4) => {
          I3.decrementAsync(), FA.incrementWorkDone(1), this.emit("error", A4), i3(A4);
        });
      })), this.loadPromise;
    }
    loadMetadata(A3 = "") {
      return this.metadataLoaded ? Promise.resolve() : (this.metadataLoadPromise || (this.metadataLoadPromise = new Promise((g3, I3) => {
        if (this.metadataLoaded && g3(), A3 == "") {
          const g4 = this.url, I4 = g4.substring(0, g4.lastIndexOf("."));
          A3 = I4 + ".zmetadata";
        }
        console.log(A3), FA.incrementWorkload(), FA.loadFile("archive", A3).then((A4) => {
          const I4 = new AC();
          I4.versions["zea-cad"] = this.getVersion(), I4.versions["zea-engine"] = this.getEngineDataVersion(), this.geomLibrary.loadMetadata(A4.geomsdata, I4), FA.incrementWorkDone(1), this.metadataLoaded = true, g3();
        }, (A4) => {
          FA.incrementWorkDone(1), this.emit("error", A4), I3(A4);
        });
      })), this.metadataLoadPromise);
    }
  };
  e.register("CADAsset", aC);
  var lC = class extends ag {
    constructor(A3) {
      super(A3);
    }
    clone(A3) {
      const g3 = new lC();
      return g3.copyFrom(this, A3), g3;
    }
  };
  e.register("CADAssembly", lC);
  var nC = class extends ag {
    constructor(A3) {
      super(A3);
    }
    clone(A3) {
      const g3 = new nC();
      return g3.copyFrom(this, A3), g3;
    }
  };
  e.register("CADPart", nC);
  var dC = class extends kI {
    constructor(A3) {
      super(A3), this.shattered = false;
    }
    setShatterState(A3) {
      this.shattered != A3 && (this.shattered = A3, this.emit("shatterStateChanged", new x(A3)));
    }
    clone(A3) {
      const g3 = new dC();
      return g3.copyFrom(this, A3), g3;
    }
    readBinary(A3, g3) {
      if (g3.versions["zea-engine"].compare([3, 9, 0]) < 0) {
        if (LI.prototype.readBinary.call(this, A3, g3), A3.loadSInt32(), g3.versions["zea-cad"].compare([0, 0, 4]) < 0) {
          const I3 = A3.loadStr();
          let C3 = g3.assetItem.getMaterialLibrary().getMaterial(I3, false);
          C3 || (C3 = new XI(I3, "SimpleSurfaceShader"), C3.getParameter("BaseColor").setValue(l.random(0.25)), g3.assetItem.getMaterialLibrary().addMaterial(C3)), this.materialParam.setValue(C3);
        }
        if (g3.versions["zea-cad"].compare([0, 0, 2]) >= 0 && g3.versions["zea-cad"].compare([0, 0, 4]) < 0) {
          this.__layers = A3.loadStrArray();
          for (const A4 of this.__layers)
            g3.addGeomToLayer(this, A4);
        }
      } else
        super.readBinary(A3, g3);
    }
  };
  e.register("CADBody", dC);
  var hC = new jg(1, 1, 1);
  var cC = null;
  var rC = class extends kI {
    addHighlight(A3, g3, I3 = false) {
    }
    removeHighlight(A3, g3 = false) {
    }
  };
  var GC = class extends ag {
    constructor(A3) {
      super(A3), this.materialMapping = {};
    }
    clone(A3) {
      const g3 = new GC();
      return g3.copyFrom(this, A3), g3;
    }
    setSelected(A3) {
      super.setSelected(A3), A3 ? this.activate() : this.deactivate();
    }
    activate() {
    }
    deactivate() {
    }
    addHighlight(A3, g3, I3 = false) {
      if (super.addHighlight(A3, g3, false), I3) {
        const A4 = g3.clone();
        A4.a = 1;
        const I4 = {};
        this.traverse((g4) => {
          if (g4 instanceof rC)
            return false;
          if (g4 instanceof kI) {
            const C4 = g4.materialParam.value;
            if (this.materialMapping[g4.getId()] = C4, !(C4.getId() in I4)) {
              const i3 = C4.clone();
              if (i3.hasParameter("BaseColor")) {
                const g5 = i3.getParameter("BaseColor");
                g5 instanceof Qg && (g5.colorSpace = pA.Gamma), g5.setValue(A4);
              }
              if (i3.hasParameter("EdgeColor")) {
                const g5 = i3.getParameter("EdgeColor");
                g5 instanceof Qg && (g5.colorSpace = pA.Gamma), g5.setValue(A4);
              }
              i3.hasParameter("Overlay") && i3.getParameter("Overlay").setValue(0.85), i3.__isOpaque = false, g4.materialParam.value = i3, I4[C4.getId()] = i3;
            }
            g4.materialParam.value = I4[C4.getId()];
          }
        });
      }
      const C3 = this.getOwner().getOwner().getOwner();
      if (C3) {
        const I4 = {}, i3 = {}, e3 = this.getParameter("LinkedEntities");
        if (e3) {
          e3.getValue().forEach((e4, t3) => {
            if (e4 == "")
              return;
            const B3 = e4.split(", "), o3 = B3.pop();
            try {
              const e5 = C3.resolvePath(B3);
              if (e5 && e5 instanceof dC)
                if (e5.getNumChildren() == 0)
                  e5.setShatterState(true), I4[e5.getId()] || (I4[e5.getId()] = e5, i3[e5.getId()] = []), i3[e5.getId()].push(o3);
                else {
                  const I5 = e5.getChildByName(o3);
                  I5 && I5.addHighlight(A3, g3, true);
                }
              else
                console.log("linkedEntity.addHighlight(name, color, true):", B3);
            } catch (A4) {
              console.log(t3 + ":" + A4.message);
            }
          });
          for (let C4 in I4) {
            const e4 = I4[C4], t3 = i3[C4];
            e4.addHighlight(A3 + ":" + t3.toString(), g3, true);
          }
        }
      }
    }
    removeHighlight(A3, g3 = false) {
      super.removeHighlight(A3, false), g3 && this.traverse((A4) => {
        A4 instanceof kI && A4.getId() in this.materialMapping && (A4.materialParam.value = this.materialMapping[A4.getId()], delete this.materialMapping[A4.getId()]);
      });
      const I3 = this.getOwner().getOwner().getOwner();
      if (I3) {
        const g4 = {}, C3 = {}, i3 = this.getParameter("LinkedEntities");
        if (i3) {
          i3.getValue().forEach((i4) => {
            if (i4 == "")
              return;
            const e3 = i4.split(", "), t3 = e3.pop();
            try {
              const i5 = I3.resolvePath(e3);
              if (i5 && i5 instanceof dC)
                if (i5.getNumChildren() == 0)
                  i5.setShatterState(false), g4[i5.getId()] || (g4[i5.getId()] = i5, C3[i5.getId()] = []), C3[i5.getId()].push(t3);
                else {
                  const g5 = i5.getChildByName(t3);
                  g5 && g5.removeHighlight(A3, true);
                }
              else
                console.log("linkedEntity.addHighlight(name, color, true):failed");
            } catch (A4) {
              console.log(A4.message);
            }
          });
          for (let I4 in g4) {
            const i4 = g4[I4], e3 = C3[I4];
            i4.removeHighlight(A3 + ":" + e3.toString(), true);
          }
        }
      }
    }
    readBinary(A3, g3) {
      super.readBinary(A3, g3), this.traverse((A4) => {
        if (A4 instanceof kI) {
          const g4 = A4.materialParam.value;
          g4.getShaderName() == "StandardSurfaceShader" && g4.setShaderName("FlatSurfaceShader"), A4.__opacity = 0.99;
        }
      }), g3.assetItem.getGeometryLibrary().once("loaded", () => {
        this.traverse((A4) => {
          if (A4.getName().startsWith("Text")) {
            const g4 = [];
            return A4.traverse((A5) => {
              if (A5 instanceof kI) {
                const I3 = A5.geomParam.value.getBoundingBox();
                cC || (cC = new YI("plane"), cC.baseColorParam.value = new l(1, 1, 0, 1e-3), cC.overlayParam.value = -1e-3);
                const C3 = new rC("plane", hC, cC), i3 = A5.localXfoParam.value.multiply(A5.geomOffsetXfoParam.value);
                i3.tr.addInPlace(I3.center()), i3.sc.multiplyInPlace(I3.diagonal()), C3.localXfoParam.value = i3, g4.push(C3);
              }
            }, false), g4.forEach((g5) => A4.addChild(g5, false)), false;
          }
        }, false);
      });
    }
  };
  e.register("PMIItem", GC);
  var mC = class extends GC {
    constructor(A3) {
      super(A3), this.camera = null;
    }
    clone(A3) {
      const g3 = new mC();
      return g3.copyFrom(this, A3), g3;
    }
    activate() {
      super.activate();
      let A3 = [];
      this.hasParameter("GraphicalElements") && (A3 = this.getParameter("GraphicalElements").getValue());
      const g3 = (() => {
        let A4 = this;
        for (; A4 && !(A4 instanceof aC); )
          A4 = A4.getParentItem();
        return A4 instanceof aC ? A4 : null;
      })(), I3 = this.getParentItem().getParentItem(), C3 = I3.getParentItem();
      if (C3) {
        const g4 = [];
        I3.traverse((A4) => {
          A4 instanceof mC || A4 instanceof GC && g4.push(A4);
        }), g4.forEach((g5) => {
          const I4 = A3.includes(g5.getName());
          g5.setVisible(I4);
        });
      }
      if (this.camera) {
        const A4 = this.localXfoParam.value.clone(), I4 = this.getParameter("TargetPoint").getValue().clone(), C4 = this.getParameter("CameraType").getValue();
        A4.tr.scaleInPlace(g3.unitsScale), I4.scaleInPlace(g3.unitsScale);
        const i3 = A4.tr.distanceTo(I4);
        if (A4.sc.set(1, 1, 1), this.camera.globalXfoParam.value = A4, this.camera.setFocalDistance(i3), C4 == "Camera_Orthographic" && (this.camera.setIsOrthographic(1, 0), this.hasParameter("CameraZoom") && g3)) {
          const A5 = 1 / this.getParameter("CameraZoom").getValue() * g3.unitsScale * 2;
          this.camera.setFrustumHeight(A5);
        }
      }
      if (this.hasParameter("ClippingPlaneOrigin")) {
        const A4 = this.getParameter("ClippingPlaneOrigin").getValue(), I4 = this.getParameter("ClippingPlaneNormal").getValue(), i3 = true, e3 = -A4.dot(I4) * g3.unitsScale;
        C3.traverse((A5) => {
          if (A5 instanceof GC)
            return false;
          A5 instanceof kI && (A5.setCutawayEnabled(i3), A5.setCutVector(I4), A5.setCutDist(e3));
        });
      } else
        C3.traverse((A4) => {
          if (A4 instanceof GC)
            return false;
          A4 instanceof kI && A4.setCutawayEnabled(false);
        });
    }
    deactivate() {
      super.deactivate();
    }
    readBinary(A3, g3) {
      super.readBinary(A3, g3), g3.camera && (this.camera = g3.camera);
    }
  };
  e.register("PMIView", mC);
  var QC = class extends aC {
    constructor(A3) {
      super(A3);
    }
    clone(A3) {
      const g3 = new QC();
      return g3.copyFrom(this, A3), g3;
    }
    readBinary(A3, g3) {
      A3.loadStr();
      const I3 = A3.loadStr();
      this.setName(I3);
      let C3 = A3.loadStr();
      const i3 = new m();
      if (g3.versions["zea-cad"].compare([3, 6, 2]) > 0 ? (i3.tr = A3.loadFloat32Vec3(), i3.ori = A3.loadFloat32Quat(), this.localXfoParam.value = i3) : I3 == "" && this.setName(C3), g3.incrementAsync(), g3.xrefs[C3]) {
        const A4 = g3.xrefs[C3], e3 = () => {
          this.copyFrom(A4), this.setName(I3), this.localXfoParam.value = i3, this.loaded = true, this.emit("loaded"), g3.decrementAsync();
        };
        A4.loaded ? e3() : A4.on("loaded", e3);
      } else {
        let A4;
        g3.resources ? g3.resources[C3] ? A4 = g3.resources[C3] : (C3.includes("/") ? C3 = C3.slice(C3.lastIndexOf("/") + 1) : C3.includes("\\") && (C3 = C3.slice(C3.lastIndexOf("\\") + 1)), g3.resources[C3] ? A4 = g3.resources[C3] : g3.xrefLoadCallback && (A4 = g3.xrefLoadCallback.call(g3, C3, this))) : g3.xrefLoadCallback ? A4 = g3.xrefLoadCallback.call(g3, C3, this) : (C3.includes("/") ? C3 = C3.slice(C3.lastIndexOf("/") + 1) : C3.includes("\\") && (C3 = C3.slice(C3.lastIndexOf("\\") + 1)), A4 = g3.folder + C3 + ".zcad"), A4 ? (g3.xrefs[C3] = this, this.load(A4, new AC(g3)).then(() => {
          g3.decrementAsync();
        }, () => {
          g3.decrementAsync();
        })) : (g3.decrementAsync(), console.warn(`While Loading ${this.getPath()} unable to resolve ${C3}`));
      }
    }
  };
  e.register("XRef", QC);
  var EC = {OPAQUE: 1, TRANSPARENT: 2, OVERLAY: 4};
  var bC = class extends nA {
    constructor() {
      super(), this.enabled = true, this.passIndex = -1, this.__gl = null, this.renderer = null, this.__renderer = null, this.enabledParam = new fA("Enabled", true), this.enabled = true, this.passIndex = 0, this.addParameter(this.enabledParam), this.enabledParam.on("valueChanged", () => this.enabled = this.enabledParam.value);
    }
    parameterValueChanged(A3) {
      super.parameterValueChanged(A3), this.renderer && this.renderer.requestRedraw();
    }
    init(A3, g3) {
      if (g3 == null)
        throw new Error("Missing constructor argument.");
      this.__gl = A3.gl, this.renderer = A3, this.__renderer = A3, this.passIndex = g3;
    }
    setPassIndex(A3) {
      this.passIndex = A3;
    }
    getPassType() {
      return EC.OPAQUE;
    }
    itemAddedToScene(A3, g3) {
      throw Error(`${this.constructor.name} must implement itemAddedToScene and itemRemovedFromScene`);
    }
    itemRemovedFromScene(A3, g3) {
      throw Error(`${this.constructor.name} must implement itemAddedToScene and itemRemovedFromScene`);
    }
    startPresenting() {
    }
    stopPresenting() {
    }
    draw(A3) {
      throw Error("draw not implemented on GLPass");
    }
    drawHighlightedGeoms(A3) {
    }
    drawGeomData(A3) {
    }
    getGeomItemAndDist(A3) {
      throw Error("getGeomItemAndDist not implemented on GLPass");
    }
  };
  var ZC = class extends ag {
    constructor(A3 = 5, g3 = 50, I3 = new l("#DCDCDC")) {
      super("GridTree"), this.disableBoundingBox = true, this.setSelectable(false);
      const C3 = new KI("gridMaterial");
      C3.baseColorParam.value = I3, C3.overlayParam.value = 0;
      const i3 = new Pg(A3, A3, g3, g3, true), e3 = new kI("GridItem", i3, C3);
      e3.setSelectable(false), this.addChild(e3, false);
      const t3 = new Yg();
      t3.setNumVertices(2), t3.setNumSegments(1), t3.setSegmentVertexIndices(0, 0, 1);
      const B3 = t3.getVertexAttribute("positions");
      B3.getValueRef(0).set(-0.5 * A3, 0, 0), B3.getValueRef(1).set(0.5 * A3, 0, 0);
      const s3 = new KI("gridXAxisMaterial");
      s3.baseColorParam.value = new l(I3.luminance(), 0, 0), s3.overlayParam.value = 0;
      const a3 = new kI("xAxisLine", t3, s3);
      a3.setSelectable(false), this.addChild(a3, false);
      const n3 = new KI("gridYAxisMaterial");
      n3.baseColorParam.value = new l(0, I3.luminance(), 0), n3.overlayParam.value = 0;
      const d3 = new kI("yAxisLine", t3, n3);
      d3.setSelectable(false);
      const h3 = new m();
      h3.ori.setFromAxisAndAngle(new o(0, 0, 1), 0.5 * Math.PI), d3.geomOffsetXfoParam.value = h3, this.addChild(d3, false);
    }
    _cleanBoundingBox() {
      return new b();
    }
  };
  e.register("GridTreeItem", ZC);
  var yC = new l("#DCDCDC");
  var uC = class {
    constructor() {
      this.envMapParam = new OA("EnvMap"), this.displayEnvMapParam = new fA("Display EnvMap", false), this.envMapLODParam = new JA("EnvMapLOD", 0), this.root = new ag("root");
    }
    getRoot() {
      return this.root;
    }
    getResourceLoader() {
      return FA;
    }
    setEnvMap(A3) {
      this.envMapParam.value = A3;
    }
    setupGrid(A3 = 5, g3 = 50, I3 = yC) {
      const C3 = new ZC(A3, g3, I3);
      return this.root.addChild(C3, false), C3;
    }
  };
  var RC = class extends $I {
    constructor(A3) {
      super(A3), this.geomLibrary.on("loaded", () => {
        this.emit("geomsLoaded");
      });
    }
    readBinary(A3, g3) {
      g3.versions["zea-engine"] || (g3.versions["zea-mesh"] = new WA(A3.loadStr()));
      const I3 = A3.loadUInt32();
      return super.readBinary(A3, g3), g3.versions["zea-engine"].compare([2, 1, 0]) < 0 && A3.loadFloat32Vec2(), this.geomLibrary.setNumGeoms(A3.loadUInt32()), I3;
    }
    load(A3, I3 = new AC()) {
      return new Promise((C3, i3) => {
        const e3 = A3.lastIndexOf("/") > -1 ? A3.substring(0, A3.lastIndexOf("/")) + "/" : "", t3 = A3.lastIndexOf("/") > -1 ? A3.substring(A3.lastIndexOf("/") + 1) : "", B3 = t3.substring(0, t3.lastIndexOf("."));
        let o3 = 0;
        I3.assetItem = this, I3.url = A3, I3.folder = e3, FA.incrementWorkload(1), this.geomLibrary.on("loaded", () => {
          FA.incrementWorkDone(1);
        }), FA.loadFile("archive", A3).then((A4) => {
          let i4;
          if (A4.tree2)
            i4 = new YA(A4.tree2.buffer, 0, g.isMobileDevice);
          else {
            const C4 = A4.tree ? A4.tree : A4[Object.keys(A4)[0]];
            i4 = new YA(C4.buffer, 0, g.isMobileDevice), I3.versions["zea-engine"] = new WA();
          }
          if (o3 = this.readBinary(i4, I3), this.loaded = true, this.emit("loaded"), o3 == 0 && A4.geoms)
            this.geomLibrary.readBinaryBuffer(t3, A4.geoms.buffer, I3);
          else {
            const A5 = e3 + B3, g3 = {numGeomsPerFile: o3, numGeoms: this.geomLibrary.getNumGeoms()};
            this.geomLibrary.loadGeomFilesStream(g3, A5, I3);
          }
          C3();
        }, (A4) => {
          this.emit("error", A4), i3(A4);
        });
      });
    }
  };
  e.register("VLAAsset", RC);
  var VC = class extends nA {
    constructor() {
      super(), this.__activated = false;
    }
    activateTool() {
      if (this.__activated)
        throw new Error("Tool already activate");
      this.__activated = true, this.emit("activatedChanged", {activated: this.__activated});
    }
    deactivateTool() {
      this.__activated = false, this.emit("activatedChanged", {activated: this.__activated});
    }
    onPointerDown(A3) {
    }
    onPointerMove(A3) {
    }
    onPointerUp(A3) {
    }
    onPointerDoublePress(A3) {
    }
    onPointerEnter(A3) {
    }
    onPointerLeave(A3) {
    }
    onWheel(A3) {
    }
    onKeyDown(A3) {
    }
    onKeyUp(A3) {
    }
    onTouchCancel(A3) {
    }
  };
  var FC = {pan: 0, dolly: 1, focussing: 2, look: 3, turntable: 4, tumbler: 5, trackball: 6};
  var SC = class extends VC {
    constructor(A3) {
      super(), this.orbitAroundCursor = false, this.zoomTowardGeomUnderCursor = false, this.aimFocusOnTouchTap = 2, this.aimFocusOnMouseClick = 2, this.enabledWASDWalkMode = false, this.defaultManipulationState = FC.turntable, this.pointerDown = false, this.dragging = 0, this.keyboardMovement = false, this.keysPressed = [], this.velocity = new o(), this.prevVelocityIntegrationTime = -1, this.ongoingTouches = {}, this.mouseWheelMovementDist = 0, this.mouseWheelZoomCount = 0, this.mouseWheelZoomId = -1, this.orbitRateParam = new JA("OrbitRate", g.isMobileDevice ? 0.5 : 1), this.dollySpeedParam = new JA("DollySpeed", 0.02), this.mouseWheelDollySpeedParam = new JA("MouseWheelDollySpeed", 0.1), this.walkSpeedParam = new JA("WalkSpeed", 5), this.walkModeCollisionDetection = new fA("WalkModeCollisionDetection", false), this.appData = A3, this.defaultManipulationState = FC.turntable, this.manipulationState = this.defaultManipulationState, this.addParameter(this.orbitRateParam), this.addParameter(this.dollySpeedParam), this.addParameter(this.mouseWheelDollySpeedParam), this.addParameter(this.walkSpeedParam), this.addParameter(this.walkModeCollisionDetection);
    }
    activateTool() {
      super.activateTool(), this.appData && this.appData.renderer && (this.prevCursor = this.appData.renderer.getGLCanvas().style.cursor, this.appData.renderer.getGLCanvas().style.cursor = "cursor");
    }
    deactivateTool() {
      super.deactivateTool(), this.appData && this.appData.renderer && (this.appData.renderer.getGLCanvas().style.cursor = this.prevCursor);
    }
    setDefaultManipulationMode(A3) {
      if (this.defaultManipulationState = typeof A3 == "string" ? FC[A3] : A3, !Object.values(FC).includes(this.defaultManipulationState))
        throw new Error("Invalid Camera Manipulation Mode. Must be one of " + Object.keys(FC));
    }
    look(A3, g3) {
      const {viewport: I3} = A3, C3 = I3.getCamera(), i3 = this.orbitRateParam.value, e3 = C3.globalXfoParam.value, t3 = new c();
      t3.rotateZ(g3.x / I3.getWidth() * Math.PI * i3), e3.ori = t3.multiply(e3.ori);
      const B3 = new c();
      B3.rotateX(g3.y / I3.getHeight() * Math.PI * i3), e3.ori.multiplyInPlace(B3), C3.globalXfoParam.value = e3;
    }
    turntable(A3, g3) {
      const {viewport: I3} = A3, C3 = I3.getCamera(), i3 = this.orbitRateParam.value, e3 = C3.globalXfoParam.value, t3 = e3.ori.inverse().rotateVec3(e3.tr.subtract(this.orbitTarget)), B3 = new c();
      B3.rotateZ(g3.x / I3.getWidth() * 2 * Math.PI * -i3), e3.ori = B3.multiply(e3.ori);
      const o3 = new c();
      o3.rotateX(g3.y / I3.getHeight() * Math.PI * -i3), e3.ori.multiplyInPlace(o3), e3.tr = this.orbitTarget.add(e3.ori.rotateVec3(t3)), C3.globalXfoParam.value = e3;
    }
    tumbler(A3, g3) {
      const {viewport: I3} = A3, C3 = I3.getCamera(), i3 = this.orbitRateParam.value, e3 = C3.globalXfoParam.value, t3 = e3.ori.getXaxis(), B3 = e3.ori.getYaxis(), o3 = e3.ori.getZaxis(), s3 = t3.scale(-g3.x).add(B3.scale(g3.y)).cross(o3);
      s3.normalizeInPlace();
      const a3 = g3.length(), l3 = e3.ori.inverse().rotateVec3(e3.tr.subtract(this.orbitTarget)), n3 = new c();
      n3.setFromAxisAndAngle(s3, a3 / I3.getWidth() * Math.PI * -i3), e3.ori = n3.multiply(e3.ori), e3.tr = this.orbitTarget.add(e3.ori.rotateVec3(l3)), C3.globalXfoParam.value = e3;
    }
    trackball(A3, g3) {
      const {viewport: I3} = A3, C3 = I3.getCamera(), i3 = this.orbitRateParam.value, e3 = C3.globalXfoParam.value, t3 = e3.ori.getXaxis(), B3 = e3.ori.getYaxis(), o3 = e3.ori.getZaxis(), s3 = t3.scale(-g3.x).add(B3.scale(g3.y)).cross(o3);
      s3.normalizeInPlace();
      const a3 = g3.length(), l3 = e3.ori.inverse().rotateVec3(e3.tr.subtract(this.orbitTarget)), n3 = new c();
      n3.setFromAxisAndAngle(s3, a3 / I3.getWidth() * Math.PI * -i3), e3.ori = n3.multiply(e3.ori), e3.tr = this.orbitTarget.add(e3.ori.rotateVec3(l3)), C3.globalXfoParam.value = e3;
    }
    pan(A3, g3) {
      const {viewport: I3} = A3, C3 = I3.getCamera(), i3 = new m(), e3 = new o(1, 0, 0), t3 = new o(0, 1, 0);
      if (C3.isOrthographic()) {
        const A4 = C3.getFrustumHeight(), B4 = A4 * (I3.getWidth() / I3.getHeight());
        i3.tr = e3.scale(-g3.x / I3.getWidth() * B4), i3.tr.addInPlace(t3.scale(g3.y / I3.getHeight() * A4));
      } else {
        const A4 = C3.getFocalDistance(), B4 = C3.getFov(), o3 = 2 * A4 * Math.tan(0.5 * B4), s3 = o3 * (I3.getWidth() / I3.getHeight());
        i3.tr = e3.scale(-g3.x / I3.getWidth() * s3), i3.tr.addInPlace(t3.scale(g3.y / I3.getHeight() * o3));
      }
      const B3 = C3.globalXfoParam.value;
      C3.globalXfoParam.value = B3.multiply(i3);
    }
    dolly(A3, g3) {
      const {viewport: I3} = A3, C3 = I3.getCamera(), i3 = C3.getFocalDistance(), e3 = () => {
        const A4 = g3.y * this.dollySpeedParam.value * i3, I4 = new m();
        I4.tr.set(0, 0, A4);
        const e4 = C3.globalXfoParam.value;
        C3.globalXfoParam.value = e4.multiply(I4);
      }, t3 = () => {
        const A4 = g3.y * this.dollySpeedParam.value, I4 = C3.getFrustumHeight(), i4 = I4 * A4;
        C3.setFrustumHeight(I4 + i4);
      };
      C3.isOrthographic() ? t3() : e3();
    }
    initDrag(A3) {
      const {pointerPos: g3} = A3;
      A3.setCapture(this), this.pointerDown = true;
      const I3 = A3.viewport.getCamera(), C3 = I3.globalXfoParam.value;
      if (this.orbitAroundCursor)
        if (A3.intersectionData != null && this.orbitAroundCursor) {
          this.orbitTarget = A3.intersectionData.intersectionPos;
          const g4 = C3.inverse().transformVec3(A3.intersectionData.intersectionPos);
          I3.setFocalDistance(-g4.z);
        } else
          A3.pointerRay ? this.orbitTarget = A3.pointerRay.pointAtDist(I3.getFocalDistance()) : this.orbitTarget = C3.tr.add(C3.ori.getZaxis().scale(-I3.getFocalDistance()));
      else
        this.orbitTarget = C3.tr.add(C3.ori.getZaxis().scale(-I3.getFocalDistance()));
      this.prevPointerPos = g3, this.dragging = 1;
    }
    endDrag(A3) {
      A3.getCapture() == this && A3.releaseCapture(), this.dragging = 0, this.pointerDown = false;
    }
    aimFocus(A3, g3, I3 = -1, C3 = 400) {
      this.focusIntervalId && clearInterval(this.focusIntervalId);
      const i3 = Math.round(C3 / 20), e3 = this.manipulationState;
      let t3 = 0;
      const B3 = () => {
        const C4 = A3.globalXfoParam.value, o3 = A3.getFocalDistance(), s3 = g3.subtract(C4.tr), a3 = s3.normalizeInPlace(), l3 = C4.clone();
        if (e3 == FC.turntable || e3 == FC.look) {
          {
            const A4 = C4.ori.getZaxis().clone();
            A4.z = 0;
            const g4 = s3.negate();
            g4.z = 0;
            const I4 = new c();
            I4.setFrom2Vectors(A4, g4), l3.ori = I4.multiply(l3.ori);
          }
          {
            const A4 = C4.ori.getXaxis().clone(), g4 = C4.ori.getZaxis().clone(), I4 = s3.negate();
            I4.subtractInPlace(A4.scale(I4.dot(A4))), I4.normalizeInPlace();
            const i4 = new c();
            g4.cross(I4).dot(A4) > 0 ? i4.rotateX(g4.angleTo(I4)) : i4.rotateX(-g4.angleTo(I4)), l3.ori = l3.ori.multiply(i4);
          }
          {
            const A4 = l3.ori.getXaxis().clone(), g4 = A4.clone();
            g4.z = 0, g4.normalizeInPlace();
            const I4 = new c();
            I4.setFrom2Vectors(A4, g4), l3.ori = I4.multiply(l3.ori);
          }
        } else {
          const A4 = C4.ori.getZaxis().clone(), g4 = s3.negate(), I4 = new c();
          I4.setFrom2Vectors(A4, g4), l3.ori = I4.multiply(l3.ori);
        }
        const n3 = Math.pow(t3 / i3, 2), d3 = C4.clone();
        if (d3.ori = C4.ori.lerp(l3.ori, n3), I3 > 0) {
          const A4 = s3.scale(a3 - I3);
          d3.tr.addInPlace(A4.scale(n3));
        }
        A3.setFocalDistance(o3 + (a3 - o3) * n3), A3.globalXfoParam.value = d3, t3++, t3 <= i3 ? this.focusIntervalId = setTimeout(B3, 20) : (this.focusIntervalId = void 0, this.emit("movementFinished"), A3.emit("movementFinished"));
      };
      B3();
    }
    orientPointOfView(A3, g3, I3, C3 = 0, i3 = 400) {
      this.focusIntervalId && clearInterval(this.focusIntervalId);
      const e3 = Math.round(i3 / 20);
      let t3 = 0;
      const B3 = () => {
        const i4 = A3.globalXfoParam.value, o3 = A3.getTargetPosition(), s3 = Math.pow(t3 / e3, 2), a3 = g3.subtract(i4.tr), l3 = a3.normalizeInPlace(), n3 = a3.scale(l3 - C3), d3 = i4.tr.add(n3.scale(s3)), h3 = o3.lerp(I3, s3);
        A3.setPositionAndTarget(d3, h3), t3++, t3 <= e3 ? this.focusIntervalId = setTimeout(B3, 20) : (this.focusIntervalId = void 0, this.emit("movementFinished"), A3.emit("movementFinished"));
      };
      B3();
    }
    onPointerDoublePress(A3) {
      const g3 = (g4) => {
        const I3 = A3.viewport.getCamera(), C3 = I3.globalXfoParam.value.tr.add(g4.dir.scale(A3.intersectionData.dist));
        this.aimFocus(I3, C3), A3.aimTarget = C3, A3.aimDistance = A3.intersectionData.dist, this.emit("aimingFocus", A3), I3.emit("aimingFocus", A3), A3.stopPropagation();
      };
      if (A3.intersectionData && this.aimFocusOnMouseClick) {
        if (A3.pointerType === q.mouse && this.aimFocusOnMouseClick == 2) {
          const I3 = A3;
          g3(I3.pointerRay), I3.preventDefault();
        }
        if (A3.pointerType === q.touch && this.aimFocusOnTouchTap == 2) {
          g3(A3.pointerRay);
        }
      }
    }
    onPointerDown(A3) {
      if (A3.pointerType === q.mouse) {
        this.dragging == 1 && this.endDrag(A3), this.initDrag(A3);
        const g3 = A3;
        g3.button == 2 ? this.manipulationState = FC.pan : g3.ctrlKey && g3.altKey ? this.manipulationState = FC.dolly : g3.ctrlKey || g3.button == 2 ? this.manipulationState = FC.look : this.manipulationState = this.defaultManipulationState, g3.preventDefault();
      } else
        A3.pointerType === q.touch && this._onTouchStart(A3);
      A3.stopPropagation();
    }
    onPointerMove(A3) {
      this.dragging != 0 && (A3.pointerType === q.mouse && this._onMouseMove(A3), A3.pointerType === q.touch && this._onTouchMove(A3), this.dragging = 2, A3.stopPropagation());
    }
    _onMouseMove(A3) {
      if (!this.pointerDown)
        return;
      const g3 = A3.pointerPos, I3 = g3.subtract(this.prevPointerPos);
      switch (this.manipulationState) {
        case FC.turntable:
          this.turntable(A3, I3);
          break;
        case FC.tumbler:
          this.tumbler(A3, I3);
          break;
        case FC.trackball:
          this.trackball(A3, I3);
          break;
        case FC.look:
          this.look(A3, I3);
          break;
        case FC.pan:
          this.pan(A3, g3.subtract(this.prevPointerPos));
          break;
        case FC.dolly:
          this.dolly(A3, I3);
      }
      this.prevPointerPos = g3, A3.preventDefault();
    }
    _onTouchMove(A3) {
      const g3 = A3.touches;
      if (g3.length == 1) {
        const I3 = g3[0], C3 = new B(I3.clientX, I3.clientY), i3 = this.ongoingTouches[I3.identifier];
        if (!i3)
          return;
        const e3 = C3.subtract(i3.pos);
        switch (this.defaultManipulationState) {
          case FC.look:
            e3.scaleInPlace(6), this.look(A3, e3);
            break;
          case FC.turntable:
            this.turntable(A3, e3);
            break;
          case FC.tumbler:
            this.tumbler(A3, e3);
            break;
          case FC.trackball:
            this.trackball(A3, e3);
        }
        i3.pos = C3;
      } else if (g3.length == 2) {
        const I3 = g3[0], C3 = this.ongoingTouches[I3.identifier], i3 = g3[1], e3 = this.ongoingTouches[i3.identifier];
        if (!C3 || !e3)
          return;
        const t3 = new B(I3.clientX, I3.clientY), s3 = new B(i3.clientX, i3.clientY), a3 = e3.pos.subtract(C3.pos).length() - s3.subtract(t3).length(), l3 = t3.subtract(C3.pos), n3 = s3.subtract(e3.pos), d3 = l3.add(n3);
        d3.scaleInPlace(0.5);
        const h3 = 2e-3 * a3, {viewport: r3} = A3, G3 = r3.getCamera(), Q3 = G3.getFocalDistance(), E3 = G3.getFov(), b3 = new o(1, 0, 0), Z3 = new o(0, 1, 0), y3 = 2 * Q3 * Math.tan(0.5 * E3), u3 = y3 * (r3.getWidth() / r3.getHeight()), R3 = new m();
        R3.tr = b3.scale(-d3.x / r3.getWidth() * u3), R3.tr.addInPlace(Z3.scale(d3.y / r3.getHeight() * y3));
        const V3 = h3 * Q3;
        switch (G3.setFocalDistance(Q3 + V3), R3.tr.z += V3, this.defaultManipulationState) {
          case FC.tumbler:
          case FC.trackball:
            const A4 = e3.pos.subtract(C3.pos), g4 = s3.subtract(t3);
            let I4 = A4.normalize().angleTo(g4.normalize());
            A4.cross(g4) < 0 && (I4 = -I4);
            const i4 = new c();
            i4.rotateZ(I4), R3.ori.multiplyInPlace(i4);
        }
        const F3 = G3.globalXfoParam.value;
        G3.globalXfoParam.value = F3.multiply(R3), C3.pos = t3, e3.pos = s3;
      }
    }
    onPointerUp(A3) {
      if (this.dragging == 1) {
        if (this.endDrag(A3), A3.intersectionData && (A3.pointerType === q.mouse && this.aimFocusOnMouseClick == 1 || A3.pointerType === q.touch && this.aimFocusOnTouchTap == 1)) {
          const g3 = A3.viewport.getCamera(), I3 = g3.globalXfoParam.value, C3 = (A3.pointerType, A3.pointerRay), i3 = I3.tr.add(C3.dir.scale(A3.intersectionData.dist));
          this.aimFocus(g3, i3), A3.aimTarget = i3, A3.aimDistance = A3.intersectionData.dist, this.emit("aimingFocus", A3), g3.emit("aimingFocus", A3), A3.stopPropagation(), A3.pointerType === q.mouse && A3.preventDefault();
        }
      } else if (this.dragging == 2) {
        if (A3.pointerType === q.mouse) {
          this.endDrag(A3), this.emit("movementFinished");
          A3.viewport.getCamera().emit("movementFinished");
        } else if (A3.pointerType === q.touch) {
          const g3 = A3, {changedTouches: I3, touches: C3} = g3;
          for (let A4 = 0; A4 < I3.length; A4++)
            this.__endTouch(I3[A4]);
          Object.keys(this.ongoingTouches).length == 0 ? this.endDrag(A3) : C3.length || (this.endDrag(A3), this.ongoingTouches = {}), g3.preventDefault();
        }
        A3.stopPropagation();
      }
    }
    onPointerLeave(A3) {
      this.keysPressed.length > 0 && (this.keysPressed = [], this.velocity.set(0, 0, 0), this.keyboardMovement = false);
    }
    onWheel(A3) {
      const g3 = A3.viewport.getCamera(), I3 = this.mouseWheelDollySpeedParam.value, C3 = A3.shiftKey ? 0.1 : 0.5, i3 = g3.globalXfoParam.value;
      let e3;
      if (!g3.isOrthographic())
        if (this.zoomTowardGeomUnderCursor)
          if (A3.intersectionData != null) {
            e3 = i3.tr.subtract(A3.intersectionData.intersectionPos), e3.normalizeInPlace();
            const I4 = i3.inverse().transformVec3(A3.intersectionData.intersectionPos);
            g3.setFocalDistance(-I4.z);
          } else {
            const I4 = A3.pointerRay.pointAtDist(g3.getFocalDistance());
            e3 = i3.tr.subtract(I4), e3.normalizeInPlace();
          }
        else
          e3 = g3.globalXfoParam.value.ori.getZaxis();
      const t3 = A3.deltaY < 0 ? -1 : 1, B3 = () => {
        const A4 = g3.getFocalDistance(), I4 = A4 * this.mouseWheelMovementDist;
        i3.tr.addInPlace(e3.scale(I4)), g3.setFocalDistance(A4 + I4), g3.globalXfoParam.value = i3, this.mouseWheelZoomCount++, this.mouseWheelZoomCount < 6 ? this.mouseWheelZoomId = window.setTimeout(B3, 10) : (this.mouseWheelZoomId = -1, this.emit("movementFinished"), g3.emit("movementFinished"));
      }, o3 = () => {
        const A4 = 50 * this.mouseWheelMovementDist;
        new m().tr.set(0, 0, A4), i3.tr.addInPlace(e3.scale(A4)), g3.globalXfoParam.value = i3;
      }, s3 = () => {
        const I4 = g3.getFrustumHeight(), C4 = I4 * this.mouseWheelMovementDist;
        if (g3.setFrustumHeight(I4 + C4), A3.intersectionData && this.zoomTowardGeomUnderCursor) {
          const e4 = i3.tr.subtract(A3.intersectionData.intersectionPos), t4 = i3.ori.getZaxis();
          e4.subtractInPlace(t4.scale(e4.dot(t4))), i3.tr.addInPlace(e4.scale(C4 / (I4 + C4))), g3.globalXfoParam.value = i3;
        }
        this.mouseWheelZoomCount++, this.mouseWheelZoomCount < 6 ? this.mouseWheelZoomId = window.setTimeout(s3, 10) : (this.mouseWheelZoomId = -1, this.emit("movementFinished"), g3.emit("movementFinished"));
      };
      this.mouseWheelZoomId > 0 ? (this.mouseWheelMovementDist += t3 * I3 * C3 * 0.5 / 6, this.mouseWheelZoomCount = 0) : (this.mouseWheelMovementDist = t3 * I3 * C3 / 6, this.mouseWheelZoomCount = 0, g3.isOrthographic() ? s3() : A3.ctrlKey ? o3() : B3()), A3.preventDefault(), A3.stopPropagation();
    }
    integrateVelocityChange(A3) {
      const {viewport: g3} = A3, I3 = g3.getCamera(), C3 = performance.now();
      if (this.prevVelocityIntegrationTime > 0) {
        const A4 = (C3 - this.prevVelocityIntegrationTime) / 1e3, i3 = this.walkSpeedParam.value;
        if (i3 > 0) {
          const C4 = new m();
          C4.tr = this.velocity.normalize().scale(i3 * A4);
          const e3 = I3.globalXfoParam.value.multiply(C4);
          if (this.walkModeCollisionDetection.value) {
            const A5 = 1.5, I4 = 1.5, C5 = 0.5, i4 = new m(e3.tr), t3 = new G(e3.tr, new o(0, 0, -1)), B3 = g3.getRenderer().raycastCluster(i4, t3, I4, C5, EC.OPAQUE);
            if (B3.length > 0) {
              let g4 = 0;
              B3.forEach((A6) => {
                g4 += A6.dist;
              }), g4 /= B3.length, e3.tr = t3.start.add(t3.dir.scale(g4 - A5));
            }
          }
          I3.globalXfoParam.value = e3;
        }
      }
      this.prevVelocityIntegrationTime = C3;
    }
    onKeyDown(A3) {
      if (!this.enabledWASDWalkMode)
        return;
      const g3 = A3.key.toLowerCase();
      if (!this.keysPressed.includes(g3)) {
        switch (g3) {
          case "w":
            this.velocity.z -= 1;
            break;
          case "s":
            this.velocity.z += 1;
            break;
          case "a":
            this.velocity.x -= 1;
            break;
          case "d":
            this.velocity.x += 1;
            break;
          default:
            return;
        }
        if (A3.stopPropagation(), this.keysPressed.push(g3), !this.keyboardMovement) {
          this.keyboardMovement = true, this.prevVelocityIntegrationTime = performance.now();
          const g4 = () => {
            this.integrateVelocityChange(A3), this.keyboardMovement && window.requestAnimationFrame(g4);
          };
          window.requestAnimationFrame(g4);
        }
      }
    }
    onKeyUp(A3) {
      const g3 = A3.key.toLowerCase();
      if (!this.keysPressed.includes(g3))
        return;
      switch (g3) {
        case "w":
          this.velocity.z += 1;
          break;
        case "s":
          this.velocity.z -= 1;
          break;
        case "a":
          this.velocity.x += 1;
          break;
        case "d":
          this.velocity.x -= 1;
          break;
        default:
          return;
      }
      A3.stopPropagation();
      const I3 = this.keysPressed.indexOf(g3);
      this.keysPressed.splice(I3, 1), this.keysPressed.length == 0 && (this.keyboardMovement = false);
    }
    __startTouch(A3) {
      this.ongoingTouches[A3.identifier] = {identifier: A3.identifier, pos: new B(A3.clientX, A3.clientY)};
    }
    __endTouch(A3) {
      delete this.ongoingTouches[A3.identifier];
    }
    _onTouchStart(A3) {
      const g3 = A3.changedTouches;
      for (let A4 = 0; A4 < g3.length; A4++)
        this.__startTouch(g3[A4]);
      this.initDrag(A3);
    }
    onTouchEnd(A3) {
      A3.preventDefault(), A3.stopPropagation();
      const g3 = A3.changedTouches;
      for (let A4 = 0; A4 < g3.length; A4++)
        this.__endTouch(g3[A4]);
      Object.keys(this.ongoingTouches).length == 0 && this.endDrag(A3);
    }
    onTouchCancel(A3) {
      A3.preventDefault();
      const g3 = A3.touches;
      for (let A4 = 0; A4 < g3.length; A4++)
        this.__endTouch(g3[A4]);
      Object.keys(this.ongoingTouches).length == 0 && this.endDrag(A3);
    }
    static get MANIPULATION_MODES() {
      return FC;
    }
  };
  var wC = function(A3, g3) {
    let I3 = null;
    if (g3.webglContextType != null)
      try {
        I3 = A3.getContext(g3.webglContextType, g3), I3.name = g3.webglContextType;
      } catch (A4) {
      }
    else {
      const C3 = ["webgl2", "webgl"];
      for (let i3 = 0; i3 < C3.length; i3++) {
        const e3 = C3[i3];
        try {
          I3 = A3.getContext(e3, g3), I3.name = e3;
        } catch (A4) {
        }
        if (I3)
          break;
      }
    }
    if (!I3)
      throw new Error("WebGL not supported on your system");
    return I3.sizeInBytes = function(A4) {
      switch (A4) {
        case this.BYTE:
        case this.UNSIGNED_BYTE:
          return 1;
        case this.SHORT:
        case this.UNSIGNED_SHORT:
          return 2;
        case this.INT:
        case this.UNSIGNED_INT:
        case this.FLOAT:
          return 4;
        default:
          throw new Error("unknown type");
      }
    }, I3.name == "webgl2" ? (I3.floatTexturesSupported = true, I3.__ext_float_linear = I3.getExtension("OES_texture_float_linear"), I3.__ext_texture_half_float_linear = I3.getExtension("OES_texture_half_float_linear"), I3.__ext_color_buffer_float = I3.getExtension("EXT_color_buffer_float")) : (I3.__ext_float = I3.getExtension("OES_texture_float"), I3.__ext_float ? (I3.floatTexturesSupported = true, I3.__ext_float_linear = I3.getExtension("OES_texture_float_linear")) : console.warn("OES_texture_float is not available"), I3.__ext_half_float = I3.getExtension("OES_texture_half_float"), I3.__ext_half_float && (I3.HALF_FLOAT = I3.__ext_half_float.HALF_FLOAT_OES, I3.floatTexturesSupported = true, I3.__ext_texture_half_float_linear = I3.getExtension("OES_texture_half_float_linear")), I3.__ext_color_buffer_float = I3.getExtension("EXT_color_buffer_float"), I3.__ext_std_derivatives = I3.getExtension("OES_standard_derivatives"), I3.__ext_Inst = I3.getExtension("ANGLE_instanced_arrays"), I3.__ext_Inst && (I3.vertexAttribDivisor = I3.__ext_Inst.vertexAttribDivisorANGLE.bind(I3.__ext_Inst), I3.drawArraysInstanced = I3.__ext_Inst.drawArraysInstancedANGLE.bind(I3.__ext_Inst), I3.drawElementsInstanced = I3.__ext_Inst.drawElementsInstancedANGLE.bind(I3.__ext_Inst)), I3.__ext_VAO = I3.getExtension("OES_vertex_array_object"), I3.__ext_VAO && (I3.createVertexArray = I3.__ext_VAO.createVertexArrayOES.bind(I3.__ext_VAO), I3.deleteVertexArray = I3.__ext_VAO.deleteVertexArrayOES.bind(I3.__ext_VAO), I3.bindVertexArray = I3.__ext_VAO.bindVertexArrayOES.bind(I3.__ext_VAO)), I3.__ext_element_index_uint = I3.getExtension("OES_element_index_uint"), I3.__ext_WEBGL_depth_texture = I3.getExtension("WEBGL_depth_texture"), I3.__ext_WEBGL_depth_texture && (I3.UNSIGNED_INT_24_8 = I3.__ext_WEBGL_depth_texture.UNSIGNED_INT_24_8_WEBGL), I3.DRAW_FRAMEBUFFER = I3.FRAMEBUFFER), I3.__ext_frag_depth = I3.getExtension("EXT_frag_depth"), I3.setupInstancedQuad = function() {
      const A4 = new Float32Array([0, 1, 2, 3]), g4 = new Uint16Array([0, 1, 2, 2, 1, 3]);
      this.__quadVertexIdsBuffer = this.createBuffer(), this.bindBuffer(this.ARRAY_BUFFER, this.__quadVertexIdsBuffer), this.bufferData(this.ARRAY_BUFFER, A4, this.STATIC_DRAW), this.__quadIndexBuffer = this.createBuffer(), this.bindBuffer(this.ELEMENT_ARRAY_BUFFER, this.__quadIndexBuffer), this.bufferData(this.ELEMENT_ARRAY_BUFFER, g4, this.STATIC_DRAW), this.__quadattrbuffers = {vertexIDs: {buffer: this.__quadVertexIdsBuffer, dataType: "Float32", dimension: 1, count: A4.length, shared: true}};
    }, I3.drawQuad = function() {
      this.drawElements(this.TRIANGLES, 6, this.UNSIGNED_SHORT, 0);
    }, I3;
  };
  var XC = function(A3, g3) {
    if (!g3.width || !g3.height) {
      if (!g3.width)
        throw new Error("Invalid texture params. 'width' not provided");
      if (!g3.height)
        throw new Error("Invalid texture params. 'height' not provided");
    }
    const I3 = A3.getParameter(A3.MAX_TEXTURE_SIZE);
    if (g3.width <= 0 || g3.width > I3 || g3.height <= 0 || g3.height > I3)
      throw new Error("GLTextureParams: Invalid texture size. width:" + g3.width + " height:" + g3.height + " maxSize:" + I3);
    const C3 = {width: g3.width, height: g3.height}, i3 = (g4) => isNaN(g4) ? A3[g4] : g4, e3 = (A4, I4) => {
      A4 in g3 ? C3[A4] = i3(g3[A4]) : I4 && (C3[A4] = i3(I4));
    };
    if (e3("format"), e3("internalFormat", C3.format), e3("type", A3.UNSIGNED_BYTE), e3("minFilter", g3.filter ? g3.filter : A3.LINEAR), e3("magFilter", g3.filter ? g3.filter : A3.LINEAR), e3("wrapS", g3.wrapS ? g3.wrapS : A3.CLAMP_TO_EDGE), e3("wrapT", g3.wrapT ? g3.wrapT : A3.CLAMP_TO_EDGE), e3("flipY", false), e3("mipMapped", false), e3("depthInternalFormat"), e3("depthFormat"), e3("depthType"), g3.createDepthTexture && (A3.name == "webgl2" || A3.__ext_WEBGL_depth_texture ? (A3.name, C3.depthFormat = A3.DEPTH_COMPONENT, C3.depthType = A3.UNSIGNED_INT) : C3.depthType = A3.UNSIGNED_SHORT), C3.format == A3.FLOAT)
      if (A3.name == "webgl2")
        C3.filter != A3.LINEAR || A3.__ext_float_linear || (console.warn("Floating point texture filtering not supported on result device"), C3.filter = A3.NEAREST);
      else if (A3.__ext_float)
        C3.filter != A3.LINEAR || A3.__ext_float_linear || (console.warn("Floating point texture filtering not supported on result device"), C3.filter = A3.NEAREST);
      else {
        if (!A3.__ext_half_float)
          throw new Error("OES_texture_half_float is not available");
        C3.format = A3.HALF_FLOAT, C3.filter != A3.LINEAR || A3.__ext_texture_half_float_linear || (console.warn("Half Float texture filtering not supported on result device"), C3.filter = A3.NEAREST);
      }
    else if (C3.format == A3.HALF_FLOAT)
      if (A3.name == "webgl2")
        ;
      else {
        if (!A3.__ext_half_float)
          throw new Error("OES_texture_half_float is not available");
        if (C3.filter != A3.LINEAR || A3.__ext_texture_half_float_linear || (console.warn("Half Float texture filtering not supported on result device"), C3.filter = A3.NEAREST), C3.channels == A3.RGB)
          throw new Error("OES_texture_half_float onlysupports RGBA textures");
      }
    else if (C3.format == "sRGB" && !A3.__ext_sRGB)
      throw new Error("EXT_sRGB is not available");
    return C3.format != null && A3.name == "webgl2" && C3.internalFormat == C3.format && (C3.type == A3.FLOAT ? C3.format == A3.RED ? C3.internalFormat = A3.R32F : C3.format == A3.RG ? C3.internalFormat = A3.RG32F : C3.format == A3.RGB ? C3.internalFormat = A3.RGB32F : C3.format == A3.RGBA && (C3.internalFormat = A3.RGBA32F) : C3.type == A3.HALF_FLOAT ? C3.format == A3.RED ? C3.internalFormat = A3.R16F : C3.format == A3.RGB ? C3.internalFormat = A3.RGB16F : C3.format == A3.RGBA && (C3.internalFormat = A3.RGBA16F) : C3.type == A3.UNSIGNED_BYTE && (C3.format == A3.RED && (C3.internalFormat = A3.R8), C3.format == A3.RGB ? C3.internalFormat = A3.RGB8 : C3.format == A3.RGBA && (C3.internalFormat = A3.RGBA8))), C3.depthFormat != null && (A3.name == "webgl2" ? C3.depthType == A3.UNSIGNED_SHORT ? C3.depthInternalFormat = A3.DEPTH_COMPONENT16 : C3.depthType == A3.UNSIGNED_INT && (C3.depthInternalFormat = A3.DEPTH_COMPONENT24) : C3.depthInternalFormat = C3.depthFormat), C3;
  };
  var HC = class extends lA {
    constructor(A3, g3) {
      if (super(), this.__image = null, this.__internalFormat = 0, this.__type = 0, this.__format = 0, this.__wrapParam = 0, this.params = {}, this.__minFilter = 0, this.__magFilter = 0, this.__wrapS = 0, this.__wrapT = 0, this.__flipY = false, this.__mipMapped = false, this.invert = false, this.alphaFromLuminance = false, this.__gltex = null, this.__typeParam = "", this.__formatParam = "", this.__gl = A3, this.ready = false, this.width = 0, this.height = 0, this.textureType = 1, this.textureDesc = [0, 0, 0, 0], this.__loaded = false, this.__bound = false, g3 != null)
        if (g3 instanceof Gg) {
          this.__image = g3;
          const A4 = () => {
            const A5 = this.__image.getParams(), g4 = A5.width, I3 = A5.height, C3 = A5.data;
            this.bufferData(C3, g4, I3);
          };
          this.__image.on("updated", A4), this.__image.isLoaded() ? this.configure(this.__image.getParams()) : this.__image.on("loaded", () => {
            this.configure(this.__image.getParams());
          });
        } else
          this.configure(g3);
    }
    isLoaded() {
      return this.__loaded;
    }
    getImage() {
      return this.__image;
    }
    getInternalFormat() {
      return this.__internalFormat;
    }
    getType() {
      return this.__type;
    }
    getFormat() {
      return this.__format;
    }
    getWrap() {
      return this.__wrapParam;
    }
    getMipMapped() {
      return this.__mipMapped;
    }
    configure(A3) {
      const g3 = this.__gl, I3 = XC(g3, A3);
      this.params = I3, this.__format = I3.format, this.__internalFormat = I3.internalFormat, this.__type = I3.type, this.__minFilter = I3.minFilter, this.__magFilter = I3.magFilter, this.__wrapS = I3.wrapS, this.__wrapT = I3.wrapT, this.__flipY = "flipY" in A3 && A3.flipY, this.__mipMapped = "mipMapped" in A3 && A3.mipMapped, this.invert = "invert" in A3 && A3.invert, this.alphaFromLuminance = "alphaFromLuminance" in A3 && A3.alphaFromLuminance, this.textureType = 1, this.textureDesc[0] = this.width, this.textureDesc[1] = this.height, this.textureType == 1 && this.__format == g3.RGBA && (this.textureType = 2), this.__gltex && g3.deleteTexture(this.__gltex), this.__gltex = g3.createTexture(), this.__updateGLTexParams();
      const C3 = I3.width, i3 = I3.height, e3 = A3.data;
      e3 ? this.bufferData(e3, C3, i3, false, false) : this.resize(C3, i3, false, false), this.__loaded || (this.emit("ready"), this.__loaded = true);
    }
    __updateGLTexParams() {
      const A3 = this.__gl;
      A3.bindTexture(A3.TEXTURE_2D, this.__gltex), A3.texParameteri(A3.TEXTURE_2D, A3.TEXTURE_MAG_FILTER, this.__minFilter), A3.texParameteri(A3.TEXTURE_2D, A3.TEXTURE_MIN_FILTER, this.__magFilter), A3.texParameteri(A3.TEXTURE_2D, A3.TEXTURE_WRAP_S, this.__wrapS), A3.texParameteri(A3.TEXTURE_2D, A3.TEXTURE_WRAP_T, this.__wrapT);
    }
    bufferData(A3, g3 = -1, I3 = -1, C3 = true, i3 = true) {
      const e3 = this.__gl;
      if (A3 != null) {
        if (A3 instanceof WebGLTexture)
          this.__gltex = A3;
        else if (A3 instanceof HTMLImageElement || A3 instanceof ImageData || A3 instanceof HTMLCanvasElement || A3 instanceof HTMLImageElement || A3 instanceof HTMLVideoElement)
          C3 && e3.bindTexture(e3.TEXTURE_2D, this.__gltex), e3.texImage2D(e3.TEXTURE_2D, 0, this.__internalFormat, this.__format, this.__type, A3), this.width = A3.width, this.height = A3.height;
        else {
          g3 == -1 && (g3 = this.width), I3 == -1 && (I3 = this.height);
          const i4 = g3 * I3;
          let t3;
          switch (this.__format) {
            case e3.RED:
            case e3.RED_INTEGER:
            case e3.ALPHA:
            case e3.LUMINANCE:
            case e3.LUMINANCE_ALPHA:
              t3 = 1;
              break;
            case e3.RG:
              t3 = 2, e3.pixelStorei(e3.UNPACK_ALIGNMENT, 2);
              break;
            case e3.RGB:
              t3 = 3;
              break;
            case e3.RGBA:
              t3 = 4;
              break;
            default:
              console.warn("Reaching default case: numChannels:=1"), t3 = 1;
          }
          A3.length != i4 * t3 && console.warn("Invalid data for Image width:" + g3 + " height:" + I3 + " format:" + this.__formatParam + " type:" + this.__typeParam + " Data Length:" + A3.length + " Expected:" + i4 * t3);
          let B3 = A3;
          this.__type == e3.HALF_FLOAT && A3 instanceof Float32Array && (B3 = r.convertFloat32ArrayToUInt16Array(A3)), C3 && e3.bindTexture(e3.TEXTURE_2D, this.__gltex), e3.name == "webgl2" ? e3.texImage2D(e3.TEXTURE_2D, 0, this.__internalFormat, g3, I3, 0, this.__format, this.__type, B3, 0) : e3.texImage2D(e3.TEXTURE_2D, 0, this.__internalFormat, g3, I3, 0, this.__format, this.__type, B3), this.width = g3, this.height = I3;
        }
        this.__mipMapped && e3.generateMipmap(e3.TEXTURE_2D);
      } else
        C3 && e3.bindTexture(e3.TEXTURE_2D, this.__gltex), e3.texImage2D(e3.TEXTURE_2D, 0, this.__internalFormat, this.width, this.height, 0, this.__format, this.__type, null), this.width = g3, this.height = I3;
      i3 && this.emit("updated");
    }
    clear() {
      const A3 = this.__gl, g3 = this.width * this.height;
      let I3, C3;
      switch (this.__format) {
        case A3.RED:
        case A3.RED_INTEGER:
        case A3.ALPHA:
        case A3.LUMINANCE:
        case A3.LUMINANCE_ALPHA:
          I3 = 1;
          break;
        case A3.RG:
          I3 = 2;
          break;
        case A3.RGB:
          I3 = 3;
          break;
        case A3.RGBA:
          I3 = 4;
          break;
        default:
          throw new Error("Invalid Format");
      }
      switch (this.__type) {
        case A3.UNSIGNED_BYTE:
          C3 = new Uint8Array(g3 * I3);
          break;
        case A3.HALF_FLOAT:
          C3 = new Uint16Array(g3 * I3);
          break;
        case A3.FLOAT:
          C3 = new Float32Array(g3 * I3);
          break;
        default:
          throw new Error("Invalid Type");
      }
      A3.name == "webgl2" ? A3.texImage2D(A3.TEXTURE_2D, 0, this.__internalFormat, this.width, this.height, 0, this.__format, this.__type, C3, 0) : A3.texImage2D(A3.TEXTURE_2D, 0, this.__internalFormat, this.width, this.height, 0, this.__format, this.__type, C3);
    }
    resize(A3, g3, I3 = false, C3 = true) {
      const i3 = this.__gl;
      if (this.width != A3 || this.height != g3) {
        const e3 = i3.getParameter(i3.MAX_TEXTURE_SIZE);
        if (A3 < 0 || A3 > e3 || g3 < 0 || g3 > e3)
          throw new Error("gl-texture2d: Invalid texture size. width:" + A3 + " height:" + g3 + " maxSize:" + e3);
        if (I3) {
          const I4 = i3.createTexture();
          i3.bindTexture(i3.TEXTURE_2D, I4), i3.texImage2D(i3.TEXTURE_2D, 0, this.__internalFormat, A3, g3, 0, this.__format, this.__type, null);
          const C4 = i3.createFramebuffer();
          i3.bindFramebuffer(i3.FRAMEBUFFER, C4), i3.framebufferTexture2D(i3.FRAMEBUFFER, i3.COLOR_ATTACHMENT0, i3.TEXTURE_2D, this.__gltex, 0), i3.bindTexture(i3.TEXTURE_2D, I4), i3.copyTexImage2D(i3.TEXTURE_2D, 0, this.__internalFormat, 0, 0, this.width, this.height, 0), i3.bindFramebuffer(i3.FRAMEBUFFER, null), i3.deleteFramebuffer(C4), this.__gl.deleteTexture(this.__gltex), this.__gltex = I4, this.__updateGLTexParams();
        } else
          this.width > 0 && this.height > 0 && (this.__gl.deleteTexture(this.__gltex), this.__gltex = i3.createTexture(), this.__updateGLTexParams()), i3.bindTexture(i3.TEXTURE_2D, this.__gltex), i3.texImage2D(i3.TEXTURE_2D, 0, this.__internalFormat, A3, g3, 0, this.__format, this.__type, null);
        if (this.width = A3, this.height = g3, C3) {
          const I4 = new F(A3, g3);
          this.emit("resized", I4);
        }
      }
    }
    populate(A3, g3, I3, C3 = 0, i3 = 0, e3 = true) {
      const t3 = this.__gl;
      e3 && t3.bindTexture(t3.TEXTURE_2D, this.__gltex), t3.texSubImage2D(t3.TEXTURE_2D, 0, C3, i3, g3, I3, this.__format, this.__type, A3);
    }
    getSize() {
      return [this.width, this.height];
    }
    get glTex() {
      return this.__gltex;
    }
    getTexHdl() {
      return this.__gltex;
    }
    preBind(A3, g3) {
      return {textureTypeUnif: g3[A3.name + "Type"], textureDescUnif: g3[A3.name + "Desc"]};
    }
    bindToUniform(A3, g3, I3) {
      if (!this.__loaded)
        return false;
      if (!this.__gltex)
        throw new Error("Unable to bind non-initialized or deleted texture.");
      const C3 = A3.boundTextures++, i3 = this.__gl;
      return i3.activeTexture(i3.TEXTURE0 + C3), i3.bindTexture(i3.TEXTURE_2D, this.__gltex), i3.uniform1i(g3.location, C3), I3 && (I3.textureTypeUnif && i3.uniform1i(I3.textureTypeUnif.location, this.textureType), I3.textureDescUnif && i3.uniform4fv(I3.textureDescUnif.location, this.textureDesc)), true;
    }
    destroy() {
      super.destroy(), this.__gl.deleteTexture(this.__gltex), this.__gltex = null;
    }
    static getCachedGLTexture2D(A3) {
      return WC[A3.getId()];
    }
    static setCachedGLTexture2D(A3, g3) {
      WC[A3.getId()] = g3;
    }
  };
  var WC = {};
  var YC = {bool: "Boolean", int: "SInt32", uint: "UInt32", float: "Float32", ivec2: "Vec2", ivec3: "Vec3", ivec4: "Vec4", vec2: "Vec2", vec3: "Vec3", vec4: "Vec4", color: "Color", mat3: "Mat3", mat4: "Mat4", sampler2D: "BaseImage", samplerCube: "BaseImage"};
  var KC = /\s+/;
  var pC = class {
    constructor() {
      this.__shaderModules = {}, this.materialTemplates = {};
    }
    setShaderModule(A3, g3) {
      A3 in this.__shaderModules || (this.__shaderModules[A3] = g3);
    }
    getShaderModule(A3) {
      return this.__shaderModules[A3];
    }
    getShaderModuleNames() {
      const A3 = [];
      for (const g3 in this.__shaderModules)
        A3.push(g3);
      return A3;
    }
    parseAttr(A3, g3, I3, C3) {
      if (!(A3[1] in YC))
        throw new Error("Error while parsing \nType not recognized:" + A3[1]);
      const i3 = A3[2].slice(0, A3[2].length - 1);
      I3.attributes[i3] = {type: YC[A3[1]], instanced: g3}, A3[1] == "color" && (A3[1] = "vec4", A3.join(" "));
    }
    handleImport(A3, g3, I3, C3, i3) {
      if (I3 in this.__shaderModules) {
        const e3 = this.__shaderModules[I3];
        if (!e3)
          throw Error("snippet not loaded or does not exists!");
        const t3 = this.parseShaderHelper(g3, e3, C3, i3);
        C3.push(I3), A3.glsl = A3.glsl + t3.glsl, A3.numLines += t3.numLines, A3.uniforms = Object.assign(Object.assign({}, A3.uniforms), t3.uniforms), A3.attributes = Object.assign(Object.assign({}, A3.attributes), t3.attributes);
      } else
        console.log("shaderName: " + g3), console.log("SNIPPET NOT FOUND: " + I3);
    }
    parseShader(A3, g3) {
      return this.parseShaderHelper(A3, g3, [], 0);
    }
    parseShaderHelper(A3, g3, I3, C3) {
      const i3 = (A4, g4) => {
        A4.glsl = A4.glsl + g4 + "\n", A4.numLines++;
      };
      I3.push(A3);
      const e3 = {glsl: "", numLines: 0, uniforms: {}, attributes: {}}, t3 = (g3 = g3.toString()).split("\n");
      for (let g4 = 0; g4 < t3.length; g4++) {
        let B3 = t3[g4];
        const o3 = B3.trim(), s3 = o3.split(KC);
        switch (s3[0]) {
          case "<%include":
          case "import": {
            const g5 = o3.split(/'|"|`/)[1].split("/").pop();
            I3.includes(g5) || this.handleImport(e3, A3, g5, I3, C3);
            break;
          }
          case "attribute":
            this.parseAttr(s3, false, e3, B3), i3(e3, B3);
            break;
          case "instancedattribute":
            this.parseAttr(s3, true, e3, B3), s3[0] = "attribute", B3 = s3.join(" "), i3(e3, B3);
            break;
          case "uniform": {
            let g5 = 1;
            s3.length == 4 && (g5 = 2);
            const I4 = s3[g5];
            if (!(I4 in YC))
              throw new Error("Error while parsing :" + A3 + " \nType not recognized:" + s3[1]);
            const C4 = s3[g5 + 1].slice(0, s3[g5 + 1].length - 1);
            C4.includes("[") ? e3.uniforms[C4.substring(0, C4.indexOf("["))] = YC[I4] : e3.uniforms[C4] = YC[I4], e3.uniforms[C4] == "struct" && console.log(s3), s3[1] == "color" && (s3[1] = "vec4", B3 = s3.join(" ")), i3(e3, B3);
            break;
          }
          default:
            i3(e3, B3);
        }
      }
      return e3;
    }
  };
  var NC = new pC();
  var JC = 0;
  var DC = class extends hA {
    constructor(A3, g3) {
      super(g3), A3 && (this.__gl = A3), this.__shaderStagesGLSL = {}, this.__shaderStages = {}, this.__shaderProgramHdls = {}, this.__gltextures = {}, this.__id = JC++;
    }
    setGLContext(A3) {
      this.__gl = A3;
    }
    setShaderStage(A3, g3) {
      this.__shaderStagesGLSL[A3] = g3, this.clearProgramsCache();
    }
    getShaderStage(A3) {
      return this.__shaderStagesGLSL[A3];
    }
    clearProgramsCache() {
      const A3 = this.__gl;
      for (const g3 in this.__shaderProgramHdls) {
        const I3 = this.__shaderProgramHdls[g3];
        for (const g4 in I3.shaderHdls)
          A3.deleteShader(I3.shaderHdls[g4]);
        A3.deleteProgram(I3.shaderProgramHdl);
      }
    }
    static isOpaque() {
      return true;
    }
    static isOverlay() {
      return false;
    }
    __compileShaderStage(A3, g3, I3, C3) {
      const i3 = this.__gl;
      if (C3 || (C3 = i3.shaderopts), C3) {
        if (C3.repl)
          for (const g4 in C3.repl)
            A3 = t.replaceAll(A3, g4, C3.repl[g4]);
        if (C3.directives) {
          A3 = C3.directives.join("\n") + "\n" + A3;
        }
      }
      let e3;
      i3.name == "webgl2" && (A3 = t.replaceAll(A3, "attribute", "in"), A3 = I3 == "vertexShader" ? t.replaceAll(A3, "varying", "out") : t.replaceAll(A3, "varying", "in"), e3 = "#version 300 es\n", A3 = "#version 300 es\n" + (A3 = t.replaceAll(A3, "texture2D", "texture")));
      const B3 = i3.createShader(g3);
      if (!B3)
        throw Error("shaderHdl not defined");
      if (i3.shaderSource(B3, A3), i3.compileShader(B3), !i3.getShaderParameter(B3, i3.COMPILE_STATUS)) {
        console.log("Errors in :" + this.constructor.name);
        const g4 = i3.getShaderInfoLog(B3).split("\n"), C4 = {};
        for (let A4 = 0; A4 < g4.length; A4++) {
          if (g4[A4].startsWith("'")) {
            g4[A4 - 1] = g4[A4 - 1] + g4[A4], delete g4[A4], A4--;
            continue;
          }
          const I4 = g4[A4].split(":");
          if (I4.length >= 2) {
            const i4 = parseInt(I4[2]);
            isNaN(i4) || (C4[i4] ? C4[i4].push(g4[A4]) : C4[i4] = [g4[A4]]);
          }
        }
        const e4 = [], t3 = A3.split("\n");
        for (const A4 in C4) {
          const g5 = Number.parseInt(A4) - 1;
          for (let A5 = Math.max(0, g5 - 4); A5 < g5; A5++)
            e4.push((g5 + 1 + " ").padStart(3) + t3[A5]);
          e4.push((g5 + 1 + ">").padStart(3) + t3[g5]);
          for (let A5 = g5 + 1; A5 < Math.min(t3.length - 1, g5 + 5); A5++)
            e4.push((g5 + 1 + " ").padStart(3) + t3[A5]);
          const I4 = C4[A4];
          for (const A5 of I4)
            e4.push(A5);
        }
        throw new Error("An error occurred compiling the shader \n=================\n" + this.constructor.name + "." + I3 + ": \n\n" + e4.join("\n"));
      }
      return B3;
    }
    __createProgram(A3) {
      const g3 = this.__gl;
      this.__shaderCompilationAttempted = true;
      const I3 = g3.createProgram();
      if (!I3)
        throw Error("shaderProgramHdl not defined");
      const C3 = {};
      this.__shaderStages.VERTEX_SHADER || (this.__shaderStages.VERTEX_SHADER = NC.parseShader("VERTEX_SHADER", this.__shaderStagesGLSL.VERTEX_SHADER));
      const i3 = this.__shaderStages.VERTEX_SHADER.glsl;
      if (i3 != null) {
        const e4 = this.__compileShaderStage(i3, g3.VERTEX_SHADER, "vertexShader", A3);
        if (!e4)
          return false;
        g3.attachShader(I3, e4), C3[g3.VERTEX_SHADER] = e4;
      }
      this.__shaderStages.FRAGMENT_SHADER || (this.__shaderStages.FRAGMENT_SHADER = NC.parseShader("FRAGMENT_SHADER", this.__shaderStagesGLSL.FRAGMENT_SHADER));
      const e3 = this.__shaderStages.FRAGMENT_SHADER.glsl;
      if (e3 != null) {
        const i4 = Object.assign({}, g3.shaderopts, A3);
        i4.frag && (i4.defines = i4.frag.defines + i4.defines);
        const t4 = this.__compileShaderStage(e3, g3.FRAGMENT_SHADER, "fragmentShader", i4);
        if (!t4)
          return false;
        g3.attachShader(I3, t4), C3[g3.FRAGMENT_SHADER] = t4;
      }
      if (g3.linkProgram(I3), !g3.getProgramParameter(I3, g3.LINK_STATUS)) {
        const A4 = g3.getProgramInfoLog(I3);
        if (!A4)
          throw Error("info not defined");
        if (A4.includes("D3D shader compilation failed")) {
          const A5 = g3.getExtension("WEBGL_debug_shaders");
          if (A5) {
            const I4 = A5.getTranslatedShaderSource(C3[g3.VERTEX_SHADER]);
            console.log(I4);
          }
        }
        throw console.log("vertexShaderGLSL:" + i3), console.log("fragmentShaderGLSL:" + e3), new Error("Unable to link the shader program:" + this.constructor.name + "\n==================\n" + A4);
      }
      const t3 = this.__extractAttributeAndUniformLocations(I3, A3);
      return t3.shaderHdls = C3, t3.shaderProgramHdl = I3, t3;
    }
    __extractAttributeAndUniformLocations(A3, g3) {
      const I3 = this.__gl, C3 = this.getAttributes(), i3 = {attrs: {}, unifs: {}};
      for (const g4 in C3) {
        const e4 = I3.getAttribLocation(A3, g4);
        if (e4 == null) {
          console.warn("Shader attribute not found:" + g4);
          continue;
        }
        const t3 = C3[g4];
        i3.attrs[g4] = {name: g4, location: e4, type: t3.type, instanced: t3.instanced};
      }
      const e3 = this.getUniforms();
      for (let C4 in e3) {
        const t3 = e3[C4];
        if (g3 && g3.repl)
          for (const A4 in g3.repl)
            C4 = C4.replace(A4, g3.repl[A4]);
        const B3 = I3.getUniformLocation(A3, C4);
        B3 != null && (i3.unifs[C4] = {name: C4, location: B3, type: t3});
      }
      return i3;
    }
    getAttributes() {
      const A3 = {};
      for (const g3 in this.__shaderStages) {
        const I3 = this.__shaderStages[g3];
        for (const g4 in I3.attributes)
          A3[g4] = I3.attributes[g4];
      }
      return A3;
    }
    getUniforms() {
      const A3 = {};
      for (const g3 in this.__shaderStages) {
        const I3 = this.__shaderStages[g3];
        for (const g4 in I3.uniforms)
          A3[g4] = I3.uniforms[g4];
      }
      return A3;
    }
    isCompiledForTarget(A3) {
      const g3 = A3 || this.getId();
      return this.__shaderProgramHdls[g3] != null;
    }
    compileForTarget(A3, g3) {
      const I3 = A3 || this.getId();
      let C3 = this.__shaderProgramHdls[I3];
      return C3 || (C3 = this.__createProgram(g3 || {}), C3.shaderkey = I3, this.__shaderProgramHdls[I3] = C3, C3);
    }
    compile() {
      this.compileForTarget();
    }
    bind(A3, g3) {
      const I3 = this.__gl;
      if (A3.glShader != this) {
        const C3 = this.compileForTarget(g3, A3.shaderopts);
        if (!C3)
          return console.warn(this.constructor.name + " is not compiled for " + g3), false;
        const i3 = C3.shaderProgramHdl;
        I3.useProgram(i3), A3.glShader = this, A3.shaderkey = C3.shaderkey, A3.unifs = C3.unifs, A3.attrs = C3.attrs, A3.boundTextures = 0, A3.glGeom = void 0, A3.bindRendererUnifs && A3.bindRendererUnifs(C3.unifs);
      }
      return A3.supportsInstancing = true, true;
    }
    unbind(A3) {
      return A3.glShader = null, A3.shaderkey = "", A3.unifs = {}, A3.attrs = {}, true;
    }
    getGeomDataShaderName() {
      return "";
    }
    getSelectedShaderName() {
      return "";
    }
    static supportsInstancing() {
      return true;
    }
    static getPackedMaterialData(A3) {
      return new Float32Array(4);
    }
    static getMaterialTemplate() {
      throw new Error("Shader does not provide a material template.");
    }
    destroy() {
      const A3 = this.__gl;
      for (const g3 in this.__shaderProgramHdls) {
        const I3 = this.__shaderProgramHdls[g3];
        A3.deleteProgram(I3.shaderProgramHdl);
      }
      this.__shaderProgramHdls = {};
    }
  };
  var fC = class {
    constructor(A3, I3, C3 = false) {
      this.colorTextureResizeEventId = -1, this.__depthTexture = null, this.__fbo = null, this.__prevBoundFbo = null, !g.isIOSDevice || A3.name != "webgl" || I3.getType() != A3.FLOAT && I3.getType() != A3.HALF_FLOAT || console.error("IOS devices are unable to render to float textures."), this.__gl = A3, this.__colorTexture = I3, this.__createDepthTexture = C3, this.__clearColor = new l(0, 0, 0, 0), this.__colorTexture && (this.colorTextureResizeEventId = this.__colorTexture.on("resized", () => {
        console.warn("This code path will be deprecated. Instead, resize the GLFbo and it will resize the texture."), this.resize(this.__colorTexture.width, this.__colorTexture.height, false);
      })), this.setup();
    }
    setClearColor(A3) {
      this.__clearColor = A3;
    }
    getWidth() {
      return this.__colorTexture.width;
    }
    getHeight() {
      return this.__colorTexture.height;
    }
    getSize() {
      return [this.__colorTexture.width, this.__colorTexture.height];
    }
    getColorTexture() {
      return this.__colorTexture;
    }
    getDepthTextureGL() {
      return this.__depthTexture;
    }
    get width() {
      return this.__colorTexture.width;
    }
    get height() {
      return this.__colorTexture.height;
    }
    get size() {
      return [this.__colorTexture.width, this.__colorTexture.height];
    }
    get colorTexture() {
      return this.__colorTexture;
    }
    setColorTexture(A3) {
      const g3 = this.__gl;
      this.__colorTexture = A3, g3.framebufferTexture2D(g3.FRAMEBUFFER, g3.COLOR_ATTACHMENT0, g3.TEXTURE_2D, this.__colorTexture.glTex, 0);
    }
    get depthTextureGL() {
      return this.__depthTexture;
    }
    setup() {
      const A3 = this.__gl;
      this.__fbo = A3.createFramebuffer(), A3.name == "webgl2" ? A3.bindFramebuffer(A3.DRAW_FRAMEBUFFER, this.__fbo) : A3.bindFramebuffer(A3.FRAMEBUFFER, this.__fbo), this.__colorTexture && (A3.name == "webgl2" ? A3.framebufferTexture2D(A3.DRAW_FRAMEBUFFER, A3.COLOR_ATTACHMENT0, A3.TEXTURE_2D, this.__colorTexture.glTex, 0) : A3.framebufferTexture2D(A3.FRAMEBUFFER, A3.COLOR_ATTACHMENT0, A3.TEXTURE_2D, this.__colorTexture.glTex, 0)), this.__createDepthTexture && this.createDepthTexture(), MC(A3, this.width, this.height), A3.name == "webgl2" ? A3.bindFramebuffer(A3.DRAW_FRAMEBUFFER, null) : A3.bindFramebuffer(A3.FRAMEBUFFER, null);
    }
    createDepthTexture() {
      const A3 = this.__gl;
      if (A3.name == "webgl2" || A3.__ext_WEBGL_depth_texture)
        A3.activeTexture(A3.TEXTURE0), this.__depthTexture = A3.createTexture(), A3.bindTexture(A3.TEXTURE_2D, this.__depthTexture), A3.texParameteri(A3.TEXTURE_2D, A3.TEXTURE_MAG_FILTER, A3.LINEAR), A3.texParameteri(A3.TEXTURE_2D, A3.TEXTURE_MIN_FILTER, A3.LINEAR), A3.texParameteri(A3.TEXTURE_2D, A3.TEXTURE_WRAP_S, A3.CLAMP_TO_EDGE), A3.texParameteri(A3.TEXTURE_2D, A3.TEXTURE_WRAP_T, A3.CLAMP_TO_EDGE), A3.name == "webgl2" ? (A3.texImage2D(A3.TEXTURE_2D, 0, A3.DEPTH_COMPONENT24, this.width, this.height, 0, A3.DEPTH_COMPONENT, A3.UNSIGNED_INT, null), A3.framebufferTexture2D(A3.DRAW_FRAMEBUFFER, A3.DEPTH_ATTACHMENT, A3.TEXTURE_2D, this.__depthTexture, 0)) : (A3.texImage2D(A3.TEXTURE_2D, 0, A3.DEPTH_COMPONENT, this.width, this.height, 0, A3.DEPTH_COMPONENT, A3.UNSIGNED_INT, null), A3.framebufferTexture2D(A3.FRAMEBUFFER, A3.DEPTH_ATTACHMENT, A3.TEXTURE_2D, this.__depthTexture, 0));
      else {
        const g3 = A3.createRenderbuffer();
        A3.bindRenderbuffer(A3.RENDERBUFFER, g3), A3.renderbufferStorage(A3.RENDERBUFFER, A3.DEPTH_COMPONENT16, this.width, this.height), A3.framebufferRenderbuffer(A3.FRAMEBUFFER, A3.DEPTH_ATTACHMENT, A3.RENDERBUFFER, g3);
      }
    }
    resize(A3, g3, I3 = true) {
      const C3 = this.__gl;
      C3.bindFramebuffer(C3.FRAMEBUFFER, null), C3.deleteFramebuffer(this.__fbo), I3 && this.__colorTexture.resize(A3, g3, false, false), this.__fbo = C3.createFramebuffer(), C3.name == "webgl2" ? C3.bindFramebuffer(C3.DRAW_FRAMEBUFFER, this.__fbo) : C3.bindFramebuffer(C3.FRAMEBUFFER, this.__fbo), C3.framebufferTexture2D(C3.FRAMEBUFFER, C3.COLOR_ATTACHMENT0, C3.TEXTURE_2D, this.__colorTexture.glTex, 0), this.__depthTexture && (C3.deleteTexture(this.__depthTexture), this.createDepthTexture()), MC(C3, this.width, this.height);
    }
    bindForWriting(A3) {
      A3 && (this.__prevBoundFbo = A3.boundRendertarget, A3.boundRendertarget = this.__fbo);
      const g3 = this.__gl;
      g3.name == "webgl2" ? g3.bindFramebuffer(g3.DRAW_FRAMEBUFFER, this.__fbo) : g3.bindFramebuffer(g3.FRAMEBUFFER, this.__fbo), g3.viewport(0, 0, this.width, this.height);
    }
    unbindForWriting(A3) {
      A3 && (A3.boundRendertarget = this.__prevBoundFbo);
      const g3 = this.__gl;
      g3.name == "webgl2" ? g3.bindFramebuffer(g3.DRAW_FRAMEBUFFER, this.__prevBoundFbo) : g3.bindFramebuffer(g3.FRAMEBUFFER, this.__prevBoundFbo);
    }
    bind(A3) {
      this.bindForWriting(A3);
    }
    unbind(A3) {
      if (A3)
        this.unbindForWriting(A3);
      else {
        const A4 = this.__gl;
        A4.bindFramebuffer(A4.FRAMEBUFFER, null);
      }
    }
    bindForReading(A3) {
      const g3 = this.__gl;
      g3.name == "webgl2" ? g3.bindFramebuffer(g3.READ_FRAMEBUFFER, this.__fbo) : g3.bindFramebuffer(g3.FRAMEBUFFER, this.__fbo);
    }
    unbindForReading() {
      const A3 = this.__gl;
      A3.name == "webgl2" ? A3.bindFramebuffer(A3.READ_FRAMEBUFFER, null) : A3.bindFramebuffer(A3.FRAMEBUFFER, null);
    }
    clear() {
      const A3 = this.__gl;
      A3.colorMask(true, true, true, true);
      const g3 = this.__clearColor.asArray();
      A3.clearColor(g3[0], g3[1], g3[2], g3[3]), this.__createDepthTexture ? A3.clear(A3.COLOR_BUFFER_BIT | A3.DEPTH_BUFFER_BIT) : A3.clear(A3.COLOR_BUFFER_BIT);
    }
    bindAndClear(A3) {
      this.bind(A3), this.clear();
    }
    destroy() {
      const A3 = this.__gl;
      A3.bindFramebuffer(A3.FRAMEBUFFER, null), A3.deleteFramebuffer(this.__fbo), this.__fbo = null, this.__colorTexture.removeListenerById("resized", this.colorTextureResizeEventId);
    }
  };
  function MC(A3, g3, I3) {
    let C3;
    if (C3 = A3.name == "webgl2" ? A3.checkFramebufferStatus(A3.DRAW_FRAMEBUFFER) : A3.checkFramebufferStatus(A3.FRAMEBUFFER), C3 !== A3.FRAMEBUFFER_COMPLETE)
      switch (A3.bindTexture(A3.TEXTURE_2D, null), A3.name == "webgl2" ? A3.bindFramebuffer(A3.DRAW_FRAMEBUFFER, null) : A3.bindFramebuffer(A3.FRAMEBUFFER, null), console.warn("Error creating Fbo width:", g3, ", height:", I3), C3) {
        case A3.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
          throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete.");
        case A3.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
          throw new Error("There is no attachment.");
        case A3.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          throw new Error("Height and width of the attachment are not the same.");
        case A3.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
          throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer.");
        case 36061:
          throw new Error("The framebuffer is unsupported");
        default:
          throw new Error("Incomplete Frambuffer");
      }
  }
  var LC = class extends V {
    constructor(A3, g3) {
      super(), this.params = {}, this.flipY = false, this.width = 0, this.height = 0, this.__gl = A3, this.textureTargets = [], this.depthTexture = null, this.textureDesc = [0, 0, 0, 0], this.clearColor = new l(0, 0, 0, 0), this.colorMask = [true, true, true, true], g3 && this.configure(g3);
    }
    configure(A3) {
      const g3 = this.__gl, I3 = XC(g3, A3);
      this.textureTargets.forEach((A4) => {
        g3.deleteTexture(A4);
      }), this.textureTargets = [], this.depthTexture && (g3.deleteTexture(this.depthTexture), this.depthTexture = null), this.frameBuffer && g3.deleteFramebuffer(this.frameBuffer), this.params = I3, this.type = I3.type, this.format = I3.format, this.internalFormat = I3.internalFormat, this.minFilter = I3.minFilter ? I3.minFilter : I3.filter, this.minFilter = I3.magFilter ? I3.magFilter : I3.filter, this.wrap = I3.wrap, this.flipY = I3.flipY, this.width = I3.width, this.height = I3.height, this.textureType = 1, this.textureDesc[0] = this.width, this.textureDesc[1] = this.height;
      const C3 = A3.numColorChannels != null ? A3.numColorChannels : I3.format != null ? 1 : 0;
      for (let A4 = 0; A4 < C3; A4++) {
        g3.activeTexture(g3.TEXTURE0 + 1);
        const A5 = g3.createTexture();
        g3.bindTexture(g3.TEXTURE_2D, A5), g3.texParameteri(g3.TEXTURE_2D, g3.TEXTURE_WRAP_S, I3.wrapS), g3.texParameteri(g3.TEXTURE_2D, g3.TEXTURE_WRAP_T, I3.wrapT), g3.texParameteri(g3.TEXTURE_2D, g3.TEXTURE_MIN_FILTER, I3.minFilter), g3.texParameteri(g3.TEXTURE_2D, g3.TEXTURE_MAG_FILTER, I3.magFilter), g3.texImage2D(g3.TEXTURE_2D, 0, this.internalFormat, I3.width, I3.height, 0, this.format, this.type, null), this.textureTargets.push(A5);
      }
      if (I3.depthFormat) {
        if (g3.name == "webgl" && !g3.__ext_WEBGL_depth_texture)
          throw new Error("Depth textures not support on this device");
        g3.activeTexture(g3.TEXTURE0), this.depthTexture = g3.createTexture(), g3.bindTexture(g3.TEXTURE_2D, this.depthTexture), g3.texParameteri(g3.TEXTURE_2D, g3.TEXTURE_WRAP_S, I3.wrapS), g3.texParameteri(g3.TEXTURE_2D, g3.TEXTURE_WRAP_T, I3.wrapT), g3.texParameteri(g3.TEXTURE_2D, g3.TEXTURE_MIN_FILTER, I3.minFilter), g3.texParameteri(g3.TEXTURE_2D, g3.TEXTURE_MAG_FILTER, I3.magFilter), g3.texImage2D(g3.TEXTURE_2D, 0, I3.depthInternalFormat, I3.width, I3.height, 0, I3.depthFormat, I3.depthType, null);
      }
      if (this.frameBuffer = g3.createFramebuffer(), this.bindForWriting(), this.textureTargets.length > 0) {
        this.textureTargets.length > 1 && g3.name == "webgl" && g3.drawBuffers;
        const A4 = [];
        for (let I4 = 0; I4 < this.textureTargets.length; I4++)
          g3.framebufferTexture2D(g3.DRAW_FRAMEBUFFER, g3.COLOR_ATTACHMENT0 + I4, g3.TEXTURE_2D, this.textureTargets[I4], 0), A4.push(g3.COLOR_ATTACHMENT0 + I4);
        this.textureTargets.length > 1 && g3.drawBuffers(A4);
      }
      this.depthTexture && g3.framebufferTexture2D(g3.DRAW_FRAMEBUFFER, g3.DEPTH_ATTACHMENT, g3.TEXTURE_2D, this.depthTexture, 0), this.checkFramebuffer();
    }
    checkFramebuffer() {
      this.bindForWriting();
      const A3 = this.__gl, g3 = A3.checkFramebufferStatus(A3.DRAW_FRAMEBUFFER);
      if (g3 != A3.FRAMEBUFFER_COMPLETE)
        switch (g3) {
          case A3.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete.");
          case A3.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            throw new Error("There is no attachment.");
          case A3.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw new Error("Height and width of the attachment are not the same.");
          case A3.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer.");
          case 36061:
            throw new Error("The framebuffer is unsupported");
          default:
            throw new Error("Incomplete Frambuffer");
        }
      this.unbindForWriting();
    }
    bindForWriting(A3, g3 = false) {
      A3 && (this.__prevBoundFbo = A3.boundRendertarget, A3.boundRendertarget = this.frameBuffer);
      const I3 = this.__gl;
      I3.name == "webgl2" ? I3.bindFramebuffer(I3.DRAW_FRAMEBUFFER, this.frameBuffer) : I3.bindFramebuffer(I3.FRAMEBUFFER, this.frameBuffer), I3.viewport(0, 0, this.width, this.height), g3 && this.clear();
    }
    unbindForWriting(A3) {
      A3 && (A3.boundRendertarget = this.__prevBoundFbo);
      const g3 = this.__gl;
      g3.bindFramebuffer(g3.name == "webgl2" ? g3.DRAW_FRAMEBUFFER : g3.FRAMEBUFFER, this.__prevBoundFbo), this.__prevBoundFbo = null;
    }
    clear(A3 = true) {
      const g3 = this.__gl, I3 = this.colorMask;
      g3.colorMask(I3[0], I3[1], I3[2], I3[3]);
      const C3 = this.clearColor.asArray();
      g3.clearColor(C3[0], C3[1], C3[2], C3[3]);
      let i3 = 0;
      this.textureTargets.length > 0 && (i3 |= g3.COLOR_BUFFER_BIT), this.depthTexture && (i3 |= g3.DEPTH_BUFFER_BIT), g3.clear(i3);
    }
    bindForReading() {
      const A3 = this.__gl;
      A3.name == "webgl2" ? A3.bindFramebuffer(A3.READ_FRAMEBUFFER, this.frameBuffer) : A3.bindFramebuffer(A3.FRAMEBUFFER, this.frameBuffer);
    }
    unbindForReading() {
      const A3 = this.__gl;
      A3.name == "webgl2" ? A3.bindFramebuffer(A3.READ_FRAMEBUFFER, null) : A3.bindFramebuffer(A3.FRAMEBUFFER, null);
    }
    bindColorTexture(A3, g3, I3 = 0) {
      const C3 = this.__gl, i3 = A3.boundTextures++;
      return C3.uniform1i(g3.location, i3), C3.activeTexture(C3.TEXTURE0 + i3), C3.bindTexture(C3.TEXTURE_2D, this.textureTargets[I3]), true;
    }
    bindDepthTexture(A3, g3) {
      const I3 = this.__gl, C3 = A3.boundTextures++;
      return I3.uniform1i(g3.location, C3), I3.activeTexture(I3.TEXTURE0 + C3), I3.bindTexture(I3.TEXTURE_2D, this.depthTexture), true;
    }
    unbind(A3) {
      this.unbindForWriting(A3);
    }
    resize(A3, g3, I3 = false) {
      const C3 = this.__gl;
      if (this.width != A3 || this.height != g3) {
        const i3 = C3.getParameter(C3.MAX_TEXTURE_SIZE);
        if (A3 < 0 || A3 > i3 || g3 < 0 || g3 > i3)
          throw new Error(`GLRenderTarget: Invalid texture size. width: ${A3} height: ${g3} maxSize: ${i3}`);
        I3 && this.bindForReading();
        const e3 = this.params;
        for (let i4 = 0; i4 < this.textureTargets.length; i4++) {
          const t3 = C3.createTexture();
          C3.bindTexture(C3.TEXTURE_2D, t3), C3.texParameteri(C3.TEXTURE_2D, C3.TEXTURE_WRAP_S, e3.wrapS), C3.texParameteri(C3.TEXTURE_2D, C3.TEXTURE_WRAP_T, e3.wrapT), C3.texParameteri(C3.TEXTURE_2D, C3.TEXTURE_MIN_FILTER, e3.minFilter), C3.texParameteri(C3.TEXTURE_2D, C3.TEXTURE_MAG_FILTER, e3.magFilter), C3.texImage2D(C3.TEXTURE_2D, 0, this.internalFormat, A3, g3, 0, this.format, this.type, null), I3 && C3.copyTexImage2D(C3.TEXTURE_2D, 0, this.internalFormat, 0, 0, Math.min(A3, this.width), Math.min(g3, this.height), 0), C3.deleteTexture(this.textureTargets[i4]), this.textureTargets[i4] = t3;
        }
        if (e3.depthFormat) {
          if (C3.name == "webgl" && !C3.__ext_WEBGL_depth_texture)
            throw new Error("Depth textures not support on this device");
          C3.activeTexture(C3.TEXTURE0);
          const i4 = C3.createTexture();
          C3.bindTexture(C3.TEXTURE_2D, i4), C3.texParameteri(C3.TEXTURE_2D, C3.TEXTURE_WRAP_S, e3.wrapS), C3.texParameteri(C3.TEXTURE_2D, C3.TEXTURE_WRAP_T, e3.wrapT), C3.texParameteri(C3.TEXTURE_2D, C3.TEXTURE_MIN_FILTER, e3.minFilter), C3.texParameteri(C3.TEXTURE_2D, C3.TEXTURE_MAG_FILTER, e3.magFilter), C3.texImage2D(C3.TEXTURE_2D, 0, e3.depthInternalFormat, A3, g3, 0, e3.depthFormat, e3.depthType, null), I3 && C3.copyTexImage2D(C3.TEXTURE_2D, 0, this.internalFormat, 0, 0, Math.min(A3, this.width), Math.min(g3, this.height), 0), C3.deleteTexture(this.depthTexture), this.depthTexture = i4;
        }
        if (I3 && this.unbindForReading(), this.width = A3, this.height = g3, this.frameBuffer && C3.deleteFramebuffer(this.frameBuffer), this.frameBuffer = C3.createFramebuffer(), this.bindForWriting(), this.textureTargets.length > 0) {
          this.textureTargets.length > 1 && C3.name == "webgl" && C3.drawBuffers;
          const A4 = [];
          for (let g4 = 0; g4 < this.textureTargets.length; g4++)
            C3.framebufferTexture2D(C3.DRAW_FRAMEBUFFER, C3.COLOR_ATTACHMENT0 + g4, C3.TEXTURE_2D, this.textureTargets[g4], 0), A4.push(C3.COLOR_ATTACHMENT0 + g4);
          this.textureTargets.length > 1 && C3.drawBuffers(A4);
        }
        this.depthTexture && C3.framebufferTexture2D(C3.DRAW_FRAMEBUFFER, C3.DEPTH_ATTACHMENT, C3.TEXTURE_2D, this.depthTexture, 0), this.checkFramebuffer();
      }
    }
    bindToUniform(A3, g3, I3) {
      const C3 = A3.boundTextures++, i3 = this.__gl.TEXTURE0 + C3, e3 = this.__gl;
      return e3.activeTexture(i3), e3.bindTexture(e3.TEXTURE_2D, this.textureTargets[0]), e3.uniform1i(g3.location, C3), I3 && (I3.textureTypeUnif && e3.uniform1i(I3.textureTypeUnif.location, this.textureType), I3.textureDescUnif && this.__gl.uniform4fv(I3.textureDescUnif.location, this.textureDesc)), true;
    }
    destroy() {
      const A3 = this.__gl;
      this.textureTargets.forEach((g3) => {
        A3.deleteTexture(g3);
      }), this.textureTargets = [], this.depthTexture && (A3.deleteTexture(this.depthTexture), this.depthTexture = null), this.frameBuffer && A3.deleteFramebuffer(this.frameBuffer);
    }
  };
  var UC = "#define GLSLIFY 1\n\n#ifdef ENABLE_MULTI_DRAW\n\n#ifdef EMULATE_MULTI_DRAW\n\nuniform int geomItemId;\nint getGeomItemId() {\n  return geomItemId;\n}\n\nvec4 getDrawItemIds() {\n  return vec4(float(geomItemId), 0.0, -1.0, -1.0);\n}\n\n#else // EMULATE_MULTI_DRAW\n\nuniform sampler2D drawIdsTexture;\n\nint getGeomItemId() {\n  ivec2 drawIdsTextureSize = textureSize(drawIdsTexture, 0);\n  ivec2 drawIdsArrayCoords = ivec2(gl_DrawID % drawIdsTextureSize.x, gl_DrawID / drawIdsTextureSize.x);\n  return int(texelFetch(drawIdsTexture, drawIdsArrayCoords, 0).r + 0.5);\n}\n\nvec4 getDrawItemIds() {\n  ivec2 drawIdsTextureSize = textureSize(drawIdsTexture, 0);\n  ivec2 drawIdsArrayCoords = ivec2(gl_DrawID % drawIdsTextureSize.x, gl_DrawID / drawIdsTextureSize.x);\n  vec4 color = texelFetch(drawIdsTexture, drawIdsArrayCoords, 0);\n  // Note: a 0 value in the texture means no sub-geom index is being rendered.\n  // subtract off 1 to get the true sub-geom index.\n  return vec4(color.r, color.g - 1.0, color.b, color.a);\n}\n\n#endif // EMULATE_MULTI_DRAW\n\n#else // ENABLE_MULTI_DRAW\n\nuniform int geomItemId;\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\nattribute float instancedIds;    // instanced attribute..\nuniform int instancedDraw;\n\nint getGeomItemId() {\n  if (instancedDraw == 0) {\n    return geomItemId;\n  }\n  else {\n    return int(instancedIds);\n  }\n}\n\nvec4 getDrawItemIds() {\n  if (instancedDraw == 0) {\n    return vec4(float(geomItemId), 0.0, -1.0, -1.0);\n  }\n  else {\n    return vec4(float(instancedIds), 0.0, -1.0, -1.0);\n  }\n}\n\n#else\n\nint getGeomItemId() {\n  return geomItemId;\n}\n\nvec4 getDrawItemIds() {\n    return vec4(float(geomItemId), 0.0, -1.0, -1.0);\n}\n\n#endif // ENABLE_FLOAT_TEXTURES\n#endif // ENABLE_MULTI_DRAW\n\n// For backwards compatibility with older plugins (UX.HandleShader)\nint getDrawItemId() {\n  return getGeomItemId();\n}\n";
  NC.setShaderModule("imageAtlas.glsl", "#define GLSLIFY 1\n// Note: On mobile, I can't seem to pass around a stuct containing sampler2D.\n// I have to unpack the struct and pass its members. :(\n// struct ImageAtlas {\n//     sampler2D layout;\n//     sampler2D image;\n//     vec4 desc;\n// };\n\nimport 'GLSLUtils.glsl'\n\nvec4 getSubImageLayout(int index, in sampler2D atlasLayout, in vec4 atlasDesc){\n    return fetchTexel(atlasLayout, int(floor(atlasDesc.z+0.5)), index);\n}\nvec2 calcSubImageTexCoords(vec2 texCoord, int index, in sampler2D atlasLayout, in vec4 atlasDesc){\n    vec4 layoutData = fetchTexel(atlasLayout, int(floor(atlasDesc.z+0.5)), index);\n    // The following line is a hack to fix artifacts in our PBR lighting\n    // We were seeing loads of lighting garbage on some sufaces that were orthogonal\n    // to the world. The UV coordinates would have been landing right on the edges\n    // of our subimages and were often sampling outside the image. This couuld\n    // have been because of filtering, or an error in the uv coords. \n    texCoord = clamp(texCoord, vec2(0.01, 0.01), vec2(0.99, 0.99));\n    vec2 subimageTexel = texCoord * layoutData.zw;\n    // subimageTexel = clamp(subimageTexel, vec2(0.0, 0.0), vec2(1.0, 1.0));\n    return subimageTexel + layoutData.xy;\n}\nvec4 sampleSubImage(vec2 texCoord, int index, in sampler2D atlasLayout, in sampler2D atlasImage, in vec4 atlasDesc){\n    vec4 layoutData = fetchTexel(atlasLayout, int(floor(atlasDesc.z+0.5)), index);\n    vec2 atlasCoords = calcSubImageTexCoords(texCoord, index, atlasLayout, atlasDesc);\n    return texture2D(atlasImage, atlasCoords);\n}"), NC.setShaderModule("surfaceGeomData.glsl", "#define GLSLIFY 1\n  uniform int floatGeomBuffer;\n  uniform int passId;\n  uniform int occlusionCulling;\n\n  import 'GLSLBits.glsl'\n  \n  vec4 setFragColor_geomData(vec3 v_viewPos, int floatGeomBuffer, int passId, float geomItemId, float elemItemId, int isOrthographic){\n    vec4 fragColor;\n\n    float viewDist;\n    if (isOrthographic > 0) {\n      viewDist = abs(v_viewPos.z);\n    } else {\n      viewDist = length(v_viewPos);\n    }\n    if (floatGeomBuffer != 0) {\n      fragColor.r = float(passId); \n      fragColor.g = float(geomItemId);\n      fragColor.b = elemItemId;\n      fragColor.a = viewDist;\n    }\n    else {\n      ///////////////////////////////////\n      // UInt8 buffer\n      fragColor.r = mod(geomItemId, 256.) / 255.;\n      fragColor.g = (floor(geomItemId / 256.) + float(passId) * 32.) / 255.;\n\n      // encode the dist as a 16 bit float\n      vec2 float16bits = encode16BitFloatInto2xUInt8(viewDist);\n      fragColor.b = float16bits.x;\n      fragColor.a = float16bits.y;\n    }\n\n#ifdef ENABLE_ES3\n    if (occlusionCulling != 0) {\n      // Calculate a simple stochastic transparency to reduce the cost of the reduction shader.\n      // We only need one pixel to be visible to consider the geometry visible, so here we \n      // keep only one in 7x7 (49) pixels. This signficatly reduces the cost of reducing the scene\n      // to the reduction data buffer.\n      // Note: this is not a stochastic transparency, as we are simply setting black pixels to \n      // reduce the number of reduction points for this geometry. The black pixels (not discarded)\n      // still occlude other geometries, but during reduction count to nothing.\n      int x = int(gl_FragCoord.x * 1000.0);\n      int y = int(gl_FragCoord.y * 1000.0);\n      if (x % 7 != 0 || y % 7 != 0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      };\n    }\n#endif // ENABLE_ES3\n\n    return fragColor;\n  }\n\n  // Note: the older code imported drawItemId.glsl and newer code is importing geomItemId.glsl\n  // This code keeps compatibility with the older shaders.\n  vec4 setFragColor_geomData(vec3 v_viewPos, int floatGeomBuffer, int passId, float geomItemId, int isOrthographic){\n    return setFragColor_geomData(v_viewPos, floatGeomBuffer, passId, geomItemId, -1.0, isOrthographic);\n  }"), NC.setShaderModule("surfaceHighlight.glsl", "#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\n\n#ifdef ENABLE_FLOAT_TEXTURES\nvec4 getHighlightColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 4);\n}\n#else\n\nuniform vec4 highlightColor;\n\nvec4 getHighlightColor(int id) {\n    return highlightColor;\n}\n\n#endif\n\nvec4 setFragColor_highlight(float v_geomItemId){\n  vec4 fragColor; \n  int geomItemId = int(v_geomItemId + 0.5);\n  fragColor = getHighlightColor(geomItemId);\n  return fragColor;\n}\n"), NC.setShaderModule("computeViewNormal.glsl", "#define GLSLIFY 1\n  \n#ifdef ENABLE_ES3\nvec3 computeViewNormal(vec3 viewPos) {\n  vec3 fdx = dFdx(viewPos);\n  vec3 fdy = dFdy(viewPos);\n  return normalize(cross(fdx, fdy));\n}\n#else \nvec3 computeViewNormal(vec3 viewPos) {\n  return vec3(0.0, 0.0, 0.0);\n}\n#endif\n"), NC.setShaderModule("calcFatLinesViewPos.glsl", "#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\nvec3 calcFatLinesViewPos(int vertexID, mat4 modelViewMatrix, inout vec3 viewNormal, inout vec2 texCoord, inout vec3 pos) {\n\n  int seqentialIndex_0 = int(mod(segmentIndices.x, 2.));\n  int seqentialIndex_1 = int(mod(segmentIndices.y, 2.));\n  int index_0 = int(segmentIndices.x) / 2;\n  int index_1 = int(segmentIndices.y) / 2;\n\n  vec3 viewPos;\n  vec4 data_0 = fetchTexel(positionsTexture, positionsTextureSize, index_0);\n  vec4 data_1 = fetchTexel(positionsTexture, positionsTextureSize, index_1);\n\n  // During XR sessions, there is a scaling applied to the view matrix\n  // which causes a distortion to the line width. We extract that scale here\n  // and use to correct the distortion.\n  // See also: FatPointsShader\n  vec3 viewZ = modelViewMatrix[2].xyz;\n  float viewScale = length(viewZ);\n\n  vec4 pos_0 = modelViewMatrix * vec4(data_0.xyz, 1.0);\n  vec4 pos_1 = modelViewMatrix * vec4(data_1.xyz, 1.0);\n  // Note: multiply the per-vertex line thickness with the line thickness uniform value;\n  float lineThickness_0 = LineThickness * data_0.w * viewScale;\n  float lineThickness_1 = LineThickness * data_1.w * viewScale;\n\n  if (vertexID < 2) {\n    pos = data_0.xyz;\n    viewPos = pos_0.xyz;\n  }\n  else {\n    pos = data_1.xyz;\n    viewPos = pos_1.xyz;\n  }\n  if (pos_1 != pos_0) {\n    vec3 segmentDir = normalize(pos_1.xyz - pos_0.xyz);\n    vec3 viewVector = normalize(viewPos);\n\n    if (vertexID < 2) {\n      vec3 segmentStartDir = segmentDir;\n      if (seqentialIndex_0 != 0) {\n        //if index_0 == 0, get the last index in the line as previous\n        int index_prev = (index_0 > 0) ? (index_0-1) : (positionsTextureSize-1);\n        vec4 data_prev = fetchTexel(positionsTexture, positionsTextureSize, index_prev);\n        vec4 pos_prev = modelViewMatrix * vec4(data_prev.xyz, 1.0);\n        segmentStartDir = normalize(segmentDir + normalize(pos_0.xyz - pos_prev.xyz));\n        // segmentStartDir = segmentDir;\n      }\n      // vec3 startBiTangent = normalize(cross(segmentStartDir, viewVector));\n      // viewNormal = normalize(cross(segmentStartDir, startBiTangent));\n      vec3 startBiTangent = normalize(vec3(-segmentStartDir.y, segmentStartDir.x, 0.0));\n      viewNormal = normalize(-viewVector);\n      // Move the endpoints to overlap a bit more.\n      //viewPos -= vec3(segmentStartDir * lineThickness_0 * 0.25);\n      if (mod(vertexIDs, 2.0) == 0.0) {\n        viewPos += vec3(startBiTangent * lineThickness_0);\n        texCoord.x = 1.0;\n      }\n      else {\n        viewPos -= vec3(startBiTangent * lineThickness_0);\n        texCoord.x = 0.0;\n      }\n      texCoord.y = 0.0;\n    }\n    else {\n      vec3 segmentEndDir = segmentDir;\n      if (seqentialIndex_1 != 0) {\n        //if index_1 == numPoints-1, get the first index in the line as next\n        int index_next = (index_1 < (positionsTextureSize-1)) ? (index_1+1) : 0;\n        vec4 data_next = fetchTexel(positionsTexture, positionsTextureSize, index_next);\n        vec4 pos_next = modelViewMatrix * vec4(data_next.xyz, 1.0);\n        segmentEndDir = normalize(segmentDir + normalize(pos_next.xyz - pos_1.xyz));\n        // segmentEndDir = segmentDir;\n      }\n      // vec3 endBiTangent = normalize(cross(segmentEndDir, viewVector));\n      // viewNormal = normalize(cross(segmentEndDir, endBiTangent));\n      vec3 endBiTangent = normalize(vec3(-segmentEndDir.y, segmentEndDir.x, 0.0));\n      viewNormal = normalize(-viewVector);\n      // Move the endpoints to overlap a bit more.\n      //viewPos += vec3(segmentEndDir * lineThickness_1 * 0.25);\n      if (mod(vertexIDs, 2.0) == 0.0) {\n        viewPos += vec3(endBiTangent * lineThickness_1);\n        texCoord.x = 1.0;\n      }\n      else {\n        viewPos -= vec3(endBiTangent * lineThickness_1);\n        texCoord.x = 0.0;\n      }\n      texCoord.y = 1.0;\n    }\n\n    // Move the line towards the viewer by the line thickness.\n    // this is to avoid depth issues when lines are rendered over meshes. \n    viewPos.z += (lineThickness_0 + lineThickness_1) * 0.5;\n  }\n\n  return viewPos;\n}\n\n"), NC.setShaderModule("constants.glsl", "#define GLSLIFY 1\n#define PI 3.141592653589793\n#define TwoPI (2.0 * PI)\n#define HalfPI (0.5 * PI)\n\n"), NC.setShaderModule("convolve-helpers.glsl", "#define GLSLIFY 1\n\n#ifdef ENVMAP_CUBE\n\nuniform samplerCube envMap;\n\nvec4 sampleEnvMap(vec3 dir) {\n  return texture(envMap, dir);\n}\n\n#else \n\nuniform sampler2D   envMap;\n\nimport 'envmap-octahedral.glsl'\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = dirToSphOctUv(dir);\n  vec4 texel = texture2D(envMap, vec2(uv.x, 1.0 - uv.y));\n  return vec4(texel.rgb/texel.a, 1.0); // TODO: Check this line. Do we need it?\n}\n\n#endif \n\nvec3 cubeFaceUvToDir(float u, float v, int faceId) {\n\n  // normalize into [-1, 1] range\n  float n_u = 2.0 * u - 1.0;\n  float n_v = 2.0 * v - 1.0;\n\n  vec3 dir;\n  switch (faceId)\n  {\n  case 0: //TEXTURE_CUBE_MAP_POSITIVE_X:\n    dir.x = 1.0f;\n    dir.y = n_v;\n    dir.z = -n_u;\n    break;\n  case 1: //TEXTURE_CUBE_MAP_NEGATIVE_X:\n    dir.x = -1.0f;\n    dir.y = n_v;\n    dir.z = n_u;\n    break;\n  case 3: //TEXTURE_CUBE_MAP_POSITIVE_Y:\n    dir.x = n_u;\n    dir.y = 1.0f;\n    dir.z = -n_v;\n    break;\n  case 2: //TEXTURE_CUBE_MAP_NEGATIVE_Y:\n    dir.x = n_u;\n    dir.y = -1.0f;\n    dir.z = n_v;\n    break;\n  case 4: //TEXTURE_CUBE_MAP_POSITIVE_Z:\n    dir.x = n_u;\n    dir.y = n_v;\n    dir.z = 1.0f;\n    break;\n  case 5: //TEXTURE_CUBE_MAP_NEGATIVE_Z:\n    dir.x = -n_u;\n    dir.y = n_v;\n    dir.z = -1.0f;\n    break;\n  }\n  return normalize(dir);\n}\n\n"), NC.setShaderModule("cutaways.glsl", "#define GLSLIFY 1\nconst int GEOMITEM_FLAG_CUTAWAY = 1; // 1<<0;\nconst int GEOMITEM_INVISIBLE_IN_GEOMDATA = 2; // 1<<1;\nconst int GEOMITEM_TRANSPARENT = 4; // 1<<1;\n\nuniform color cutColor;\n\n#ifdef ENABLE_FLOAT_TEXTURES\n  vec4 getCutaway(int id) {\n    return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 5);\n  }\n\n#else\n\n  uniform vec4 cutawayData;\n\n  vec4 getCutaway(int id) {\n    return cutawayData;\n  }\n\n#endif\n\n#define RAY_EPS 0.0000001\nstruct Ray {\n  vec3 start;\n  vec3 dir;\n};\n\nfloat intersectRayPlane(Ray ray, Ray plane) {\n  vec3 w = ray.start - plane.start;\n  float D = dot(plane.dir, ray.dir);\n  float N = dot(-plane.dir, w);\n\n  if (abs(D) < RAY_EPS) {\n    // segment is parallel to plane\n    if (N == 0.0)\n      return -1.0; // segment lies in plane\n    else\n      return -1.0; // no intersection\n  }\n  // they are not parallel\n  // compute intersect param\n  float sI = N / D;\n  if (sI < -RAY_EPS) {\n    return -1.0; // no intersection\n  }\n  return sI;\n}\n\nbool cutaway(vec3 worldPos, vec3 planeNormal, float planeDist) {\n\n  vec3 planePos = planeNormal * planeDist;\n  vec3 planeDir = worldPos + planePos;\n  float planeOffset = dot(planeDir, planeNormal);\n  if (planeOffset > 0.0) {\n    return true;\n  }\n  return false;\n}\n"), NC.setShaderModule("debugColors.glsl", "#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\n\nvec3 getDebugColor(float id) {\n  int sel = int(round(mod(round(id), 16.0)));\n  \n  if (sel==0)\n    return vec3(0.0, 1.0, 1.0);\n  else if (sel==1)\n    return vec3(0.0, 1.0, 0.0);\n  else if (sel==2)\n    return vec3(1.0, 0.0, 1.0);\n  else if (sel==3)\n    return vec3(0.75, 0.75, 0.0);\n  else if (sel==4)\n    return vec3(0.0, 0.75, 0.75);\n  else if (sel==5)\n    return vec3(0.75, 0.0, 0.75);\n  else if (sel==6)\n    return vec3(0.45, 0.95, 0.0);\n  else if (sel==7)\n    return vec3(0.0, 0.45, 0.95);\n  else if (sel==8)\n    return vec3(0.95, 0.0, 0.45);\n  else if (sel==9)\n    return vec3(0.95, 0.45, 0.0);\n  else if (sel==10)\n    return vec3(0.0, 0.95, 0.45);\n  else if (sel==11)\n    return vec3(0.45, 0.0, 0.95);\n  else if (sel==12)\n    return vec3(0.45, 0.45, 0.95);\n  else if (sel==13)\n    return vec3(0.0, 0.0, 0.45);\n  else if (sel==14)\n    return vec3(0.0, 0.45, 0.45);\n  else if (sel==15)\n    return vec3(0.45, 0.0, 0.45);\n  else return vec3(0.2, 0.2, 0.2);\n}\n\n"), NC.setShaderModule("drawItemId.glsl", UC), NC.setShaderModule("geomItemId.glsl", UC), NC.setShaderModule("geomType.glsl", "#define GLSLIFY 1\n\nconst int TRIANGLES = 0;\nconst int LINES = 1;\nconst int POINTS = 2;"), NC.setShaderModule("drawItemTexture.glsl", "#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\nuniform sampler2D instancesTexture;\nuniform highp int instancesTextureSize;\n\n// See also: src\\Renderer\\GLSLConstants.js\n// const pixelsPerGLGeomItem = 8\nconst int pixelsPerItem = 8;\n\nvec4 getInstanceData(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 0);\n}\n\n#else\n\nuniform vec4 drawItemData;\n\nvec4 getInstanceData(int id) {\n  return drawItemData;\n}\n\n#endif\n\n"), NC.setShaderModule("envmap-dualfisheye.glsl", "#define GLSLIFY 1\n\nvec2 dualfisheyeUVsFromDir(vec3 dir) {\n  vec2 result;\n  float angle = 0.465;\n  if (dir.x < 0.0) {\n    result = vec2(((dir.z * -angle) + 0.5) * 0.5, (dir.y * angle) + 0.5);\n  }\n  else {\n    result = vec2( 0.5 + ((dir.z * angle) + 0.5) * 0.5, (dir.y * angle) + 0.5);\n  }\n  return result;\n}\n\n"), NC.setShaderModule("envmap-equirect.glsl", "#define GLSLIFY 1 \nimport 'constants.glsl'\n\nvec2 latLongUVsFromDir(vec3 dir) {\n  // Math function taken from...\n  // http://gl.ict.usc.edu/Data/HighResProbes/\n  // Note: Scaling from u=[0,2], v=[0,1] to u=[0,1], v=[0,1]\n  float phi = acos(dir.z);\n  float theta = atan(dir.x, dir.y);\n  return vec2((1.0 + theta / PI) / 2.0, phi / PI);\n}\n\n// Note: when u == 0.5 z = 1.0\nvec3 dirFromLatLongUVs(float u, float v) {\n  // http://gl.ict.usc.edu/Data/HighResProbes/\n  float theta = PI*((u * 2.0) - 1.0);\n  float phi = PI*v;\n  return vec3(sin(phi)*sin(theta), sin(phi)*cos(theta), cos(phi));\n}\n\nvec3 dirFromPolar(vec2 polar) {\n  float u = polar.x / (PI * 2.0);\n  float v = polar.y / PI;\n  return dirFromLatLongUVs(u, v);\n}\n\n"), NC.setShaderModule("envmap-octahedral.glsl", "#define GLSLIFY 1\nimport 'constants.glsl'\nimport 'GLSLUtils.glsl'\n#define sectorize(value) step(0.0, (value))*2.0-1.0\n#define sum(value) dot(clamp((value), 1.0, 1.0), (value))\n\nvec2 dirToSphOctUv(vec3 normal) {\n  normal = normalize(normal);\n  vec3 aNorm = abs(normal);\n  vec3 sNorm = sectorize(normal);\n  \n  vec2 dir = aNorm.xy;\n  float orient = atan(dir.x, max(dir.y,0.0000000000000001))/HalfPI;\n\n  dir = vec2(aNorm.z, length(aNorm.xy));\n  float pitch = atan(dir.y, dir.x)/HalfPI;\n\n  vec2 uv = vec2(sNorm.x*orient, sNorm.y*(1.0-orient))*pitch;\n\n  if (normal.z < 0.0) {\n    uv = sNorm.xy - abs(uv.ts)*sNorm.xy;\n  }\n  vec2 res = uv*0.5+0.5;\n  // Flip-v\n  // return res;\n  return vec2(res.x, 1.0 - res.y);\n}\n\nvec3 sphOctUvToDir(vec2 uv) {\n  uv = uv*2.0-1.0;\n  // Flip-v\n  uv.y = -uv.y;\n  vec2 suv = sectorize(uv);\n  float sabsuv = sum(abs(uv));\n  float pitch = sabsuv*HalfPI;\n\n  if (pitch <= 0.0) {\n    return vec3(0.0, 0.0, 1.0);\n  }\n  if (abs(pitch - PI) < 0.000001) {\n    return vec3(0.0, 0.0, -1.0);\n  }\n  if (sabsuv > 1.0) {\n    uv = (1.0-abs(uv.ts))*suv;\n  }\n\n  float orient = (abs(uv.s)/sabsuv)*HalfPI;\n  float sOrient = sin(orient);\n  float cOrient = cos(orient);\n  float sPitch = sin(pitch);\n  float cPitch = cos(pitch);\n\n  return vec3(\n    sOrient*suv.s*sPitch,\n    cOrient*suv.t*sPitch,\n    cPitch\n  );\n}\n\n"), NC.setShaderModule("GLSLBits.glsl", '#define GLSLIFY 1\n    \n/////////////////////////////////////////////////////////////////\n// http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js\nfloat shift_right(float v, float amt) {\n  v = floor(v) + 0.5;\n  return floor(v / exp2(amt));\n}\nfloat shift_left(float v, float amt) {\n  return floor(v * exp2(amt) + 0.5);\n}\n\nfloat mask_last(float v, float bits) {\n  return mod(v, shift_left(1.0, bits));\n}\nfloat extract_bits(float num, float from, float to) {\n  from = floor(from + 0.5);\n  to = floor(to + 0.5);\n  return mask_last(shift_right(num, from), to - from);\n}\n\n/////////////////////////////////////////////////////////////////\n// https://stackoverflow.com/questions/18453302/how-do-you-pack-one-32bit-int-into-4-8bit-ints-in-glsl-webgl\n\nconst vec4 bitEnc = vec4(1.,255.,65025.,16581375.);\nconst vec4 bitDec = 1./bitEnc;\nvec4 EncodeFloatRGBA (float v) {\n  vec4 enc = bitEnc * v;\n  enc = fract(enc);\n  enc -= enc.yzww * vec2(1./255., 0.).xxxy;\n  return enc;\n}\nfloat DecodeFloatRGBA (vec4 v) {\n  return dot(v, bitDec);\n}\n\n/////////////////////////////////////////////////////////////////\n// https://gist.github.com/Flexi23/1713774\n// \nvec2 encode16BitFloatInto2xUInt8(float v) {\n  vec2 c = vec2(0.);\n\n  int signum = (v >= 0.) ? 128 : 0;\n  v = abs(v);\n  int exponent = 15;\n  float limit = 1024.; // considering the bias from 2^-5 to 2^10 (==1024)\n  for(int exp = 15; exp > 0; exp--) {\n    if ( v < limit) {\n      limit /= 2.;\n      exponent--;\n    }\n  }\n\n  float rest;\n  if (exponent == 0) {\n    rest = v / limit / 2.;      // "subnormalize" implicite preceding 0. \n  } \n  else {\n    rest = (v - limit)/limit;   // normalize accordingly to implicite preceding 1.\n  }\n\n  int mantissa = int(rest * 2048.);   // 2048 = 2^11 for the (split) 11 bit mantissa\n  int msb = mantissa / 256;           // the most significant 3 bits go into the lower part of the first byte\n  int lsb = mantissa - msb * 256;     // there go the other 8 bit of the lower significance\n\n  c.x = float(signum + exponent * 8 + msb) / 255.;    // color normalization for texture2D\n  c.y = float(lsb) / 255.;\n\n  if (v >= 2048.) {\n    c.y = 1.;\n  }\n\n  return c;\n}\n\nfloat decode16BitFloatFrom2xUInt8(vec2 c) {\n  float v = 0.;\n\n  int ix = int(c.x*255.); // 1st byte: 1 bit signum, 4 bits exponent, 3 bits mantissa (MSB)\n  int iy = int(c.y*255.); // 2nd byte: 8 bit mantissa (LSB)\n\n  int s = (c.x >= 0.5) ? 1 : -1;\n  ix = (s > 0) ? ix - 128 : ix;   // remove the signum bit from exponent\n  int iexp = ix / 8;              // cut off the last 3 bits of the mantissa to select the 4 exponent bits\n  int msb = ix - iexp * 8;        // subtract the exponent bits to select the 3 most significant bits of the mantissa\n\n  int norm = (iexp == 0) ? 0 : 2048;          // distinguish between normalized and subnormalized numbers\n  int mantissa = norm + msb * 256 + iy;       // implicite preceding 1 or 0 added here\n  norm = (iexp == 0) ? 1 : 0;                 // normalization toggle\n  float exponent = pow( 2., float(iexp + norm) - 16.); // -5 for the the exponent bias from 2^-5 to 2^10 plus another -11 for the normalized 12 bit mantissa \n  v = float( s * mantissa ) * exponent;\n\n  return v;\n}\n\n// TODO : Encoding Float32 to 4x UInt8\n// http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js\n// http://ultraist.hatenablog.com/entry/20110608/1307539319\n\n'), NC.setShaderModule("GLSLUtils.glsl", "#define GLSLIFY 1\n\nint ftoi(float val) {\n  return int(floor(val + 0.5));\n}\nivec2 ftoi(vec2 v2) {\n  return ivec2(ftoi(v2.x), ftoi(v2.y));\n}\nivec3 ftoi(vec3 v4) {\n  return ivec3(ftoi(v4.x), ftoi(v4.y), ftoi(v4.z));\n}\nivec4 ftoi(vec4 v4) {\n  return ivec4(ftoi(v4.x), ftoi(v4.y), ftoi(v4.z), ftoi(v4.w));\n}\n\n#ifdef ENABLE_ES3\n\nint imod(int x, int y) {\n  return x % y;\n}\n\nvoid setFlag(inout int flags, int flag) {\n  flags |= flag;\n}\n\nvoid clearFlag(inout int flags, int flag) {\n  flags &= ~flag;\n}\n\nbool testFlag(int flags, int flag) {\n  return (flags & flag) != 0;\n}\n\n// private function: Mangle me...\nivec2 _pixelIndexToUV(int index, int textureWidth) {\n  return ivec2(index % textureWidth, index / textureWidth);\n}\n\nvec4 fetchTexel(sampler2D texture, int textureWidth, int index) {\n  return texelFetch(texture, _pixelIndexToUV(index, textureWidth), 0);\n}\n\nvec4 fetchTexel(sampler2D texture, ivec2 textureSize, ivec2 texCoord) {\n  return texelFetch(texture, texCoord, 0);\n}\n\nvec4 fetchTexel(sampler2D texture, ivec2 textureSize, int index) {\n    return texelFetch(texture, _pixelIndexToUV(index, textureSize.x), 0);\n}\n\n#else\n\n// TODO: integrate: https://gist.github.com/mattatz/70b96f8c57d4ba1ad2cd\n\nint max(int a, int b) {\n  return a > b ? a : b;\n}\nint min(int a, int b) {\n  return a < b ? a : b;\n}\n\nfloat round(float val) {\n  return floor(val + 0.4);\n}\n\nint imod(int x, int y) {\n  return x-y*(x/y);\n}\n\nvoid setFlag(inout int flags, int flag) {\n  flags += flag;\n}\nvoid clearFlag(inout int flags, int flag) {\n  flags -= flag;\n}\n\nbool testFlag(int flags, int flag) {\n  return imod(flags / flag, 2) != 0;\n}\n\n// private function: Mangle me...\nvec2 _pixelIndexToUV(int index, int textureSize) {\n  float flTexSize = float(textureSize);\n  float x = (float(imod(index, textureSize))+0.5)/flTexSize;\n  float y = (floor(float(index / textureSize))+0.5)/flTexSize;\n  return vec2(x, y);\n}\n\nvec4 fetchTexel(sampler2D texture, int textureSize, int index) {\n  vec2 texCoord = _pixelIndexToUV(index, textureSize);\n  return texture2D(texture, texCoord);\n}\n\nvec4 fetchTexel(sampler2D texture, ivec2 textureSize, ivec2 texCoord) {\n  vec2 ftextureSize = vec2(textureSize);\n  return texture2D(texture, (vec2(texCoord) + 0.5) / ftextureSize);\n}\n\n#endif // ENABLE_ES3\n\nint uvToPixelIndex(vec2 uv, int textureSize) {\n  return int(uv.x * float(textureSize)) + (int(floor(uv.y * float(textureSize))) * textureSize);\n}\n\n"), NC.setShaderModule("Hammersley.glsl", "#define GLSLIFY 1\nfloat RadicalInverse_VdC(uint bits) \n{\n  bits = (bits << 16u) | (bits >> 16u);\n  bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n  bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n  bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n  bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n  return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n// ----------------------------------------------------------------------------\nvec2 Hammersley(uint i, uint N)\n{\n  return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n} \n"), NC.setShaderModule("ImportanceSampleGGX.glsl", "#define GLSLIFY 1\nimport 'constants.glsl'\n\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n{\n  float a = roughness*roughness;\n\n  float phi = 2.0 * PI * Xi.x;\n  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n  float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n  // from spherical coordinates to cartesian coordinates\n  vec3 H = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\n\n  // from tangent-space vector to world-space sample vector\n  vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n  vec3 tangent   = normalize(cross(up, N));\n  vec3 bitangent = cross(N, tangent);\n\n  vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n  return normalize(sampleVec);\n} \n"), NC.setShaderModule("materialparams.glsl", "#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\nimport 'gamma.glsl'\n\n#ifdef ENABLE_MULTI_DRAW\n \nuniform sampler2D materialsTexture;\nuniform highp ivec2 materialsTextureSize;\n\nvec4 getMaterialValue(vec2 materialCoords, int valueIndex) {\n  int index = ftoi(materialCoords.x) + valueIndex;\n  ivec2 texelCoords = ivec2(imod(index, materialsTextureSize.x), index / materialsTextureSize.x);\n  \n  return fetchTexel(materialsTexture, materialsTextureSize, texelCoords);\n}\n\n#else // ENABLE_MULTI_DRAW\n\n////////////////////////\n// Material Param Helpers.\n\nvec4 getColorParamValue(vec4 value, sampler2D tex, int texType, vec2 texCoord) {\n  if (texType == 0) {\n    return value;\n  }\n  else if (texType == 1 || texType == 2) {\n    // Note: we assume textures are always in gamma space, and must be converted\n    // to linear. I cann't find evidence that 8-bit textures can be in linear space.\n    // TODO: Use SRGB textures.\n    return toLinear(texture2D(tex, texCoord));\n  }\n  else if (texType == 3) {\n    // Float HDR Texture. We assume these textures are in linear space.\n    return texture2D(tex, texCoord);\n  }\n  else\n    return value;\n}\n\nfloat luminanceFromRGB(vec3 rgb) {\n  return 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;\n}\n\nfloat getLuminanceParamValue(float value, sampler2D tex, int texType, vec2 texCoord) {\n  if (texType == 0)\n    return value;\n  else\n    return luminanceFromRGB(texture2D(tex, texCoord).rgb);\n}\n\n#endif // ENABLE_MULTI_DRAW\n"), NC.setShaderModule("modelMatrix.glsl", "#define GLSLIFY 1\n#ifdef ENABLE_FLOAT_TEXTURES\nimport 'GLSLUtils.glsl'\nimport 'transpose.glsl'\nmat4 getMatrix(sampler2D texture, int textureSize, int index) {\n  // Unpack 3 x 4 matrix columns into a 4 x 4 matrix.\n  vec4 col0 = fetchTexel(texture, textureSize, (index * pixelsPerItem) + 1);\n  vec4 col1 = fetchTexel(texture, textureSize, (index * pixelsPerItem) + 2);\n  vec4 col2 = fetchTexel(texture, textureSize, (index * pixelsPerItem) + 3);\n  mat4 result = transpose(mat4(col0, col1, col2, vec4(0.0, 0.0, 0.0, 1.0)));\n  return result;\n}\n\nmat4 getModelMatrix(int id) {\n  return getMatrix(instancesTexture, instancesTextureSize, id);\n}\n\n#else\n\nuniform mat4 modelMatrix;\n\nmat4 getModelMatrix(int id) {\n  return modelMatrix;\n}\n\n#endif\n\n"), NC.setShaderModule("PBRSurfaceRadiance.glsl", "#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\nconst int ENVMAP_FLAG_HEADLIGHT =  1; // 1<<0;\n\nstruct MaterialParams {\n  vec3 baseColor;\n  float ambientOcclusion;\n  float metallic;\n  float roughness;\n  float reflectance;\n  float opacity;\n  float emission;\n};\n\n#ifndef ENABLE_PBR\n\nvec4 pbrSurfaceRadiance(in MaterialParams material, vec3 normal, in vec3 viewVector) {\n  vec3 irradiance = vec3(dot(normal, viewVector));\n  float ao = material.ambientOcclusion; \n  return vec4(material.baseColor * ao * irradiance + (material.emission * material.baseColor), material.opacity);\n\n  // return vec4(material.baseColor * ao * irradiance , material.opacity);\n}\n\n#else\n\nuniform int envMapFlags;\nuniform samplerCube irradianceMap;\nuniform samplerCube prefilterMap;\nuniform sampler2D brdfLUT;\n\nvec3 sampleIrradiance(vec3 dir) {\n  return texture(irradianceMap, dir).rgb;\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nfloat luminance(vec3 color) {\n  return 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n}\n\nvec4 pbrSurfaceRadiance(in MaterialParams material, vec3 normal, in vec3 viewVector) {\n  if (envMapFlags == -1) {\n    vec3 irradiance = vec3(dot(normal, viewVector));\n    float ao = material.ambientOcclusion; \n    return vec4(material.baseColor * ao * irradiance + (material.emission * material.baseColor), material.opacity);\n  }\n\n  vec3 N = normal;\n  vec3 V = viewVector;\n  vec3 R = reflect(-V, N);\n  float roughness = material.roughness * material.roughness;\n  vec3 diffuseColor = (1.0 - material.metallic) * material.baseColor;\n\n  // Note: The specular reflectance of metallic surfaces is chromatic\n  // https://google.github.io/filament/Filament.html#listing_fnormal\n  vec3 F0 = 0.16 * material.reflectance * material.reflectance * (1.0 - material.metallic) + material.baseColor * material.metallic;\n\n  float NdotV = dot(N, V);\n\n  vec3 F = fresnelSchlickRoughness(max(NdotV, 0.0), F0, roughness);\n\n  vec3 kS = F;\n  vec3 kD = 1.0 - kS;\n  kD *= 1.0 - material.metallic;\n  float ao = material.ambientOcclusion; \n  \n  vec3 irradiance;\n  vec3 irradianceSampleDir = normal;\n  \n  bool headLightMode = testFlag(envMapFlags, ENVMAP_FLAG_HEADLIGHT);\n  if (headLightMode) {\n    irradianceSampleDir = viewVector;\n  }\n  irradiance = sampleIrradiance(irradianceSampleDir);\n  // vec3 irradiance = shGetIrradianceAt(shCoefficients, N);\n  vec3 diffuse    = irradiance * diffuseColor;\n  \n  const float MAX_REFLECTION_LOD = 4.0;\n  vec3 prefilteredColor = textureLod(prefilterMap, R,  roughness * MAX_REFLECTION_LOD).rgb;   \n  vec2 envBRDF  = texture(brdfLUT, vec2(max(NdotV, 0.0), roughness)).rg;\n  vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n  \n  vec3 radiance = (kD * diffuse + specular) * ao;\n  \n  // Now handle semi-transparent objects. We need to be able to linearly interpolate\n  // opacity to make objects disappear, so we need a continuous change.\n  float opacity = material.opacity;\n  vec4 transparent = vec4((radiance * opacity) + specular, opacity + luminance(specular) + luminance(F));\n  vec4 result = mix(transparent, vec4(radiance, 1.0), opacity);\n\n  // Add emission on as the final component.\n  // Note: emission allows a material to blend off its specular component, \n  // which can also be used to make an object completely disappear if also transparent.\n  return mix(result, vec4(material.baseColor, opacity), material.emission);\n}\n\n#endif // ENABLE_PBR\n"), NC.setShaderModule("SHCoeffs.glsl", "#define GLSLIFY 1\nuniform vec3 shCoeffs[9];\n\nvec3 sampleSHCoeffs(vec3 dir) {\n  // dir is assumed to have unit length\n  float x = dir.x, y = dir.y, z = dir.z;\n  // band 0\n  vec3 result = shCoeffs[ 0 ] * 0.886227;\n  // band 1\n  result += shCoeffs[ 1 ] * 2.0 * 0.511664 * y;\n  result += shCoeffs[ 2 ] * 2.0 * 0.511664 * z;\n  result += shCoeffs[ 3 ] * 2.0 * 0.511664 * x;\n  // band 2\n  result += shCoeffs[ 4 ] * 2.0 * 0.429043 * x * y;\n  result += shCoeffs[ 5 ] * 2.0 * 0.429043 * y * z;\n  result += shCoeffs[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n  result += shCoeffs[ 7 ] * 2.0 * 0.429043 * x * z;\n  result += shCoeffs[ 8 ] * 0.429043 * ( x * x - y * y );\n  return result;\n}\n"), NC.setShaderModule("gamma.glsl", "#define GLSLIFY 1\nconst float gamma_const = 2.2;\n\nfloat toLinear(float v) {\n  return pow(v, gamma_const);\n}\n\nvec2 toLinear(vec2 v) {\n  return pow(v, vec2(gamma_const));\n}\n\nvec3 toLinear(vec3 v) {\n  return pow(v, vec3(gamma_const));\n}\n\nvec4 toLinear(vec4 v) {\n  return vec4(toLinear(v.rgb), v.a);\n}\n\nfloat toGamma(float v) {\n  return pow(v, 1.0 / gamma_const);\n}\n\nvec2 toGamma(vec2 v) {\n  return pow(v, vec2(1.0 / gamma_const));\n}\n\nvec3 toGamma(vec3 v) {\n  return pow(v, vec3(1.0 / gamma_const));\n}\n\nvec4 toGamma(vec4 v) {\n  return vec4(toGamma(v.rgb), v.a);\n}\n\nfloat toGamma(float v, float gamma) {\n  return pow(v, 1.0 / gamma);\n}\n\nvec2 toGamma(vec2 v, float gamma) {\n  return pow(v, vec2(1.0 / gamma));\n}\n\nvec3 toGamma(vec3 v, float gamma) {\n  return pow(v, vec3(1.0 / gamma));\n}\n\nvec4 toGamma(vec4 v, float gamma) {\n  return vec4(toGamma(v.rgb, gamma), v.a);\n}\n\n"), NC.setShaderModule("inverse.glsl", "#define GLSLIFY 1\n\n#ifndef ENABLE_ES3\n\nfloat inverse(float m) {\n  return 1.0 / m;\n}\n\nmat2 inverse(mat2 m) {\n  return mat2(m[1][1],-m[0][1],\n             -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nmat3 inverse(mat3 m) {\n  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nmat4 inverse(mat4 m) {\n  float\n      a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n      a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n      a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n      a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n\n      b00 = a00 * a11 - a01 * a10,\n      b01 = a00 * a12 - a02 * a10,\n      b02 = a00 * a13 - a03 * a10,\n      b03 = a01 * a12 - a02 * a11,\n      b04 = a01 * a13 - a03 * a11,\n      b05 = a02 * a13 - a03 * a12,\n      b06 = a20 * a31 - a21 * a30,\n      b07 = a20 * a32 - a22 * a30,\n      b08 = a20 * a33 - a23 * a30,\n      b09 = a21 * a32 - a22 * a31,\n      b10 = a21 * a33 - a23 * a31,\n      b11 = a22 * a33 - a23 * a32,\n\n      det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n  return mat4(\n      a11 * b11 - a12 * b10 + a13 * b09,\n      a02 * b10 - a01 * b11 - a03 * b09,\n      a31 * b05 - a32 * b04 + a33 * b03,\n      a22 * b04 - a21 * b05 - a23 * b03,\n      a12 * b08 - a10 * b11 - a13 * b07,\n      a00 * b11 - a02 * b08 + a03 * b07,\n      a32 * b02 - a30 * b05 - a33 * b01,\n      a20 * b05 - a22 * b02 + a23 * b01,\n      a10 * b10 - a11 * b08 + a13 * b06,\n      a01 * b08 - a00 * b10 - a03 * b06,\n      a30 * b04 - a31 * b02 + a33 * b00,\n      a21 * b02 - a20 * b04 - a23 * b00,\n      a11 * b07 - a10 * b09 - a12 * b06,\n      a00 * b09 - a01 * b07 + a02 * b06,\n      a31 * b01 - a30 * b03 - a32 * b00,\n      a20 * b03 - a21 * b01 + a22 * b00) / det;\n}\n\n#endif\n\n"), NC.setShaderModule("transpose.glsl", "#define GLSLIFY 1\n\n#ifndef ENABLE_ES3\n\nfloat transpose(float m) {\n  return m;\n}\n\nmat2 transpose(mat2 m) {\n  return mat2(m[0][0], m[1][0],\n              m[0][1], m[1][1]);\n}\n\nmat3 transpose(mat3 m) {\n  return mat3(m[0][0], m[1][0], m[2][0],\n              m[0][1], m[1][1], m[2][1],\n              m[0][2], m[1][2], m[2][2]);\n}\n\nmat4 transpose(mat4 m) {\n  return mat4(m[0][0], m[1][0], m[2][0], m[3][0],\n              m[0][1], m[1][1], m[2][1], m[3][1],\n              m[0][2], m[1][2], m[2][2], m[3][2],\n              m[0][3], m[1][3], m[2][3], m[3][3]);\n}\n\n#endif\n\n"), NC.setShaderModule("quadVertexFromID.glsl", "#define GLSLIFY 1\nattribute float vertexIDs;\n\nvec2 getQuadVertexPositionFromID() {\n  int vertexID = int(vertexIDs);\n  if (vertexID == 0)\n    return vec2(-0.5, -0.5);\n  else if (vertexID == 1)\n    return vec2(0.5, -0.5);\n  else if (vertexID == 2)\n    return vec2(-0.5, 0.5);\n  else if (vertexID == 3)\n    return vec2(0.5, 0.5);\n  return vec2(0,0);\n}\n"), NC.setShaderModule("unpackHDR.glsl", "#define GLSLIFY 1\n\nvec3 decodeHDR(const in vec3 ldrPixel, const in float cdmAlpha) {\n  float avg = (cdmAlpha * 16.0 - 8.0);\n  float scl = 1.0;\n  vec3 color;\n  color.x = (tan((ldrPixel.x-0.5)*1.5)/scl)+avg;\n  color.y = (tan((ldrPixel.y-0.5)*1.5)/scl)+avg;\n  color.z = (tan((ldrPixel.z-0.5)*1.5)/scl)+avg;\n\n  // convert from logarithmic curve to linear curve.\n  // subtract the epsilon that was added during encoding.\n  const float eps = 0.001;\n  color.x = pow(10.0, color.x) - eps;\n  color.y = pow(10.0, color.y) - eps;\n  color.z = pow(10.0, color.z) - eps;\n  return color;\n}\n\nvec3 decodeHDR(sampler2D ldrSampler, sampler2D cdmSampler, vec2 texCoord) {\n#ifdef ENABLE_ES3\n  float cdm = texture2D(cdmSampler, texCoord).r;\n#else\n  float cdm = texture2D(cdmSampler, texCoord).a;\n#endif\n  return decodeHDR(texture2D(ldrSampler, texCoord).rgb, cdm);\n}\n\n");
  var vC = class extends DC {
    constructor(A3) {
      super(A3, "UnpackHDRShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(position*2.0, 0.0, 1.0);\n}\n"), this.setShaderStage("FRAGMENT_SHADER", " \nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2 v_texCoord;\nuniform sampler2D ldrSampler;\nuniform sampler2D cdmSampler;\nuniform vec4 srcRegion; // pos, and size of the source region\n\nimport 'unpackHDR.glsl'\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec2 srcUv = srcRegion.xy + (v_texCoord * srcRegion.zw);\n\n  fragColor = vec4(decodeHDR(ldrSampler, cdmSampler, srcUv), 1.0);\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n\n");
    }
  };
  var kC = (A3, g3) => {
    let I3, C3, i3;
    switch (g3) {
      case "UInt8":
        I3 = 1, C3 = 4, i3 = A3.UNSIGNED_BYTE;
        break;
      case "SInt8":
        I3 = 1, C3 = 4, i3 = A3.BYTE;
        break;
      case "UInt16":
        I3 = 1, C3 = 4, i3 = A3.UNSIGNED_SHORT;
        break;
      case "SInt16":
        I3 = 1, C3 = 4, i3 = A3.SHORT;
        break;
      case "UInt32":
        I3 = 1, C3 = 4, i3 = A3.UNSIGNED_INT;
        break;
      case "SInt32":
        I3 = 1, C3 = 4, i3 = A3.INT;
        break;
      case "Float32":
        I3 = 1, C3 = 4, i3 = A3.FLOAT;
        break;
      case "Vec2":
        I3 = 2, C3 = 4, i3 = A3.FLOAT;
        break;
      case "Vec3":
        I3 = 3, C3 = 4, i3 = A3.FLOAT;
        break;
      case "Vec4":
      case "Color":
        I3 = 4, C3 = 4, i3 = A3.FLOAT;
        break;
      case "RGBA":
        I3 = 4, C3 = 1, i3 = A3.UNSIGNED_BYTE;
        break;
      default:
        throw "Unhandled Type";
    }
    return {dimension: I3, elementSize: C3, dataType: i3};
  };
  var xC = class {
  };
  var zC = class extends xC {
    constructor(A3, g3, I3, C3) {
      super(), this.gl = A3, this.shaderAttrs = g3, this.glattrbuffers = I3, this.indexBuffer = C3;
    }
    bind(A3) {
      const g3 = this.gl;
      for (const A4 in this.shaderAttrs) {
        if (A4 == "instancedIds")
          continue;
        const I3 = this.shaderAttrs[A4], C3 = I3.location;
        if (C3 == -1)
          continue;
        const i3 = this.glattrbuffers[A4];
        if (!i3) {
          g3.disableVertexAttribArray(C3);
          continue;
        }
        const e3 = kC(this.gl, i3.dataType), t3 = e3.dimension * e3.elementSize, B3 = i3.offset != null ? i3.offset * e3.dimension * e3.elementSize : 0, o3 = i3.normalized == 1, s3 = I3.instanced;
        g3.enableVertexAttribArray(C3), g3.bindBuffer(g3.ARRAY_BUFFER, i3.buffer), g3.vertexAttribPointer(C3, e3.dimension, e3.dataType, o3, t3, B3), g3.vertexAttribDivisor && (s3 == 1 ? g3.vertexAttribDivisor(C3, 1) : g3.vertexAttribDivisor(C3, 0));
      }
      return g3.bindBuffer(g3.ELEMENT_ARRAY_BUFFER, this.indexBuffer), true;
    }
    unbind() {
      const A3 = this.gl;
      for (const g3 in this.shaderAttrs) {
        const I3 = this.shaderAttrs[g3], C3 = I3.location;
        C3 == -1 && A3.enableVertexAttribArray(C3), I3.instanced && A3.vertexAttribDivisor(C3, 0);
      }
      A3.bindBuffer(A3.ELEMENT_ARRAY_BUFFER, null);
    }
    destroy() {
    }
  };
  var TC = class extends xC {
    constructor(A3, g3, I3, C3) {
      super(), this.gl = A3, this.vao = A3.createVertexArray(), A3.bindVertexArray(this.vao);
      for (const C4 in g3) {
        if (C4 == "instancedIds")
          continue;
        const i3 = g3[C4], e3 = i3.location;
        if (e3 == -1)
          continue;
        let t3 = I3[C4];
        if (!t3 && (C4.endsWith("Next") && (t3 = I3[C4.substring(0, C4.length - 4)], i3.offset = 1), !t3)) {
          A3.disableVertexAttribArray(e3);
          continue;
        }
        const B3 = kC(A3, t3.dataType), o3 = B3.dimension * B3.elementSize, s3 = i3.offset != null ? i3.offset * B3.dimension * B3.elementSize : 0, a3 = t3.normalized == 1, l3 = i3.instanced;
        A3.enableVertexAttribArray(e3), A3.bindBuffer(A3.ARRAY_BUFFER, t3.buffer), A3.vertexAttribPointer(e3, B3.dimension, B3.dataType, a3, o3, s3), A3.vertexAttribDivisor && (l3 == 1 ? A3.vertexAttribDivisor(e3, 1) : A3.vertexAttribDivisor(e3, 0));
      }
      this.indexBuffer = C3, this.indexBuffer && A3.bindBuffer(A3.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
    }
    bind(A3) {
      const g3 = this.gl;
      return g3.bindVertexArray(this.vao), this.indexBuffer && g3.bindBuffer(g3.ELEMENT_ARRAY_BUFFER, this.indexBuffer), true;
    }
    unbind() {
      const A3 = this.gl;
      A3.bindVertexArray(null), this.indexBuffer && A3.bindBuffer(A3.ELEMENT_ARRAY_BUFFER, null);
    }
    destroy() {
      const A3 = this.gl;
      this.indexBuffer && (A3.bindVertexArray(this.vao), A3.bindBuffer(A3.ELEMENT_ARRAY_BUFFER, null)), A3.deleteVertexArray(this.vao);
    }
  };
  function _C(A3, g3, I3, C3) {
    return A3.createVertexArray == null ? new zC(A3, g3, I3, C3) : new TC(A3, g3, I3, C3);
  }
  var PC = class {
    constructor(A3) {
      this.stack = [], this.gl = A3, this.pushGLStack();
    }
    pushGLStack() {
      this.top = {enabled: new Set(), disabled: new Set(), functions: {}}, this.stack.push(this.top);
    }
    popGLStack() {
      const A3 = this.top;
      this.top = this.stack.pop(), this.stack.length > 0 && (A3.enabled.forEach((A4) => {
        let g3;
        for (g3 = this.stack.length - 1; g3 >= 0; g3--) {
          const I3 = this.stack[g3];
          if (I3.enabled.has(A4))
            break;
          if (I3.disabled.has(A4)) {
            this.gl.disable(A4);
            break;
          }
        }
        g3 < 0 && this.gl.disable(A4);
      }), A3.disabled.forEach((A4) => {
        let g3;
        for (g3 = this.stack.length - 1; g3 >= 0; g3--) {
          const I3 = this.stack[g3];
          if (I3.disabled.has(A4))
            break;
          if (I3.enabled.has(A4)) {
            this.gl.enable(A4);
            break;
          }
        }
        g3 < 0 && this.gl.enable(A4);
      }));
    }
    glEnable(A3) {
      this.gl.enable(A3), this.top.enabled.add(A3);
    }
    glDisable(A3) {
      this.gl.disable(A3), this.top.disabled.add(A3);
    }
    setGLParam(A3, g3) {
      this.top[A3] = g3, Array.isArray(g3) ? this.gl[A3](...g3) : this.gl[A3](g3);
    }
  };
  var OC = class extends PC {
  };
  var jC = class extends PC {
    toHighlightRenderState() {
      const A3 = new OC(this.gl);
      return A3.boundRendertarget = this.boundRendertarget, A3.viewXfo = this.viewXfo, A3.viewScale = this.viewScale, A3.region = this.region, A3.cameraMatrix = this.cameraMatrix, A3.viewport = this.viewport, A3.viewports = this.viewports, A3.vrPresenting = this.vrPresenting, A3;
    }
  };
  var qC = class extends PC {
  };
  var $C = class extends HC {
    constructor(A3, g3) {
      super(A3), this.listenerIDs = {}, this.fbo = null, this.srcLDRTex = null, this.srcCDMTex = null, this.unpackHDRShader = null, this.shaderBinding = null, this.hdrImage = g3;
      const I3 = () => {
        this.__unpackHDRImage(this.hdrImage.getParams());
      };
      this.listenerIDs.updated = this.hdrImage.on("updated", I3), this.hdrImage.isLoaded() ? I3() : this.listenerIDs.loaded = this.hdrImage.on("loaded", I3);
    }
    getImage() {
      return this.hdrImage;
    }
    __unpackHDRImage(A3) {
      const g3 = this.__gl, I3 = A3.data.ldr, C3 = A3.data.cdm;
      if (this.fbo)
        this.srcLDRTex.bufferData(I3), this.srcCDMTex.bufferData(C3);
      else {
        this.configure({format: "RGBA", type: "FLOAT", width: I3.width, height: I3.height, filter: "LINEAR", wrap: "CLAMP_TO_EDGE"}), this.fbo = new fC(this.__gl, this), this.fbo.setClearColor(new l(0, 0, 0, 0)), this.srcLDRTex = new HC(this.__gl, {format: "RGB", type: "UNSIGNED_BYTE", width: I3.width, height: I3.height, filter: "NEAREST", mipMapped: false, wrap: "CLAMP_TO_EDGE", data: I3}), this.srcCDMTex = new HC(this.__gl, {format: g3.name == "webgl2" ? "RED" : "ALPHA", type: "UNSIGNED_BYTE", width: I3.width, height: I3.height, filter: "NEAREST", mipMapped: false, wrap: "CLAMP_TO_EDGE", data: C3}), this.unpackHDRShader = new vC(this.__gl);
        const A4 = this.unpackHDRShader.compileForTarget("GLHDRImage", {directives: ["#define ENABLE_ES3"]});
        this.shaderBinding = _C(this.__gl, A4.attrs, g3.__quadattrbuffers, g3.__quadIndexBuffer);
      }
      this.fbo.bindAndClear();
      const i3 = new PC(g3);
      this.unpackHDRShader.bind(i3, "GLHDRImage"), this.shaderBinding.bind(i3);
      const e3 = i3.unifs;
      this.srcLDRTex.bindToUniform(i3, e3.ldrSampler), this.srcCDMTex.bindToUniform(i3, e3.cdmSampler), g3.uniform4fv(e3.srcRegion.location, [0, 0, 1, 1]), g3.drawQuad(), this.fbo.unbind(), this.emit("updated");
    }
    bindToUniform(A3, g3, I3) {
      return super.bindToUniform(A3, g3, I3);
    }
    destroy() {
      super.destroy(), this.fbo && (this.fbo.destroy(), this.srcLDRTex.destroy(), this.srcCDMTex.destroy()), this.unpackHDRShader && this.unpackHDRShader.destroy(), this.shaderBinding && this.shaderBinding.destroy(), "loaded" in this.listenerIDs && this.hdrImage.removeListenerById("loaded", this.listenerIDs.loaded), this.hdrImage.removeListenerById("updated", this.listenerIDs.updated);
    }
  };
  var Ai = class extends DC {
    constructor(A3) {
      super(A3, "PreComputeBRDFShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(position*2.0, 0.0, 1.0);\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nvarying vec2 v_texCoord;\n\nimport 'GLSLUtils.glsl'\nimport 'Hammersley.glsl'\nimport 'ImportanceSampleGGX.glsl'\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n  float a = roughness;\n  float k = (a * a) / 2.0;\n\n  float nom   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return nom / denom;\n}\n// ----------------------------------------------------------------------------\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n\nvec2 IntegrateBRDF(float NdotV, float roughness)\n{\n  vec3 V;\n  V.x = sqrt(1.0 - NdotV*NdotV);\n  V.y = 0.0;\n  V.z = NdotV;\n\n  float A = 0.0;\n  float B = 0.0;\n\n  vec3 N = vec3(0.0, 0.0, 1.0);\n\n  for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n  {\n    vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n    vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n    vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n    float NdotL = max(L.z, 0.0);\n    float NdotH = max(H.z, 0.0);\n    float VdotH = max(dot(V, H), 0.0);\n\n    if (NdotL > 0.0)\n    {\n      float G = GeometrySmith(N, V, L, roughness);\n      float G_Vis = (G * VdotH) / (NdotH * NdotV);\n      float Fc = pow(1.0 - VdotH, 5.0);\n\n      A += (1.0 - Fc) * G_Vis;\n      B += Fc * G_Vis;\n    }\n  }\n  A /= float(SAMPLE_COUNT);\n  B /= float(SAMPLE_COUNT);\n  return vec2(A, B);\n}\n\nout vec2 fragColor;\nvoid main(void) {\n  vec2 integratedBRDF = IntegrateBRDF(v_texCoord.x, v_texCoord.y);\n  fragColor = integratedBRDF;\n}\n\n");
    }
  };
  var gi = class extends DC {
    constructor(A3) {
      super(A3, "ConvolveIrradianceShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(position*2.0, 0.0, 1.0);\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\nimport 'constants.glsl'\nimport 'convolve-helpers.glsl'\n\nuniform float roughness;\nuniform int faceId;\nvarying vec2 v_texCoord;\n\nout vec4 fragColor;\nvoid main(void) {\n\n  vec3 N = cubeFaceUvToDir(v_texCoord.x, v_texCoord.y, faceId);   \n\n  vec3 irradiance = vec3(0.0);\n\n  vec3 up        = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n  vec3 tangent   = normalize(cross(up, N));\n  vec3 bitangent = cross(N, tangent);\n\n  float nrSamples = 0.0; \n  for(float phi = 0.0; phi < 2.0 * PI; phi += SAMPLE_DELTA)\n  {\n    for(float theta = 0.0; theta < 0.5 * PI; theta += SAMPLE_DELTA)\n    {\n      // spherical to cartesian (in tangent space)\n      // from spherical coordinates to cartesian coordinates\n      vec3 H = vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));\n      // tangent space to world\n      vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n\n      irradiance += sampleEnvMap(normalize(sampleVec)).rgb * cos(theta) * sin(theta);\n      nrSamples++;\n    }\n  }\n  irradiance = PI * irradiance * (1.0 / float(nrSamples));\n\n  fragColor = vec4(irradiance, 1.0);\n}\n");
    }
  };
  var Ii = class extends DC {
    constructor(A3) {
      super(A3, "ConvolveSpecularShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(position*2.0, 0.0, 1.0);\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "precision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'ImportanceSampleGGX.glsl'\nimport 'convolve-helpers.glsl'\nimport 'Hammersley.glsl'\n  \n  \nuniform float roughness;\nuniform int faceId;\nvarying vec2 v_texCoord;\n\nout vec4 fragColor;\nvoid main(void) {\n\n  vec3 N = cubeFaceUvToDir(v_texCoord.x, v_texCoord.y, faceId);   \n\n  vec3 R = N;\n  vec3 V = R;\n\n  float totalWeight = 0.0;   \n  vec3 prefilteredColor = vec3(0.0);     \n  for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n  {\n    vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n    vec3 H  = ImportanceSampleGGX(Xi, N, roughness);\n    vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n\n    float NdotL = max(dot(N, L), 0.0);\n    if (NdotL > 0.0)\n    {\n      prefilteredColor += sampleEnvMap(L).rgb * NdotL;\n      totalWeight      += NdotL;\n    }\n  }\n  prefilteredColor = prefilteredColor / totalWeight;\n\n  fragColor = vec4(prefilteredColor, 1.0);\n}\n");
    }
  };
  var Ci = class extends V {
    constructor(A3, g3) {
      super(), this.__gl = A3;
      const I3 = A3;
      this.maxFragmentShaderTextureUnits = A3.getParameter(this.__gl.MAX_TEXTURE_IMAGE_UNITS), I3.__quadVertexIdsBuffer || I3.setupInstancedQuad(), this.textureType = 1, this.textureDesc = [0, 0, 0, 0], this.__convolved = false, this.__fbos = [];
    }
    convolveProbe(A3) {
      const I3 = this.__gl, C3 = new PC(I3);
      C3.shaderopts = {directives: ["#define ENABLE_ES3", "#define ENABLE_FLOAT_TEXTURES"]}, g.deviceCategory == "Low" ? (C3.shaderopts.directives.push("#define SAMPLE_DELTA 0.1"), C3.shaderopts.directives.push("#define SAMPLE_COUNT 64u")) : g.deviceCategory == "Medium" ? (C3.shaderopts.directives.push("#define SAMPLE_DELTA 0.08"), C3.shaderopts.directives.push("#define SAMPLE_COUNT 256u")) : (C3.shaderopts.directives.push("#define SAMPLE_DELTA 0.025"), C3.shaderopts.directives.push("#define SAMPLE_COUNT 1024u")), this.brdfLUTTexture = I3.createTexture(), I3.bindTexture(I3.TEXTURE_2D, this.brdfLUTTexture), I3.texImage2D(I3.TEXTURE_2D, 0, I3.RG16F, 512, 512, 0, I3.RG, I3.FLOAT, null), I3.texParameteri(I3.TEXTURE_2D, I3.TEXTURE_WRAP_S, I3.CLAMP_TO_EDGE), I3.texParameteri(I3.TEXTURE_2D, I3.TEXTURE_WRAP_T, I3.CLAMP_TO_EDGE), I3.texParameteri(I3.TEXTURE_2D, I3.TEXTURE_MIN_FILTER, I3.LINEAR), I3.texParameteri(I3.TEXTURE_2D, I3.TEXTURE_MAG_FILTER, I3.LINEAR);
      const i3 = new Ai(this.__gl), e3 = i3.compileForTarget("GLProbe", C3.shaderopts), t3 = _C(this.__gl, e3.attrs, I3.__quadattrbuffers, I3.__quadIndexBuffer), B3 = I3.createFramebuffer();
      I3.bindFramebuffer(I3.DRAW_FRAMEBUFFER, B3), I3.framebufferTexture2D(I3.DRAW_FRAMEBUFFER, I3.COLOR_ATTACHMENT0, I3.TEXTURE_2D, this.brdfLUTTexture, 0), i3.bind(C3), t3.bind(C3), I3.clear(I3.COLOR_BUFFER_BIT | I3.DEPTH_BUFFER_BIT), I3.viewport(0, 0, 512, 512), I3.drawQuad(), I3.bindFramebuffer(I3.DRAW_FRAMEBUFFER, null), I3.deleteFramebuffer(B3), i3.unbind(C3), i3.destroy();
      {
        const g3 = new gi(this.__gl), i4 = g3.compileForTarget("GLProbe", C3.shaderopts), e4 = _C(this.__gl, i4.attrs, I3.__quadattrbuffers, I3.__quadIndexBuffer);
        g3.bind(C3, "GLProbe"), e4.bind(C3);
        const t4 = C3.unifs;
        A3.bindToUniform(C3, t4.envMap);
        const B4 = 64;
        this.irradianceCubeTex = I3.createTexture(), I3.bindTexture(I3.TEXTURE_CUBE_MAP, this.irradianceCubeTex), I3.texParameteri(I3.TEXTURE_CUBE_MAP, I3.TEXTURE_MAG_FILTER, I3.LINEAR), I3.texParameteri(I3.TEXTURE_CUBE_MAP, I3.TEXTURE_MIN_FILTER, I3.LINEAR_MIPMAP_LINEAR), I3.texParameteri(I3.TEXTURE_CUBE_MAP, I3.TEXTURE_WRAP_S, I3.CLAMP_TO_EDGE), I3.texParameteri(I3.TEXTURE_CUBE_MAP, I3.TEXTURE_WRAP_T, I3.CLAMP_TO_EDGE), I3.texParameteri(I3.TEXTURE_CUBE_MAP, I3.TEXTURE_WRAP_R, I3.CLAMP_TO_EDGE);
        for (let A4 = 0; A4 < 6; A4++)
          I3.texImage2D(I3.TEXTURE_CUBE_MAP_POSITIVE_X + A4, 0, I3.RGBA32F, B4, B4, 0, I3.RGBA, I3.FLOAT, null);
        const o3 = I3.createFramebuffer();
        I3.bindFramebuffer(I3.DRAW_FRAMEBUFFER, o3);
        for (let A4 = 0; A4 < 6; ++A4)
          I3.uniform1i(t4.faceId.location, A4), I3.framebufferTexture2D(I3.DRAW_FRAMEBUFFER, I3.COLOR_ATTACHMENT0, I3.TEXTURE_CUBE_MAP_POSITIVE_X + A4, this.irradianceCubeTex, 0), I3.viewport(0, 0, B4, B4), I3.clearColor(1, 0, 0, 1), I3.clear(I3.COLOR_BUFFER_BIT | I3.DEPTH_BUFFER_BIT), I3.drawQuad();
        I3.bindFramebuffer(I3.DRAW_FRAMEBUFFER, null), I3.deleteFramebuffer(o3), I3.generateMipmap(I3.TEXTURE_CUBE_MAP);
      }
      {
        const g3 = new Ii(this.__gl), i4 = g3.compileForTarget("GLProbe", C3.shaderopts), e4 = _C(this.__gl, i4.attrs, I3.__quadattrbuffers, I3.__quadIndexBuffer);
        g3.bind(C3, "GLProbe"), e4.bind(C3);
        const t4 = C3.unifs;
        A3.bindToUniform(C3, t4.envMap), this.specularCubetex = I3.createTexture(), I3.bindTexture(I3.TEXTURE_CUBE_MAP, this.specularCubetex), I3.texParameteri(I3.TEXTURE_CUBE_MAP, I3.TEXTURE_MAG_FILTER, I3.LINEAR), I3.texParameteri(I3.TEXTURE_CUBE_MAP, I3.TEXTURE_MIN_FILTER, I3.LINEAR_MIPMAP_LINEAR), I3.texParameteri(I3.TEXTURE_CUBE_MAP, I3.TEXTURE_WRAP_S, I3.CLAMP_TO_EDGE), I3.texParameteri(I3.TEXTURE_CUBE_MAP, I3.TEXTURE_WRAP_T, I3.CLAMP_TO_EDGE), I3.texParameteri(I3.TEXTURE_CUBE_MAP, I3.TEXTURE_WRAP_R, I3.CLAMP_TO_EDGE);
        const B4 = 256;
        for (let A4 = 0; A4 < 6; A4++)
          I3.texImage2D(I3.TEXTURE_CUBE_MAP_POSITIVE_X + A4, 0, I3.RGBA32F, B4, B4, 0, I3.RGBA, I3.FLOAT, null);
        I3.generateMipmap(I3.TEXTURE_CUBE_MAP);
        const o3 = 5;
        for (let A4 = 0; A4 < o3; ++A4) {
          const g4 = B4 * Math.pow(0.5, A4), C4 = B4 * Math.pow(0.5, A4), i5 = I3.createFramebuffer();
          I3.bindFramebuffer(I3.DRAW_FRAMEBUFFER, i5), I3.viewport(0, 0, g4, C4);
          const e5 = A4 / (o3 - 1);
          I3.uniform1f(t4.roughness.location, e5);
          for (let g5 = 0; g5 < 6; ++g5)
            I3.uniform1i(t4.faceId.location, g5), I3.framebufferTexture2D(I3.DRAW_FRAMEBUFFER, I3.COLOR_ATTACHMENT0, I3.TEXTURE_CUBE_MAP_POSITIVE_X + g5, this.specularCubetex, A4), I3.drawQuad();
          I3.bindFramebuffer(I3.DRAW_FRAMEBUFFER, null), I3.deleteFramebuffer(i5);
        }
        g3.destroy();
      }
      this.__convolved = true;
    }
    bind(A3) {
      const g3 = this.__gl, {irradianceMap: I3, prefilterMap: C3, brdfLUT: i3, envMapFlags: e3} = A3.unifs;
      if (!this.__convolved)
        return I3 && g3.uniform1i(I3.location, this.maxFragmentShaderTextureUnits - 1), C3 && g3.uniform1i(C3.location, this.maxFragmentShaderTextureUnits - 1), e3 && g3.uniform1i(e3.location, -1), false;
      if (i3) {
        const I4 = A3.boundTextures++;
        g3.activeTexture(this.__gl.TEXTURE0 + I4), g3.bindTexture(g3.TEXTURE_2D, this.brdfLUTTexture), g3.uniform1i(i3.location, I4);
      }
      if (I3) {
        const C4 = A3.boundTextures++, i4 = this.__gl.TEXTURE0 + C4;
        g3.activeTexture(i4), g3.bindTexture(g3.TEXTURE_CUBE_MAP, this.irradianceCubeTex), g3.uniform1i(I3.location, C4);
      }
      if (C3) {
        const I4 = A3.boundTextures++, i4 = this.__gl.TEXTURE0 + I4;
        g3.activeTexture(i4), g3.bindTexture(g3.TEXTURE_CUBE_MAP, this.specularCubetex), g3.uniform1i(C3.location, I4);
      }
      return e3 && g3.uniform1i(e3.location, 0), true;
    }
    destroy() {
    }
  };
  var ii = class extends DC {
    constructor(A3) {
      super(A3, "EnvMapShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\n\nimport 'inverse.glsl'\nimport 'transpose.glsl'\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID() * 2.0;\n  v_texCoord = position * 0.5 + 0.5;\n\n  mat4 inverseProjection = inverse(projectionMatrix);\n  mat3 inverseModelview = transpose(mat3(viewMatrix));\n\n  // transform from the normalized device coordinates back to the view space\n  vec3 unprojected = (inverseProjection * vec4(position, 0, 1)).xyz;\n\n  // transfrom from the view space back to the world space\n  // and use it as a sampling vector\n  v_worldDir = inverseModelview * unprojected;\n\n  gl_Position = vec4(position, 0, 1);\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'gamma.glsl'\nimport 'constants.glsl'\n\nuniform float focus;\nuniform float exposure;\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\nvarying vec2 v_texCoord;\n\n#define ENABLE_INLINE_GAMMACORRECTION\n\n#define ENV_MAP_LATLONG 0\n#define ENV_MAP_OCT 1\n#define ENV_MAP_CUBE 2\n#define ENV_MAP_irradianceMap 8\n#define ENV_MAP_prefilterMap 3\n#define ENV_MAP_STEREO_LATLONG 4\n#define ENV_MAP_DUALFISHEYE 5\n#define ENV_MAP_SH 6\n#define ENV_MAP_BRDF_LUT 7\n\n#define ENV_MAPTYPE ENV_MAP_OCT\n\n#if (ENV_MAPTYPE == ENV_MAP_LATLONG)  \n\nimport 'envmap-equirect.glsl'\n\nuniform sampler2D backgroundImage;\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = latLongUVsFromDir(normalize(dir));\n  vec4 texel = texture2D(backgroundImage, uv) * exposure;\n  return vec4(texel.rgb/texel.a, 1.0);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_OCT)  \n\nimport 'envmap-octahedral.glsl'\n\nuniform sampler2D   envMap;\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = dirToSphOctUv(normalize(dir));\n  if (false) {\n    vec4 texel = texture2D(envMap, uv);\n    return vec4(texel.rgb/texel.a, 1.0);\n  }\n  else {\n    return texture2D(envMap, uv) * exposure;\n  }\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_CUBE)\n\nuniform samplerCube cubeMap;\n\nvec4 sampleEnvMap(vec3 dir) {\n  return texture(cubeMap, dir, 0.0);// * exposure;\n  // return textureLod(cubeMap, dir, exposure);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_irradianceMap)\n\nuniform samplerCube irradianceMap;\n\nvec4 sampleEnvMap(vec3 dir) {\n  return textureLod(irradianceMap, dir, exposure);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_prefilterMap)\n\nuniform samplerCube prefilterMap;\n\nvec4 sampleEnvMap(vec3 dir) {\n  return textureLod(prefilterMap, dir, exposure);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_STEREO_LATLONG)  \n\nimport 'envmap-equirect.glsl'\nuniform int eye;// L = 0, R = 1;\nuniform sampler2D backgroundImage;\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = latLongUVsFromDir(normalize(v_worldDir));\n  uv.y *= 0.5;\n  if (eye == 1) {\n    uv.y += 0.5;\n  }\n  vec4 texel = texture2D(backgroundImage, uv) * exposure;\n  fragColor = vec4(texel.rgb/texel.a, 1.0);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_DUALFISHEYE)\n\nimport 'envmap-dualfisheye.glsl'\n\nvec4 sampleEnvMap(vec3 dir) {\n  vec2 uv = dualfisheyeUVsFromDir(dir);\n  return texture2D(backgroundImage, uv) * exposure;\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_SH)\n\nimport 'SHCoeffs.glsl'\n\nvec4 sampleEnvMap(vec3 dir) {\n	return vec4(sampleSHCoeffs(dir) * exposure, 1.0);\n}\n\n#elif (ENV_MAPTYPE == ENV_MAP_BRDF_LUT)\n\nuniform sampler2D brdfLUT;\n\nvec4 sampleEnvMap(vec3 dir) {\n  return texture2D(brdfLUT, v_texCoord);\n}\n#endif\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  fragColor = sampleEnvMap(normalize(v_worldDir));\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb);\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n");
    }
  };
  var ei = class extends Ci {
    constructor(A3, g3) {
      super(A3.gl, "EnvMap"), this.__srcGLTex = null, this.__envMapShader = null, this.__envMapShaderBinding = null, this.__renderer = A3, this.__envMap = g3, this.__backgroundFocus = 0, this.__envMap.isLoaded() ? this.init() : this.__envMap.once("loaded", (A4) => {
        this.init();
      });
    }
    init() {
      const A3 = this.__renderer.gl;
      A3.__quadVertexIdsBuffer || A3.setupInstancedQuad(), this.__srcGLTex = new $C(A3, this.__envMap), this.__envMapShader = new ii(A3);
      const g3 = this.__envMapShader.compileForTarget("GLEnvMap", {directives: ["#define ENABLE_ES3"]});
      this.__envMapShaderBinding = _C(A3, g3.attrs, A3.__quadattrbuffers, A3.__quadIndexBuffer);
      const I3 = this.__envMap.headlightModeParam, C3 = () => {
        I3.value ? this.textureDesc[3] |= 1 : this.textureDesc[3] &= -2;
      };
      C3(), I3.on("valueChanged", () => {
        C3(), this.emit("updated");
      }), this.convolveProbe(this.__srcGLTex), this.emit("updated");
    }
    getEnvMap() {
      return this.__envMap;
    }
    getBackgroundFocus() {
      return this.__backgroundFocus;
    }
    setBackgroundFocus(A3) {
      this.__backgroundFocus = A3, this.__renderer.requestRedraw();
    }
    draw(A3) {
      if (this.__envMap.isLoaded()) {
        const g3 = this.__gl;
        {
          this.__envMapShader.bind(A3, "GLEnvMap");
          const I3 = A3.unifs, {envMap: C3, focus: i3, exposure: e3} = A3.unifs;
          C3 && this.__srcGLTex.bindToUniform(A3, C3), i3 && g3.uniform1f(i3.location, this.__backgroundFocus), e3 && g3.uniform1f(e3.location, A3.exposure), this.__envMapShaderBinding.bind(A3), g3.depthMask(false), A3.bindViewports(I3, () => {
            g3.drawQuad();
          }), g3.depthMask(true);
        }
      }
    }
    destroy() {
      super.destroy(), this.__srcGLTex && this.__srcGLTex.destroy();
    }
  };
  function ti(A3) {
    var g3 = typeof A3;
    return A3 != null && (g3 == "object" || g3 == "function");
  }
  var Bi = typeof global == "object" && global && global.Object === Object && global;
  var oi = typeof self == "object" && self && self.Object === Object && self;
  var si = Bi || oi || Function("return this")();
  var ai = function() {
    return si.Date.now();
  };
  var li = /\s/;
  var ni = /^\s+/;
  function di(A3) {
    return A3 ? A3.slice(0, function(A4) {
      for (var g3 = A4.length; g3-- && li.test(A4.charAt(g3)); )
        ;
      return g3;
    }(A3) + 1).replace(ni, "") : A3;
  }
  var hi = si.Symbol;
  var ci = Object.prototype;
  var ri = ci.hasOwnProperty;
  var Gi = ci.toString;
  var mi = hi ? hi.toStringTag : void 0;
  var Qi = Object.prototype.toString;
  var Ei = hi ? hi.toStringTag : void 0;
  function bi(A3) {
    return A3 == null ? A3 === void 0 ? "[object Undefined]" : "[object Null]" : Ei && Ei in Object(A3) ? function(A4) {
      var g3 = ri.call(A4, mi), I3 = A4[mi];
      try {
        A4[mi] = void 0;
        var C3 = true;
      } catch (A5) {
      }
      var i3 = Gi.call(A4);
      return C3 && (g3 ? A4[mi] = I3 : delete A4[mi]), i3;
    }(A3) : function(A4) {
      return Qi.call(A4);
    }(A3);
  }
  var Zi = /^[-+]0x[0-9a-f]+$/i;
  var yi = /^0b[01]+$/i;
  var ui = /^0o[0-7]+$/i;
  var Ri = parseInt;
  function Vi(A3) {
    if (typeof A3 == "number")
      return A3;
    if (function(A4) {
      return typeof A4 == "symbol" || function(A5) {
        return A5 != null && typeof A5 == "object";
      }(A4) && bi(A4) == "[object Symbol]";
    }(A3))
      return NaN;
    if (ti(A3)) {
      var g3 = typeof A3.valueOf == "function" ? A3.valueOf() : A3;
      A3 = ti(g3) ? g3 + "" : g3;
    }
    if (typeof A3 != "string")
      return A3 === 0 ? A3 : +A3;
    A3 = di(A3);
    var I3 = yi.test(A3);
    return I3 || ui.test(A3) ? Ri(A3.slice(2), I3 ? 2 : 8) : Zi.test(A3) ? NaN : +A3;
  }
  var Fi = Math.max;
  var Si = Math.min;
  function wi(A3, g3, I3) {
    var C3, i3, e3, t3, B3, o3, s3 = 0, a3 = false, l3 = false, n3 = true;
    if (typeof A3 != "function")
      throw new TypeError("Expected a function");
    function d3(g4) {
      var I4 = C3, e4 = i3;
      return C3 = i3 = void 0, s3 = g4, t3 = A3.apply(e4, I4);
    }
    function h3(A4) {
      return s3 = A4, B3 = setTimeout(r3, g3), a3 ? d3(A4) : t3;
    }
    function c3(A4) {
      var I4 = A4 - o3;
      return o3 === void 0 || I4 >= g3 || I4 < 0 || l3 && A4 - s3 >= e3;
    }
    function r3() {
      var A4 = ai();
      if (c3(A4))
        return G3(A4);
      B3 = setTimeout(r3, function(A5) {
        var I4 = g3 - (A5 - o3);
        return l3 ? Si(I4, e3 - (A5 - s3)) : I4;
      }(A4));
    }
    function G3(A4) {
      return B3 = void 0, n3 && C3 ? d3(A4) : (C3 = i3 = void 0, t3);
    }
    function m3() {
      var A4 = ai(), I4 = c3(A4);
      if (C3 = arguments, i3 = this, o3 = A4, I4) {
        if (B3 === void 0)
          return h3(o3);
        if (l3)
          return clearTimeout(B3), B3 = setTimeout(r3, g3), d3(o3);
      }
      return B3 === void 0 && (B3 = setTimeout(r3, g3)), t3;
    }
    return g3 = Vi(g3) || 0, ti(I3) && (a3 = !!I3.leading, e3 = (l3 = "maxWait" in I3) ? Fi(Vi(I3.maxWait) || 0, g3) : e3, n3 = "trailing" in I3 ? !!I3.trailing : n3), m3.cancel = function() {
      B3 !== void 0 && clearTimeout(B3), s3 = 0, C3 = o3 = i3 = B3 = void 0;
    }, m3.flush = function() {
      return B3 === void 0 ? t3 : G3(ai());
    }, m3;
  }
  var Xi = class extends DC {
    constructor(A3) {
      super(A3, "ScreenQuadShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\nuniform vec2 pos;\nuniform vec2 size;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(vec2(-1.0, -1.0) + (pos * 2.0) + (v_texCoord * abs(size) * 2.0), 0.0, 1.0);\n  if (size.x < 0.0)\n    v_texCoord.x = 1.0 - v_texCoord.x;\n  if (size.y < 0.0)\n    v_texCoord.y = 1.0 - v_texCoord.y;\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D image;\nuniform vec4 color;\nuniform int isTextured;\n\nvarying vec2 v_texCoord;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  if (isTextured != 0)\n    fragColor = texture2D(image, v_texCoord);\n  else \n    fragColor = color;\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n");
    }
  };
  var Hi = class {
    constructor(A3, g3) {
      this.__gl = A3, this.__pos = [0, 0], this.__size = [1, 1], this.flipY = true, this.__glshader = new Xi(A3), A3.__quadVertexIdsBuffer || A3.setupInstancedQuad();
      const I3 = this.__glshader.compileForTarget("GLScreenQuad", g3);
      this.__quadBinding = _C(this.__gl, I3.attrs, A3.__quadattrbuffers, A3.__quadIndexBuffer), this.ready = true;
    }
    bind(A3, g3, I3, C3) {
      const i3 = A3.unifs, e3 = this.__gl;
      g3 && g3 instanceof HC ? (e3.uniform1i(i3.isTextured.location, 1), g3.bindToUniform(A3, A3.unifs.image)) : g3 && g3 instanceof l && (e3.uniform1i(i3.isTextured.location, 0), e3.uniform4fv(i3.color.location, g3.asArray()));
      {
        const A4 = i3.pos;
        if (A4) {
          let g4 = I3 ? I3 instanceof B ? I3.asArray() : I3 : this.__pos;
          e3.uniform2fv(A4.location, g4);
        }
      }
      {
        const A4 = i3.size;
        if (A4) {
          let g4 = C3 ? C3 instanceof B ? C3.asArray() : C3 : this.__size;
          e3.uniform2fv(A4.location, g4);
        }
      }
      this.__quadBinding.bind(A3);
    }
    bindShader(A3) {
      return this.__glshader.bind(A3, "GLScreenQuad");
    }
    draw(A3, g3, I3, C3) {
      this.bind(A3, g3, I3, C3);
      const i3 = this.__gl;
      i3.drawElements(i3.TRIANGLES, 6, i3.UNSIGNED_SHORT, 0);
    }
  };
  var Wi = class extends lA {
    constructor(A3, g3) {
      super(), this.genBufferOpts = {}, this.__indexBuffer = null, this.__gl = A3, this.__geom = g3, this.__glattrbuffers = {}, this.__shaderBindings = {}, this.buffersDirty = true;
      this.__geom.on("geomDataChanged", (A4) => {
        this.dirtyBuffers(A4);
      });
      this.__geom.on("geomDataTopologyChanged", (A4) => {
        this.clearBuffers(), this.dirtyBuffers(A4);
      });
    }
    getGeom() {
      return this.__geom;
    }
    dirtyBuffers(A3) {
      this.genBufferOpts = A3, this.buffersDirty = true, this.emit("updated");
    }
    genBuffers(A3) {
    }
    updateBuffers(A3) {
      this.genBuffers(A3), this.buffersDirty = false;
    }
    bind(A3) {
      if (this.__destroyed)
        throw new Error("Error binding a destroyed geom");
      this.buffersDirty && this.updateBuffers();
      let g3 = this.__shaderBindings[A3.shaderkey];
      if (!g3) {
        g3 = _C(this.__gl, A3.attrs, this.__glattrbuffers, this.__indexBuffer), this.__shaderBindings[A3.shaderkey] = g3;
      }
      g3.bind(A3);
    }
    unbind(A3) {
      const g3 = this.__shaderBindings[A3.shaderkey];
      g3 && g3.unbind(A3);
    }
    draw(A3) {
      throw new Error("Not implemented. Implement this method in a derived class.");
    }
    drawInstanced(A3, g3) {
      throw new Error("Not implemented. Implement this method in a derived class.");
    }
    bindAndDraw(A3) {
      this.bind(A3), this.draw(A3);
    }
    clearBuffers() {
      const A3 = this.__gl;
      for (const g3 in this.__glattrbuffers) {
        const I3 = this.__glattrbuffers[g3];
        I3.shared || A3.deleteBuffer(I3.buffer);
      }
      this.__glattrbuffers = {};
      for (const A4 in this.__shaderBindings) {
        this.__shaderBindings[A4].destroy();
      }
      this.__shaderBindings = {};
    }
    destroy() {
      this.__geom.deleteMetadata("glgeom"), this.clearBuffers(), this.__destroyed = true, this.emit("destructing");
    }
  };
  var Yi = class extends Wi {
    constructor(A3, g3) {
      super(A3, g3), this.__numTriIndices = 0, this.__indexDataType = 0, this.__numVertices = 0, this.__numTriangles = 0, this.__numRenderVerts = 0;
    }
    genBuffers() {
      super.genBuffers();
      const A3 = this.__gl, g3 = this.__geom.genBuffers(), I3 = g3.indices;
      this.__numTriIndices = g3.indices.length, I3 instanceof Uint8Array && (this.__indexDataType = this.__gl.UNSIGNED_BYTE), I3 instanceof Uint16Array && (this.__indexDataType = this.__gl.UNSIGNED_SHORT), I3 instanceof Uint32Array && (this.__indexDataType = this.__gl.UNSIGNED_INT), this.__numVertices = this.__geom.getNumVertices(), this.__numTriangles = I3.length / 3, this.__numRenderVerts = g3.numRenderVerts, this.__indexBuffer && A3.deleteBuffer(this.__indexBuffer), this.__indexBuffer = A3.createBuffer(), A3.bindBuffer(A3.ELEMENT_ARRAY_BUFFER, this.__indexBuffer), A3.bufferData(A3.ELEMENT_ARRAY_BUFFER, g3.indices, A3.STATIC_DRAW);
      for (const I4 in g3.attrBuffers) {
        const C3 = g3.attrBuffers[I4];
        this.__glattrbuffers[I4] && this.__glattrbuffers[I4].buffer && A3.deleteBuffer(this.__glattrbuffers[I4].buffer);
        const i3 = A3.createBuffer();
        A3.bindBuffer(A3.ARRAY_BUFFER, i3), A3.bufferData(A3.ARRAY_BUFFER, C3.values, A3.STATIC_DRAW), this.__glattrbuffers[I4] = {buffer: i3, dataType: C3.dataType, normalized: C3.normalized}, I4 == "textureCoords" && (this.__glattrbuffers.texCoords = this.__glattrbuffers.textureCoords);
      }
    }
    updateBuffers(A3) {
      const g3 = this.__gl;
      if (this.__numVertices != this.__geom.getNumVertices())
        return void this.genBuffers();
      const I3 = this.__geom.genBuffers({includeIndices: false});
      for (const A4 in I3.attrBuffers) {
        const C3 = I3.attrBuffers[A4], i3 = this.__glattrbuffers[A4];
        g3.bindBuffer(g3.ARRAY_BUFFER, i3.buffer), g3.bufferData(g3.ARRAY_BUFFER, C3.values, g3.STATIC_DRAW);
      }
      this.buffersDirty = false;
    }
    clearBuffers() {
      this.__gl.deleteBuffer(this.__indexBuffer), this.__indexBuffer = null, super.clearBuffers();
    }
    draw(A3) {
      this.__gl.drawElements(this.__gl.TRIANGLES, this.__numTriIndices, this.__indexDataType, 0);
    }
    drawInstanced(A3, g3) {
      this.__gl.drawElementsInstanced(this.__gl.TRIANGLES, this.__numTriIndices, this.__indexDataType, 0, g3);
    }
    destroy() {
      super.destroy();
      this.__gl.deleteBuffer(this.__indexBuffer), this.__indexBuffer = null;
    }
  };
  var Ki = {MSAA_RENDERBUFFER: 0, COLORBUFFER: 1, DEPTHBUFFER: 2};
  var pi = class extends nA {
    constructor(A3) {
      super(), this.__fbo = null, this.offscreenBuffer = null, this.depthTexture = null, this.__backgroundTexture = null, this.__backgroundGLTexture = null, this.offscreenBufferFbo = null, this.__width = 0, this.__height = 0, this.__canvasWidth = 0, this.__canvasHeight = 0, this.fb = null, this.depthBuffer = null, this.EXT_frag_depth = null, this.depthRange = [0, 0], this.backgroundColorParam = new xA("BackgroundColor", new l("#eeeeee")), this.doubleClickTimeParam = new JA("DoubleClickTimeMS", 200), this.renderer = A3, this.__renderer = A3, this.addParameter(this.doubleClickTimeParam);
      const g3 = this.__renderer.gl;
      this.__gl = g3, this.quad = new Yi(g3, new AI(1, 1)), g3.name == "webgl2" && (this.offscreenBuffer = new HC(g3, {type: "UNSIGNED_BYTE", format: "RGBA", filter: "LINEAR", width: 4, height: 4}), this.depthTexture = new HC(g3, {type: g3.UNSIGNED_INT_24_8, format: g3.DEPTH_STENCIL, internalFormat: g3.name == "webgl2" ? g3.DEPTH24_STENCIL8 : g3.DEPTH_COMPONENT, filter: g3.NEAREST, wrap: g3.CLAMP_TO_EDGE, width: 4, height: 4})), this.highlightedGeomsBuffer = new HC(g3, {type: "UNSIGNED_BYTE", format: "RGBA", filter: "NEAREST", width: 4, height: 4}), this.highlightedGeomsBufferFbo = new fC(g3, this.highlightedGeomsBuffer, true), this.highlightedGeomsBufferFbo.setClearColor(new l(0, 0, 0, 0));
      const I3 = () => {
        const A4 = this.backgroundColorParam.value;
        A4 instanceof Gg ? A4 instanceof BI ? (this.__backgroundTexture = A4, this.__backgroundGLTexture = new $C(g3, A4)) : (this.__backgroundTexture = A4, this.__backgroundGLTexture = new HC(g3, A4)) : A4 instanceof l ? (this.__backgroundGLTexture && (this.__backgroundGLTexture.destroy(), this.__backgroundGLTexture = null, this.__backgroundTexture = null), this.offscreenBufferFbo && this.offscreenBufferFbo.setClearColor(new l(A4.asArray()))) : console.warn("Invalid background:" + A4), this.emit("updated");
      };
      I3(), this.backgroundColorParam.on("valueChanged", I3);
    }
    getRenderer() {
      return this.renderer;
    }
    getWidth() {
      return this.__width;
    }
    getHeight() {
      return this.__height;
    }
    resize(A3, g3) {
      if (this.__canvasWidth == A3 && this.__canvasHeight == g3)
        return;
      this.__canvasWidth = A3, this.__canvasHeight = g3, this.__width = A3, this.__height = g3, this.resizeRenderTargets(A3, g3);
      const I3 = new F(this.__width, this.__height);
      this.emit("resized", I3);
    }
    resizeRenderTargets(A3, I3) {
      this.highlightedGeomsBuffer && this.highlightedGeomsBufferFbo.resize(A3, I3);
      const C3 = this.__renderer.gl;
      if (this.renderer.outlineThickness > 0 && this.renderer.outlineMethod == "image") {
        if (g.browserName == "Safari" || C3.name == "webgl")
          return void console.warn("Disabling outlines on Safari due to a regression in WebKit", g);
        this.fb && (C3.deleteFramebuffer(this.fb[Ki.MSAA_RENDERBUFFER]), C3.deleteFramebuffer(this.fb[Ki.COLORBUFFER]), C3.deleteFramebuffer(this.fb[Ki.DEPTHBUFFER]), this.colorRenderbuffer && C3.deleteRenderbuffer(this.colorRenderbuffer), this.depthBuffer && C3.deleteRenderbuffer(this.depthBuffer)), this.offscreenBuffer.resize(A3, I3), this.depthTexture.resize(A3, I3), this.fb = [], this.fb[Ki.MSAA_RENDERBUFFER] = C3.createFramebuffer(), C3.bindFramebuffer(C3.FRAMEBUFFER, this.fb[Ki.MSAA_RENDERBUFFER]), this.colorRenderbuffer = C3.createRenderbuffer(), C3.bindRenderbuffer(C3.RENDERBUFFER, this.colorRenderbuffer), this.renderer.multiSampledScreenBuffer ? C3.renderbufferStorage(C3.RENDERBUFFER, C3.RGBA8, A3, I3) : C3.renderbufferStorageMultisample(C3.RENDERBUFFER, 4, C3.RGBA8, A3, I3), C3.framebufferRenderbuffer(C3.FRAMEBUFFER, C3.COLOR_ATTACHMENT0, C3.RENDERBUFFER, this.colorRenderbuffer), this.depthBuffer = C3.createRenderbuffer(), C3.bindRenderbuffer(C3.RENDERBUFFER, this.depthBuffer), this.renderer.multiSampledScreenBuffer ? C3.renderbufferStorage(C3.RENDERBUFFER, C3.DEPTH24_STENCIL8, A3, I3) : C3.renderbufferStorageMultisample(C3.RENDERBUFFER, 4, C3.DEPTH24_STENCIL8, A3, I3), C3.framebufferRenderbuffer(C3.FRAMEBUFFER, C3.DEPTH_ATTACHMENT, C3.RENDERBUFFER, this.depthBuffer), this.fb[Ki.COLORBUFFER] = C3.createFramebuffer(), C3.bindFramebuffer(C3.FRAMEBUFFER, this.fb[Ki.COLORBUFFER]), C3.framebufferTexture2D(C3.FRAMEBUFFER, C3.COLOR_ATTACHMENT0, C3.TEXTURE_2D, this.offscreenBuffer.glTex, 0), C3.bindFramebuffer(C3.FRAMEBUFFER, null), this.fb[Ki.DEPTHBUFFER] = C3.createFramebuffer(), C3.bindFramebuffer(C3.FRAMEBUFFER, this.fb[Ki.DEPTHBUFFER]), C3.framebufferTexture2D(C3.FRAMEBUFFER, C3.DEPTH_ATTACHMENT, C3.TEXTURE_2D, this.depthTexture.glTex, 0), C3.bindFramebuffer(C3.FRAMEBUFFER, null);
        const i3 = C3.checkFramebufferStatus(C3.name == "webgl2" ? C3.DRAW_FRAMEBUFFER : C3.FRAMEBUFFER);
        if (i3 !== C3.FRAMEBUFFER_COMPLETE)
          switch (i3) {
            case C3.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
              throw new Error("The attachment types are mismatched or not all framebuffer attachment points are framebuffer attachment complete.");
            case C3.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
              throw new Error("There is no attachment.");
            case C3.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
              throw new Error("Height and width of the attachment are not the same.");
            case C3.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
              throw new Error("The format of the attachment is not supported or if depth and stencil attachments are not the same renderbuffer.");
            case 36061:
              throw new Error("The framebuffer is unsupported");
            default:
              throw new Error("Incomplete Frambuffer");
          }
      }
    }
    draw(A3) {
      const I3 = this.__renderer.gl;
      A3.pushGLStack();
      const C3 = A3.boundRendertarget;
      if (this.renderer.outlineThickness > 0 && this.renderer.outlineMethod == "image") {
        if (g.browserName == "Safari" || I3.name == "webgl")
          console.warn("Disabling outlines on Safari due to a regression in WebKit", g);
        else {
          this.fb || this.resizeRenderTargets(this.__width, this.__height);
          const g3 = this.fb[Ki.MSAA_RENDERBUFFER];
          I3.bindFramebuffer(I3.name == "webgl2" ? I3.DRAW_FRAMEBUFFER : I3.FRAMEBUFFER, g3), A3.boundRendertarget = g3;
        }
      } else
        A3.boundRendertarget || I3.bindFramebuffer(I3.FRAMEBUFFER, null);
      I3.viewport(0, 0, this.__width, this.__height);
      const i3 = this.backgroundColorParam.value.asArray();
      I3.clearColor(i3[0], i3[1], i3[2], i3[3]), I3.colorMask(true, true, true, false), I3.clear(I3.COLOR_BUFFER_BIT | I3.DEPTH_BUFFER_BIT), A3.glEnable(I3.DEPTH_TEST), this.__renderer.drawScene(A3);
      const e3 = A3.toHighlightRenderState();
      if (this.drawHighlights(e3), e3.stack.length != 1 && console.warn(" corrupt highlightRenderState.stack.length:", e3.stack.length), this.fb) {
        const g3 = I3;
        g3.bindFramebuffer(g3.READ_FRAMEBUFFER, this.fb[Ki.MSAA_RENDERBUFFER]), g3.bindFramebuffer(g3.DRAW_FRAMEBUFFER, this.fb[Ki.COLORBUFFER]), g3.clearBufferfv(g3.COLOR, 0, [0, 0, 0, 0]), g3.blitFramebuffer(0, 0, this.__width, this.__height, 0, 0, this.__width, this.__height, g3.COLOR_BUFFER_BIT, g3.LINEAR), I3.bindFramebuffer(I3.DRAW_FRAMEBUFFER, C3), A3.boundRendertarget = C3, I3.viewport(0, 0, this.__width, this.__height), I3.disable(I3.DEPTH_TEST);
        const i4 = this.__renderer.screenQuad;
        i4.bindShader(A3), i4.draw(A3, this.offscreenBuffer), I3.enable(I3.DEPTH_TEST);
      }
      A3.popGLStack(), this.renderer.emit("redrawOccurred");
    }
    drawSilhouettes(A3) {
      A3.pushGLStack();
      const g3 = this.__renderer.gl, I3 = g3;
      I3.bindFramebuffer(I3.READ_FRAMEBUFFER, this.fb[Ki.MSAA_RENDERBUFFER]), I3.bindFramebuffer(I3.DRAW_FRAMEBUFFER, this.fb[Ki.DEPTHBUFFER]), I3.clearBufferfv(I3.COLOR, 0, [1, 1, 1, 1]), I3.blitFramebuffer(0, 0, this.__width, this.__height, 0, 0, this.__width, this.__height, I3.DEPTH_BUFFER_BIT, I3.NEAREST), I3.bindFramebuffer(I3.DRAW_FRAMEBUFFER, this.fb[Ki.MSAA_RENDERBUFFER]), A3.boundRendertarget = this.fb[Ki.MSAA_RENDERBUFFER], I3.viewport(0, 0, this.__width, this.__height), A3.glEnable(g3.BLEND), A3.glDisable(g3.DEPTH_TEST), I3.blendEquation(I3.FUNC_ADD), I3.blendFunc(I3.SRC_ALPHA, I3.ONE_MINUS_SRC_ALPHA), I3.depthMask(false), this.renderer.silhouetteShader.bind(A3);
      const C3 = A3.unifs;
      this.depthTexture.bindToUniform(A3, C3.depthTexture), I3.uniform2f(C3.screenSize.location, this.__width, this.__height), I3.uniform1f(C3.outlineThickness.location, this.renderer.outlineThickness * window.devicePixelRatio);
      const i3 = this.renderer.outlineColor.asArray();
      I3.uniform4f(C3.outlineColor.location, i3[0], i3[1], i3[2], i3[3]), I3.uniform1f(C3.outlineSensitivity.location, this.renderer.outlineSensitivity), I3.uniform1f(C3.outlineDepthBias.location, this.renderer.outlineDepthBias), I3.uniform2f(C3.depthRange.location, this.depthRange[0], this.depthRange[1]), this.quad.bindAndDraw(A3), I3.depthMask(true), A3.popGLStack();
    }
    drawHighlights(A3) {
      if (this.highlightedGeomsBufferFbo) {
        const g3 = this.__renderer.gl;
        this.highlightedGeomsBufferFbo.bindForWriting(A3), this.highlightedGeomsBufferFbo.clear(), A3.pushGLStack(), A3.glEnable(g3.CULL_FACE), A3.glEnable(g3.DEPTH_TEST), A3.glDisable(g3.BLEND), g3.depthFunc(g3.LESS), g3.depthMask(true), A3.glShader = null, this.__renderer.drawHighlightedGeoms(A3), this.highlightedGeomsBufferFbo.unbindForWriting(A3), g3.viewport(0, 0, this.__width, this.__height);
        {
          this.renderer.highlightsShader.bind(A3), A3.pushGLStack(), A3.glEnable(g3.BLEND), g3.blendEquation(g3.FUNC_ADD), g3.blendFunc(g3.SRC_ALPHA, g3.ONE_MINUS_SRC_ALPHA);
          const I3 = A3.unifs;
          g3.uniform1f(I3.outlineThickness.location, this.renderer.highlightOutlineThickness), this.highlightedGeomsBuffer.bindToUniform(A3, I3.highlightDataTexture), g3.uniform2f(I3.highlightDataTextureSize.location, A3.region[2], A3.region[3]), this.quad.bindAndDraw(A3), A3.popGLStack();
        }
        A3.popGLStack();
      }
    }
    getManipulator() {
      return this.manipulator;
    }
    setManipulator(A3) {
      this.manipulator != A3 && (this.manipulator && this.manipulator.deactivateTool && this.manipulator.deactivateTool(), this.manipulator = A3, this.manipulator.activateTool && this.manipulator.activateTool());
    }
    onPointerDown(A3) {
      console.warn("@GLBaseViewport#onPointerDown - Implement me!");
    }
    onPointerUp(A3) {
      console.warn("@GLBaseViewport#onPointerUp - Implement me!");
    }
    onPointerMove(A3) {
      console.warn("@GLBaseViewport#onPointerMove - Implement me!");
    }
    onPointerEnter(A3) {
      console.warn("@GLBaseViewport#onPointerEnter - Implement me!");
    }
    onPointerLeave(A3) {
      console.warn("@GLBaseViewport#onPointerLeave - Implement me!");
    }
    onMouseLeave(A3) {
    }
    onKeyDown(A3) {
    }
    onKeyUp(A3) {
    }
  };
  var Ni = class extends pi {
    constructor(A3, g3, I3, C3) {
      super(A3), this.__geomDataBufferSizeFactor = 1, this.debugGeomDataBuffer = false, this.debugOcclusionBuffer = false, this.debugReductionBuffer = false, this.debugHighlightedGeomsBuffer = false, this.__x = 0, this.__y = 0, this.region = [0, 0, 0, 0], this.__cameraXfo = new m(), this.__cameraMat = new h(), this.__viewMat = new h(), this.__geomDataBufferInvalid = true, this.__screenPos = null, this.__name = g3, this.__projectionMatrix = new h(), this.__frustumDim = new B(), this.__bl = new B(0, 0), this.__tr = new B(1, 1), this.__prevDownTime = 0;
      const i3 = this.__renderer.gl;
      this.__geomDataBuffer = new HC(i3, {type: A3.floatGeomBuffer ? "FLOAT" : "UNSIGNED_BYTE", format: "RGBA", filter: "NEAREST", width: I3 <= 1 ? 1 : Math.floor(I3 / this.__geomDataBufferSizeFactor), height: C3 <= 1 ? 1 : Math.floor(C3 / this.__geomDataBufferSizeFactor)}), this.__geomDataBufferFbo = new fC(i3, this.__geomDataBuffer, true), this.__geomDataBufferFbo.setClearColor(new l(0, 0, 0, 0)), this.__camera = new IC("DefaultCamera"), this.setCamera(this.__camera), this.setManipulator(new SC({renderer: A3})), this.resize(I3, C3);
    }
    getBl() {
      return this.__bl;
    }
    setBl(A3) {
      this.__bl.x = A3, this.__bl.y = A3, this.resize(this.__canvasWidth, this.__canvasHeight);
    }
    getTr() {
      return this.__tr;
    }
    setTr(A3) {
      this.__tr.x = A3, this.__tr.y = A3, this.resize(this.__canvasWidth, this.__canvasHeight);
    }
    getPosX() {
      return this.__x;
    }
    getPosY() {
      return this.__y;
    }
    resize(A3, g3) {
      if (this.__canvasWidth == A3 && this.__canvasHeight == g3)
        return;
      this.__canvasWidth = A3, this.__canvasHeight = g3, this.__x = A3 * this.__bl.x, this.__y = A3 * this.__bl.y, this.__width = A3 * this.__tr.x - A3 * this.__bl.x, this.__height = g3 * this.__tr.y - g3 * this.__bl.y, this.region = [this.__x, this.__y, this.__width, this.__height], this.__camera && this.__updateProjectionMatrix(), this.resizeRenderTargets(this.__width, this.__height);
      const I3 = new F(this.__width, this.__height);
      this.emit("resized", I3);
    }
    resizeRenderTargets(A3, g3) {
      super.resizeRenderTargets(A3, g3), this.__geomDataBufferFbo && (this.__geomDataBufferFbo.resize(Math.floor(this.__width / this.__geomDataBufferSizeFactor), Math.floor(this.__height / this.__geomDataBufferSizeFactor)), this.renderGeomDataFbo());
    }
    getCamera() {
      return this.__camera;
    }
    setCamera(A3) {
      this.__camera = A3, this.depthRange = [this.__camera.getNear(), this.__camera.getFar()];
      const g3 = A3.globalXfoParam, I3 = () => {
        this.__cameraXfo = g3.value, this.__cameraMat = this.__cameraXfo.toMat4(), this.__viewMat = this.__cameraMat.inverse();
      };
      I3(), g3.on("valueChanged", () => {
        I3(), this.invalidateGeomDataBuffer(), this.emit("updated");
        const A4 = new P("CameraAndPointer", this.__cameraXfo);
        this.emit("viewChanged", A4);
      }), this.__camera.on("projectionParamChanged", () => {
        this.__updateProjectionMatrix(), this.depthRange = [this.__camera.getNear(), this.__camera.getFar()], this.emit("updated");
      }), this.__updateProjectionMatrix();
    }
    __updateProjectionMatrix() {
      const A3 = this.__width / this.__height;
      this.__camera.updateProjectionMatrix(this.__projectionMatrix, A3);
      const g3 = Math.tan(this.__camera.getFov() / 2) * this.__camera.getNear() * 2, I3 = g3 * A3;
      this.__frustumDim.set(I3, g3);
    }
    getProjectionMatrix() {
      return this.__projectionMatrix;
    }
    getViewMatrix() {
      return this.__viewMat;
    }
    frameView(A3) {
      this.__width > 0 && this.__height > 0 ? this.__camera.frameView(this, A3) : this.once("resized", () => this.frameView());
    }
    calcScreenPosFromWorldPos(A3) {
      const g3 = this.__projectionMatrix.multiply(this.__viewMat).transformVec4(new s(A3.x, A3.y, A3.z, 1));
      return g3.x /= g3.w, g3.y /= g3.w, new B((0.5 * g3.x + 0.5) * this.__width, (-0.5 * g3.y + 0.5) * this.__height);
    }
    calcRayFromScreenPos(A3) {
      const g3 = this.__canvasHeight * (1 - this.__tr.y);
      let I3 = (A3.x - this.__x) / this.__width, C3 = (A3.y - g3) / this.__height;
      I3 = 2 * I3 - 1, C3 = 2 * C3 - 1;
      const i3 = this.__cameraMat, e3 = this.__projectionMatrix.inverse();
      if (e3 == null)
        return console.warn(`Unable to generate Ray from screen pos:${A3.toString()} in region ${this.region}`), new G();
      let t3, B3;
      if (this.__camera.isOrthographic()) {
        const A4 = e3.transformVec3(new o(I3, -C3, -1));
        A4.z = 0, t3 = i3.transformVec3(A4), B3 = new o(0, 0, -1);
      } else
        t3 = i3.translation, B3 = e3.transformVec3(new o(I3, -C3, -1));
      return B3 = i3.rotateVec3(B3).normalize(), new G(t3, B3);
    }
    renderGeomDataFbo() {
      if (this.__geomDataBufferFbo) {
        const A3 = new qC(this.renderer.__gl);
        this.initRenderState(A3), A3.geomDataFbo = this.__geomDataBufferFbo, this.__geomDataBufferFbo.bindAndClear(A3), this.__renderer.drawSceneGeomData(A3), this.__geomDataBufferInvalid = false, this.__geomDataBufferFbo.unbind();
      }
    }
    invalidateGeomDataBuffer() {
      this.__geomDataBufferInvalid = true;
    }
    getGeomDataAtPos(A3, g3) {
      if (this.__geomDataBufferFbo) {
        if (this.__geomDataBufferInvalid && (this.renderGeomDataFbo(), this.__screenPos = null), A3 === this.__screenPos)
          return this.__intersectionData;
        this.__screenPos = A3, this.__intersectionData = null;
        const I3 = this.__renderer.gl;
        I3.finish(), this.__geomDataBufferFbo.bindForReading();
        const C3 = this.__geomDataBufferFbo.width, i3 = this.__geomDataBufferFbo.height, e3 = Math.floor(A3.x * (C3 / this.__width)), t3 = Math.floor(A3.y * (i3 / this.__height));
        let B3, o3;
        if (this.__renderer.floatGeomBuffer) {
          if (o3 = new Float32Array(4), I3.readPixels(e3, i3 - t3 - 1, 1, 1, I3.RGBA, I3.FLOAT, o3), o3[3] == 0)
            return null;
          B3 = 63 & Math.round(o3[0]);
        } else {
          if (o3 = new Uint8Array(4), I3.readPixels(e3, i3 - t3 - 1, 1, 1, I3.RGBA, I3.UNSIGNED_BYTE, o3), I3.bindFramebuffer(I3.FRAMEBUFFER, null), o3[0] == 0 && o3[1] == 0)
            return;
          B3 = Math.floor(o3[1] / 32);
        }
        this.__geomDataBufferFbo.unbind();
        const s3 = this.__renderer.getPass(B3);
        if (!s3)
          return console.warn("Geom data buffer returns invalid pass id:", B3), null;
        const a3 = s3.getGeomItemAndDist(o3);
        if (a3) {
          if (!a3.geomItem.isSelectable())
            return null;
          g3 || (g3 = this.calcRayFromScreenPos(A3));
          const I4 = g3.start.add(g3.dir.scale(a3.dist));
          this.__intersectionData = new H(A3, g3, I4, o3, a3);
        }
        return this.__intersectionData;
      }
      return null;
    }
    getGeomItemsInRect(A3, g3) {
      var I3;
      if (this.__geomDataBufferFbo) {
        const C3 = this.__renderer.gl;
        C3.finish();
        const i3 = this.__geomDataBufferFbo.width, e3 = this.__geomDataBufferFbo.height, t3 = i3 / this.__width, B3 = e3 / this.__height, o3 = Math.round(A3.x * t3), s3 = Math.round(A3.y * B3), a3 = Math.round(g3.x * t3), l3 = Math.round(g3.y * B3), n3 = Math.round(e3 - l3), d3 = Math.round(o3), h3 = Math.round(a3 - o3), c3 = Math.round(l3 - s3), r3 = h3 * c3;
        let G3;
        this.__geomDataBufferFbo.bindForReading(), this.__renderer.floatGeomBuffer ? (G3 = new Float32Array(4 * r3), C3.readPixels(d3, n3, h3, c3, C3.RGBA, C3.FLOAT, G3)) : (G3 = new Uint8Array(4 * r3), C3.readPixels(d3, n3, h3, c3, C3.RGBA, C3.UNSIGNED_BYTE, G3)), C3.bindFramebuffer(C3.FRAMEBUFFER, null);
        const m3 = new Set();
        for (let A4 = 0; A4 < r3; A4++) {
          let g4;
          const C4 = G3.subarray(4 * A4, 4 * (A4 + 1));
          if (this.__renderer.floatGeomBuffer) {
            if (C4[3] == 0)
              continue;
            g4 = Math.round(C4[0]);
          } else {
            if (C4[0] == 0 && C4[1] == 0)
              continue;
            g4 = Math.floor(C4[1] / 64);
          }
          const i4 = (I3 = this.__renderer.getPass(g4)) === null || I3 === void 0 ? void 0 : I3.getGeomItemAndDist(C4);
          if (i4) {
            if (!i4.geomItem.isSelectable())
              continue;
            m3.add(i4.geomItem);
          }
        }
        return m3;
      }
      return new Set();
    }
    __getPointerPos(A3, g3) {
      return new B((A3 - this.getPosX()) * window.devicePixelRatio, (g3 - this.getPosY()) * window.devicePixelRatio);
    }
    prepareUIEvent(A3) {
      A3.viewport = this;
    }
    onPointerDown(A3) {
      if (this.prepareUIEvent(A3), A3.pointerType === q.mouse) {
        const g4 = A3;
        g4.pointerPos = this.__getPointerPos(g4.rendererX, g4.rendererY), g4.pointerRay = this.calcRayFromScreenPos(g4.pointerPos), g4.intersectionData = this.getGeomDataAtPos(g4.pointerPos, g4.pointerRay);
      } else if (A3.pointerType === q.touch) {
        const g4 = A3;
        if (g4.touches.length == 1) {
          const A4 = g4.touches[0];
          g4.pointerPos = this.__getPointerPos(A4.rendererX, A4.rendererY), g4.pointerRay = this.calcRayFromScreenPos(g4.pointerPos), g4.intersectionData = this.getGeomDataAtPos(g4.pointerPos, g4.pointerRay);
        }
      }
      const g3 = Date.now();
      if (g3 - this.__prevDownTime < this.doubleClickTimeParam.value && (A3 instanceof iA || A3 instanceof tA && A3.touches.length == 1)) {
        if (this.manipulator && (this.manipulator.onPointerDoublePress(A3), !A3.propagating))
          return;
        if (this.emit("pointerDoublePressed", A3), !A3.propagating)
          return;
      } else
        this.__prevDownTime = g3;
      A3.getCapture() && (A3.getCapture().onPointerDown(A3), !A3.propagating) || (A3.intersectionData == null || (A3.intersectionData.geomItem.onPointerDown(A3), A3.propagating)) && (this.emit("pointerDown", A3), A3.propagating && (!this.manipulator || (this.manipulator.onPointerDown(A3), A3.propagating)));
    }
    onPointerUp(A3) {
      if (this.prepareUIEvent(A3), A3.pointerType === q.mouse) {
        const g3 = A3;
        g3.pointerPos = this.__getPointerPos(g3.rendererX, g3.rendererY), g3.pointerRay = this.calcRayFromScreenPos(g3.pointerPos), g3.intersectionData = this.getGeomDataAtPos(g3.pointerPos, g3.pointerRay);
      } else if (A3.pointerType === q.touch) {
        const g3 = A3;
        if (g3.touches.length == 0 && g3.changedTouches.length == 1) {
          const A4 = g3.changedTouches[0];
          g3.pointerPos = this.__getPointerPos(A4.rendererX, A4.rendererY), g3.pointerRay = this.calcRayFromScreenPos(g3.pointerPos), g3.intersectionData = this.getGeomDataAtPos(g3.pointerPos, g3.pointerRay);
        }
      }
      A3.getCapture() && (A3.getCapture().onPointerUp(A3), !A3.propagating) || (A3.intersectionData == null || (A3.intersectionData.geomItem.onPointerUp(A3), A3.propagating)) && (this.emit("pointerUp", A3), A3.propagating && (!this.manipulator || (this.manipulator.onPointerUp(A3), A3.propagating)));
    }
    onPointerMove(A3) {
      if (this.prepareUIEvent(A3), A3.pointerType === q.mouse) {
        const g3 = A3, I3 = this.__getPointerPos(g3.rendererX, g3.rendererY);
        g3.pointerPos = I3, g3.pointerRay = this.calcRayFromScreenPos(I3);
      } else if (A3.pointerType === q.touch) {
        const g3 = A3;
        for (let A4 = 0; A4 < g3.touches.length; A4++) {
          const I3 = g3.touches[A4];
          I3.touchPos = this.__getPointerPos(I3.rendererX, I3.rendererY), I3.touchRay = this.calcRayFromScreenPos(I3.touchPos);
        }
        g3.pointerPos = g3.touches[0].touchPos, g3.pointerRay = g3.touches[0].touchRay;
      }
      if (!A3.getCapture() || (A3.getCapture().onPointerMove(A3), A3.propagating)) {
        if (A3.intersectionData = this.getGeomDataAtPos(A3.pointerPos, A3.pointerRay), A3.intersectionData) {
          if (A3.intersectionData.geomItem != this.pointerOverItem) {
            if (this.pointerOverItem && (A3.leftGeometry = this.pointerOverItem, this.pointerOverItem.onPointerLeave(A3), A3.propagating && this.emit("pointerLeaveGeom", A3)), A3.propagating = true, this.pointerOverItem = A3.intersectionData.geomItem, this.pointerOverItem.onPointerEnter(A3), !A3.propagating)
              return;
            this.emit("pointerOverGeom", A3);
          }
          if (A3.propagating = true, A3.intersectionData.geomItem.onPointerMove(A3), !A3.propagating)
            return;
        } else if (this.pointerOverItem) {
          if (A3.leftGeometry = this.pointerOverItem, this.pointerOverItem.onPointerLeave(A3), this.pointerOverItem = null, !A3.propagating)
            return;
          this.emit("pointerLeaveGeom", A3);
        }
        this.emit("pointerMove", A3), A3.propagating && (!this.manipulator || (this.manipulator.onPointerMove(A3), A3.propagating));
      }
    }
    onPointerEnter(A3) {
      this.prepareUIEvent(A3), this.emit("pointerEnter", A3), A3.propagating && (!this.manipulator || !this.manipulator.onPointerEnter || (this.manipulator.onPointerEnter(A3), A3.propagating));
    }
    onPointerLeave(A3) {
      this.prepareUIEvent(A3), this.emit("pointerLeave", A3), A3.propagating && (!this.manipulator || !this.manipulator.onPointerLeave || (this.manipulator.onPointerLeave(A3), A3.propagating));
    }
    onKeyDown(A3) {
      this.prepareUIEvent(A3), this.manipulator && (this.manipulator.onKeyDown(A3), !A3.propagating) || this.emit("keyDown", A3);
    }
    onKeyUp(A3) {
      this.prepareUIEvent(A3), this.manipulator && (this.manipulator.onKeyUp(A3), !A3.propagating) || this.emit("keyUp", A3);
    }
    onWheel(A3) {
      this.prepareUIEvent(A3), A3.pointerPos = this.__getPointerPos(A3.rendererX, A3.rendererY), A3.pointerRay = this.calcRayFromScreenPos(A3.pointerPos), A3.intersectionData = this.getGeomDataAtPos(A3.pointerPos, A3.pointerRay), (A3.intersectionData == null || (A3.intersectionData.geomItem.onWheel(A3), A3.propagating)) && (this.manipulator ? this.manipulator.onWheel(A3) : this.emit("mouseWheel", A3));
    }
    onTouchCancel(A3) {
      this.prepareUIEvent(A3), A3.getCapture() && (A3.getCapture().onTouchCancel(A3), !A3.propagating) || this.manipulator && (this.manipulator.onTouchCancel(A3), !A3.propagating) || this.emit("touchCancel", A3);
    }
    initRenderState(A3) {
      A3.viewXfo = this.__cameraXfo, A3.viewScale = 1, A3.region = this.region, A3.cameraMatrix = this.__cameraMat, A3.viewport = this, A3.viewports = [{region: this.region, viewMatrix: this.__viewMat, projectionMatrix: this.__projectionMatrix, viewportFrustumSize: this.__frustumDim, isOrthographic: this.__camera.isOrthographic() ? 1 : 0, fovY: this.__camera.getFov()}];
    }
    draw(A3) {
      const g3 = this.__renderer.gl;
      if (this.initRenderState(A3), A3.pushGLStack(), A3.glDisable(g3.BLEND), A3.glEnable(g3.DEPTH_TEST), A3.glEnable(g3.CULL_FACE), super.draw(A3), A3.popGLStack(), this.debugGeomDataBuffer) {
        this.renderGeomDataFbo();
        const A4 = new jC(this.__renderer.gl), g4 = this.__renderer.screenQuad;
        g4.bindShader(A4), g4.draw(A4, this.__geomDataBuffer, new B(0, 0), new B(1, 1));
      }
      if (this.debugHighlightedGeomsBuffer) {
        const A4 = new jC(this.__renderer.gl), g4 = this.__renderer.screenQuad;
        g4.bindShader(A4), g4.draw(A4, this.highlightedGeomsBuffer, new B(0, 0), new B(1, 1));
      }
      if (this.debugOcclusionBuffer) {
        const g4 = this.__renderer.glGeomItemLibrary.occlusionDataBuffer, I3 = this.__renderer.screenQuad;
        I3.bindShader(A3);
        const C3 = A3.unifs.image;
        g4.bindColorTexture(A3, C3);
        const i3 = this.__renderer.gl;
        i3.enable(i3.BLEND), i3.blendEquation(i3.FUNC_ADD), i3.blendFunc(i3.SRC_ALPHA, i3.ONE_MINUS_SRC_ALPHA), I3.draw(A3, null, new B(0, 0), new B(1, 1)), i3.disable(i3.BLEND);
      }
      if (this.debugReductionBuffer) {
        const g4 = this.__renderer.glGeomItemLibrary.reductionDataBuffer, I3 = this.__renderer.screenQuad;
        I3.bindShader(A3);
        const C3 = A3.unifs.image;
        g4.bindColorTexture(A3, C3);
        const i3 = this.__renderer.gl;
        i3.enable(i3.BLEND), i3.blendEquation(i3.FUNC_ADD), i3.blendFunc(i3.SRC_ALPHA, i3.ONE_MINUS_SRC_ALPHA), I3.draw(A3, null, new B(0, 0), new B(1, 1)), i3.disable(i3.BLEND);
      }
    }
  };
  var Ji = class {
    constructor(A3, g3) {
      this.__xrvp = A3, this.__treeItem = new ag("XRHead"), g3.addChild(this.__treeItem), this.__mat4 = new h(), this.__localXfo = new m();
    }
    setVisible(A3) {
      if (A3 && !this.hmdGeomItem) {
        const A4 = this.__xrvp.getAsset();
        if (!A4)
          return;
        const g3 = A4.getChildByName("HMD");
        if (!g3)
          return;
        this.hmdGeomItem = g3.clone({assetItem: A4}), this.hmdGeomItem && (this.hmdGeomItem.localXfoParam.value = new m(new o(0, -0.035, -0.03), new c(0, 1, 0, Math.PI), new o(1e-3, 1e-3, 1e-3)), this.__treeItem.addChild(this.hmdGeomItem, false));
      }
      this.hmdGeomItem && (this.hmdGeomItem.visibleParam.value = A3);
    }
    update(A3) {
      this.__mat4.setDataArray(A3.transform.matrix), this.__localXfo.setFromMat4(this.__mat4), this.__treeItem.localXfoParam.value = this.__localXfo;
    }
    getTreeItem() {
      return this.__treeItem;
    }
    getXfo() {
      return this.__localXfo;
    }
  };
  var Di = class extends V {
    constructor(A3, I3, C3) {
      if (super(), this.pressedButtons = [], this.raycastTick = 5, this.raycastArea = 5e-3, this.raycastDist = 0.04, this.pointerRay = new G(), this.raycastAreaCache = 0, this.raycastDistCache = 0, this.rayCastRenderTargetProjMatrix = new h(), this.capturedItem = null, this.xrvp = A3, this.inputSource = I3, this.id = C3, this.buttonPressed = false, this.inputSource.gamepad.buttons.forEach((A4, g3) => {
        g3 != 0 && (this.pressedButtons[g3] = A4.pressed);
      }), this.mat4 = new h(), this.xfo = new m(), this.treeItem = new ag("XRController:" + I3.handedness + C3), !g.isMobileDevice) {
        this.tipItem = new ag("Tip");
        const g3 = new m();
        if (g3.tr.set(0, -0.05, -0.13), this.tipItem.localXfoParam.value = g3, this.treeItem.addChild(this.tipItem, false), A3.getTreeItem().addChild(this.treeItem), I3.targetRayMode == "tracked-pointer") {
          switch (I3.profiles[0]) {
            case "htc-vive":
              localStorage.setItem("ZeaEngine_XRDevice", "Vive");
              break;
            case "oculus-touch":
            case "oculus-touch-v2":
            case "oculus-touch-v3":
              localStorage.setItem("ZeaEngine_XRDevice", "Oculus");
          }
          A3.loadHMDResources().then((A4) => {
            if (!A4)
              return;
            const g4 = new m();
            let C4;
            if (g4.ori.setFromAxisAndAngle(new o(0, 1, 0), Math.PI), g4.sc.set(1e-3, 1e-3, 1e-3), I3.profiles[0] == "htc-vive")
              C4 = A4.getChildByName("Controller"), g4.tr.set(0, -0.035, -0.085);
            else
              switch (I3.handedness) {
                case "left":
                  C4 = A4.getChildByName("LeftController"), g4.tr.set(0, -0.035, -0.085), g4.sc.scaleInPlace(0.85);
                  break;
                case "right":
                  C4 = A4.getChildByName("RightController"), g4.tr.set(0, -0.035, -0.085), g4.sc.scaleInPlace(0.85);
                  break;
                case "none":
                case "left-right":
                case "left-right-none":
                  C4 = A4.getChildByName("Controller");
              }
            if (C4) {
              const I4 = C4.clone({assetItem: A4});
              I4.localXfoParam.value = g4, this.treeItem.addChild(I4, false);
            }
          });
        }
      }
      this.tick = 0;
    }
    getHandedness() {
      return this.inputSource.handedness;
    }
    getId() {
      return this.id;
    }
    getTreeItem() {
      return this.treeItem;
    }
    getTipItem() {
      return this.tipItem;
    }
    getTipXfo() {
      return this.tipItem.globalXfoParam.value;
    }
    getTouchPadValue() {
      return this.touchpadValue;
    }
    isButtonPressed() {
      return this.buttonPressed;
    }
    getControllerStageLocalXfo() {
      return this.xfo;
    }
    getControllerTipStageLocalXfo() {
      return this.xfo.multiply(this.tipItem.localXfoParam.value);
    }
    updatePose(A3, g3, I3) {
      const C3 = g3.getPose(I3.gripSpace, A3);
      if (C3 && C3.transform) {
        if (this.mat4.setDataArray(C3.transform.matrix), this.xfo.setFromMat4(this.mat4), this.treeItem.localXfoParam.value = this.xfo, this.hitTested = false, this.raycastDist > 0 && this.raycastTick > 0 && this.tick % this.raycastTick == 0) {
          const A4 = this.getGeomItemAtTip();
          if (A4 != null) {
            const g4 = new gA(this.xrvp, this, 0, this.buttonPressed ? 1 : 0);
            g4.intersectionData = A4, g4.pointerRay = this.pointerRay, A4.geomItem != this.pointerOverItem && (this.pointerOverItem && (g4.leftGeometry = this.pointerOverItem, this.pointerOverItem.onPointerLeave(g4), g4.propagating && this.xrvp.emit("pointerLeaveGeom", g4)), g4.propagating = true, this.pointerOverItem = A4.geomItem, this.pointerOverItem.onPointerEnter(g4), g4.propagating && this.xrvp.emit("pointerOverGeom", g4)), A4.geomItem.onPointerMove(g4);
          } else if (this.pointerOverItem) {
            const A5 = new gA(this.xrvp, this, 0, this.buttonPressed ? 1 : 0);
            A5.pointerRay = this.pointerRay, A5.leftGeometry = this.pointerOverItem, this.pointerOverItem.onPointerLeave(A5), this.pointerOverItem = null;
          }
        }
        this.inputSource.gamepad.buttons.forEach((A4, g4) => {
          if (g4 != 0) {
            if (A4.pressed && !this.pressedButtons[g4]) {
              this.pressedButtons[g4] = true;
              const A5 = new gA(this.xrvp, this, g4, 1);
              A5.intersectionData = this.getGeomItemAtTip(), A5.pointerRay = this.pointerRay, this.emit("buttonPressed", A5);
            } else if (!A4.pressed && this.pressedButtons[g4]) {
              this.pressedButtons[g4] = false;
              const A5 = new gA(this.xrvp, this, g4, 0);
              this.emit("buttonReleased", A5);
            }
          }
        }), this.tick++;
      }
    }
    getGeomItemAtTip() {
      if (this.hitTested)
        return this.intersectionData;
      if (this.hitTested = true, this.raycastDist == 0)
        return null;
      const A3 = this.xrvp.getRenderer(), g3 = this.tipItem.globalXfoParam.value.clone();
      g3.sc.set(1, 1, 1), this.pointerRay.start = g3.tr, this.pointerRay.dir = g3.ori.getZaxis().negate();
      const I3 = this.raycastDist * this.xrvp.stageScale, C3 = this.raycastArea * this.xrvp.stageScale;
      return I3 == this.raycastDistCache && C3 == this.raycastAreaCache || (this.rayCastRenderTargetProjMatrix.setOrthographicMatrix(-0.5 * C3, 0.5 * C3, -0.5 * C3, 0.5 * C3, 0, I3), this.raycastDistCache = I3, this.raycastAreaCache = C3), this.intersectionData = A3.raycastWithProjection(g3, this.rayCastRenderTargetProjMatrix, this.pointerRay), this.intersectionData;
    }
  };
  var fi = class extends VC {
    constructor(A3) {
      super(), this.listenerIDs = {}, this.__controllerTriggersHeld = [], this.xrvp = A3, this.vrControllerToolTip = new gI(0.015), this.vrControllerToolTipMat = new XI("Cross", "FlatSurfaceShader"), this.vrControllerToolTipMat.getParameter("BaseColor").value = new l("#03E3AC"), this.listenerIDs = {};
    }
    addIconToController(A3) {
      const g3 = new kI("HandleToolTip", this.vrControllerToolTip, this.vrControllerToolTipMat);
      g3.setSelectable(false), A3.getTipItem().removeAllChildren(), A3.getTipItem().addChild(g3, false);
    }
    activateTool() {
      super.activateTool();
      for (const A3 of this.xrvp.getControllers())
        this.addIconToController(A3);
      this.listenerIDs.controllerAdded = this.xrvp.on("controllerAdded", (A3) => {
        this.addIconToController(A3.controller);
      });
    }
    deactivateTool() {
      super.deactivateTool();
      for (const A3 of this.xrvp.getControllers())
        A3.getTipItem().removeAllChildren();
      this.xrvp.removeListenerById("controllerAdded", this.listenerIDs.controllerAdded);
    }
    __initMoveStage() {
      if (this.__controllerTriggersHeld.length == 1)
        this.__grabPos = this.__controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr.clone(), this.stageXfo__GrabStart = this.xrvp.getXfo().clone(), this.__invOri = this.stageXfo__GrabStart.ori.inverse();
      else if (this.__controllerTriggersHeld.length == 2) {
        const A3 = this.__controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr, g3 = this.__controllerTriggersHeld[1].getControllerTipStageLocalXfo().tr;
        this.__grabDir = g3.subtract(A3), this.__grabPos = A3.lerp(g3, 0.5), this.__grabDir.y = 0, this.__grabDist = this.__grabDir.length(), this.__grabDir.scaleInPlace(1 / this.__grabDist), this.stageXfo__GrabStart = this.xrvp.getXfo().clone(), this.__grab_to_stage = this.__grabPos.subtract(this.stageXfo__GrabStart.tr);
      }
    }
    onVRControllerButtonDown(A3) {
      if (A3.button != 0)
        return;
      this.__controllerTriggersHeld.indexOf(A3.controller) == -1 && (this.__controllerTriggersHeld.push(A3.controller), this.__initMoveStage(), A3.stopPropagation());
    }
    onVRControllerButtonUp(A3) {
      if (A3.button != 0)
        return;
      const g3 = this.__controllerTriggersHeld.indexOf(A3.controller);
      g3 != -1 && (this.__controllerTriggersHeld.splice(g3, 1), this.__initMoveStage(), A3.stopPropagation());
    }
    onVRControllerDoubleClicked(A3) {
      console.log("onVRControllerDoubleClicked:", this.__controllerTriggersHeld.length);
      const g3 = this.xrvp.getXfo().clone();
      g3.sc.set(1, 1, 1), this.xrvp.setXfo(g3);
    }
    onVRPoseChanged(A3) {
      if (this.__controllerTriggersHeld.length == 1) {
        const A4 = this.__controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr, g3 = new m();
        g3.tr = this.__grabPos.subtract(A4);
        const I3 = this.stageXfo__GrabStart.multiply(g3);
        this.xrvp.setXfo(I3);
      } else if (this.__controllerTriggersHeld.length == 2) {
        const A4 = this.__controllerTriggersHeld[0].getControllerTipStageLocalXfo().tr, g3 = this.__controllerTriggersHeld[1].getControllerTipStageLocalXfo().tr, I3 = A4.lerp(g3, 0.5), C3 = g3.subtract(A4);
        C3.y = 0;
        const i3 = C3.length();
        if (i3 < 1e-4)
          return;
        C3.scaleInPlace(1 / i3);
        const e3 = new m(), t3 = Math.max(Math.min(this.__grabDist / i3, 10), 0.1);
        e3.sc.set(t3, t3, t3);
        let B3 = this.__grabDir.angleTo(C3);
        this.__grabDir.cross(C3).y > 0 && (B3 = -B3), e3.ori.rotateY(B3);
        const o3 = e3.ori.rotateVec3(this.__grabPos);
        e3.tr.addInPlace(this.__grabPos.subtract(o3));
        const s3 = this.__grabPos.scale(1 - t3);
        e3.tr.addInPlace(e3.ori.rotateVec3(s3));
        const a3 = this.__grabPos.subtract(I3).scale(t3);
        e3.tr.addInPlace(e3.ori.rotateVec3(a3));
        const l3 = this.stageXfo__GrabStart.multiply(e3);
        this.xrvp.setXfo(l3);
      }
    }
    onPointerDown(A3) {
      A3.pointerType === q.xr && this.onVRControllerButtonDown(A3);
    }
    onPointerMove(A3) {
      A3.pointerType === q.xr && this.onVRPoseChanged(A3);
    }
    onPointerUp(A3) {
      A3.pointerType === q.xr && this.onVRControllerButtonUp(A3);
    }
    onPointerDoublePress(A3) {
      A3.pointerType === q.xr && this.onVRControllerDoubleClicked(A3);
    }
  };
  var Mi = class extends pi {
    constructor(A3) {
      super(A3), this.viewXfo = new m(), this.stageXfo = new m(), this.invStageMatrix = new h(), this.session = null, this.hmd = "", this.region = [], this.projectionMatrices = [], this.viewMatrices = [], this.cameraMatrices = [], this.doubleClickTimeParam.value = 300, this.__projectionMatricesUpdated = false, this.__stageTreeItem = new ag("VRStage"), this.__stageTreeItem.setVisible(false), this.__renderer.addTreeItem(this.__stageTreeItem), this.__xrhead = new Ji(this, this.__stageTreeItem), this.controllersMap = {}, this.controllers = [], this.controllerPointerDownTime = [], this.spectatorMode = false, this.tick = 0;
      const g3 = new m();
      g3.ori.setFromAxisAndAngle(new o(1, 0, 0), 0.5 * Math.PI), this.setXfo(g3), this.setManipulator(new fi(this));
    }
    getRenderer() {
      return this.renderer;
    }
    getAsset() {
      return this.__vrAsset;
    }
    getTreeItem() {
      return this.__stageTreeItem;
    }
    getVRHead() {
      return this.__xrhead;
    }
    getXfo() {
      return this.stageXfo;
    }
    setXfo(A3) {
      this.stageXfo = A3, this.__stageTreeItem.globalXfoParam.value = A3, this.invStageMatrix = A3.inverse().toMat4(), this.stageScale = A3.sc.x;
    }
    getControllers() {
      return this.controllers;
    }
    getHMDName() {
      return this.hmd;
    }
    isPresenting() {
      return this.session != null;
    }
    setSpectatorMode(A3) {
      if (!A3) {
        const A4 = this.__renderer.gl;
        A4.bindFramebuffer(A4.FRAMEBUFFER, null), A4.viewport(0, 0, A4.drawingBufferWidth, A4.drawingBufferHeight);
        let g3 = this.backgroundColorParam.value.asArray();
        A4.clearColor(g3[0], g3[1], g3[2], g3[3]), A4.colorMask(true, true, true, true), A4.clear(A4.COLOR_BUFFER_BIT | A4.DEPTH_BUFFER_BIT);
      }
      this.spectatorMode = A3;
    }
    __startSession() {
      const A3 = (g3, I3) => {
        this.session && (this.session.requestAnimationFrame(A3), this.drawXRFrame(I3));
      };
      this.session.requestAnimationFrame(A3);
    }
    loadHMDResources() {
      if (g.isMobileDevice)
        return Promise.resolve(null);
      let A3 = localStorage.getItem("ZeaEngine_XRDevice");
      if (A3 || (A3 = "Oculus", localStorage.setItem("ZeaEngine_XRDevice", A3)), this.hmd != A3)
        this.hmdAssetPromise = void 0;
      else if (this.hmdAssetPromise)
        return this.hmdAssetPromise;
      return this.hmd = A3, this.hmdAssetPromise = new Promise((g3, I3) => {
        {
          let I4;
          switch (A3) {
            case "Vive":
            default:
              I4 = "ZeaEngine/Vive.vla";
              break;
            case "Oculus":
              I4 = "ZeaEngine/Oculus.vla";
          }
          if (!FA.commonResources[I4]) {
            const A4 = new RC(I4);
            A4.load(FA.systemUrls[I4]), FA.commonResources[I4] = A4;
          }
          this.__vrAsset = FA.getCommonResource(I4);
          const C3 = () => {
            const A4 = this.__vrAsset.getMaterialLibrary(), I5 = A4.getMaterialNames();
            for (const g4 of I5) {
              const I6 = A4.getMaterial(g4, false);
              I6 && I6.setShaderName("SimpleSurfaceShader");
            }
            this.__vrAsset.traverse((A5) => {
              A5.setSelectable(false);
            }), g3(this.__vrAsset);
          };
          this.__vrAsset.isLoaded() ? C3() : this.__vrAsset.once("loaded", C3);
        }
      }), this.hmdAssetPromise;
    }
    startPresenting() {
      return new Promise((A3, I3) => {
        this.spectatorMode || this.setSpectatorMode(false);
        (() => {
          navigator.xr.requestSession("immersive-vr", {requiredFeatures: ["local-floor"], optionalFeatures: ["bounded-floor"]}).then((C3) => {
            const i3 = this.__renderer.getViewport();
            if (i3) {
              const A4 = i3.getCamera().globalXfoParam.value, g3 = new m();
              g3.tr = A4.tr.clone(), g3.tr.z -= 1.3;
              const I4 = A4.ori.getZaxis();
              I4.z = 0, I4.normalizeInPlace(), g3.ori.setFromDirectionAndUpvector(I4, new o(0, 0, 1)), this.setXfo(g3);
            }
            C3.addEventListener("end", (A4) => {
              this.__stageTreeItem.setVisible(false), this.session = null, this.emit("presentingChanged", new x(false));
            });
            const e3 = (A4) => {
              console.log("creating controller:", A4.handedness, A4.profiles);
              const g3 = this.controllers.length, I4 = new Di(this, A4, g3);
              this.controllersMap[A4.handedness] = I4, this.controllers[g3] = I4;
              const C4 = new W(I4);
              return this.emit("controllerAdded", C4), I4;
            };
            C3.addEventListener("selectstart", (A4) => {
              const g3 = this.controllersMap[A4.inputSource.handedness];
              g3 && (g3.buttonPressed = true, this.onPointerDown(new gA(this, g3, 0, 1)));
            }), C3.addEventListener("selectend", (A4) => {
              const g3 = this.controllersMap[A4.inputSource.handedness];
              g3 && (g3.buttonPressed = false, this.onPointerUp(new gA(this, g3, 0, 0)));
            }), C3.addEventListener("inputsourceschange", (A4) => {
              for (const g3 of A4.added)
                g3.profiles.length != 0 && e3(g3);
            }), this.session = C3;
            const t3 = new XRWebGLLayer(C3, this.__gl);
            C3.updateRenderState({baseLayer: t3}), this.__width = t3.framebufferWidth, this.__height = t3.framebufferHeight, this.region = [0, 0, this.__width, this.__height], this.depthRange = [C3.renderState.depthNear, C3.renderState.depthFar], this.resizeRenderTargets(this.__width, this.__height);
            const B3 = (g3) => {
              this.__refSpace = g3, this.__stageTreeItem.setVisible(true), this.emit("presentingChanged", new x(true)), this.loadHMDResources().then(() => {
                this.__startSession(), A3();
              });
            };
            C3.requestReferenceSpace(g.isMobileDevice ? "local" : "bounded-floor").catch((A4) => {
              console.log("Falling back to local-floor reference space"), C3.requestReferenceSpace("local-floor").then(B3);
            }).then((A4) => {
              B3(A4);
            }).catch((A4) => {
              console.warn(A4.message), I3(new Error("Unable to start XR Session:" + A4.message));
            });
          }).catch((A4) => {
            console.warn(A4.message);
          });
        })();
      });
    }
    stopPresenting() {
      this.session && this.session.end();
    }
    togglePresenting() {
      this.session ? this.stopPresenting() : this.startPresenting();
    }
    updateControllers(A3) {
      const g3 = this.session.inputSources;
      for (let I3 = 0; I3 < g3.length; I3++) {
        const C3 = g3[I3];
        if (C3.profiles.length == 0)
          return;
        this.controllers[I3] ? this.controllers[I3].updatePose(this.__refSpace, A3, C3) : console.warn("Missing controller");
      }
    }
    initCullingRenderState(A3) {
      A3.viewXfo = this.viewXfo, A3.viewScale = 1, A3.region = this.region, A3.cameraMatrix = A3.viewXfo.toMat4(), A3.viewport = this, A3.viewports = [{region: this.region, viewMatrix: A3.cameraMatrix.inverse(), isOrthographic: 0}];
    }
    drawXRFrame(A3) {
      const I3 = A3.session, C3 = I3.renderState.baseLayer, i3 = A3.getViewerPose(this.__refSpace);
      if (!i3)
        return;
      this.__xrhead.update(i3);
      const e3 = this.__xrhead.getTreeItem().globalXfoParam.value;
      this.viewXfo = e3;
      const t3 = i3.views;
      if (!this.__projectionMatricesUpdated) {
        this.projectionMatrices = [], this.viewMatrices = [], this.cameraMatrices = [];
        for (let A4 = 0; A4 < t3.length; A4++) {
          const g3 = t3[A4], I4 = new h();
          I4.setDataArray(g3.projectionMatrix), this.projectionMatrices[A4] = I4, this.viewMatrices[A4] = new h(), this.cameraMatrices[A4] = new h();
        }
        this.__projectionMatricesUpdated = true;
      }
      const B3 = this.__renderer.gl;
      B3.bindFramebuffer(B3.FRAMEBUFFER, C3.framebuffer);
      let o3 = this.backgroundColorParam.value.asArray();
      B3.clearColor(o3[0], o3[1], o3[2], o3[3]), B3.colorMask(true, true, true, true), B3.clear(B3.COLOR_BUFFER_BIT | B3.DEPTH_BUFFER_BIT), this.depthRange = [I3.renderState.depthNear, I3.renderState.depthFar];
      const s3 = new jC(this.__renderer.gl);
      s3.boundRendertarget = C3.framebuffer, s3.region = this.region, s3.viewport = this, s3.vrviewport = this, s3.viewports = [];
      for (let A4 = 0; A4 < t3.length; A4++) {
        const g3 = t3[A4];
        this.viewMatrices[A4].setDataArray(g3.transform.inverse.matrix), this.viewMatrices[A4].multiplyInPlace(this.invStageMatrix);
        const I4 = C3.getViewport(g3);
        s3.viewports.push({viewMatrix: this.viewMatrices[A4], projectionMatrix: this.projectionMatrices[A4], region: [I4.x, I4.y, I4.width, I4.height], isOrthographic: 0});
      }
      s3.viewXfo = e3, s3.viewScale = 1 / this.stageScale, s3.cameraMatrix = s3.viewXfo.toMat4(), s3.region = this.region, s3.vrPresenting = true, this.draw(s3);
      const a3 = new IA(this, e3, this.controllers);
      this.updateControllers(A3), a3.getCapture() && a3.getCapture().onPointerMove(a3), this.manipulator && a3.propagating && this.manipulator.onPointerMove(a3);
      const l3 = new j(s3.viewXfo);
      if (l3.hmd = this.hmd, l3.controllers = this.controllers, l3.viewport = this, l3.vrviewport = this, this.emit("viewChanged", l3), this.spectatorMode && !g.isMobileDevice && this.tick % 5 == 0) {
        const A4 = this.__renderer.getViewport();
        if (A4) {
          this.__xrhead.setVisible(true);
          const g3 = new jC(this.renderer.__gl);
          A4.draw(g3), this.__xrhead.setVisible(false);
        }
      }
      this.tick++;
    }
    onPointerDown(A3) {
      A3.intersectionData = A3.controller.getGeomItemAtTip(), A3.pointerRay = A3.controller.pointerRay;
      const g3 = Date.now();
      if (g3 - this.controllerPointerDownTime[A3.controller.id] < this.doubleClickTimeParam.value) {
        if (this.emit("pointerDoublePressed", A3), !A3.propagating)
          return;
        if (this.manipulator && (this.manipulator.onPointerDoublePress(A3), !A3.propagating))
          return;
      }
      this.controllerPointerDownTime[A3.controller.id] = g3, A3.getCapture() && (A3.getCapture().onPointerDown(A3), !A3.propagating) || (A3.intersectionData == null || (A3.intersectionData.geomItem.onPointerDown(A3), A3.propagating)) && (this.emit("pointerDown", A3), A3.propagating && this.manipulator && this.manipulator.onPointerDown(A3));
    }
    onPointerUp(A3) {
      this.controllerPointerDownTime[A3.controller.id] = 0, A3.pointerRay = A3.controller.pointerRay, A3.getCapture() && (A3.getCapture().onPointerUp(A3), !A3.propagating) || (A3.intersectionData = A3.controller.getGeomItemAtTip(), (A3.intersectionData == null || (A3.intersectionData.geomItem.onPointerUp(A3), A3.propagating)) && (this.emit("pointerUp", A3), A3.propagating && (!this.manipulator || (this.manipulator.onPointerUp(A3), A3.propagating))));
    }
  };
  var Li = class extends u {
    constructor(A3) {
      super(), this.dirty = false, this.unif = A3;
    }
    bind(A3) {
    }
    unbind(A3) {
    }
    destroy() {
    }
  };
  var Ui = class extends Li {
    constructor(A3, g3, I3, C3, i3) {
      super(C3), this.gltexture = null, this.textureType = -1;
      const e3 = I3.getName();
      switch (this.param = I3, this.unif = C3, this.textureUnif = i3[e3 + "Tex"], this.textureTypeUnif = i3[e3 + "TexType"], this.uniform1i = A3.uniform1i.bind(A3), this.unif.type) {
        case "Boolean":
        case "SInt32":
          this.uniformXX = A3.uniform1i.bind(A3);
          break;
        case "UInt32":
          A3.name == "webgl2" ? this.uniformXX = A3.uniform1ui.bind(A3) : this.uniformXX = A3.uniform1i.bind(A3);
          break;
        case "Float32":
          this.uniformXX = A3.uniform1f.bind(A3);
      }
      this.bind = this.bindValue;
      const t3 = (I4) => {
        let C4 = HC.getCachedGLTexture2D(I4);
        C4 || (C4 = I4.type === "FLOAT" ? new $C(A3, I4) : new HC(A3, I4), HC.setCachedGLTexture2D(I4, C4)), this.texBinding = C4.preBind(this.textureUnif, i3), C4.on("updated", () => {
          g3.emit("updated");
        }), this.gltexture = C4, this.gltexture.addRef(this), this.textureType = 1, this.bind = this.bindTexture, g3.emit("updated");
      };
      let B3, o3;
      if (this.update = () => {
        try {
          B3 || (typeof I3.value == "boolean" ? this.val = I3.value ? 1 : 0 : this.val = I3.value);
        } catch (A4) {
        }
        g3.emit("updated");
      }, I3 instanceof mg) {
        const A4 = (A5) => {
          A5.isLoaded() ? t3(A5) : o3 = A5.on("loaded", () => {
            t3(B3);
          }), B3 = A5;
        }, C4 = () => {
          HC.getCachedGLTexture2D(B3).removeRef(this), this.texBinding = null, this.gltexture = null, this.textureType = -1, this.bind = this.bindValue, o3 && B3.removeListenerById("loaded", o3), B3 = null, o3 = null, g3.emit("updated");
        };
        I3.getImage() && A4(I3.getImage()), I3.on("textureConnected", () => {
          A4(I3.getImage());
        }), I3.on("textureDisconnected", () => {
          C4();
        });
      }
      this.dirty = true, I3.on("valueChanged", () => {
        this.dirty = true, g3.emit("updated");
      });
    }
    bindValue(A3) {
      this.dirty && (this.update(), this.dirty = false), this.unif && this.uniformXX(this.unif.location, this.val), this.textureTypeUnif && this.uniform1i(this.textureTypeUnif.location, 0);
    }
    bindTexture(A3) {
      this.dirty && (this.update(), this.dirty = false), this.gltexture.bindToUniform(A3, this.textureUnif, this.texBinding);
    }
  };
  var vi = class extends Li {
    constructor(A3, g3, I3, C3) {
      switch (super(C3), this.param = I3, this.unif.type) {
        case "Vec2":
          this.uniformXX = A3.uniform2fv.bind(A3);
          break;
        case "Vec3":
          this.uniformXX = A3.uniform3fv.bind(A3);
          break;
        case "Vec4":
          this.uniformXX = A3.uniform4fv.bind(A3);
      }
      this.dirty = true, I3.on("valueChanged", () => {
        this.dirty = true, g3.emit("updated");
      });
    }
    bind(A3) {
      this.dirty && (this.values = this.param.value.asArray(), this.dirty = false), this.uniformXX(this.unif.location, this.values);
    }
    unbind() {
    }
    destroy() {
    }
  };
  var ki = class extends Li {
    constructor(A3, g3, I3, C3) {
      switch (super(C3), this.values = new Float32Array(0), this.param = I3, this.unif.type) {
        case "Mat3":
          this.uniformMatrixXXX = A3.uniformMatrix3fv.bind(A3);
          break;
        case "Mat4":
          this.uniformMatrixXXX = A3.uniformMatrix4fv.bind(A3);
      }
      this.dirty = true, I3.on("valueChanged", () => {
        this.dirty = true, g3.emit("updated");
      });
    }
    bind(A3) {
      this.dirty && (this.values = this.param.value.asArray(), this.dirty = false), this.uniformMatrixXXX(this.unif.location, false, this.values);
    }
    unbind() {
    }
    destroy() {
    }
  };
  var xi = class extends Li {
    constructor(A3, g3, I3, C3, i3) {
      super(C3);
      const e3 = I3.getName();
      this.param = I3, this.textureUnif = i3[e3 + "Tex"], this.textureTypeUnif = i3[e3 + "TexType"], this.values = Float32Array.from([0, 0, 0, 0]), this.bind = this.bindValue;
      const t3 = (I4) => {
        B3 = I4;
        let C4 = HC.getCachedGLTexture2D(I4);
        C4 || (C4 = I4.type === "FLOAT" ? new $C(A3, I4) : new HC(A3, I4), HC.setCachedGLTexture2D(I4, C4)), this.texBinding = C4.preBind(this.textureUnif, i3), C4.on("updated", () => {
          g3.emit("updated");
        }), this.gltexture = C4, this.gltexture.addRef(this), this.textureType = 1, this.bind = this.bindTexture, g3.emit("updated");
      };
      let B3, o3;
      const s3 = (A4) => {
        A4.isLoaded() ? t3(A4) : o3 = A4.once("loaded", () => {
          t3(A4);
        });
      }, a3 = () => {
        this.gltexture.removeRef(this), this.gltexture = null, this.texBinding = null, this.textureType = null, o3 && B3.removeListenerById("loaded", o3), this.bind = this.bindValue, B3 = null, o3 = null, g3.emit("updated");
      };
      this.update = () => {
        try {
          B3 || this.unif && (I3 instanceof Qg && I3.colorSpace == pA.Gamma ? this.values = I3.value.toLinear().asArray() : this.values = I3.value.asArray());
        } catch (A4) {
        }
        g3.emit("updated");
      }, I3 instanceof Qg && (I3.getImage() && s3(I3.getImage()), I3.on("textureConnected", () => {
        s3(I3.getImage());
      }), I3.on("textureDisconnected", () => {
        a3();
      })), this.dirty = true, I3.on("valueChanged", () => {
        this.dirty = true;
      }), this.uniform1i = A3.uniform1i.bind(A3), this.uniform4fv = A3.uniform4fv.bind(A3);
    }
    bindValue(A3) {
      this.unif && (this.dirty && (this.update(), this.dirty = false), this.unif && this.uniform4fv(this.unif.location, this.values), this.textureTypeUnif && this.uniform1i(this.textureTypeUnif.location, 0));
    }
    bindTexture(A3) {
      this.dirty && (this.update(), this.dirty = false), this.gltexture.bindToUniform(A3, this.textureUnif, this.texBinding);
    }
  };
  var zi = {};
  var Ti = class {
    constructor(A3, g3, I3, C3) {
      this.uniformBindings = [];
      const i3 = (i4) => {
        const e4 = i4.getName(), t3 = I3[e4];
        if (t3 != null)
          switch (t3.type) {
            case "Boolean":
            case "UInt32":
            case "SInt32":
            case "Float32":
              this.uniformBindings.push(new Ui(A3, g3, i4, t3, I3));
              break;
            case "Vec2":
            case "Vec3":
            case "Vec4":
              this.uniformBindings.push(new vi(A3, g3, i4, t3));
              break;
            case "Color":
              this.uniformBindings.push(new xi(A3, g3, i4, t3, I3));
              break;
            case "Mat4":
              this.uniformBindings.push(new ki(A3, g3, i4, t3));
              break;
            default:
              return void console.warn("Param :" + e4 + " has unhandled data type:" + t3.type);
          }
        else {
          if (I3[e4 + "Tex"])
            return void this.uniformBindings.push(new xi(A3, g3, i4, t3, I3));
          if (C3) {
            const A4 = g3.getMaterial().getShaderName();
            zi[A4] || (zi[A4] = {}), zi[A4][e4] || (console.warn("Material:" + g3.getMaterial().getName(), "with Shader ", A4, "Param has no unif", e4), zi[A4][e4] = true);
          }
        }
      }, e3 = g3.getMaterial().getParameters();
      for (const A4 of e3)
        i3(A4);
    }
    bind(A3) {
      for (const g3 of this.uniformBindings)
        g3.bind(A3);
      return true;
    }
    unbind(A3) {
      for (const g3 of this.uniformBindings)
        g3.unbind(A3);
    }
    destroy() {
      for (const A3 of this.uniformBindings)
        A3.destroy();
    }
  };
  var _i = class extends V {
    constructor(A3, g3, I3) {
      super(), this.__gl = A3, this.__material = g3, this.__glshader = I3, this.__shaderBindings = {}, g3.on("parameterValueChanged", () => this.emit("updated"));
    }
    getMaterial() {
      return this.__material;
    }
    getGLShader() {
      return this.__glshader;
    }
    bind(A3, g3) {
      this.__boundTexturesBeforeMaterial = A3.boundTextures;
      let I3 = this.__shaderBindings[A3.shaderkey];
      if (!I3) {
        const C3 = this.__gl;
        I3 = new Ti(C3, this, A3.unifs, g3), this.__shaderBindings[A3.shaderkey] = I3;
      }
      I3.bind(A3);
    }
    unbind(A3) {
      A3.boundTextures = this.__boundTexturesBeforeMaterial;
    }
  };
  var Pi = class extends V {
    constructor(A3) {
      super(), this.materials = [], this.materialIndices = {}, this.glMaterials = {}, this.refCounts = [], this.freeIndices = [], this.dirtyIndices = new Set(), this.materialsAllocator = new X(), this.renderer = A3, this.materialsAllocator.on("dataReallocated", (A4) => {
        const g3 = A4.id;
        this.dirtyIndices.add(g3);
      });
    }
    addMaterial(A3) {
      let g3 = this.materialIndices[A3.getId()];
      if (g3 != null)
        return this.refCounts[g3]++, g3;
      g3 = this.freeIndices.length ? this.freeIndices.pop() : this.materials.length, this.materials[g3] = A3, this.refCounts[g3] = 1, this.materialIndices[A3.getId()] = g3;
      const I3 = A3.getShaderClass().getPackedMaterialData(A3);
      this.materialsAllocator.allocate(g3, I3.length / 4);
      return A3.on("parameterValueChanged", () => {
        this.dirtyIndices.add(g3), this.emit("updated");
      }), this.dirtyIndices.add(g3), g3;
    }
    getGLMaterial(A3) {
      if (this.glMaterials[A3.getId()])
        return this.glMaterials[A3.getId()];
      const g3 = this.renderer.getOrCreateShader(A3.getShaderName()), I3 = this.renderer.gl, C3 = new _i(I3, A3, g3);
      return C3.on("updated", () => {
        this.renderer.requestRedraw();
      }), A3.setMetadata("glMaterial", C3), this.glMaterials[A3.getId()] = C3, C3;
    }
    getMaterialAllocation(A3) {
      const g3 = this.materialIndices[A3.getId()];
      if (g3 != null)
        return this.materialsAllocator.getAllocation(g3);
    }
    removeMaterial(A3) {
      const g3 = this.materialIndices[A3.getId()];
      this.refCounts[g3]--, this.refCounts[g3] > 0 || (this.freeIndices.push(g3), this.materialsAllocator.deallocate(g3), this.materials[g3] = null, delete this.materialIndices[A3.getId()], this.dirtyIndices.has(g3) && this.dirtyIndices.delete(g3));
    }
    uploadMaterials(A3) {
      const g3 = this.renderer.__gl, I3 = r.nextPow2(Math.ceil(Math.sqrt(this.materialsAllocator.reservedSpace))), C3 = A3.boundTextures++;
      if (g3.activeTexture(g3.TEXTURE0 + C3), this.materialsTexture) {
        if (this.materialsTexture.width < I3) {
          this.materialsTexture.resize(I3, I3);
          for (let A4 = 0; A4 < this.materials.length; A4++)
            this.materialsAllocator.getAllocation(A4) && this.dirtyIndices.add(A4);
        }
      } else
        this.materialsTexture = new HC(this.renderer.__gl, {format: "RGBA", type: "FLOAT", width: I3, height: I3, filter: "NEAREST", wrap: "CLAMP_TO_EDGE", mipMapped: false}), this.materialsTexture.clear();
      const i3 = this.materialsTexture, e3 = this.materialsTexture.width;
      g3.bindTexture(g3.TEXTURE_2D, i3.glTex), this.dirtyIndices.forEach((A4) => {
        const I4 = this.materialsAllocator.getAllocation(A4), C4 = this.materials[A4], t3 = C4.getShaderClass().getPackedMaterialData(C4), B3 = I4.start % e3, o3 = Math.ceil((B3 + I4.size) / e3);
        let s3 = 0, a3 = I4.size, l3 = B3;
        for (let A5 = 0; A5 < o3; A5++) {
          let A6;
          l3 + a3 > e3 ? (A6 = e3 - l3, l3 = 0) : A6 = a3;
          const C5 = (I4.start + s3) % e3, B4 = Math.floor((I4.start + s3) / e3), o4 = t3.subarray(4 * s3, 4 * (s3 + A6));
          g3.texSubImage2D(g3.TEXTURE_2D, 0, C5, B4, A6, 1, i3.getFormat(), i3.getType(), o4), s3 += A6, a3 -= A6;
        }
      }), this.dirtyIndices = new Set(), g3.bindTexture(g3.TEXTURE_2D, null), A3.boundTextures--;
    }
    update(A3) {
      this.dirtyIndices.size > 0 && this.uploadMaterials(A3);
    }
    bind(A3) {
      if (this.dirtyIndices.size > 0 && this.uploadMaterials(A3), !this.materialsTexture)
        return false;
      const {materialsTexture: g3, materialsTextureSize: I3} = A3.unifs;
      if (g3 && (this.materialsTexture.bindToUniform(A3, g3), I3)) {
        this.renderer.gl.uniform2i(I3.location, this.materialsTexture.width, this.materialsTexture.height);
      }
      return true;
    }
  };
  var Oi = class extends Wi {
    constructor(A3, g3) {
      super(A3, g3), this.__numVertices = 9, this.__vboState = -1, this.genBuffers();
    }
    genBuffers(A3) {
      super.genBuffers(A3);
      const g3 = this.__gl, I3 = this.__geom.genBuffers();
      for (const A4 in I3.attrBuffers) {
        const C3 = I3.attrBuffers[A4], i3 = g3.createBuffer();
        g3.bindBuffer(g3.ARRAY_BUFFER, i3), g3.bufferData(g3.ARRAY_BUFFER, C3.values, g3.STATIC_DRAW), this.__glattrbuffers[A4] = {buffer: i3, dataType: C3.dataType, normalized: C3.normalized};
      }
      this.__numVertices = I3.numVertices, this.__vboState = 2;
    }
    updateBuffers(A3) {
      const g3 = this.__gl, I3 = this.__geom.genBuffers(), C3 = I3.numVertices != this.__numVertices;
      for (const A4 in I3.attrBuffers) {
        const i3 = I3.attrBuffers[A4], e3 = this.__glattrbuffers[A4];
        C3 && (g3.deleteBuffer(e3.buffer), e3.buffer = g3.createBuffer()), g3.bindBuffer(g3.ARRAY_BUFFER, e3.buffer), g3.bufferData(g3.ARRAY_BUFFER, i3.values, g3.STATIC_DRAW);
      }
      this.__numVertices = I3.numVertices;
    }
    bind(A3) {
      if (A3.unifs.PointSize) {
        const g3 = this.__gl;
        let I3 = this.__shaderBindings[A3.shaderkey];
        if (!I3) {
          g3.__quadVertexIdsBuffer || g3.setupInstancedQuad();
          const C3 = Object.assign(this.__glattrbuffers, g3.__quadattrbuffers);
          I3 = _C(this.__gl, A3.attrs, C3, g3.__quadIndexBuffer), this.__shaderBindings[A3.shaderkey] = I3;
        }
        return I3.bind(A3), true;
      }
      return super.bind(A3), true;
    }
    draw(A3) {
      const g3 = this.__gl;
      A3.unifs.PointSize ? g3.drawElementsInstanced(g3.TRIANGLES, 6, g3.UNSIGNED_SHORT, 0, this.__numVertices) : g3.drawArrays(g3.POINTS, 0, this.__numVertices);
    }
    drawInstanced(A3, g3) {
      this.__gl.drawArraysInstanced(this.__gl.POINTS, 0, this.__numVertices, g3);
    }
  };
  var ji = class extends Wi {
    constructor(A3, g3) {
      super(A3, g3), this.__numSegIndices = 0, this.__numVertices = 0, this.__fatBuffersNeedUpload = false, this.fatBuffers = null, this.__buffersNeedUpload = false, this.__indexDataType = 0, this.__numSegIndices = 0, this.__numVertices = 0, this.__fatBuffersNeedUpload = true;
    }
    dirtyBuffers(A3) {
      super.dirtyBuffers(A3), this.__fatBuffersNeedUpload = true, this.emit("updated");
    }
    clearBuffers() {
      const A3 = this.__gl;
      if (A3.deleteBuffer(this.__indexBuffer), this.__indexBuffer = null, this.fatBuffers && this.fatBuffers.positionsTexture) {
        this.fatBuffers.positionsTexture && (this.fatBuffers.positionsTexture.destroy(), this.fatBuffers.positionsTexture = null);
        const g3 = this.fatBuffers.glattrbuffers.segmentIndices;
        g3.buffer && (A3.deleteBuffer(g3.buffer), this.fatBuffers.glattrbuffers.segmentIndices = null);
      }
      super.clearBuffers();
    }
    genFatBuffers(A3) {
      const g3 = this.__gl, I3 = this.__geom.genBuffers(), C3 = I3.indices, i3 = I3.numVertices != this.__numVertices;
      g3.__quadVertexIdsBuffer || g3.setupInstancedQuad(), this.fatBuffers || (this.fatBuffers = {drawCount: 0, positionsTexture: null, glattrbuffers: {}}, this.fatBuffers.glattrbuffers.vertexIDs = g3.__quadattrbuffers.vertexIDs);
      const e3 = A3.boundTextures++;
      g3.activeTexture(this.__gl.TEXTURE0 + e3), this.fatBuffers.drawCount = C3.length / 2;
      const t3 = this.__geom.getVertexAttributes(), B3 = t3.positions, s3 = t3.lineThickness, a3 = new Float32Array(4 * B3.getCount());
      for (let A4 = 0; A4 < B3.getCount(); A4++) {
        new o(new Float32Array(a3.buffer, 4 * A4 * 4, 3)).setFromOther(B3.getValueRef(A4)), a3[4 * A4 + 3] = s3 ? s3.getFloat32Value(A4) : 1;
      }
      i3 && this.fatBuffers.positionsTexture && (this.fatBuffers.positionsTexture.destroy(), this.fatBuffers.positionsTexture = null), this.fatBuffers.positionsTexture ? this.fatBuffers.positionsTexture.bufferData(a3, B3.getCount(), 1) : this.fatBuffers.positionsTexture = new HC(this.__gl, {format: "RGBA", type: "FLOAT", width: B3.getCount(), height: 1, filter: "NEAREST", wrap: "CLAMP_TO_EDGE", data: a3, mipMapped: false});
      const l3 = () => {
        const A4 = new Float32Array(C3.length);
        for (let g4 = 0; g4 < C3.length; g4++) {
          let I4;
          I4 = g4 % 2 == 0 ? g4 > 0 ? C3[g4] == C3[g4 - 1] : C3[g4] == C3[C3.length - 1] : g4 < C3.length - 1 ? C3[g4] == C3[g4 + 1] : C3[g4] == C3[0], A4[g4] = (I4 ? 1 : 0) + 2 * C3[g4];
        }
        return A4;
      };
      if (this.fatBuffers.glattrbuffers.segmentIndices)
        (!this.genBufferOpts || this.genBufferOpts && this.genBufferOpts.topologyChanged) && (g3.bindBuffer(g3.ARRAY_BUFFER, this.fatBuffers.glattrbuffers.segmentIndices.buffer), g3.bufferData(g3.ARRAY_BUFFER, l3(), g3.STATIC_DRAW));
      else {
        const A4 = g3.createBuffer();
        g3.bindBuffer(g3.ARRAY_BUFFER, A4), g3.bufferData(g3.ARRAY_BUFFER, l3(), g3.STATIC_DRAW), this.fatBuffers.glattrbuffers.segmentIndices = {buffer: A4, dimension: 2, dataType: "Vec2"};
      }
      this.__numSegIndices = C3.length, this.__numVertices = I3.numVertices, g3.bindTexture(g3.TEXTURE_2D, null), A3.boundTextures--, this.__fatBuffersNeedUpload = false;
    }
    genBuffers(A3) {
      const g3 = this.__gl, I3 = this.__geom.genBuffers(), C3 = I3.indices, i3 = I3.numVertices != this.__numVertices;
      this.__indexBuffer ? (!this.genBufferOpts || this.genBufferOpts && this.genBufferOpts.topologyChanged) && (this.__numSegIndices != C3.length && (g3.deleteBuffer(this.__indexBuffer), this.__indexBuffer = g3.createBuffer()), g3.bindBuffer(g3.ELEMENT_ARRAY_BUFFER, this.__indexBuffer), g3.bufferData(g3.ELEMENT_ARRAY_BUFFER, C3, g3.STATIC_DRAW), this.__numSegIndices = C3.length) : (this.__indexBuffer = g3.createBuffer(), g3.bindBuffer(g3.ELEMENT_ARRAY_BUFFER, this.__indexBuffer), g3.bufferData(g3.ELEMENT_ARRAY_BUFFER, C3, g3.STATIC_DRAW));
      for (const A4 in I3.attrBuffers) {
        const C4 = I3.attrBuffers[A4];
        if (this.__glattrbuffers[A4]) {
          const I4 = this.__glattrbuffers[A4];
          i3 && (g3.deleteBuffer(I4.buffer), I4.buffer = g3.createBuffer()), g3.bindBuffer(g3.ARRAY_BUFFER, I4.buffer), g3.bufferData(g3.ARRAY_BUFFER, C4.values, g3.STATIC_DRAW);
        } else {
          const I4 = g3.createBuffer();
          g3.bindBuffer(g3.ARRAY_BUFFER, I4), g3.bufferData(g3.ARRAY_BUFFER, C4.values, g3.STATIC_DRAW), this.__glattrbuffers[A4] = {buffer: I4, dataType: C4.dataType, normalized: C4.normalized};
        }
      }
      this.__numSegIndices = C3.length, this.__numVertices = I3.numVertices, this.__buffersNeedUpload = false, C3 instanceof Uint8Array && (this.__indexDataType = this.__gl.UNSIGNED_BYTE), C3 instanceof Uint16Array && (this.__indexDataType = this.__gl.UNSIGNED_SHORT), C3 instanceof Uint32Array && (this.__indexDataType = this.__gl.UNSIGNED_INT);
    }
    bind(A3) {
      const g3 = this.__gl, I3 = A3.unifs;
      if (I3.LineThickness && g3.floatTexturesSupported) {
        this.__fatBuffersNeedUpload && this.genFatBuffers(A3);
        const C3 = this.fatBuffers;
        let i3 = this.__shaderBindings[A3.shaderkey];
        return i3 || (i3 = _C(this.__gl, A3.attrs, C3.glattrbuffers, g3.__quadIndexBuffer), this.__shaderBindings[A3.shaderkey] = i3), i3.bind(A3), I3.positionsTexture && (C3.positionsTexture.bindToUniform(A3, I3.positionsTexture), g3.uniform1i(I3.positionsTextureSize.location, C3.positionsTexture.width)), true;
      }
      return super.bind(A3), true;
    }
    drawPoints() {
      this.__gl.drawArrays(this.__gl.POINTS, 0, this.__geom.numVertices());
    }
    draw(A3) {
      const g3 = this.__gl;
      A3.unifs.LineThickness && g3.floatTexturesSupported ? g3.drawElementsInstanced(g3.TRIANGLES, 6, g3.UNSIGNED_SHORT, 0, this.fatBuffers.drawCount) : g3.drawElements(this.__gl.LINES, this.__numSegIndices, this.__indexDataType, 0);
    }
    drawInstanced(A3, g3) {
      const I3 = this.__gl, {occluded: C3} = A3.unifs;
      C3 && I3.uniform1i(C3.location, 0), I3.drawElementsInstanced(this.__gl.LINES, this.__numSegIndices, this.__indexDataType, 0, g3), C3 && (I3.uniform1i(C3.location, 1), I3.depthFunc(I3.GREATER), I3.drawElementsInstanced(this.__gl.LINES, this.__numSegIndices, this.__indexDataType, 0, g3), I3.depthFunc(I3.LEQUAL));
    }
  };
  var qi = (A3, g3) => {
    const I3 = new Int32Array(g3);
    return I3.set(A3), I3;
  };
  var $i = class extends V {
    constructor(A3) {
      super(), this.shaderAttrSpec = {}, this.freeGeomIndices = [], this.geoms = [], this.geomRefCounts = [], this.geomsDict = {}, this.glGeomsDict = {}, this.geomBuffersTmp = [], this.glattrbuffers = {}, this.shaderBindings = {}, this.attributesBufferNeedsRealloc = false, this.attributesBufferNeedsAlloc = [], this.attributesAllocator = new X(), this.dirtyGeomIndices = new Set(), this.geomVertexOffsets = new Int32Array(1), this.geomVertexCounts = new Int32Array(1), this.numIndices = 0, this.indicesBufferNeedsRealloc = false, this.indicesAllocator = new X(), this.indicesCounts = new Int32Array(1), this.indicesOffsets = new Int32Array(1), this.indexBuffer = null, this.freeDataAfterUpload = true, this.__destroyed = false, this.renderer = A3, this.__gl = A3.gl, this.attributesAllocator.on("resized", () => {
        this.attributesBufferNeedsRealloc = true;
      }), this.attributesAllocator.on("dataReallocated", (A4) => {
        const g4 = A4.id, I3 = A4.allocation;
        this.dirtyGeomIndices.add(g4), this.geomVertexOffsets[g4] = I3.start, this.geomVertexCounts[g4] = I3.size;
      }), this.freeGeomIndices.push(0), this.indicesAllocator.on("resized", () => {
        this.indicesBufferNeedsRealloc = true;
      }), this.indicesAllocator.on("dataReallocated", (A4) => {
        const g4 = A4.id;
        this.dirtyGeomIndices.add(g4);
      });
      const g3 = Math.pow(2, 23);
      this.attributesAllocator.reservedSpace = g3, this.indicesAllocator.reservedSpace = 4 * g3, this.attributesBufferNeedsRealloc = true, this.indicesBufferNeedsRealloc = true;
    }
    constructGLGeom(A3) {
      let g3 = this.glGeomsDict[A3.getId()];
      if (g3 != null)
        return g3;
      const I3 = this.__gl;
      if (A3 instanceof Kg || A3 instanceof Dg)
        g3 = new Yi(I3, A3);
      else if (A3 instanceof Yg || A3 instanceof Jg)
        g3 = new ji(I3, A3);
      else {
        if (!(A3 instanceof Wg || A3 instanceof Ng))
          throw new Error("Unsupported geom type:" + A3.constructor.name);
        g3 = new Oi(I3, A3);
      }
      return this.glGeomsDict[A3.getId()] = g3, g3.on("updated", () => {
        this.renderer.requestRedraw();
      }), g3.addRef(this), g3;
    }
    addGeom(A3) {
      let g3 = this.geomsDict[A3.getId()];
      if (g3 != null)
        return this.geomRefCounts[g3]++, g3;
      if (this.freeGeomIndices.length == 0) {
        const A4 = this.geomVertexCounts.length, g4 = 2 * A4;
        this.geomVertexCounts = qi(this.geomVertexCounts, g4), this.geomVertexOffsets = qi(this.geomVertexOffsets, g4), this.indicesCounts = qi(this.indicesCounts, g4), this.indicesOffsets = qi(this.indicesOffsets, g4);
        for (let I3 = g4 - 1; I3 >= A4; I3--)
          this.freeGeomIndices.push(I3);
      }
      g3 = this.freeGeomIndices.pop(), this.geoms[g3] = A3, this.geomRefCounts[g3] = 1, this.geomsDict[A3.getId()] = g3, this.dirtyGeomIndices.add(g3), this.geomVertexCounts[g3] = 0, this.geomVertexOffsets[g3] = 0, this.indicesCounts[g3] = 0, this.indicesOffsets[g3] = 0;
      return A3.on("geomDataChanged", () => {
        this.dirtyGeomIndices.add(g3), this.emit("updated");
      }), A3.on("geomDataTopologyChanged", () => {
        this.dirtyGeomIndices.add(g3), this.emit("updated");
      }), g3;
    }
    removeGeom(A3) {
      const g3 = this.geomsDict[A3.getId()];
      this.geomRefCounts[g3]--, this.geomRefCounts[g3] > 0 || (this.attributesAllocator.getAllocation(g3) && this.attributesAllocator.deallocate(g3), this.indicesAllocator.getAllocation(g3) && this.indicesAllocator.deallocate(g3), this.dirtyGeomIndices.has(g3) && this.dirtyGeomIndices.delete(g3), this.geomVertexCounts[g3] = 0, this.geomVertexOffsets[g3] = 0, this.geoms[g3] = null, this.freeGeomIndices.push(g3), delete this.geomsDict[A3.getId()], delete this.geomBuffersTmp[g3], this.indicesCounts[g3] = 0, this.indicesOffsets[g3] = 0);
    }
    getGeom(A3) {
      return this.geoms[A3];
    }
    getGeomOffsetAndCount(A3) {
      return [this.indicesOffsets[A3], this.indicesCounts[A3]];
    }
    getGeomBuffers(A3) {
      return this.geomBuffersTmp[A3];
    }
    allocateBuffers(A3) {
      const g3 = this.geoms[A3];
      if (!g3)
        return;
      const I3 = g3.genBuffers(), C3 = I3.numRenderVerts ? I3.numRenderVerts : I3.numVertices;
      if (this.geomVertexCounts[A3] != C3)
        if (C3 == 0)
          this.attributesAllocator.deallocate(A3), this.geomVertexOffsets[A3] = 0, this.geomVertexCounts[A3] = 0;
        else {
          const g4 = this.attributesAllocator.allocate(A3, C3);
          this.geomVertexOffsets[A3] = g4.start, this.geomVertexCounts[A3] = g4.size;
        }
      for (const A4 in I3.attrBuffers)
        if (!this.shaderAttrSpec[A4]) {
          const g4 = I3.attrBuffers[A4], C4 = kC(this.__gl, g4.dataType);
          this.shaderAttrSpec[A4] = {dataType: g4.dataType, normalized: g4.normalized, dimension: C4.dimension, elementSize: C4.elementSize}, this.attributesBufferNeedsAlloc.push(A4);
        }
      if (I3.indices) {
        const g4 = I3.indices.length;
        if (this.indicesCounts[A3] != g4)
          if (g4 == 0)
            this.indicesAllocator.deallocate(A3), this.indicesOffsets[A3] = 0, this.indicesCounts[A3] = 0;
          else {
            const I4 = this.indicesAllocator.allocate(A3, g4), C4 = 4;
            this.indicesOffsets[A3] = I4.start * C4, this.indicesCounts[A3] = I4.size;
          }
      } else
        this.indicesOffsets[A3] = this.geomVertexOffsets[A3], this.indicesCounts[A3] = this.geomVertexCounts[A3];
      this.geomBuffersTmp[A3] = I3;
    }
    genAttributesBuffers() {
      for (const A3 in this.shaderAttrSpec)
        this.genAttributesBuffer(A3);
      this.attributesBufferNeedsAlloc = [];
    }
    genAttributesBuffer(A3) {
      const g3 = this.attributesAllocator.reservedSpace, I3 = this.__gl;
      {
        const C3 = this.shaderAttrSpec[A3], i3 = g3 * C3.dimension, e3 = I3.createBuffer();
        I3.bindBuffer(I3.ARRAY_BUFFER, e3);
        const t3 = i3 * C3.elementSize;
        I3.bufferData(I3.ARRAY_BUFFER, t3, I3.STATIC_DRAW), this.glattrbuffers[A3] && this.glattrbuffers[A3].buffer && (I3.bindBuffer(I3.COPY_WRITE_BUFFER, e3), I3.bindBuffer(I3.COPY_READ_BUFFER, this.glattrbuffers[A3].buffer), I3.copyBufferSubData(I3.COPY_READ_BUFFER, I3.COPY_WRITE_BUFFER, 0, 0, this.glattrbuffers[A3].length * C3.elementSize), I3.deleteBuffer(this.glattrbuffers[A3].buffer)), C3.numValues = i3;
        const B3 = A3 == "textureCoords" ? "texCoords" : A3;
        this.glattrbuffers[B3] = {buffer: e3, dataType: C3.dataType, normalized: C3.normalized, length: i3, dimension: C3.dimension};
      }
    }
    genIndicesBuffers() {
      const A3 = this.indicesAllocator.reservedSpace;
      if (this.numIndices != A3) {
        const g3 = this.__gl, I3 = g3.createBuffer();
        g3.bindBuffer(g3.ELEMENT_ARRAY_BUFFER, I3);
        const C3 = 4, i3 = A3 * C3;
        g3.bufferData(g3.ELEMENT_ARRAY_BUFFER, i3, g3.STATIC_DRAW), this.indexBuffer && (g3.bindBuffer(g3.COPY_WRITE_BUFFER, I3), g3.bindBuffer(g3.COPY_READ_BUFFER, this.indexBuffer), g3.copyBufferSubData(g3.COPY_READ_BUFFER, g3.COPY_WRITE_BUFFER, 0, 0, this.numIndices * C3), g3.deleteBuffer(this.indexBuffer)), this.indexBuffer = I3, this.numIndices = A3;
      }
    }
    uploadBuffers(A3) {
      const g3 = this.__gl;
      let I3 = this.geomBuffersTmp[A3];
      if (!I3) {
        const g4 = this.geoms[A3];
        if (!g4)
          return;
        I3 = g4.genBuffers(), this.geomBuffersTmp[A3] = I3;
      }
      const C3 = this.geomVertexCounts[A3], i3 = I3.numRenderVerts ? I3.numRenderVerts : I3.numVertices;
      if (C3 != i3)
        throw new Error("Invalid allocation for this geom");
      if (i3 != 0) {
        for (const C4 in I3.attrBuffers) {
          const i4 = this.shaderAttrSpec[C4], e3 = I3.attrBuffers[C4], t3 = this.glattrbuffers[C4];
          if (!e3 || !t3)
            continue;
          g3.bindBuffer(g3.ARRAY_BUFFER, t3.buffer);
          const B3 = i4.elementSize, o3 = this.geomVertexOffsets[A3] * B3 * i4.dimension;
          g3.bufferSubData(g3.ARRAY_BUFFER, o3, e3.values);
        }
        if (g3.bindBuffer(g3.ARRAY_BUFFER, null), I3.indices && I3.indices.length > 0) {
          const g4 = I3.indices, C4 = this.indicesAllocator.getAllocation(A3);
          if (C4.size != g4.length)
            throw new Error("Invalid allocation for this geom");
          const i4 = this.attributesAllocator.getAllocation(A3), e3 = new Uint32Array(C4.size);
          for (let A4 = 0; A4 < g4.length; A4++)
            e3[A4] = I3.indices[A4] + i4.start;
          const t3 = this.__gl;
          t3.bindBuffer(t3.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
          const B3 = 4, o3 = C4.start * B3;
          t3.bufferSubData(t3.ELEMENT_ARRAY_BUFFER, o3, e3), t3.bindBuffer(t3.ELEMENT_ARRAY_BUFFER, null);
        }
        this.emit("geomDataChanged", new p(A3));
      } else {
        const g4 = new p(A3);
        this.emit("geomDataChanged", g4);
      }
    }
    cleanGeomBuffers() {
      if (this.dirtyGeomIndices.forEach((A3) => {
        this.allocateBuffers(A3);
      }), this.attributesBufferNeedsRealloc || this.indicesBufferNeedsRealloc) {
        for (const A3 in this.shaderBindings) {
          this.shaderBindings[A3].destroy();
        }
        this.shaderBindings = {}, this.attributesBufferNeedsRealloc && (this.genAttributesBuffers(), this.attributesBufferNeedsRealloc = false), this.indicesBufferNeedsRealloc && (this.genIndicesBuffers(), this.indicesBufferNeedsRealloc = false);
      } else
        this.attributesBufferNeedsAlloc.length > 0 && (this.attributesBufferNeedsAlloc.forEach((A3) => {
          this.genAttributesBuffer(A3);
        }), this.attributesBufferNeedsAlloc = []);
      this.dirtyGeomIndices.forEach((A3) => {
        this.uploadBuffers(A3);
      }), this.dirtyGeomIndices = new Set();
    }
    bind(A3) {
      this.dirtyGeomIndices.size > 0 && this.cleanGeomBuffers();
      let g3 = this.shaderBindings[A3.shaderkey];
      if (g3)
        g3.bind(A3);
      else {
        g3 = _C(this.__gl, A3.attrs, this.glattrbuffers, this.indexBuffer), this.shaderBindings[A3.shaderkey] = g3;
        {
          const A4 = this.__gl;
          A4.drawElements(A4.POINTS, 1, A4.UNSIGNED_INT, 0), A4.drawElements(A4.LINES, 2, A4.UNSIGNED_INT, 0), A4.drawElements(A4.TRIANGLES, 3, A4.UNSIGNED_INT, 0);
          const g4 = new Uint32Array(1), I3 = 4, C3 = this.indicesAllocator.allocatedSpace * I3;
          A4.bufferSubData(A4.ELEMENT_ARRAY_BUFFER, C3, g4);
        }
      }
      return true;
    }
    unbind(A3) {
      const g3 = this.shaderBindings[A3.shaderkey];
      g3 && g3.unbind(A3);
    }
    clearBuffers() {
      const A3 = this.__gl;
      for (const g3 in this.glattrbuffers) {
        const I3 = this.glattrbuffers[g3];
        I3.shared || A3.deleteBuffer(I3.buffer);
      }
      this.glattrbuffers = {}, this.indexBuffer && (A3.deleteBuffer(this.indexBuffer), this.indexBuffer = null);
      for (const A4 in this.shaderBindings) {
        this.shaderBindings[A4].destroy();
      }
      this.shaderBindings = {};
    }
    destroy() {
      this.clearBuffers(), this.__destroyed = true, this.emit("destructing");
    }
  };
  var Ae = {GEOMITEM_FLAG_CUTAWAY: 1, GEOMITEM_INVISIBLE_IN_GEOMDATA: 2, GEOMITEM_TRANSPARENT: 4};
  var ge = class extends V {
    constructor(A3, g3, I3, C3, i3, e3 = false) {
      if (super(), this.listenerIDs = {}, this.shattered = false, this.culled = false, this.cutDataChanged = false, this.cutData = [], this.geomMatrixDirty = false, this.gl = A3, this.geomItem = g3, this.geomItemId = I3, this.geomId = C3, this.materialId = i3, this.supportInstancing = e3, this.visible = this.geomItem.isVisible(), this.listenerIDs.visibilityChanged = this.geomItem.on("visibilityChanged", (A4) => {
        const g4 = !this.culled && this.visible;
        this.visible = A4.visible;
        const I4 = !this.culled && this.visible;
        g4 != I4 && this.emit("visibilityChanged", new O(I4));
      }), g3 instanceof dC && (this.shattered = g3.shattered), this.listenerIDs.shatterStateChanged = this.geomItem.on("shatterStateChanged", (A4) => {
        this.shattered = A4.state, this.emit("shatterStateChanged", A4);
      }), !this.supportInstancing) {
        this.cutDataChanged = false, this.cutData = [0, 0, 0, 0];
        const A4 = 0;
        let I4 = 0;
        this.geomItem.isCutawayEnabled() && (I4 |= Ae.GEOMITEM_FLAG_CUTAWAY), g3.isSelectable() || (I4 |= Ae.GEOMITEM_INVISIBLE_IN_GEOMDATA), g3.materialParam.value.isOpaque() || (I4 |= Ae.GEOMITEM_TRANSPARENT), this.geomData = [I4, A4, 0, 0], this.geomMatrixDirty = true, this.listenerIDs["GeomMat.valueChanged"] = this.geomItem.geomMatParam.on("valueChanged", () => {
          this.geomMatrixDirty = true, this.emit("updated");
        }), this.listenerIDs.cutAwayChanged = this.geomItem.on("cutAwayChanged", () => {
          this.cutDataChanged = true, this.emit("updated");
        });
        const C4 = (A5) => {
          if (A5.isOpaqueStateChanged) {
            let g4 = this.geomData[0];
            A5.isOpaque ? g4 &= ~Ae.GEOMITEM_TRANSPARENT : g4 |= Ae.GEOMITEM_TRANSPARENT, this.geomData[0], this.emit("updated");
          }
        };
        this.listenerIDs.opacityChanged = this.geomItem.on("opacityChanged", C4), this.listenerIDs["material:opacityChanged"] = this.geomItem.materialParam.on("opacityChanged", C4);
      }
    }
    getGeomItem() {
      return this.geomItem;
    }
    isVisible() {
      return !this.culled && this.visible;
    }
    getGeomItemId() {
      return this.geomItemId;
    }
    setCulled(A3) {
      const g3 = !this.culled && this.visible;
      this.culled = A3;
      const I3 = !this.culled && this.visible;
      g3 != I3 && this.emit("visibilityChanged", new O(I3));
    }
    bind(A3) {
      const g3 = this.gl, I3 = A3.unifs;
      if (!this.supportInstancing) {
        const A4 = I3.modelMatrix;
        A4 && (this.geomMatrixDirty && (this.modelMatrixArray = this.geomItem.geomMatParam.value.asArray()), g3.uniformMatrix4fv(A4.location, false, this.modelMatrixArray));
        const C4 = I3.drawItemData;
        C4 && g3.uniform4fv(C4.location, this.geomData);
        const i3 = I3.cutawayData;
        if (i3) {
          if (this.cutDataChanged && this.geomItem.isCutawayEnabled()) {
            const A5 = this.geomItem.getCutVector(), g4 = this.geomItem.getCutDist();
            this.cutData = [A5.x, A5.y, A5.z, g4];
          }
          g3.uniform4fv(i3.location, this.cutData);
        }
      }
      const C3 = I3.geomItemId;
      return C3 && g3.uniform1i(C3.location, this.geomItemId), true;
    }
    destroy() {
      this.geomItem.removeListenerById("visibilityChanged", this.listenerIDs.visibilityChanged), this.supportInstancing || (this.geomItem.geomMatParam.removeListenerById("valueChanged", this.listenerIDs["GeomMat.valueChanged"]), this.geomItem.removeListenerById("cutAwayChanged", this.listenerIDs.cutAwayChanged));
    }
  };
  var Ie = class extends DC {
    constructor(A3) {
      super(A3, "ReductionShader"), this.setShaderStage("VERTEX_SHADER", "\n\nprecision highp float;\n\nuniform int reductionTextureWidth;\nuniform sampler2D geomDataTexture;\n\nivec2 texelCoordFromVertexId(){\n  ivec2 texSize = textureSize(geomDataTexture, 0);\n  return ivec2(\n    gl_VertexID % texSize.x, \n    gl_VertexID / texSize.x\n    );\n}\n\nvec2 pointPositionFromGeomItemId(int geomItemId){\n  vec2 result = vec2(\n    (float(geomItemId % reductionTextureWidth) + 0.5) / float(reductionTextureWidth), \n    (float(geomItemId / reductionTextureWidth) + 0.5) / float(reductionTextureWidth)\n    );\n  return vec2(-1.0, -1.0) + (result * 2.0);\n}\n\nvoid main()\n{\n  // Get the texel coordinate in the source geomdata buffer.\n  // there is one point for every pixel in the geomdata texture.\n  ivec2 texelCoord = texelCoordFromVertexId();\n  int geomItemId = int(texelFetch(geomDataTexture, texelCoord, 0).g + 0.5);\n\n  if (geomItemId > 0) {\n    vec2 position = pointPositionFromGeomItemId(geomItemId);\n    gl_Position = vec4(position, 0.0, 1.0);\n    gl_PointSize = 1.0;\n  } else {\n    // Move it off screen\n    gl_Position = vec4(-2.0, -2.0, 0.0, 1.0);\n    gl_PointSize = 0.0;\n  }\n}\n\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n\n");
    }
  };
  var Ce = class extends DC {
    constructor(A3) {
      super(A3, "BoundingBoxShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec4 positions;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 cameraMatrix;\n\nuniform highp int occlusionCulling;\nuniform sampler2D reductionDataTexture;\n\nimport 'transpose.glsl'\nimport 'GLSLUtils.glsl'\nimport 'stack-gl/transpose.glsl'\nimport 'stack-gl/inverse.glsl'\nimport 'geomItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\nconst int GEOMITEM_INVISIBLE_IN_GEOMDATA = 2; // 1<<1;\n\n/* VS Outputs */\nvarying vec4 v_color;\n\nvoid main(void) {\n\n  int drawItemId = getGeomItemId();\n  vec4 geomItemData  = getInstanceData(drawItemId);\n  int flags = int(geomItemData.r + 0.5);\n\n  if (occlusionCulling != 0) {\n    // Check if in the reduction texture, this item is already flagged as visible.\n    // Note: we only draw bboxes for those that have been flagged as invisible, but might\n    // be just off screen, or onscreen, but were culled in the previous update.\n    int isVisible = int(fetchTexel(reductionDataTexture, textureSize(reductionDataTexture, 0), drawItemId).r);\n    if (isVisible > 0) {\n      return;\n    }\n    if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n      return;\n    }\n  }\n\n  vec4 bboxMin = fetchTexel(instancesTexture, instancesTextureSize, (drawItemId * pixelsPerItem) + 6);\n  vec4 bboxMax = fetchTexel(instancesTexture, instancesTextureSize, (drawItemId * pixelsPerItem) + 7);\n  mat4 viewProjectionMatrix = projectionMatrix * viewMatrix;\n\n  if (occlusionCulling != 0) {\n    // TODO: The bounding box stochastic\n    v_color = vec4(0.0, float(drawItemId), 0.0, 1.0);\n  } else {\n    v_color = fetchTexel(instancesTexture, instancesTextureSize, (drawItemId * pixelsPerItem) + 4);\n  }\n\n  vec4 pos = positions;\n  if (pos.x < 0.0) pos.x = bboxMin.x;\n  else if (pos.x > 0.0) pos.x = bboxMax.x;\n  if (pos.y < 0.0) pos.y = bboxMin.y;\n  else if (pos.y > 0.0) pos.y = bboxMax.y;\n  if (pos.z < 0.0) pos.z = bboxMin.z;\n  else if (pos.z > 0.0) pos.z = bboxMax.z;\n\n  gl_Position = viewProjectionMatrix * pos;\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\n/* VS Outputs */\nvarying vec4 v_color;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  int drawItemId = int(v_color.g);\n  fragColor = v_color;\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n");
    }
  };
  var ie = ZA("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwp2YXIgd29ya2VyX2NvZGUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHsKICAndXNlIHN0cmljdCc7CgogIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqLwogIGNvbnN0IHZlYzNfc3VidHJhY3QgPSAodmVjMSwgdmVjMikgPT4gewogICAgcmV0dXJuIFt2ZWMxWzBdIC0gdmVjMlswXSwgdmVjMVsxXSAtIHZlYzJbMV0sIHZlYzFbMl0gLSB2ZWMyWzJdXQogIH07CiAgY29uc3QgdmVjM19sZW5ndGggPSAodmVjKSA9PiB7CiAgICByZXR1cm4gTWF0aC5zcXJ0KHZlY1swXSAqIHZlY1swXSArIHZlY1sxXSAqIHZlY1sxXSArIHZlY1syXSAqIHZlY1syXSkKICB9OwogIGNvbnN0IHZlYzJfc2NhbGUgPSAodmVjLCBzY2wpID0+IHsKICAgIHJldHVybiBbdmVjWzBdICogc2NsLCB2ZWNbMV0gKiBzY2xdCiAgfTsKICBjb25zdCB2ZWMyX2xlbmd0aCA9ICh2ZWMpID0+IHsKICAgIHJldHVybiBNYXRoLnNxcnQodmVjWzBdICogdmVjWzBdICsgdmVjWzFdICogdmVjWzFdKQogIH07CgogIGNvbnN0IHF1YXRfY29uanVnYXRlID0gKHF1YXQpID0+IHsKICAgIHJldHVybiBbLXF1YXRbMF0sIC1xdWF0WzFdLCAtcXVhdFsyXSwgcXVhdFszXV0KICB9OwogIGNvbnN0IHF1YXRfbXVsdGlwbHkgPSAocXVhdDEsIHF1YXQyKSA9PiB7CiAgICBjb25zdCBheCA9IHF1YXQxWzBdOwogICAgY29uc3QgYXkgPSBxdWF0MVsxXTsKICAgIGNvbnN0IGF6ID0gcXVhdDFbMl07CiAgICBjb25zdCBhdyA9IHF1YXQxWzNdOwogICAgY29uc3QgYnggPSBxdWF0MlswXTsKICAgIGNvbnN0IGJ5ID0gcXVhdDJbMV07CiAgICBjb25zdCBieiA9IHF1YXQyWzJdOwogICAgY29uc3QgYncgPSBxdWF0MlszXTsKCiAgICByZXR1cm4gWwogICAgICBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5LAogICAgICBheSAqIGJ3ICsgYXcgKiBieSArIGF6ICogYnggLSBheCAqIGJ6LAogICAgICBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4LAogICAgICBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6LAogICAgXQogIH07CiAgY29uc3QgcXVhdF9yb3RhdGVWZWMzID0gKHF1YXQsIHZlYzMpID0+IHsKICAgIGNvbnN0IHZxID0gW3ZlYzNbMF0sIHZlYzNbMV0sIHZlYzNbMl0sIDAuMF07CiAgICBjb25zdCBwcSA9IHF1YXRfbXVsdGlwbHkocXVhdF9tdWx0aXBseShxdWF0LCB2cSksIHF1YXRfY29uanVnYXRlKHF1YXQpKTsKICAgIHJldHVybiBbcHFbMF0sIHBxWzFdLCBwcVsyXV0KICB9OwoKICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogIC8vIEZydXN0dW0gQ3VsbGluZyBkYXRhLgogIGxldCBlbmFibGVPY2NsdXNpb25DdWxsaW5nID0gZmFsc2U7CiAgY29uc3QgZ2VvbUl0ZW1zRGF0YSA9IFtdOwogIGNvbnN0IG91dE9mRnJ1c3R1bSA9IFtdOwogIGxldCBmcnVzdHVtQ3VsbGVkQ291bnQgPSAwOwogIGxldCBuZXdseUN1bGxlZCA9IFtdOwogIGxldCBuZXdseVVuQ3VsbGVkID0gW107CgogIGxldCB2aXNpYmxlQ291bnQgPSAwOwogIGNvbnN0IHRvdGFsR2VvbVN0YXRzID0gewogICAgdHJpYW5nbGVzOiAwLAogICAgbGluZXM6IDAsCiAgICBwb2ludHM6IDAsCiAgfTsKICBjb25zdCB2aXNpYmxlR2VvbVN0YXRzID0gewogICAgdHJpYW5nbGVzOiAwLAogICAgbGluZXM6IDAsCiAgICBwb2ludHM6IDAsCiAgfTsKICBjb25zdCBnZW9tU3RhdHNfYWRkVG90YWwgPSAoZ2VvbVN0YXRzKSA9PiB7CiAgICAvLyBjb25zb2xlLmxvZygnZ2VvbVN0YXRzX2FkZDonLCBnZW9tU3RhdHMudHJpYW5nbGVzLCB2aXNpYmxlR2VvbVN0YXRzLnRyaWFuZ2xlcykKICAgIHRvdGFsR2VvbVN0YXRzLnRyaWFuZ2xlcyArPSBnZW9tU3RhdHMudHJpYW5nbGVzOwogICAgdG90YWxHZW9tU3RhdHMubGluZXMgKz0gZ2VvbVN0YXRzLmxpbmVzOwogICAgdG90YWxHZW9tU3RhdHMucG9pbnRzICs9IGdlb21TdGF0cy5wb2ludHM7CiAgfTsKICBjb25zdCBnZW9tU3RhdHNfc3VidHJhY3RUb3RhbCA9IChnZW9tU3RhdHMpID0+IHsKICAgIC8vIGNvbnNvbGUubG9nKCdnZW9tU3RhdHNfc3VidHJhY3Q6JywgZ2VvbVN0YXRzLnRyaWFuZ2xlcywgdmlzaWJsZUdlb21TdGF0cy50cmlhbmdsZXMpCiAgICB0b3RhbEdlb21TdGF0cy50cmlhbmdsZXMgLT0gZ2VvbVN0YXRzLnRyaWFuZ2xlczsKICAgIHRvdGFsR2VvbVN0YXRzLmxpbmVzIC09IGdlb21TdGF0cy5saW5lczsKICAgIHRvdGFsR2VvbVN0YXRzLnBvaW50cyAtPSBnZW9tU3RhdHMucG9pbnRzOwogIH07CiAgY29uc3QgZ2VvbVN0YXRzX2FkZCA9IChnZW9tU3RhdHMpID0+IHsKICAgIC8vIGNvbnNvbGUubG9nKCdnZW9tU3RhdHNfYWRkOicsIGdlb21TdGF0cy50cmlhbmdsZXMsIHZpc2libGVHZW9tU3RhdHMudHJpYW5nbGVzKQogICAgdmlzaWJsZUNvdW50Kys7CiAgICB2aXNpYmxlR2VvbVN0YXRzLnRyaWFuZ2xlcyArPSBnZW9tU3RhdHMudHJpYW5nbGVzOwogICAgdmlzaWJsZUdlb21TdGF0cy5saW5lcyArPSBnZW9tU3RhdHMubGluZXM7CiAgICB2aXNpYmxlR2VvbVN0YXRzLnBvaW50cyArPSBnZW9tU3RhdHMucG9pbnRzOwogIH07CiAgY29uc3QgZ2VvbVN0YXRzX3N1YnRyYWN0ID0gKGdlb21TdGF0cykgPT4gewogICAgLy8gY29uc29sZS5sb2coJ2dlb21TdGF0c19zdWJ0cmFjdDonLCBnZW9tU3RhdHMudHJpYW5nbGVzLCB2aXNpYmxlR2VvbVN0YXRzLnRyaWFuZ2xlcykKICAgIHZpc2libGVDb3VudC0tOwogICAgdmlzaWJsZUdlb21TdGF0cy50cmlhbmdsZXMgLT0gZ2VvbVN0YXRzLnRyaWFuZ2xlczsKICAgIHZpc2libGVHZW9tU3RhdHMubGluZXMgLT0gZ2VvbVN0YXRzLmxpbmVzOwogICAgdmlzaWJsZUdlb21TdGF0cy5wb2ludHMgLT0gZ2VvbVN0YXRzLnBvaW50czsKICB9OwoKICBsZXQgY2FtZXJhUG9zOwogIGxldCBjYW1lcmFJbnZPcmk7CiAgbGV0IGlzT3J0aG9ncmFwaGljID0gZmFsc2U7CiAgbGV0IGZydXN0dW1IZWlnaHQgPSAwOwogIGxldCBmcnVzdHVtV2lkdGggPSAwOwogIGxldCBmcnVzdHVtSGFsZkFuZ2xlWCA9IDA7CiAgbGV0IGZydXN0dW1IYWxmQW5nbGVZID0gMDsKICBsZXQgc29saWRBbmdsZUxpbWl0ID0gMC4wMDQ7CgogIGNvbnN0IGN1bGwgPSAoaW5kZXgpID0+IHsKICAgIGlmICghb3V0T2ZGcnVzdHVtW2luZGV4XSkgewogICAgICBvdXRPZkZydXN0dW1baW5kZXhdID0gdHJ1ZTsKICAgICAgZnJ1c3R1bUN1bGxlZENvdW50Kys7CiAgICAgIG5ld2x5Q3VsbGVkLnB1c2goaW5kZXgpOwoKICAgICAgLy8gV2UgY291bGQgYmUgY3VsbGluZyBzb21ldGhpbmcgdGhhdCB3YXMgYWxyZWFkeQogICAgICAvLyBub3QgdmlzaWJsZSBpbiB0aGUgb2NjbHVzaW9uIGJ1ZmZlci4KICAgICAgaWYgKCFlbmFibGVPY2NsdXNpb25DdWxsaW5nIHx8ICFvY2NsdWRlZFtpbmRleF0pIHsKICAgICAgICBnZW9tU3RhdHNfc3VidHJhY3QoZ2VvbUl0ZW1zRGF0YVtpbmRleF0uZ2VvbVN0YXRzKTsKICAgICAgfQogICAgfQogIH07CiAgY29uc3QgdW5DdWxsID0gKGluZGV4KSA9PiB7CiAgICBpZiAob3V0T2ZGcnVzdHVtW2luZGV4XSkgewogICAgICBvdXRPZkZydXN0dW1baW5kZXhdID0gZmFsc2U7CiAgICAgIGZydXN0dW1DdWxsZWRDb3VudC0tOwogICAgICBuZXdseVVuQ3VsbGVkLnB1c2goaW5kZXgpOwoKICAgICAgLy8gT2NjbHVzaW9uIGN1bGxpbmcgY2FuIG9ubHkgZGV0ZXJtaW5lIGlmIHNvbWV0aGluZyBpcyB2aXNpYmxlCiAgICAgIC8vIG1lYW5pbmcgdGhhdCB3ZSBhc3N1bWUgaXQgaXMgbm90LCB1bnRpbCBpdCBzaG93cyB1cCBpbiB0aGUgb2NjbHVzaW9uIGJ1ZmZlci4KICAgICAgLy8gT25jZSBpdCBhcHBlYXJzIGluIHRoZSBvY2NsdXNpb24gYnVmZmVyLCB3ZSBzdGFydCByZW5kZXJpbmcgaXQgYWdhaW4uCiAgICAgIC8vIFNvLCB3aGVuIGFuIGl0ZW0gY29tZXMgYmFjayBpbnRvIHRoZSBmcnVzdHVtLCB3ZSBzdGFydCByZW5kZXJpbmcgaXRzIGJib3guCiAgICAgIC8vIFRoZW4gaWYgdGhlIGJib3ggaXMgc2Vlbiwgd2UgdGhlbiBzdGFydCBzaG93aW5nIGl0LgogICAgICBpZiAoZW5hYmxlT2NjbHVzaW9uQ3VsbGluZyAmJiAhZ2VvbUl0ZW1zRGF0YVtpbmRleF0udHJhbnNwYXJlbnQpIHsKICAgICAgICBvY2NsdWRlZFtpbmRleF0gPSB0cnVlOwogICAgICB9IGVsc2UgewogICAgICAgIGdlb21TdGF0c19hZGQoZ2VvbUl0ZW1zRGF0YVtpbmRleF0uZ2VvbVN0YXRzKTsKICAgICAgfQogICAgfQogIH07CgogIGNvbnN0IGNoZWNrR2VvbUl0ZW0gPSAoZ2VvbUl0ZW1EYXRhKSA9PiB7CiAgICBpZiAoIWdlb21JdGVtRGF0YSB8fCAhY2FtZXJhUG9zKSByZXR1cm4KICAgIGlmICghZ2VvbUl0ZW1EYXRhLnZpc2libGUpIHsKICAgICAgcmV0dXJuCiAgICB9CgogICAgLy8gU29tZSBpdGVtcywgbGlrZSBIYW5kbGVzIGFuZCB0aGUgZ3JpZCwgb3Igb3IgdGhlIFZSIGNvbnRyb2xsZXJzIHRoYXQgc2hvdWxkIG5vdCBiZSBjdWxsZWQuCiAgICBpZiAoIWdlb21JdGVtRGF0YS5jdWxsYWJsZSkgewogICAgICB1bkN1bGwoZ2VvbUl0ZW1EYXRhLmlkKTsKICAgICAgcmV0dXJuCiAgICB9CiAgICBjb25zdCBib3VuZGluZ1JhZGl1cyA9IGdlb21JdGVtRGF0YS5ib3VuZGluZ1JhZGl1czsKCiAgICBpZiAoaXNPcnRob2dyYXBoaWMpIHsKICAgICAgLy8gQ3VsbCB2ZXJ5IHNtYWxsIGl0ZW1zCiAgICAgIC8vIE5vdGU6IHdoZW4gaW4gVlIsIHRoZSBGb1YgYmVjb21lcyB2ZXJ5IHdpZGUgYW5kIHRoZSBwaXhlbAogICAgICAvLyBoZWlnaHQgdmFyaWVzLiBJdCBzZWVtcyBtb3JlIGNvbnNpc3RlbnQgdG8ganVzdCB1c2Ugc29saWRBbmdsZQogICAgICAvLyB3aGljaCBpcyByZXNvbHV0aW9uIGludmFyaWFudC4KICAgICAgY29uc3QgdmhlaWdodCA9IGJvdW5kaW5nUmFkaXVzIC8gZnJ1c3R1bUhlaWdodDsKICAgICAgaWYgKHNvbGlkQW5nbGVMaW1pdCA+IDAgJiYgdmhlaWdodCA8IHNvbGlkQW5nbGVMaW1pdCkgewogICAgICAgIGN1bGwoZ2VvbUl0ZW1EYXRhLmlkKTsKICAgICAgICByZXR1cm4KICAgICAgfQoKICAgICAgLy8gTm93IHdlIGNoZWNrIGlmIHRoZSBpdGVtIGlzIHdpdGhpbiB0aGUgdmlldyBmcnVzdHVtLgogICAgICAvLyBXZSBuZWVkIHRoZSBzb2xpZCBhbmdsZSBvZiB0aGUgaXRlbSBmb3IgZWFjaCBheGlzIChYICYgWSkKICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIGF0IHRoZSBjb3JuZXJzIG9mIHRoZSBzY3JlZW4sIHRoZSBvYmplY3QgaXMgc2xpZ2h0bHkKICAgICAgLy8gZnVydGhlciBhd2F5LCBzbyB0aGUgc29saWQgYW5nbGUgY2FsY3VsYXRlZCBhYm92ZSBnZXRzIHNtYWxsZXIuCiAgICAgIC8vIFRoaXMgd2FzIGNhdXNpbmcgaXRlbXMgd2l0aCBiaWcgYm91bmRpbmcgc3BoZXJlcyB0byBiZSBjdWxsZWQgdG9vIGVhcmx5CiAgICAgIC8vIGF0IHRoZSBjb3JuZXIgb2YgdGhlIHNjcmVlbi4KICAgICAgY29uc3QgdmVjID0gdmVjM19zdWJ0cmFjdChnZW9tSXRlbURhdGEucG9zLCBjYW1lcmFQb3MpOwogICAgICBjb25zdCB2aWV3UG9zID0gcXVhdF9yb3RhdGVWZWMzKGNhbWVyYUludk9yaSwgdmVjKTsKICAgICAgaWYgKAogICAgICAgIE1hdGguYWJzKHZpZXdQb3NbMF0pIC0gYm91bmRpbmdSYWRpdXMgPiBmcnVzdHVtV2lkdGggKiAwLjUgfHwKICAgICAgICBNYXRoLmFicyh2aWV3UG9zWzFdKSAtIGJvdW5kaW5nUmFkaXVzID4gZnJ1c3R1bUhlaWdodCAqIDAuNQogICAgICApIHsKICAgICAgICBjdWxsKGdlb21JdGVtRGF0YS5pZCk7CiAgICAgICAgcmV0dXJuCiAgICAgIH0KICAgIH0gZWxzZSB7CiAgICAgIGNvbnN0IHZlYyA9IHZlYzNfc3VidHJhY3QoZ2VvbUl0ZW1EYXRhLnBvcywgY2FtZXJhUG9zKTsKICAgICAgY29uc3QgZGlzdCA9IHZlYzNfbGVuZ3RoKHZlYyk7CiAgICAgIC8vIHVuQ3VsbCBpdGVtcyBjbG9zZSB0byB0aGUgdmlldy4KICAgICAgaWYgKGRpc3QgPCBib3VuZGluZ1JhZGl1cykgewogICAgICAgIHVuQ3VsbChnZW9tSXRlbURhdGEuaWQpOwogICAgICAgIHJldHVybgogICAgICB9CiAgICAgIC8vIEN1bGwgdmVyeSBzbWFsbCBpdGVtcwogICAgICAvLyBOb3RlOiB3aGVuIGluIFZSLCB0aGUgRm9WIGJlY29tZXMgdmVyeSB3aWRlIGFuZCB0aGUgcGl4ZWwKICAgICAgLy8gaGVpZ2h0IHZhcmllcy4gSXQgc2VlbXMgbW9yZSBjb25zaXN0ZW50IHRvIGp1c3QgdXNlIHNvbGlkQW5nbGUKICAgICAgLy8gd2hpY2ggaXMgcmVzb2x1dGlvbiBpbnZhcmlhbnQuCiAgICAgIGNvbnN0IHNvbGlkQW5nbGUgPSBNYXRoLmFzaW4oYm91bmRpbmdSYWRpdXMgLyBkaXN0KTsKICAgICAgaWYgKHNvbGlkQW5nbGVMaW1pdCA+IDAgJiYgc29saWRBbmdsZSA8IHNvbGlkQW5nbGVMaW1pdCkgewogICAgICAgIGN1bGwoZ2VvbUl0ZW1EYXRhLmlkKTsKICAgICAgICByZXR1cm4KICAgICAgfQoKICAgICAgLy8gTm93IHdlIGNoZWNrIGlmIHRoZSBpdGVtIGlzIHdpdGhpbiB0aGUgdmlldyBmcnVzdHVtLgogICAgICAvLyBXZSBuZWVkIHRoZSBzb2xpZCBhbmdsZSBvZiB0aGUgaXRlbSBmb3IgZWFjaCBheGlzIChYICYgWSkKICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIGF0IHRoZSBjb3JuZXJzIG9mIHRoZSBzY3JlZW4sIHRoZSBvYmplY3QgaXMgc2xpZ2h0bHkKICAgICAgLy8gZnVydGhlciBhd2F5LCBzbyB0aGUgc29saWQgYW5nbGUgY2FsY3VsYXRlZCBhYm92ZSBnZXRzIHNtYWxsZXIuCiAgICAgIC8vIFRoaXMgd2FzIGNhdXNpbmcgaXRlbXMgd2l0aCBiaWcgYm91bmRpbmcgc3BoZXJlcyB0byBiZSBjdWxsZWQgdG9vIGVhcmx5CiAgICAgIC8vIGF0IHRoZSBjb3JuZXIgb2YgdGhlIHNjcmVlbi4KICAgICAgY29uc3Qgdmlld1BvcyA9IHF1YXRfcm90YXRlVmVjMyhjYW1lcmFJbnZPcmksIHZlYyk7CiAgICAgIGNvbnN0IHZpZXdWZWNYWiA9IFt2aWV3UG9zWzBdLCB2aWV3UG9zWzJdXTsKICAgICAgY29uc3Qgdmlld1ZlY1laID0gW3ZpZXdQb3NbMV0sIHZpZXdQb3NbMl1dOwogICAgICBjb25zdCBkaXN0WCA9IHZlYzJfbGVuZ3RoKHZpZXdWZWNYWik7CiAgICAgIGNvbnN0IGRpc3RZID0gdmVjMl9sZW5ndGgodmlld1ZlY1laKTsKICAgICAgY29uc3Qgc29saWRBbmdsZVhaID0gTWF0aC5hc2luKGJvdW5kaW5nUmFkaXVzIC8gZGlzdFgpOwogICAgICBjb25zdCBzb2xpZEFuZ2xlWVogPSBNYXRoLmFzaW4oYm91bmRpbmdSYWRpdXMgLyBkaXN0WSk7CiAgICAgIGNvbnN0IHZpZXdWZWNOb3JtWFogPSB2ZWMyX3NjYWxlKHZpZXdWZWNYWiwgMSAvIGRpc3RYKTsKICAgICAgY29uc3Qgdmlld1ZlY05vcm1ZWiA9IHZlYzJfc2NhbGUodmlld1ZlY1laLCAxIC8gZGlzdFkpOwoKICAgICAgbGV0IHZpZXdBbmdsZTsKICAgICAgLy8gSWYgYW4gaXRlbSBpcyBiZWhpbmQgdGhlIHZpZXdlcgogICAgICBpZiAodmlld1Bvc1syXSA+IDApIHsKICAgICAgICB2aWV3QW5nbGUgPSBbCiAgICAgICAgICBNYXRoLlBJIC0gTWF0aC5hYnMoTWF0aC5hc2luKHZpZXdWZWNOb3JtWFpbMF0pKSAtIHNvbGlkQW5nbGVYWiwKICAgICAgICAgIE1hdGguUEkgLSBNYXRoLmFicyhNYXRoLmFzaW4odmlld1ZlY05vcm1ZWlswXSkpIC0gc29saWRBbmdsZVlaLAogICAgICAgIF07CiAgICAgIH0gZWxzZSB7CiAgICAgICAgdmlld0FuZ2xlID0gWwogICAgICAgICAgTWF0aC5hYnMoTWF0aC5hc2luKHZpZXdWZWNOb3JtWFpbMF0pKSAtIHNvbGlkQW5nbGVYWiwKICAgICAgICAgIE1hdGguYWJzKE1hdGguYXNpbih2aWV3VmVjTm9ybVlaWzBdKSkgLSBzb2xpZEFuZ2xlWVosCiAgICAgICAgXTsKICAgICAgfQogICAgICAvLyBjb25zb2xlLmxvZyhnZW9tSXRlbURhdGEuaWQsICdhbmdsZSBUbyBJdGVtOicsIGZydXN0dW1IYWxmQW5nbGVYLCB2aWV3QW5nbGVbMF0sIGZydXN0dW1IYWxmQW5nbGVZLCB2aWV3QW5nbGVbMV0pCiAgICAgIGlmICh2aWV3QW5nbGVbMF0gPiBmcnVzdHVtSGFsZkFuZ2xlWCB8fCB2aWV3QW5nbGVbMV0gPiBmcnVzdHVtSGFsZkFuZ2xlWSkgewogICAgICAgIGN1bGwoZ2VvbUl0ZW1EYXRhLmlkKTsKICAgICAgICByZXR1cm4KICAgICAgfQogICAgfQoKICAgIHVuQ3VsbChnZW9tSXRlbURhdGEuaWQpOwogIH07CgogIGNvbnN0IG9uVmlld1BvcnRDaGFuZ2VkID0gKGRhdGEsIHBvc3RNZXNzYWdlKSA9PiB7CiAgICBpZiAoZGF0YS5pc09ydGhvZ3JhcGhpYykgewogICAgICBpc09ydGhvZ3JhcGhpYyA9IHRydWU7CiAgICAgIGZydXN0dW1IZWlnaHQgPSBkYXRhLmZydXN0dW1IZWlnaHQ7CiAgICAgIGZydXN0dW1XaWR0aCA9IGRhdGEuZnJ1c3R1bVdpZHRoOwogICAgfSBlbHNlIHsKICAgICAgaXNPcnRob2dyYXBoaWMgPSBmYWxzZTsKICAgICAgZnJ1c3R1bUhhbGZBbmdsZVggPSBkYXRhLmZydXN0dW1IYWxmQW5nbGVYOwogICAgICBmcnVzdHVtSGFsZkFuZ2xlWSA9IGRhdGEuZnJ1c3R1bUhhbGZBbmdsZVk7CiAgICB9CgogICAgc29saWRBbmdsZUxpbWl0ID0gZGF0YS5zb2xpZEFuZ2xlTGltaXQ7CiAgICBpZiAoY2FtZXJhUG9zICYmIGNhbWVyYUludk9yaSkgewogICAgICBnZW9tSXRlbXNEYXRhLmZvckVhY2goY2hlY2tHZW9tSXRlbSk7CiAgICAgIG9uRG9uZUZydXN0dW1DdWxsKHBvc3RNZXNzYWdlKTsKICAgIH0KICB9OwoKICBjb25zdCBvblZpZXdDaGFuZ2VkID0gKGRhdGEsIHBvc3RNZXNzYWdlKSA9PiB7CiAgICBjYW1lcmFQb3MgPSBkYXRhLmNhbWVyYVBvczsKICAgIGNhbWVyYUludk9yaSA9IHF1YXRfY29uanVnYXRlKGRhdGEuY2FtZXJhT3JpKTsKICAgIHNvbGlkQW5nbGVMaW1pdCA9IGRhdGEuc29saWRBbmdsZUxpbWl0OwogICAgaWYgKGdlb21JdGVtc0RhdGEubGVuZ3RoID4gMCkgewogICAgICBnZW9tSXRlbXNEYXRhLmZvckVhY2goY2hlY2tHZW9tSXRlbSk7CiAgICAgIG9uRG9uZUZydXN0dW1DdWxsKHBvc3RNZXNzYWdlKTsKICAgIH0KICB9OwoKICBsZXQgaW5GcnVzdHVtRHJhd0lkc0J1ZmZlclBvcHVsYXRlZCA9IGZhbHNlOwogIGNvbnN0IGdlbmVyYXRlSW5GcnVzdHVtSW5kaWNlcyA9ICgpID0+IHsKICAgIGxldCBvZmZzZXQgPSAwOwogICAgb3V0T2ZGcnVzdHVtLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4gewogICAgICBpZiAoaW5kZXggPiAwICYmICF2YWx1ZSAmJiBnZW9tSXRlbXNEYXRhW2luZGV4XS52aXNpYmxlICYmICFnZW9tSXRlbXNEYXRhW2luZGV4XS50cmFuc3BhcmVudCkgb2Zmc2V0Kys7CiAgICB9KTsKICAgIC8vIENyZWF0ZSBhIGZsb2F0IGFycmF5IHRoYXQgY2FuIGJlIHVzZWQgYXMgYW4gaW5zdGFuY2VzCiAgICAvLyBhdHRyaWJ1dGUgdG8gcGFzcyBpbnRvIHRoZSBkcmF3aW5nIG9mIHRoZSBib3VuZGluZyBib3hlcy4KICAgIGNvbnN0IGluRnJ1c3R1bUluZGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KG9mZnNldCk7CiAgICBvZmZzZXQgPSAwOwogICAgb3V0T2ZGcnVzdHVtLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4gewogICAgICBpZiAoaW5kZXggPiAwICYmICF2YWx1ZSAmJiBnZW9tSXRlbXNEYXRhW2luZGV4XS52aXNpYmxlICYmICFnZW9tSXRlbXNEYXRhW2luZGV4XS50cmFuc3BhcmVudCkgewogICAgICAgIGluRnJ1c3R1bUluZGljZXNbb2Zmc2V0XSA9IGluZGV4OwogICAgICAgIG9mZnNldCsrOwogICAgICB9CiAgICB9KTsKICAgIHJldHVybiBpbkZydXN0dW1JbmRpY2VzCiAgfTsKCiAgY29uc3Qgb25Eb25lRnJ1c3R1bUN1bGwgPSAocG9zdE1lc3NhZ2UpID0+IHsKICAgIGlmICghZW5hYmxlT2NjbHVzaW9uQ3VsbGluZykgewogICAgICBjb25zdCBjb3VudEluRnJ1c3R1bSA9IGdlb21JdGVtc0RhdGEubGVuZ3RoIC0gMSAtIGZydXN0dW1DdWxsZWRDb3VudDsKCiAgICAgIHBvc3RNZXNzYWdlKHsKICAgICAgICB0eXBlOiAnQ3VsbFJlc3VsdHMnLAogICAgICAgIG5ld2x5Q3VsbGVkLAogICAgICAgIG5ld2x5VW5DdWxsZWQsCiAgICAgICAgdmlzaWJsZTogY291bnRJbkZydXN0dW0sCiAgICAgICAgdG90YWw6IGdlb21JdGVtc0RhdGEubGVuZ3RoIC0gMSwKICAgICAgICB2aXNpYmxlR2VvbVN0YXRzLAogICAgICAgIHRvdGFsR2VvbVN0YXRzLAogICAgICB9KTsKICAgIH0gZWxzZSB7CiAgICAgIC8vIGNvbnNvbGUubG9nKCdGcnVzdHVtQ3VsbFJlc3VsdHM6JywgJ25ld2x5Q3VsbGVkOicsIG5ld2x5Q3VsbGVkLCAnbmV3bHlVbkN1bGxlZDonLCBuZXdseVVuQ3VsbGVkLCBvdXRPZkZydXN0dW0pCiAgICAgIC8vIGNvbnN0IGNvdW50SW5GcnVzdHVtID0gZ2VvbUl0ZW1zRGF0YS5sZW5ndGggLSAxIC0gZnJ1c3R1bUN1bGxlZENvdW50CgogICAgICAvLyBpZiAoY291bnRJbkZydXN0dW0gPiAzMDApIHsKICAgICAgLy8gICBjb25zb2xlLmxvZygnY291bnRJbkZydXN0dW06JywgY291bnRJbkZydXN0dW0pCiAgICAgIC8vIH0KICAgICAgaWYgKG5ld2x5Q3VsbGVkLmxlbmd0aCA+IDAgfHwgbmV3bHlVbkN1bGxlZC5sZW5ndGggPiAwIHx8ICFpbkZydXN0dW1EcmF3SWRzQnVmZmVyUG9wdWxhdGVkKSB7CiAgICAgICAgY29uc3QgaW5GcnVzdHVtSW5kaWNlcyA9IGdlbmVyYXRlSW5GcnVzdHVtSW5kaWNlcygpOwoKICAgICAgICAvLyBXaGVuIG9jY2x1c2lvbiBjdWxsaW5nIGlzIG9uLCB3ZSBvbmx5IHVuY3VsbCBpdGVtcyBhZnRlciB0aGV5CiAgICAgICAgLy8gYXJlIGRldGVjdGVkIGluIHRoZSBvY2NsdXNpb24gYnVmZmVyLiBUcmFuc3BhcmVudCBpdGVtcyBhcmUgbm90CiAgICAgICAgLy8gcmVuZGVyZWQgdG8gdGhlIG9jY2x1c2lvbiBidWZmZXIsIHNvIG11c3QgYmUgdW5jdWxsZWQgaW1tZWRpYXRlbHkuCiAgICAgICAgY29uc3QgbmV3bHlVbkN1bGxlZF90cmFuc3BhcmVudCA9IFtdOwogICAgICAgIG5ld2x5VW5DdWxsZWQuZm9yRWFjaCgoaW5kZXgpID0+IHsKICAgICAgICAgIGlmIChpbmRleCA+IDAgJiYgZ2VvbUl0ZW1zRGF0YVtpbmRleF0gJiYgZ2VvbUl0ZW1zRGF0YVtpbmRleF0udmlzaWJsZSAmJiBnZW9tSXRlbXNEYXRhW2luZGV4XS50cmFuc3BhcmVudCkgewogICAgICAgICAgICBuZXdseVVuQ3VsbGVkX3RyYW5zcGFyZW50LnB1c2goaW5kZXgpOwogICAgICAgICAgfQogICAgICAgIH0pOwogICAgICAgIHBvc3RNZXNzYWdlKAogICAgICAgICAgewogICAgICAgICAgICB0eXBlOiAnSW5GcnVzdHVtSW5kaWNlcycsCiAgICAgICAgICAgIG5ld2x5Q3VsbGVkLAogICAgICAgICAgICBuZXdseVVuQ3VsbGVkOiBuZXdseVVuQ3VsbGVkX3RyYW5zcGFyZW50LAogICAgICAgICAgICAvKiBXaGVuIG9jY2x1c2lvbiBjdWxsaW5nIGlzIHJ1bm5pbmcsd2Ugb25seSBjb25zaWRlcgogICAgICAgICAgICBjdWxsaW5nIGNvbXBsZXRlZCBhZnRlciB0aGUgb2NjbHVzaW9uIGN1bGxpbmcgaXMgZG9uZS4KICAgICAgICAgICAgdmlzaWJsZTogdmlzaWJsZUNvdW50LAogICAgICAgICAgICB0b3RhbDogZ2VvbUl0ZW1zRGF0YS5sZW5ndGggLSAxLAogICAgICAgICAgICB2aXNpYmxlR2VvbVN0YXRzLAogICAgICAgICAgICB0b3RhbEdlb21TdGF0cywqLwogICAgICAgICAgICBpbkZydXN0dW1JbmRpY2VzLAogICAgICAgICAgfSwKICAgICAgICAgIFtpbkZydXN0dW1JbmRpY2VzLmJ1ZmZlcl0KICAgICAgICApOwogICAgICAgIGluRnJ1c3R1bURyYXdJZHNCdWZmZXJQb3B1bGF0ZWQgPSB0cnVlOwogICAgICB9IGVsc2UgewogICAgICAgIC8vIE5vdGU6IHRoZSBpbkZydXN0dW1EcmF3SWRzQnVmZmVyIGlzIGFscmVhZHkgdXAgdG8gZGF0ZSB3ZSBjYW4gc2tpcCB0aGlzLgogICAgICAgIHBvc3RNZXNzYWdlKHsKICAgICAgICAgIHR5cGU6ICdJbkZydXN0dW1JbmRpY2VzJywKICAgICAgICAgIG5ld2x5Q3VsbGVkOiBbXSwKICAgICAgICAgIG5ld2x5VW5DdWxsZWQ6IFtdLAogICAgICAgICAgdmlzaWJsZTogdmlzaWJsZUNvdW50LAogICAgICAgICAgdG90YWw6IGdlb21JdGVtc0RhdGEubGVuZ3RoIC0gMSwKICAgICAgICAgIHZpc2libGVHZW9tU3RhdHMsCiAgICAgICAgICB0b3RhbEdlb21TdGF0cywKICAgICAgICB9KTsKICAgICAgfQogICAgfQoKICAgIG5ld2x5Q3VsbGVkID0gW107CiAgICBuZXdseVVuQ3VsbGVkID0gW107CiAgfTsKCiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8KICAvLyBPY2NsdXNpb24gQ3VsbGluZyBkYXRhLgogIGNvbnN0IG9jY2x1ZGVkID0gW107CiAgY29uc3QgcHJvY2Vzc09jY2x1c2lvbkRhdGEgPSAoZGF0YSkgPT4gewogICAgY29uc3QgdmlzaWJsZUl0ZW1zID0gZGF0YS52aXNpYmxlSXRlbXM7CgogICAgY29uc3QgbmV3bHlDdWxsZWQgPSBbXTsKICAgIGNvbnN0IG5ld2x5VW5DdWxsZWQgPSBbXTsKICAgIHZpc2libGVJdGVtcy5zb21lKCh2YWx1ZSwgaW5kZXgpID0+IHsKICAgICAgaWYgKGluZGV4ID09IDApIHJldHVybiBmYWxzZQogICAgICBpZiAoaW5kZXggPj0gZ2VvbUl0ZW1zRGF0YS5sZW5ndGgpIHJldHVybiB0cnVlCgogICAgICBjb25zdCBnZW9tSXRlbURhdGEgPSBnZW9tSXRlbXNEYXRhW2luZGV4XTsKICAgICAgaWYgKCFnZW9tSXRlbURhdGEgfHwgIWdlb21JdGVtRGF0YS5jdWxsYWJsZSB8fCAhZ2VvbUl0ZW1EYXRhLnZpc2libGUgfHwgZ2VvbUl0ZW1EYXRhLnRyYW5zcGFyZW50KSByZXR1cm4gZmFsc2UKCiAgICAgIGlmICghb3V0T2ZGcnVzdHVtW2luZGV4XSkgewogICAgICAgIGlmICh2YWx1ZSA9PSAwKSB7CiAgICAgICAgICAvLyBOb3QgdHJhbnNwYXJlbnQgb2JqZWN0IGNhbiBub3QgYmUgb2NjbHVzaW9uIGN1bGxlZCwgYmVjYXVzZSB3ZSBkbyBub3QgcmVuZGVyIHRoZW0gdG8gdGhlCiAgICAgICAgICAvLyBvY2NsdXNpb24gYnVmZmVyLiBUaGlzIG1lYW5zIHRoZXkgY2Fubm90IG9jY2x1ZGUsIG9yIGJlIGNvbnNpZGVyZWQgb2NjbHVkZWQuCiAgICAgICAgICBpZiAoIW9jY2x1ZGVkW2luZGV4XSkgewogICAgICAgICAgICBvY2NsdWRlZFtpbmRleF0gPSB0cnVlOwogICAgICAgICAgICBuZXdseUN1bGxlZC5wdXNoKGluZGV4KTsKICAgICAgICAgICAgZ2VvbVN0YXRzX3N1YnRyYWN0KGdlb21JdGVtRGF0YS5nZW9tU3RhdHMpOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSB7CiAgICAgICAgICBpZiAob2NjbHVkZWRbaW5kZXhdKSB7CiAgICAgICAgICAgIG9jY2x1ZGVkW2luZGV4XSA9IGZhbHNlOwogICAgICAgICAgICBuZXdseVVuQ3VsbGVkLnB1c2goaW5kZXgpOwogICAgICAgICAgICBnZW9tU3RhdHNfYWRkKGdlb21JdGVtRGF0YS5nZW9tU3RhdHMpOwogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgfSk7CiAgICAvLyBOb3RlOiBldmVuIGlmIG9jY2x1c2lvbiBjdWxsaW5nIGRpZCBudCBmaWx0ZXIgb3V0IGFueSBtb3JlIGl0ZW1zCiAgICAvLyB3ZSBtdXN0IGVtaXQgdGhpcyBtZXNzYWdlIHRvIHRoZSBtYWlucyB3b3JrZXIgc28gaXQga25vd3MgdGhhdCBjdWxsaW5nIGlzIGNvbXBsZXRlZC4KICAgIHBvc3RNZXNzYWdlKHsKICAgICAgdHlwZTogJ0N1bGxSZXN1bHRzJywKICAgICAgbmV3bHlDdWxsZWQsCiAgICAgIG5ld2x5VW5DdWxsZWQsCiAgICAgIHZpc2libGU6IHZpc2libGVDb3VudCwKICAgICAgdG90YWw6IGdlb21JdGVtc0RhdGEubGVuZ3RoIC0gMSwKICAgICAgdmlzaWJsZUdlb21TdGF0cywKICAgICAgdG90YWxHZW9tU3RhdHMsCiAgICB9KTsKICB9OwoKICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwogIC8vIE1lc3NhZ2luZwogIGNvbnN0IGhhbmRsZU1lc3NhZ2UgPSAoZGF0YSwgcG9zdE1lc3NhZ2UpID0+IHsKICAgIGlmIChkYXRhLnR5cGUgPT0gJ0luaXQnKSB7CiAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXplZCBDdWxsaW5nIFdvcmtlcicpOwogICAgICBlbmFibGVPY2NsdXNpb25DdWxsaW5nID0gZGF0YS5lbmFibGVPY2NsdXNpb25DdWxsaW5nOwogICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT0gJ1ZpZXdwb3J0Q2hhbmdlZCcpIHsKICAgICAgb25WaWV3UG9ydENoYW5nZWQoZGF0YSwgcG9zdE1lc3NhZ2UpOwogICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT0gJ1ZpZXdDaGFuZ2VkJykgewogICAgICBvblZpZXdDaGFuZ2VkKGRhdGEsIHBvc3RNZXNzYWdlKTsKICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09ICdVcGRhdGVHZW9tSXRlbXMnKSB7CiAgICAgIGRhdGEucmVtb3ZlZEl0ZW1JbmRpY2VzLmZvckVhY2goKGluZGV4KSA9PiB7CiAgICAgICAgY29uc3QgZ2VvbUl0ZW1EYXRhID0gZ2VvbUl0ZW1zRGF0YVtpbmRleF07CiAgICAgICAgaWYgKGdlb21JdGVtRGF0YSAmJiBnZW9tSXRlbURhdGEudmlzaWJsZSkgewogICAgICAgICAgZ2VvbVN0YXRzX3N1YnRyYWN0VG90YWwoZ2VvbUl0ZW1EYXRhLmdlb21TdGF0cyk7CiAgICAgICAgICBpZiAoIWVuYWJsZU9jY2x1c2lvbkN1bGxpbmcgfHwgIW9jY2x1ZGVkW2luZGV4XSkgewogICAgICAgICAgICBnZW9tU3RhdHNfc3VidHJhY3QoZ2VvbUl0ZW1EYXRhLmdlb21TdGF0cyk7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIGdlb21JdGVtc0RhdGFbaW5kZXhdID0gbnVsbDsKICAgICAgICBvdXRPZkZydXN0dW1baW5kZXhdID0gdHJ1ZTsKICAgICAgfSk7CiAgICAgIGRhdGEuZ2VvbUl0ZW1zLmZvckVhY2goKGdlb21JdGVtRGF0YSkgPT4gewogICAgICAgIGNvbnN0IGluZGV4ID0gZ2VvbUl0ZW1EYXRhLmlkOwogICAgICAgIC8vIE5ldyBnZW9tcyBkZWZhdWx0IHRvIGJlaW5nIHVuLWN1bGxlZAogICAgICAgIC8vIEV4aXN0aW5nIGdlb21zIHRoYXQgbWF5IGJlIGNoYW5naW5nIHN0YXRlLCBsaWtlIGNoYW5naW5nCiAgICAgICAgLy8gdmlzaWJpbGl0eSBvciB0cmFuc2Zvcm1hdGlvbnMgc2hvdWxkIHNpbXBseSB1cGRhdGUuCiAgICAgICAgaWYgKCFnZW9tSXRlbXNEYXRhW2luZGV4XSkgewogICAgICAgICAgb3V0T2ZGcnVzdHVtW2luZGV4XSA9IGZhbHNlOwogICAgICAgICAgaWYgKGdlb21JdGVtRGF0YS52aXNpYmxlKSB7CiAgICAgICAgICAgIGdlb21TdGF0c19hZGRUb3RhbChnZW9tSXRlbURhdGEuZ2VvbVN0YXRzKTsKICAgICAgICAgICAgZ2VvbVN0YXRzX2FkZChnZW9tSXRlbURhdGEuZ2VvbVN0YXRzKTsKICAgICAgICAgIH0KICAgICAgICB9IGVsc2UgewogICAgICAgICAgLy8gYXJlIGVpdGhlciBhZGRpbmcgYSBuZXcgaXRlbSwgb3IgdW5oaWRpbmcgYW4gZXhpc3RpbmcgaXRlbS4KICAgICAgICAgIGNvbnN0IGJlY29taW5nVmlzaWJsZSA9ICFnZW9tSXRlbXNEYXRhW2luZGV4XS52aXNpYmxlICYmIGdlb21JdGVtRGF0YS52aXNpYmxlOwogICAgICAgICAgY29uc3QgYmVjb21pbmdJblZpc2libGUgPSBnZW9tSXRlbXNEYXRhW2luZGV4XS52aXNpYmxlICYmICFnZW9tSXRlbURhdGEudmlzaWJsZTsKICAgICAgICAgIGlmIChiZWNvbWluZ1Zpc2libGUpIHsKICAgICAgICAgICAgZ2VvbVN0YXRzX2FkZFRvdGFsKGdlb21JdGVtRGF0YS5nZW9tU3RhdHMpOwogICAgICAgICAgICBvdXRPZkZydXN0dW1baW5kZXhdID0gdHJ1ZTsKICAgICAgICAgICAgb2NjbHVkZWRbaW5kZXhdID0gZmFsc2U7CiAgICAgICAgICAgIC8vIGlmICghb3V0T2ZGcnVzdHVtW2luZGV4XSAmJiAhb2NjbHVkZWRbaW5kZXhdKSB7CiAgICAgICAgICAgIC8vICAgZ2VvbVN0YXRzX2FkZChnZW9tSXRlbURhdGEuZ2VvbVN0YXRzKQogICAgICAgICAgICAvLyB9CiAgICAgICAgICB9IGVsc2UgaWYgKGJlY29taW5nSW5WaXNpYmxlKSB7CiAgICAgICAgICAgIGdlb21TdGF0c19zdWJ0cmFjdFRvdGFsKGdlb21JdGVtRGF0YS5nZW9tU3RhdHMpOwogICAgICAgICAgICBpZiAoIW91dE9mRnJ1c3R1bVtpbmRleF0gJiYgKCFlbmFibGVPY2NsdXNpb25DdWxsaW5nIHx8ICFvY2NsdWRlZFtpbmRleF0pKSB7CiAgICAgICAgICAgICAgZ2VvbVN0YXRzX3N1YnRyYWN0KGdlb21JdGVtRGF0YS5nZW9tU3RhdHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIG91dE9mRnJ1c3R1bVtpbmRleF0gPSB0cnVlOwogICAgICAgICAgICBvY2NsdWRlZFtpbmRleF0gPSBmYWxzZTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIGNvbnN0IGJlY29taW5nVHJhbnNwYXJlbnQgPSAhZ2VvbUl0ZW1zRGF0YVtpbmRleF0udHJhbnNwYXJlbnQgJiYgZ2VvbUl0ZW1EYXRhLnRyYW5zcGFyZW50OwogICAgICAgICAgICBjb25zdCBiZWNvbWluZ09wYXF1ZSA9IGdlb21JdGVtc0RhdGFbaW5kZXhdLnRyYW5zcGFyZW50ICYmICFnZW9tSXRlbURhdGEudHJhbnNwYXJlbnQ7CiAgICAgICAgICAgIGlmIChiZWNvbWluZ1RyYW5zcGFyZW50KSB7CiAgICAgICAgICAgICAgaWYgKGVuYWJsZU9jY2x1c2lvbkN1bGxpbmcgJiYgIW91dE9mRnJ1c3R1bVtpbmRleF0gJiYgb2NjbHVkZWRbaW5kZXhdKSB7CiAgICAgICAgICAgICAgICAvLyBJdGVtcyBiZWNvbWluZyB0cmFuc3BhcmVudCBtdXN0IGJlIHVuY3VsbGVkIGltbWVkaWF0ZWx5LgogICAgICAgICAgICAgICAgbmV3bHlVbkN1bGxlZC5wdXNoKGluZGV4KTsKICAgICAgICAgICAgICAgIGdlb21TdGF0c19hZGQoZ2VvbUl0ZW1EYXRhLmdlb21TdGF0cyk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9IGVsc2UgaWYgKGJlY29taW5nT3BhcXVlKSB7CiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0JlY29taW5nIG9wYXF1ZTonLCBpbmRleCkKICAgICAgICAgICAgICAvLyBJdGVtcyBiZWNvbWluZyB0cmFuc3BhcmVudCBtdXN0IGJlIHVuY3VsbGVkIGltbWVkaWF0ZWx5LgogICAgICAgICAgICAgIC8vIE9jY2x1c2lvbiBjdWxsaW5nIGNhbiBvbmx5IGRldGVybWluZSBpZiBzb21ldGhpbmcgaXMgdmlzaWJsZQogICAgICAgICAgICAgIC8vIG1lYW5pbmcgdGhhdCB3ZSBhc3N1bWUgaXQgaXMgbm90LCB1bnRpbCBpdCBzaG93cyB1cCBpbiB0aGUgb2NjbHVzaW9uIGJ1ZmZlci4KICAgICAgICAgICAgICAvLyBPbmNlIGl0IGFwcGVhcnMgaW4gdGhlIG9jY2x1c2lvbiBidWZmZXIsIHdlIHN0YXJ0IHJlbmRlcmluZyBpdCBhZ2Fpbi4KICAgICAgICAgICAgICAvLyBTbywgd2hlbiBhbiBpdGVtIGNvbWVzIGJhY2sgaW50byB0aGUgZnJ1c3R1bSwgd2Ugc3RhcnQgcmVuZGVyaW5nIGl0cyBiYm94LgogICAgICAgICAgICAgIC8vIFRoZW4gaWYgdGhlIGJib3ggaXMgc2Vlbiwgd2UgdGhlbiBzdGFydCBzaG93aW5nIGl0LgogICAgICAgICAgICAgIGlmIChlbmFibGVPY2NsdXNpb25DdWxsaW5nICYmICFvdXRPZkZydXN0dW1baW5kZXhdKSB7CiAgICAgICAgICAgICAgICBvY2NsdWRlZFtpbmRleF0gPSB0cnVlOwogICAgICAgICAgICAgICAgZ2VvbVN0YXRzX3N1YnRyYWN0KGdlb21JdGVtRGF0YS5nZW9tU3RhdHMpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBnZW9tSXRlbXNEYXRhW2luZGV4XSA9IGdlb21JdGVtRGF0YTsKICAgICAgICBjaGVja0dlb21JdGVtKGdlb21JdGVtc0RhdGFbaW5kZXhdKTsKICAgICAgfSk7CiAgICAgIGluRnJ1c3R1bURyYXdJZHNCdWZmZXJQb3B1bGF0ZWQgPSBmYWxzZTsKICAgICAgb25Eb25lRnJ1c3R1bUN1bGwocG9zdE1lc3NhZ2UpOwogICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT0gJ09jY2x1c2lvbkRhdGEnKSB7CiAgICAgIHByb2Nlc3NPY2NsdXNpb25EYXRhKGRhdGEpOwogICAgfQogIH07CgogIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7CiAgICBoYW5kbGVNZXNzYWdlKGV2ZW50LmRhdGEsIHNlbGYucG9zdE1lc3NhZ2UpOwogIH07CgogIGV4cG9ydHMuaGFuZGxlTWVzc2FnZSA9IGhhbmRsZU1lc3NhZ2U7CgogIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7CgogIHJldHVybiBleHBvcnRzOwoKfSkoe30pOwoK", null, false);
  function ee(A3, g3, I3, C3, i3, e3 = 0, t3 = 0) {
    return mA(this, void 0, void 0, function* () {
      const B3 = A3.fenceSync(A3.SYNC_GPU_COMMANDS_COMPLETE, 0);
      return A3.flush(), yield function(A4, g4, I4, C4) {
        return new Promise((i4, e4) => {
          !function t4() {
            const B4 = A4.clientWaitSync(g4, I4, 0);
            B4 != A4.WAIT_FAILED ? B4 != A4.TIMEOUT_EXPIRED ? i4() : setTimeout(t4, C4) : e4();
          }();
        });
      }(A3, B3, 0, 10), A3.deleteSync(B3), A3.bindBuffer(g3, I3), A3.getBufferSubData(g3, C3, i3, e3, t3), A3.bindBuffer(g3, null), i3;
    });
  }
  var te = class extends Yg {
    constructor() {
      super(), this.setNumVertices(8);
      const A3 = this.getVertexAttribute("positions");
      A3.getValueRef(0).set(0.5, -0.5, 0.5), A3.getValueRef(1).set(0.5, 0.5, 0.5), A3.getValueRef(2).set(-0.5, 0.5, 0.5), A3.getValueRef(3).set(-0.5, -0.5, 0.5), A3.getValueRef(4).set(0.5, -0.5, -0.5), A3.getValueRef(5).set(0.5, 0.5, -0.5), A3.getValueRef(6).set(-0.5, 0.5, -0.5), A3.getValueRef(7).set(-0.5, -0.5, -0.5), this.setNumSegments(34), this.setSegmentVertexIndices(0, 0, 1), this.setSegmentVertexIndices(1, 0, 2), this.setSegmentVertexIndices(2, 0, 3), this.setSegmentVertexIndices(3, 0, 4), this.setSegmentVertexIndices(4, 0, 5), this.setSegmentVertexIndices(5, 0, 6), this.setSegmentVertexIndices(6, 0, 7), this.setSegmentVertexIndices(7, 1, 0), this.setSegmentVertexIndices(8, 1, 2), this.setSegmentVertexIndices(9, 1, 3), this.setSegmentVertexIndices(10, 1, 4), this.setSegmentVertexIndices(11, 1, 5), this.setSegmentVertexIndices(12, 1, 6), this.setSegmentVertexIndices(13, 1, 7), this.setSegmentVertexIndices(14, 2, 0), this.setSegmentVertexIndices(15, 2, 1), this.setSegmentVertexIndices(16, 2, 3), this.setSegmentVertexIndices(17, 2, 4), this.setSegmentVertexIndices(18, 2, 5), this.setSegmentVertexIndices(19, 2, 6), this.setSegmentVertexIndices(20, 2, 7), this.setSegmentVertexIndices(21, 3, 1), this.setSegmentVertexIndices(22, 3, 2), this.setSegmentVertexIndices(23, 3, 0), this.setSegmentVertexIndices(24, 3, 4), this.setSegmentVertexIndices(25, 3, 5), this.setSegmentVertexIndices(26, 3, 6), this.setSegmentVertexIndices(27, 3, 7), this.setSegmentVertexIndices(28, 4, 5), this.setSegmentVertexIndices(29, 4, 6), this.setSegmentVertexIndices(30, 4, 7), this.setSegmentVertexIndices(31, 5, 6), this.setSegmentVertexIndices(32, 5, 7), this.setSegmentVertexIndices(33, 6, 7);
    }
  };
  var Be = class extends V {
    constructor(A3, g3) {
      var I3;
      super(), this.glGeomItems = [null], this.glGeomItemEventHandlers = [], this.glGeomItemsMap = {}, this.glGeomItemsIndexFreeList = [], this.dirtyItemIndices = [], this.dirtyWorkerItemIndices = new Set(), this.removedItemIndices = [], this.glGeomItemsTexture = null, this.xrPresenting = false, this.xrFovY = 0, this.xrProjectionMatrix = new h(), this.debugOcclusionBuffer = false, this.inFrustumIndicesCount = 0, this.drawIdsBufferDirty = false, this.timer_query_ext = null, this.renderer = A3, this.enableFrustumCulling = g3.enableFrustumCulling || g3.enableOcclusionCulling;
      const C3 = this.renderer.gl;
      this.enableOcclusionCulling = g3.enableOcclusionCulling && C3.name == "webgl2", this.debugOcclusionBuffer = (I3 = g3.debugOcclusionBuffer) !== null && I3 !== void 0 && I3, this.enableFrustumCulling && this.setupCullingWorker(A3);
    }
    setupCullingWorker(A3) {
      this.worker = new ie(), this.worker.postMessage({type: "Init", enableOcclusionCulling: this.enableOcclusionCulling});
      let g3 = true;
      this.worker.onmessage = (A4) => {
        A4.data.type == "InFrustumIndices" ? this.enableOcclusionCulling ? (A4.data.newlyCulled && this.applyCullResults(A4.data), this.calculateOcclusionCulling(A4.data.inFrustumIndices)) : (this.applyCullResults(A4.data), this.emitCullingUpdateData(A4.data), g3 = true) : A4.data.type == "CullResults" ? (this.applyCullResults(A4.data), this.emitCullingUpdateData(A4.data), g3 = true) : A4.data.type == "Done" && this.renderer.emit("CullingUpdated"), g3 = true;
      };
      const I3 = () => {
        const g4 = A3.getViewport(), I4 = A3.getViewport().getCamera(), C4 = g4.getWidth() / g4.getHeight();
        if (I4.isOrthographic()) {
          const g5 = I4.getFrustumHeight(), i4 = g5 * C4;
          this.worker.postMessage({type: "ViewportChanged", frustumHeight: g5, frustumWidth: i4, isOrthographic: true, solidAngleLimit: A3.solidAngleLimit});
        } else {
          const g5 = 0.5 * I4.getFov(), i4 = Math.atan(Math.tan(g5) * C4);
          this.worker.postMessage({type: "ViewportChanged", frustumHalfAngleX: i4, frustumHalfAngleY: g5, isOrthographic: false, solidAngleLimit: A3.solidAngleLimit});
        }
      };
      A3.on("resized", I3);
      const C3 = A3.getViewport().getCamera();
      C3.on("projectionParamChanged", (A4) => {
        C3.isOrthographic() && I3();
      }), I3(), A3.once("xrViewportSetup", (g4) => {
        this.xrViewport = g4.xrViewport;
        const C4 = g4.xrViewport;
        C4.on("presentingChanged", (g5) => {
          if (this.xrPresenting = g5.state, g5.state) {
            e3 = 10;
            const g6 = Math.PI / 180;
            let I4 = 62 * g6, i4 = 50 * g6;
            if (C4.getHMDName() === "Vive")
              I4 *= 0.6, i4 *= 0.6;
            else
              I4 *= 0.5, i4 *= 0.5;
            this.xrFovY = 2 * I4;
            const t4 = 1.24, B3 = C4.depthRange[0], o3 = C4.depthRange[1];
            this.xrProjectionMatrix.setPerspectiveMatrix(this.xrFovY, t4, B3, o3), this.worker.postMessage({type: "ViewportChanged", frustumHalfAngleX: i4, frustumHalfAngleY: I4, isOrthographic: false, solidAngleLimit: A3.solidAngleLimit});
          } else
            e3 = 5, I3(), t3();
        });
      });
      let i3 = 0, e3 = 5;
      A3.on("viewChanged", (I4) => {
        if (g3) {
          if (i3 % e3 == 0) {
            g3 = false;
            const C4 = I4.viewXfo.tr, i4 = I4.viewXfo.ori;
            this.worker.postMessage({type: "ViewChanged", cameraPos: C4.asArray(), cameraOri: i4.asArray(), solidAngleLimit: A3.solidAngleLimit});
          }
          i3++;
        }
      });
      const t3 = () => {
        const g4 = A3.getViewport().getCamera().globalXfoParam.value, I4 = g4.tr, C4 = g4.ori;
        this.worker.postMessage({type: "ViewChanged", cameraPos: I4.asArray(), cameraOri: C4.asArray(), solidAngleLimit: A3.solidAngleLimit});
      };
      if (A3.getViewport().getCamera().on("movementFinished", t3), t3(), this.enableOcclusionCulling) {
        const A4 = this.renderer.gl;
        this.timer_query_ext = A4.getExtension("EXT_disjoint_timer_query_webgl2");
        let g4 = 1 / window.devicePixelRatio;
        const I4 = Math.ceil(this.renderer.getWidth() * g4), C4 = Math.ceil(this.renderer.getHeight() * g4);
        this.occlusionDataBuffer = new LC(A4, {type: A4.FLOAT, format: A4.RGBA, minFilter: A4.NEAREST, magFilter: A4.NEAREST, width: I4, height: C4, depthType: A4.UNSIGNED_SHORT, depthFormat: A4.DEPTH_COMPONENT, depthInternalFormat: A4.DEPTH_COMPONENT16}), this.renderer.on("resized", (A5) => {
          this.xrPresenting || this.occlusionDataBuffer.resize(Math.ceil(A5.width * g4), Math.ceil(A5.height * g4));
        }), this.reductionDataBuffer = new LC(A4, {type: A4.UNSIGNED_BYTE, internalFormat: A4.R8, format: A4.RED, minFilter: A4.NEAREST, magFilter: A4.NEAREST, width: 1, height: 1, depthType: A4.UNSIGNED_SHORT, depthFormat: A4.DEPTH_COMPONENT, depthInternalFormat: A4.DEPTH_COMPONENT16}), this.bbox = new ji(A4, new te()), this.reductionShader = new Ie(A4), this.boundingBoxShader = new Ce(A4), this.boundingBoxShader.compileForTarget("GLGeomItemLibrary", {directives: this.renderer.directives}), this.inFrustumIndicesCount = 0;
      }
    }
    applyCullResults(A3) {
      A3.newlyCulled && A3.newlyCulled.forEach((A4) => {
        this.glGeomItems[A4] && this.glGeomItems[A4].setCulled(true);
      }), A3.newlyUnCulled && A3.newlyUnCulled.forEach((A4) => {
        this.glGeomItems[A4] && this.glGeomItems[A4].setCulled(false);
      }), this.renderer.requestRedraw();
    }
    emitCullingUpdateData(A3) {
      var g3, I3;
      this.renderer.emit("CullingUpdated", {culled: (g3 = A3.newlyCulled) === null || g3 === void 0 ? void 0 : g3.length, unCulled: (I3 = A3.newlyUnCulled) === null || I3 === void 0 ? void 0 : I3.length, visible: A3.visible, total: A3.total, visibleGeomStats: A3.visibleGeomStats, totalGeomStats: A3.totalGeomStats});
    }
    updateCulledDrawIDsBuffer(A3) {
      const g3 = this.renderer.gl;
      if (!g3.floatTexturesSupported)
        return void (this.drawIdsBufferDirty = false);
      this.inFrustumDrawIdsBuffer && this.inFrustumIndicesCount != A3.length && (g3.deleteBuffer(this.inFrustumDrawIdsBuffer), this.inFrustumDrawIdsBuffer = null), this.inFrustumDrawIdsBuffer || (this.inFrustumDrawIdsBuffer = g3.createBuffer(), g3.bindBuffer(g3.ARRAY_BUFFER, this.inFrustumDrawIdsBuffer)), g3.bindBuffer(g3.ARRAY_BUFFER, this.inFrustumDrawIdsBuffer), g3.bufferData(g3.ARRAY_BUFFER, A3, g3.STATIC_DRAW), this.inFrustumIndicesCount = A3.length, this.drawIdsBufferDirty = false;
      const I3 = Math.max(4, r.nextPow2(Math.round(Math.sqrt(this.glGeomItems.length) + 0.5)));
      this.reductionDataBuffer.width != I3 && (this.reductionDataBuffer.resize(I3, I3), this.reductionDataArray = new Uint8Array(I3 * I3));
    }
    calculateOcclusionCulling(A3) {
      if (A3 && A3.length > 0 && this.updateCulledDrawIDsBuffer(A3), this.inFrustumIndicesCount == 0)
        return void this.worker.postMessage({type: "OcclusionData", visibleItems: []});
      const g3 = this.renderer.gl, I3 = new qC(g3);
      this.renderer.bindGLBaseRenderer(I3), I3.directives = [...this.renderer.directives, "#define DRAW_GEOMDATA"], I3.shaderopts.directives = I3.directives, I3.floatGeomBuffer = true, I3.occlusionCulling = 1, this.xrPresenting ? (this.xrViewport.initCullingRenderState(I3), I3.viewports[0].fovY = this.xrFovY, I3.viewports[0].projectionMatrix = this.xrProjectionMatrix) : this.renderer.getViewport().initRenderState(I3);
      const C3 = this.occlusionDataBuffer.width * this.occlusionDataBuffer.height, i3 = this.timer_query_ext, e3 = (A4, I4, e4) => {
        this.reductionDataBuffer.bindForWriting(A4, I4), I4 || (g3.enable(g3.BLEND), g3.blendEquation(g3.FUNC_ADD), g3.blendFunc(g3.SRC_COLOR, g3.DST_COLOR)), this.reductionShader.bind(A4);
        const {geomDataTexture: t4, reductionTextureWidth: B4} = A4.unifs;
        t4 && this.occlusionDataBuffer.bindToUniform(A4, t4), B4 && g3.uniform1i(B4.location, this.reductionDataBuffer.width), i3 && g3.beginQuery(i3.TIME_ELAPSED_EXT, e4), g3.drawArrays(g3.POINTS, 0, C3), i3 && g3.endQuery(i3.TIME_ELAPSED_EXT), I4 || g3.disable(g3.BLEND), this.reductionDataBuffer.unbindForWriting(A4);
      };
      let t3, B3, o3, s3;
      i3 && (t3 = g3.createQuery(), g3.beginQuery(i3.TIME_ELAPSED_EXT, t3)), ((A4) => {
        this.occlusionDataBuffer.bindForWriting(A4, true), A4.glDisable(g3.BLEND), A4.glDisable(g3.CULL_FACE), A4.glEnable(g3.DEPTH_TEST), g3.depthFunc(g3.LESS), g3.depthMask(true);
        this.renderer.getPass(0).drawGeomData(A4);
        this.renderer.getPass(1).drawGeomData(A4), this.occlusionDataBuffer.unbindForWriting(A4);
      })(I3), i3 && g3.endQuery(i3.TIME_ELAPSED_EXT), i3 && (B3 = g3.createQuery()), e3(I3, true, B3), i3 && (o3 = g3.createQuery(), g3.beginQuery(i3.TIME_ELAPSED_EXT, o3)), (() => {
        this.occlusionDataBuffer.bindForWriting(I3, false), this.debugOcclusionBuffer || (g3.colorMask(true, true, true, true), g3.clearColor(0, 0, 0, 0), g3.clear(g3.COLOR_BUFFER_BIT)), this.boundingBoxShader.bind(I3, "GLGeomItemLibrary"), this.bbox.bind(I3);
        const {instancesTexture: A4, instancesTextureSize: C4, instancedDraw: i4, reductionDataTexture: e4, occlusionCulling: t4} = I3.unifs;
        this.glGeomItemsTexture.bindToUniform(I3, A4), g3.uniform1i(C4.location, this.glGeomItemsTexture.width), g3.uniform1i(i4.location, 1), g3.uniform1i(t4.location, 1), this.reductionDataBuffer.bindColorTexture(I3, e4);
        const B4 = I3.attrs.instancedIds.location;
        g3.enableVertexAttribArray(B4), g3.bindBuffer(g3.ARRAY_BUFFER, this.inFrustumDrawIdsBuffer), g3.vertexAttribPointer(B4, 1, g3.FLOAT, false, 4, 0), g3.vertexAttribDivisor(B4, 1), I3.bindViewports(I3.unifs, () => {
          this.bbox.drawInstanced(I3, this.inFrustumIndicesCount);
        }), this.occlusionDataBuffer.unbindForWriting(I3);
      })(), i3 && g3.endQuery(i3.TIME_ELAPSED_EXT), i3 && (s3 = g3.createQuery()), e3(I3, false, s3);
      const a3 = {numReductionPoints: C3}, l3 = (A4, I4) => {
        const C4 = g3.getQueryParameter(I4, g3.QUERY_RESULT_AVAILABLE), e4 = g3.getParameter(i3.GPU_DISJOINT_EXT);
        if (C4 && !e4) {
          const C5 = g3.getQueryParameter(I4, g3.QUERY_RESULT);
          a3[A4] = C5 / 1e6, g3.deleteQuery(I4);
        }
      }, n3 = this.reductionDataBuffer.width, d3 = this.reductionDataBuffer.height, h3 = g3.RED, c3 = g3.UNSIGNED_BYTE;
      this.reductionDataBuffer.bindForReading(), function(A4, g4, I4, C4, i4, e4, t4, B4) {
        return mA(this, void 0, void 0, function* () {
          const o4 = A4.createBuffer();
          return A4.bindBuffer(A4.PIXEL_PACK_BUFFER, o4), A4.bufferData(A4.PIXEL_PACK_BUFFER, B4.byteLength, A4.STREAM_READ), A4.readPixels(g4, I4, C4, i4, e4, t4, 0), A4.bindBuffer(A4.PIXEL_PACK_BUFFER, null), yield ee(A4, A4.PIXEL_PACK_BUFFER, o4, 0, B4), A4.deleteBuffer(o4), B4;
        });
      }(g3, 0, 0, n3, d3, h3, c3, this.reductionDataArray).then(() => {
        this.reductionDataBuffer.unbindForReading(), i3 && (l3("queryDrawScene", t3), l3("queryDrawCulledBBoxes", o3), l3("queryReduceSceneGeoms", B3), l3("queryReduceBBoxes", s3), this.renderer.emit("occlusionCullingProfilingData", a3)), this.worker.postMessage({type: "OcclusionData", visibleItems: this.reductionDataArray});
      });
    }
    addGeomItem(A3) {
      let g3 = this.glGeomItemsMap[A3.getId()];
      if (g3 != null)
        return this.glGeomItems[g3];
      performance.now();
      const I3 = A3.materialParam;
      let C3 = I3.value, i3 = -1;
      i3 = this.renderer.glMaterialLibrary.addMaterial(C3);
      const e3 = () => {
        this.renderer.glMaterialLibrary.removeMaterial(C3), C3 = I3.value, n3.materialId = this.renderer.glMaterialLibrary.addMaterial(C3), h3(), d3();
      };
      I3.on("valueChanged", e3);
      const t3 = A3.geomParam;
      let B3 = t3.value;
      const o3 = this.renderer.glGeomLibrary.addGeom(B3), s3 = () => {
        this.renderer.glGeomLibrary.removeGeom(B3), B3 = t3.value, n3.geomId = this.renderer.glGeomLibrary.addGeom(B3), this.enableFrustumCulling && this.dirtyWorkerItemIndices.add(g3), d3();
      };
      t3.on("valueChanged", s3), this.glGeomItemsIndexFreeList.length > 0 ? g3 = this.glGeomItemsIndexFreeList.pop() : (g3 = this.glGeomItems.length, this.glGeomItems.push(null)), this.removedItemIndices.includes(g3) && this.removedItemIndices.splice(this.removedItemIndices.indexOf(g3), 1), this.dirtyItemIndices.push(g3);
      const a3 = this.renderer.gl, l3 = a3.floatTexturesSupported, n3 = new ge(a3, A3, g3, o3, i3, l3), d3 = () => {
        this.dirtyItemIndices.includes(g3) || (this.dirtyItemIndices.push(g3), this.renderer.drawItemChanged());
      };
      A3.geomMatParam.on("valueChanged", d3), A3.on("cutAwayChanged", d3), A3.on("highlightChanged", d3), A3.on("selectabilityChanged", d3), A3.on("opacityChanged", d3);
      const h3 = () => {
        this.enableFrustumCulling && (this.dirtyWorkerItemIndices.has(g3) || (this.dirtyWorkerItemIndices.add(g3), this.renderer.drawItemChanged()));
      };
      return this.enableFrustumCulling && this.dirtyWorkerItemIndices.add(g3), A3.on("visibilityChanged", h3), A3.on("opacityChanged", h3), A3.geomMatParam.on("valueChanged", h3), t3.on("boundingBoxChanged", h3), this.glGeomItems[g3] = n3, this.glGeomItemEventHandlers[g3] = {geomItemChanged: d3, materialChanged: e3, geomChanged: s3, workerItemDataChanged: h3}, this.glGeomItemsMap[A3.getId()] = g3, this.renderer.requestRedraw(), n3;
    }
    removeGeomItem(A3) {
      const g3 = this.glGeomItemsMap[A3.getId()];
      if (g3 == null)
        return null;
      const I3 = this.glGeomItems[g3], C3 = A3.geomParam.value;
      this.renderer.glGeomLibrary.removeGeom(C3);
      const i3 = A3.materialParam.value;
      this.renderer.glMaterialLibrary.removeMaterial(i3);
      const e3 = this.glGeomItemEventHandlers[g3], t3 = A3.geomParam;
      return A3.materialParam.off("valueChanged", e3.materialChanged), t3.off("valueChanged", e3.geomChanged), A3.geomMatParam.off("valueChanged", e3.geomItemChanged), A3.off("cutAwayChanged", e3.geomItemChanged), A3.off("highlightChanged", e3.geomItemChanged), A3.off("selectabilityChanged", e3.geomItemChanged), A3.off("opacityChanged", e3.geomItemChanged), A3.off("visibilityChanged", e3.workerItemDataChanged), A3.geomMatParam.off("valueChanged", e3.workerItemDataChanged), t3.off("boundingBoxChanged", e3.workerItemDataChanged), A3.off("opacityChanged", e3.workerItemDataChanged), this.glGeomItems[g3] = null, this.glGeomItemEventHandlers[g3] = null, this.glGeomItemsIndexFreeList.push(g3), delete this.glGeomItemsMap[A3.getId()], this.removedItemIndices.push(g3), this.dirtyWorkerItemIndices.has(g3) && this.dirtyWorkerItemIndices.delete(g3), this.renderer.requestRedraw(), I3;
    }
    getGeomItem(A3) {
      var g3;
      if (!(A3 >= this.glGeomItems.length))
        return (g3 = this.glGeomItems[A3]) === null || g3 === void 0 ? void 0 : g3.geomItem;
      console.warn("Invalid Draw Item id:" + A3 + " NumItems:" + (this.glGeomItems.length - 1));
    }
    getGLGeomItem(A3) {
      const g3 = this.glGeomItemsMap[A3.getId()];
      return g3 != null ? this.glGeomItems[g3] : null;
    }
    populateDrawItemDataArray(A3, g3, I3) {
      const C3 = this.glGeomItems[A3];
      if (!C3)
        return;
      const {geomItem: i3, geomId: e3} = C3, t3 = i3.materialParam.value, B3 = 32 * g3;
      let o3 = 0;
      i3.isCutawayEnabled() && (o3 |= Ae.GEOMITEM_FLAG_CUTAWAY), i3.isSelectable() || (o3 |= Ae.GEOMITEM_INVISIBLE_IN_GEOMDATA), t3.isOpaque() && i3.isOpaque() || (o3 |= Ae.GEOMITEM_TRANSPARENT);
      const a3 = new s(new Float32Array(I3.buffer, 4 * (B3 + 0), 4));
      a3.set(o3, i3.opacity, 0, 0);
      const l3 = this.renderer.glMaterialLibrary.getMaterialAllocation(t3);
      l3 && (a3.z = l3.start), a3.w = e3;
      const n3 = i3.geomMatParam.value, d3 = new s(new Float32Array(I3.buffer, 4 * (B3 + 4), 4)), h3 = new s(new Float32Array(I3.buffer, 4 * (B3 + 8), 4)), c3 = new s(new Float32Array(I3.buffer, 4 * (B3 + 12), 4));
      d3.set(n3.xAxis.x, n3.yAxis.x, n3.zAxis.x, n3.translation.x), h3.set(n3.xAxis.y, n3.yAxis.y, n3.zAxis.y, n3.translation.y), c3.set(n3.xAxis.z, n3.yAxis.z, n3.zAxis.z, n3.translation.z);
      const r3 = new s(new Float32Array(I3.buffer, 4 * (B3 + 16), 4));
      if (i3.isHighlighted()) {
        const A4 = i3.getHighlight();
        r3.set(A4.r, A4.g, A4.b, A4.a);
      }
      const G3 = new s(new Float32Array(I3.buffer, 4 * (B3 + 20), 4));
      if (i3.isCutawayEnabled()) {
        const A4 = i3.getCutVector(), g4 = i3.getCutDist();
        G3.set(A4.x, A4.y, A4.z, g4);
      }
      const m3 = i3.boundingBoxParam.value, Q3 = new s(new Float32Array(I3.buffer, 4 * (B3 + 24))), E3 = new s(new Float32Array(I3.buffer, 4 * (B3 + 28)));
      Q3.set(m3.p0.x, m3.p0.y, m3.p0.z, 0), E3.set(m3.p1.x, m3.p1.y, m3.p1.z, 0);
    }
    getCullingWorkerData(A3, g3, I3) {
      const C3 = A3.boundingBoxParam.value, i3 = 0.5 * C3.size(), e3 = C3.center();
      let t3 = A3.cullable != 0;
      const B3 = g3.getParameter("MaintainScreenSize");
      B3 && B3.value && (t3 = false), g3.getShaderName().startsWith("ScreenSpace") && (t3 = false), g3.hasParameter("PointSize") && (t3 = false), this.enableOcclusionCulling && !A3.isSelectable() && (t3 = false);
      const o3 = !A3.isOpaque() || !g3.isOpaque(), s3 = {triangles: 0, lines: 0, points: 0}, a3 = A3.geomParam.value;
      if (a3 instanceof Mg)
        s3.triangles += a3.getNumTriangles(), s3.lines += a3.getNumLineSegments(), s3.points += a3.getNumPoints();
      else if (a3 instanceof Kg || a3 instanceof Dg)
        s3.triangles += a3.getNumTriangles();
      else if (a3 instanceof Yg || a3 instanceof Jg)
        s3.lines += a3.getNumLineSegments();
      else {
        if (!(a3 instanceof Wg || a3 instanceof Ng))
          throw new Error("Unsupported geom type:" + a3.constructor.name);
        s3.points += a3.getNumVertices();
      }
      return {id: I3, boundingRadius: i3, pos: e3.asArray(), cullable: t3, visible: A3.isVisible(), transparent: o3, geomStats: s3};
    }
    uploadGeomItemsToWorker() {
      if (this.enableFrustumCulling) {
        const A3 = [];
        this.dirtyWorkerItemIndices.forEach((g3) => {
          const I3 = this.glGeomItems[g3];
          if (!I3)
            return;
          const {geomItem: C3} = I3, i3 = C3.materialParam.value;
          A3.push(this.getCullingWorkerData(C3, i3, g3));
        }), this.worker.postMessage({type: "UpdateGeomItems", geomItems: A3, removedItemIndices: this.removedItemIndices}), this.dirtyWorkerItemIndices.clear(), this.removedItemIndices = [];
      }
    }
    uploadGeomItems(A3) {
      const g3 = this.renderer.gl;
      if (!g3.floatTexturesSupported)
        return;
      let I3 = Math.round(Math.sqrt(8 * this.glGeomItems.length) + 0.5);
      I3 = r.nextPow2(I3), I3 % 8 != 0 && (I3 += 8 - I3 % 8), this.glGeomItemsTexture ? this.glGeomItemsTexture.width != I3 && (this.glGeomItemsTexture.resize(I3, I3), this.dirtyItemIndices = Array(I3 * I3 / 8).fill(0).map((A4, g4) => g4)) : (this.glGeomItemsTexture = new HC(g3, {format: "RGBA", type: "FLOAT", width: I3, height: I3, filter: "NEAREST", wrap: "CLAMP_TO_EDGE", mipMapped: false}), this.glGeomItemsTexture.clear()), g3.bindTexture(g3.TEXTURE_2D, this.glGeomItemsTexture.glTex);
      const C3 = this.glGeomItemsTexture.getType();
      for (let A4 = 0; A4 < this.dirtyItemIndices.length; A4++) {
        const i3 = this.dirtyItemIndices[A4], e3 = Math.floor(8 * i3 / I3);
        let t3 = i3 + 1;
        for (let g4 = A4 + 1; g4 < this.dirtyItemIndices.length; g4++) {
          const A5 = this.dirtyItemIndices[g4];
          if (Math.floor(8 * A5 / I3) != e3)
            break;
          if (A5 != t3)
            break;
          t3++;
        }
        const B3 = t3 - i3, o3 = 8 * i3 % I3, s3 = 8 * B3, a3 = 1, l3 = new Float32Array(32 * B3);
        for (let A5 = i3; A5 < t3; A5++)
          this.populateDrawItemDataArray(A5, A5 - i3, l3);
        if (C3 == g3.FLOAT)
          this.glGeomItemsTexture.populate(l3, s3, a3, o3, e3, false);
        else {
          const A5 = r.convertFloat32ArrayToUInt16Array(l3);
          this.glGeomItemsTexture.populate(A5, s3, a3, o3, e3, false);
        }
        A4 += B3 - 1;
      }
      this.removedItemIndices = [], this.dirtyItemIndices = [];
    }
    bind(A3) {
      (this.dirtyWorkerItemIndices.size > 0 || this.removedItemIndices.length > 0) && this.uploadGeomItemsToWorker(), this.dirtyItemIndices.length > 0 && this.uploadGeomItems(A3);
      const g3 = this.renderer.gl, {instancesTexture: I3, instancesTextureSize: C3} = A3.unifs;
      I3 && (this.glGeomItemsTexture.bindToUniform(A3, I3), g3.uniform1i(C3.location, this.glGeomItemsTexture.width));
    }
  };
  var oe;
  var se = false;
  var ae = false;
  var le = {};
  var ne = class extends nA {
    constructor(A3, I3 = {}) {
      var C3;
      if (super(), this.listenerIDs = {}, this.directives = [], this.solidAngleLimit = 4e-3, this.__glcanvas = null, this.__scene = null, this.__shaderDirectives = {}, this.__renderGeomDataFbosRequested = false, this.__shaders = {}, this.__passes = {}, this.passAssignments = {}, this.__passesRegistrationOrder = [], this.__passCallbacks = [], this.__viewports = [], this.__activeViewport = void 0, this.__continuousDrawing = false, this.__redrawRequested = false, this.__isMobile = false, this.__drawSuspensionLevel = 0, this.__xrViewportPresenting = false, this.floatGeomBuffer = true, this.multiSampledScreenBuffer = false, this.__supportXR = false, this.__xrViewport = void 0, this.screenQuad = null, !g.gpuDesc)
        throw new Error("Unable to create renderer. WebGL not Supported");
      this.__isMobile = g.isMobileDevice, this.requestRedraw = this.requestRedraw.bind(this), this.__gl = this.setupWebGL(A3, I3), this.screenQuad = new Hi(this.__gl, {directives: this.directives}), this.bindEventHandlers();
      const i3 = this.addViewport("main");
      i3.debugGeomDataBuffer = I3.debugGeomDataBuffer, i3.debugOcclusionBuffer = I3.debugOcclusionBuffer, this.glMaterialLibrary = new Pi(this), this.glMaterialLibrary.on("updated", () => {
        this.requestRedraw();
      }), this.glGeomLibrary = new $i(this), this.glGeomLibrary.on("updated", () => {
        this.requestRedraw();
      }), this.glGeomItemLibrary = new Be(this, I3), this.glGeomItemLibrary.on("updated", () => {
        this.requestRedraw();
      });
      for (const A4 in le)
        for (const g3 of le[A4])
          this.addPass(new g3(), parseInt(A4), false);
      this.__supportXR = (C3 = I3.supportXR) === null || C3 === void 0 || C3, this.__xrViewportPromise = new Promise((A4, g3) => {
        var I4, C4;
        if (this.__supportXR && ((I4 = navigator) === null || I4 === void 0 ? void 0 : I4.xr)) {
          const g4 = () => {
            this.__gl.makeXRCompatible().then(() => {
              this.__xrViewport = this.__setupXRViewport();
              let g5 = new CA(this.__xrViewport);
              this.emit("xrViewportSetup", g5), A4(this.__xrViewport);
            });
          };
          (C4 = navigator) === null || C4 === void 0 || C4.xr.isSessionSupported("immersive-vr").then((A5) => {
            A5 && g4();
          }).catch((A5) => {
            console.warn("Unable to setup XR:" + A5);
          });
        }
      });
    }
    addShaderPreprocessorDirective(A3, g3) {
      this.__shaderDirectives[A3] = g3 ? "#define " + A3 + " = " + g3 : "#define " + A3;
      const I3 = [];
      for (const A4 in this.__shaderDirectives)
        I3.push(this.__shaderDirectives[A4]);
      this.directives = I3;
    }
    getWidth() {
      return this.__glcanvas.width;
    }
    getHeight() {
      return this.__glcanvas.height;
    }
    addViewport(A3) {
      const g3 = new Ni(this, A3, this.getWidth(), this.getHeight());
      return g3.on("updated", () => {
        this.requestRedraw();
      }), g3.on("viewChanged", (A4) => {
        this.__xrViewportPresenting || this.emit("viewChanged", A4);
      }), this.__viewports.push(g3), this.__activeViewport = g3, g3;
    }
    getViewport(A3 = 0) {
      return this.__viewports[A3];
    }
    getViewportAtPos(A3, g3) {
      for (const I3 of this.__viewports) {
        const C3 = I3.getPosX(), i3 = I3.getPosY(), e3 = I3.getWidth(), t3 = I3.getHeight();
        if (A3 >= C3 && g3 >= i3 && A3 <= e3 + C3 && g3 <= t3 + i3)
          return I3;
      }
    }
    activateViewport(A3) {
      this.__activeViewport != A3 && (this.__activeViewport = A3);
    }
    activateViewportAtPos(A3, g3) {
      if (this.__xrViewportPresenting)
        return;
      const I3 = this.getViewportAtPos(A3, g3);
      I3 && I3 != this.__activeViewport && this.activateViewport(I3);
    }
    getActiveViewport() {
      return this.__activeViewport;
    }
    suspendDrawing() {
      this.__drawSuspensionLevel++;
    }
    resumeDrawing() {
      this.__drawSuspensionLevel--, this.__drawSuspensionLevel == 0 && (this.renderGeomDataFbos(), this.requestRedraw());
    }
    renderGeomDataFbos() {
      if (this.__renderGeomDataFbosRequested == 1)
        return;
      this.__renderGeomDataFbosRequested = true;
      window.requestAnimationFrame(() => {
        for (const A3 of this.__viewports)
          A3.renderGeomDataFbo();
        this.__renderGeomDataFbosRequested = false;
      });
    }
    getScene() {
      return this.__scene;
    }
    setScene(A3) {
      this.__scene = A3, this.addTreeItem(this.__scene.getRoot());
      let g3 = new L(this.__scene);
      this.emit("sceneSet", g3);
    }
    addTreeItem(A3) {
      if (!(A3 instanceof ag))
        return;
      const g3 = A3.getId(), I3 = {};
      if (this.listenerIDs[g3] = I3, A3 instanceof kI) {
        const g4 = A3.geomParam;
        if (g4.value == null) {
          const C3 = () => {
            delete I3["Geometry.valueChanged"], this.assignTreeItemToGLPass(A3);
          };
          I3["Geometry.valueChanged"] = g4.once("valueChanged", C3);
        } else
          this.assignTreeItemToGLPass(A3);
      } else
        this.assignTreeItemToGLPass(A3);
      for (const g4 of A3.getChildren())
        g4 && this.addTreeItem(g4);
      I3.childAdded = A3.on("childAdded", (A4) => {
        this.addTreeItem(A4.childItem);
      }), I3.childRemoved = A3.on("childRemoved", (A4) => {
        this.removeTreeItem(A4.childItem);
      }), this.renderGeomDataFbos();
    }
    assignTreeItemToGLPass(A3) {
      if (A3 instanceof kI) {
        const g4 = A3;
        this.glGeomItemLibrary.addGeomItem(g4);
      }
      let g3 = false;
      for (let I3 = this.__passesRegistrationOrder.length - 1; I3 >= 0; I3--) {
        const C3 = {continueInSubTree: true};
        if (g3 = this.__passesRegistrationOrder[I3].itemAddedToScene(A3, C3), g3) {
          if (this.passAssignments[A3.getId()] = I3, !C3.continueInSubTree)
            return;
          break;
        }
      }
      if (!g3)
        for (const g4 of this.__passCallbacks) {
          const I3 = {continueInSubTree: true};
          if (g4.itemAddedFn(A3, I3)) {
            if (!I3.continueInSubTree)
              return;
            break;
          }
        }
    }
    removeTreeItem(A3) {
      if (!(A3 instanceof ag))
        return;
      const g3 = A3.getId(), I3 = this.listenerIDs[g3];
      delete this.listenerIDs[g3], A3.removeListenerById("childAdded", I3.childAdded), A3.removeListenerById("childRemoved", I3.childRemoved);
      const C3 = this.passAssignments[g3];
      if (C3 != null) {
        const I4 = {continueInSubTree: true};
        this.getPass(C3).itemRemovedFromScene(A3, I4), delete this.passAssignments[g3];
      }
      for (const g4 of A3.getChildren())
        g4 && this.removeTreeItem(g4);
      if (A3 instanceof kI) {
        const g4 = A3;
        if (I3["Geometry.valueChanged"]) {
          A3.geomParam.removeListenerById("valueChanged", I3["Geometry.valueChanged"]);
        }
        this.glGeomItemLibrary.removeGeomItem(g4);
      }
      this.renderGeomDataFbos();
    }
    get gl() {
      return this.__gl;
    }
    getGL() {
      return this.__gl;
    }
    handleResize(A3, g3) {
      if (this.__xrViewportPresenting)
        return;
      const I3 = Math.max(4, A3) * window.devicePixelRatio, C3 = Math.max(4, g3) * window.devicePixelRatio;
      this.__glcanvas.width = I3, this.__glcanvas.height = C3, this.__viewports.forEach((A4) => {
        A4.resize(I3, C3);
      });
      const i3 = new F(I3, C3);
      this.emit("resized", i3), this.requestRedraw();
    }
    getDiv() {
      return this.__glcanvas.parentElement;
    }
    setupWebGL(A3, I3 = {}) {
      var C3, i3;
      const {tagName: e3} = A3;
      if (!["DIV", "CANVAS"].includes(e3))
        throw new Error("Only CANVAS and DIV are valid root elements.");
      const t3 = e3 === "DIV";
      this.__glcanvas = A3, t3 ? (console.warn("@GLBaseRenderer#setupWebGL.", "Using a DIV as root element is deprecated.", "Use a CANVAS instead.", "See: https://docs.zea.live/zea-engine/#/getting-started/get-started-with-engine?id=basic-setup"), this.__glcanvas = document.createElement("canvas"), A3.appendChild(this.__glcanvas)) : this.__glcanvas = A3, this.__glcanvas.style["touch-action"] = "none", this.__glcanvas.parentElement.style.position = "relative", this.__glcanvas.parentElement.style.overflow = "hidden", this.__glcanvas.style.width = "100%", this.__glcanvas.style.height = "100%", this.__glcanvas.style.position = "absolute";
      const B3 = function(A4, g3, I4) {
        var C4 = true, i4 = true;
        if (typeof A4 != "function")
          throw new TypeError("Expected a function");
        return ti(I4) && (C4 = "leading" in I4 ? !!I4.leading : C4, i4 = "trailing" in I4 ? !!I4.trailing : i4), wi(A4, g3, {leading: C4, maxWait: g3, trailing: i4});
      }((A4) => {
        if (Array.isArray(A4) && A4.length)
          for (const g3 of A4) {
            if (!g3.contentRect)
              return;
            const A5 = Math.round(g3.contentRect.width), I4 = Math.round(g3.contentRect.height);
            this.handleResize(A5, I4);
          }
      }, 500);
      window.addEventListener("resize", () => {
        const A4 = [{contentRect: {width: this.__glcanvas.parentElement.clientWidth, height: this.__glcanvas.parentElement.clientHeight}}];
        B3(A4);
      });
      const o3 = new ResizeObserver(B3);
      try {
        o3.observe(this.__glcanvas.parentNode, {box: "device-pixel-content-box"});
      } catch (A4) {
        o3.observe(this.__glcanvas.parentNode, {box: "content-box"});
      }
      this.handleResize(this.__glcanvas.parentElement.clientWidth, this.__glcanvas.parentElement.clientHeight);
      const s3 = g.OS === "macOS" && g.browserName === "Chrome", a3 = g.isIOSDevice, l3 = {preserveDrawingBuffer: true};
      l3.antialias = !s3 && !a3 && ((C3 = I3.antialias) === null || C3 === void 0 || C3), l3.depth = true, l3.stencil = true, l3.alpha = (i3 = I3.alpha) !== null && i3 !== void 0 && i3, l3.xrCompatible = false, this.multiSampledScreenBuffer = l3.antialias, l3.powerPreference = I3.powerPreference || "high-performance";
      const n3 = wC(this.__glcanvas, l3);
      n3 || alert("Unable to create WebGL context. WebGL not supported."), n3.name == "webgl2" && this.addShaderPreprocessorDirective("ENABLE_ES3"), n3.floatTexturesSupported && this.addShaderPreprocessorDirective("ENABLE_FLOAT_TEXTURES");
      {
        const A4 = n3.name == "webgl2" ? n3.getExtension("WEBGL_multi_draw") : null;
        A4 && !I3.disableMultiDraw ? (n3.multiDrawArrays = A4.multiDrawArraysWEBGL.bind(A4), n3.multiDrawElements = A4.multiDrawElementsWEBGL.bind(A4), n3.multiDrawElementsInstanced = A4.multiDrawElementsInstancedWEBGL.bind(A4), n3.multiDrawArraysInstanced = A4.multiDrawArraysInstancedWEBGL.bind(A4)) : this.addShaderPreprocessorDirective("EMULATE_MULTI_DRAW");
      }
      return g.browserName == "Safari" && n3.name == "webgl" ? this.floatGeomBuffer = false : this.floatGeomBuffer = I3.floatGeomBuffer != null ? I3.floatGeomBuffer : n3.floatTexturesSupported, n3.floatGeomBuffer = this.floatGeomBuffer, n3;
    }
    bindEventHandlers() {
      const A3 = () => this.getWidth() > 0 && this.getHeight(), I3 = (A4) => !!g.isMobileDevice && (console.warn("Mobile device is triggering mouse event:", A4.type), true);
      this.__glcanvas.addEventListener("mousedown", (A4) => {
        if (I3(A4))
          return;
        const g3 = new iA(A4, this.__glcanvas.getBoundingClientRect());
        se = true, oe = this, this.activateViewportAtPos(g3.rendererX, g3.rendererY);
        const C3 = this.getActiveViewport();
        C3 && C3.onPointerDown(g3), ae = false;
      }), document.addEventListener("mouseup", (g3) => {
        if (I3(g3))
          return;
        if (oe != this || !A3())
          return;
        const C3 = new iA(g3, this.__glcanvas.getBoundingClientRect());
        se = false;
        const i3 = this.getActiveViewport();
        i3 && i3.onPointerUp(C3), ae && (i3 && i3.onPointerLeave(C3), oe = void 0);
      }), document.addEventListener("mousemove", (g3) => {
        if (I3(g3))
          return;
        if (oe != this || !A3())
          return;
        const C3 = new iA(g3, this.__glcanvas.getBoundingClientRect());
        se || this.activateViewportAtPos(C3.rendererX, C3.rendererY);
        const i3 = this.getActiveViewport();
        i3 && i3.onPointerMove(C3);
      }), this.__glcanvas.addEventListener("mouseenter", (A4) => {
        if (!I3(A4) && !se) {
          oe = this;
          const g3 = new iA(A4, this.__glcanvas.getBoundingClientRect());
          if (this.activateViewportAtPos(g3.rendererX, g3.rendererY), !se) {
            const A5 = this.getActiveViewport();
            A5 && A5.onPointerEnter(g3);
          }
          ae = false;
        }
      }), this.__glcanvas.addEventListener("mouseleave", (g3) => {
        if (I3(g3))
          return;
        if (oe != this || !A3())
          return;
        const C3 = new iA(g3, this.__glcanvas.getBoundingClientRect());
        if (se)
          ae = true;
        else {
          const A4 = this.getActiveViewport();
          A4 && A4.onPointerLeave(C3), oe = void 0;
        }
      }), document.addEventListener("contextmenu", (g3) => {
        oe == this && A3() && (g3.preventDefault(), g3.stopPropagation());
      }), this.__glcanvas.addEventListener("touchstart", (A4) => {
        oe = this;
        const g3 = this.getActiveViewport(), I4 = new tA(A4, this.__glcanvas.getBoundingClientRect());
        g3.onPointerDown(I4);
      }, {passive: true}), this.__glcanvas.addEventListener("touchend", (A4) => {
        const g3 = this.getActiveViewport(), I4 = new tA(A4, this.__glcanvas.getBoundingClientRect());
        g3.onPointerUp(I4);
      }, {passive: true}), this.__glcanvas.addEventListener("touchmove", (A4) => {
        const g3 = this.getActiveViewport(), I4 = new tA(A4, this.__glcanvas.getBoundingClientRect());
        g3.onPointerMove(I4);
      }, {passive: true}), this.__glcanvas.addEventListener("touchcancel", (A4) => {
        const g3 = this.getActiveViewport(), I4 = new tA(A4, this.__glcanvas.getBoundingClientRect());
        g3.onTouchCancel(I4);
      }, {passive: true});
      window.addEventListener("wheel", (g3) => {
        if (oe == this && A3() && oe) {
          const A4 = new BA(g3, this.__glcanvas.getBoundingClientRect()), I4 = oe.getActiveViewport();
          I4 && I4.onWheel(A4);
        }
      }, {passive: false}), document.addEventListener("keydown", (g3) => {
        if (oe != this || !A3())
          return;
        const I4 = new J(g3), C3 = oe.getActiveViewport();
        C3 && C3.onKeyDown(I4);
      }), document.addEventListener("keyup", (g3) => {
        if (oe != this || !A3())
          return;
        const I4 = new J(g3), C3 = oe.getActiveViewport();
        C3 && C3.onKeyUp(I4);
      });
    }
    getGLCanvas() {
      return this.__glcanvas;
    }
    frameAll(A3 = 0) {
      this.__viewports[A3].frameView([this.__scene.getRoot()]);
    }
    getOrCreateShader(A3) {
      let g3 = this.__shaders[A3];
      return g3 || (g3 = e.constructClass(A3), g3 || console.error("@GLBaseRenderer#getOrCreateShader - Shader not registered with the Registry:", A3), g3.setGLContext(this.__gl), this.__shaders[A3] = g3), g3;
    }
    addPass(A3, g3 = -1, I3 = true) {
      g3 == -1 && (g3 = A3.getPassType()), this.__passes[g3] || (this.__passes[g3] = []);
      let C3 = 0;
      for (const A4 in this.__passes) {
        if (A4 == g3.toString())
          break;
        C3 += this.__passes[A4].length;
      }
      if (C3 += this.__passes[g3].length, A3.on("updated", (A4) => {
        this.requestRedraw(), this.renderGeomDataFbos();
      }), A3.init(this, C3), this.__passes[g3].push(A3), I3) {
        let A4 = 0;
        for (const g4 in this.__passes) {
          const I4 = this.__passes[g4];
          I4.forEach((g5, I5) => {
            g5.setPassIndex(A4 + I5);
          }), A4 += I4.length;
        }
      }
      return this.__passesRegistrationOrder.push(A3), this.requestRedraw(), C3;
    }
    getPass(A3) {
      let g3 = 0;
      for (const I3 in this.__passes) {
        const C3 = this.__passes[I3];
        if (A3 - g3 < C3.length)
          return C3[A3 - g3];
        g3 += C3.length;
      }
    }
    supportsVR() {
      var A3;
      return console.warn("@GLBaseRenderer#supportVR - Deprecated Method. Please instead connect to the vrViewportSetup signal."), this.__supportXR && ((A3 = navigator) === null || A3 === void 0 ? void 0 : A3.xr) != null;
    }
    __setupXRViewport() {
      const A3 = new Mi(this), g3 = (A4) => {
        this.emit("viewChanged", A4);
      };
      return A3.on("presentingChanged", (I3) => {
        const C3 = I3.state;
        if (this.__xrViewportPresenting != C3)
          if (this.__xrViewportPresenting = C3, C3) {
            for (const A4 in this.__passes) {
              const g4 = this.__passes[A4];
              for (const A5 of g4)
                A5.startPresenting();
            }
            A3.on("viewChanged", g3);
          } else {
            A3.off("viewChanged", g3), this.emit("updated");
            for (const A4 in this.__passes) {
              const g4 = this.__passes[A4];
              for (const A5 of g4)
                A5.stopPresenting();
            }
            const I4 = this.getViewport().getCamera().globalXfoParam.value, C4 = new P("CameraAndPointer", I4);
            this.emit("viewChanged", C4), this.requestRedraw();
          }
      }), A3;
    }
    getVRViewport() {
      return this.__xrViewport;
    }
    getXRViewport() {
      return this.__xrViewportPromise;
    }
    isXRViewportPresenting() {
      return this.__xrViewportPresenting;
    }
    isContinuouslyDrawing() {
      return this.__continuousDrawing;
    }
    startContinuousDrawing() {
      if (this.isContinuouslyDrawing() || this.__xrViewportPresenting)
        return;
      const A3 = () => {
        const g3 = new jC(this.gl);
        this.__continuousDrawing && !this.__xrViewportPresenting && window.requestAnimationFrame(A3);
        for (const A4 of this.__viewports)
          A4.draw(g3);
      };
      this.__continuousDrawing = true, window.requestAnimationFrame(A3);
    }
    stopContinuousDrawing() {
      this.__continuousDrawing = false;
    }
    toggleContinuousDrawing() {
      this.__continuousDrawing ? this.stopContinuousDrawing() : this.startContinuousDrawing();
    }
    drawItemChanged() {
      for (const A3 of this.__viewports)
        A3.invalidateGeomDataBuffer();
      this.requestRedraw();
    }
    requestRedraw() {
      if (this.__redrawRequested || this.__continuousDrawing || this.__xrViewportPresenting || this.__drawSuspensionLevel > 0)
        return false;
      return window.requestAnimationFrame(() => {
        this.__redrawRequested = false;
        const A3 = new jC(this.gl);
        for (const g3 of this.__viewports)
          g3.draw(A3);
        A3.stack.length != 1 && console.warn(" corrupt renderstate.stack.length:", A3.stack.length);
      }), this.__redrawRequested = true, true;
    }
    forceRender() {
      if (!this.__redrawRequested)
        return void console.warn("@GlBaseRenderer#forceRender - Scene is not dirty");
      this.__redrawRequested = false;
      const A3 = new jC(this.gl);
      for (const g3 of this.__viewports)
        g3.draw(A3);
    }
    bindGLBaseRenderer(A3) {
      A3.gl = this.__gl, A3.shaderopts = {directives: this.directives};
      const g3 = this.__gl;
      A3.viewports && A3.viewports.length != 1 ? (A3.bindRendererUnifs = (I3) => {
        const {cameraMatrix: C3} = I3;
        C3 && g3.uniformMatrix4fv(C3.location, false, A3.cameraMatrix.asArray());
      }, A3.bindViewports = (I3, C3) => {
        A3.viewports.forEach((A4, i3) => {
          let e3 = A4.region;
          g3.viewport(e3[0], e3[1], e3[2], e3[3]);
          const {viewMatrix: t3, projectionMatrix: B3, eye: o3, isOrthographic: s3} = I3;
          t3 && g3.uniformMatrix4fv(t3.location, false, A4.viewMatrix.asArray()), B3 && g3.uniformMatrix4fv(B3.location, false, A4.projectionMatrix.asArray()), o3 && g3.uniform1i(o3.location, i3), s3 && g3.uniform1i(s3.location, A4.isOrthographic), C3();
        });
      }) : (A3.bindRendererUnifs = (I3) => {
        const {cameraMatrix: C3, viewMatrix: i3, projectionMatrix: e3, eye: t3, isOrthographic: B3} = I3;
        C3 && g3.uniformMatrix4fv(C3.location, false, A3.cameraMatrix.asArray());
        const o3 = A3.viewports[0];
        i3 && g3.uniformMatrix4fv(i3.location, false, o3.viewMatrix.asArray()), e3 && g3.uniformMatrix4fv(e3.location, false, o3.projectionMatrix.asArray()), t3 && g3.uniform1i(t3.location, 0), B3 && g3.uniform1i(B3.location, o3.isOrthographic);
      }, A3.bindViewports = (A4, g4) => g4());
    }
    drawScene(A3) {
      A3.directives = [...this.directives, "#define DRAW_COLOR"], A3.shaderopts.directives = A3.directives;
      for (const g3 in this.__passes) {
        const I3 = this.__passes[g3];
        for (const g4 of I3)
          g4.enabled && g4.draw(A3);
      }
    }
    drawHighlightedGeoms(A3) {
      this.bindGLBaseRenderer(A3), A3.directives = [...this.directives, "#define DRAW_HIGHLIGHT"], A3.shaderopts.directives = A3.directives;
      for (const g3 in this.__passes) {
        const I3 = this.__passes[g3];
        for (const g4 of I3)
          g4.enabled && g4.drawHighlightedGeoms(A3);
      }
    }
    drawSceneGeomData(A3, g3 = 255) {
      A3.pushGLStack(), A3.glEnable(this.__gl.DEPTH_TEST), A3.glEnable(this.__gl.CULL_FACE), this.bindGLBaseRenderer(A3), A3.directives = [...this.directives, "#define DRAW_GEOMDATA"], A3.shaderopts.directives = A3.directives, A3.floatGeomBuffer = this.floatGeomBuffer;
      for (const I3 in this.__passes) {
        if ((Number.parseInt(I3) & g3) == 0)
          continue;
        const C3 = this.__passes[I3];
        for (const g4 of C3)
          g4.enabled && g4.drawGeomData(A3);
      }
      A3.popGLStack();
    }
    static registerPass(A3, g3) {
      le[g3] || (le[g3] = []), le[g3].push(A3);
    }
    destroy() {
      this.resizeObserver.disconnect();
    }
  };
  var de = class extends DC {
    constructor(A3) {
      super(A3, "HighlightsShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;    //(location = 0)\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  v_texCoord = positions.xy+0.5;\n  gl_Position = vec4(positions.xy*2.0, 0.0, 1.0);\n}\n\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nuniform float outlineThickness;\nuniform sampler2D highlightDataTexture;\nuniform vec2 highlightDataTextureSize;\n\nvarying vec2 v_texCoord;\n\nvec3 SobelFactor(vec3 ldc, vec3 ldl, vec3 ldr, vec3 ldu, vec3 ldd)\n{\n  return abs(ldl - ldc) +\n      abs(ldr - ldc) +\n      abs(ldu - ldc) +\n      abs(ldd - ldc);\n}\n\n// https://github.com/ssell/UnitySobelOutline/blob/2e1f4a5b4e703ae2c96aaf08d5518ce58abbaab9/Assets/Resources/Shaders/SobelOutlineHLSL.shader#L18\nvec4 SobelSample(vec2 uv)\n{\n  vec3 offset = vec3((1.0 / highlightDataTextureSize.x), (1.0 / highlightDataTextureSize.y), 0.0) * outlineThickness;\n\n  vec4 pixelCenter = texture2D(highlightDataTexture, uv);\n  vec3 pixelLeft   = texture2D(highlightDataTexture, uv - offset.xz).rgb;\n  vec3 pixelRight  = texture2D(highlightDataTexture, uv + offset.xz).rgb;\n  vec3 pixelUp     = texture2D(highlightDataTexture, uv + offset.zy).rgb;\n  vec3 pixelDown   = texture2D(highlightDataTexture, uv - offset.zy).rgb;\n\n  vec3 sobelNormalVec = SobelFactor(pixelCenter.rgb, pixelLeft, pixelRight, pixelUp, pixelDown);\n  \n  float sobelNormal = sobelNormalVec.x + sobelNormalVec.y + sobelNormalVec.z;\n  \n  float outlineDepthMultiplier = 10.0;\n  float outlineDepthBias = 2.5;\n  sobelNormal = pow(sobelNormal * outlineDepthMultiplier, outlineDepthBias);\n\n  sobelNormal = clamp(sobelNormal, 0.0, 1.0);\n\n  \n  float pixelCenterWeight = length(pixelCenter.rgb) > 0.0 ? 1.0 : 0.0;\n  float pixelLeftWeight   = length(pixelLeft) > 0.0 ? 1.0 : 0.0;\n  float pixelRightWeight  = length(pixelRight) > 0.0 ? 1.0 : 0.0;\n  float pixelUpWeight     = length(pixelUp) > 0.0 ? 1.0 : 0.0;\n  float pixelDownWeight   = length(pixelDown) > 0.0 ? 1.0 : 0.0;\n  \n  // Weight each neighbors contribution to the current pixel color.\n  pixelCenter.rgb = pixelCenter.rgb * pixelCenterWeight;\n  pixelLeft   *= pixelLeftWeight;\n  pixelRight  *= pixelRightWeight;\n  pixelUp     *= pixelUpWeight;\n  pixelDown   *= pixelDownWeight;\n\n  // Add all the weighted contributions, and then normalize.\n  vec3 outlineColor = pixelCenter.rgb + pixelLeft + pixelRight +  pixelUp + pixelDown;\n  outlineColor /= pixelCenterWeight + pixelLeftWeight + pixelRightWeight + pixelUpWeight + pixelDownWeight;\n\n  return mix(vec4(outlineColor, sobelNormal), pixelCenter, pixelCenter.a);\n}\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n    \n  vec4 outlineColor = SobelSample(v_texCoord);\n  \n  if (outlineColor.a > 0.0001) {\n#ifndef ENABLE_ES3\n    gl_FragColor = outlineColor;\n#else\n    fragColor = outlineColor;\n#endif\n  }\n  else {\n      discard;\n  }\n}\n\n");
    }
  };
  var he = class extends DC {
    constructor(A3) {
      super(A3, "SilhouetteShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 positions;    //(location = 0)\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  v_texCoord = positions.xy+0.5;\n  gl_Position = vec4(positions.xy*2.0, 0.0, 1.0);\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "\n#ifndef ENABLE_ES3\n#extension GL_EXT_frag_depth: enable\n#endif\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform vec2 screenSize;\nuniform vec2 depthRange;\n\nuniform float outlineThickness;\nuniform color outlineColor;\nuniform float outlineSensitivity;\nuniform float outlineDepthBias;\n\nvarying vec2 v_texCoord;\n\n// http://web.archive.org/web/20130416194336/http://olivers.posterous.com/linear-depth-in-glsl-for-real\nfloat LinearEyeDepth(float z_b) {\n  float z_n = 2.0 * z_b - 1.0;\n  float z_e = 2.0 * depthRange.x * depthRange.y / (depthRange.y + depthRange.x - z_n * (depthRange.y - depthRange.x));\n  return z_e;\n}\n\nfloat LogEyeDepth(float z_b) {\n  return depthRange.x + ((depthRange.y - depthRange.x) * z_b);\n}\n\n// https://www.vertexfragment.com/ramblings/unity-postprocessing-sobel-outline/#depth-based-outline\n// https://github.com/ssell/UnitySobelOutline/blob/2e1f4a5b4e703ae2c96aaf08d5518ce58abbaab9/Assets/Resources/Shaders/SobelOutlineHLSL.shader\n\nfloat SobelDepth(float ldc, float ldl, float ldr, float ldu, float ldd)\n{\n  return abs(ldl - ldc) +\n      abs(ldr - ldc) +\n      abs(ldu - ldc) +\n      abs(ldd - ldc);\n}\n\nfloat SobelSampleDepth(vec2 uv, vec3 offset)\n{\n  float pixelCenter = LinearEyeDepth(texture2D(depthTexture, uv).r);\n  float pixelLeft   = LinearEyeDepth(texture2D(depthTexture, uv - offset.xz).r);\n  float pixelRight  = LinearEyeDepth(texture2D(depthTexture, uv + offset.xz).r);\n  float pixelUp     = LinearEyeDepth(texture2D(depthTexture, uv + offset.zy).r);\n  float pixelDown   = LinearEyeDepth(texture2D(depthTexture, uv - offset.zy).r);\n\n  float  outlineDepthMultiplier = (1.0 / pixelCenter) * outlineSensitivity;\n\n  return SobelDepth(pixelCenter, pixelLeft, pixelRight, pixelUp, pixelDown) * outlineDepthMultiplier;\n}\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec3 offset = vec3((1.0 / screenSize.x), (1.0 / screenSize.y), 0.0) * outlineThickness;\n  float sobelDepth = SobelSampleDepth(v_texCoord, offset);\n  float sobelValue = pow(sobelDepth, outlineDepthBias);\n\n  float minEdgeValue = 0.25;\n  float maxEdgeValue = 0.55;\n  sobelDepth = smoothstep(minEdgeValue, maxEdgeValue, sobelValue);\n\n#ifdef ENABLE_ES3\n  fragColor = vec4(outlineColor.rgb, sobelDepth);\n#else\n  fragColor = vec4(mix(texture2D(colorTexture, v_texCoord).rgb, outlineColor.rgb, sobelDepth), 1.0);\n#ifdef  GL_EXT_frag_depth\n  gl_FragDepthEXT = texture2D(depthTexture, v_texCoord).r;\n#endif\n#endif\n\n  // float z = texture2D(depthTexture, v_texCoord).r;\n  // float near = depthRange.x * 2.0;    // the near plane\n  // float far = depthRange.y / 2.0;     // the far plane\n  // float c = (2.0 * near) / (far + near - z * (far - near));  // convert to linear values \n  // fragColor = vec4(vec3(c), 1.0);\n\n  \n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n");
    }
  };
  var ce = EC.OPAQUE | EC.TRANSPARENT | EC.OVERLAY;
  var re = class extends ne {
    constructor(A3, g3 = {}) {
      super(A3, g3), this.__exposure = 1, this.__gamma = 2.2, this.__glEnvMap = null, this.highlightOutlineThickness = 1, this.renderMode = "pbr", this.outlineMethod = "geometry", this.outlineThickness = 0, this.outlineColor = new l(0.15, 0.15, 0.15, 1), this.hiddenLineColor = new l(0.15, 0.15, 0.15, 0), this.outlineSensitivity = 2, this.outlineDepthBias = 0.7, this.__rayCastRenderTarget = null, this.__backgroundMapShader = null, this.__backgroundMapShaderBinding = null, this.__rayCastRenderTargetProjMatrix = new h(), this.__exposure = 1, this.__gamma = 2.2, this.__displayEnvironment = true, this.__debugMode = 0, this.rayCastDist = 0, this.rayCastArea = 0;
      const I3 = this.__gl;
      this.highlightsShader = new de(I3), this.silhouetteShader = new he(I3), this.__debugTextures = [void 0], this.addShaderPreprocessorDirective("ENABLE_INLINE_GAMMACORRECTION"), g3.disableTextures || this.addShaderPreprocessorDirective("ENABLE_TEXTURES"), g3.debugGeomIds && this.addShaderPreprocessorDirective("DEBUG_GEOM_ID");
    }
    __bindEnvMap(A3) {
      const g3 = this.__gl;
      if (!(A3 instanceof RI)) {
        const I4 = A3;
        if (I4.type === "FLOAT" ? this.__glBackgroundMap = new $C(this.__gl, I4) : this.__glBackgroundMap = new HC(this.__gl, I4), this.__glBackgroundMap.on("loaded", () => {
          this.requestRedraw();
        }), this.__glBackgroundMap.on("updated", () => {
          this.requestRedraw();
        }), !this.__backgroundMapShader) {
          g3.__quadVertexIdsBuffer || g3.setupInstancedQuad(), this.__backgroundMapShader = new ii(this.__gl);
          const A4 = this.__backgroundMapShader.compileForTarget();
          this.__backgroundMapShaderBinding = _C(this.__gl, A4.attrs, g3.__quadattrbuffers, g3.__quadIndexBuffer);
        }
        return;
      }
      if (g3.name !== "webgl2")
        return;
      A3.type === "FLOAT" && (this.addShaderPreprocessorDirective("ENABLE_PBR"), this.__glEnvMap = new ei(this, A3)), this.__glEnvMap.on("loaded", (A4) => {
        this.requestRedraw();
      }), this.__glEnvMap.on("updated", (A4) => {
        this.requestRedraw();
      });
      const I3 = new K(this.__glEnvMap);
      this.emit("envMapAssigned", I3);
    }
    setScene(A3) {
      const g3 = A3.envMapParam;
      g3.value != null && this.__bindEnvMap(g3.value), g3.on("valueChanged", () => {
        this.__bindEnvMap(g3.value);
      });
      const I3 = A3.displayEnvMapParam;
      this.__displayEnvironment = I3.value, I3.on("valueChanged", () => {
        this.__displayEnvironment = I3.value, this.requestRedraw();
      }), super.setScene(A3);
    }
    addViewport(A3) {
      return super.addViewport(A3);
    }
    get exposure() {
      return this.__exposure;
    }
    set exposure(A3) {
      this.__exposure = A3, this.requestRedraw();
    }
    get gamma() {
      return this.__gamma;
    }
    set gamma(A3) {
      this.__gamma = A3, this.requestRedraw();
    }
    get displayEnvironment() {
      return this.__displayEnvironment;
    }
    set displayEnvironment(A3) {
      this.__displayEnvironment = A3, this.requestRedraw();
    }
    raycastWithRay(A3, g3, I3 = 0.01, C3 = ce) {
      const i3 = new m();
      return i3.setLookAt(A3.start, A3.start.add(A3.dir), new o(0, 0, 1)), this.raycast(i3, A3, g3, I3, C3);
    }
    raycastWithXfo(A3, g3, I3 = 0.01, C3 = ce) {
      const i3 = new G(A3.tr, A3.ori.getZaxis().negate());
      return this.raycast(A3, i3, g3, I3, C3);
    }
    raycast(A3, g3, I3, C3 = 0.01, i3 = ce) {
      return this.rayCastDist == I3 && this.rayCastArea == C3 || (this.__rayCastRenderTargetProjMatrix.setOrthographicMatrix(-0.5 * C3, 0.5 * C3, -0.5 * C3, 0.5 * C3, 0, I3), this.rayCastDist = I3, this.rayCastArea = C3), this.raycastWithProjection(A3, this.__rayCastRenderTargetProjMatrix, g3, i3);
    }
    raycastWithProjection(A3, g3, I3, C3 = ce) {
      var i3;
      const e3 = new qC(this.__gl);
      e3.cameraMatrix = A3.toMat4(), e3.viewports = [{region: [0, 0, 3, 3], viewMatrix: A3.inverse().toMat4(), projectionMatrix: g3, isOrthographic: 1, fovY: 0}];
      const t3 = this.__gl;
      this.__rayCastRenderTarget || (this.__rayCastRenderTarget = new LC(t3, {type: "FLOAT", format: "RGBA", filter: "NEAREST", createDepthTexture: true, width: 3, height: 3, numColorChannels: 1})), this.__rayCastRenderTarget.bindForWriting(e3, true), t3.enable(t3.CULL_FACE), t3.enable(t3.DEPTH_TEST), t3.depthFunc(t3.LEQUAL), t3.depthMask(true), this.drawSceneGeomData(e3, C3), t3.finish(), this.__rayCastRenderTarget.unbindForWriting(), this.__rayCastRenderTarget.bindForReading();
      const B3 = new Float32Array(36);
      t3.readPixels(0, 0, 3, 3, t3.RGBA, t3.FLOAT, B3), this.__rayCastRenderTarget.unbindForReading();
      const o3 = [4, 3, 5, 1, 7];
      let s3;
      for (const A4 of o3)
        if (B3[4 * A4 + 3] != 0) {
          s3 = B3.subarray(4 * A4, 4 * A4 + 4);
          break;
        }
      if (!s3)
        return null;
      const a3 = 63 & Math.round(s3[0]), l3 = (i3 = this.getPass(a3)) === null || i3 === void 0 ? void 0 : i3.getGeomItemAndDist(s3);
      if (l3) {
        const A4 = I3.start.add(I3.dir.scale(l3.dist));
        return {pointerRay: I3, intersectionPos: A4, geomItem: l3.geomItem, componentId: -1, dist: l3.dist, geomData: s3};
      }
      return null;
    }
    raycastCluster(A3, g3, I3, C3 = 0.01, i3 = ce) {
      const e3 = this.__gl;
      this.__rayCastRenderTarget || (this.__rayCastRenderTarget = new LC(e3, {type: "FLOAT", format: "RGBA", filter: "NEAREST", createDepthTexture: true, width: 3, height: 3, numColorChannels: 1}), this.__rayCastRenderTargetProjMatrix = new h()), this.rayCastDist == I3 && this.rayCastArea == C3 || (this.__rayCastRenderTargetProjMatrix.setOrthographicMatrix(-0.5 * C3, 0.5 * C3, -0.5 * C3, 0.5 * C3, 0, I3), this.rayCastDist = I3, this.rayCastArea = C3);
      const t3 = new qC(this.__gl);
      t3.viewports = [{region: [0, 0, 3, 3], viewMatrix: A3.inverse().toMat4(), projectionMatrix: this.__rayCastRenderTargetProjMatrix, isOrthographic: 1}], t3.cameraMatrix = A3.toMat4(), this.__rayCastRenderTarget.bindForWriting(t3, true), e3.enable(e3.CULL_FACE), e3.enable(e3.DEPTH_TEST), e3.depthFunc(e3.LEQUAL), e3.depthMask(true), this.drawSceneGeomData(t3, i3), e3.finish(), this.__rayCastRenderTarget.unbindForWriting(), this.__rayCastRenderTarget.bindForReading();
      const B3 = new Float32Array(36);
      e3.readPixels(0, 0, 3, 3, e3.RGBA, e3.FLOAT, B3), this.__rayCastRenderTarget.unbindForReading();
      const o3 = [];
      for (let A4 = 0; A4 < 9; A4++)
        if (B3[4 * A4 + 3] != 0) {
          const I4 = B3.subarray(4 * A4, 4 * A4 + 4), C4 = 63 & Math.round(I4[0]), i4 = this.getPass(C4);
          if (i4) {
            const A5 = i4.getGeomItemAndDist(I4);
            if (A5) {
              const C5 = g3.start.add(g3.dir.scale(A5.dist));
              o3.push({pointerRay: g3, intersectionPos: C5, geomItem: A5.geomItem, componentId: -1, dist: A5.dist, geomData: I4});
            }
          }
        }
      return o3;
    }
    drawBackground(A3) {
      if (this.__glBackgroundMap && this.__backgroundMapShader && this.__backgroundMapShaderBinding) {
        if (!this.__glBackgroundMap.isLoaded())
          return;
        const g3 = this.__gl;
        g3.depthMask(false), this.__backgroundMapShader.bind(A3);
        const I3 = A3.unifs;
        this.__glBackgroundMap.bindToUniform(A3, I3.backgroundImage), this.__backgroundMapShaderBinding.bind(A3), g3.drawQuad();
      } else
        this.__glEnvMap && this.__glEnvMap.draw && this.__glEnvMap.draw(A3);
    }
    bindGLRenderer(A3) {
      super.bindGLBaseRenderer(A3), A3.envMap = this.__glEnvMap, A3.exposure = this.__exposure, A3.renderMode = this.renderMode, A3.outlineThickness = this.outlineThickness, A3.outlineColor = this.outlineColor, A3.hiddenLineColor = this.hiddenLineColor, A3.outlineMethod = this.outlineMethod, A3.screenQuad = this.screenQuad;
    }
    drawScene(A3) {
      this.bindGLRenderer(A3), this.__displayEnvironment && this.drawBackground(A3), super.drawScene(A3);
    }
  };
  var Ge = class extends V {
    constructor(A3, g3) {
      super(), this.drawIdsArray = null, this.drawIdsBuffer = null, this.highlightedIdsArray = null, this.highlightedIdsBuffer = null, this.gl = A3, this.glGeom = g3, this.id = g3 ? g3.getGeom().getId() : this.getId(), this.glGeomItems = [], this.glgeomItems_freeIndices = [], this.glgeomItemEventHandlers = [], this.drawIdsArray = null, this.drawIdsBuffer = null, this.drawIdsBufferDirty = true, this.highlightedIdsArray = null, this.highlightedIdsBuffer = null, this.highlightedIdsBufferDirty = true, this.visibleItems = [], this.highlightedItems = [];
    }
    getGLGeom() {
      return this.glGeom;
    }
    getDrawCount() {
      return this.visibleItems.length;
    }
    addGLGeomItem(A3) {
      let g3;
      if (this.glgeomItems_freeIndices.length > 0 ? g3 = this.glgeomItems_freeIndices.pop() : (g3 = this.glGeomItems.length, this.glGeomItems.push(null)), A3.geomItem.isVisible()) {
        this.visibleItems.push(g3);
        const A4 = new Y(1, this.visibleItems.length);
        this.emit("drawCountChanged", A4);
      }
      A3.geomItem.isHighlighted() && (this.highlightedItems.push(g3), this.highlightedIdsBufferDirty = true);
      const I3 = {};
      I3.highlightChanged = (I4) => {
        if (A3.geomItem.isHighlighted()) {
          if (this.highlightedItems.includes(g3))
            return;
          this.highlightedItems.push(g3);
          const A4 = new Y(1, this.highlightedItems.length);
          this.emit("highlightedCountChanged", A4);
        } else {
          this.highlightedItems.splice(this.highlightedItems.indexOf(g3), 1);
          const A4 = new Y(-1, this.highlightedItems.length);
          this.emit("highlightedCountChanged", A4);
        }
        this.highlightedIdsBufferDirty = true;
      }, A3.geomItem.on("highlightChanged", I3.highlightChanged), I3.visibilityChanged = (A4) => {
        if (A4.visible) {
          this.visibleItems.push(g3);
          const A5 = new Y(1, this.visibleItems.length);
          this.emit("drawCountChanged", A5);
        } else {
          this.visibleItems.splice(this.visibleItems.indexOf(g3), 1);
          const A5 = new Y(-1, this.visibleItems.length);
          this.emit("drawCountChanged", A5);
        }
        this.drawIdsBufferDirty = true;
      }, A3.geomItem.on("visibilityChanged", I3.visibilityChanged), this.glGeomItems[g3] = A3, this.glgeomItemEventHandlers[g3] = I3, this.drawIdsBufferDirty = true, A3.GLGeomItemSet = this;
    }
    removeGLGeomItem(A3) {
      const g3 = this.glGeomItems.indexOf(A3), I3 = this.glgeomItemEventHandlers[g3];
      if (A3.geomItem.off("highlightChanged", I3.highlightChanged), A3.geomItem.off("visibilityChanged", I3.visibilityChanged), this.glGeomItems[g3] = null, this.glgeomItemEventHandlers[g3] = null, A3.GLGeomItemSet = null, this.glgeomItems_freeIndices.push(g3), A3.geomItem.isVisible()) {
        this.visibleItems.splice(this.visibleItems.indexOf(g3), 1);
        const A4 = new Y(-1, this.visibleItems.length);
        this.emit("drawCountChanged", A4);
      }
      if (A3.geomItem.isHighlighted()) {
        this.highlightedItems.splice(this.highlightedItems.indexOf(g3), 1);
        const A4 = new Y(-1, this.highlightedItems.length);
        this.emit("highlightedCountChanged", A4);
      }
      this.drawIdsBufferDirty = true, this.glGeomItems.length == this.glgeomItems_freeIndices.length && this.destroy();
    }
    updateDrawIDsBuffer() {
      const A3 = this.gl;
      A3.floatTexturesSupported ? (this.drawIdsBuffer && this.glGeomItems.length != this.drawIdsArray.length && (this.gl.deleteBuffer(this.drawIdsBuffer), this.drawIdsBuffer = null), this.drawIdsBuffer || (this.drawIdsBuffer = A3.createBuffer(), A3.bindBuffer(A3.ARRAY_BUFFER, this.drawIdsBuffer)), A3.bindBuffer(A3.ARRAY_BUFFER, this.drawIdsBuffer), A3.bufferData(A3.ARRAY_BUFFER, this.getDrawIdsArray(), A3.STATIC_DRAW), this.drawIdsBufferDirty = false) : this.drawIdsBufferDirty = false;
    }
    getDrawIdsArray() {
      return this.drawIdsBufferDirty && (this.drawIdsArray && this.glGeomItems.length == this.drawIdsArray.length || (this.drawIdsArray = new Float32Array(this.glGeomItems.length)), this.visibleItems.forEach((A3, g3) => {
        this.drawIdsArray[g3] = this.glGeomItems[A3].getGeomItemId();
      }), this.drawIdsBufferDirty = false), this.drawIdsArray;
    }
    updateHighlightedIDsBuffer() {
      const A3 = this.gl;
      A3.floatTexturesSupported ? (this.highlightedIdsBuffer && this.glGeomItems.length > this.highlightedIdsArray.length && (this.gl.deleteBuffer(this.highlightedIdsBuffer), this.highlightedIdsBuffer = null), this.highlightedIdsBuffer || (this.highlightedIdsBuffer = A3.createBuffer()), A3.bindBuffer(A3.ARRAY_BUFFER, this.highlightedIdsBuffer), A3.bufferData(A3.ARRAY_BUFFER, this.getHighlightedIdsArray(), A3.STATIC_DRAW), this.highlightedIdsBufferDirty = false) : this.highlightedIdsBufferDirty = false;
    }
    getHighlightedIdsArray() {
      return this.highlightedIdsBufferDirty && ((!this.highlightedIdsArray || this.highlightedItems.length > this.highlightedIdsArray.length) && (this.highlightedIdsArray = new Float32Array(this.glGeomItems.length)), this.highlightedItems.forEach((A3, g3) => {
        this.highlightedIdsArray[g3] = this.glGeomItems[A3].getGeomItemId();
      }), this.highlightedIdsBufferDirty = false), this.highlightedIdsArray;
    }
    draw(A3) {
      this.visibleItems.length != 0 && (this.drawIdsBufferDirty && this.updateDrawIDsBuffer(), this.__bindAndRender(A3, this.visibleItems, this.drawIdsBuffer));
    }
    drawHighlighted(A3) {
      this.highlightedItems.length != 0 && (this.highlightedIdsBufferDirty && this.updateHighlightedIDsBuffer(), this.__bindAndRender(A3, this.highlightedItems, this.highlightedIdsBuffer));
    }
    drawGeomData(A3) {
      this.visibleItems.length != 0 && (this.drawIdsBufferDirty && this.updateDrawIDsBuffer(), this.__bindAndRender(A3, this.visibleItems, this.drawIdsBuffer));
    }
    __bindAndRender(A3, g3, I3) {
      const C3 = this.gl, i3 = A3.unifs;
      if (A3.glGeom != this.glGeom && (this.glGeom.bind(A3), A3.glGeom = this.glGeom), C3.floatTexturesSupported && C3.drawElementsInstanced && A3.supportsInstancing) {
        A3.unifs.instancedDraw && C3.uniform1i(A3.unifs.instancedDraw.location, 1);
        const e3 = A3.attrs.instancedIds.location;
        C3.enableVertexAttribArray(e3), C3.bindBuffer(C3.ARRAY_BUFFER, I3), C3.vertexAttribPointer(e3, 1, C3.FLOAT, false, 4, 0), C3.vertexAttribDivisor(e3, 1), A3.bindViewports(i3, () => {
          this.glGeom.drawInstanced(A3, g3.length);
        });
      } else
        A3.unifs.instancedDraw && C3.uniform1i(A3.unifs.instancedDraw.location, 0), g3.forEach((g4) => {
          this.glGeomItems[g4].bind(A3), A3.bindViewports(i3, () => {
            this.glGeom.draw(A3);
          });
        });
    }
    destroy() {
      this.drawIdsBuffer && (this.gl.deleteBuffer(this.drawIdsBuffer), this.drawIdsBuffer = null), this.highlightedIdsBuffer && (this.gl.deleteBuffer(this.highlightedIdsBuffer), this.highlightedIdsBuffer = null), this.emit("destructing");
    }
  };
  var me = class extends V {
    constructor(A3, g3) {
      super(), this.glGeomItemSets = {}, this.pass = A3, this.__gl = A3.renderer.gl, this.glMaterial = g3, this.glGeomItemSets = {}, this.drawCount = 0;
      const I3 = g3.getMaterial(), C3 = (A4) => {
        I3.off("opacityChanged", C3);
        for (const A5 in this.glGeomItemSets) {
          const g4 = this.glGeomItemSets[A5];
          for (const A6 of g4.glGeomItems) {
            const g5 = A6.geomItem;
            this.pass.removeGeomItem(g5), this.pass.renderer.assignTreeItemToGLPass(g5);
          }
        }
      };
      I3.on("opacityChanged", C3);
    }
    getGLMaterial() {
      return this.glMaterial;
    }
    addGLGeomItem(A3, g3) {
      const I3 = g3.getGeom().getId();
      let C3 = this.glGeomItemSets[I3];
      C3 || (C3 = new Ge(this.__gl, g3), this.addGeomItemSet(C3)), C3.addGLGeomItem(A3);
    }
    drawCountChanged(A3) {
      this.drawCount += A3.change, this.emit("updated");
    }
    __materialChanged() {
      const A3 = this.glMaterial.getMaterial();
      if (!this.pass.checkMaterial(A3))
        for (const A4 in this.glGeomItemSets) {
          const g3 = this.glGeomItemSets[A4];
          for (const A5 of g3.glGeomItems) {
            const g4 = A5.geomItem;
            this.pass.removeGeomItem(g4), this.pass.renderer.assignTreeItemToGLPass(g4);
          }
        }
    }
    addGeomItemSet(A3) {
      const g3 = A3.getGLGeom().getGeom().getId();
      this.glGeomItemSets[g3] = A3;
      const I3 = A3.on("drawCountChanged", (A4) => {
        this.drawCountChanged(A4);
      });
      A3.once("destructing", () => {
        A3.removeListenerById("drawCountChanged", I3), delete this.glGeomItemSets[g3], Object.keys(this.glGeomItemSets).length == 0 && this.emit("destructing");
      });
    }
    draw(A3) {
      if (this.drawCount == 0)
        return;
      this.glMaterial.bind(A3, true);
      for (const g3 in this.glGeomItemSets) {
        this.glGeomItemSets[g3].draw(A3);
      }
      this.glMaterial.unbind(A3);
    }
    drawHighlighted(A3) {
      this.glMaterial.bind(A3, false);
      for (const g3 in this.glGeomItemSets) {
        this.glGeomItemSets[g3].drawHighlighted(A3);
      }
      this.glMaterial.unbind(A3);
    }
    drawGeomData(A3) {
      this.glMaterial.bind(A3, false);
      for (const g3 in this.glGeomItemSets) {
        this.glGeomItemSets[g3].draw(A3);
      }
      this.glMaterial.unbind(A3);
    }
  };
  var Qe = class extends V {
    constructor(A3, g3, I3) {
      super(), this.gl = A3, this.pass = g3, this.glShader = I3.glShader, this.glgeomdatashader = I3.glgeomdatashader, this.glselectedshader = I3.glselectedshader, this.glMaterialGeomItemSets = [];
    }
    findMaterialGeomItemSets(A3) {
      for (const g3 of this.glMaterialGeomItemSets)
        if (g3.glMaterial == A3)
          return g3;
      return null;
    }
    addGLGeomItem(A3, g3, I3) {
      let C3 = this.findMaterialGeomItemSets(I3);
      C3 || (C3 = new me(this.pass, I3), this.addMaterialGeomItemSets(C3)), C3.addGLGeomItem(A3, g3);
    }
    addMaterialGeomItemSets(A3) {
      this.glMaterialGeomItemSets.push(A3);
      const g3 = () => {
        this.emit("updated");
      }, I3 = () => {
        A3.off("updated", g3), A3.off("destructing", I3);
        const C3 = this.glMaterialGeomItemSets.indexOf(A3);
        this.glMaterialGeomItemSets.splice(C3, 1), this.glMaterialGeomItemSets.length == 0 && this.emit("destructing");
      };
      A3.on("updated", g3), A3.on("destructing", I3);
    }
    removeMaterialGeomItemSets(A3) {
      const g3 = this.glMaterialGeomItemSets.indexOf(A3);
      this.glMaterialGeomItemSets.splice(g3, 1);
    }
    getMaterialGeomItemSets() {
      return this.glMaterialGeomItemSets;
    }
    draw(A3) {
      const g3 = this.glShader;
      if (this.glShader.bind(A3)) {
        this.pass.renderer.glGeomItemLibrary.bind(A3);
        for (const g4 of this.glMaterialGeomItemSets)
          g4.draw(A3);
        g3.unbind(A3);
      }
    }
    drawHighlightedGeoms(A3) {
      if (this.glselectedshader && this.glselectedshader.bind(A3, "highlight")) {
        this.pass.renderer.glGeomItemLibrary.bind(A3);
        for (const g3 of this.glMaterialGeomItemSets)
          g3.drawHighlighted(A3);
        this.glselectedshader.unbind(A3);
      }
    }
    drawGeomData(A3) {
      var g3;
      if (!this.glgeomdatashader || !this.glgeomdatashader.bind(A3, "geomData"))
        return;
      this.pass.renderer.glGeomItemLibrary.bind(A3);
      const I3 = this.gl, {floatGeomBuffer: C3, passId: i3, occlusionCulling: e3} = A3.unifs;
      C3 && I3.uniform1i(C3.location, A3.floatGeomBuffer ? 1 : 0), i3 && I3.uniform1i(i3.location, A3.passIndex), e3 && I3.uniform1i(e3.location, (g3 = A3.occlusionCulling) !== null && g3 !== void 0 ? g3 : 0);
      for (const g4 of this.glMaterialGeomItemSets)
        g4.drawGeomData(A3);
      this.glgeomdatashader.unbind(A3);
    }
  };
  var Ee = class extends DC {
    constructor(A3) {
      super(A3, "BillboardShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 cameraMatrix;\nuniform int isOrthographic;\n\nimport 'GLSLUtils.glsl'\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\n// A sorted attribute of instance Ids so we draw from back to front.\ninstancedattribute float instanceIds;\n\nimport 'transpose.glsl'\nimport 'imageAtlas.glsl'\n\nuniform sampler2D atlasBillboards_layout;\nuniform vec4 atlasBillboards_desc;\n\nuniform sampler2D instancesTexture;\nuniform int instancesTextureSize;\nuniform int passId;\n\nconst int cols_per_instance = 7;\n\nmat4 getMatrix(sampler2D texture, int textureSize, int index) {\n  // Unpack 3 x 4 matix columns into a 4 x 4 matrix.\n  vec4 col0 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 0);\n  vec4 col1 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 1);\n  vec4 col2 = fetchTexel(texture, textureSize, (index * cols_per_instance) + 2);\n  mat4 result = mat4(col0, col1, col2, vec4(0.0, 0.0, 0.0, 1.0));\n  return transpose(result);\n  // return mat4(1.0);\n}\n\nmat4 getModelMatrix(int id) {\n  return getMatrix(instancesTexture, instancesTextureSize, id);\n}\nvec4 getInstanceData(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 3);\n}\nvec4 getPivot(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 4);\n}\nvec4 getTintColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 5);\n}\n\n#else\n\nuniform vec4 atlasBillboards_desc;\n\nuniform mat4 modelMatrix;\nuniform vec2 pivot;\nuniform vec4 billboardData;\nuniform vec4 tintColor;\nuniform vec4 layoutData;\n\n#endif\n\nuniform int inVR;\n\nmat4 calcLookAtMatrix(vec3 origin, vec3 target, float roll) {\n  // vec3 rr = vec3(sin(roll), 0.0, cos(roll));\n  vec3 rr = vec3(0.0, 0.0, 1.0);\n  vec3 ww = normalize(target - origin);\n  vec3 uu = normalize(cross(rr, ww));\n  vec3 vv = normalize(cross(ww, uu));\n\n  return mat4(vec4(uu, 0.0), vec4(vv, 0.0), vec4(ww, 0.0), vec4(origin, 1.0));\n}\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n  return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\n/* VS Outputs */\nvarying float v_instanceID;\nvarying vec2 v_texCoord;\nvarying float v_alpha;\nvarying vec4 v_tint;\nvarying vec3 v_viewPos;\n\nvoid main(void) {\n\n#ifdef ENABLE_FLOAT_TEXTURES\n\n  int instanceID = int(instanceIds);\n  v_instanceID = float(instanceID) + 0.25;\n\n  mat4 modelMatrix = getModelMatrix(instanceID);\n  vec2 pivot = getPivot(instanceID).xy;\n  vec4 billboardData = getInstanceData(instanceID);\n  vec4 layoutData = fetchTexel(atlasBillboards_layout, int(atlasBillboards_desc.z), int(billboardData.z));\n  v_tint = getTintColor(instanceID);\n\n#else\n\n  v_tint = tintColor;\n\n#endif\n\n  vec2 quadVertex = getQuadVertexPositionFromID();\n  \n  vec2 pos = quadVertex + vec2(0.5, 0.0) - pivot;\n  v_texCoord = vec2(quadVertex.x, -quadVertex.y) + 0.5;\n  v_alpha = billboardData.w;\n  v_texCoord *= layoutData.zw;\n  v_texCoord += layoutData.xy;\n\n  float scl = billboardData.x;\n  float width = layoutData.z * atlasBillboards_desc.x * scl;\n  float height = layoutData.w * atlasBillboards_desc.y * scl;\n  int flags = int(billboardData.y);\n\n  // Use cross platform bit flags methods\n  bool alignedToCamera = testFlag(flags, 4); // flag = 1<<2\n  bool drawOnTop = testFlag(flags, 8); // flag = 1 << 3\n  bool fixedSizeOnscreen = testFlag(flags, 16); // flag = 1 << 4\n\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n  // Note: items in front of the camera will have a negative value here.\n  float sc = 1.0;\n  if (fixedSizeOnscreen) {\n    sc = -modelViewMatrix[3][2];\n    \n    if (inVR == 1) {\n      // During XR sessions, there is a scaling applied to the view matrix\n      // which causes a distortion to the line width. We extract that scale here\n      // and use to correct the distortion.\n      // See also: FatPointsShader\n      vec3 viewZ = modelViewMatrix[2].xyz;\n      float viewScale = length(viewZ);\n      sc /= viewScale;\n    }\n  }\n  \n  mat4 modelViewProjectionMatrix;\n  if (alignedToCamera) {\n    if (inVR == 0) {\n      gl_Position = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n      gl_Position += vec4(pos.x * width * sc, (pos.y + 0.5) * height * sc, 0.0, 0.0);\n      v_viewPos = gl_Position.xyz;\n      gl_Position = projectionMatrix * gl_Position;\n    } else {\n      vec3 cameraPos = vec3(cameraMatrix[3][0], cameraMatrix[3][1], cameraMatrix[3][2]);\n      vec3 billboardPos = vec3(modelMatrix[3][0], modelMatrix[3][1], modelMatrix[3][2]);\n      mat4 lookAt = calcLookAtMatrix(billboardPos, cameraPos, 0.0);\n      mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * lookAt;\n      gl_Position = modelViewProjectionMatrix * vec4(pos.x * width * sc, (pos.y + 0.5) * height * sc, 0.0, 1.0);\n      v_viewPos = (modelViewMatrix * vec4(pos.x * width * sc, (pos.y + 0.5) * height * sc, 0.0, 1.0)).xyz;\n    }\n  }\n  else {\n    modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;\n    gl_Position = modelViewProjectionMatrix * vec4(pos.x * width, (pos.y + 0.5) * height, 0.0, 1.0);\n    v_viewPos = (modelViewMatrix * vec4(pos.x * width, (pos.y + 0.5) * height, 0.0, 1.0)).xyz;\n  }\n\n  // Use cross platform bit flags methods\n  if (drawOnTop) {\n    if (isOrthographic > 0){\n      gl_Position.z = mix(gl_Position.z, -1.0, 0.5);\n    } else {\n      gl_Position.z = mix(gl_Position.z, -gl_Position.z, 0.5);\n    }\n  }\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nimport 'imageAtlas.glsl'\n\nuniform sampler2D atlasBillboards;\n\n/* VS Outputs */\nvarying float v_instanceID;\nvarying vec2 v_texCoord;\nvarying float v_alpha;\nvarying vec4 v_tint;\nvarying vec3 v_viewPos;\n\nuniform sampler2D instancesTexture;\nuniform int instancesTextureSize;\n\n#if defined(DRAW_GEOMDATA)\n  uniform int isOrthographic;\n  import 'surfaceGeomData.glsl'\n#endif // DRAW_GEOMDATA\n\nconst int cols_per_instance = 7;\n\nvec4 getHilightColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * cols_per_instance) + 6);\n}\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  int instanceID = int(v_instanceID);\n  vec4 imageColor = texture2D(atlasBillboards, v_texCoord) * v_tint;\n  imageColor.a *= v_alpha;\n  if(imageColor.a < 0.1)\n    discard;\n\n#if defined(DRAW_COLOR)\n  fragColor = imageColor;\n  // fragColor.r = 1.0;\n  // fragColor.a = 1.0;\n#elif defined(DRAW_GEOMDATA)\n  fragColor = setFragColor_geomData(v_viewPos, floatGeomBuffer, passId, v_instanceID, 0.0, isOrthographic);\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = getHilightColor(instanceID);\n  // Skip unhilighting labels.\n  if(fragColor.r < 0.001 && fragColor.g < 0.001 && fragColor.b < 0.001)\n    discard;\n#endif // DRAW_HIGHLIGHT\n  \n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n");
    }
  };
  var be = class extends DC {
    constructor(A3) {
      super(A3, "EnvProjectionShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;    //(location = 0)\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform vec3 projectionCenter;\n\nimport 'inverse.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\n \nvoid main()\n{\n  int geomItemId = getGeomItemId();\n  vec4 pos = vec4(positions, 1.);\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n  mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;\n\n  gl_Position = modelViewProjectionMatrix * pos;\n\n  vec4 worldPos = modelMatrix * pos;\n  v_worldDir = worldPos.xyz - projectionCenter;\n}\n\n");
    }
  };
  new XI("EnvProjectionShader_template").addParameter(new LA("projectionCenter", new o(0, 0, 1.7)));
  var Ze = class extends DC {
    constructor(A3) {
      super(A3, "FatLinesShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\ninstancedattribute vec2 segmentIndices;\nattribute float vertexIDs;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform int isOrthographic;\n\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\nuniform int geomItemId;\nint getGeomItemId() {\n  return geomItemId;\n}\n\nuniform sampler2D positionsTexture;\nuniform int positionsTextureSize;\n\nuniform float LineThickness;\nuniform float Overlay;\n\nimport 'calcFatLinesViewPos.glsl'\n\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_texCoord;\n\nvarying float v_geomItemId;\nvarying vec4 v_geomItemData;\nvarying float v_drawItemID;\nvarying vec3 v_worldPos;\n\nvoid main(void) {\n\n  int geomItemId = getGeomItemId();\n  v_geomItemId = float(geomItemId);\n  v_geomItemData = getInstanceData(geomItemId);\n\n  int vertexID = int(vertexIDs);\n\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  vec3 pos;\n\n  #if defined(DRAW_COLOR)\n    v_viewPos       = calcFatLinesViewPos(vertexID, modelViewMatrix, v_viewNormal, v_texCoord, pos);\n  #elif defined(DRAW_GEOMDATA)\n    vec3  viewNormal;\n    vec2  texCoord;\n    v_viewPos       = calcFatLinesViewPos(vertexID, modelViewMatrix, viewNormal, texCoord, pos);\n    v_drawItemID = float(getGeomItemId());\n    v_worldPos      = (modelMatrix * vec4(pos, 1.0)).xyz;\n  #endif\n\n  gl_Position     = projectionMatrix * vec4(v_viewPos, 1.0);\n\n  if (isOrthographic > 0){\n    gl_Position.z -= mix(gl_Position.z, -1.0, Overlay);\n  } else {\n    gl_Position.z = mix(gl_Position.z, -gl_Position.z, Overlay);\n  }\n\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nuniform color BaseColor;\nuniform mat4 cameraMatrix;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\n/* VS Outputs */\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_texCoord;\nvarying float v_geomItemId;\nvarying vec4 v_geomItemData;\nvarying float v_drawItemID;\nvarying vec3 v_worldPos;\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\nimport 'cutaways.glsl'\nimport 'GLSLBits.glsl'\n\nuniform int floatGeomBuffer;\nuniform int passId;\n\n#if defined(DRAW_HIGHLIGHT)\n  import 'surfaceHighlight.glsl'\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n  float treeItemOpacity = v_geomItemData.y;\n\n#if defined(DRAW_COLOR)\n  int debugLevel = 0;\n  if (debugLevel == 0) {\n\n    vec3 viewVector = mat3(cameraMatrix) * normalize(-v_viewPos);\n    vec3 normal = mat3(cameraMatrix) * v_viewNormal;\n    float NdotV = dot(normalize(normal), normalize(viewVector));\n\n    // Modulate the lighting using the texture coord so the line looks round.\n    NdotV *= cos((v_texCoord.x - 0.5) * 2.0);\n\n    vec4 color = BaseColor * NdotV;\n    fragColor = vec4(color.rgb, BaseColor.a * treeItemOpacity);\n  }\n  else {\n    fragColor = vec4(v_texCoord.x, 0.0, 0.0, 1.0);\n  }\n#elif defined(DRAW_GEOMDATA)\n  int geomItemId = int(v_geomItemId + 0.5);\n  int flags = int(v_geomItemData.x + 0.5);\n\n // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) {\n    vec4 cutAwayData  = getCutaway(geomItemId);\n    vec3 planeNormal = cutAwayData.xyz;\n    float planeDist = cutAwayData.w;\n    if (cutaway(v_worldPos, planeNormal, planeDist)) {\n      discard;\n      return;\n    }\n  }\n  if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n    discard;\n    return;\n  }\n\n  float dist = length(v_viewPos);\n\n  if (floatGeomBuffer != 0) {\n    fragColor.r = float(passId); \n    fragColor.g = float(v_drawItemID);\n    fragColor.b = 0.0;// TODO: store poly-id or something.\n    fragColor.a = dist;\n  }\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = setFragColor_highlight(v_geomItemId);\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n");
    }
    bind(A3, g3) {
      return !!super.bind(A3, g3) && (A3.supportsInstancing = false, true);
    }
    static supportsInstancing() {
      return false;
    }
    static getMaterialTemplate() {
      return ye;
    }
  };
  var ye = new HI("FatLinesShader_template");
  e.register("FatLinesShader", Ze);
  var ue = class extends DC {
    constructor(A3) {
      super(A3, "FlatSurfaceShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nattribute vec3 positions;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform int isOrthographic;\n\nimport 'GLSLUtils.glsl'\n\nimport 'geomItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\n#ifdef ENABLE_MULTI_DRAW\nimport 'materialparams.glsl'\n#else\nuniform float Overlay;\n#endif\n\n/* VS Outputs */\nvarying vec4 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n\nvoid main(void) {\n  v_drawItemIds = getDrawItemIds();\n  int geomItemId = int(v_drawItemIds.x + 0.5);\n  v_geomItemData  = getInstanceData(geomItemId);\n\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n  vec4 pos = vec4(positions, 1.);\n  vec4 viewPos = (modelViewMatrix * pos);\n  gl_Position = projectionMatrix * viewPos;\n\n  v_viewPos = viewPos.xyz;\n#ifdef ENABLE_TEXTURES\n  v_textureCoord = texCoords;\n  v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y\n#endif\n\n  //////////////////////////////////////////////\n  // Overlay\n\n#ifdef ENABLE_MULTI_DRAW\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 materialValue1 = getMaterialValue(materialCoords, 1);\n  float overlay = materialValue1.x;\n#else\n  float overlay = Overlay;\n#endif\n\n  if (isOrthographic > 0){\n    gl_Position.z -= overlay;\n  } else {\n    gl_Position.z = mix(gl_Position.z, -gl_Position.z, overlay);\n  }\n\n  //////////////////////////////////////////////\n  \n  v_worldPos      = (modelMatrix * pos).xyz;\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\nimport 'cutaways.glsl'\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\n\n#ifdef DEBUG_GEOM_ID\nimport 'debugColors.glsl'\n#endif\n\n#ifndef ENABLE_MULTI_DRAW\n\nuniform color BaseColor;\n\n#ifdef ENABLE_TEXTURES\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\n#endif\n\n#endif // ENABLE_MULTI_DRAW\n\n/* VS Outputs */\nvarying vec4 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\n#if defined(DRAW_GEOMDATA)\n  uniform int isOrthographic;\n  import 'surfaceGeomData.glsl'\n#elif defined(DRAW_HIGHLIGHT)\n  import 'surfaceHighlight.glsl'\n#endif // DRAW_HIGHLIGHT\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  int geomItemId = int(v_drawItemIds.x + 0.5);\n  int flags = int(v_geomItemData.x + 0.5);\n  float treeItemOpacity = v_geomItemData.y;\n\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) \n  {\n    vec4 cutAwayData   = getCutaway(geomItemId);\n    vec3 planeNormal = cutAwayData.xyz;\n    float planeDist = cutAwayData.w;\n    if (cutaway(v_worldPos, planeNormal, planeDist)) {\n      discard;\n      return;\n    }\n  }\n\n  //////////////////////////////////////////////\n  // Material\n#ifdef ENABLE_MULTI_DRAW\n\n  vec2 materialCoords = v_geomItemData.zw;\n  if (v_drawItemIds.z > 0.5) {\n    materialCoords.x = v_drawItemIds.z;\n  }\n  vec4 baseColor = getMaterialValue(materialCoords, 0);\n\n#else // ENABLE_MULTI_DRAW\n\n#ifndef ENABLE_TEXTURES\n  vec4 baseColor = BaseColor;\n#else\n  vec4 baseColor = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, v_textureCoord);\n#endif // ENABLE_TEXTURES\n\n#endif // ENABLE_MULTI_DRAW\n\n  baseColor.a *= treeItemOpacity;\n  if (baseColor.a < 0.001) discard;\n\n#if defined(DRAW_COLOR)\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) {\n    if (!gl_FrontFacing) {\n#ifdef ENABLE_ES3\n      fragColor = cutColor;\n#else\n      gl_FragColor = cutColor;\n#endif\n      return;\n    }\n  }\n\n  //////////////////////////////////////////////\n  fragColor = baseColor;\n\n#ifdef DEBUG_GEOM_ID\n  // ///////////////////////\n  // Debug Draw ID (this correlates to GeomID within a GLGeomSet)\n  float geomId = v_geomItemData.w;\n  fragColor.rgb = getDebugColor(geomId);\n  // ///////////////////////\n#endif\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb);\n#endif\n\n#elif defined(DRAW_GEOMDATA)\n\n  if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n    discard;\n    return;\n  }\n  if (occlusionCulling != 0) {\n    // Transparent geoms do not render to the occlusion buffer\n    if (testFlag(flags, GEOMITEM_TRANSPARENT)) {\n      discard;\n      return;\n    }\n  }\n  fragColor = setFragColor_geomData(v_viewPos, floatGeomBuffer, passId, v_drawItemIds.x, v_drawItemIds.y, isOrthographic);\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = setFragColor_highlight(v_drawItemIds.x);\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n");
    }
    bind(A3, g3) {
      super.bind(A3, g3), A3.pushGLStack();
      const I3 = this.__gl;
      return A3.glDisable(I3.CULL_FACE), true;
    }
    unbind(A3) {
      return super.unbind(A3), this.__gl, A3.popGLStack(), true;
    }
    static getPackedMaterialData(A3) {
      const g3 = new Float32Array(8), I3 = A3.getParameter("BaseColor");
      let C3;
      C3 = I3 instanceof Qg && I3.colorSpace == pA.Gamma ? I3.value.toLinear() : I3.value, g3[0] = C3.r, g3[1] = C3.g, g3[2] = C3.b, g3[3] = C3.a;
      const i3 = A3.getParameter("Overlay");
      return i3 && (g3[4] = i3.getValue()), g3;
    }
    static getMaterialTemplate() {
      return Re;
    }
  };
  var Re = new YI("FlatSurfaceShader_template");
  e.register("FlatSurfaceShader", ue);
  var Ve = class extends DC {
    constructor(A3) {
      super(A3, "LinesShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nattribute vec3 positions;\nattribute vec3 positionsNext;\n\nimport 'GLSLUtils.glsl'\nimport 'geomItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform int isOrthographic;\n\n#ifdef ENABLE_MULTI_DRAW\nimport 'materialparams.glsl'\n#else\nuniform float Overlay;\n#endif\n\n/* VS Outputs */\nvarying float v_geomItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_nextVertexDist;\n\nvoid main(void) {\n  int geomItemId = getGeomItemId();\n  v_geomItemId = float(geomItemId);\n  v_geomItemData  = getInstanceData(geomItemId);\n\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  vec4 viewPos = modelViewMatrix * vec4(positions, 1.0);\n  vec4 viewPosNext = modelViewMatrix * vec4(positionsNext, 1.0);\n\n#ifdef ENABLE_ES3\n  float nextVertexDist = length(viewPosNext.xyz - viewPos.xyz);\n  if (imod(gl_VertexID, 2) == 0) {\n    v_nextVertexDist.x = nextVertexDist;\n    v_nextVertexDist.y = 0.0;\n  } else {\n    v_nextVertexDist.x = 0.0;\n    v_nextVertexDist.y = nextVertexDist;\n  }\n  v_nextVertexDist.z = float(gl_VertexID);\n#endif\n\n  v_viewPos = viewPos.xyz;\n  gl_Position = projectionMatrix * viewPos;\n    \n\n  //////////////////////////////////////////////\n  // Overlay\n\n#ifdef ENABLE_MULTI_DRAW\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 materialValue1 = getMaterialValue(materialCoords, 1);\n  float overlay = materialValue1.y;\n#else\n  float overlay = Overlay;\n#endif\n\n   \n#if defined(DRAW_GEOMDATA)\n  float _overlay = mix(overlay, 1.0, 0.0001);\n#else\n  float _overlay = overlay;\n#endif\n\n  if (isOrthographic > 0){\n    gl_Position.z -= _overlay;\n  } else {\n    gl_Position.z = mix(gl_Position.z, -gl_Position.z, _overlay);\n  }\n\n  //////////////////////////////////////////////\n  \n  \n  vec4 pos = vec4(positions, 1.);\n  v_worldPos      = (modelMatrix * pos).xyz;\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\nimport 'cutaways.glsl'\nimport 'materialparams.glsl'\n\n#if defined(DRAW_COLOR)\n\nuniform int occluded;\nuniform vec4 hiddenLineColor;\n\n#ifndef ENABLE_MULTI_DRAW\n\nuniform color BaseColor;\nuniform float Opacity;\n\nuniform color OccludedColor;\n\n#endif // ENABLE_MULTI_DRAW\n\n#elif defined(DRAW_GEOMDATA)\n\nuniform int isOrthographic;\n\nimport 'surfaceGeomData.glsl'\n\n#elif defined(DRAW_HIGHLIGHT)\n\n#ifdef ENABLE_FLOAT_TEXTURES\nvec4 getHighlightColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 4);\n}\n#else // ENABLE_FLOAT_TEXTURES\n\nuniform vec4 highlightColor;\n\nvec4 getHighlightColor() {\n  return highlightColor;\n}\n\n#endif // ENABLE_FLOAT_TEXTURES\n\n#endif // DRAW_HIGHLIGHT\n\n/* VS Outputs */\nvarying float v_geomItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_nextVertexDist;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  int geomItemId = int(v_geomItemId + 0.5);\n  int flags = int(v_geomItemData.x + 0.5);\n  float treeItemOpacity = v_geomItemData.y;\n\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) \n  {\n    vec4 cutAwayData   = getCutaway(geomItemId);\n    vec3 planeNormal = cutAwayData.xyz;\n    float planeDist = cutAwayData.w;\n    if (cutaway(v_worldPos, planeNormal, planeDist)) {\n      discard;\n      return;\n    }\n  }\n\n  //////////////////////////////////////////////\n  // Material\n\n#ifdef ENABLE_MULTI_DRAW\n\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 BaseColor = getMaterialValue(materialCoords, 0);\n  vec4 matValue1 = getMaterialValue(materialCoords, 1);\n  vec4 matValue2 = getMaterialValue(materialCoords, 2);\n  float Opacity  = matValue1.r;\n#endif // ENABLE_MULTI_DRAW\n\n  //////////////////////////////////////////////\n  // Color\n#if defined(DRAW_COLOR)\n\n  fragColor = BaseColor;\n  \n  if (occluded == 1) {\n    fragColor = hiddenLineColor;\n  }\n\n  fragColor.a *= Opacity * treeItemOpacity;\n\n  //////////////////////////////////////////////\n  // GeomData\n#elif defined(DRAW_GEOMDATA)\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n    discard;\n    return;\n  }\n  \n  fragColor = setFragColor_geomData(v_viewPos, floatGeomBuffer, passId, v_geomItemId, 0.0, isOrthographic);\n  \n  //////////////////////////////////////////////\n  // Highlight\n#elif defined(DRAW_HIGHLIGHT)\n  \n  fragColor = getHighlightColor(geomItemId);\n\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n");
    }
    static getPackedMaterialData(A3) {
      const g3 = new Float32Array(8), I3 = A3.getParameter("BaseColor");
      let C3;
      return C3 = I3 instanceof Qg && I3.colorSpace == pA.Gamma ? I3.value.toLinear() : I3.value, g3[0] = C3.r, g3[1] = C3.g, g3[2] = C3.b, g3[3] = C3.a, g3[4] = A3.getParameter("Opacity").value, g3[5] = A3.getParameter("Overlay").value, g3;
    }
    static getMaterialTemplate() {
      return Fe;
    }
  };
  var Fe = new KI("LinesShader_template");
  e.register("LinesShader", Ve);
  var Se = class extends DC {
    constructor(A3) {
      super(A3, "PointsShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;\n\nimport 'GLSLUtils.glsl'\nimport 'geomItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform int isOrthographic;\n\n#ifdef ENABLE_MULTI_DRAW\nimport 'materialparams.glsl'\n#else\nuniform float PointSize;\nuniform float Overlay;\n#endif\n\n/* VS Outputs */\nvarying float v_geomItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\n\nvoid main(void) {\n  int geomItemId = getGeomItemId();\n  v_geomItemId = float(geomItemId);\n  v_geomItemData  = getInstanceData(geomItemId);\n\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  \n  vec4 viewPos = modelViewMatrix * vec4(positions, 1.);\n  gl_Position = projectionMatrix * viewPos;\n  \n\n  //////////////////////////////////////////////\n  // Material\n#ifdef ENABLE_MULTI_DRAW\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 materialValue1 = getMaterialValue(materialCoords, 1);\n  int maintainScreenSize = int(materialValue1.x + 0.5);\n  float pointSize = materialValue1.x;\n  float overlay = materialValue1.y;\n#else\n  float pointSize = PointSize;\n  float overlay = Overlay;\n#endif\n  //////////////////////////////////////////////\n\n  // Note: as of 22/01/2021 gl_PointSize has stopped working again...\n  gl_PointSize = pointSize;\n\n#if defined(DRAW_GEOMDATA)\n  // Make the geom data point size at least 8 pixels across, else its impossible to hit.\n  gl_PointSize = max(8.0, pointSize);\n#endif\n\n  if (isOrthographic > 0){\n    gl_Position.z -= overlay;\n  } else {\n    gl_Position.z = mix(gl_Position.z, -gl_Position.z, overlay);\n  }\n  \n  v_viewPos = -viewPos.xyz;\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\n#ifndef ENABLE_MULTI_DRAW\n\nuniform color BaseColor;\n\n#endif\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\nimport 'cutaways.glsl'\nimport 'materialparams.glsl'\n\n#if defined(DRAW_GEOMDATA)\n\nuniform int floatGeomBuffer;\nuniform int passId;\n\nimport 'GLSLBits.glsl'\n\n#elif defined(DRAW_HIGHLIGHT)\n\n#ifdef ENABLE_FLOAT_TEXTURES\nvec4 getHighlightColor(int id) {\n  return fetchTexel(instancesTexture, instancesTextureSize, (id * pixelsPerItem) + 4);\n}\n#else // ENABLE_FLOAT_TEXTURES\n\nuniform vec4 highlightColor;\n\nvec4 getHighlightColor() {\n  return highlightColor;\n}\n\n#endif // ENABLE_FLOAT_TEXTURES\n\n#endif // DRAW_HIGHLIGHT\n\n/* VS Outputs */\nvarying float v_geomItemId;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\n/* VS Outputs */\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  //////////////////////////////////////////////\n  // Color\n#if defined(DRAW_COLOR)\n\n#ifdef ENABLE_MULTI_DRAW\n\n  vec2 materialCoords = v_geomItemData.zw;\n  vec4 baseColor = getMaterialValue(materialCoords, 0);\n  vec4 matValue1 = getMaterialValue(materialCoords, 1);\n  float pointSize       = baseColor.a * matValue1.r;\n  float overlay      = matValue1.g;\n\n#else // ENABLE_MULTI_DRAW\n\n  vec4 baseColor = BaseColor;\n\n#endif // ENABLE_MULTI_DRAW\n\n  fragColor = baseColor;\n\n  //////////////////////////////////////////////\n  // GeomData\n#elif defined(DRAW_GEOMDATA)\n\n  float viewDist = length(v_viewPos);\n\n  if (floatGeomBuffer != 0) {\n    fragColor.r = float(passId); \n    fragColor.g = float(v_geomItemId);\n    fragColor.b = 0.0;// TODO: store poly-id or something.\n    fragColor.a = viewDist;\n  }\n  else {\n    ///////////////////////////////////\n    // UInt8 buffer\n    fragColor.r = mod(v_geomItemId, 256.) / 256.;\n    fragColor.g = (floor(v_geomItemId / 256.) + (float(passId) * 64.)) / 256.;\n\n    // encode the dist as a 16 bit float\n    vec2 float16bits = encode16BitFloatInto2xUInt8(viewDist);\n    fragColor.b = float16bits.x;\n    fragColor.a = float16bits.y;\n  }\n\n  //////////////////////////////////////////////\n  // Highlight\n#elif defined(DRAW_HIGHLIGHT)\n  \n  int geomItemId = int(v_geomItemId + 0.5);\n  fragColor = getHighlightColor(geomItemId);\n\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n");
    }
    static getPackedMaterialData(A3) {
      const g3 = new Float32Array(12), I3 = A3.getParameter("BaseColor");
      let C3;
      return C3 = I3 instanceof Qg && I3.colorSpace == pA.Gamma ? I3.value.toLinear() : I3.value, g3[0] = C3.r, g3[1] = C3.g, g3[2] = C3.b, g3[3] = C3.a, g3[4] = A3.getParameter("PointSize").value, g3[5] = A3.getParameter("Overlay").value, g3;
    }
    static getMaterialTemplate() {
      return we;
    }
  };
  var we = new pI("PointsShader_template");
  e.register("PointsShader", Se);
  var Xe = class extends DC {
    constructor(A3) {
      super(A3, "FatPointsShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\ninstancedattribute vec3 positions;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform int isOrthographic;\n\nimport 'GLSLUtils.glsl' \nimport 'inverse.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\nimport 'quadVertexFromID.glsl'\n\nuniform int geomItemId;\nint getGeomItemId() {\n  return geomItemId;\n}\n\nuniform float PointSize;\nuniform float Overlay;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\nvarying vec3 v_viewPos;\nvarying float v_geomItemId;\n\nvoid main(void) {\n  int geomItemId = getGeomItemId();\n  vec2 quadPointPos = getQuadVertexPositionFromID();\n  v_texCoord = quadPointPos + 0.5;\n\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  \n  vec4 viewPos = modelViewMatrix * vec4(positions, 1.);\n\n  // During XR sessions, there is a scaling applied to the view matrix\n  // which causes a distortion to the line width. We extract that scale here\n  // and use to correct the distortion.\n  // See also: FatLinesShader\n  vec3 viewZ = modelViewMatrix[2].xyz;\n  float viewScale = length(viewZ);\n  viewPos += vec4(vec3(quadPointPos, 0.0) * PointSize * viewScale, 0.);\n\n  // Generate a quad which is 0.5 * PointSize closer towards\n  // us. This allows points to be visualized even if snug on \n  // a surface. (else they get fully clipped)\n  viewPos.z += 0.5 * PointSize;\n\n  v_geomItemId = float(getGeomItemId());\n  v_viewPos = -viewPos.xyz;\n  \n  gl_Position = projectionMatrix * viewPos;\n\n  if (isOrthographic > 0){\n    gl_Position.z -= Overlay;\n  } else {\n    gl_Position.z = mix(gl_Position.z, -gl_Position.z, Overlay);\n  }\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nimport 'constants.glsl'\n\nuniform color BaseColor;\nuniform float Rounded;\nuniform float BorderWidth;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\nvarying vec3 v_viewPos;\nvarying float v_geomItemId;\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\n#if defined(DRAW_GEOMDATA)\n  uniform int isOrthographic;\n  import 'surfaceGeomData.glsl'\n#elif defined(DRAW_HIGHLIGHT)\n  import 'surfaceHighlight.glsl'\n#endif // DRAW_HIGHLIGHT\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\nfloat dist = length(v_texCoord - 0.5);\nif (dist > 0.5)\n  discard;\n\n#if defined(DRAW_COLOR)\n\n  if (dist > 0.5 - (BorderWidth * 0.5))\n    fragColor = vec4(0.,0.,0.,1.);\n  else {\n    // Modulate the lighting using the texture coord so the point looks round.\n    float NdotV = cos(dist * PI);\n\n    fragColor = BaseColor * mix(1.0, NdotV, Rounded);\n  }\n\n#elif defined(DRAW_GEOMDATA)\n  fragColor = setFragColor_geomData(v_viewPos, floatGeomBuffer, passId, v_geomItemId, 0.0, isOrthographic);\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = setFragColor_highlight(v_geomItemId);\n#endif // DRAW_HIGHLIGHT\n\n  \n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n");
    }
    bind(A3, g3) {
      return !!super.bind(A3, g3) && (A3.supportsInstancing = false, true);
    }
    static supportsInstancing() {
      return false;
    }
    static getMaterialTemplate() {
      return He;
    }
  };
  var He = new WI("FatPointsShader_template");
  e.register("FatPointsShader", Xe);
  var We = class extends DC {
    constructor(A3) {
      super(A3, "SimpleSurfaceShader"), this.setShaderStage("VERTEX_SHADER", "precision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;\nattribute vec3 normals;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nimport 'GLSLUtils.glsl'\nimport 'transpose.glsl'\nimport 'inverse.glsl'\nimport 'geomItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\n/* VS Outputs */\nvarying vec4 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n\nvoid main(void) {\n  v_drawItemIds = getDrawItemIds();\n  int geomItemId = int(v_drawItemIds.x + 0.5);\n  v_geomItemData  = getInstanceData(geomItemId);\n\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n  vec4 pos = vec4(positions, 1.);\n  vec4 viewPos    = modelViewMatrix * pos;\n  gl_Position     = projectionMatrix * viewPos;\n\n  mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));\n  v_viewPos       = -viewPos.xyz;\n  v_viewNormal    = normalMatrix * normals;\n\n#ifdef ENABLE_TEXTURES\n  v_textureCoord  = texCoords;\n  // v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y\n#endif\n\n  v_worldPos      = (modelMatrix * pos).xyz;\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "precision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl'\nimport 'cutaways.glsl'\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\n\n#ifdef DEBUG_GEOM_ID\nimport 'debugColors.glsl'\n#endif\n\n/* VS Outputs */\nvarying vec4 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n/* VS Outputs */\n\nuniform mat4 cameraMatrix;\nuniform int isOrthographic;\n\n#ifdef ENABLE_ES3\n    out vec4 fragColor;\n#endif\n\n#if defined(DRAW_COLOR)\n\n#ifndef ENABLE_MULTI_DRAW\n\nuniform color BaseColor;\nuniform float Opacity;\nuniform float EmissiveStrength;\n\n#ifdef ENABLE_TEXTURES\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\nuniform sampler2D OpacityTex;\nuniform int OpacityTexType;\nuniform sampler2D EmissiveStrengthTex;\nuniform int EmissiveStrengthTexType;\n#endif // ENABLE_TEXTURES\n\n#endif // ENABLE_MULTI_DRAW\n\nimport 'computeViewNormal.glsl'\n  \n// end DRAW_COLOR\n#elif defined(DRAW_GEOMDATA)\n  import 'surfaceGeomData.glsl'\n#elif defined(DRAW_HIGHLIGHT)\n  import 'surfaceHighlight.glsl'\n#endif // DRAW_HIGHLIGHT\n\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n  int geomItemId = int(v_drawItemIds.x + 0.5);\n  int elemId = int(v_drawItemIds.y + 0.5);\n  int perFaceMaterialId = int(v_drawItemIds.z);\n  int flags = int(v_geomItemData.x + 0.5);\n  float treeItemOpacity = v_geomItemData.y;\n\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) \n  {\n    vec4 cutAwayData   = getCutaway(geomItemId);\n    vec3 planeNormal = cutAwayData.xyz;\n    float planeDist = cutAwayData.w;\n    if (cutaway(v_worldPos, planeNormal, planeDist)) {\n      discard;\n      return;\n    }\n  }\n\n#if defined(DRAW_COLOR)\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) \n  {\n    if (!gl_FrontFacing) {\n#ifdef ENABLE_ES3\n      fragColor = cutColor;\n#else\n      gl_FragColor = cutColor;\n#endif\n      return;\n    }\n  }\n\n  //////////////////////////////////////////////\n  // Normals\n  \n  vec3 viewNormal;\n  if (length(v_viewNormal) < 0.1) {\n    viewNormal = computeViewNormal(v_viewPos);\n  } else {\n    viewNormal = normalize(v_viewNormal);\n  }\n  vec3 normal = normalize(mat3(cameraMatrix) * viewNormal);\n  \n  vec3 viewVector;\n  if (isOrthographic == 0)\n    viewVector = normalize(mat3(cameraMatrix) * normalize(v_viewPos));\n  else \n    viewVector = vec3(-cameraMatrix[2][0], -cameraMatrix[2][1], -cameraMatrix[2][2]);\n  \n  //////////////////////////////////////////////\n  // Material\n\n#ifdef ENABLE_MULTI_DRAW\n\n  vec2 materialCoords = v_geomItemData.zw;\n  if (v_drawItemIds.z > 0.5) {\n    materialCoords.x = v_drawItemIds.z;\n  }\n  vec4 baseColor      = getMaterialValue(materialCoords, 0);\n  vec4 matValue1      = getMaterialValue(materialCoords, 1);\n  float opacity       = baseColor.a * matValue1.r;\n  float emission      = matValue1.g;\n\n#else // ENABLE_MULTI_DRAW\n\n#ifndef ENABLE_TEXTURES\n  vec4 baseColor      = BaseColor;\n  float emission      = EmissiveStrength;\n  float opacity       = baseColor.a * Opacity;\n#else\n  vec4 baseColor      = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, v_textureCoord);\n  float opacity       = baseColor.a * getLuminanceParamValue(Opacity, OpacityTex, OpacityTexType, v_textureCoord) * treeItemOpacity;\n  float emission      = getLuminanceParamValue(EmissiveStrength, EmissiveStrengthTex, EmissiveStrengthTexType, v_textureCoord);\n#endif\n\n#endif // ENABLE_MULTI_DRAW\n\n  // Hacky simple irradiance. \n  float ndotv = dot(normal, viewVector);\n  if (ndotv < 0.0) {\n    normal = -normal;\n    ndotv = dot(normal, viewVector);\n\n    // Note: these 2 lines can be used to debug inverted meshes.\n    //baseColor = vec4(1.0, 0.0, 0.0, 1.0);\n    //ndotv = 1.0;\n  }\n\n  fragColor = vec4((ndotv * baseColor.rgb) + (emission * baseColor.rgb), opacity);\n\n  // Note: the 'treeItemOpacity' is not an input to the lighting, \n  // as we want to also blend off the specular reflections to make an object\n  // fade away to nothing. (not become a transparent glass object).\n  fragColor.a *= treeItemOpacity;\n\n#ifdef DEBUG_GEOM_ID\n  // ///////////////////////\n  // Debug Draw ID (this correlates to GeomID within a GLGeomSet)\n  float geomId = v_geomItemData.w;\n  fragColor.rgb = getDebugColor(geomId);\n  // ///////////////////////\n#endif\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb);\n#endif\n\n#elif defined(DRAW_GEOMDATA)\n\n  if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n    discard;\n    return;\n  }\n  if (occlusionCulling != 0) {\n    // Transparent geoms do not render to the occlusion buffer\n    if (testFlag(flags, GEOMITEM_TRANSPARENT)) {\n      discard;\n      return;\n    }\n  }\n  fragColor = setFragColor_geomData(v_viewPos, floatGeomBuffer, passId, v_drawItemIds.x, v_drawItemIds.y, isOrthographic);\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = setFragColor_highlight(v_drawItemIds.x);\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}");
    }
    static getPackedMaterialData(A3) {
      const g3 = new Float32Array(8), I3 = A3.getParameter("BaseColor");
      let C3;
      return C3 = I3 instanceof Qg && I3.colorSpace == pA.Gamma ? I3.value.toLinear() : I3.value, g3[0] = C3.r, g3[1] = C3.g, g3[2] = C3.b, g3[3] = C3.a, g3[4] = A3.getParameter("Opacity").value, g3[5] = A3.getParameter("EmissiveStrength").value, g3;
    }
    static getMaterialTemplate() {
      return Ye;
    }
  };
  var Ye = new JI("SimpleSurfaceShader_template");
  e.register("SimpleSurfaceShader", We);
  var Ke = class extends DC {
    constructor(A3) {
      super(A3, "StandardSuraceShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\nattribute vec3 positions;\nattribute vec3 normals;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform int isOrthographic;\n\n// Now that we render multiple types of geometry from a single shader\n// we need to know what kind of geometry it is...\nuniform int geomType;\n\nuniform float outlineThickness;\nuniform vec2 viewportSize;\n\n// should be imported by bottom 3\nimport 'GLSLUtils.glsl'\nimport 'transpose.glsl'\nimport 'inverse.glsl'\n\nimport 'geomItemId.glsl'\nimport 'geomType.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\n/* VS Outputs */\nvarying vec4 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n/* VS Outputs */\n\n#if defined(DRAW_COLOR)\n#elif defined(DRAW_GEOMDATA)\n#elif defined(DRAW_HIGHLIGHT)\n#endif // DRAW_HIGHLIGHT\n\nvoid main(void) {\n\n  v_drawItemIds = getDrawItemIds();\n  int geomItemId = int(v_drawItemIds.x + 0.5);\n  v_geomItemData = getInstanceData(geomItemId);\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n\n  vec4 pos = vec4(positions, 1.);\n  mat4 modelViewMatrix = viewMatrix * modelMatrix;\n  vec4 viewPos    = modelViewMatrix * pos;\n  gl_Position     = projectionMatrix * viewPos;\n  v_viewPos = -viewPos.xyz;\n  v_worldPos      = (modelMatrix * pos).xyz;\n\n  mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));\n  v_viewPos       = -viewPos.xyz;\n  v_viewNormal    = normalMatrix * normals;\n  \n  // offset slightly the lines and points to make them clearly defined.\n  // This ensures that lines drawn over surfaces are solid and not clipped\n  // at all by the surface.\n  if (geomType == TRIANGLES) {\n    if (outlineThickness > 0.00001) {\n      vec2 screenNormal = v_viewNormal.xy;\n      gl_Position.xy += normalize(screenNormal) * ((2.0 / viewportSize) * outlineThickness) * gl_Position.w;\n    }\n  }\n  else if (geomType == LINES) { // start 'LINES'\n    float overlay = 0.00003;\n    if (isOrthographic > 0){\n      gl_Position.z -= overlay;\n    } else {\n      gl_Position.z = mix(gl_Position.z, -gl_Position.z, overlay);\n    }\n  } // end 'LINES'\n  else if (geomType == POINTS) { // start 'POINTS'\n    float overlay = 0.00005;\n    if (isOrthographic > 0){\n      gl_Position.z -= overlay;\n    } else {\n      gl_Position.z = mix(gl_Position.z, -gl_Position.z, overlay);\n    }\n  }  // end 'POINTS'\n\n#ifdef ENABLE_TEXTURES\n  v_textureCoord  = texCoords;\n#endif\n\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "precision highp float;\nprecision highp int;\n#define GLSLIFY 1\nimport 'GLSLUtils.glsl'\nimport 'drawItemTexture.glsl' \nimport 'cutaways.glsl'\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\nimport 'GLSLBits.glsl'\n\n/* VS Outputs */\nvarying vec4 v_drawItemIds;\nvarying vec4 v_geomItemData;\nvarying vec3 v_viewPos;\nvarying vec3 v_viewNormal;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\nvarying vec3 v_worldPos;\n/* VS Outputs */\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\n// Now that we render multiple types of geometry from a single shader\n// we need to know what kind of geometry it is...\nuniform int geomType;\nimport 'geomType.glsl'\n\nuniform int isOrthographic;\n\n#if defined(DRAW_COLOR)\n\nuniform int renderMode;\nuniform int occluded;\nuniform float outlineThickness;\nuniform vec4 hiddenLineColor;\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\nuniform float exposure;\n#endif\n\nuniform mat4 cameraMatrix;\n\n#ifndef ENABLE_MULTI_DRAW\n\nuniform color BaseColor;\nuniform float AmbientOcclusion;\nuniform float Roughness;\nuniform float Metallic;\nuniform float Reflectance;\nuniform float EmissiveStrength;\nuniform float Opacity;\n\nuniform color EdgeColor;\nuniform color PointColor;\n\n#ifdef ENABLE_TEXTURES\nuniform sampler2D BaseColorTex;\nuniform int BaseColorTexType;\n\nuniform sampler2D AmbientOcclusionTex;\nuniform int AmbientOcclusionTexType;\n\n#ifdef ENABLE_PBR\nuniform sampler2D RoughnessTex;\nuniform int RoughnessTexType;\n\nuniform sampler2D MetallicTex;\nuniform int MetallicTexType;\n\nuniform sampler2D ReflectanceTex;\nuniform int ReflectanceTexType;\n\nuniform sampler2D NormalTex;\nuniform int NormalTexType;\n#endif // ENABLE_PBR\n\nuniform sampler2D EmissiveStrengthTex;\nuniform int EmissiveStrengthTexType;\n\n#endif // ENABLE_TEXTURES\n#endif // ENABLE_MULTI_DRAW\n\nimport 'PBRSurfaceRadiance.glsl'\n\n#ifdef ENABLE_PBR\nmat3 cotangentFrame( in vec3 normal, in vec3 pos, in vec2 texCoord ) {\n  // https://stackoverflow.com/questions/5255806/how-to-calculate-tangent-and-binormal\n  vec3 n = normal;\n  // derivations of the fragment position\n  vec3 pos_dx = dFdx( pos );\n  vec3 pos_dy = dFdy( pos );\n  // derivations of the texture coordinate\n  vec2 texC_dx = dFdx( texCoord );\n  vec2 texC_dy = dFdy( texCoord );\n  // tangent vector and binormal vector\n  vec3 t = -(texC_dy.y * pos_dx - texC_dx.y * pos_dy);\n  vec3 b = -(texC_dx.x * pos_dy - texC_dy.x * pos_dx);\n\n  t = t - n * dot( t, n ); // orthonormalization ot the tangent vectors\n  b = b - n * dot( b, n ); // orthonormalization of the binormal vectors to the normal vector\n  b = b - t * dot( b, t ); // orthonormalization of the binormal vectors to the tangent vector\n  mat3 tbn = mat3( normalize(t), normalize(b), n );\n\n  return tbn;\n}\n#endif\n\nimport 'computeViewNormal.glsl'\n\n#ifdef DEBUG_GEOM_ID\nimport 'debugColors.glsl'\n#endif\n\n// end DRAW_COLOR\n#elif defined(DRAW_GEOMDATA)\n\nimport 'surfaceGeomData.glsl'\n\n#elif defined(DRAW_HIGHLIGHT)\nimport 'surfaceHighlight.glsl'\n#endif // DRAW_HIGHLIGHT\n\nvoid main(void) {\n  #ifndef ENABLE_ES3\n    vec4 fragColor;\n  #endif\n  \n  int geomItemId = int(v_drawItemIds.x + 0.5);\n  int elemId = int(v_drawItemIds.y + 0.5);\n  int perFaceMaterialId = int(v_drawItemIds.z);\n  int flags = int(v_geomItemData.x + 0.5);\n  float treeItemOpacity = v_geomItemData.y;\n\n  if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) {\n    vec4 cutAwayData   = getCutaway(geomItemId);\n    vec3 planeNormal = cutAwayData.xyz;\n    float planeDist = cutAwayData.w;\n    if (cutaway(v_worldPos, planeNormal, planeDist)) {\n        discard;\n        return;\n    }\n  }\n  vec2 materialCoords = v_geomItemData.zw;\n  if (v_drawItemIds.z > 0.5) {\n    materialCoords.x = v_drawItemIds.z;\n  }\n  \n#if defined(DRAW_COLOR)\n\n  if (geomType == TRIANGLES) { // start 'TRIANGLES'\n\n  // Cutaways\n    if (testFlag(flags, GEOMITEM_FLAG_CUTAWAY)) {\n      if (!gl_FrontFacing) {\n#ifdef ENABLE_ES3\n        fragColor = cutColor;\n#else\n        gl_FragColor = cutColor;\n#endif\n        return;\n      }\n    }\n\n    //////////////////////////////////////////////\n    // Normals\n    vec3 viewNormal;\n    if (length(v_viewNormal) < 0.1) {\n      viewNormal = computeViewNormal(v_viewPos);\n    } else {\n      viewNormal = normalize(v_viewNormal);\n    }\n    vec3 normal = normalize(mat3(cameraMatrix) * viewNormal);\n    \n    vec3 viewVector;\n    if (isOrthographic == 0)\n      viewVector = normalize(mat3(cameraMatrix) * normalize(v_viewPos));\n    else \n      viewVector = vec3(cameraMatrix[2][0], cameraMatrix[2][1], cameraMatrix[2][2]);\n      \n    if (dot(normal, viewVector) < 0.0) {\n      normal = -normal;\n      // Note: this line can be used to debug inverted meshes.\n      //material.baseColor = vec3(1.0, 0.0, 0.0);\n    }\n\n    //////////////////////////////////////////////\n    // Material\n\n    MaterialParams material;\n\n#ifdef ENABLE_MULTI_DRAW\n    vec4 matValue0      = getMaterialValue(materialCoords, 0);\n    vec4 matValue1      = getMaterialValue(materialCoords, 1);\n    vec4 matValue2      = getMaterialValue(materialCoords, 2);\n\n    material.baseColor     = matValue0.rgb;\n    material.ambientOcclusion      = matValue1.r;\n    material.metallic      = matValue1.g;\n    material.roughness     = matValue1.b;\n    material.reflectance   = matValue1.a;\n\n    material.emission      = matValue2.r;\n    material.opacity       = matValue2.g * matValue0.a;\n    if (material.opacity < 0.001) discard;\n\n#else // ENABLE_MULTI_DRAW\n\n#ifndef ENABLE_TEXTURES\n    material.baseColor     = BaseColor.rgb;\n    material.emission      = EmissiveStrength;\n\n#ifdef ENABLE_PBR\n    material.roughness     = Roughness;\n    material.metallic      = Metallic;\n    material.reflectance   = Reflectance;\n#endif\n\n#else // ENABLE_TEXTURES\n    // Planar YZ projection for texturing, repeating every meter.\n    // vec2 texCoord       = v_worldPos.xz * 0.2;\n    vec2 texCoord          = v_textureCoord;\n\n    vec4 baseColor         = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, texCoord);\n\n    material.ambientOcclusion = getLuminanceParamValue(AmbientOcclusion, AmbientOcclusionTex, AmbientOcclusionTexType, texCoord);\n    material.baseColor     = baseColor.rgb;\n    \n    material.opacity       = Opacity * baseColor.a;\n    if (material.opacity < 0.001) discard;\n\n#ifdef ENABLE_PBR\n\n    material.metallic      = getLuminanceParamValue(Metallic, MetallicTex, MetallicTexType, texCoord);\n    material.roughness     = getLuminanceParamValue(Roughness, RoughnessTex, RoughnessTexType, texCoord);\n\n    // TODO: Communicate that this tex contains the roughness as well.\n    if (MetallicTexType != 0) {\n      vec4 metallicRoughness = vec4(Metallic, Roughness, 0.0, 1.0);\n      metallicRoughness     = texture2D(MetallicTex, texCoord);\n      material.roughness     = metallicRoughness.g;\n      material.metallic     = metallicRoughness.b;\n    }\n\n    material.reflectance   = getLuminanceParamValue(Reflectance, ReflectanceTex, ReflectanceTexType, texCoord);\n#endif // ENABLE_PBR\n    material.emission         = getLuminanceParamValue(EmissiveStrength, EmissiveStrengthTex, EmissiveStrengthTexType, texCoord);\n#endif // ENABLE_TEXTURES\n\n#ifdef ENABLE_TEXTURES\n#ifdef ENABLE_PBR\n    if (NormalTexType != 0) {\n      mat3 tbn = cotangentFrame(normal, viewVector, texCoord);\n      normal = normalize(tbn * (texture2D(NormalTex, texCoord).rgb * 2.0 - 1.0));\n    }\n#endif // ENABLE_PBR\n#endif // ENABLE_TEXTURES\n#endif // ENABLE_MULTI_DRAW\n\n    if (outlineThickness > 0.00001) {\n#ifdef ENABLE_MULTI_DRAW\n      vec4 edgeColor      = getMaterialValue(materialCoords, 3);\n      vec4 matValue2      = getMaterialValue(materialCoords, 2);\n      float opacity       = matValue2.g;\n#else \n      vec4 edgeColor      = EdgeColor;\n      float opacity        = Opacity;\n#endif // ENABLE_MULTI_DRAW\n      edgeColor.a = edgeColor.a * opacity * treeItemOpacity;\n      if (edgeColor.a < 0.001) discard;\n      fragColor = edgeColor;\n    } else {\n      if (renderMode == 1) { // Flat\n        fragColor = vec4(material.baseColor, material.opacity);\n      } else if (renderMode == 2) { // Shaded\n        // simple irradiance. \n        float ndotv = dot(normal, viewVector);\n        fragColor = vec4((ndotv * material.baseColor) + (material.emission * material.baseColor), material.opacity);\n      } else if (renderMode == 3) { // PBR\n        fragColor = pbrSurfaceRadiance(material, normal, viewVector);\n      }\n      \n      // Note: the 'treeItemOpacity' is not an input to the PBR lighting, \n      // as we want to also blend off the specular reflections to make an object\n      // fade away to nothing. (not become a transparent glass object).\n      fragColor.a *= treeItemOpacity;\n\n      // Debugging code to help understand what might be happening in the shader.\n      // fragColor = vec4(texture2D(NormalTex, texCoord).rgb, 1.0);\n      // fragColor = metallicRoughness;\n      // fragColor = vec4(material.baseColor, 1.0);;\n      // fragColor = vec4(vec3(material.metallic), 1.0);;\n      // fragColor = vec4(vec3(material.roughness), 1.0);;\n      // fragColor = vec4(vec3(material.ambientOcclusion), 1.0);\n    }\n\n  } // end 'TRIANGLES'\n  else if (geomType == LINES) { // start 'LINES'\n    if (occluded == 1) {\n#ifdef ENABLE_MULTI_DRAW\n      vec4 matValue2      = getMaterialValue(materialCoords, 2);\n      float opacity       = matValue2.g;\n#else \n      float opacity        = Opacity;\n#endif // ENABLE_MULTI_DRAW\n      fragColor = hiddenLineColor;\n      fragColor.a = hiddenLineColor.a * opacity * treeItemOpacity;\n      if (fragColor.a < 0.001) discard;\n    } else {\n#ifdef ENABLE_MULTI_DRAW\n      vec4 edgeColor      = getMaterialValue(materialCoords, 3);\n      vec4 matValue2      = getMaterialValue(materialCoords, 2);\n      float opacity       = matValue2.g;\n#else \n      vec4 edgeColor      = EdgeColor;\n      float opacity        = Opacity;\n#endif // ENABLE_MULTI_DRAW\n      edgeColor.a = edgeColor.a * opacity * treeItemOpacity;\n      if (edgeColor.a < 0.001) discard;\n      fragColor = edgeColor;\n    }\n  } // end 'LINES'\n  else if (geomType == POINTS) { // start 'POINTS'\n#ifdef ENABLE_MULTI_DRAW\n    vec4 pointColor     = getMaterialValue(materialCoords, 4);\n    vec4 matValue2      = getMaterialValue(materialCoords, 2);\n    float opacity       = matValue2.g;\n#else \n    vec4 pointColor      = PointColor;\n    float opacity        = Opacity;\n#endif // ENABLE_MULTI_DRAW\n    pointColor.a = pointColor.a * opacity * treeItemOpacity;\n    if (pointColor.a < 0.001) discard;\n    fragColor = pointColor;\n  }  // end 'POINTS'\n  \n#ifdef DEBUG_GEOM_ID\n  // ///////////////////////\n  // Debug Draw ID (this correlates to GeomID within a GLGeomSet)\n  float geomId = v_geomItemData.w;\n  fragColor.rgb = getDebugColor(geomId);\n  // ///////////////////////\n#endif\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n// end DRAW_COLOR\n#elif defined(DRAW_GEOMDATA)\n  // Cutaways\n  if (testFlag(flags, GEOMITEM_INVISIBLE_IN_GEOMDATA)) {\n    discard;\n    return;\n  }\n  if (occlusionCulling != 0) {\n    // Transparent geoms do not render to the occlusion buffer\n    if (testFlag(flags, GEOMITEM_TRANSPARENT)) {\n      discard;\n      return;\n    }\n  }\n\n  // We can make geoms invisible to hide them. \n  // Avoid drawing GeomData for geoms that are completely transparent.\n  if (geomType == TRIANGLES) { // start 'TRIANGLES'\n    vec4 matValue0      = getMaterialValue(materialCoords, 0);\n    vec4 matValue2      = getMaterialValue(materialCoords, 2);\n    float opacity          = matValue2.g * matValue0.a * treeItemOpacity;\n    if (opacity < 0.001) {\n      discard;\n      return;\n    }\n  } // end 'TRIANGLES'\n  else if (geomType == LINES) { // start 'LINES'\n#ifdef ENABLE_MULTI_DRAW\n    vec4 edgeColor      = getMaterialValue(materialCoords, 3);\n#else \n    vec4 edgeColor      = EdgeColor;\n#endif // ENABLE_MULTI_DRAW\n    float opacity          = edgeColor.a * treeItemOpacity;\n    if (opacity < 0.001) {\n      discard;\n      return;\n    }\n  } // end 'LINES'\n  else if (geomType == POINTS) { // start 'POINTS'\n#ifdef ENABLE_MULTI_DRAW\n    vec4 pointColor      = getMaterialValue(materialCoords, 4);\n#else \n    vec4 pointColor      = PointColor;\n#endif // ENABLE_MULTI_DRAW\n    float opacity          = pointColor.a * treeItemOpacity;\n    if (opacity < 0.001) {\n      discard;\n      return;\n    }\n  }  // end 'POINTS'\n\n  \n  fragColor = setFragColor_geomData(v_viewPos, floatGeomBuffer, passId, v_drawItemIds.x, v_drawItemIds.y, isOrthographic);\n   \n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = getHighlightColor(geomItemId);\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n\n}");
    }
    bind(A3, g3) {
      if (super.bind(A3, g3), A3 instanceof jC) {
        const g4 = A3, I3 = this.__gl;
        g4.envMap && g4.envMap.bind(g4);
        const {exposure: C3, cutColor: i3, renderMode: e3} = g4.unifs;
        C3 && I3.uniform1f(C3.location, g4.exposure), g4.renderMode && e3 && (g4.renderMode == "flat" || g4.renderMode == "flat-noedges" ? I3.uniform1i(e3.location, 1) : g4.renderMode == "shaded" || g4.renderMode == "shaded-noedges" ? I3.uniform1i(e3.location, 2) : g4.renderMode != "pbr" && g4.renderMode != "pbr-noedges" || I3.uniform1i(e3.location, 3)), i3 && I3.uniform4f(i3.location, 0.3, 0, 0, 1);
      }
      return true;
    }
    static getPackedMaterialData(A3) {
      const g3 = new Float32Array(20), I3 = A3.getParameter("BaseColor");
      let C3;
      C3 = I3 instanceof Qg && I3.colorSpace == pA.Gamma ? I3.value.toLinear() : I3.value, g3[0] = C3.r, g3[1] = C3.g, g3[2] = C3.b, g3[3] = C3.a, g3[4] = A3.getParameter("AmbientOcclusion").value, g3[5] = A3.getParameter("Metallic").value, g3[6] = A3.getParameter("Roughness").value, g3[7] = A3.getParameter("Reflectance").value, g3[8] = A3.getParameter("EmissiveStrength").value, g3[9] = A3.getParameter("Opacity").value;
      const i3 = A3.getParameter("EdgeColor").value;
      g3[12] = i3.r, g3[13] = i3.g, g3[14] = i3.b, g3[15] = i3.a;
      const e3 = A3.getParameter("PointColor").value;
      return g3[16] = e3.r, g3[17] = e3.g, g3[18] = e3.b, g3[19] = e3.a, g3;
    }
    static getMaterialTemplate() {
      return pe;
    }
  };
  var pe = new DI("StandardSurfaceShader_template");
  e.register("StandardSurfaceShader", Ke), e.register("TransparentSurfaceShader", Ke);
  var Ne = class extends DC {
    constructor(A3) {
      super(A3, "ScreenSpaceShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nattribute vec3 positions;\n#ifdef ENABLE_TEXTURES\nattribute vec2 texCoords;\n#endif\n\nimport 'GLSLUtils.glsl'\nimport 'geomItemId.glsl'\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\n/* VS Outputs */\nvarying float v_geomItemId;\nvarying vec4 v_geomItemData;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n\nvoid main(void) {\n  int geomItemId = getGeomItemId();\n  v_geomItemId = float(geomItemId);\n  v_geomItemData  = getInstanceData(geomItemId);\n\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n\n  gl_Position = (modelMatrix * vec4(positions, 1.0));\n\n  v_textureCoord = texCoords;\n  v_textureCoord.y = 1.0 - v_textureCoord.y;// Flip y\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\n#ifdef ENABLE_MULTI_DRAW\nimport 'drawItemTexture.glsl'\n#endif // ENABLE_MULTI_DRAW\n\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\n\n#if defined(DRAW_COLOR)\n\n  #ifndef ENABLE_MULTI_DRAW\n\n    uniform color BaseColor;\n\n    #ifdef ENABLE_TEXTURES\n      uniform sampler2D BaseColorTex;\n      uniform int BaseColorTexType;\n    #endif\n\n  #endif // ENABLE_MULTI_DRAW\n#endif // DRAW_COLOR\n\n/* VS Outputs */\nvarying float v_geomItemId;\nvarying vec4 v_geomItemData;\n#ifdef ENABLE_TEXTURES\nvarying vec2 v_textureCoord;\n#endif\n\n#if defined(DRAW_GEOMDATA)\n  uniform int isOrthographic;\n  import 'surfaceGeomData.glsl'\n#elif defined(DRAW_HIGHLIGHT)\n  import 'surfaceHighlight.glsl'\n#endif // DRAW_HIGHLIGHT\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n  \n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  //////////////////////////////////////////////\n  // Color\n#if defined(DRAW_COLOR)\n\n  #ifdef ENABLE_MULTI_DRAW\n\n    vec2 materialCoords = v_geomItemData.zw;\n    vec4 baseColor = getMaterialValue(materialCoords, 0);\n\n  #else // ENABLE_MULTI_DRAW\n\n  #ifndef ENABLE_TEXTURES\n    vec4 baseColor = BaseColor;\n  #else\n    vec4 baseColor      = getColorParamValue(BaseColor, BaseColorTex, BaseColorTexType, v_textureCoord);\n  #endif\n\n  #endif // ENABLE_MULTI_DRAW\n\n    fragColor = baseColor;\n\n  #ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb);\n  #endif\n\n  //////////////////////////////////////////////\n  // GeomData\n#elif defined(DRAW_GEOMDATA)\n  fragColor = setFragColor_geomData(vec3(0,0,0), floatGeomBuffer, passId, v_geomItemId, 0.0, isOrthographic);\n#elif defined(DRAW_HIGHLIGHT)\n  fragColor = setFragColor_highlight(v_geomItemId);\n#endif // DRAW_HIGHLIGHT\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n");
    }
    static isOverlay() {
      return true;
    }
    static getPackedMaterialData(A3) {
      const g3 = new Float32Array(8), I3 = A3.getParameter("BaseColor").value;
      return g3[0] = I3.r, g3[1] = I3.g, g3[2] = I3.b, g3[3] = I3.a, g3;
    }
    static getMaterialTemplate() {
      return Je;
    }
  };
  var Je = new NI("ScreenSpaceShader_template");
  e.register("ScreenSpaceShader", Ne);
  var De = class extends bC {
    constructor() {
      super(), this.materials = {}, this.listenerIDs = {};
    }
    init(A3, g3) {
      super.init(A3, g3);
    }
    itemAddedToScene(A3, g3) {
      if (A3 instanceof kI) {
        const g4 = A3;
        return !!this.filterGeomItem(g4) && (this.addGeomItem(g4), true);
      }
      return false;
    }
    itemRemovedFromScene(A3, g3) {
      return A3 instanceof kI && (this.removeGeomItem(A3), true);
    }
    filterGeomItem(A3) {
      return true;
    }
    addGeomItem(A3) {
      const g3 = {};
      this.listenerIDs[A3.getId()] = g3;
      const I3 = () => {
        this.removeGeomItem(A3), this.renderer.assignTreeItemToGLPass(A3);
      };
      g3["materialParam.valueChanged"] = A3.materialParam.on("valueChanged", I3), g3["geomParam.valueChanged"] = A3.geomParam.on("valueChanged", I3);
      const C3 = (A4) => {
        A4.isOpaqueStateChanged && I3();
      }, i3 = A3.materialParam.value;
      this.materials[A3.getId()] = i3, g3["geomItem.opacityChanged"] = A3.on("opacityChanged", C3), g3["material.opacityChanged"] = i3.on("opacityChanged", C3);
    }
    removeGeomItem(A3) {
      const g3 = A3.getId(), I3 = this.listenerIDs[g3];
      delete this.listenerIDs[g3], A3.materialParam.removeListenerById("valueChanged", I3["materialParam.valueChanged"]), A3.geomParam.removeListenerById("valueChanged", I3["geomParam.valueChanged"]);
      const C3 = this.materials[A3.getId()];
      delete this.materials[g3], A3.removeListenerById("opacityChanged", I3["geomItem.opacityChanged"]), C3.removeListenerById("opacityChanged", I3["material.opacityChanged"]);
    }
    constructShaders(A3) {
      let g3, I3;
      const C3 = this.__renderer.getOrCreateShader(A3);
      return g3 = C3.getGeomDataShaderName() ? this.__renderer.getOrCreateShader(C3.getGeomDataShaderName()) : C3, I3 = C3.getSelectedShaderName() ? this.__renderer.getOrCreateShader(C3.getSelectedShaderName()) : C3, {glShader: C3, glgeomdatashader: g3, glselectedshader: I3};
    }
    getGeomItemAndDist(A3) {
      let g3, I3, C3 = -1;
      A3 instanceof Float32Array ? (g3 = Math.round(A3[1]), C3 = Math.round(A3[2]), I3 = A3[3]) : (g3 = A3[0] + ((63 & A3[1]) << 8), I3 = r.decode16BitFloatFrom2xUInt8(A3.slice(2, 3)));
      const i3 = this.renderer.glGeomItemLibrary.getGeomItem(g3);
      if (i3)
        return {geomItem: i3, componentId: C3, dist: I3};
    }
  };
  var fe = class extends DC {
    constructor(A3) {
      super(A3, "FattenLinesShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\nattribute vec3 positions;  //(location = 0)\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  v_texCoord = positions.xy+0.5;\n  gl_Position = vec4(positions.xy*2.0, -1.0, 1.0);\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nuniform vec2 screenSize;\n\nuniform float growth;\n\nvarying vec2 v_texCoord;\n\nbool sampleNeiPixel(vec2 fragCoord, inout vec4 res) {\n  res = texture2D(colorTexture, fragCoord/screenSize);\n  if (res.a > 0.0) {\n    return true;\n  }\n  return false;\n}\n\nvec4 samplePixels(vec2 fragCoord) {\n  vec4 res = vec4(0.0);\n  \n  if (sampleNeiPixel(fragCoord, res)) return res; // M\n  \n  // Search surrounding pixels for geoms\n  if (sampleNeiPixel(fragCoord+vec2( 1, 0), res)) return res; // E\n  if (sampleNeiPixel(fragCoord+vec2(-1, 0), res)) return res; // W\n  if (sampleNeiPixel(fragCoord+vec2( 0, 1), res)) return res; // N\n  if (sampleNeiPixel(fragCoord+vec2( 0,-1), res)) return res; // S\n  if (sampleNeiPixel(fragCoord+vec2( 1, 1), res)) return res; // NW\n  if (sampleNeiPixel(fragCoord+vec2(-1, 1), res)) return res; // NE\n  if (sampleNeiPixel(fragCoord+vec2( 1,-1), res)) return res; // SW\n  if (sampleNeiPixel(fragCoord+vec2(-1,-1), res)) return res; // SE\n  \n  return res;\n}\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  fragColor = samplePixels(gl_FragCoord.xy);\n  if (fragColor.a < 0.0001) {\n    discard; \n  }\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n");
    }
  };
  var Me;
  var Le;
  !function(A3) {
    A3[A3.TRIANGLES = 0] = "TRIANGLES", A3[A3.LINES = 1] = "LINES", A3[A3.POINTS = 2] = "POINTS";
  }(Me || (Me = {}));
  var Ue = class extends V {
    constructor(A3) {
      super(), this.glGeomItems = [], this.glGeomIdsMapping = {}, this.glgeomItemEventHandlers = [], this.freeIndices = [], this.dirtyGeomItems = new Set(), this.drawIdsBufferDirty = true, this.drawIdsArraysAllocators = {}, this.drawIdsArrays = {}, this.drawIdsTextures = {}, this.drawElementCounts = {}, this.drawElementOffsets = {}, this.drawOrderToIndex = [], this.indexToDrawIndex = [], this.highlightedItems = {}, this.highlightedIdsArraysAllocators = {}, this.highlightElementCounts = {}, this.highlightElementOffsets = {}, this.highlightedIdsArray = {}, this.highlightedIdsTextures = {}, this.dirtyHighlightedGeomItems = new Set(), this.highlightedIdsBufferDirty = true, this.linesGeomDataBuffer = null, this.fattenLinesShader = null, this.quad = null, this.fbo = null, this.renderer = A3, this.gl = A3.gl, this.renderer.glGeomLibrary.on("geomDataChanged", (A4) => {
        const g3 = this.glGeomIdsMapping[A4.index];
        g3 != null && g3.forEach((A5) => {
          this.dirtyGeomItems.add(A5), this.drawIdsBufferDirty || (this.drawIdsBufferDirty = true, this.emit("updated"));
        });
      });
    }
    addGLGeomItem(A3) {
      const g3 = this.freeIndices.length > 0 ? this.freeIndices.pop() : this.glGeomItems.length;
      this.glGeomIdsMapping[A3.geomId] ? this.glGeomIdsMapping[A3.geomId].push(g3) : this.glGeomIdsMapping[A3.geomId] = [g3];
      const I3 = {};
      A3.visible && (this.indexToDrawIndex[g3] = this.drawOrderToIndex.length, this.drawOrderToIndex.push(g3), this.dirtyGeomItems.add(g3)), I3.visibilityChanged = (I4) => {
        if (I4.visible) {
          const I5 = this.renderer.glGeomLibrary.getGeomBuffers(A3.geomId);
          for (let C4 in I5.counts) {
            if (I5.counts[C4] == 0)
              continue;
            const i3 = this.drawIdsArraysAllocators[C4];
            if (i3) {
              const e3 = i3.getAllocation(g3);
              if (e3) {
                const g4 = e3.start;
                if (A3.shattered)
                  for (let A4 = 0; A4 < e3.size; A4++)
                    this.drawElementCounts[C4][g4 + A4] = I5.subGeomCounts[C4][A4];
                else {
                  const A4 = I5.materialSubGeoms[C4];
                  for (let I6 = 0; I6 < e3.size; I6++) {
                    const i4 = A4[I6];
                    this.drawElementCounts[C4][g4 + I6] = i4.count;
                  }
                }
              }
            }
          }
        } else
          for (let A4 in this.drawIdsArraysAllocators) {
            const I5 = this.drawIdsArraysAllocators[A4];
            if (I5) {
              const C4 = I5.getAllocation(g3);
              if (C4) {
                const g4 = C4.start;
                for (let I6 = 0; I6 < C4.size; I6++)
                  this.drawElementCounts[A4][g4 + I6] = 0;
              }
            }
          }
        this.emit("updated");
      }, A3.on("visibilityChanged", I3.visibilityChanged);
      const C3 = (A4) => {
        const I4 = A4.indexOf(":");
        let C4 = [];
        var i3, e3;
        (I4 != -1 && (C4 = A4.substring(I4 + 1).split(",").map((A5) => Number.parseInt(A5))), !this.highlightedItems[g3] || (i3 = this.highlightedItems[g3], e3 = C4, i3.length != e3.length || i3.some((A5, g4) => A5 != e3[g4]))) && (this.highlightedItems[g3] = C4, this.highlightedIdsBufferDirty = true, this.emit("updated"));
      };
      A3.geomItem.isHighlighted() && C3(A3.geomItem.getHighlightName()), I3.highlightChanged = (A4) => {
        A4 && A4.name ? C3(A4.name) : (delete this.highlightedItems[g3], this.highlightedIdsBufferDirty = true, this.emit("updated"));
      }, A3.geomItem.on("highlightChanged", I3.highlightChanged), I3.shatterStateChanged = (A4) => {
        this.dirtyGeomItems.add(g3), this.drawIdsBufferDirty = true, this.renderer.renderGeomDataFbos();
      }, A3.on("shatterStateChanged", I3.shatterStateChanged);
      A3.geomItem.geomParam.value.materials.forEach((A4) => {
        this.renderer.glMaterialLibrary.addMaterial(A4);
      });
      this.glGeomItems[g3] = A3, this.glgeomItemEventHandlers[g3] = I3, this.drawIdsBufferDirty = true, this.emit("updated");
    }
    removeGLGeomItem(A3) {
      const g3 = this.glGeomItems.indexOf(A3), I3 = this.glGeomIdsMapping[A3.geomId];
      I3.splice(I3.indexOf(g3), 1), I3.length == 0 && delete this.glGeomIdsMapping[A3.geomId];
      const C3 = this.glgeomItemEventHandlers[g3];
      A3.geomItem.off("highlightChanged", C3.highlightChanged), A3.off("visibilityChanged", C3.visibilityChanged), this.glGeomItems[g3] = null, this.glgeomItemEventHandlers[g3] = null, this.freeIndices.push(g3), this.dirtyGeomItems.has(g3) && this.dirtyGeomItems.delete(g3);
      for (let A4 in this.drawIdsArraysAllocators) {
        const I4 = this.drawIdsArraysAllocators[A4].getAllocation(g3);
        if (I4) {
          for (let g4 = 0; g4 < I4.size; g4++)
            this.drawElementOffsets[A4][I4.start + g4] = 0, this.drawElementCounts[A4][I4.start + g4] = 0;
          this.drawIdsArraysAllocators[A4].deallocate(g3);
        }
      }
      if (A3.isVisible()) {
        const A4 = this.drawOrderToIndex.indexOf(g3);
        this.drawOrderToIndex.splice(A4, 1), this.indexToDrawIndex[g3] = -1, this.drawIdsBufferDirty = true;
      }
      A3.geomItem.isHighlighted() && (delete this.highlightedItems[g3], this.highlightedIdsBufferDirty = true), this.emit("updated");
    }
    updateDrawIDsBuffer(A3) {
      this.dirtyGeomItems.forEach((A4) => {
        const g4 = this.glGeomItems[A4];
        if (g4) {
          const I4 = this.renderer.glGeomLibrary.getGeomBuffers(g4.geomId);
          let C4 = {};
          if (g4.shattered)
            for (let A5 in I4.subGeomCounts)
              C4[A5] = I4.subGeomCounts[A5].length;
          else
            for (let A5 in I4.materialSubGeoms)
              C4[A5] = I4.materialSubGeoms[A5].length;
          for (let g5 in C4) {
            const I5 = C4[g5];
            this.drawIdsArraysAllocators[g5] || (this.drawIdsArraysAllocators[g5] = new X());
            const i3 = this.drawIdsArraysAllocators[g5].getAllocation(A4);
            if (i3)
              for (let A5 = 0; A5 < i3.size; A5++)
                this.drawElementCounts[g5][i3.start + A5] = 0;
            this.drawIdsArraysAllocators[g5].allocate(A4, I5);
          }
        }
      });
      let g3 = false;
      for (let A4 in this.drawIdsArraysAllocators) {
        const I4 = this.drawIdsArraysAllocators[A4];
        (!this.drawElementCounts[A4] || I4.reservedSpace > this.drawElementCounts[A4].length - 1) && (this.drawElementCounts[A4] && I4.reservedSpace > this.drawElementCounts[A4].length - 1 && (g3 = true), this.drawIdsArrays[A4] = new Float32Array(4 * I4.reservedSpace), this.drawElementOffsets[A4] = new Int32Array(I4.reservedSpace + 1), this.drawElementCounts[A4] = new Int32Array(I4.reservedSpace + 1));
      }
      if (g3)
        for (let A4 = 0; A4 < this.drawOrderToIndex.length; A4++)
          this.dirtyGeomItems.add(A4);
      this.dirtyGeomItems.forEach((A4) => {
        const g4 = this.glGeomItems[A4];
        if (!g4)
          return;
        const I4 = this.renderer.glGeomLibrary.getGeomOffsetAndCount(g4.geomId), C4 = this.renderer.glGeomLibrary.getGeomBuffers(g4.geomId), i3 = g4.isVisible();
        if (g4.shattered) {
          let e3 = 0;
          const t3 = (t4, B3, o3) => {
            const s3 = this.drawIdsArraysAllocators[o3], a3 = this.drawIdsArrays[o3], l3 = this.drawElementOffsets[o3], n3 = this.drawElementCounts[o3], d3 = s3.getAllocation(A4);
            if (!d3)
              return;
            const h3 = C4.materials;
            for (let A5 = 0; A5 < t4.length; A5++) {
              const o4 = d3.start + A5;
              if (l3[o4] = I4[0] + 4 * t4[A5], n3[o4] = i3 ? B3[A5] : 0, a3[4 * o4 + 0] = g4.geomItemId, a3[4 * o4 + 1] = e3 + 1, h3.length > 0 && C4.subGeomMaterialIndices[A5] > 0) {
                const g5 = C4.subGeomMaterialIndices[A5] - 1, I5 = C4.materials[g5];
                this.renderer.glMaterialLibrary.addMaterial(I5);
                const i4 = this.renderer.glMaterialLibrary.getMaterialAllocation(I5);
                a3[4 * o4 + 2] = i4.start;
              } else
                a3[4 * o4 + 2] = 0;
              a3[4 * o4 + 3] = 0, e3++;
            }
          };
          t3(C4.subGeomOffsets.TRIANGLES, C4.subGeomCounts.TRIANGLES, "TRIANGLES"), t3(C4.subGeomOffsets.LINES, C4.subGeomCounts.LINES, "LINES"), t3(C4.subGeomOffsets.POINTS, C4.subGeomCounts.POINTS, "POINTS");
        } else {
          const e3 = (e4, t3) => {
            const B3 = this.drawIdsArraysAllocators[t3], o3 = this.drawIdsArrays[t3], s3 = this.drawElementOffsets[t3], a3 = this.drawElementCounts[t3], l3 = B3.getAllocation(A4);
            if (!l3)
              return;
            const n3 = C4.materials;
            for (let A5 = 0; A5 < e4.length; A5++) {
              const t4 = e4[A5], B4 = l3.start + A5;
              if (s3[B4] = I4[0] + 4 * t4.offset, a3[B4] = i3 ? t4.count : 0, o3[4 * B4 + 0] = g4.geomItemId, o3[4 * B4 + 1] = 0, n3.length > 0 && t4.materialId >= 0 && C4.materials[t4.materialId]) {
                const A6 = C4.materials[t4.materialId];
                this.renderer.glMaterialLibrary.addMaterial(A6);
                const g5 = this.renderer.glMaterialLibrary.getMaterialAllocation(A6);
                o3[4 * B4 + 2] = g5.start;
              } else
                o3[4 * B4 + 2] = 0;
              o3[4 * B4 + 3] = 0;
            }
          };
          for (let g5 in C4.materialSubGeoms) {
            if (!this.drawIdsArraysAllocators[g5].getAllocation(A4))
              continue;
            e3(C4.materialSubGeoms[g5], g5);
          }
        }
      });
      const I3 = this.renderer.gl;
      if (!I3.multiDrawElements)
        return;
      const C3 = (C4) => {
        const i3 = this.drawIdsArrays[C4];
        let e3 = this.drawIdsTextures[C4];
        const t3 = this.drawIdsArraysAllocators[C4].reservedSpace, B3 = A3.boundTextures++;
        I3.activeTexture(I3.TEXTURE0 + B3);
        const o3 = r.nextPow2(Math.ceil(Math.sqrt(t3)));
        if (e3) {
          if (e3.width < o3 || e3.height < o3) {
            e3.resize(o3, o3);
            for (let A4 = 0; A4 < this.drawOrderToIndex.length; A4++)
              this.dirtyGeomItems.add(A4);
            g3 = true;
          }
        } else
          e3 = new HC(this.gl, {format: "RGBA", type: "FLOAT", width: o3, height: o3, filter: "NEAREST", wrap: "CLAMP_TO_EDGE", mipMapped: false}), this.drawIdsTextures[C4] = e3, g3 = true;
        {
          const A4 = e3, t4 = e3.width;
          I3.bindTexture(I3.TEXTURE_2D, A4.glTex);
          const B4 = 0, o4 = 0, s3 = 1, a3 = A4.getFormat(), l3 = A4.getType();
          if (g3) {
            const A5 = this.drawIdsArraysAllocators[C4].allocatedSpace, g4 = Math.ceil((o4 + A5) / t4);
            let e4 = 0, n3 = A5, d3 = o4;
            for (let A6 = 0; A6 < g4; A6++) {
              let A7;
              d3 + n3 > t4 ? (A7 = t4 - d3, d3 = 0) : A7 = n3;
              const g5 = e4 % t4, C5 = Math.floor(e4 / t4), o5 = i3.subarray(4 * e4, 4 * (e4 + A7));
              if (o5.length != 4 * A7)
                throw new Error("Invalid drawIds subarray :" + o5.length + " width:" + A7);
              I3.texSubImage2D(I3.TEXTURE_2D, B4, g5, C5, A7, s3, a3, l3, o5), e4 += A7, n3 -= A7;
            }
          } else {
            const A5 = this.drawIdsArraysAllocators[C4];
            this.dirtyGeomItems.forEach((g4) => {
              const C5 = A5.getAllocation(g4);
              if (!C5)
                return;
              const e4 = C5.start, o5 = C5.size, n3 = e4 % t4, d3 = Math.ceil((n3 + o5) / t4);
              let h3 = 0, c3 = o5, r3 = n3;
              for (let A6 = 0; A6 < d3; A6++) {
                let A7;
                r3 + c3 > t4 ? (A7 = t4 - r3, r3 = 0) : A7 = c3;
                const g5 = (e4 + h3) % t4, C6 = Math.floor((e4 + h3) / t4), o6 = i3.subarray(4 * (e4 + h3), 4 * (e4 + h3 + A7));
                if (o6.length != 4 * A7)
                  throw new Error("Invalid drawIds subarray :" + o6.length + " width:" + A7);
                I3.texSubImage2D(I3.TEXTURE_2D, B4, g5, C6, A7, s3, a3, l3, o6), h3 += A7, c3 -= A7;
              }
            });
          }
        }
        I3.bindTexture(I3.TEXTURE_2D, null), A3.boundTextures--;
      };
      for (let A4 in this.drawIdsArrays)
        C3(A4);
      this.dirtyGeomItems = new Set(), this.drawIdsBufferDirty = false;
    }
    updateHighlightedIDsBuffer(A3) {
      if (this.highlightedIdsBufferDirty) {
        this.highlightedIdsArraysAllocators = {}, this.highlightedIdsArray = {}, this.highlightElementOffsets = {}, this.highlightElementCounts = {};
        for (let A5 in this.highlightedItems) {
          const g4 = Number.parseInt(A5), I4 = this.highlightedItems[A5], C3 = this.glGeomItems[g4], i3 = this.renderer.glGeomLibrary.getGeomBuffers(C3.geomId);
          let e3 = {TRIANGLES: 0, LINES: 0, POINTS: 0};
          if (I4.length > 0)
            I4.forEach((A6) => {
              if (A6 < i3.subGeomCounts.TRIANGLES.length)
                e3.TRIANGLES += 1;
              else {
                const g5 = A6 - i3.subGeomCounts.TRIANGLES.length;
                if (g5 < i3.subGeomCounts.LINES.length)
                  e3.LINES += 1;
                else {
                  g5 - i3.subGeomCounts.LINES.length < i3.subGeomCounts.POINTS.length && (e3.POINTS += 1);
                }
              }
            });
          else
            for (let A6 in i3.counts)
              i3.counts[A6] > 0 && (e3[A6] = 1);
          for (let A6 in e3) {
            const I5 = e3[A6];
            I5 != 0 && (this.highlightedIdsArraysAllocators[A6] || (this.highlightedIdsArraysAllocators[A6] = new X()), this.highlightedIdsArraysAllocators[A6].allocate(g4, I5));
          }
        }
        for (let A5 in this.highlightedIdsArraysAllocators) {
          const g4 = this.highlightedIdsArraysAllocators[A5];
          (!this.highlightElementCounts[A5] || g4.reservedSpace > this.highlightElementCounts[A5].length - 1) && (this.highlightedIdsArray[A5] = new Float32Array(4 * g4.reservedSpace), this.highlightElementOffsets[A5] = new Int32Array(g4.reservedSpace + 1), this.highlightElementCounts[A5] = new Int32Array(g4.reservedSpace + 1));
        }
        const A4 = 4;
        for (let g4 in this.highlightedItems) {
          const I4 = Number.parseInt(g4), C3 = this.highlightedItems[g4], i3 = this.glGeomItems[I4], e3 = this.renderer.glGeomLibrary.getGeomOffsetAndCount(i3.geomId), t3 = this.renderer.glGeomLibrary.getGeomBuffers(i3.geomId);
          if (C3.length != 0)
            C3.forEach((g5, C4) => {
              const B3 = (t4, B4, o3, s3) => {
                const a3 = this.highlightedIdsArraysAllocators[o3], l3 = this.highlightedIdsArray[o3], n3 = this.highlightElementOffsets[o3], d3 = this.highlightElementCounts[o3], h3 = a3.getAllocation(I4).start + C4;
                n3[h3] = e3[0] + t4[s3] * A4, d3[h3] = B4[s3], l3[4 * h3 + 0] = i3.geomItemId, l3[4 * h3 + 1] = g5 + 1, l3[4 * h3 + 2] = 0, l3[4 * h3 + 3] = 0;
              };
              if (g5 < t3.subGeomCounts.TRIANGLES.length)
                B3(t3.subGeomOffsets.TRIANGLES, t3.subGeomCounts.TRIANGLES, "TRIANGLES", g5);
              else {
                const A5 = g5 - t3.subGeomCounts.TRIANGLES.length;
                if (A5 < t3.subGeomCounts.LINES.length)
                  B3(t3.subGeomOffsets.LINES, t3.subGeomCounts.LINES, "LINES", A5);
                else {
                  t3.subGeomCounts.LINES.length;
                  t3.subGeomCounts.POINTS.length;
                }
              }
            });
          else
            for (let g5 in t3.offsets) {
              const C4 = t3.counts[g5];
              if (C4 == 0)
                continue;
              const B3 = t3.offsets[g5], o3 = this.highlightedIdsArraysAllocators[g5].getAllocation(I4).start;
              this.highlightElementOffsets[g5][o3] = e3[0] + B3 * A4, this.highlightElementCounts[g5][o3] = C4, this.highlightedIdsArray[g5][4 * o3 + 0] = i3.geomItemId;
            }
        }
        this.highlightedIdsBufferDirty = false;
      }
      const g3 = this.renderer.gl;
      if (!g3.multiDrawElements)
        return;
      const I3 = (I4) => {
        const C3 = this.highlightedIdsArray[I4];
        if (!C3 || C3.length == 0)
          return;
        let i3 = this.highlightedIdsTextures[I4];
        const e3 = this.highlightedIdsArraysAllocators[I4].reservedSpace, t3 = A3.boundTextures++;
        g3.activeTexture(g3.TEXTURE0 + t3);
        const B3 = r.nextPow2(Math.ceil(Math.sqrt(e3)));
        i3 ? (i3.width < B3 || i3.height < B3) && i3.resize(B3, B3) : (i3 = new HC(this.gl, {format: "RGBA", type: "FLOAT", width: B3, height: B3, filter: "NEAREST", wrap: "CLAMP_TO_EDGE", mipMapped: false}), this.highlightedIdsTextures[I4] = i3);
        {
          const A4 = i3, e4 = i3.width;
          g3.bindTexture(g3.TEXTURE_2D, A4.glTex);
          const t4 = 0, B4 = 0, o3 = 1, s3 = A4.getFormat(), a3 = A4.getType(), l3 = this.highlightedIdsArraysAllocators[I4].allocatedSpace, n3 = Math.ceil((B4 + l3) / e4);
          let d3 = 0, h3 = l3, c3 = B4;
          for (let A5 = 0; A5 < n3; A5++) {
            let A6;
            c3 + h3 > e4 ? (A6 = e4 - c3, c3 = 0) : A6 = h3;
            const I5 = d3 % e4, i4 = Math.floor(d3 / e4), B5 = C3.subarray(4 * d3, 4 * (d3 + A6));
            if (B5.length != 4 * A6)
              throw new Error("Invalid drawIds subarray :" + B5.length + " width:" + A6);
            g3.texSubImage2D(g3.TEXTURE_2D, t4, I5, i4, A6, o3, s3, a3, B5), d3 += A6, h3 -= A6;
          }
        }
        g3.bindTexture(g3.TEXTURE_2D, null), A3.boundTextures--;
      };
      for (let A4 in this.highlightedIdsArray)
        I3(A4);
    }
    draw(A3) {
      if (this.drawOrderToIndex.length == 0)
        return;
      this.drawIdsBufferDirty && this.updateDrawIDsBuffer(A3), A3.pushGLStack();
      const g3 = this.drawIdsArrays, I3 = this.drawElementCounts, C3 = this.drawElementOffsets, i3 = this.drawIdsTextures, e3 = this.drawIdsArraysAllocators, t3 = this.gl, B3 = A3.unifs;
      t3.depthFunc(t3.LEQUAL);
      const {drawIdsTexture: o3, geomType: s3, outlineThickness: a3, viewportSize: l3, occluded: n3, renderMode: d3} = A3.unifs, h3 = A3 instanceof jC && d3 ? A3.renderMode : null, c3 = h3 != "flat-noedges" && h3 != "shaded-noedges" && h3 != "pbr-noedges", r3 = A3 instanceof jC && a3 && l3 && A3.outlineMethod == "geometry" && A3.outlineThickness > 0 && c3, G3 = r3 && h3 == "wireframe", m3 = A3.hiddenLineColor && A3.hiddenLineColor.a > 0 && n3;
      if (G3 ? (t3.enable(t3.STENCIL_TEST), t3.clearStencil(0), t3.clear(t3.STENCIL_BUFFER_BIT), t3.stencilOpSeparate(t3.FRONT, t3.DECR_WRAP, t3.DECR_WRAP, t3.DECR_WRAP), t3.stencilOpSeparate(t3.BACK, t3.INCR_WRAP, t3.INCR_WRAP, t3.INCR_WRAP), t3.stencilFunc(t3.ALWAYS, 0, 255), t3.enable(t3.CULL_FACE), t3.cullFace(t3.BACK), t3.disable(t3.DEPTH_TEST), t3.depthMask(false), t3.colorMask(false, false, false, false)) : h3 == "hiddenline" ? t3.colorMask(false, false, false, false) : t3.disable(t3.CULL_FACE), g3.TRIANGLES && e3.TRIANGLES.allocatedSpace > 0)
        if (t3.multiDrawElements && i3.TRIANGLES.bindToUniform(A3, o3), s3 && t3.uniform1i(s3.location, Me.TRIANGLES), a3 && t3.uniform1f(a3.location, 0), A3.bindViewports(B3, () => {
          this.multiDrawMeshes(A3, g3.TRIANGLES, I3.TRIANGLES, C3.TRIANGLES, e3.TRIANGLES.allocatedSpace);
        }), r3) {
          if (t3.enable(t3.CULL_FACE), t3.cullFace(t3.FRONT), t3.uniform1f(a3.location, this.renderer.outlineThickness * window.devicePixelRatio), t3.uniform2f(l3.location, A3.region[2] - A3.region[0], A3.region[3] - A3.region[1]), h3 == "hiddenline" && t3.colorMask(true, true, true, false), G3 || (A3.glEnable(t3.BLEND), t3.blendEquation(t3.FUNC_ADD), t3.blendFunc(t3.SRC_ALPHA, t3.ONE_MINUS_SRC_ALPHA)), A3.bindViewports(B3, () => {
            this.multiDrawMeshes(A3, g3.TRIANGLES, I3.TRIANGLES, C3.TRIANGLES, e3.TRIANGLES.allocatedSpace);
          }), t3.disable(t3.CULL_FACE), t3.cullFace(t3.BACK), G3) {
            t3.enable(t3.DEPTH_TEST), t3.depthMask(true), t3.colorMask(true, true, true, true), t3.stencilFunc(t3.NOTEQUAL, 0, 255), t3.stencilOp(t3.KEEP, t3.KEEP, t3.KEEP), A3.glEnable(t3.BLEND), t3.blendEquation(t3.FUNC_ADD), t3.blendFunc(t3.SRC_ALPHA, t3.ONE_MINUS_SRC_ALPHA);
            const g4 = A3.glShader, I4 = A3.shaderkey, C4 = this.renderer.screenQuad;
            C4.bindShader(A3), C4.draw(A3, this.renderer.outlineColor), g4.bind(A3, I4), this.renderer.glGeomItemLibrary.bind(A3), this.renderer.glGeomLibrary.bind(A3), this.renderer.glMaterialLibrary.bind(A3), t3.disable(t3.STENCIL_TEST);
          }
        } else
          A3.glEnable(t3.BLEND), t3.blendEquation(t3.FUNC_ADD), t3.blendFunc(t3.SRC_ALPHA, t3.ONE_MINUS_SRC_ALPHA);
      if (c3 && g3.LINES && e3.LINES.allocatedSpace > 0 && (t3.multiDrawElements && i3.LINES.bindToUniform(A3, o3), s3 && t3.uniform1i(s3.location, Me.LINES), A3.bindViewports(B3, () => {
        this.multiDrawLines(A3, g3.LINES, I3.LINES, C3.LINES, e3.LINES.allocatedSpace);
      }), m3)) {
        const {hiddenLineColor: i4} = A3.unifs;
        t3.uniform1i(n3.location, 1), t3.uniform4fv(i4.location, A3.hiddenLineColor.asArray()), t3.depthFunc(t3.GREATER), t3.depthMask(false), A3.bindViewports(B3, () => {
          this.multiDrawLines(A3, g3.LINES, I3.LINES, C3.LINES, e3.LINES.allocatedSpace);
        }), t3.depthFunc(t3.LEQUAL), t3.depthMask(true), t3.uniform1i(n3.location, 0);
      }
      if (g3.POINTS && e3.POINTS.allocatedSpace > 0 && (t3.multiDrawElements && i3.POINTS.bindToUniform(A3, o3), s3 && t3.uniform1i(s3.location, Me.POINTS), A3.bindViewports(B3, () => {
        this.multiDrawPoints(A3, g3.POINTS, I3.POINTS, C3.POINTS, e3.POINTS.allocatedSpace);
      }), m3)) {
        const {hiddenLineColor: i4} = A3.unifs;
        t3.uniform1i(n3.location, 1), t3.uniform4fv(i4.location, A3.hiddenLineColor.asArray()), t3.depthFunc(t3.GREATER), t3.depthMask(false), A3.bindViewports(B3, () => {
          this.multiDrawPoints(A3, g3.POINTS, I3.POINTS, C3.POINTS, e3.POINTS.allocatedSpace);
        }), t3.depthFunc(t3.LEQUAL), t3.depthMask(true), t3.uniform1i(n3.location, 0);
      }
      s3 && t3.uniform1i(s3.location, 0), A3.popGLStack();
    }
    drawGeomData(A3) {
      this.drawIdsBufferDirty && this.updateDrawIDsBuffer(A3), A3.pushGLStack();
      const g3 = this.renderer.gl, I3 = A3.unifs, {drawIdsTexture: C3, geomType: i3} = I3, e3 = this.drawElementCounts, t3 = this.drawElementOffsets, B3 = this.drawIdsTextures, o3 = this.drawIdsArraysAllocators, s3 = this.drawIdsArrays;
      this.renderer.renderMode != "wireframe" && A3.bindViewports(I3, () => {
        s3.TRIANGLES && o3.TRIANGLES.allocatedSpace > 0 && (g3.multiDrawElements && B3.TRIANGLES.bindToUniform(A3, C3), i3 && g3.uniform1i(i3.location, Me.TRIANGLES), this.multiDrawMeshes(A3, s3.TRIANGLES, e3.TRIANGLES, t3.TRIANGLES, o3.TRIANGLES.allocatedSpace));
      });
      if (A3.geomDataFbo) {
        this.linesGeomDataBuffer || (this.linesGeomDataBuffer = new HC(g3, {type: this.renderer.floatGeomBuffer ? "FLOAT" : "UNSIGNED_BYTE", format: "RGBA", filter: "NEAREST", width: 1, height: 2}), this.fattenLinesShader = new fe(g3), this.quad = new Yi(g3, new AI(1, 1)));
        const I4 = A3.geomDataFbo, C4 = I4.width, i4 = I4.height;
        if (this.linesGeomDataBuffer.width != C4 || this.linesGeomDataBuffer.height != i4) {
          this.fbo && (g3.deleteFramebuffer(this.fbo), this.fbo = null), this.linesGeomDataBuffer.resize(C4, i4), this.fbo = g3.createFramebuffer();
          const A4 = this.linesGeomDataBuffer.glTex, e4 = I4.__depthTexture;
          g3.name == "webgl2" ? (g3.bindFramebuffer(g3.DRAW_FRAMEBUFFER, this.fbo), g3.framebufferTexture2D(g3.DRAW_FRAMEBUFFER, g3.COLOR_ATTACHMENT0, g3.TEXTURE_2D, A4, 0), g3.framebufferTexture2D(g3.DRAW_FRAMEBUFFER, g3.DEPTH_ATTACHMENT, g3.TEXTURE_2D, e4, 0)) : (g3.bindFramebuffer(g3.FRAMEBUFFER, this.fbo), g3.framebufferTexture2D(g3.FRAMEBUFFER, g3.COLOR_ATTACHMENT0, g3.TEXTURE_2D, A4, 0), g3.framebufferTexture2D(g3.FRAMEBUFFER, g3.DEPTH_ATTACHMENT, g3.TEXTURE_2D, e4, 0)), MC(g3, C4, i4);
        } else
          g3.name == "webgl2" ? g3.bindFramebuffer(g3.DRAW_FRAMEBUFFER, this.fbo) : g3.bindFramebuffer(g3.FRAMEBUFFER, this.fbo);
        g3.colorMask(true, true, true, true), g3.clearColor(0, 0, 0, 0), g3.clear(g3.COLOR_BUFFER_BIT);
      }
      if (A3.bindViewports(I3, () => {
        s3.LINES && o3.LINES.allocatedSpace > 0 && (g3.multiDrawElements && B3.LINES.bindToUniform(A3, C3), i3 && g3.uniform1i(i3.location, Me.LINES), this.multiDrawLines(A3, s3.LINES, e3.LINES, t3.LINES, o3.LINES.allocatedSpace)), s3.POINTS && o3.POINTS.allocatedSpace > 0 && (g3.multiDrawElements && B3.POINTS.bindToUniform(A3, C3), i3 && g3.uniform1i(i3.location, Me.POINTS), this.multiDrawPoints(A3, s3.POINTS, e3.POINTS, t3.POINTS, o3.POINTS.allocatedSpace));
      }), this.linesGeomDataBuffer && A3.geomDataFbo) {
        A3.boundRendertarget = null, A3.geomDataFbo.bindForWriting(A3);
        const I4 = A3.glShader, C4 = A3.shaderkey;
        this.fattenLinesShader.bind(A3), g3.disable(g3.DEPTH_TEST);
        const {colorTexture: i4, screenSize: e4} = A3.unifs;
        this.linesGeomDataBuffer.bindToUniform(A3, i4);
        const t4 = A3.geomDataFbo;
        g3.uniform2f(e4.location, t4.width, t4.height), this.quad.bindAndDraw(A3), g3.enable(g3.DEPTH_TEST), I4.bind(A3, C4), this.renderer.glGeomLibrary.bind(A3), this.renderer.glMaterialLibrary.bind(A3);
      }
      A3.popGLStack();
    }
    drawHighlighted(A3) {
      if (Object.keys(this.highlightedItems).length == 0)
        return;
      this.highlightedIdsBufferDirty && this.updateHighlightedIDsBuffer(A3), A3.pushGLStack();
      const g3 = this.highlightedIdsArray, I3 = this.highlightElementCounts, C3 = this.highlightElementOffsets, i3 = this.highlightedIdsTextures, e3 = this.highlightedIdsArraysAllocators, t3 = A3.unifs, B3 = this.renderer.gl;
      B3.depthFunc(B3.LEQUAL), A3.glDisable(B3.CULL_FACE);
      const {drawIdsTexture: o3, geomType: s3} = A3.unifs;
      A3.bindViewports(t3, () => {
        g3.TRIANGLES && e3.TRIANGLES.allocatedSpace > 0 && (B3.multiDrawElements && i3.TRIANGLES.bindToUniform(A3, o3), s3 && B3.uniform1i(s3.location, Me.TRIANGLES), this.multiDrawMeshes(A3, g3.TRIANGLES, I3.TRIANGLES, C3.TRIANGLES, e3.TRIANGLES.allocatedSpace)), g3.LINES && e3.LINES.allocatedSpace > 0 && (B3.multiDrawElements && i3.LINES.bindToUniform(A3, o3), s3 && B3.uniform1i(s3.location, Me.LINES), this.multiDrawLines(A3, g3.LINES, I3.LINES, C3.LINES, e3.LINES.allocatedSpace)), g3.POINTS && e3.POINTS.allocatedSpace > 0 && (B3.multiDrawElements && i3.POINTS.bindToUniform(A3, o3), s3 && B3.uniform1i(s3.location, Me.POINTS), this.multiDrawPoints(A3, g3.POINTS, I3.POINTS, C3.POINTS, e3.POINTS.allocatedSpace));
      }), s3 && B3.uniform1i(s3.location, 0), A3.popGLStack();
    }
    multiDrawMeshes(A3, g3, I3, C3, i3) {
      const e3 = this.gl;
      if (e3.multiDrawElements)
        e3.multiDrawElements(e3.TRIANGLES, I3, 0, e3.UNSIGNED_INT, C3, 0, i3);
      else {
        const {geomItemId: t3} = A3.unifs;
        for (let A4 = 0; A4 < i3; A4++)
          e3.uniform1i(t3.location, g3[4 * A4]), e3.drawElements(e3.TRIANGLES, I3[A4], e3.UNSIGNED_INT, C3[A4]);
      }
    }
    multiDrawLines(A3, g3, I3, C3, i3) {
      const e3 = this.gl;
      if (e3.multiDrawElements)
        e3.multiDrawElements(e3.LINES, I3, 0, e3.UNSIGNED_INT, C3, 0, i3);
      else {
        const {geomItemId: t3} = A3.unifs;
        for (let A4 = 0; A4 < i3; A4++)
          e3.uniform1i(t3.location, g3[4 * A4]), e3.drawElements(e3.LINES, I3[A4], e3.UNSIGNED_INT, C3[A4]);
      }
    }
    multiDrawPoints(A3, g3, I3, C3, i3) {
      const e3 = this.gl;
      if (e3.multiDrawElements)
        e3.multiDrawElements(e3.POINTS, I3, 0, e3.UNSIGNED_INT, C3, 0, i3);
      else {
        const {geomItemId: t3} = A3.unifs;
        for (let A4 = 0; A4 < i3; A4++)
          e3.uniform1i(t3.location, g3[4 * A4]), e3.drawElements(e3.POINTS, I3[A4], e3.UNSIGNED_INT, C3[A4]);
      }
    }
    sortItems(A3) {
      this.drawIdsBufferDirty;
    }
    destroy() {
      for (let A3 in this.drawIdsTextures)
        this.drawIdsTextures[A3].destroy();
      for (let A3 in this.highlightedIdsTextures)
        this.highlightedIdsTextures[A3].destroy();
      this.emit("destructing");
    }
  };
  var ve = class extends V {
    constructor(A3) {
      super(), this.glGeomItems = [], this.glGeomIdsMapping = {}, this.glgeomItemEventHandlers = [], this.freeIndices = [], this.viewPos = new o(), this.drawElementCounts = new Int32Array(0), this.drawElementOffsets = new Int32Array(0), this.highlightElementCounts = new Int32Array(0), this.highlightElementOffsets = new Int32Array(0), this.drawOrderToIndex = [], this.indexToDrawIndex = [], this.drawIdsArray = new Float32Array(0), this.drawIdsBufferDirty = true, this.drawIdsTexture = null, this.highlightedItems = [], this.highlightedIdsArray = null, this.highlightedIdsTexture = null, this.highlightedIdsBufferDirty = false, this.dirtyGeomIndices = new Set(), this.renderer = A3, this.gl = A3.gl, this.renderer.glGeomLibrary.on("geomDataChanged", (A4) => {
        this.dirtyGeomIndices.add(A4.index);
      });
    }
    addGLGeomItem(A3) {
      const g3 = this.freeIndices.length > 0 ? this.freeIndices.pop() : this.glGeomItems.length;
      this.glGeomIdsMapping[A3.geomId] ? this.glGeomIdsMapping[A3.geomId].push(g3) : this.glGeomIdsMapping[A3.geomId] = [g3], this.indexToDrawIndex[g3] = this.drawOrderToIndex.length, this.drawOrderToIndex.push(g3);
      const I3 = {};
      I3.visibilityChanged = (I4) => {
        const C3 = this.indexToDrawIndex[g3];
        if (I4.visible) {
          const g4 = this.renderer.glGeomLibrary.getGeomOffsetAndCount(A3.geomId);
          this.drawElementCounts[C3] = g4[1];
        } else
          this.drawElementCounts[C3] = 0;
        this.emit("updated");
      }, A3.on("visibilityChanged", I3.visibilityChanged), A3.geomItem.isHighlighted() && (this.highlightedItems.push(A3), this.highlightedIdsBufferDirty = true), I3.highlightChanged = (g4) => {
        if (g4 && g4.name) {
          if (this.highlightedItems.includes(A3))
            return;
          this.highlightedItems.push(A3);
        } else
          this.highlightedItems.splice(this.highlightedItems.indexOf(A3), 1);
        this.highlightedIdsBufferDirty = true, this.emit("updated");
      }, A3.geomItem.on("highlightChanged", I3.highlightChanged), this.glGeomItems[g3] = A3, this.glgeomItemEventHandlers[g3] = I3, this.drawIdsBufferDirty = true, this.emit("updated");
    }
    removeGLGeomItem(A3) {
      const g3 = this.glGeomItems.indexOf(A3), I3 = this.glGeomIdsMapping[A3.geomId];
      I3.splice(I3.indexOf(g3), 1), I3.length == 0 && (delete this.glGeomIdsMapping[A3.geomId], this.dirtyGeomIndices.has(A3.geomId) && this.dirtyGeomIndices.delete(A3.geomId));
      const C3 = this.glgeomItemEventHandlers[g3];
      if (A3.geomItem.off("highlightChanged", C3.highlightChanged), A3.off("visibilityChanged", C3.visibilityChanged), this.glGeomItems[g3] = null, this.glgeomItemEventHandlers[g3] = null, this.drawIdsArray[g3] = 0, this.drawElementOffsets[g3] = 0, this.drawElementCounts[g3] = 0, this.freeIndices.push(g3), A3.isVisible()) {
        const A4 = this.drawOrderToIndex.indexOf(g3);
        this.drawOrderToIndex.splice(A4, 1), this.indexToDrawIndex[g3] = -1, this.drawElementCounts[A4] = 0, this.drawIdsBufferDirty = true;
      }
      if (A3.geomItem.isHighlighted()) {
        const g4 = this.highlightedItems.indexOf(A3);
        this.highlightedItems.splice(g4, 1), this.highlightedIdsBufferDirty = true;
      }
      this.emit("updated");
    }
    cleanGeomIds() {
      this.dirtyGeomIndices.forEach((A3) => {
        const g3 = this.glGeomIdsMapping[A3];
        if (g3 != null) {
          const I3 = this.renderer.glGeomLibrary.getGeomOffsetAndCount(A3);
          g3.forEach((A4) => {
            const g4 = this.glGeomItems[A4];
            if (g4.isVisible()) {
              const C3 = this.indexToDrawIndex[A4];
              this.drawElementOffsets[C3] = I3[0], this.drawElementCounts[C3] = I3[1], this.drawIdsArray[C3] = g4.geomItemId;
              const i3 = this.highlightedItems.indexOf(g4);
              i3 != -1 && (this.highlightElementOffsets[i3] = I3[0], this.highlightElementCounts[i3] = I3[1]);
            }
          });
        }
      }), this.dirtyGeomIndices = new Set();
    }
    updateDrawIDsBuffer(A3) {
      (!this.drawIdsArray || this.drawOrderToIndex.length > this.drawIdsArray.length) && (this.drawIdsArray = new Float32Array(this.drawOrderToIndex.length), this.drawElementOffsets = new Int32Array(this.drawOrderToIndex.length + 1), this.drawElementCounts = new Int32Array(this.drawOrderToIndex.length + 1)), this.drawOrderToIndex.forEach((A4, g4) => {
        const I4 = this.glGeomItems[A4];
        if (!I4)
          return;
        const C4 = this.renderer.glGeomLibrary.getGeomOffsetAndCount(I4.geomId);
        this.drawElementOffsets[g4] = C4[0], this.drawElementCounts[g4] = I4.isVisible() ? C4[1] : 0, this.drawIdsArray[g4] = I4.geomItemId, this.indexToDrawIndex[A4] = g4;
      }), this.dirtyGeomIndices = new Set();
      const g3 = this.renderer.gl;
      if (!g3.multiDrawElements)
        return;
      const I3 = A3.boundTextures++;
      g3.activeTexture(g3.TEXTURE0 + I3);
      const C3 = 2 * r.nextPow2(Math.ceil(Math.sqrt(this.drawOrderToIndex.length)));
      this.drawIdsTexture ? (this.drawIdsTexture.width < C3 || this.drawIdsTexture.height < C3) && this.drawIdsTexture.resize(C3, C3) : this.drawIdsTexture = new HC(this.gl, {format: g3.name == "webgl2" ? "RED" : "ALPHA", type: "FLOAT", width: C3, height: C3, filter: "NEAREST", wrap: "CLAMP_TO_EDGE", mipMapped: false});
      {
        const A4 = this.drawIdsTexture, I4 = this.drawIdsTexture.width;
        g3.bindTexture(g3.TEXTURE_2D, A4.glTex);
        const C4 = 0, i3 = 0, e3 = 1, t3 = A4.getFormat(), B3 = A4.getType(), o3 = Math.ceil((i3 + this.drawOrderToIndex.length) / I4);
        let s3 = 0, a3 = this.drawOrderToIndex.length, l3 = i3;
        for (let A5 = 0; A5 < o3; A5++) {
          let A6;
          l3 + a3 > I4 ? (A6 = I4 - l3, l3 = 0) : A6 = a3;
          const i4 = s3 % I4, o4 = Math.floor(s3 / I4), n3 = this.drawIdsArray.subarray(s3, s3 + A6);
          g3.texSubImage2D(g3.TEXTURE_2D, C4, i4, o4, A6, e3, t3, B3, n3), s3 += A6, a3 -= A6;
        }
      }
      g3.bindTexture(g3.TEXTURE_2D, null), A3.boundTextures--, this.drawIdsBufferDirty = false;
    }
    updateHighlightedIDsBuffer(A3) {
      if (this.highlightedIdsBufferDirty) {
        (!this.highlightedIdsArray || this.highlightedItems.length > this.highlightedIdsArray.length) && (this.highlightedIdsArray = new Float32Array(this.highlightedItems.length), this.highlightElementOffsets = new Int32Array(this.highlightedItems.length + 1), this.highlightElementCounts = new Int32Array(this.highlightedItems.length + 1)), this.highlightedItems.forEach((A4, g4) => {
          this.highlightedIdsArray[g4] = A4.geomItemId;
          const I4 = this.renderer.glGeomLibrary.getGeomOffsetAndCount(A4.geomId);
          this.highlightElementOffsets[g4] = I4[0], this.highlightElementCounts[g4] = I4[1];
        });
        for (let A4 = this.highlightedItems.length; A4 < this.highlightElementCounts.length; A4++)
          this.highlightElementOffsets[A4] = 0, this.highlightElementCounts[A4] = 0;
        this.highlightedIdsBufferDirty = false;
      }
      const g3 = this.renderer.gl;
      if (!g3.multiDrawElements)
        return;
      const I3 = A3.boundTextures++;
      g3.activeTexture(g3.TEXTURE0 + I3);
      const C3 = r.nextPow2(Math.ceil(Math.sqrt(this.highlightedItems.length)));
      this.highlightedIdsTexture ? (this.highlightedIdsTexture.width < C3 || this.highlightedIdsTexture.height < C3) && this.highlightedIdsTexture.resize(C3, C3) : this.highlightedIdsTexture = new HC(this.gl, {format: g3.name == "webgl2" ? "RED" : "ALPHA", type: "FLOAT", width: C3, height: C3, filter: "NEAREST", wrap: "CLAMP_TO_EDGE", mipMapped: false});
      {
        const A4 = this.highlightedIdsTexture, I4 = this.highlightedIdsTexture.width;
        g3.bindTexture(g3.TEXTURE_2D, A4.glTex);
        const C4 = 0, i3 = 0, e3 = 1, t3 = A4.getFormat(), B3 = A4.getType(), o3 = Math.ceil((i3 + this.highlightedIdsArray.length) / I4);
        let s3 = 0, a3 = this.highlightedIdsArray.length, l3 = i3;
        for (let A5 = 0; A5 < o3; A5++) {
          let A6;
          l3 + a3 > I4 ? (A6 = I4 - l3, l3 = 0) : A6 = a3;
          const i4 = s3 % I4, o4 = Math.floor(s3 / I4), n3 = this.highlightedIdsArray.subarray(s3, s3 + A6);
          g3.texSubImage2D(g3.TEXTURE_2D, C4, i4, o4, A6, e3, t3, B3, n3), s3 += A6, a3 -= A6;
        }
      }
      g3.bindTexture(g3.TEXTURE_2D, null), A3.boundTextures--;
    }
    draw(A3) {
      if (this.drawIdsBufferDirty ? this.updateDrawIDsBuffer(A3) : this.dirtyGeomIndices.size > 0 && this.cleanGeomIds(), this.drawIdsArray.length != 0) {
        if (this.drawIdsTexture) {
          const {drawIdsTexture: g3} = A3.unifs;
          this.drawIdsTexture.bindToUniform(A3, g3);
        }
        this.bindAndRender(A3, this.drawIdsArray, this.drawElementCounts, this.drawElementOffsets, this.drawOrderToIndex.length);
      }
    }
    drawHighlighted(A3) {
      if (this.highlightedItems.length != 0) {
        if (this.highlightedIdsBufferDirty && this.updateHighlightedIDsBuffer(A3), this.highlightedIdsTexture) {
          const {drawIdsTexture: g3} = A3.unifs;
          this.highlightedIdsTexture.bindToUniform(A3, g3);
        }
        this.bindAndRender(A3, this.highlightedIdsArray, this.highlightElementCounts, this.highlightElementOffsets, this.highlightedItems.length);
      }
    }
    drawGeomData(A3) {
      if (this.drawIdsBufferDirty && this.updateDrawIDsBuffer(A3), this.drawOrderToIndex.length != 0) {
        if (this.drawIdsTexture) {
          const {drawIdsTexture: g3} = A3.unifs;
          this.drawIdsTexture.bindToUniform(A3, g3);
        }
        this.bindAndRender(A3, this.drawIdsArray, this.drawElementCounts, this.drawElementOffsets, this.drawOrderToIndex.length);
      }
    }
    bindAndRender(A3, g3, I3, C3, i3) {
      const e3 = this.gl, t3 = A3.unifs;
      t3.instancedDraw && e3.uniform1i(A3.unifs.instancedDraw.location, 1), A3.bindViewports(t3, () => {
        this.multiDraw(A3, g3, I3, C3, i3);
      });
    }
    sortItems(A3) {
      const g3 = new Float32Array(this.drawOrderToIndex.length);
      this.drawOrderToIndex.forEach((I3) => {
        const C3 = this.glGeomItems[I3];
        if (C3) {
          const i3 = C3.geomItem.boundingBoxParam.value, e3 = i3.center(), t3 = i3.size(), B3 = e3.distanceTo(A3) - t3;
          g3[I3] = B3;
        }
      }), this.drawOrderToIndex.sort((A4, I3) => g3[I3] - g3[A4]), this.drawOrderToIndex.forEach((A4, g4) => {
        const I3 = this.glGeomItems[A4];
        I3 && (this.drawIdsArray[g4] = I3.geomItemId, this.indexToDrawIndex[A4] = g4);
      }), this.drawIdsBufferDirty = true, this.viewPos = A3;
    }
    destroy() {
      this.drawIdsTexture && this.drawIdsTexture.destroy(), this.highlightedIdsTexture && this.highlightedIdsTexture.destroy(), this.emit("destructing");
    }
  };
  var ke = class extends ve {
    multiDraw(A3, g3, I3, C3, i3) {
      const {occluded: e3, hiddenLineColor: t3} = A3.unifs, B3 = A3.hiddenLineColor && A3.hiddenLineColor.a > 0 && e3 && t3, o3 = this.gl;
      if (o3.multiDrawArrays)
        o3.multiDrawElements(o3.LINES, I3, 0, o3.UNSIGNED_INT, C3, 0, i3), B3 && (o3.uniform1i(e3.location, 1), o3.uniform4fv(t3.location, A3.hiddenLineColor.asArray()), o3.depthFunc(o3.GREATER), o3.depthMask(false), o3.multiDrawElements(o3.LINES, I3, 0, o3.UNSIGNED_INT, C3, 0, i3), o3.depthFunc(o3.LEQUAL), o3.depthMask(true), o3.uniform1i(e3.location, 0));
      else {
        const {geomItemId: s3} = A3.unifs;
        for (let A4 = 0; A4 < i3; A4++)
          o3.uniform1i(s3.location, g3[A4]), o3.drawElements(o3.LINES, I3[A4], o3.UNSIGNED_INT, C3[A4]);
        if (B3) {
          o3.uniform1i(e3.location, 1), o3.uniform4fv(t3.location, A3.hiddenLineColor.asArray()), o3.depthFunc(o3.GREATER), o3.depthMask(false);
          for (let A4 = 0; A4 < i3; A4++)
            o3.uniform1i(s3.location, g3[A4]), o3.drawElements(o3.LINES, I3[A4], o3.UNSIGNED_INT, C3[A4]);
          o3.depthFunc(o3.LEQUAL), o3.depthMask(true), o3.uniform1i(e3.location, 0);
        }
      }
    }
  };
  var xe = class extends ve {
    multiDraw(A3, g3, I3, C3, i3) {
      const e3 = this.gl;
      if (e3.multiDrawArrays)
        e3.multiDrawArrays(e3.POINTS, C3, 0, I3, 0, i3);
      else {
        const {geomItemId: t3} = A3.unifs;
        for (let A4 = 0; A4 < i3; A4++)
          e3.uniform1i(t3.location, g3[A4]), e3.drawArrays(e3.POINTS, C3[A4], I3[A4]);
      }
    }
  };
  !function(A3) {
    A3[A3.TRIANGLES = 0] = "TRIANGLES", A3[A3.LINES = 1] = "LINES", A3[A3.POINTS = 2] = "POINTS";
  }(Le || (Le = {}));
  var ze = class extends ve {
    multiDraw(A3, g3, I3, C3, i3) {
      const e3 = this.gl, t3 = () => {
        if (e3.multiDrawElements)
          e3.multiDrawElements(e3.TRIANGLES, I3, 0, e3.UNSIGNED_INT, C3, 0, i3);
        else {
          const {geomItemId: t4} = A3.unifs;
          for (let A4 = 0; A4 < i3; A4++)
            e3.uniform1i(t4.location, g3[A4]), e3.drawElements(e3.TRIANGLES, I3[A4], e3.UNSIGNED_INT, C3[A4]);
        }
      };
      e3.depthFunc(e3.LEQUAL);
      const {geomType: B3, outlineThickness: o3, viewportSize: s3, renderMode: a3} = A3.unifs, l3 = A3 instanceof jC && a3 ? A3.renderMode : null, n3 = A3 instanceof jC && o3 && s3 && A3.outlineMethod == "geometry" && A3.outlineThickness > 0 && l3 != "flat-noedges" && l3 != "pbr-noedges", d3 = n3 && l3 == "wireframe";
      if (d3 ? (e3.enable(e3.STENCIL_TEST), e3.clearStencil(0), e3.clear(e3.STENCIL_BUFFER_BIT), e3.stencilOpSeparate(e3.FRONT, e3.DECR_WRAP, e3.DECR_WRAP, e3.DECR_WRAP), e3.stencilOpSeparate(e3.BACK, e3.INCR_WRAP, e3.INCR_WRAP, e3.INCR_WRAP), e3.stencilFunc(e3.ALWAYS, 0, 255), e3.enable(e3.CULL_FACE), e3.cullFace(e3.BACK), e3.disable(e3.DEPTH_TEST), e3.depthMask(false), e3.colorMask(false, false, false, false)) : l3 == "hiddenline" && e3.colorMask(false, false, false, false), B3 && e3.uniform1i(B3.location, Le.TRIANGLES), o3 && e3.uniform1f(o3.location, 0), t3(), n3) {
        const g4 = A3;
        if (e3.enable(e3.CULL_FACE), e3.cullFace(e3.FRONT), e3.uniform1f(o3.location, g4.outlineThickness * window.devicePixelRatio), e3.uniform2f(s3.location, A3.region[2] - A3.region[0], A3.region[3] - A3.region[1]), l3 == "hiddenline" && e3.colorMask(true, true, true, false), d3 || (e3.enable(e3.BLEND), e3.blendEquation(e3.FUNC_ADD), e3.blendFunc(e3.SRC_ALPHA, e3.ONE_MINUS_SRC_ALPHA)), t3(), e3.disable(e3.CULL_FACE), e3.cullFace(e3.BACK), d3) {
          e3.enable(e3.DEPTH_TEST), e3.depthMask(true), e3.colorMask(true, true, true, true), e3.stencilFunc(e3.NOTEQUAL, 0, 255), e3.stencilOp(e3.KEEP, e3.KEEP, e3.KEEP), e3.enable(e3.BLEND), e3.blendEquation(e3.FUNC_ADD), e3.blendFunc(e3.SRC_ALPHA, e3.ONE_MINUS_SRC_ALPHA);
          const A4 = g4.glShader, I4 = g4.shaderkey, C4 = g4.screenQuad;
          C4.bindShader(g4), C4.draw(g4, g4.outlineColor), A4.bind(g4, I4), this.renderer.glGeomItemLibrary.bind(g4), this.renderer.glGeomLibrary.bind(g4), this.renderer.glMaterialLibrary.bind(g4), e3.disable(e3.STENCIL_TEST);
        }
      }
    }
  };
  var Te = class extends V {
    constructor(A3, g3, I3) {
      super(), this.glGeomItemSets = {}, this.glGeomDataShaderKey = "", this.glHighlightShaderKey = "", this.pass = A3, this.gl = g3, this.glShader = I3.glShader, this.glGeomDataShader = I3.glgeomdatashader ? I3.glgeomdatashader : I3.glShader, this.glHighlightShader = I3.glselectedshader ? I3.glselectedshader : I3.glShader, this.glShaderKey = I3.glShader.getId() + "multidraw-draw", this.glGeomDataShader && (this.glGeomDataShaderKey = this.glGeomDataShader.getId() + "multidraw-geomdata"), this.glHighlightShader && (this.glHighlightShaderKey = this.glHighlightShader.getId() + "multidraw-highlight");
    }
    getOrCreateGLGeomItemSet(A3) {
      let g3;
      if (A3 instanceof Mg) {
        if (this.glGeomItemSets.CompoundGeom)
          return this.glGeomItemSets.CompoundGeom;
        g3 = new Ue(this.pass.renderer), this.glGeomItemSets.CompoundGeom = g3;
      } else if (A3 instanceof Kg || A3 instanceof Dg) {
        if (this.glGeomItemSets.GLMesh)
          return this.glGeomItemSets.GLMesh;
        g3 = new ze(this.pass.renderer), this.glGeomItemSets.GLMesh = g3;
      } else if (A3 instanceof Yg || A3 instanceof Jg) {
        if (this.glGeomItemSets.GLLines)
          return this.glGeomItemSets.GLLines;
        g3 = new ke(this.pass.renderer), this.glGeomItemSets.GLLines = g3;
      } else {
        if (!(A3 instanceof Wg || A3 instanceof Ng))
          throw new Error("Unsupported geom type:" + A3.constructor.name);
        if (this.glGeomItemSets.GLPoints)
          return this.glGeomItemSets.GLPoints;
        g3 = new xe(this.pass.renderer), this.glGeomItemSets.GLPoints = g3;
      }
      return g3.on("updated", () => {
        this.emit("updated");
      }), g3;
    }
    addGLGeomItem(A3) {
      const g3 = A3.geomItem.geomParam.value, I3 = this.getOrCreateGLGeomItemSet(g3);
      A3.GLGeomItemSet = I3, I3.addGLGeomItem(A3);
    }
    removeGLGeomItem(A3) {
      A3.GLGeomItemSet.removeGLGeomItem(A3), A3.GLGeomItemSet = null;
    }
    bindShader(A3, g3, I3) {
      const C3 = this.gl;
      if (A3.isCompiledForTarget(I3) || (C3.multiDrawElements ? g3.shaderopts.directives.push("#define ENABLE_MULTI_DRAW\n#extension GL_ANGLE_multi_draw : enable") : g3.shaderopts.directives.push("#define ENABLE_MULTI_DRAW"), A3.compileForTarget(I3, g3.shaderopts), g3.shaderopts.directives.pop()), !A3.bind(g3, I3))
        throw new Error("Unable to bind shader:" + A3);
      this.pass.renderer.glGeomItemLibrary.bind(g3), this.pass.renderer.glGeomLibrary.bind(g3), this.pass.renderer.glMaterialLibrary.bind(g3);
    }
    draw(A3) {
      this.bindShader(this.glShader, A3, this.glShaderKey);
      for (const g3 in this.glGeomItemSets)
        this.glGeomItemSets[g3].draw(A3);
      this.glShader.unbind(A3);
    }
    drawHighlightedGeoms(A3) {
      if (this.glHighlightShader) {
        this.bindShader(this.glHighlightShader, A3, this.glHighlightShaderKey);
        for (const g3 in this.glGeomItemSets)
          this.glGeomItemSets[g3].drawHighlighted(A3);
        this.glHighlightShader.unbind(A3);
      }
    }
    drawGeomData(A3) {
      var g3;
      this.bindShader(this.glGeomDataShader, A3, this.glGeomDataShaderKey);
      const I3 = A3.gl, {floatGeomBuffer: C3, passId: i3, occlusionCulling: e3, viewportSize: t3} = A3.unifs;
      C3 && I3.uniform1i(C3.location, A3.floatGeomBuffer ? 1 : 0), i3 && I3.uniform1i(i3.location, A3.passIndex), e3 && I3.uniform1i(e3.location, (g3 = A3.occlusionCulling) !== null && g3 !== void 0 ? g3 : 0);
      for (const g4 in this.glGeomItemSets)
        this.glGeomItemSets[g4].drawGeomData(A3);
      this.glGeomDataShader.unbind(A3);
    }
    sortItems(A3) {
      for (const g3 in this.glGeomItemSets)
        this.glGeomItemSets[g3].sortItems(A3);
    }
  };
  var _e = class extends De {
    constructor() {
      super(), this.__glshadermaterials = {}, this.__glShaderGeomSets = {};
    }
    getPassType() {
      return EC.OPAQUE;
    }
    filterGeomItem(A3) {
      const g3 = A3.materialParam.value;
      return A3.isOpaque() && g3.isOpaque();
    }
    checkMaterial(A3) {
      return A3.isOpaque();
    }
    removeAndReAddGeomItem(A3) {
      this.removeGeomItem(A3), this.__renderer.assignTreeItemToGLPass(A3);
    }
    addGeomItem(A3) {
      super.addGeomItem(A3);
      const g3 = A3.materialParam.value, I3 = this.renderer.glGeomLibrary, C3 = this.renderer.glGeomItemLibrary;
      if (!g3.isTextured() && g3.getShaderClass().supportsInstancing()) {
        const I4 = g3.getShaderName();
        let C4 = this.__glShaderGeomSets[I4];
        if (!C4) {
          const A4 = this.constructShaders(I4);
          C4 = new Te(this, this.__gl, A4), C4.on("updated", () => {
            this.__renderer.requestRedraw();
          }), this.__glShaderGeomSets[I4] = C4;
        }
        const i4 = this.renderer.glGeomItemLibrary.getGLGeomItem(A3);
        return C4.addGLGeomItem(i4), i4.GLShaderGeomSets = C4, this.emit("updated"), true;
      }
      const i3 = I3.constructGLGeom(A3.geomParam.value), e3 = C3.getGLGeomItem(A3), t3 = g3.getShaderName(), B3 = this.renderer.glMaterialLibrary.getGLMaterial(g3);
      let o3 = this.__glshadermaterials[t3];
      if (!o3) {
        const A4 = this.constructShaders(t3);
        o3 = new Qe(this.__gl, this, A4), this.__glshadermaterials[t3] = o3, o3.on("updated", () => {
          this.__renderer.requestRedraw();
        });
      }
      return o3.addGLGeomItem(e3, i3, B3), true;
    }
    removeGeomItem(A3) {
      super.removeGeomItem(A3);
      const g3 = this.renderer.glGeomItemLibrary.getGLGeomItem(A3);
      if (g3.GLShaderGeomSets) {
        return g3.GLShaderGeomSets.removeGLGeomItem(g3), g3.GLShaderGeomSets = null, true;
      }
      if (g3.GLGeomItemSet) {
        return g3.GLGeomItemSet.removeGLGeomItem(g3), g3.GLGeomItemSet = null, true;
      }
      return true;
    }
    removeMaterial(A3) {
      const g3 = A3.getShaderName(), I3 = this.__glshadermaterials[g3];
      if (!I3 || I3 != A3.getMetadata("glshaderMaterials"))
        return void console.warn("Material not found in pass");
      const C3 = A3.getMetadata("glMaterialGeomItemSets");
      I3.removeMaterialGeomItemSets(C3);
    }
    __traverseTreeAndDraw(A3) {
      for (const g3 in this.__glShaderGeomSets)
        this.__glShaderGeomSets[g3].draw(A3);
      for (const g3 in this.__glshadermaterials)
        this.__glshadermaterials[g3].draw(A3);
      A3.glGeom && A3.glGeom.unbind(A3);
    }
    draw(A3) {
      const g3 = this.__gl;
      A3.pushGLStack(), A3.glDisable(g3.BLEND), A3.glEnable(g3.DEPTH_TEST), A3.glDisable(g3.CULL_FACE), g3.depthFunc(g3.LEQUAL), g3.depthMask(true), this.__traverseTreeAndDraw(A3);
      const I3 = this.renderer;
      I3.outlineThickness > 0 && I3.outlineMethod == "image" && A3.viewport.drawSilhouettes(A3), A3.popGLStack();
    }
    drawHighlightedGeoms(A3) {
      const g3 = this.__gl;
      g3.disable(g3.CULL_FACE);
      for (const g4 in this.__glShaderGeomSets)
        this.__glShaderGeomSets[g4].drawHighlightedGeoms(A3);
      for (const g4 in this.__glshadermaterials) {
        this.__glshadermaterials[g4].drawHighlightedGeoms(A3);
      }
      A3.glGeom && A3.glGeom.unbind(A3);
    }
    drawGeomData(A3) {
      A3.passIndex = this.passIndex;
      const g3 = this.__gl;
      g3.disable(g3.BLEND), g3.disable(g3.CULL_FACE), g3.enable(g3.DEPTH_TEST), g3.depthFunc(g3.LEQUAL), g3.depthMask(true);
      for (const g4 in this.__glShaderGeomSets)
        this.__glShaderGeomSets[g4].drawGeomData(A3);
      for (const g4 in this.__glshadermaterials) {
        this.__glshadermaterials[g4].drawGeomData(A3);
      }
      A3.glGeom && A3.glGeom.unbind(A3);
    }
  };
  re.registerPass(_e, EC.OPAQUE);
  var Pe = class extends _e {
    constructor() {
      super(), this.linesGeomDataBuffer = null, this.fattenLinesShader = null, this.quad = null, this.fbo = null;
    }
    init(A3, g3) {
      super.init(A3, g3);
    }
    filterGeomItem(A3) {
      const g3 = A3.geomParam.value;
      return g3 instanceof Yg || g3 instanceof Jg || g3 instanceof Wg || g3 instanceof Ng;
    }
    draw(A3) {
      const g3 = this.__gl;
      A3.pushGLStack(), A3.glEnable(g3.BLEND), A3.glEnable(g3.DEPTH_TEST), g3.blendFunc(g3.SRC_ALPHA, g3.ONE_MINUS_SRC_ALPHA), g3.depthFunc(g3.LEQUAL), g3.depthMask(true), this.__traverseTreeAndDraw(A3), A3.popGLStack();
    }
    drawGeomData(A3) {
      const g3 = this.__gl;
      if (A3.geomDataFbo && !A3.occlusionCulling) {
        this.linesGeomDataBuffer || (this.linesGeomDataBuffer = new HC(g3, {type: this.__renderer.floatGeomBuffer ? "FLOAT" : "UNSIGNED_BYTE", format: "RGBA", filter: "NEAREST", width: 1, height: 2}), this.fattenLinesShader = new fe(g3), this.quad = new Yi(g3, new AI(1, 1)));
        const I3 = A3.geomDataFbo, C3 = I3.width, i3 = I3.height;
        if (this.linesGeomDataBuffer.width != C3 || this.linesGeomDataBuffer.height != i3) {
          this.fbo && (g3.deleteFramebuffer(this.fbo), this.fbo = null), this.linesGeomDataBuffer.resize(C3, i3), this.fbo = g3.createFramebuffer();
          const A4 = this.linesGeomDataBuffer.glTex, e3 = I3.__depthTexture;
          g3.name == "webgl2" ? (g3.bindFramebuffer(g3.DRAW_FRAMEBUFFER, this.fbo), g3.framebufferTexture2D(g3.DRAW_FRAMEBUFFER, g3.COLOR_ATTACHMENT0, g3.TEXTURE_2D, A4, 0), g3.framebufferTexture2D(g3.DRAW_FRAMEBUFFER, g3.DEPTH_ATTACHMENT, g3.TEXTURE_2D, e3, 0)) : (g3.bindFramebuffer(g3.FRAMEBUFFER, this.fbo), g3.framebufferTexture2D(g3.FRAMEBUFFER, g3.COLOR_ATTACHMENT0, g3.TEXTURE_2D, A4, 0), g3.framebufferTexture2D(g3.FRAMEBUFFER, g3.DEPTH_ATTACHMENT, g3.TEXTURE_2D, e3, 0)), MC(g3, C3, i3);
        } else
          g3.name == "webgl2" ? g3.bindFramebuffer(g3.DRAW_FRAMEBUFFER, this.fbo) : g3.bindFramebuffer(g3.FRAMEBUFFER, this.fbo);
        g3.colorMask(true, true, true, true), g3.clearColor(0, 0, 0, 0), g3.clear(g3.COLOR_BUFFER_BIT);
      }
      if (super.drawGeomData(A3), A3.geomDataFbo && !A3.occlusionCulling) {
        A3.geomDataFbo.bindForWriting(A3), this.fattenLinesShader.bind(A3);
        const {colorTexture: I3, screenSize: C3} = A3.unifs;
        this.linesGeomDataBuffer.bindToUniform(A3, I3);
        const i3 = A3.geomDataFbo;
        g3.uniform2f(C3.location, i3.width, i3.height), this.quad.bindAndDraw(A3);
      }
    }
  };
  re.registerPass(Pe, EC.OPAQUE);
  var Oe = class extends De {
    constructor() {
      super(), this.itemCount = 0, this.__glShaderGeomSets = {}, this.transparentItems = [], this.transparentItemIndices = {}, this.freeList = [], this.visibleItems = [], this.prevSortCameraPos = new o(), this.sortCameraMovementDistance = 0, this.reSort = false;
    }
    init(A3, g3) {
      super.init(A3, g3), this.itemCount = 0, this.__glShaderGeomSets = {}, this.transparentItems = [], this.transparentItemIndices = {}, this.freeList = [], this.visibleItems = [], this.prevSortCameraPos = new o(999, 999, 999), this.sortCameraMovementDistance = 0.25, this.reSort = false;
    }
    getPassType() {
      return EC.TRANSPARENT;
    }
    filterGeomItem(A3) {
      const g3 = A3.geomParam.value;
      if (g3 instanceof Yg || g3 instanceof Wg || g3 instanceof Ng || g3 instanceof Jg)
        return false;
      const I3 = A3.materialParam.value;
      return !A3.isOpaque() || !I3.isOpaque();
    }
    resortNeeded() {
      this.reSort = true;
    }
    addGeomItem(A3) {
      super.addGeomItem(A3), this.itemCount++;
      const g3 = this.listenerIDs[A3.getId()], I3 = A3.materialParam.value, C3 = I3.getShaderName(), i3 = this.constructShaders(C3);
      if (!I3.isTextured() && I3.getShaderClass().supportsInstancing()) {
        let I4 = this.__glShaderGeomSets[C3];
        I4 || (I4 = new Te(this, this.__gl, i3), I4.on("updated", () => {
          this.renderer.requestRedraw();
        }), this.__glShaderGeomSets[C3] = I4);
        const e4 = this.renderer.glGeomItemLibrary.getGLGeomItem(A3);
        return I4.addGLGeomItem(e4), g3["glGeomItem.visibilityChanged"] = e4.on("visibilityChanged", () => {
          this.resortNeeded();
        }), this.emit("updated"), e4.GLShaderGeomSets = I4, void (this.reSort = true);
      }
      const e3 = this.renderer.glGeomLibrary.constructGLGeom(A3.geomParam.value), t3 = this.renderer.glGeomItemLibrary.getGLGeomItem(A3);
      if (!t3)
        throw new Error("glGeomItem not found for geomItem:" + A3.getName());
      const B3 = this.renderer.glMaterialLibrary.getGLMaterial(I3);
      g3["glGeomItem.visibilityChanged"] = t3.on("visibilityChanged", (A4) => {
        if (A4.visible)
          this.visibleItems.push(o3);
        else {
          const A5 = this.visibleItems.indexOf(o3);
          this.visibleItems.splice(A5, 1);
        }
        this.reSort = true;
      }), g3["GeomMat.valueChanged"] = A3.geomMatParam.on("valueChanged", () => {
        this.reSort = true;
      });
      const o3 = {geomItem: A3, shaders: i3, glGeom: e3, glMaterial: B3, glGeomItem: t3, material: I3};
      let s3;
      s3 = this.freeList.length > 0 ? this.freeList.pop() : this.transparentItems.length, this.transparentItems[s3] = o3, this.transparentItemIndices[A3.getId()] = s3, A3.isVisible() && this.visibleItems.push(o3), this.reSort = true;
    }
    removeGeomItem(A3) {
      this.itemCount--;
      const g3 = this.listenerIDs[A3.getId()];
      super.removeGeomItem(A3);
      const I3 = this.renderer.glGeomItemLibrary.getGLGeomItem(A3);
      if (!I3)
        throw new Error("glGeomItem not found for geomItem:" + A3.getName());
      if (I3.removeListenerById("visibilityChanged", g3["glGeomItem.visibilityChanged"]), I3.GLShaderGeomSets) {
        I3.GLShaderGeomSets.removeGLGeomItem(I3), I3.GLShaderGeomSets = null;
      } else {
        const g4 = this.transparentItemIndices[A3.getId()], I4 = this.transparentItems[g4];
        delete this.transparentItemIndices[A3.getId()], this.transparentItems[g4] = null, this.freeList.push(g4);
        const C3 = this.visibleItems.indexOf(I4);
        C3 != -1 && this.visibleItems.splice(C3, 1);
      }
      return this.emit("updated"), true;
    }
    sortItems(A3) {
      for (const g3 in this.__glShaderGeomSets)
        this.__glShaderGeomSets[g3].sortItems(A3);
      for (const g3 of this.visibleItems) {
        const I3 = g3.glGeomItem.geomItem.geomMatParam.value;
        g3.dist = I3.translation.distanceTo(A3);
      }
      this.visibleItems.sort((A4, g3) => A4.dist > g3.dist ? -1 : A4.dist < g3.dist ? 1 : 0), this.reSort = false;
    }
    _drawItem(A3, g3, I3) {
      I3.currentGLMaterial != g3.glMaterial && (I3.currentGLMaterial = g3.glMaterial, I3.currentGLMaterial.bind(A3)), I3.currentGLGeom != g3.glGeom && (I3.currentGLGeom = g3.glGeom, I3.currentGLGeom.bind(A3));
      g3.glGeomItem.bind(A3), A3.bindViewports(A3.unifs, () => {
        I3.currentGLGeom.draw(A3);
      });
    }
    _drawItems(A3) {
      for (const g4 in this.__glShaderGeomSets)
        this.__glShaderGeomSets[g4].draw(A3);
      const g3 = {currentglShader: null, currentGLMaterial: null, currentGLGeom: null};
      for (const I3 of this.visibleItems) {
        const C3 = I3.shaders.glShader;
        if (g3.currentglShader != C3) {
          if (!C3.bind(A3, "color"))
            continue;
          const I4 = this.__gl, i3 = A3.unifs;
          i3.instancedDraw && I4.uniform1i(i3.instancedDraw.location, 0), this.renderer.glGeomItemLibrary.bind(A3), g3.currentglShader = C3;
        }
        this._drawItem(A3, I3, g3);
      }
    }
    draw(A3) {
      if (this.itemCount == 0)
        return;
      const g3 = this.__gl, I3 = A3.viewXfo.tr;
      if (this.reSort || I3.distanceTo(this.prevSortCameraPos) > this.sortCameraMovementDistance) {
        if (this.sortItems(I3), this.prevSortCameraPos = I3, A3.vrviewport)
          this.sortCameraMovementDistance = 0.2 * A3.viewScale;
        else if (A3.viewport) {
          const g4 = A3.viewport.getCamera();
          this.sortCameraMovementDistance = 0.3 * g4.getFocalDistance();
        }
      }
      A3.pushGLStack(), A3.glEnable(g3.BLEND), A3.glEnable(g3.DEPTH_TEST), A3.glEnable(g3.CULL_FACE), g3.depthFunc(g3.LESS), g3.blendEquation(g3.FUNC_ADD), A3.pass = "ADD", g3.blendFunc(g3.SRC_ALPHA, g3.ONE_MINUS_SRC_ALPHA), g3.cullFace(g3.BACK), this._drawItems(A3), A3.popGLStack();
    }
    drawHighlightedGeoms(A3) {
      const g3 = this.__gl;
      g3.disable(g3.CULL_FACE);
      for (const g4 in this.__glShaderGeomSets)
        this.__glShaderGeomSets[g4].drawHighlightedGeoms(A3);
      const I3 = {currentglShader: null, currentGLMaterial: null, currentGLGeom: null};
      for (const C3 of this.visibleItems) {
        if (!C3.geomItem.isHighlighted())
          continue;
        if (!C3.shaders.glselectedshader)
          continue;
        const i3 = C3.shaders;
        if (I3.currentglShader != i3.glselectedshader) {
          if (!i3.glselectedshader.bind(A3, "highlight"))
            continue;
          I3.currentglShader = i3.glselectedshader;
        }
        const {floatGeomBuffer: e3, passId: t3, instancedDraw: B3} = A3.unifs;
        e3 && g3.uniform1i(e3.location, g3.floatGeomBuffer ? 1 : 0), t3 && g3.uniform1i(t3.location, this.passIndex), B3 && g3.uniform1i(B3.location, 0), this.renderer.glGeomItemLibrary.bind(A3), this._drawItem(A3, C3, I3);
      }
      I3.currentGLGeom && I3.currentGLGeom.unbind(A3);
    }
    drawGeomData(A3) {
      const g3 = this.__gl;
      A3.pushGLStack(), A3.glEnable(g3.DEPTH_TEST), A3.glEnable(g3.CULL_FACE);
      for (const g4 in this.__glShaderGeomSets)
        this.__glShaderGeomSets[g4].drawGeomData(A3);
      const I3 = {currentglShader: null, currentGLMaterial: null, currentGLGeom: null};
      for (const C3 of this.visibleItems) {
        if (!C3.glGeomItem.geomItem.isSelectable())
          continue;
        const i3 = C3.shaders;
        if (!i3.glgeomdatashader)
          continue;
        if (I3.currentglShader != i3.glgeomdatashader) {
          if (!i3.glgeomdatashader.bind(A3, "geomdata"))
            continue;
          I3.currentglShader = i3.glgeomdatashader;
        }
        const {floatGeomBuffer: e3, passId: t3, instancedDraw: B3} = A3.unifs;
        e3 && g3.uniform1i(e3.location, g3.floatGeomBuffer ? 1 : 0), t3 && g3.uniform1i(t3.location, this.passIndex), B3 && g3.uniform1i(B3.location, 0), this.renderer.glGeomItemLibrary.bind(A3), this._drawItem(A3, C3, I3);
      }
      I3.currentGLGeom && I3.currentGLGeom.unbind(A3), A3.popGLStack();
    }
  };
  re.registerPass(Oe, EC.TRANSPARENT);
  var je = class extends DC {
    constructor(A3) {
      super(A3, "AtlasLayoutShader"), this.setShaderStage("VERTEX_SHADER", "\n\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'quadVertexFromID.glsl'\n\nuniform vec2 pos;\nuniform vec2 size;\nuniform vec2 srctextureDim;\nconst int border = 2;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n  vec2 position = getQuadVertexPositionFromID();\n  v_texCoord = position+0.5;\n  gl_Position = vec4(vec2(-1.0, -1.0) + (pos * 2.0) + (v_texCoord * size * 2.0), 0.0, 1.0);\n\n  vec2 borderVec2 = vec2(float(border), float(border));\n  v_texCoord *= (srctextureDim + (borderVec2 * 2.0)) / srctextureDim;\n  v_texCoord -= borderVec2 / srctextureDim;\n}\n\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nuniform sampler2D srctexture;\nuniform vec2 srctextureDim;\nuniform bool alphaFromLuminance;\nuniform bool invert;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n\nfloat luminanceFromRGB(vec3 rgb) {\n  return 0.2126*rgb.r + 0.7152*rgb.g + 0.0722*rgb.b;\n}\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\n\nvoid main(void) {\n  vec2 pixelCoord = v_texCoord*srctextureDim;\n  vec2 uv = v_texCoord;\n\n  // Wrap X coords\n  if (pixelCoord.x < 0.0) {\n    uv.x += 1.0/srctextureDim.x;\n    uv.y = 1.0 - uv.y;\n  }\n  else if (pixelCoord.x > srctextureDim.x) {\n    uv.x -= 1.0/srctextureDim.x;\n    uv.y = 1.0 - uv.y;\n  }\n\n  // Wrap Y coords\n  if (pixelCoord.y < 0.0) {\n    uv.y += 1.0/srctextureDim.y;\n    uv.x = 1.0 - uv.x;\n  }\n  else if (pixelCoord.y > srctextureDim.y) {\n    uv.y -= 1.0/srctextureDim.y;\n    uv.x = 1.0 - uv.x;\n  }\n\n  vec4 texel = texture2D(srctexture, uv);\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  // TODO: check why we pre-multiply alphas here.\n  // fragColor = vec4(texel.rgb/texel.a, texel.a);\n\n  if (alphaFromLuminance) {\n    fragColor = vec4(texel.rgb, luminanceFromRGB(texel.rgb));\n  }\n  else {\n    fragColor = texel;\n  }\n  \n  if (invert) {\n    fragColor = vec4(1.0) - fragColor;\n  }\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n\n");
    }
  };
  var qe = class extends LC {
    constructor(A3, g3, I3 = "RGBA", C3 = "FLOAT") {
      super(A3), this.__asyncCount = 0, this.loaded = false, this.ready = false, this.__layout = [], this.__layoutVec4s = [], this.__atlasLayoutShaderBinding = null, this.__atlasLayoutShader = null, this.__name = g3, this.__formatParam = I3, this.__typeParam = C3, this.clearColor = new l(0, 0, 0, 0), this.__subImages = [], this.__layoutNeedsRegeneration = false, this.__asyncCount = 0, this.loaded = false;
    }
    incAsyncCount(A3 = 1) {
      this.__asyncCount += A3, this.ready = false;
    }
    decAsyncCount() {
      this.__asyncCount > 0 && (this.__asyncCount--, this.__asyncCount == 0 && (this.loaded = true, this.emit("loaded")));
    }
    isLoaded() {
      return this.__asyncCount == 0;
    }
    addSubImage(A3) {
      if (A3 instanceof Gg) {
        const g3 = new HC(this.__gl, A3);
        A3.isLoaded() || (this.incAsyncCount(), A3.on("loaded", () => {
          this.decAsyncCount();
        })), A3.setMetadata("ImageAtlas_gltex", g3), g3.addRef(this);
        const I3 = () => {
          this.__layoutNeedsRegeneration = true, this.renderAtlas();
        };
        A3.on("updated", I3), this.__subImages.push(g3);
      } else {
        const g3 = A3;
        g3.addRef(this), this.__subImages.push(g3);
      }
      return this.__layoutNeedsRegeneration = true, this.__subImages.length - 1;
    }
    removeSubImage(A3) {
      let g3;
      if (A3 instanceof Gg) {
        const I3 = A3.getMetadata("ImageAtlas_gltex");
        g3 = this.__subImages.indexOf(I3), A3.deleteMetadata("ImageAtlas_gltex");
      } else
        g3 = this.__subImages.indexOf(A3);
      this.__subImages[g3].removeRef(this), this.__subImages.splice(g3, 1), this.__layoutNeedsRegeneration = true;
    }
    getSubImage(A3) {
      return this.__subImages[A3];
    }
    numSubImages() {
      return this.__layout ? this.__layout.length : this.__subImages.length;
    }
    generateAtlasLayout(A3) {
      if (this.__subImages.length == 0)
        return void (this.__layoutNeedsRegeneration = false);
      const g3 = [];
      this.__subImages.forEach((A4, I4) => {
        g3.push({w: A4.width + 4, h: A4.height + 4, area: A4.width * A4.height, index: I4});
      }), g3.sort((A4, g4) => A4.area > g4.area ? -1 : A4.area < g4.area ? 1 : 0);
      const I3 = new S();
      I3.fit(g3), this.__layout = [], g3.forEach((A4, g4) => {
        A4.fit ? this.__layout[A4.index] = {pos: new B(A4.fit.x + 2, A4.fit.y + 2), size: new B(A4.w, A4.h)} : console.warn("Unable to fit image");
      });
      const C3 = I3.root.w, i3 = I3.root.h;
      this.configure({width: C3, height: i3, format: this.__typeParam == "FLOAT" && this.__formatParam == "RGB" ? "RGBA" : this.__formatParam, type: this.__typeParam, filter: "LINEAR"});
      const e3 = this.__gl;
      if (e3.__quadVertexIdsBuffer || e3.setupInstancedQuad(), !this.__atlasLayoutShader) {
        this.__atlasLayoutShader = new je(this.__gl);
        const A4 = [];
        e3.name == "webgl2" && A4.push("#define ENABLE_ES3");
        const g4 = this.__atlasLayoutShader.compileForTarget("GLImageAtlas", {directives: A4});
        this.__atlasLayoutShaderBinding = _C(this.__gl, g4.attrs, e3.__quadattrbuffers, e3.__quadIndexBuffer);
      }
      let t3 = Math.round(Math.sqrt(1 * this.__layout.length) + 0.5);
      if (t3 = r.nextPow2(t3), t3 % 1 != 0 && (t3 += 1 - t3 % 1), e3.floatTexturesSupported) {
        const A4 = new Float32Array(t3 * t3 * 4);
        for (let g4 = 0; g4 < this.__layout.length; g4++) {
          const I4 = this.__layout[g4];
          new s(new Float32Array(A4.buffer, 4 * g4 * 4, 4)).set(I4.pos.x / C3, I4.pos.y / i3, I4.size.x / C3, I4.size.y / i3);
        }
        this.__atlasLayoutTexture && this.__atlasLayoutTexture.width == t3 && this.__atlasLayoutTexture.height == t3 ? this.__atlasLayoutTexture.bufferData(A4, t3, t3) : (this.__atlasLayoutTexture && this.__atlasLayoutTexture.destroy(), this.__atlasLayoutTexture = new HC(e3, {format: "RGBA", type: "FLOAT", filter: "NEAREST", wrap: "CLAMP_TO_EDGE", mipMapped: false, width: t3, height: t3, data: A4}));
      } else
        this.__layoutVec4s = [], this.__layout.forEach((A4, g4) => {
          this.__layoutVec4s[g4] = [A4.pos.x / C3, A4.pos.y / i3, A4.size.x / C3, A4.size.y / i3];
        });
      this.textureDesc[0] = this.width, this.textureDesc[1] = this.height, this.textureDesc[2] = this.__atlasLayoutTexture.width, this.__layoutNeedsRegeneration = false;
    }
    getLayoutData(A3) {
      return this.__layoutVec4s[A3];
    }
    renderAtlas(A3 = false, g3 = 0) {
      if (this.__subImages.length == 0)
        return;
      this.__layoutNeedsRegeneration && this.generateAtlasLayout();
      const I3 = this.__gl, C3 = new PC(I3);
      this.bindForWriting(C3, true), this.__atlasLayoutShader.bind(C3, "GLImageAtlas"), this.__atlasLayoutShaderBinding.bind(C3);
      const i3 = new B(1 / this.width, 1 / this.height), e3 = C3.unifs;
      for (let A4 = g3; A4 < this.__subImages.length; A4++) {
        const g4 = this.__subImages[A4], t3 = this.__layout[A4];
        g4.bindToUniform(C3, e3.srctexture) && (I3.uniform2fv(e3.pos.location, t3.pos.multiply(i3).asArray()), I3.uniform2fv(e3.size.location, t3.size.multiply(i3).asArray()), I3.uniform2f(e3.srctextureDim.location, g4.width, g4.height), I3.uniform1i(e3.alphaFromLuminance.location, g4.alphaFromLuminance ? 1 : 0), I3.uniform1i(e3.invert.location, g4.invert ? 1 : 0), I3.drawQuad(), C3.boundTextures--);
      }
      A3 && this.cleanup(), this.unbind(C3), this.emit("updated");
    }
    isReady() {
      return this.__atlasLayoutTexture != null;
    }
    bindToUniform(A3, g3) {
      super.bindToUniform(A3, g3);
      const I3 = A3.unifs;
      if (this.__atlasLayoutTexture) {
        const C3 = I3[g3.name + "_layout"];
        C3 && this.__atlasLayoutTexture.bindToUniform(A3, C3);
        const i3 = I3[g3.name + "_desc"];
        i3 && this.__gl.uniform4fv(i3.location, this.textureDesc);
      } else {
        const A4 = I3[g3.name + "_desc"];
        A4 && this.__gl.uniform4f(A4.location, this.width, this.height, 0, 0);
      }
      return true;
    }
    cleanup() {
      for (const A3 of this.__subImages)
        A3.removeRef(this);
      this.__subImages = [], this.destroy();
    }
    destroy() {
      this.cleanup(), super.destroy();
    }
  };
  var $e = class extends bC {
    constructor() {
      super(), this.atlas = null, this.indexArrayUpdateNeeded = false, this.instanceIdsBuffer = null, this.indexArray = new Float32Array(0), this.glshader = null, this.shaderComp = {}, this.shaderBinding = null, this.modelMatrixArray = [], this.billboardDataArray = [], this.tintColorArray = [], this.width = 0, this.drawItemsTexture = null, this.billboards = [], this.dirtyBillboards = new Set(), this.freeIndices = [], this.drawCount = 0, this.threshold = 0, this.updateRequested = false, this.prevSortCameraPos = new o();
    }
    init(A3, g3) {
      super.init(A3, g3), this.atlas = new qe(this.renderer.gl, "Billboards", "RGBA", "UNSIGNED_BYTE"), this.atlas.clearColor = new l(1, 1, 1, 0);
      const I3 = (A4) => this.emit("updated", A4);
      this.atlas.on("loaded", I3), this.atlas.on("updated", I3);
    }
    getPassType() {
      return EC.TRANSPARENT;
    }
    itemAddedToScene(A3, g3) {
      return A3 instanceof gC && (this.addBillboard(A3), true);
    }
    itemRemovedFromScene(A3, g3) {
      return A3 instanceof gC && (this.removeBillboard(A3), true);
    }
    addBillboard(A3) {
      const g3 = A3.imageParam, I3 = g3.value;
      if (!I3)
        return void g3.on("valueChanged", () => this.addBillboard(A3));
      let C3;
      C3 = this.freeIndices.length > 0 ? this.freeIndices.pop() : this.billboards.length;
      const i3 = this.atlas.addSubImage(I3);
      A3.setMetadata("GLBillboardsPass_Index", C3);
      const e3 = () => {
        A3.isVisible() ? (this.drawCount++, this.dirtyBillboards.add(C3)) : this.drawCount--, this.reqUpdateIndexArray();
      };
      A3.on("visibilityChanged", e3);
      const t3 = () => {
        A3.isVisible() && (this.dirtyBillboards.add(C3), this.emit("updated"));
      };
      A3.globalXfoParam.on("valueChanged", t3), A3.alphaParam.on("valueChanged", t3), A3.on("highlightChanged", t3), A3.isVisible() && this.drawCount++, this.billboards[C3] = {billboard: A3, imageIndex: i3, visibilityChanged: e3, updateBillboard: t3}, this.indexArrayUpdateNeeded = true, this.requestUpdate();
    }
    removeBillboard(A3) {
      const g3 = A3.getMetadata("GLBillboardsPass_Index");
      if (g3 == -1)
        return void console.warn("Billboard already removed.");
      const I3 = this.billboards[g3], C3 = I3.billboard.imageParam.value;
      this.atlas.removeSubImage(C3), A3.off("visibilityChanged", I3.visibilityChanged), A3.off("highlightChanged", I3.updateBillboard), A3.globalXfoParam.off("valueChanged", I3.updateBillboard), A3.alphaParam.off("valueChanged", I3.updateBillboard), this.billboards[g3] = null, this.freeIndices.push(g3), A3.isVisible() && this.drawCount--, this.indexArrayUpdateNeeded = true, this.requestUpdate();
    }
    populateBillboardDataArray(A3, g3, I3) {
      const C3 = A3.billboard, i3 = C3.globalXfoParam.value.toMat4(), e3 = C3.pixelsPerMeterParam.value, t3 = C3.pivotParam.value, B3 = 1 / e3;
      let o3 = 0;
      C3.alignedToCameraParam.value && (o3 |= 4), C3.drawOnTopParam.value && (o3 |= 8), C3.fixedSizeOnscreenParam.value && (o3 |= 16);
      const a3 = C3.alphaParam.value, l3 = C3.colorParam.value, n3 = 7 * g3 * 4, d3 = new s(new Float32Array(I3.buffer, 4 * n3, 4)), h3 = new s(new Float32Array(I3.buffer, 4 * (n3 + 4), 4)), c3 = new s(new Float32Array(I3.buffer, 4 * (n3 + 8), 4)), r3 = new s(new Float32Array(I3.buffer, 4 * (n3 + 12), 4));
      d3.set(i3.xAxis.x, i3.yAxis.x, i3.zAxis.x, i3.translation.x), h3.set(i3.xAxis.y, i3.yAxis.y, i3.zAxis.y, i3.translation.y), c3.set(i3.xAxis.z, i3.yAxis.z, i3.zAxis.z, i3.translation.z), r3.set(B3, o3, A3.imageIndex, a3);
      new s(new Float32Array(I3.buffer, 4 * (n3 + 16), 4)).set(t3.x, t3.y, 0, 0);
      if (new s(new Float32Array(I3.buffer, 4 * (n3 + 20), 4)).set(l3.r, l3.g, l3.b, l3.a), C3.isHighlighted()) {
        const A4 = C3.getHighlight();
        new s(new Float32Array(I3.buffer, 4 * (n3 + 24), 4)).set(A4.r, A4.g, A4.b, A4.a);
      }
    }
    requestUpdate() {
      this.updateRequested || (this.updateRequested = true, this.emit("updated"));
    }
    reqUpdateIndexArray() {
      this.indexArrayUpdateNeeded || (this.indexArrayUpdateNeeded = true, this.emit("updated"));
    }
    updateIndexArray() {
      const A3 = this.__gl;
      this.indexArray && this.indexArray.length != this.drawCount && (A3.deleteBuffer(this.instanceIdsBuffer), this.instanceIdsBuffer = null), this.indexArray = new Float32Array(this.drawCount);
      let g3 = 0;
      for (let A4 = 0; A4 < this.billboards.length; A4++)
        this.billboards[A4] && this.billboards[A4].billboard.isVisible() && (this.indexArray[g3] = A4, g3++);
      this.instanceIdsBuffer || (this.instanceIdsBuffer = A3.createBuffer()), A3.bindBuffer(A3.ARRAY_BUFFER, this.instanceIdsBuffer), A3.bufferData(A3.ARRAY_BUFFER, this.indexArray, A3.STATIC_DRAW), this.indexArrayUpdateNeeded = false;
    }
    updateBillboards(A3) {
      const g3 = () => {
        this.indexArrayUpdateNeeded && this.updateIndexArray();
        const g4 = this.__gl;
        if (!this.glshader) {
          g4.__quadVertexIdsBuffer || g4.setupInstancedQuad(), this.glshader = new Ee(g4);
          const I4 = this.glshader.compileForTarget("GLBillboardsPass", A3.shaderopts);
          this.shaderBinding = _C(g4, I4.attrs, g4.__quadattrbuffers, g4.__quadIndexBuffer);
        }
        if (this.atlas.renderAtlas(), !g4.floatTexturesSupported || !g4.drawElementsInstanced)
          return this.modelMatrixArray = [], this.billboardDataArray = [], this.tintColorArray = [], this.indexArray.forEach((A4) => {
            const g5 = this.billboards[A4], I4 = g5.billboard, C3 = I4.globalXfoParam.value.toMat4(), i3 = 1 / I4.pixelsPerMeterParam.value;
            let e3 = 0;
            I4.alignedToCameraParam.value && (e3 |= 4), I4.drawOnTopParam.value && (e3 |= 8), I4.fixedSizeOnscreenParam.value && (e3 |= 16);
            const t3 = I4.alphaParam.value, B3 = I4.colorParam.value;
            this.modelMatrixArray[A4] = C3.asArray(), this.billboardDataArray[A4] = [i3, e3, g5.imageIndex, t3], this.tintColorArray[A4] = [B3.r, B3.g, B3.b, B3.a];
          }), void (this.updateRequested = false);
        let I3 = Math.round(Math.sqrt(7 * (this.billboards.length - this.freeIndices.length)) + 0.5);
        if (I3 % 7 != 0 && (I3 += 7 - I3 % 7), this.width = I3, this.drawItemsTexture)
          this.drawItemsTexture.resize(I3, I3);
        else {
          const A4 = {format: "RGBA", type: "FLOAT", width: I3, height: I3, filter: "NEAREST", wrap: "CLAMP_TO_EDGE", mipMapped: false};
          this.drawItemsTexture = new HC(g4, A4), this.drawItemsTexture.clear();
        }
        this.indexArray.forEach((A4) => {
          A4 != -1 && this.updateBillboard(A4);
        }), this.updateRequested = false;
      };
      this.atlas.isLoaded() ? g3() : this.atlas.on("loaded", g3);
    }
    updateBillboard(A3) {
      if (this.drawCount == 0 || !this.drawItemsTexture)
        return;
      const g3 = this.billboards[A3];
      if (!g3.billboard.isVisible())
        return;
      const I3 = this.__gl, C3 = new Float32Array(28);
      this.populateBillboardDataArray(g3, 0, C3), I3.bindTexture(I3.TEXTURE_2D, this.drawItemsTexture.glTex);
      const i3 = 7 * A3 % this.width, e3 = Math.floor(7 * A3 / this.width), t3 = this.drawItemsTexture.getType(), B3 = this.drawItemsTexture.getFormat();
      if (t3 == I3.FLOAT)
        I3.texSubImage2D(I3.TEXTURE_2D, 0, i3, e3, 7, 1, B3, t3, C3);
      else {
        const A4 = r.convertFloat32ArrayToUInt16Array(C3);
        I3.texSubImage2D(I3.TEXTURE_2D, 0, i3, e3, 7, 1, B3, t3, A4);
      }
    }
    sort(A3) {
      for (const g4 of this.billboards) {
        const {billboard: I3} = g4;
        if (I3 && I3.isVisible()) {
          const C3 = I3.globalXfoParam.value;
          g4.dist = C3.tr.distanceTo(A3);
        }
      }
      this.indexArray.sort((A4, g4) => A4 == -1 ? 1 : g4 == -1 || this.billboards[A4].dist > this.billboards[g4].dist ? -1 : this.billboards[A4].dist < this.billboards[g4].dist ? 1 : 0);
      const g3 = this.__gl;
      g3.floatTexturesSupported && this.instanceIdsBuffer && (g3.bindBuffer(g3.ARRAY_BUFFER, this.instanceIdsBuffer), g3.bufferData(g3.ARRAY_BUFFER, this.indexArray, g3.STATIC_DRAW));
    }
    __draw(A3, g3) {
      const I3 = this.__gl;
      if (!this.glshader)
        return;
      this.glshader.bind(A3, g3), this.shaderBinding.bind(A3);
      const C3 = A3.unifs, {atlasBillboards: i3, passId: e3, floatGeomBuffer: t3, inVR: B3} = A3.unifs;
      if (i3 && this.atlas.bindToUniform(A3, C3.atlasBillboards), t3 && A3 instanceof qC && I3.uniform1i(t3.location, A3.floatGeomBuffer ? 1 : 0), e3 && I3.uniform1i(e3.location, this.passIndex), B3 && I3.uniform1i(B3.location, A3.vrPresenting ? 1 : 0), I3.floatTexturesSupported && I3.drawElementsInstanced) {
        const {instancesTexture: g4, instancesTextureSize: i4} = A3.unifs;
        this.drawItemsTexture.bindToUniform(A3, g4), I3.uniform1i(i4.location, this.width);
        {
          const g5 = A3.attrs.instanceIds.location;
          I3.enableVertexAttribArray(g5), I3.bindBuffer(I3.ARRAY_BUFFER, this.instanceIdsBuffer), I3.vertexAttribPointer(g5, 1, I3.FLOAT, false, 4, 0), I3.vertexAttribDivisor(g5, 1);
        }
        A3.bindViewports(C3, () => {
          I3.drawElementsInstanced(I3.TRIANGLES, 6, I3.UNSIGNED_SHORT, 0, this.drawCount);
        });
      } else {
        const {modelMatrix: g4, billboardData: i4, tintColor: e4, layoutData: t4} = A3.unifs, B4 = this.indexArray.length;
        for (let o3 = 0; o3 < B4; o3++)
          I3.uniformMatrix4fv(g4.location, false, this.modelMatrixArray[o3]), I3.uniform4fv(i4.location, this.billboardDataArray[o3]), I3.uniform4fv(e4.location, this.tintColorArray[o3]), I3.uniform4fv(t4.location, this.atlas.getLayoutData(this.billboards[o3].imageIndex)), A3.bindViewports(C3, () => {
            I3.drawQuad();
          });
      }
    }
    draw(A3) {
      if (this.drawCount == 0)
        return;
      if (this.updateRequested && this.updateBillboards(A3), this.dirtyBillboards.size > 0 && (this.dirtyBillboards.forEach((A4) => {
        this.updateBillboard(A4);
      }), this.dirtyBillboards.clear()), this.indexArrayUpdateNeeded && this.updateIndexArray(), !this.glshader)
        return;
      const g3 = A3.viewXfo.tr;
      if (g3.distanceTo(this.prevSortCameraPos) > this.threshold)
        if (this.sort(g3), this.prevSortCameraPos = g3.clone(), this.drawCount > 1) {
          const A4 = this.indexArray[this.indexArray.length - 1], g4 = this.indexArray[this.indexArray.length - 2], I4 = this.billboards[A4].billboard, C3 = this.billboards[g4].billboard, i3 = I4.globalXfoParam.value.tr, e3 = C3.globalXfoParam.value.tr;
          this.threshold = i3.distanceTo(e3);
        } else
          this.threshold = 9999;
      const I3 = this.__gl;
      I3.depthMask(false), I3.disable(I3.CULL_FACE), I3.enable(I3.BLEND), I3.blendEquation(I3.FUNC_ADD), I3.blendFunc(I3.SRC_ALPHA, I3.ONE_MINUS_SRC_ALPHA), this.__draw(A3, "DRAW_COLOR"), I3.disable(I3.BLEND), I3.depthMask(true);
    }
    drawHighlightedGeoms(A3) {
      this.drawCount != 0 && this.__draw(A3, "DRAW_HIGHLIGHT");
    }
    drawGeomData(A3) {
      this.drawCount != 0 && this.__draw(A3, "DRAW_GEOMDATA");
    }
    getGeomItemAndDist(A3) {
      let g3, I3;
      if (A3 instanceof Float32Array ? (g3 = Math.round(A3[1]), I3 = A3[3]) : (g3 = A3[0] + ((63 & A3[1]) << 8), I3 = r.decode16BitFloatFrom2xUInt8(A3.slice(2, 3))), !(g3 >= this.billboards.length))
        return {geomItem: this.billboards[g3].billboard, componentId: 0, dist: I3};
      console.warn("Invalid Draw Item id:" + g3 + " NumBillboards:" + (this.billboards.length - 1));
    }
  };
  re.registerPass($e, EC.TRANSPARENT);
  var At = class extends _e {
    constructor() {
      super();
    }
    getPassType() {
      return EC.OVERLAY;
    }
    filterGeomItem(A3) {
      if (A3.isOverlay())
        return true;
      const g3 = A3.materialParam.value.getShaderClass();
      return !(!g3 || !g3.isOverlay());
    }
    draw(A3) {
      const g3 = this.__gl;
      g3.clear(g3.DEPTH_BUFFER_BIT), g3.enable(g3.CULL_FACE), g3.cullFace(g3.BACK), g3.enable(g3.BLEND), g3.blendEquation(g3.FUNC_ADD), A3.pass = "ADD", g3.blendFunc(g3.SRC_ALPHA, g3.ONE_MINUS_SRC_ALPHA), this.__traverseTreeAndDraw(A3), g3.disable(g3.BLEND);
    }
    drawGeomData(A3) {
      const g3 = this.__gl;
      g3.clear(g3.DEPTH_BUFFER_BIT), g3.enable(g3.CULL_FACE), g3.cullFace(g3.BACK), g3.enable(g3.BLEND), g3.blendEquation(g3.FUNC_ADD), A3.pass = "ADD", g3.blendFunc(g3.SRC_ALPHA, g3.ONE_MINUS_SRC_ALPHA), super.drawGeomData(A3), g3.disable(g3.BLEND), g3.enable(g3.DEPTH_TEST);
    }
  };
  re.registerPass(At, EC.OVERLAY);
  console.log("Zea Engine v4.4.0");
  var gt = new class {
    constructor(A3) {
      this.version = A3, this.registry = {};
    }
    registerLib(A3) {
      const g3 = A3.name, I3 = A3.version;
      this.registry[g3] && console.warn("Library already registered:" + g3), this.registry[g3] = I3, console.log(`Registered lib '${g3}' v${I3}`);
    }
    listLibs() {
      return this.registry;
    }
  }("4.4.0");
  var It = Object.freeze({__proto__: null, Allocation1D: w, Allocator1D: X, AssetItem: $I, AssetLoadContext: AC, Attribute: bg, BaseClass: u, BaseEvent: R, BaseGeom: wg, BaseGeomItem: LI, BaseGroup: xI, BaseImage: Gg, BaseItem: hA, BaseProxy: pg, BaseTool: VC, BillboardItem: gC, BillboardShader: Ee, BinReader: YA, BinWriter: class {
    constructor(A3 = 0) {
      this.__data = new ArrayBuffer(A3), this.__byteOffset = 0, this.__reserved = A3, this.__dataView = new DataView(this.__data);
    }
    pos() {
      return this.__byteOffset;
    }
    seek(A3) {
      this.__byteOffset = A3;
    }
    seekEnd() {
      this.__byteOffset = this.__reserved;
    }
    getBuffer() {
      if (this.__data.byteLength == this.__byteOffset)
        return this.__data;
      return new Uint8Array(this.__data).slice(0, this.__byteOffset).buffer;
    }
    __grow() {
      const A3 = 2 * (this.__reserved > 0 ? this.__reserved : 1), g3 = new ArrayBuffer(A3), I3 = new Uint8Array(g3), C3 = new Uint8Array(this.__data);
      I3.set(C3), this.__data = g3, this.__dataView = new DataView(this.__data), this.__reserved = A3;
    }
    __reserve(A3) {
      this.__byteOffset + A3 > this.__reserved && this.__grow();
    }
    __offset(A3) {
      this.__byteOffset += A3, this.__byteOffset > this.__reserved && this.__grow();
    }
    writeUInt8(A3) {
      this.__reserve(1), this.__dataView.setUint8(this.__byteOffset, A3), this.__offset(1);
    }
    writeUInt16(A3) {
      this.__reserve(2), this.__dataView.setUint16(this.__byteOffset, A3, true), this.__offset(2);
    }
    writeUInt32(A3) {
      this.__reserve(4), this.__dataView.setUint32(this.__byteOffset, A3, true), this.__offset(4);
    }
    writeSInt32(A3) {
      this.__reserve(4), this.__dataView.setInt32(this.__byteOffset, A3, true), this.__offset(4);
    }
    writeFloat16(A3) {
      const g3 = r.encode16BitFloat(A3);
      this.writeUInt16(g3);
    }
    writeFloat32(A3) {
      this.__reserve(4), this.__dataView.setFloat32(this.__byteOffset, A3, true), this.__offset(4);
    }
    writeUInt8Array(A3, g3 = true) {
      const I3 = (A3.length, A3.length);
      this.__reserve(I3 + (g3 ? 4 : 0)), g3 && this.writeUInt32(I3);
      for (let g4 = 0; g4 < I3; g4++)
        this.writeUInt8(A3[g4]);
    }
    writeUInt16Array(A3, g3 = true) {
      const I3 = (A3.length, A3.length);
      this.__reserve(2 * I3 + (g3 ? 4 : 0)), g3 && this.writeUInt32(I3);
      for (let g4 = 0; g4 < I3; g4++)
        this.writeUInt16(A3[g4]);
    }
    writeUInt32Array(A3, g3 = true) {
      const I3 = (A3.length, A3.length);
      this.__reserve(4 * I3 + (g3 ? 4 : 0)), g3 && this.writeUInt32(I3);
      for (let g4 = 0; g4 < I3; g4++)
        this.writeUInt32(A3[g4]);
    }
    writeFloat32Array(A3, g3 = true) {
      const I3 = (A3.length, A3.length);
      this.__reserve(4 * I3 + (g3 ? 4 : 0)), g3 && this.writeUInt32(I3);
      for (let g4 = 0; g4 < I3; g4++)
        this.writeFloat32(A3[g4]);
    }
    writeStr(A3, g3 = true) {
      const I3 = A3.length;
      this.__reserve(4 * I3 + (g3 ? 4 : 0)), g3 && this.writeUInt32(I3);
      for (let g4 = 0; g4 < I3; g4++)
        this.writeFloat32(A3.charCodeAt(g4));
    }
    writeSInt32Vec2(A3) {
      this.writeSInt32(A3.x), this.writeSInt32(A3.y);
    }
    writeUInt32Vec2(A3) {
      this.writeUInt32(A3.x), this.writeUInt32(A3.y);
    }
    writeFloat16Vec2(A3) {
      this.writeFloat16(A3.x), this.writeFloat16(A3.y);
    }
    writeFloat32Vec2(A3) {
      this.writeFloat32(A3.x), this.writeFloat32(A3.y);
    }
    writeFloat16Vec3(A3) {
      this.writeFloat16(A3.x), this.writeFloat16(A3.y), this.writeFloat16(A3.z);
    }
    writeFloat32Vec3(A3) {
      this.writeFloat32(A3.x), this.writeFloat32(A3.y), this.writeFloat32(A3.z);
    }
    writeFloat16Quat(A3) {
      this.writeFloat16(A3.x), this.writeFloat16(A3.y), this.writeFloat16(A3.z), this.writeFloat16(A3.w);
    }
    writeFloat32Quat(A3) {
      this.writeFloat32(A3.x), this.writeFloat32(A3.y), this.writeFloat32(A3.z), this.writeFloat32(A3.w);
    }
    writeRGBFloat32Color(A3) {
      this.writeFloat32(A3.r), this.writeFloat32(A3.g), this.writeFloat32(A3.b);
    }
    writeRGBAFloat32Color(A3) {
      this.writeFloat32(A3.r), this.writeFloat32(A3.g), this.writeFloat32(A3.b), this.writeFloat32(A3.a);
    }
    writeRGBUInt8Color(A3) {
      this.writeUInt8(A3.r), this.writeUInt8(A3.g), this.writeUInt8(A3.b);
    }
    writeRGBAUInt8Color(A3) {
      this.writeUInt8(A3.r), this.writeUInt8(A3.g), this.writeUInt8(A3.b), this.writeUInt8(A3.a);
    }
    writeBox2(A3) {
      this.writeFloat32Vec2(A3.p0), this.writeFloat32Vec2(A3.p1);
    }
    writeBox3(A3) {
      this.writeFloat32Vec3(A3.p0), this.writeFloat32Vec3(A3.p1);
    }
    writePadd(A3) {
      const g3 = A3 - this.__byteOffset;
      this.__reserve(g3), this.__offset(g3);
    }
    writeAlignment(A3) {
      const g3 = this.__byteOffset % A3;
      g3 != 0 && (this.__reserve(A3 - g3), this.__offset(A3 - g3));
    }
  }, BooleanOperatorInput: class extends tg {
  }, BooleanOperatorOutput: class extends gg {
  }, BooleanParameter: fA, Box2: Q, Box2Parameter: vA, Box3: b, Box3Parameter: kA, CADAssembly: lC, CADAsset: aC, CADBody: dC, CADPart: nC, Camera: IC, CameraManipulator: SC, ChildAddedEvent: oA, Circle: zg, Color: l, ColorAttribute: Hg, ColorOperatorInput: class extends tg {
  }, ColorOperatorOutput: class extends gg {
  }, ColorParameter: xA, get ColorSpace() {
    return pA;
  }, CompoundGeom: Mg, Cone: Og, ControllerAddedEvent: W, CountChangedEvent: Y, Cross: Tg, Cuboid: jg, CuttingPlane: sC, Cylinder: qg, DataImage: CI, Disc: $g, EnvMap: RI, EnvMapAssignedEvent: K, EnvMapShader: ii, EnvProjectionShader: be, EulerAngles: n, EventEmitter: V, FRAMEBUFFER: Ki, FatLinesMaterial: HI, FatLinesShader: Ze, FatPointsMaterial: WI, FatPointsShader: Xe, FileImage: eI, FileImage2D: class extends eI {
    constructor(A3, g3 = {}) {
      console.warn("FileImage2D is becoming deprecated in favor of simple FileImage"), super(A3, g3);
    }
  }, FilePathParameter: cg, FlatSurfaceMaterial: YI, FlatSurfaceShader: ue, Float32: 6, Frustum: class {
    constructor(A3, g3, I3, C3, i3, e3) {
      this.planes = [A3 || new Z(), g3 || new Z(), I3 || new Z(), C3 || new Z(), i3 || new Z(), e3 || new Z()];
    }
    setFromMatrix(A3) {
      const g3 = A3, I3 = this.planes;
      I3[0].set(g3.m03 - g3.m00, g3.m13 - g3.m10, g3.m23 - g3.m20, g3.m33 - g3.m30), I3[1].set(g3.m03 + g3.m00, g3.m13 + g3.m10, g3.m23 + g3.m20, g3.m33 + g3.m30), I3[2].set(g3.m03 + g3.m01, g3.m13 + g3.m11, g3.m23 + g3.m21, g3.m33 + g3.m31), I3[3].set(g3.m03 - g3.m01, g3.m13 - g3.m11, g3.m23 - g3.m21, g3.m33 - g3.m31), I3[4].set(g3.m03 - g3.m02, g3.m13 - g3.m12, g3.m23 - g3.m22, g3.m33 - g3.m32), I3[5].set(g3.m03 + g3.m02, g3.m13 + g3.m12, g3.m23 + g3.m22, g3.m33 + g3.m32), I3.forEach((A4) => A4.normalizeInPlace());
    }
    intersectsBox(A3) {
      const g3 = new o(), I3 = this.planes, {min: C3, max: i3} = A3;
      for (let A4 = 0; A4 < 6; A4++) {
        const e3 = I3[A4];
        if (g3.x = e3.normal.x > 0 ? i3.x : C3.x, g3.y = e3.normal.y > 0 ? i3.y : C3.y, g3.z = e3.normal.z > 0 ? i3.z : C3.z, e3.distanceToPoint(g3) < 0)
          return false;
      }
      return true;
    }
    toJSON() {
      return {p0: this.planes[0].toJSON(), p1: this.planes[1].toJSON(), p2: this.planes[2].toJSON(), p3: this.planes[3].toJSON(), p4: this.planes[4].toJSON(), p5: this.planes[5].toJSON()};
    }
    fromJSON(A3) {
      this.planes[0].fromJSON(A3.p0), this.planes[1].fromJSON(A3.p1), this.planes[2].fromJSON(A3.p2), this.planes[3].fromJSON(A3.p3), this.planes[4].fromJSON(A3.p4), this.planes[5].fromJSON(A3.p5);
    }
    toString() {
      return t.stringifyJSONWithFixedPrecision(this.toJSON());
    }
  }, GIFImage: uI, GLBaseViewport: pi, GLBillboardsPass: $e, GLBoundingBoxPass: class extends bC {
    constructor() {
      super(), this.boxes = [], this.dirtyBoxes = new Set(), this.freeIndices = [], this.idToIndex = [], this.drawCount = 0, this.indexArrayUpdateNeeded = false, this.__updateRequested = false, this.__modelMatrixArray = [], this.__treeItemDataArray = [], this.__tintColorArray = [], this.__indexArray = new Float32Array(0), this.__width = 0;
    }
    getPassType() {
      return EC.OPAQUE;
    }
    init(A3, g3) {
      super.init(A3, g3);
      const I3 = this.__renderer.gl;
      this.glgeom = new ji(I3, new _g(1, 1, 1)), this.glshader = new Ce(I3);
    }
    itemAddedToScene(A3, g3) {
      return false;
    }
    itemRemovedFromScene(A3, g3) {
      return false;
    }
    addTreeItem(A3, g3 = true) {
      if (A3 instanceof ag && (this.bindTreeItem(A3), g3)) {
        for (const g4 of A3.getChildren())
          g4 && this.addTreeItem(g4);
        A3.on("childAdded", (A4) => {
          this.addTreeItem(A4.childItem);
        }), A3.on("childRemoved", (A4) => {
          this.unbindTreeItem(A4.childItem);
        });
      }
    }
    bindTreeItem(A3) {
      let g3, I3 = this.freeIndices.pop();
      g3 = I3 || this.boxes.length, this.idToIndex[A3.getId()] = g3;
      const C3 = () => {
        A3.isVisible() ? (this.drawCount++, this.dirtyBoxes.add(g3)) : this.drawCount--, this.indexArrayUpdateNeeded = true;
      };
      A3.on("visibilityChanged", C3);
      const i3 = () => {
        A3.isVisible() && (this.dirtyBoxes.add(g3), this.emit("updated"));
      };
      A3.globalXfoParam.on("valueChanged", i3), A3.boundingBoxParam.on("valueChanged", i3), A3.isVisible() && this.drawCount++, this.boxes[g3] = {treeItem: A3, visibilityChanged: C3, xfoChanged: i3}, this.indexArrayUpdateNeeded = true, this.__updateRequested = true, this.emit("updated");
    }
    unbindTreeItem(A3) {
      if (!(A3.getId() in this.idToIndex))
        return void console.warn("Billboard already removed.");
      const g3 = this.idToIndex[A3.getId()], I3 = this.boxes[g3];
      A3.off("visibilityChanged", I3.visibilityChanged), A3.globalXfoParam.off("valueChanged", I3.xfoChanged), A3.boundingBoxParam.off("valueChanged", I3.xfoChanged), this.boxes[g3] = null, this.freeIndices.push(g3), A3.isVisible() && this.drawCount--, this.indexArrayUpdateNeeded = true, this.__updateRequested = true, this.__updateBoxes(), this.emit("updated");
    }
    __populateBoxesDataArray(A3, g3, I3) {
      const C3 = A3.treeItem;
      let i3, e3;
      C3 instanceof kI ? (i3 = new l(1, 0, 0, 1), e3 = C3.geomMatParam.value) : (i3 = new l(0, 0, 1, 1), e3 = C3.globalXfoParam.value.toMat4());
      const t3 = C3.boundingBoxParam.value, B3 = 8 * g3 * 4, o3 = new s(new Float32Array(I3.buffer, 4 * B3, 4)), a3 = new s(new Float32Array(I3.buffer, 4 * (B3 + 4), 4)), n3 = new s(new Float32Array(I3.buffer, 4 * (B3 + 8), 4)), d3 = new s(new Float32Array(I3.buffer, 4 * (B3 + 12), 4)), h3 = new s(new Float32Array(I3.buffer, 4 * (B3 + 16), 4)), c3 = new s(new Float32Array(I3.buffer, 4 * (B3 + 24), 4)), r3 = new s(new Float32Array(I3.buffer, 4 * (B3 + 28), 4));
      o3.set(0, 0, 0, 0), a3.set(e3.xAxis.x, e3.yAxis.x, e3.zAxis.x, e3.translation.x), n3.set(e3.xAxis.y, e3.yAxis.y, e3.zAxis.y, e3.translation.y), d3.set(e3.xAxis.z, e3.yAxis.z, e3.zAxis.z, e3.translation.z), h3.set(i3.r, i3.g, i3.b, i3.a), c3.set(t3.p0.x, t3.p0.y, t3.p0.z, 0), r3.set(t3.p1.x, t3.p1.y, t3.p1.z, 0);
    }
    __updateIndexArray() {
      const A3 = this.__gl;
      this.__indexArray && this.__indexArray.length != this.drawCount && (A3.deleteBuffer(this.__instanceIdsBuffer), this.__instanceIdsBuffer = void 0), this.__indexArray = new Float32Array(this.drawCount);
      let g3 = 0;
      for (let A4 = 0; A4 < this.boxes.length; A4++)
        this.boxes[A4] && this.boxes[A4].treeItem.isVisible() && (this.__indexArray[g3] = A4, g3++);
      this.__instanceIdsBuffer || (this.__instanceIdsBuffer = A3.createBuffer()), A3.bindBuffer(A3.ARRAY_BUFFER, this.__instanceIdsBuffer), A3.bufferData(A3.ARRAY_BUFFER, this.__indexArray, A3.STATIC_DRAW), this.indexArrayUpdateNeeded = false;
    }
    __updateBoxes() {
      this.indexArrayUpdateNeeded && this.__updateIndexArray();
      const A3 = this.__renderer.gl;
      let g3 = Math.round(Math.sqrt(8 * (this.boxes.length - this.freeIndices.length)) + 0.5);
      g3 % 8 != 0 && (g3 += 8 - g3 % 8), this.__width = g3, this.__drawItemsTexture ? this.__drawItemsTexture.resize(g3, g3) : (this.__drawItemsTexture = new HC(A3, {format: "RGBA", type: "FLOAT", width: g3, height: g3, filter: "NEAREST", wrap: "CLAMP_TO_EDGE", mipMapped: false}), this.__drawItemsTexture.clear()), this.__indexArray.forEach((A4) => {
        A4 != -1 && this.__updateBox(A4);
      }), this.__updateRequested = false;
    }
    __updateBox(A3) {
      if (this.drawCount == 0 || !this.__drawItemsTexture)
        return;
      const g3 = this.boxes[A3];
      if (!g3.treeItem.isVisible())
        return;
      const I3 = this.__gl, C3 = new Float32Array(32);
      this.__populateBoxesDataArray(g3, 0, C3), I3.bindTexture(I3.TEXTURE_2D, this.__drawItemsTexture.glTex);
      const i3 = 8 * A3 % this.__width, e3 = Math.floor(8 * A3 / this.__width), t3 = this.__drawItemsTexture.getType(), B3 = this.__drawItemsTexture.getFormat();
      if (t3 == I3.FLOAT)
        I3.texSubImage2D(I3.TEXTURE_2D, 0, i3, e3, 8, 1, B3, t3, C3);
      else {
        const A4 = r.convertFloat32ArrayToUInt16Array(C3);
        I3.texSubImage2D(I3.TEXTURE_2D, 0, i3, e3, 8, 1, B3, t3, A4);
      }
    }
    draw(A3) {
      if (this.drawCount == 0)
        return;
      this.__updateRequested && this.__updateBoxes(), this.dirtyBoxes.size > 0 && (this.dirtyBoxes.forEach((A4) => {
        this.__updateBox(A4);
      }), this.dirtyBoxes.clear()), this.indexArrayUpdateNeeded && this.__updateIndexArray();
      const g3 = this.__gl;
      this.glshader.bind(A3), this.glgeom.bind(A3);
      const I3 = A3.unifs;
      if (g3.uniform1i(I3.occlusionCulling.location, 0), g3.floatTexturesSupported && g3.drawElementsInstanced) {
        this.__drawItemsTexture.bindToUniform(A3, I3.instancesTexture), g3.uniform1i(I3.instancesTextureSize.location, this.__width);
        {
          const I4 = A3.attrs.instancedIds.location;
          g3.enableVertexAttribArray(I4), g3.bindBuffer(g3.ARRAY_BUFFER, this.__instanceIdsBuffer), g3.vertexAttribPointer(I4, 1, g3.FLOAT, false, 4, 0), g3.vertexAttribDivisor(I4, 1);
        }
        g3.uniform1i(I3.instancedDraw.location, 1), A3.bindViewports(I3, () => {
          this.glgeom.drawInstanced(A3, this.drawCount);
        });
      } else {
        const C3 = this.__indexArray.length;
        for (let i3 = 0; i3 < C3; i3++)
          A3.bindViewports(I3, () => {
            g3.drawQuad();
          });
      }
    }
  }, GLCADPass: class extends bC {
    constructor(A3 = false) {
      super(), console.warn("GLCADPass is deprecated. No need to install this pass in the renderer.");
    }
    itemAddedToScene(A3, g3) {
      return false;
    }
    itemRemovedFromScene(A3, g3) {
      return false;
    }
  }, GLFbo: fC, GLGeom: Wi, GLGeomItem: ge, GLGeomItemChangeType: {GEOMITEM_CHANGED: 0, GEOM_CHANGED: 1, VISIBILITY_CHANGED: 2, HIGHLIGHT_CHANGED: 3}, GLGeomItemFlags: Ae, GLGeomItemSet: Ge, GLLines: ji, GLLinesPass: Pe, GLMaterial: _i, GLMaterialGeomItemSets: me, GLMesh: Yi, GLOpaqueGeomsPass: _e, GLOverlayPass: At, GLPass: bC, GLPoints: Oi, GLRenderTarget: LC, GLRenderer: re, GLShader: DC, GLShaderMaterials: Qe, GLStandardGeomsPass: De, GLTexture2D: HC, GLTransparentGeomsPass: Oe, GLViewport: Ni, GeomItem: kI, GeomLibrary: OI, GeometryParameter: hg, Grid: Pg, GridTreeItem: ZC, GrowingPacker: S, HDRImage: BI, IGeomShaderBinding: xC, ImageParameter: OA, IndexEvent: p, InstanceItem: MI, IntersectionData: H, ItemEvent: ng, ItemSetParameter: dg, KeyboardEvent: J, KinematicGroup: tC, LDRImage: tI, LDRVideo: oI, Label: SI, LabelManager: VI, LatLongEnvProjectionShader: class extends be {
    constructor(A3) {
      super(A3), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'envmap-equirect.glsl'\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\n\nuniform color envMap;\nuniform sampler2D envMapTex;\nuniform int envMapTexType;\n\nuniform float exposure;\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec2 texCoord = latLongUVsFromDir(normalize(v_worldDir));\n  vec4 env = getColorParamValue(envMap, envMapTex, envMapTexType, texCoord);\n  fragColor = vec4(env.rgb/env.a, 1.0);\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n");
    }
  }, Lines: Yg, LinesCuboid: _g, LinesMaterial: KI, LinesProxy: Jg, LinesShader: Ve, ListParameter: $A, Mat3: d, Mat3OperatorInput: class extends tg {
  }, Mat3OperatorOutput: class extends gg {
  }, Mat3Parameter: TA, Mat4: h, Mat4OperatorInput: class extends tg {
  }, Mat4OperatorOutput: ig, Mat4Parameter: _A, Material: XI, MaterialColorParam: Qg, MaterialFloatParam: mg, MaterialGroup: BC, MaterialLibrary: jI, MaterialParameter: rg, MathFunctions: r, Mesh: Kg, MeshProxy: Dg, MultiChoiceParameter: DA, NameChangedEvent: sA, NormalsShader: class extends DC {
    constructor(A3) {
      super(A3, "NormalsShader"), this.setShaderStage("VERTEX_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\ninstancedattribute vec3 positions;\ninstancedattribute vec3 normals;\nattribute vec2 vertexIDs;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\n\nuniform float normalLength;\n\nimport 'drawItemTexture.glsl'\nimport 'modelMatrix.glsl'\n\n/* VS Outputs */\nvarying float v_weight;\n\nvoid main(void) {\n  mat4 modelMatrix = getModelMatrix(geomItemId);\n  mat4 modelViewProjectionMatrix = projectionMatrix * viewMatrix * modelMatrix;\n  if (vertexIDs.x == 0.0) {\n    gl_Position = modelViewProjectionMatrix * vec4(positions, 1.0);\n    v_weight = 1.0;\n  }\n  else {\n    gl_Position = modelViewProjectionMatrix * vec4(positions+(normals*normalLength), 1.0);\n    v_weight = 0.0;\n  }\n}\n"), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nuniform color normalColor;\n\n/* VS Outputs */\nvarying float v_weight;\n\nvoid main(void) {\n  gl_FragColor = normalColor;\n  gl_FragColor.a = v_weight;\n}\n");
    }
  }, NumberOperatorInput: class extends tg {
  }, NumberOperatorOutput: class extends gg {
  }, NumberParameter: JA, ObjAsset: class extends $I {
    constructor(A3) {
      super(A3), this.splitObjects = new fA("splitObjects", false), this.splitGroupsIntoObjects = new fA("splitGroupsIntoObjects", false), this.loadMtlFile = new fA("loadMtlFile", true), this.unitsConversion = new JA("unitsConversion", 1), this.defaultShader = new jA("defaultShader", ""), this.splitObjectsParam = new fA("splitObjects", false), this.splitGroupsIntoObjectsParam = new fA("splitGroupsIntoObjects", false), this.loadMtlFileParam = new fA("loadMtlFile", true), this.unitsConversionParam = new JA("unitsConversion", 1), this.defaultShaderParam = new jA("defaultShader", ""), this.addParameter(this.splitObjectsParam), this.addParameter(this.splitGroupsIntoObjectsParam), this.addParameter(this.loadMtlFileParam), this.addParameter(this.unitsConversionParam), this.addParameter(this.defaultShaderParam);
    }
    load(A3) {
      return this.loaded = false, new Promise((g3, I3) => {
        const C3 = A3.substring(0, A3.lastIndexOf("/")) + "/", i3 = (A4) => {
          const g4 = A4.split("\n"), I4 = /\s+/;
          let i4;
          const e4 = function(A5) {
            if (A5.length == 3)
              return new l(parseFloat(A5[0]), parseFloat(A5[1]), parseFloat(A5[2]));
            throw new Error("Unable to parse a color from the following parts:" + A5.join("_"));
          }, t4 = (A5, g5) => {
            const I5 = new eI(A5);
            return I5.load(C3 + g5), I5;
          };
          for (let A5 = 0; A5 < g4.length; A5++) {
            let C4 = g4[A5].trim();
            if (C4.startsWith("#"))
              continue;
            C4.includes("#") && (C4 = C4.substring(0, C4.indexOf("#")).trim());
            const B3 = C4.split(I4), o3 = B3.shift(), s4 = B3.join(" ");
            switch (o3) {
              case "newmtl":
                i4 = new XI(s4), i4.setShaderName("StandardSurfaceShader"), this.materialLibrary.addMaterial(i4);
                break;
              case "Kd": {
                const A7 = i4.getParameter("BaseColor");
                A7.value = e4(B3), A7 instanceof Qg && (A7.colorSpace, pA.Linear);
                break;
              }
              case "map_Kd": {
                const A7 = i4.getParameter("BaseColor");
                A7 instanceof Qg && A7.setImage(t4("map_Kd", B3[0]));
                break;
              }
              case "Ks":
                const A6 = (parseFloat(B3[0]) + parseFloat(B3[1]) + parseFloat(B3[2])) / 3;
                i4.getParameter("Roughness").value = 1 - A6, i4.getParameter("Reflectance").value = A6;
                break;
              case "map_Ks":
                const g5 = i4.getParameter("Roughness");
                g5 instanceof mg && g5.setImage(t4("map_Ks", B3[0])), i4.getParameter("Reflectance").value = 0.2;
                break;
              case "d":
                const I5 = parseFloat(s4);
                I5 < 1 && (i4.setShaderName("TransparentSurfaceShader"), i4.getParameter("Opacity").value = I5);
                break;
              case "map_d":
                i4.getParameter("alpha").value = parseFloat(B3[0]);
                break;
              case "map_bump":
                const C5 = i4.getParameter("Normal");
                C5 instanceof Qg && C5.setImage(t4("normal", B3[0]));
            }
          }
        }, e3 = (A4) => new Promise((g4) => {
          rA(A4, (A5) => {
            FA.incrementWorkDone(1), i3(A5), FA.incrementWorkDone(1), g4();
          });
        }), t3 = [], s3 = [], a3 = [], n3 = {}, d3 = (A4) => mA(this, void 0, void 0, function* () {
          const g4 = A4.split("\n"), I4 = /\s+/;
          let i4, B3, o3 = 0;
          const l3 = (A5) => {
            if (A5 in n3) {
              let g5 = 1;
              for (; A5 + String(g5) in n3; )
                g5++;
              A5 += String(g5);
            }
            i4 = {verticesRemapping: {}, texCoordsRemapping: {}, normalsRemapping: {}, vertexIndices: [], texCoordIndices: [], normalIndices: [], numVertices: 0, numTexCoords: 0, numNormals: 0, faceCounts: [], material: B3}, n3[A5] = i4, o3++;
          };
          l3("geom");
          const d4 = this.splitGroupsIntoObjectsParam.value;
          for (let A5 = 0; A5 < g4.length; A5++) {
            let h4 = g4[A5].trim();
            if (h4.startsWith("#"))
              continue;
            h4.includes("#") && (h4 = h4.substring(0, h4.indexOf("#")).trim());
            const c4 = h4.split(I4), r3 = c4.shift(), G3 = c4.join(" ");
            switch (r3) {
              case "":
              case "s":
                continue;
              case "mtllib":
                if (!this.loadMtlFileParam.value)
                  continue;
                FA.incrementWorkload(2);
                const A6 = C3 + G3;
                A6 && (yield e3(A6));
                break;
              case "o":
                l3(G3);
                break;
              case "usemtl":
                B3 = G3, l3(G3 + Object.keys(n3).length);
                break;
              case "g":
                d4 && l3(G3 ? c4.join("_") : "Group" + o3);
                break;
              case "v":
                t3.push(c4.map((A7) => parseFloat(A7)));
                break;
              case "vt":
                a3.push(c4.map((A7) => parseFloat(A7)));
                break;
              case "vn":
                s3.push(c4.map((A7) => parseFloat(A7)));
                break;
              case "f": {
                const A7 = [], g5 = [], I5 = [];
                for (let C4 = 0, e4 = c4.length; C4 < e4; C4++) {
                  const e5 = c4[C4].split("/").map((A8) => parseInt(A8) - 1), t4 = e5[0];
                  let B4 = i4.verticesRemapping[t4];
                  if (B4 == null && (B4 = i4.numVertices, i4.verticesRemapping[t4] = B4, i4.numVertices++), A7.push(B4), e5.length > 1 && !isNaN(e5[1])) {
                    const A8 = e5[1];
                    g5.push(A8);
                  }
                  if (e5.length > 2 && !isNaN(e5[2])) {
                    const A8 = e5[2];
                    I5.push(A8);
                  }
                }
                i4.vertexIndices.push(A7), I5.length > 0 && i4.normalIndices.push(I5), g5.length > 0 && i4.texCoordIndices.push(g5), i4.faceCounts[A7.length - 3] == null && (i4.faceCounts[A7.length - 3] = []), i4.faceCounts[A7.length - 3]++;
                break;
              }
              default:
                console.warn("Unhandled line:" + h4);
            }
          }
        }), h3 = () => {
          for (const A4 in n3)
            n3[A4].numVertices != 0 && c3(A4, n3[A4]);
          this.emit("loaded"), this.getGeometryLibrary().emit("loaded"), this.emit("geomsLoaded"), g3();
        }, c3 = (A4, g4) => {
          for (let A5 = 0; A5 < g4.faceCounts.length; A5++)
            g4.faceCounts[A5] == null && (g4.faceCounts[A5] = 0);
          const I4 = g4.numVertices, C4 = new Kg();
          C4.setDebugName(A4), C4.setFaceCounts(g4.faceCounts), C4.setNumVertices(I4);
          const i4 = C4.getVertexAttribute("positions"), e4 = this.unitsConversionParam.value;
          for (const A5 in g4.verticesRemapping) {
            const I5 = Number.parseInt(A5), C5 = g4.verticesRemapping[I5];
            i4.getValueRef(C5).set(t3[I5][0] * e4, t3[I5][1] * e4, t3[I5][2] * e4);
          }
          let l3, n4;
          g4.normalIndices.length > 0 && (l3 = new Zg(), C4.addVertexAttribute("normals", l3)), g4.texCoordIndices.length > 0 && (n4 = new yg(), C4.addVertexAttribute("texCoords", n4));
          const d4 = Array(g4.faceCounts.length).fill(0);
          for (let A5 = 0; A5 < g4.vertexIndices.length; A5++) {
            const I5 = g4.vertexIndices[A5];
            let i5 = 0;
            for (let A6 = 0; A6 < I5.length - 3; ++A6)
              g4.faceCounts[A6] && (i5 += g4.faceCounts[A6]);
            if (i5 += d4[I5.length - 3], d4[I5.length - 3]++, C4.setFaceVertexIndices(i5, I5), l3) {
              const I6 = g4.normalIndices[A5];
              for (let A6 = 0; A6 < I6.length; A6++) {
                const g5 = new o(s3[I6[A6]][0], s3[I6[A6]][1], s3[I6[A6]][2]);
                l3.setFaceVertexValue(i5, A6, g5);
              }
            }
            if (n4 && g4.texCoordIndices.length == g4.vertexIndices.length) {
              const I6 = g4.texCoordIndices[A5];
              for (let A6 = 0; A6 < I6.length; A6++) {
                const g5 = new B(a3[I6[A6]][0], a3[I6[A6]][1]);
                n4.setFaceVertexValue(i5, A6, g5);
              }
            }
          }
          const h4 = new kI(A4, C4), c4 = C4.getBoundingBox().center();
          {
            const A5 = c4.negate(), g5 = C4.getVertexAttribute("positions");
            for (let I5 = 0; I5 < g5.getCount(); I5++)
              g5.getValueRef(I5).addInPlace(A5);
            C4.setBoundingBoxDirty();
          }
          if (h4.localXfoParam.value = new m(c4), g4.material != null && this.materialLibrary.hasMaterial(g4.material))
            h4.materialParam.value = this.materialLibrary.getMaterial(g4.material);
          else {
            const g5 = this.defaultShaderParam.value, I5 = new XI(A4 + " mat");
            I5.setShaderName(g5 != "" ? g5 : "StandardSurfaceShader"), this.materialLibrary.addMaterial(I5), h4.materialParam.value = I5;
          }
          this.addChild(h4, false);
        };
        (() => {
          FA.incrementWorkload(2), rA(A3, (A4) => {
            FA.incrementWorkDone(1), d3(A4).then(() => {
              h3(), FA.incrementWorkDone(1);
            });
          }, (A4) => {
            this.emit("error", A4), I3(A4);
          });
        })();
      });
    }
  }, OctahedralEnvProjectionShader: class extends be {
    constructor(A3) {
      super(A3), this.setShaderStage("FRAGMENT_SHADER", "\nprecision highp float;\n#define GLSLIFY 1\n\nimport 'GLSLUtils.glsl'\nimport 'envmap-octahedral.glsl'\nimport 'gamma.glsl'\nimport 'materialparams.glsl'\n\nuniform color envMap;\nuniform sampler2D envMapTex;\nuniform int envMapTexType;\n\nuniform float exposure;\n\n/* VS Outputs */\nvarying vec3 v_worldDir;\n\n#ifdef ENABLE_ES3\n  out vec4 fragColor;\n#endif\nvoid main(void) {\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec2 texCoord = dirToSphOctUv(normalize(v_worldDir));\n  vec4 env = getColorParamValue(envMap, envMapTex, envMapTexType, texCoord);\n\n  fragColor = vec4(env.rgb/env.a, 1.0);\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n  fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n");
    }
  }, OpacityStateChangedEvent: _, Operator: eg, OperatorInput: tg, OperatorOutput: gg, get OperatorOutputMode() {
    return KA;
  }, PMIItem: GC, PMIView: mC, POINTER_TYPES: q, Parameter: NA, ParameterAddedEvent: D, ParameterOwner: nA, ParameterRemovedEvent: f, PassType: EC, Plane: AI, PlaneType: Z, PointGrid: kg, Points: Wg, PointsMaterial: pI, PointsProxy: Ng, PointsShader: Se, ProceduralLines: Ug, ProceduralMesh: vg, ProceduralPoints: Lg, Quat: c, QuatOperatorInput: class extends tg {
  }, QuatOperatorOutput: class extends gg {
  }, QuatParameter: zA, RGBA: a, RangeLoadedEvent: M, Ray: G, Rect: xg, RefCounted: lA, Registry: e, ResizedEvent: F, ResourceLoader: VA, SInt16: 3, SInt32: 5, SInt8: 1, Scene: uC, SceneSetEvent: L, ScreenQuadShader: Xi, ScreenSpaceMaterial: NI, ScreenSpaceShader: Ne, SelectabilityChangedEvent: U, SelectedEvent: v, SelectionSet: zI, ShaderLibrary: pC, ShaderNameChangedEvent: k, SimpleSurfaceMaterial: JI, SimpleSurfaceShader: We, Sphere: gI, SphereType: E, StandardSurfaceMaterial: DI, StandardSurfaceShader: Ke, StateChangedEvent: x, StreamFileParsedEvent: z, StringFunctions: t, StringListParameter: qA, StringParameter: jA, StructParameter: Ag, SystemDesc: g, TexturedChangedEvent: T, Torus: II, Touch: eA, TreeItem: ag, TreeItemParameter: lg, UInt16: 2, UInt32: 4, UInt8: 0, UnpackHDRShader: vC, VLAAsset: RC, VRController: class extends Di {
  }, VRViewport: class extends Mi {
  }, Vec2: B, Vec2Attribute: yg, Vec2OperatorInput: class extends tg {
  }, Vec2OperatorOutput: class extends gg {
  }, Vec2Parameter: MA, Vec3: o, Vec3Attribute: Zg, Vec3OperatorInput: class extends tg {
  }, Vec3OperatorOutput: class extends gg {
  }, Vec3Parameter: LA, Vec4: s, Vec4Attribute: Xg, Vec4OperatorInput: class extends tg {
  }, Vec4OperatorOutput: Ig, Vec4Parameter: UA, Version: WA, VideoStreamImage2D: wI, ViewChangedEvent: P, VisibilityChangedEvent: O, XRController: Di, XRControllerEvent: gA, XRHead: Ji, XRPoseEvent: IA, XRViewChangedEvent: j, XRViewManipulator: fi, XRViewport: Mi, XRef: QC, Xfo: m, XfoOperatorInput: Bg, XfoOperatorOutput: Cg, XfoParameter: PA, XrViewportEvent: CA, ZeaMouseEvent: iA, ZeaPointerEvent: AA, ZeaTouchEvent: tA, ZeaUIEvent: N, ZeaWheelEvent: BA, checkFramebuffer: MC, create3DContext: wC, genDataTypeDesc: kC, generateShaderGeomBinding: _C, getFileFolder: function(A3) {
    return A3.substring(0, A3.lastIndexOf("/")) + "/";
  }, labelManager: FI, libsRegistry: gt, loadBinfile: GA, loadJSONfile: function(A3, g3, I3, C3) {
    cA(A3, "json", (A4) => {
      g3(A4.response, A4);
    }, (g4) => {
      if (I3 == null)
        throw new Error("Unable to XHR File:" + A3);
      I3(g4);
    }, C3);
  }, loadTextfile: rA, loadXMLfile: function(A3, g3, I3, C3) {
    cA(A3, "document", (A4) => {
      g3(A4.responseXML);
    }, (g4) => {
      if (I3 == null)
        throw new Error("Unable to XHR File:" + A3);
      I3(g4);
    }, C3);
  }, resourceLoader: FA, shaderLibrary: NC});
  var Ct = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
  function it(A3, g3, I3) {
    return A3(I3 = {path: g3, exports: {}, require: function(A4, g4) {
      return function() {
        throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
      }(g4 == null && I3.path);
    }}, I3.exports), I3.exports;
  }
  function et(A3) {
    if (A3.__esModule)
      return A3;
    var g3 = Object.defineProperty({}, "__esModule", {value: true});
    return Object.keys(A3).forEach(function(I3) {
      var C3 = Object.getOwnPropertyDescriptor(A3, I3);
      Object.defineProperty(g3, I3, C3.get ? C3 : {enumerable: true, get: function() {
        return A3[I3];
      }});
    }), g3;
  }
  var tt = it(function(A3) {
    !function(g3) {
      var I3 = {bytesToHex: function(A4) {
        return function(A5) {
          return A5.map(function(A6) {
            return g4 = A6.toString(16), I4 = 2, g4.length > I4 ? g4 : Array(I4 - g4.length + 1).join("0") + g4;
            var g4, I4;
          }).join("");
        }(A4);
      }, hexToBytes: function(A4) {
        if (A4.length % 2 == 1)
          throw new Error("hexToBytes can't have a string with an odd number of characters.");
        return A4.indexOf("0x") === 0 && (A4 = A4.slice(2)), A4.match(/../g).map(function(A5) {
          return parseInt(A5, 16);
        });
      }};
      A3.exports ? A3.exports = I3 : g3.convertHex = I3;
    }(Ct);
  });
  var Bt = it(function(A3) {
    !function(g3) {
      var I3 = {bytesToString: function(A4) {
        return A4.map(function(A5) {
          return String.fromCharCode(A5);
        }).join("");
      }, stringToBytes: function(A4) {
        return A4.split("").map(function(A5) {
          return A5.charCodeAt(0);
        });
      }};
      I3.UTF8 = {bytesToString: function(A4) {
        return decodeURIComponent(escape(I3.bytesToString(A4)));
      }, stringToBytes: function(A4) {
        return I3.stringToBytes(unescape(encodeURIComponent(A4)));
      }}, A3.exports ? A3.exports = I3 : g3.convertString = I3;
    }(Ct);
  });
  it(function(A3) {
    !function(g3) {
      var I3 = {};
      A3.exports ? (I3.bytesToHex = tt.bytesToHex, I3.convertString = Bt, A3.exports = t3) : (I3.bytesToHex = g3.convertHex.bytesToHex, I3.convertString = g3.convertString, g3.sha256 = t3);
      var C3 = [];
      !function() {
        function A4(A5) {
          for (var g5 = Math.sqrt(A5), I5 = 2; I5 <= g5; I5++)
            if (!(A5 % I5))
              return false;
          return true;
        }
        function g4(A5) {
          return 4294967296 * (A5 - (0 | A5)) | 0;
        }
        for (var I4 = 2, i4 = 0; i4 < 64; )
          A4(I4) && (C3[i4] = g4(Math.pow(I4, 1 / 3)), i4++), I4++;
      }();
      var i3 = [], e3 = function(A4, g4, I4) {
        for (var e4 = A4[0], t4 = A4[1], B3 = A4[2], o3 = A4[3], s3 = A4[4], a3 = A4[5], l3 = A4[6], n3 = A4[7], d3 = 0; d3 < 64; d3++) {
          if (d3 < 16)
            i3[d3] = 0 | g4[I4 + d3];
          else {
            var h3 = i3[d3 - 15], c3 = (h3 << 25 | h3 >>> 7) ^ (h3 << 14 | h3 >>> 18) ^ h3 >>> 3, r3 = i3[d3 - 2], G3 = (r3 << 15 | r3 >>> 17) ^ (r3 << 13 | r3 >>> 19) ^ r3 >>> 10;
            i3[d3] = c3 + i3[d3 - 7] + G3 + i3[d3 - 16];
          }
          var m3 = e4 & t4 ^ e4 & B3 ^ t4 & B3, Q3 = (e4 << 30 | e4 >>> 2) ^ (e4 << 19 | e4 >>> 13) ^ (e4 << 10 | e4 >>> 22), E3 = n3 + ((s3 << 26 | s3 >>> 6) ^ (s3 << 21 | s3 >>> 11) ^ (s3 << 7 | s3 >>> 25)) + (s3 & a3 ^ ~s3 & l3) + C3[d3] + i3[d3];
          n3 = l3, l3 = a3, a3 = s3, s3 = o3 + E3 | 0, o3 = B3, B3 = t4, t4 = e4, e4 = E3 + (Q3 + m3) | 0;
        }
        A4[0] = A4[0] + e4 | 0, A4[1] = A4[1] + t4 | 0, A4[2] = A4[2] + B3 | 0, A4[3] = A4[3] + o3 | 0, A4[4] = A4[4] + s3 | 0, A4[5] = A4[5] + a3 | 0, A4[6] = A4[6] + l3 | 0, A4[7] = A4[7] + n3 | 0;
      };
      function t3(A4, g4) {
        A4.constructor === String && (A4 = I3.convertString.UTF8.stringToBytes(A4));
        var C4 = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], i4 = function(A5) {
          for (var g5 = [], I4 = 0, C5 = 0; I4 < A5.length; I4++, C5 += 8)
            g5[C5 >>> 5] |= A5[I4] << 24 - C5 % 32;
          return g5;
        }(A4), t4 = 8 * A4.length;
        i4[t4 >> 5] |= 128 << 24 - t4 % 32, i4[15 + (t4 + 64 >> 9 << 4)] = t4;
        for (var B3 = 0; B3 < i4.length; B3 += 16)
          e3(C4, i4, B3);
        var o3 = function(A5) {
          for (var g5 = [], I4 = 0; I4 < 32 * A5.length; I4 += 8)
            g5.push(A5[I4 >>> 5] >>> 24 - I4 % 32 & 255);
          return g5;
        }(C4);
        return g4 && g4.asBytes ? o3 : g4 && g4.asString ? I3.convertString.bytesToString(o3) : I3.bytesToHex(o3);
      }
      t3.x2 = function(A4, g4) {
        return t3(t3(A4, {asBytes: true}), g4);
      };
    }(Ct);
  });

  // dist/build/main.js
  var $n = {root: true, children: [{isFallback: true, path: "/_fallback", component: () => Promise.resolve().then(() => require_fallback_7aee0e06()).then((t3) => t3.default)}, {isPage: true, path: "/examples", id: "_examples", component: () => Promise.resolve().then(() => require_examples_0cc77ff1()).then((t3) => t3.default)}, {isIndex: true, isPage: true, path: "/index", id: "_index", component: () => Promise.resolve().then(() => require_index_6246489a()).then((t3) => t3.default)}, {isPage: true, path: "/layout", id: "_layout", component: () => Promise.resolve().then(() => require_layout_33693570()).then((t3) => t3.default)}, {isDir: true, ext: "", children: [{isIndex: true, isPage: true, path: "/login/index", id: "_login_index", component: () => Promise.resolve().then(() => require_index_849ba556()).then((t3) => t3.default)}], path: "/login"}, {isDir: true, children: [{isIndex: true, isPage: true, path: "/sign-in-callback/index", id: "_signInCallback_index", component: () => Promise.resolve().then(() => require_index_913c809f()).then((t3) => t3.default)}], isLayout: true, isReset: true, path: "/sign-in-callback", id: "_signInCallback__reset", component: () => Promise.resolve().then(() => require_reset_c057f75c()).then((t3) => t3.default)}], isLayout: true, path: "/", id: "__layout", component: () => Promise.resolve().then(() => require_layout_bb6274c2()).then((t3) => t3.default)};
  var {tree: yn, routes: bn} = function(t3) {
    const e3 = ["restoreDefaults", "setParamKeys", "setRegex", "setShortPath", "setRank", "assignLayout", "setPrototype", "addMetaChildren", "assignRelations", "setIsIndexable", "assignIndex", "assignAPI", "createFlatList"], n3 = {tree: t3, routes: []};
    for (let t4 of e3) {
      (gn[t4].sync || gn[t4])(n3);
    }
    return n3;
  }($n);
  function _n(e3) {
    let n3, o3;
    return n3 = new We2({props: {routes: bn}}), {c() {
      Bt2(n3.$$.fragment);
    }, m(t3, e4) {
      Dt(n3, t3, e4), o3 = true;
    }, p: t2, i(t3) {
      o3 || (St(n3.$$.fragment, t3), o3 = true);
    }, o(t3) {
      Lt(n3.$$.fragment, t3), o3 = false;
    }, d(t3) {
      Ut(n3, t3);
    }};
  }
  !function(t3, e3 = {target: document.body}, n3 = "hmr", o3 = "app-loaded") {
    const r3 = document.getElementById(n3), s3 = document.createElement("div");
    function i3() {
      removeEventListener(o3, i3), r3 && r3.remove(), s3.style.visibility = null, s3.setAttribute("id", n3);
    }
    s3.style.visibility = "hidden", e3.target.appendChild(s3), r3 ? addEventListener(o3, i3) : i3(), new t3({...e3, target: s3});
  }(class extends Kt {
    constructor(t3) {
      super(), Ht(this, t3, null, _n, a2, {});
    }
  }, {target: document.body}, "routify-app");
})();
