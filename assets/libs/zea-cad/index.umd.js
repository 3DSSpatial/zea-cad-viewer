!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@zeainc/zea-engine")):"function"==typeof define&&define.amd?define(["exports","@zeainc/zea-engine"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).zeaCad={},e.zeaEngine)}(this,(function(e,t){"use strict";const r={CURVE_TYPE_LINE:20,CURVE_TYPE_CIRCLE:21,CURVE_TYPE_ELIPSE:22,CURVE_TYPE_NURBS_CURVE:26},a={SURFACE_TYPE_PLANE:0,SURFACE_TYPE_CONE:1,SURFACE_TYPE_CYLINDER:2,SURFACE_TYPE_SPHERE:3,SURFACE_TYPE_TORUS:4,SURFACE_TYPE_LINEAR_EXTRUSION:5,SURFACE_TYPE_REVOLUTION:6,SURFACE_TYPE_NURBS_SURFACE:8,SURFACE_TYPE_OFFSET_SURFACE:9,SURFACE_TYPE_TRIMMED_RECT_SURFACE:10,SURFACE_TYPE_POLY_PLANE:14,SURFACE_TYPE_FAN:15,SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN:16},n=e=>{switch(e){case r.CURVE_TYPE_LINE:return"CURVE_TYPE_LINE";case r.CURVE_TYPE_CIRCLE:return"CURVE_TYPE_CIRCLE";case r.CURVE_TYPE_ELIPSE:return"CURVE_TYPE_ELIPSE";case r.CURVE_TYPE_NURBS_CURVE:return"CURVE_TYPE_NURBS_CURVE"}},s=e=>{switch(e){case a.SURFACE_TYPE_PLANE:return"SURFACE_TYPE_PLANE";case a.SURFACE_TYPE_CONE:return"SURFACE_TYPE_CONE";case a.SURFACE_TYPE_CYLINDER:return"SURFACE_TYPE_CYLINDER";case a.SURFACE_TYPE_SPHERE:return"SURFACE_TYPE_SPHERE";case a.SURFACE_TYPE_TORUS:return"SURFACE_TYPE_TORUS";case a.SURFACE_TYPE_LINEAR_EXTRUSION:return"SURFACE_TYPE_LINEAR_EXTRUSION";case a.SURFACE_TYPE_REVOLUTION:return"SURFACE_TYPE_REVOLUTION";case a.SURFACE_TYPE_NURBS_SURFACE:return"SURFACE_TYPE_NURBS_SURFACE";case a.SURFACE_TYPE_OFFSET_SURFACE:return"SURFACE_TYPE_OFFSET_SURFACE";case a.SURFACE_TYPE_TRIMMED_RECT_SURFACE:return"SURFACE_TYPE_TRIMMED_RECT_SURFACE";case a.SURFACE_TYPE_POLY_PLANE:return"SURFACE_TYPE_POLY_PLANE";case a.SURFACE_TYPE_FAN:return"SURFACE_TYPE_FAN";case a.SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN:return"SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN"}};class i extends t.Lines{constructor(e=1,t=1){super(),this.__numSpansU=e-1,this.__numSpansV=t-1,this.__rebuild()}__rebuild(){this.setNumVertices((this.__numSpansU+1)*(this.__numSpansV+1)),this.setNumSegments(this.__numSpansU*(this.__numSpansV+1)+(this.__numSpansU+1)*this.__numSpansV);let e=0;for(let t=0;t<=this.__numSpansV;t++)for(let r=0;r<this.__numSpansU;r++){const a=(this.__numSpansU+1)*t+r,n=(this.__numSpansU+1)*t+(r+1);this.setSegmentVertexIndices(e,a,n),e++}for(let t=0;t<this.__numSpansV;t++)for(let r=0;r<=this.__numSpansU;r++){const a=(this.__numSpansU+1)*t+r,n=(this.__numSpansU+1)*(t+1)+r;this.setSegmentVertexIndices(e,a,n),e++}}}class o{constructor(e,t){this.__cadAsset=e,this.__trimSetLibrary=t,this.__curveLibraryBuffer=void 0,this.__meshes=[],this.__hulls=[],this.__formFactors={},this.__maxNumKnots=0}setBinaryBuffers(e,r,a){if(this.__surfaceLibraryBuffer=r,this.cadDataVersion=a,this.__surfaceLibraryReader=new t.BinReader(this.__surfaceLibraryBuffer),this.__surfaceLibrarySize=Math.sqrt(r.byteLength/8),this.__numSurfaces=this.__surfaceLibraryReader.loadUInt32(),this.__totalSurfaceArea=this.__surfaceLibraryReader.loadFloat32(),0==this.__totalSurfaceArea)for(let e=0;e<this.__numSurfaces;e++){const t=this.getSurfaceDims(e),r=t.sizeU*t.sizeV;this.__totalSurfaceArea+=r}this.__curveLibraryBuffer=e,this.__curveLibraryReader=new t.BinReader(this.__curveLibraryBuffer),this.__curveLibrarySize=Math.sqrt(e.byteLength/8),this.__numCurves=this.__curveLibraryReader.loadUInt32()}getCurveBuffer(){return this.__curveLibraryBuffer}getSurfaceBuffer(){return this.__surfaceLibraryBuffer}getNumSurfaces(){return this.__numSurfaces}getNumCurves(){return this.__numCurves}getDetailFactor(e){return Math.pow(2,e)*this.__cadAsset.curvatureToDetail}getCurveDataTexelCoords(e){this.__curveLibraryReader.seek(8+16*e);return{x:this.__curveLibraryReader.loadFloat16(),y:this.__curveLibraryReader.loadFloat16()}}__seekCurveData(e,t=0){const r=this.getCurveDataTexelCoords(e),a=8*r.x+8*r.y*this.__curveLibrarySize;this.__curveLibraryReader.seek(a+t)}getCurveType(e){this.__seekCurveData(e);return this.__curveLibraryReader.loadFloat16()}getCurveTypeLabel(e){const t=this.getCurveType(e);return n(t)}getCurveDims(e){return this.__curveLibraryReader.seek(8+16*e),{addrX:this.__curveLibraryReader.loadFloat16(),addrY:this.__curveLibraryReader.loadFloat16(),curvature:this.__curveLibraryReader.loadFloat16(),length:this.__curveLibraryReader.loadFloat16(),flags:this.__curveLibraryReader.loadFloat16()}}getCurveData(e){const a=this.getCurveDims(e),n=this.getCurveType(e),s=new t.Vec2(this.__curveLibraryReader.loadFloat16(),this.__curveLibraryReader.loadFloat16());switch(n){case r.CURVE_TYPE_LINE:return{curveId:e,dims:a,curveType:"CURVE_TYPE_LINE",domain:s};case r.CURVE_TYPE_CIRCLE:return{curveId:e,dims:a,curveType:"CURVE_TYPE_CIRCLE",domain:s,radius:this.__curveLibraryReader.loadFloat16()};case r.CURVE_TYPE_ELIPSE:return{curveId:e,dims:a,curveType:"SURFACE_TYPE_CYLINDER",domain:s,majorRadius:this.__curveLibraryReader.loadFloat16(),minorRadius:this.__curveLibraryReader.loadFloat16()};case r.CURVE_TYPE_NURBS_CURVE:{const r=this.__curveLibraryReader.loadFloat16(),n=this.__curveLibraryReader.loadFloat16(),i=this.__curveLibraryReader.loadFloat16();this.__curveLibraryReader.advance(4);const o=[];for(let e=0;e<n;e++){const e=new t.Vec4(this.__curveLibraryReader.loadFloat16(),this.__curveLibraryReader.loadFloat16(),this.__curveLibraryReader.loadFloat16(),this.__curveLibraryReader.loadFloat16());o.push(e)}const d=[];for(let e=0;e<i;e++)d.push(this.__curveLibraryReader.loadFloat16());return{curveId:e,dims:a,curveType:"CURVE_TYPE_NURBS_CURVE",domain:s,degree:r,numCPs:n,controlPoints:o,knots:d}}default:console.warn("Invalid Curve Type:",n)}}getSurfaceDataTexelCoords(e){this.__surfaceLibraryReader.seek(8+18*e);return{x:this.__surfaceLibraryReader.loadUFloat16(),y:this.__surfaceLibraryReader.loadUFloat16()}}__seekSurfaceData(e,t=0){const r=this.getSurfaceDataTexelCoords(e),a=8*r.x+8*r.y*this.__surfaceLibrarySize;this.__surfaceLibraryReader.seek(a+t)}getSurfaceType(e){this.__seekSurfaceData(e);return this.__surfaceLibraryReader.loadFloat16()}getSurfaceTypeLabel(e){const t=this.getSurfaceType(e);return s(t)}getSurfaceDims(e){this.__surfaceLibraryReader.seek(8+18*e);return{addrX:this.__surfaceLibraryReader.loadUFloat16(),addrY:this.__surfaceLibraryReader.loadUFloat16(),curvatureU:this.__surfaceLibraryReader.loadFloat16(),curvatureV:this.__surfaceLibraryReader.loadFloat16(),sizeU:this.__surfaceLibraryReader.loadFloat16(),sizeV:this.__surfaceLibraryReader.loadFloat16(),flags:this.__surfaceLibraryReader.loadFloat16(),trimSetId:(()=>{if(this.cadDataVersion.compare([0,0,27])<0){return this.__surfaceLibraryReader.loadFloat16()+(this.__surfaceLibraryReader.loadFloat16()<<8)}return this.__surfaceLibraryReader.loadSInt32From2xFloat16()})()}}getSurfaceData(e,r=!0){const n=this.getSurfaceDims(e),s=this.getSurfaceType(e),i=()=>{const e=new t.Box2;return e.p0.x=this.__surfaceLibraryReader.loadFloat16(),e.p0.y=this.__surfaceLibraryReader.loadFloat16(),e.p1.x=this.__surfaceLibraryReader.loadFloat16(),e.p1.y=this.__surfaceLibraryReader.loadFloat16(),e};switch(n.trimSetId>=0&&r&&(n.trimSet=this.__trimSetLibrary.getTrimSetCurves(n.trimSetId)),s){case a.SURFACE_TYPE_PLANE:return{surfaceId:e,dims:n,surfaceType:"SURFACE_TYPE_PLANE",domain:i()};case a.SURFACE_TYPE_FAN:{const r=i(),a=[],s=n.curvatureU+1;for(let e=0;e<s;e++){const e=new t.Vec2(this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16());a.push(e)}return{surfaceId:e,dims:n,surfaceType:"SURFACE_TYPE_FAN",domain:r,points:a}}case a.SURFACE_TYPE_CONE:return{surfaceId:e,dims:n,surfaceType:"SURFACE_TYPE_CONE",domain:i(),radius:this.__surfaceLibraryReader.loadFloat16(),semiAngle:this.__surfaceLibraryReader.loadFloat16()};case a.SURFACE_TYPE_CYLINDER:return{surfaceId:e,dims:n,surfaceType:"SURFACE_TYPE_CYLINDER",domain:i(),radius:this.__surfaceLibraryReader.loadFloat16()};case a.SURFACE_TYPE_SPHERE:return{surfaceId:e,dims:n,surfaceType:"SURFACE_TYPE_SPHERE",domain:i(),radius:this.__surfaceLibraryReader.loadFloat16()};case a.SURFACE_TYPE_TORUS:return{surfaceId:e,dims:n,surfaceType:"SURFACE_TYPE_TORUS",domain:i(),majorRadius:this.__surfaceLibraryReader.loadFloat16(),minorRadius:this.__surfaceLibraryReader.loadFloat16()};case a.SURFACE_TYPE_LINEAR_EXTRUSION:{const r=i();let a;const s=this.__surfaceLibraryReader.loadUFloat16(),o=this.__surfaceLibraryReader.loadUFloat16();a=s+2048*o;const d=this.getCurveData(a);return{surfaceId:e,dims:n,surfaceType:"SURFACE_TYPE_LINEAR_EXTRUSION",domain:r,curve_tr:new t.Vec3(this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16()),curve_ori:new t.Quat(this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16()),curveData:d,partA:s,partB:o}}case a.SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN:case a.SURFACE_TYPE_REVOLUTION:{const r=i();let a;if(this.cadDataVersion.compare([0,0,27])<0){a=this.__surfaceLibraryReader.loadFloat16()+(this.__surfaceLibraryReader.loadFloat16()<<8)}else a=this.__surfaceLibraryReader.loadUInt32From2xUFloat16();return{surfaceId:e,dims:n,surfaceType:"SURFACE_TYPE_REVOLUTION",domain:r,curve_tr:new t.Vec3(this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16()),curve_ori:new t.Quat(this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16()),curveData:this.getCurveData(a)}}case a.SURFACE_TYPE_NURBS_SURFACE:{const r=i(),a=this.__surfaceLibraryReader.loadFloat16(),s=this.__surfaceLibraryReader.loadFloat16(),o=this.__surfaceLibraryReader.loadFloat16(),d=this.__surfaceLibraryReader.loadFloat16(),l=this.__surfaceLibraryReader.loadFloat16(),c=this.__surfaceLibraryReader.loadFloat16(),u=this.__surfaceLibraryReader.loadFloat16(),_=0!=(1&u),h=0!=(2&u),f=[];for(let e=0;e<o*d;e++){const e=new t.Vec4(this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16(),this.__surfaceLibraryReader.loadFloat16());f.push(e)}const m=[];for(let e=0;e<l;e++)m.push(this.__surfaceLibraryReader.loadFloat16());const v=[];for(let e=0;e<c;e++)v.push(this.__surfaceLibraryReader.loadFloat16());return{surfaceId:e,dims:n,surfaceType:"SURFACE_TYPE_NURBS_SURFACE",domain:r,periodicU:_,periodicV:h,degreeU:a,degreeV:s,numCPsU:o,numCPsV:d,controlPoints:f,knotsU:m,knotsV:v}}case a.SURFACE_TYPE_POLY_PLANE:return{surfaceId:e,dims:n,surfaceType:"SURFACE_TYPE_POLY_PLANE",points:[this.__surfaceLibraryReader.loadFloat16Vec2(),this.__surfaceLibraryReader.loadFloat16Vec2(),this.__surfaceLibraryReader.loadFloat16Vec2(),this.__surfaceLibraryReader.loadFloat16Vec2()]};default:{const t=this.getSurfaceType(e);console.warn("Invalid Surface Type:",t," surfaceId:",e)}}}findSpan(e,t,r,a){if(this.cadDataVersion.compare([0,0,6])>=0){this.cadDataVersion;let n=r[0],s=n,i=1;const o=r.length-t-1;for(;i<o;i++){if(n+=r[i],i>t&&e<n){i--;break}s=n}i==o&&i--,a[t]=s;let d=s,l=s;for(let e=1;e<=t;e++)d-=r[i-e+1],l+=r[i+e],a[t-e]=d,a[t+e]=l;return i}}calcBasisValues(e,t,r,a){const n=[],s=[],i=[1];a[0]=0;for(let o=1;o<=t;++o){n[o]=e-r[t+1-o],s[o]=r[t+o]-e;let d=0;for(let e=0;e<o;++e){const t=s[e+1],r=n[o-e],a=i[e]/(t+r);i[e]=d+t*a,d=r*a}if(i[o]=d,o==t-1||1==t){d=0;for(let e=0;e<t;e++){const n=e+1,s=r[n+t],o=r[n],l=t*i[e]/(s-o);a[e]=d-l,d=l}a[t]=d}}return i}calcBasisDerivatives(e,t,r){const a=[],n=[];let s=0,i=0;const o=[];for(let e=0;e<=t;e++)o.push([]);o[0][0]=1;for(let d=1;d<=t;d++){a[d]=e-r[t+1-d],n[d]=r[t+d]-e,s=0;for(let e=0;e<d;e++){const t=n[e+1],r=a[d-e],l=t+r;o[d][e]=l,i=o[e][d-1]/l,o[e][d]=s+t*i,s=r*i}o[d][d]=s}const d=[[],[]];for(let e=0;e<=t;e++)d[0][e]=o[e][t];const l=[[],[]];for(let e=0;e<=t;e++)l[0].push(0),l[1].push(0);for(let e=0;e<=t;e++){let r=0,a=1;l[0][0]=1;{const n=1;let s=0;const i=e-n,c=t-n;let u=0,_=0;e>=n&&(l[a][0]=l[r][0]/o[c+1][i],s=l[a][0]*o[i][c]),u=i>=-1?1:-i,_=e-1<=c?n-1:t-e;for(let e=u;e<=_;e++)l[a][e]=(l[r][e]-l[r][e-1])/o[c+1][i+e],s+=l[a][e]*o[i+e][c];e<=c&&(l[a][n]=-l[r][n-1]/o[c+1][e],s+=l[a][n]*o[e][c]),d[n][e]=s;const h=r;r=a,a=h}}let c=t;{const e=1;for(let r=0;r<=t;r++)d[e][r]=d[e][r]*c;c*=t-e}return d}calcSurfacePoint(e,r){const a=e,n=Math.remap(r[0],0,1,a.domain.p0.x,a.domain.p1.x),s=Math.remap(r[1],0,1,a.domain.p0.y,a.domain.p1.y),i=[],o=this.findSpan(n,a.degreeU,a.knotsU,i),d=[],l=this.findSpan(s,a.degreeV,a.knotsV,d),c=[],u=this.calcBasisValues(n,a.degreeU,i,c),_=[],h=this.calcBasisValues(s,a.degreeV,d,_),f=new t.Vec3(0,0,0),m=new t.Vec3(0,0,0),v=new t.Vec3(0,0,0);let g=0;const p=o-a.degreeU,y=l-a.degreeV;for(let e=0;e<=a.degreeV;++e){const t=y+e;for(let r=0;r<=a.degreeU;++r){const n=p+r,s=a.controlPoints[n+t*a.numCPsU],i=s.t,o=u[r],d=h[e],l=i*o*d;f.addInPlace(s.scale(l)),g+=l;const y=c[r],S=_[e];m.addInPlace(s.scale(y*d)),v.addInPlace(s.scale(o*S))}}0!=g&&!isNaN(g)&&isFinite(g)||console.warn("Unable to evaluate surface"),f.scaleInPlace(1/g);const S=i[a.degreeU+1]-i[a.degreeU],x=d[a.degreeV+1]-d[a.degreeV],b=(a.domain.p1.x-a.domain.p0.x)/a.knotsU.length,L=(a.domain.p1.y-a.domain.p0.y)/a.knotsV.length;if(S/b<.01){let e=p;e=s>a.domain.p1.y-1e-4?p+a.degreeU-2:p+1;const t=(n-d[a.degreeV])/x,r=y+Math.floor(t*a.degreeV),i=a.controlPoints[e+r*a.numCPsU].toVec3(),o=a.controlPoints[e+1+r*a.numCPsU].toVec3();m.setFromOther(o.subtract(i))}else if(m.length()<.05){let e;e=l>a.degreeV?y+a.degreeV-2:y+1;const t=(n-i[a.degreeU])/S,r=p+Math.floor(t*a.degreeU),s=a.controlPoints[r+e*a.numCPsU].toVec3(),o=a.controlPoints[r+1+e*a.numCPsU].toVec3();m.setFromOther(o.subtract(s))}if(x/L<.01){let e=y;e=s>a.domain.p1.y-1e-4?y+a.degreeV-2:y+1;const t=(n-i[a.degreeU])/S,r=p+Math.floor(t*a.degreeU),o=a.controlPoints[r+e*a.numCPsU].toVec3(),d=a.controlPoints[r+(e+1)*a.numCPsU].toVec3();v.setFromOther(d.subtract(o))}else if(v.length()<.05){let e=p;e=s>a.domain.p1.y-1e-4?p+a.degreeU-2:p+1;const t=(n-d[a.degreeV])/x,r=y+Math.floor(t*a.degreeV),i=a.controlPoints[e+r*a.numCPsU].toVec3(),o=a.controlPoints[e+(r+1)*a.numCPsU].toVec3();v.setFromOther(o.subtract(i))}return{pos:f,normal:m.cross(v).normalize()}}generatePolygonSurface(e,r=0){if(this.__meshes[e])return this.__meshes[e];if(this.getSurfaceType(e)!=a.SURFACE_TYPE_NURBS_SURFACE)return;const n=this.getSurfaceData(e);if(!n)return;const s=n.numCPsU*Math.pow(2,r),i=n.numCPsV*Math.pow(2,r);console.log("generatePolygonSurface:"+e+" M:"+s+" N:"+i);const o=new t.Plane(1,1,s,i),d=new Lines;d.setNumVertices((s+1)*(i+1)*2),d.setNumSegments((s+1)*(i+1));const l=d.getVertexAttribute("positions");let c=0;const u=o.getVertexAttribute("positions"),_=o.getVertexAttribute("normals");for(let e=0;e<=i;e++){const t=e/i;for(let e=0;e<=s;e++){const r=e/s,a=this.calcSurfacePoint(n,[r,t]);u.getValueRef(c).set(a.pos.x,a.pos.y,a.pos.z),_.getValueRef(c).set(a.normal.x,a.normal.y,a.normal.z),d.setSegmentVertexIndices(c,2*c,2*c+1),l.getValueRef(2*c).set(a.pos.x,a.pos.y,a.pos.z),l.getValueRef(2*c+1).set(a.pos.x+.2*a.normal.x,a.pos.y+.2*a.normal.y,a.pos.z+.2*a.normal.z),c++}}const h=new t.Material("myMat","SimpleSurfaceShader");h.getParameter("BaseColor").setValue(t.Color.random(.15)),o.material=h;const f=new t.Material("myMat","FlatSurfaceShader");return f.getParameter("BaseColor").setValue(new t.Color(1,0,0)),d.material=f,this.__meshes[e]=o,{mesh:o,normals:d}}generateHullGeometry(e){if(this.__hulls[e])return this.__hulls[e];if(this.getSurfaceType(e)!=a.SURFACE_TYPE_NURBS_SURFACE)return;const r=this.getSurfaceData(e);if(!r)return;console.log("generateHullGeometry:"+e+" numCPsU:"+r.numCPsU+" numCPsV:"+r.numCPsV);const n=new i(r.numCPsU,r.numCPsV),s=n.getVertexAttribute("positions");let o=0;for(let e=0;e<r.numCPsV;e++)for(let t=0;t<r.numCPsU;t++){const a=t+e*r.numCPsU,n=r.controlPoints[a];s.getValueRef(o).set(n.x,n.y,n.z),o++}const d=new t.Material("hullMaterial","FlatSurfaceShader");return d.getParameter("BaseColor").setValue(t.Color.random(-.25)),n.material=d,this.__hulls[e]=n,n}dumpDebugSurfaces(){const e=[];for(let t=0;t<this.__numSurfaces;t++)try{e.push(this.getSurfaceData(t,!1))}catch(r){console.warn("Error accessing Surface: ",t,r),e.push({})}return e}dumpDebugCurves(){const e=[];for(let t=0;t<this.__numSurfaces;t++)try{e.push(this.getCurveData(t))}catch(r){console.warn("Error accessing Curve: ",t,r),e.push({})}return e}logFormfactors(){for(const e in this.__formFactors)console.log(e+":"+this.__formFactors[e])}}class d{constructor(){this.__reader=void 0}setBinaryBuffer(e,r){if(this.__reader=e,this.__numTrimSets=this.__reader.loadUInt32(),r.compare([0,0,0])>0)this.__totalTrimSurfaceArea=this.__reader.loadFloat32();else{this.__totalTrimSurfaceArea=0;for(let e=0;e<this.__numTrimSets;e++){const t=this.getTrimSetDim(e),r=t[0]*t[1];this.__totalTrimSurfaceArea+=r}}const a=Math.sqrt(this.__totalTrimSurfaceArea),n=t.SystemDesc.gpuDesc.maxTextureSize,s=n>>1,i=n>>2,o=n>>3,d=n>>4;this.__texelSizes=[a/d,a/o,a/i,a/s]}getBinaryBuffer(){return this.__reader?this.__reader.data:null}getNumTrimSets(){return this.__numTrimSets}getTrimArea(){return this.__totalTrimSurfaceArea}getTexelSize(e,t){let r;return r=t<2?3:t<6?2:1,this.__texelSizes[r]}getTrimSetDim(e){this.__reader.seek(8+4*e),this.__reader.seek(this.__reader.loadUInt32());return[this.__reader.loadFloat32(),this.__reader.loadFloat32()]}getTrimSetCurves(e){this.__reader.seek(8+4*e),this.__reader.seek(this.__reader.loadUInt32());const t=this.__reader.loadFloat32(),r=this.__reader.loadFloat32(),a=this.__reader.loadUInt32(),n=this.__reader.loadUInt32(),s=()=>({id:this.__reader.loadFloat32(),xfo_tr:[this.__reader.loadFloat32(),this.__reader.loadFloat32()],xfo_rot:[this.__reader.loadFloat32(),this.__reader.loadFloat32(),this.__reader.loadFloat32(),this.__reader.loadFloat32()],flags:this.__reader.loadFloat32()}),i=[];for(let e=0;e<n;e++)i.push(s());const o=[];for(let e=0;e<a;e++){const e=[],t=this.__reader.loadUInt32();for(let r=0;r<t;r++)e.push(s());o.push(e)}return{size:[t,r],perimeter:i,holes:o}}dumpDebugTrimSets(){const e=[];for(let t=0;t<this.__numTrimSets;t++)try{e.push({dims:this.getTrimSetDim(t),curves:this.getTrimSetCurves(t)})}catch(r){console.warn("Error accessing TrimSet: ",t,r),e.push({})}return e}}class l{constructor(e){null!=e&&this.setBinaryBuffer(e)}setBinaryBuffers(e,r){this.__buffer=r,this.__reader=new t.BinReader(this.__buffer),this.__size=Math.sqrt(r.byteLength/16),this.__toc=e,this.__tocReader=new t.BinReader(e),this.__numBodies=this.__tocReader.loadUInt32()}getToc(){return this.__toc}getBinaryBuffer(){return this.__buffer}getNumBodies(){return this.__numBodies}getBodyDataTexelCoords(e){this.__tocReader.seek(4+12*e);return{x:this.__tocReader.loadUInt32(),y:this.__tocReader.loadUInt32()}}__seekBodyData(e,t=0){const r=this.getBodyDataTexelCoords(e),a=16*r.x+16*r.y*this.__size;this.__reader.seek(a+t)}getNumSurfacesForBody(e){this.__seekBodyData(e,24);return this.__reader.loadFloat32()}getBodyBBox(e){this.__seekBodyData(e);const r=new t.Box3;return r.p0=this.__reader.loadFloat32Vec3(),r.p1=this.__reader.loadFloat32Vec3(),r}getBodyDescData(e,r=!0){this.__seekBodyData(e);const a=new t.Box3;a.p0=this.__reader.loadFloat32Vec3(),a.p1=this.__reader.loadFloat32Vec3();const n=this.__reader.loadFloat32(),s=this.__reader.loadFloat32(),i=[];for(let e=0;e<n;e++)if(r){const e={surfaceId:this.__reader.loadFloat32()};e.xfo=new t.Xfo(this.__reader.loadFloat32Vec3(),this.__reader.loadFloat32Quat(),this.__reader.loadFloat32Vec3()),e.color=this.__reader.loadRGBAFloat32Color(),i.push(e)}else i.push(this.__reader.loadFloat32()),this.__reader.advance(56);const o=[];for(let e=0;e<s;e++)if(r){const e={curveId:this.__reader.loadFloat32()};e.xfo=new t.Xfo(this.__reader.loadFloat32Vec3(),this.__reader.loadFloat32Quat(),this.__reader.loadFloat32Vec3()),e.color=this.__reader.loadRGBAFloat32Color(),o.push(e)}else o.push(this.__reader.loadFloat32()),this.__reader.advance(56);return{bbox:a,surfaceRefs:i,curveRefs:o}}}class c extends t.BaseGeomItem{constructor(e,r){super(e),this.__bodyDescId=-1,this.__id=-1,this.__bodyBBox=new t.Box3,this.__cadAsset=r,this.__cadAsset&&this.__cadAsset.incCADBodyCount(),this.__materialParam=this.addParameter(new t.MaterialParameter("Material")),this.__colorParam=this.addParameter(new t.ColorParameter("Color",new t.Color(1,0,0,0)))}getCADAsset(){return this.__cadAsset}clone(e){const t=new c;return t.copyFrom(this,e),t}copyFrom(e,t){super.copyFrom(e,t),this.__cadAsset=e.getCADAsset(),this.__cadAsset.incCADBodyCount(),this.setBodyDescId(e.getBodyDescId()),this.setMaterial(e.getMaterial())}getBodyDataTexelCoords(){return this.__cadAsset.getBodyLibrary().getBodyDataTexelCoords(this.__bodyDescId)}getBodyDescData(){const e=this.__cadAsset.getBodyLibrary().getBodyDescData(this.__bodyDescId);for(const t of e.surfaceRefs)t.surfaceType=this.__cadAsset.getSurfaceLibrary().getSurfaceTypeLabel(t.surfaceId),t.dims=this.__cadAsset.getSurfaceLibrary().getSurfaceDims(t.surfaceId);return e}getSurfaceRefs(){return this.getBodyDescData().surfaceRefs}getBodyDescId(){return this.__bodyDescId}setBodyDescId(e){this.__bodyDescId=e,e>=0&&(this.__bodyBBox=this.__cadAsset.getBodyLibrary().getBodyBBox(this.__bodyDescId),this._setBoundingBoxDirty())}getMaterial(){return this.__materialParam.getValue()}setMaterial(e,t){this.__materialParam.setValue(e,t)}_cleanBoundingBox(e){return e=super._cleanBoundingBox(e),-1!=this.__bodyDescId&&e.addBox3(this.__bodyBBox,this.getParameter("GlobalXfo").getValue()),e}readBinary(e,r){super.readBinary(e,r),this.__cadAsset=r.assetItem,this.__cadAsset.incCADBodyCount();const a=e.loadSInt32();if(a>=0&&this.setBodyDescId(a),r.versions["zea-cad"].compare([0,0,4])<0){const a=e.loadStr();let n=r.assetItem.getMaterialLibrary().getMaterial(a,!1);n||(n=new t.Material(a,"SimpleSurfaceShader"),n.getParameter("BaseColor").setValue(t.Color.random(.25)),r.assetItem.getMaterialLibrary().addMaterial(n)),this.getParameter("Material").setValue(n)}if(r.versions["zea-cad"].compare([0,0,2])>=0&&r.versions["zea-cad"].compare([0,0,4])<0){this.__layers=e.loadStrArray();for(const e of this.__layers)r.addGeomToLayer(this,e)}}generatePolygonMeshSurfaces(e=0){const r=new t.TreeItem(this.getName());return this.getBodyDescData().surfaceRefs.forEach((a,n)=>{const s=this.__cadAsset.getSurfaceLibrary().generatePolygonSurface(a.surfaceId,e);if(s){const e=new t.GeomItem("Surface"+n+":"+a.surfaceId,s,s.material);e.getParameter("LocalXfo").setValue(a.xfo),r.addChild(e)}}),r}generateHullGeometry(){const e=new t.TreeItem(this.getName());return this.getBodyDescData().surfaceRefs.forEach((r,a)=>{const n=this.__cadAsset.getSurfaceLibrary().generateHullGeometry(r.surfaceId);if(n){const s=new t.GeomItem("Hull"+a+":"+r.surfaceId,n,n.material);return s.getParameter("LocalXfo").setValue(r.xfo),e.addChild(s),!1}}),e}toJSON(e=0){return super.toJSON(e)}fromJSON(e,t=0){super.fromJSON(e,t)}}t.Registry.register("CADBody",c);const u=new RegExp("\\.(stp|step|jt|3dm|ifc|vlcad|zcad)$","i");class _ extends t.AssetItem{constructor(e){super(e),this.__trimSetLibrary=new d,this.__surfaceLibrary=new o(this,this.__trimSetLibrary),this.__bodyLibrary=new l,this.__atlasSize=new t.Vec2,this.__numCADBodyItems=0,this.__loaded=!1,this.__datafileParam=this.addParameter(new t.FilePathParameter("FilePath")),this.addParameterDeprecationMapping("DataFilePath","FilePath"),this.__datafileParam.on("valueChanged",()=>{let e;const t=this.__datafileParam.getFileDesc();if(t.metadata&&t.metadata.ConvertFile){let r;const a=new RegExp("\\.(vlcad|zcad)$","i");t.metadata.ConvertFile.map(e=>{a.test(e.filename)&&(r=e)}),r?e=r.url:console.warn("ConvertFile metadata contains no vla file.")}else t.url?e=t.url:console.warn("CADAsset unable to load file:",t);this.load(e)}),this.addParameter(new t.BooleanParameter("DisplayEdges",!0)),this.addParameter(new t.ColorParameter("EdgeColor",new t.Color(.1,.1,.1,.75))),this.lod=function(){const e=new URLSearchParams(window.location.search);if(e.has("lod"))return Number.parseInt(e.get("lod"));switch(t.SystemDesc.deviceCategory){case"Low":return 1;case"Medium":return 2;case"High":return 3}return 1}(),this.curvatureToDetail=.5}isLoaded(){return this.__loaded}getLOD(){return Math.max(0,this.lod)}incCADBodyCount(){this.__numCADBodyItems++}getNumBodyItems(){return this.__numCADBodyItems}getSurfaceLibrary(){return this.__surfaceLibrary}getTrimSetLibrary(){return this.__trimSetLibrary}getBodyLibrary(){return this.__bodyLibrary}getMaterialLibrary(){return this.__materials}getVersion(){return this.cadfileversion}readRootLevelBinary(e,r){this.__numCADBodyItems=0,r.versions["zea-cad"]=new t.Version(e.loadStr()),r.sdk=e.loadStr(),this.cadfileversion=r.versions["zea-cad"],super.readBinary(e,r)}load(e,r=new t.AssetLoadContext){return this.__loadPromise||(this.__loadPromise=new Promise((a,n)=>{const s=e.lastIndexOf("/")>-1?e.substring(0,e.lastIndexOf("/"))+"/":"",i=e.lastIndexOf("/")>-1?e.substring(e.lastIndexOf("/")+1):"",o=i.substring(0,i.lastIndexOf("."));this.url=e,r.assetItem=this,r.url=e,r.folder=s,r.resources||(r.resources={}),r.xrefs={},r.on("done",()=>{this.__loaded=!0,a(),this.emit("loaded")}),r.incrementAsync(),t.resourceLoader.incrementWorkload(1),this.__geomLibrary.once("loaded",()=>{t.resourceLoader.incrementWorkDone(1)}),t.resourceLoader.loadFile("archive",e).then(e=>{const a=new t.BinReader((e.tree2||e.tree).buffer,0,t.SystemDesc.isMobileDevice);e.bodies&&this.__bodyLibrary.setBinaryBuffers(e.bodiestoc.buffer,e.bodies.buffer);const n=this.getName();if(this.readRootLevelBinary(a,r),""!=n&&this.setName(n),r.versions["zea-cad"]=this.getVersion(),r.versions["zea-engine"]=this.getEngineDataVersion(),e.geoms)this.__geomLibrary.readBinaryBuffer(i,e.geoms.buffer,r);else if(e["geomLibrary.json"]){e["desc.json"];const t=JSON.parse(new TextDecoder("utf-8").decode(e["geomLibrary.json"])),a=s+o;this.__geomLibrary.loadGeomFilesStream(t,a,r)}else t.resourceLoader.incrementWorkDone(1);if(e.trimSets){const r=e.trimSets||e.trimsets||e.trimSets2,a=new t.BinReader(r.buffer,0,t.SystemDesc.isMobileDevice);this.__trimSetLibrary.setBinaryBuffer(a,this.getVersion())}e.curves&&this.__surfaceLibrary.setBinaryBuffers(e.curves.buffer,e.surfaces.buffer,this.getVersion()),r.decrementAsync()},e=>{t.resourceLoader.incrementWorkDone(1),this.emit("error",e),n(e)})})),this.__loadPromise}toJSON(e,t){return super.toJSON(e,t)}fromJSON(e,r,a){const n=()=>{const n=t.TreeItem.LoadFlags.LOAD_FLAG_LOADING_BIN_TREE_VALUES;super.fromJSON(e,r,n,a),r.decAsyncCount(),this.__loaded||(this.emit("loaded"),this.__loaded=!0)};if(e.params&&e.params.DataFilePath){this.__datafileLoaded=n,r.incAsyncCount();const t=e.params.DataFilePath;delete e.params.DataFilePath,this.__datafileParam.fromJSON(t,r)}else n()}generatePolygonMeshSurfaces(e=0){const r=new t.TreeItem("surfaces"),a=t=>{t.getChildren().forEach(t=>{if(t instanceof c){const a=t.generatePolygonMeshSurfaces(e),n=t.getParameter("GlobalXfo").getValue();a.getParameter("GlobalXfo").setValue(n),r.addChild(a)}else a(t)})};return a(this),surfaceLibrary.logFormfactors(),r}generateHullGeometry(){const e=new t.TreeItem("hull"),r=t=>{t.getChildren().forEach(t=>{if(t instanceof c){const r=t.generateHullGeometry(),a=t.getParameter("GlobalXfo").getValue();e.getParameter("GlobalXfo").setValue(a),e.addChild(r)}else r(t)})};return r(this),surfaceLibrary.logFormfactors(),e}static get LOADSTATE(){return LOADSTATE}static supportsExt(e){return u.test(e)}}t.Registry.register("CADAsset",_);class h extends t.TreeItem{constructor(e){super(e)}clone(e){const t=new h;return t.copyFrom(this,e),t}toJSON(e,t=0){return super.toJSON(e,t)}fromJSON(e,t,r=0){super.fromJSON(e,t,r)}}t.Registry.register("CADAssembly",h);class f extends t.TreeItem{constructor(e){super(e)}clone(e){const t=new f;return t.copyFrom(this,e),t}copyFrom(e,t){super.copyFrom(e,t)}readBinary(e,t){super.readBinary(e,t)}toJSON(e=0){return super.toJSON(e)}fromJSON(e,t=0){super.fromJSON(e,t)}}t.Registry.register("CADPart",f);const m=e=>{for(;!(e instanceof _);)e=e.getOwner();return e},v=new t.Color("#F9CE03");v.a=.1;class g extends t.TreeItem{constructor(e){super(e)}clone(e){const t=new g;return t.copyFrom(this,e),t}setSelected(e){super.setSelected(e),e?this.activate():this.deactivate()}activate(){console.log("activate"),this.getParameters().forEach(e=>{const t=e.getName();"Visible"!=t&&"GlobalXfo"!=t&&"LocalXfo"!=t&&"BoundingBox"!=t&&console.log(t)});const e=m(this);if(this.getOwner().getOwner().getOwner()){const t=this.getParameter("LinkedEntities");if(t){const r=t.getValue();console.log(r),r.forEach(t=>{const r=t.split(", ");try{const t=e.resolvePath(r);t&&t.addHighlight("pmi",v,!0)}catch(e){console.log(e.message)}})}}}deactivate(){console.log("deactivate");const e=m(this);if(this.getOwner().getOwner()){const t=this.getParameter("LinkedEntities");if(t){const r=t.getValue();console.log(r),r.forEach(t=>{const r=t.split(", ");try{const t=e.resolvePath(r);t&&t.removeHighlight("pmi",!0)}catch(e){}})}}}}t.Registry.register("PMIItem",g);class p extends t.TreeItem{constructor(e){super(e)}clone(e){const t=new p;return t.copyFrom(this,e),t}activate(e){if(super.activate(),e){const t=this.getParameter("GlobalXfo").getValue().clone(),r=this.getParameter("TargetPoint").getValue();r.scaleInPlace(t.sc.z);const a=t.tr.distanceTo(r);t.sc.set(1,1,1),e.getParameter("GlobalXfo").setValue(t),e.setFocalDistance(a)}}}t.Registry.register("PMIView",p);class y extends _{constructor(e){super(e)}clone(e){const t=new y;return t.copyFrom(this,e),t}readBinary(e,r){e.loadStr();const a=e.loadStr();this.setName(a);let n=e.loadStr();if(r.versions["zea-cad"].compare([3,6,2])>0){const r=new t.Xfo;r.tr=e.loadFloat32Vec3(),r.ori=e.loadFloat32Quat(),this.__localXfoParam.loadValue(r)}else""==a&&this.setName(n);if(r.assets[n]){const e=r.assets[n];e.isLoaded()?this.copyFrom(e,0):e.on("loaded",()=>{this.copyFrom(e,0)})}else if(r.assets[n]=this,r.resources[n]||(n.includes("/")?n=n.slice(n.lastIndexOf("/")+1):n.includes("\\")&&(n=n.slice(n.lastIndexOf("\\")+1)),r.resources[n]||(r.resources[n]=r.folder+n+".zcad")),r.resources[n]){console.log("resolving XRef:",n," > ",r.resources[n]);const e=r.resources[n];if(r.incrementAsync(),r.xrefs[n]){const e=r.xrefs[n];e.isLoaded()?this.copyFrom(e):e.on("loaded",()=>{this.copyFrom(e)})}else r.xrefs[n]=this,this.load(e,new t.AssetLoadContext(r)).then(()=>{r.decrementAsync()},e=>{console.log(`While Loading ${this.getPath()} unable to resolve ${n}`),r.decrementAsync()})}}}t.Registry.register("XRef",y);class S extends t.Lines{constructor(e,t){super(),this.setNumSegments(e*t),this.setNumVertices(e*t*2);const r=this.getVertexAttribute("positions");for(let a=0;a<t;a++){const n=a/(t-1)-.5;for(let t=0;t<e;t++){const s=t/(e-1)-.5,i=a*e+t;r.getValueRef(2*i).set(s,n,0),r.getValueRef(2*i+1).set(s,n,1),this.setSegmentVertexIndices(i,2*i,2*i+1)}}}}class x extends t.Mesh{constructor(e){super(),this.setNumVertices(e);const t=e-2;this.setFaceCounts([t]);for(let e=0;e<t;e++)this.setFaceVertexIndices(e,[0,e+1,e+2]);const r=this.getVertexAttribute("positions");for(let t=0;t<e;t++)r.getValueRef(t).set(t/e-.5,-.5,0)}}class b{constructor(e){this.__gl=e,this.__drawCoordsArray=null,this.__drawCoordsBuffer=null,this.__drawCount=0,this.__bindAttr=(t,r,a,n,s,i=!0)=>{e.enableVertexAttribArray(t),e.vertexAttribPointer(t,r,a,!1,n,s),i&&e.vertexAttribDivisor(t,1)}}setDrawItems(e){this.__drawCoordsBuffer&&(this.__gl.deleteBuffer(this.__drawCoordsBuffer),this.__drawCoordsBuffer=null);const t=this.__gl;return this.__drawCoordsBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.__drawCoordsBuffer),t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW),this.__drawCount=e.length/4,this.__drawCount}addDrawItems(e){if(this.__drawCoordsArray){const t=new Float32Array(this.__drawCoordsArray.length+e.length);t.set(this.__drawCoordsArray),t.set(e,this.__drawCoordsArray.length),this.__drawCoordsArray=t}else this.__drawCoordsArray=e;this.__drawCoordsBuffer&&(this.__gl.deleteBuffer(this.__drawCoordsBuffer),this.__drawCoordsBuffer=null);const t=this.__gl;return this.__drawCoordsBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.__drawCoordsBuffer),t.bufferData(t.ARRAY_BUFFER,this.__drawCoordsArray,t.STATIC_DRAW),this.__drawCount+=e.length/4,this.__drawCount}getDrawCount(){return this.__drawCount}bind(e){if(0==this.__drawCount)return 0;const t=this.__gl;t.bindBuffer(t.ARRAY_BUFFER,this.__drawCoordsBuffer);const r=e.attrs;return this.__bindAttr(r.drawCoords.location,4,t.FLOAT,16,0),this.__drawCount}destroy(){this.__gl.deleteBuffer(this.__drawCoordsBuffer),this.__drawCoordsBuffer=null}}const L={};class C{constructor(e,r,a){if(this.__gl=e,0!=r&&0!=a||console.error("invalid GLSurfaceDrawSet:"+r+","+a),1==a){const n=r;L[n]||(L[n]=new t.GLMesh(e,new x(r))),this.__glgeom=L[n],this.__numTris=r-2,this.__glnormalsgeom=new t.GLLines(e,new S(r,a)),this.key=n}else{const n=r+"x"+a;L[n]||(L[n]=new t.GLMesh(e,new t.Plane(1,1,r-1,a-1))),this.__glgeom=L[n],this.__numTris=(r-1)*(a-1)*2,this.__glnormalsgeom=new t.GLLines(e,new S(r,a)),this.key=n}this.__quadDetail=[r-1,a-1],this.__freeIndices=[],this.__subSets={}}setDrawItems(e,t){this.__subSets[t]||(this.__subSets[t]=new b(this.__gl));const r=this.__subSets[t].setDrawItems(e);return this.__numTris*r}addDrawItems(e,t){this.__subSets[t]||(this.__subSets[t]=new b(this.__gl));const r=this.__subSets[t].addDrawItems(e);return this.__numTris*r}getDrawCount(e){return this.__subSets[e]?this.__subSets[e].getDrawCount():0}draw(e,t){const r=this.__subSets[t];if(!r)return;const a=this.__gl,n=e.unifs;n.quadDetail&&a.uniform2i(n.quadDetail.location,this.__quadDetail[0],this.__quadDetail[1]),this.__glgeom.bind(e);const s=r.bind(e);e.bindViewports(e.unifs,()=>{this.__glgeom.drawInstanced(s)})}drawNormals(e,t){if(!this.__glnormalsgeom)return;const r=this.__subSets[t];if(!r)return;const a=this.__gl,n=e.unifs;n.quadDetail&&a.uniform2i(n.quadDetail.location,this.__quadDetail[0],this.__quadDetail[1]),this.__glnormalsgeom.bind(e);const s=r.bind(e);e.bindViewports(e.unifs,()=>{this.__glnormalsgeom.drawInstanced(s)})}destroy(){this.__glnormalsgeom&&this.__glnormalsgeom.destroy();for(const e in this.__subSets){this.__subSets[e].destroy()}}}class R extends t.Lines{constructor(e=1){super(),this.setNumVertices(e+1),this.setNumSegments(e);const t=this.getVertexAttribute("positions");for(let r=0;r<=e;r++)r<e&&this.setSegmentVertexIndices(r,r,r+1),t.getValueRef(r).set(r/e,0,0);this.emit("geomDataTopologyChanged")}}class T{constructor(e){this.__gl=e,this.__drawCoordsArray=null,this.__drawCoordsBuffer=null,this.__drawCount=0,this.__bindAttr=(t,r,a,n,s,i=!0)=>{e.enableVertexAttribArray(t),e.vertexAttribPointer(t,r,a,!1,n,s),i&&e.vertexAttribDivisor(t,1)}}setDrawItems(e){this.__drawCoordsBuffer&&(this.__gl.deleteBuffer(this.__drawCoordsBuffer),this.__drawCoordsBuffer=null);const t=this.__gl;return this.__drawCoordsBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.__drawCoordsBuffer),t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW),this.__drawCount=e.length/4,this.__drawCount}addDrawItems(e){if(this.__drawCoordsArray){const t=new Float32Array(this.__drawCoordsArray.length+e.length);t.set(this.__drawCoordsArray),t.set(e,this.__drawCoordsArray.length),this.__drawCoordsArray=t}else this.__drawCoordsArray=e;this.__drawCoordsBuffer&&(this.__gl.deleteBuffer(this.__drawCoordsBuffer),this.__drawCoordsBuffer=null);const t=this.__gl;return this.__drawCoordsBuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.__drawCoordsBuffer),t.bufferData(t.ARRAY_BUFFER,this.__drawCoordsArray,t.STATIC_DRAW),this.__drawCount+=e.length/4,this.__drawCount}getDrawCount(){return this.__drawCount}bind(e){if(0==this.__drawCount)return 0;const t=this.__gl;t.bindBuffer(t.ARRAY_BUFFER,this.__drawCoordsBuffer);const r=e.attrs;return this.__bindAttr(r.drawCoords.location,4,t.FLOAT,16,0),this.__drawCount}destroy(){this.__gl.deleteBuffer(this.__drawCoordsBuffer),this.__drawCoordsBuffer=null}}const A={};class E{constructor(e,r){this.__gl=e,0==r&&console.error("invalid GLCurveDrawSet:"+r),A[r]||(A[r]=new t.GLLines(e,new R(r))),this.key=r,this.__glgeom=A[r],this.__edgeDetail=r,this.__freeIndices=[],this.__subSets={},this.__numDrawItems=0}setDrawItems(e,t){return this.__subSets[t]||(this.__subSets[t]=new T(this.__gl)),this.__subSets[t].setDrawItems(e),this.__numDrawItems+=e.length/2,this.__numDrawItems}addDrawItems(e,t){this.__subSets[t]||(this.__subSets[t]=new T(this.__gl)),this.__numDrawItems+=this.__subSets[t].addDrawItems(e)}getDrawCount(e){return this.__subSets[e]?this.__subSets[e].getDrawCount():0}draw(e,t){const r=this.__subSets[t];if(!r)return;const a=this.__gl,n=e.unifs;n.edgeDetail&&a.uniform1i(n.edgeDetail.location,this.__edgeDetail),this.__glgeom.bind(e);const s=r.bind(e);e.bindViewports(e.unifs,()=>{this.__glgeom.drawInstanced(s)})}destroy(){this.__glnormalsgeom&&this.__glnormalsgeom.destroy();for(const e in this.__subSets){this.__subSets[e].destroy()}}}class D extends t.GLShader{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=t.shaderLibrary.parseShader("GLEvaluateCADCurveShader.vertexShader","\nprecision highp float;\n\nattribute vec3 positions;\ninstancedattribute vec4 patchCoords;         // where the values will be written to in the target texture.\ninstancedattribute vec2 curveDataCoords;     // where the data will come from in the source texture\n\nuniform ivec2 curvesAtlasTextureSize;\n\n/* VS Outputs */\nvarying vec2 v_geomDataCoords;\nvarying vec2 v_patchSize;\nvarying vec2 v_vertexCoord;\n\n\n\nvoid main(void) {\n\n  vec2 patchPos = patchCoords.xy;\n  v_patchSize = patchCoords.zw;\n\n  v_geomDataCoords = curveDataCoords;\n  v_vertexCoord = (positions.xy + 0.5) * v_patchSize;\n\n  vec2 pos = (patchPos + v_vertexCoord) / vec2(curvesAtlasTextureSize);\n  gl_Position =  vec4((pos - 0.5) * 2.0, 0.0, 1.0);\n}\n"),this.__shaderStages.FRAGMENT_SHADER=t.shaderLibrary.parseShader("GLEvaluateCADCurveShader.fragmentShader",'\n// #extension GL_EXT_draw_buffers : require\nprecision highp float;\n\n/* VS Outputs */\nvarying vec2 v_geomDataCoords;\nvarying vec2 v_patchSize;\nvarying vec2 v_vertexCoord;\n\n\nstruct PosNorm {\n  vec3 pos;\n  vec3 normal;\n  int geomType;\n};\n\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLMath.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLCADCurves.glsl"/>\n<%include file="GLSLNURBS.glsl"/>\n<%include file="GLSLNURBSCurves.glsl"/>\n\nuniform sampler2D curveDataTexture;\nuniform ivec2 curveDataTextureSize;\nuniform int writeTangents;\n\nPosNorm evalCADCurves(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  int geomType = GLSLBinReader_readInt(reader, texture);\n\n  // PosNorm result;\n  // result.pos = vec3(float(geomType));\n  // // fragColor = reader.buffer;\n  // // fragColor = vec4(float(reader.textureSize.x), float(reader.textureSize.y), float(geomType), 1.0);\n  // return result;\n\n\n  if(geomType == CURVE_TYPE_LINE) {\n      return calcLinePoint(params.x, reader, texture);\n  } \n  if(geomType == CURVE_TYPE_CIRCLE) {\n      return calcCirclePoint(params.x, reader, texture);\n  } \n  if(geomType == CURVE_TYPE_ELIPSE) {\n      return calcElipsePoint(params.x, reader, texture);\n  }\n  if(geomType == CURVE_TYPE_NURBS_CURVE) {\n      return calcNURBSCurve3dPoint(params.x, reader, texture);\n  } \n  \n  PosNorm detault;\n  return detault;\n}\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n\n  // Evaluate the curve per vertex\n\n  // compute exact xy coords per pixel by rounding the vertex coord to the nearest integer and then dividing my patch size.\n  // The interpollated xy coords from the quad are not exact because the quad must cover the pixels with some margin.\n\n  // The quad overlaps the pixels by half a pixel, so \n  vec2 params = vec2(floor(v_vertexCoord.x), floor(v_vertexCoord.y));\n  if(v_patchSize.x > 1.0)\n      params.x /= v_patchSize.x - 1.0;\n  // if(v_patchSize.y > 1.0)\n  //     params.y /= v_patchSize.y - 1.0;\n\n  ivec4 region = ivec4(0, 0, curveDataTextureSize.x, curveDataTextureSize.y);\n  ivec2 start = ivec2(int(v_geomDataCoords.x), int(v_geomDataCoords.y));\n\n  GLSLBinReader reader;\n  GLSLBinReader_init(reader, curveDataTextureSize, region, start, 32);\n  PosNorm posNorm = evalCADCurves(params, reader, curveDataTexture);\n\n  if(writeTangents == 1) {\n      fragColor = vec4(posNorm.normal, 1.0);\n  }\n  else {\n      fragColor = vec4(posNorm.pos, 1.0);\n  }\n  // fragColor = vec4(params.x, params.y, 0.0, 1.0);\n  // gl_FragData[0] = vec4(posNorm.pos, 1.0);\n  // gl_FragData[1] = vec4(posNorm.normal, 1.0);\n\n  // fragColor.r = v_geomDataCoords.x;\n  // fragColor.g = v_geomDataCoords.y;\n  // fragColor.b = float(curveDataTextureSize.x);\n  // fragColor.a = float(curveDataTextureSize.y);\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n')}}t.Registry.register("GLEvaluateCADCurveShader",D);class B{constructor(e,r,a,n){this.__gl=e,this.__cadpassdata=r,this.__surfacesLibrary=a,this.cadDataVersion=n;const s=this.__surfacesLibrary.getCurveBuffer(),i=Math.sqrt(s.byteLength/8);this.__curveDataTexture=new t.GLTexture2D(e,{format:"RGBA",type:"HALF_FLOAT",width:i,height:i,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:new Uint16Array(s)}),this.__bindAttr=(t,r,a,n,s,i=!0)=>{e.enableVertexAttribArray(t),e.vertexAttribPointer(t,r,e.FLOAT,!1,n,s),i&&e.vertexAttribDivisor(t,1)}}evaluateCurves(e,r,a,n){const s=r;if(0==s)return;const i=this.__gl;this.__curveAtlasLayoutTexture=new t.GLTexture2D(this.__gl,{format:"RGBA",type:"FLOAT",width:a[0],height:a[1],filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:e}),this.__curvesAtlasRenderTarget?this.__curvesAtlasRenderTarget.width==n[0]&&this.__curvesAtlasRenderTarget.height==n[1]||this.__curvesAtlasRenderTarget.resize(n[0],n[1],!0):(this.__curvesAtlasRenderTarget=new t.GLRenderTarget(i,{format:"RGBA",type:"FLOAT",width:n[0],height:n[1],filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1}),this.__curvesTangentAtlasRenderTarget=new t.GLRenderTarget(i,{format:"RGBA",type:"FLOAT",width:n[0],height:n[1],filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1}));const o={shaderopts:{directives:[...i.shaderopts.directives]}};this.__curvesAtlasRenderTarget.bindForWriting(o,!0),this.cadDataVersion.compare([0,0,0])>0&&o.shaderopts.directives.push("#define EXPORT_KNOTS_AS_DELTAS 1"),this.cadDataVersion.compare([0,0,26])>0&&o.shaderopts.directives.push("#define INTS_PACKED_AS_2FLOAT16 1"),this.evaluateCurveShader||(this.evaluateCurveShader=new D(i)),this.evaluateCurveShader.bind(o),this.__cadpassdata.glplanegeom.bind(o);const d=o.unifs,l=o.attrs;i.uniform2i(d.curvesAtlasTextureSize.location,this.__curvesAtlasRenderTarget.width,this.__curvesAtlasRenderTarget.height),this.__curveDataTexture.bindToUniform(o,d.curveDataTexture),i.uniform2i(d.curveDataTextureSize.location,this.__curveDataTexture.width,this.__curveDataTexture.height);const c=i.createBuffer();i.bindBuffer(i.ARRAY_BUFFER,c),i.bufferData(i.ARRAY_BUFFER,e,i.STATIC_DRAW),this.__bindAttr(l.patchCoords.location,4,i.FLOAT,32,0),this.__bindAttr(l.curveDataCoords.location,2,i.FLOAT,32,16),i.uniform1i(d.writeTangents.location,0),this.__cadpassdata.glplanegeom.drawInstanced(s),this.__curvesTangentAtlasRenderTarget.bindForWriting(o,!0),i.uniform1i(d.writeTangents.location,1),this.__cadpassdata.glplanegeom.drawInstanced(s),i.deleteBuffer(c),this.__curvesTangentAtlasRenderTarget.unbind(),i.finish()}bindCurvesAtlasLayout(e){const t=this.__gl,r=e.unifs;this.__curvesAtlasRenderTarget&&r.curvesAtlasLayoutTexture&&(this.__curveAtlasLayoutTexture.bindToUniform(e,r.curvesAtlasLayoutTexture),t.uniform2i(r.curvesAtlasLayoutTextureSize.location,this.__curveAtlasLayoutTexture.width,this.__curveAtlasLayoutTexture.height))}bindCurvesAtlas(e){const t=this.__gl,r=e.unifs;this.__curvesAtlasRenderTarget&&(this.__curvesAtlasRenderTarget.bindColorTexture(e,r.curvesAtlasTexture),r.curveTangentsTexture&&this.__curvesTangentAtlasRenderTarget.bindColorTexture(e,r.curveTangentsTexture),r.curvesAtlasTextureSize&&t.uniform2i(r.curvesAtlasTextureSize.location,this.__curvesAtlasRenderTarget.width,this.__curvesAtlasRenderTarget.height),r.curvesAtlasLayoutTexture&&(this.__curveAtlasLayoutTexture.bindToUniform(e,r.curvesAtlasLayoutTexture),t.uniform2i(r.curvesAtlasLayoutTextureSize.location,this.__curveAtlasLayoutTexture.width,this.__curveAtlasLayoutTexture.height)))}destroy(){this.__curveDataTexture.destroy(),this.__curveAtlasLayoutTexture&&(this.__curveAtlasLayoutTexture.destroy(),this.__curvesAtlasRenderTarget.destroy(),this.__curvesTangentAtlasRenderTarget.destroy())}}class V{constructor(e,t=0,r=!0){this.__data=e,this.__byteOffset=t,this.__dataView=new DataView(this.__data),this.__isMobileDevice=r,this.utf8decoder=new TextDecoder}get isMobileDevice(){return this.__isMobileDevice}get data(){return this.__data}get byteLength(){return this.__dataView.byteLength}get remainingByteLength(){return this.__dataView.byteLength-this.__byteOffset}pos(){return this.__byteOffset}seek(e){this.__byteOffset=e}advance(e){this.__byteOffset+=e}loadUInt8(){const e=this.__dataView.getUint8(this.__byteOffset);return this.__byteOffset+=1,e}loadUInt16(){const e=this.__dataView.getUint16(this.__byteOffset,!0);return this.__byteOffset+=2,e}loadUInt32(){const e=this.__dataView.getUint32(this.__byteOffset,!0);return this.__byteOffset+=4,e}loadSInt32(){const e=this.__dataView.getInt32(this.__byteOffset,!0);return this.__byteOffset+=4,e}loadFloat16(){return(e=>{const t=(32768&e)>>15,r=(31744&e)>>10,a=1023&e;return 0==r?(t?-1:1)*Math.pow(2,-14)*(a/Math.pow(2,10)):31==r?a?NaN:1/0*(t?-1:1):(t?-1:1)*Math.pow(2,r-15)*(1+a/Math.pow(2,10))})(this.loadUInt16())}loadUFloat16(){const e=this.loadFloat16();return e<0?2048-e:e}loadFloat16From2xUInt8(){const e=this.__dataView.getFloat16(this.__byteOffset,!0);return this.__byteOffset+=2,e}loadUInt32From2xUFloat16(){return this.loadUFloat16()+4096*this.loadUFloat16()}loadSInt32From2xFloat16(){return this.loadFloat16()+2048*this.loadFloat16()}loadFloat32(){const e=this.__dataView.getFloat32(this.__byteOffset,!0);return this.__byteOffset+=4,e}loadUInt8Array(e,t=!1){null==e&&(e=this.loadUInt32());const r=new Uint8Array(this.__data,this.__byteOffset,e);this.__byteOffset+=e;this.__byteOffset;return r}loadUInt16Array(e,t=!1){if(null==e&&(e=this.loadUInt32()),0==e)return new Uint16Array;let r;if(this.readPadd(2),this.__isMobileDevice){r=new Uint16Array(e);for(let t=0;t<e;t++)r[t]=this.__dataView.getUint16(this.__byteOffset,!0),this.__byteOffset+=2}else r=new Uint16Array(this.__data,this.__byteOffset,e),this.__byteOffset+=2*e;return r}loadUInt32Array(e,t=!1){if(null==e&&(e=this.loadUInt32()),0==e)return new Uint32Array;let r;if(this.readPadd(4),this.__isMobileDevice){r=new Uint32Array(e);for(let t=0;t<e;t++)r[t]=this.__dataView.getUint32(this.__byteOffset,!0),this.__byteOffset+=4}else r=new Uint32Array(this.__data,this.__byteOffset,e),this.__byteOffset+=4*e;return r}loadFloat32Array(e,t=!1){if(null==e&&(e=this.loadUInt32()),0==e)return new Float32Array;let r;if(this.readPadd(4),this.__isMobileDevice){r=new Float32Array(e);for(let t=0;t<e;t++)r[t]=this.__dataView.getFloat32(this.__byteOffset,!0),this.__byteOffset+=4}else r=new Float32Array(this.__data,this.__byteOffset,e),this.__byteOffset+=4*e;return r}loadStr(){const e=this.loadUInt32(),t=new Uint8Array(this.__data,this.__byteOffset,e);this.__byteOffset+=e;let r="";for(let a=0;a<e;a++)r+=String.fromCharCode(t[a]);return r}loadStrArray(){const e=this.loadUInt32(),t=[];for(let r=0;r<e;r++)t[r]=this.loadStr();return t}readPadd(e){const t=this.__byteOffset%e;0!=t&&(this.__byteOffset+=e-t)}}t.shaderLibrary.setShaderModule("GLSLBinReader.glsl","\n\n#ifdef DECODE_16BIT_FLOAT_FROM_8BIT_INT\n\n/////////////////////////////////////////////////////////////////\n// http://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js\n// Note: modulo on some GPUS. (e.g. iPhone)\n// often incur errors in modulo, leaving a result\n// that appears to boe the y param. in this use case\n// we are only interested in integer moduos anyway\n// so we just trim off erronious values. .Seems to work. \nfloat fixed_mod(float x, float y) {\n  float res = mod(x, y);\n  return (abs(y - res) < 0.5) ? 0.0 : res;\n}\n\nfloat shift_right(float v, float amt) {\n  v = floor(v) + 0.5;\n  return floor(v / exp2(amt));\n}\n\nfloat shift_left(float v, float amt) {\n  return floor(v * exp2(amt) + 0.5);\n}\n\nfloat mask_last(float v, float bits) {\n  return fixed_mod(v, shift_left(1.0, bits));\n}\n\nfloat extract_bits(float num, float from, float to) {\n  from = floor(from + 0.5);\n  to = floor(to + 0.5);\n  return mask_last(shift_right(num, from), to - from);\n}\n\n\n/////////////////////////////////////////////////////////////////\n\nfloat decode16BitFloatFrom2xUInt8_IEEE(vec2 c){\n  float v = 0.;\n\n  // int h = c.x + c.y * 256;\n  // const s = (h & 0x8000) >> 15;\n  // const e = (h & 0x7C00) >> 10;\n  // const f = h & 0x03FF;\n\n\n  // float h = c.x + c.y * 256.0;\n  // float s = extract_bits(h, 15.0, 16.0);\n  // float e = extract_bits(h, 10.0, 15.0);\n  // float f = extract_bits(h, 0.0, 10.0);\n\n  // float s = extract_bits(c.y, 7.0, 8.0);\n  // float e = extract_bits(c.y, 2.0, 7.0);\n\n  int s = (c.y >= 127.5) ? 1 : 0;\n  float e = shift_right(c.y - ((s == 1) ? 128.0 : 0.0), 2.0);\n  float f = c.x + mask_last(c.y, 2.0) * 256.0;\n  // return float(s);\n\n  if(e < 0.5) {\n    return ((s!=0)?-1.0:1.0) * exp2(-14.0) * (f/exp2(10.0));\n  } else if (int(e) == 0x1F) {\n    float NaN = 0.0;\n    float Inf = 0.0;\n    return (f==0.0)?(NaN):(((s!=0)?-1.0:1.0)*Inf);\n  }\n\n  return ((s!=0)?-1.0:1.0) * exp2(e-15.0) * (1.0+(f/exp2(10.0)));\n}\n\n#endif\n\n// RGBA16 textures\nvec4 GLSLBinReader_texelFetch2D(sampler2D texture, ivec2 textureSize, ivec2 address) {\n  return fetchTexel(texture, textureSize, address);\n}\n\nstruct GLSLBinReader {\n  ivec2 textureSize; \n  ivec4 region;\n  ivec2 start; /* the base address from which we base the offsets */\n  int offset; /* how far we have read into the buffer . Note: value is in channels. so 4 == 1 pixel.*/\n  vec4 buffer; \n  ivec2 bufferaddress;\n  int bpc; // bits per channel. (e.g. 8, 16, 32)\n};\n\nvoid GLSLBinReader_init(inout GLSLBinReader reader, ivec2 textureSize, ivec4 region, ivec2 start, int bpc) {\n  reader.textureSize = textureSize;\n  reader.region = region;\n  reader.start = start;\n#ifdef DECODE_16BIT_FLOAT_FROM_8BIT_INT\n  reader.start = ivec2(start.x * 2, start.y);\n#else\n  reader.start = start;\n#endif\n  reader.bpc = bpc;\n  reader.bufferaddress = ivec2(-1, -1);\n}\n\nvoid GLSLBinReader_init(inout GLSLBinReader reader, ivec2 textureSize, int bpc) {\n  reader.textureSize = textureSize;\n  reader.region = ivec4(0, 0, textureSize.x, textureSize.y);\n  reader.start = ivec2(0,0);\n  reader.bpc = bpc;\n  reader.bufferaddress = ivec2(-1, -1);\n}\n\n\nivec2 GLSLBinReader_getAddress(in GLSLBinReader reader, int offset) {\n#ifdef DECODE_16BIT_FLOAT_FROM_8BIT_INT\n  ivec2 address = ivec2(reader.start.x + (offset/2), reader.start.y);\n#else\n  ivec2 address = ivec2(reader.start.x + (offset/4), reader.start.y);\n#endif\n  address.y += address.x / reader.region.z;\n  address.x = imod(address.x, reader.region.z);\n  return address;\n}\n\n\nfloat GLSLBinReader_readFloat(inout GLSLBinReader reader, sampler2D texture, int offset) {\n\n  ivec2 address = GLSLBinReader_getAddress(reader, offset);\n\n  if(address != reader.bufferaddress){\n    reader.buffer = GLSLBinReader_texelFetch2D(texture, reader.textureSize, reader.region.xy + address);\n    reader.bufferaddress = address;\n  }\n\n#ifdef DECODE_16BIT_FLOAT_FROM_8BIT_INT\n\n  int swizelIndex = imod(offset, 2);\n  if(swizelIndex == 0)\n    return decode16BitFloatFrom2xUInt8_IEEE(reader.buffer.xy * 255.0);\n  return decode16BitFloatFrom2xUInt8_IEEE(reader.buffer.zw * 255.0);\n\n#else\n\n  int swizelIndex = imod(offset, 4);\n  if(swizelIndex == 0)\n    return reader.buffer.x;\n  if(swizelIndex == 1)\n    return reader.buffer.y;\n  if(swizelIndex == 2)\n    return reader.buffer.z;\n  return reader.buffer.w;\n  \n#endif\n}\n\n\nint GLSLBinReader_readInt(inout GLSLBinReader reader, sampler2D texture, int offset) {\n  if(reader.bpc == 8)\n    return int(GLSLBinReader_readFloat(reader, texture, offset) * 255.0);\n  else {\n    float flt = GLSLBinReader_readFloat(reader, texture, offset);\n    return int(flt);\n  }\n}\n\nint GLSLBinReader_readUInt(inout GLSLBinReader reader, sampler2D texture, int offset) {\n  if(reader.bpc == 8)\n    return int(GLSLBinReader_readFloat(reader, texture, offset) * 255.0);\n  else {\n    float flt = GLSLBinReader_readFloat(reader, texture, offset);\n    if (flt < 0.0) {\n      return int(2048.0 - flt);\n    }\n    else {\n      return int(flt);\n    }\n  }\n}\n\nvec4 GLSLBinReader_readVec4(inout GLSLBinReader reader, sampler2D texture, int offset) {\n  ivec2 address = GLSLBinReader_getAddress(reader, offset);\n  return GLSLBinReader_texelFetch2D(texture, reader.textureSize, reader.region.xy + address);\n}\n\n\nvec3 GLSLBinReader_readVec3(inout GLSLBinReader reader, sampler2D texture, int offset) {\n  return GLSLBinReader_readVec4(reader, texture, offset).rgb;\n}\n\nvec2 GLSLBinReader_readVec2(inout GLSLBinReader reader, sampler2D texture, int offset) {\n  return vec2(\n    GLSLBinReader_readFloat(reader, texture, offset),\n    GLSLBinReader_readFloat(reader, texture, offset+1)\n  );\n}\n\n\n\nfloat GLSLBinReader_readFloat(inout GLSLBinReader reader, sampler2D texture) {\n  float result = GLSLBinReader_readFloat( reader,  texture, reader.offset);\n  reader.offset++;\n  return result;\n}\n\nint GLSLBinReader_readInt(inout GLSLBinReader reader, sampler2D texture) {\n  if(reader.bpc == 8)\n    return int(GLSLBinReader_readFloat(reader, texture) * 255.0);\n  else\n    return int(GLSLBinReader_readFloat(reader, texture));\n}\n\nint GLSLBinReader_readUInt(inout GLSLBinReader reader, sampler2D texture) {\n  if(reader.bpc == 8)\n    return int(GLSLBinReader_readFloat(reader, texture) * 255.0);\n  else {\n    float flt = GLSLBinReader_readFloat(reader, texture);\n    if (flt < 0.0) {\n      return int(2048.0 - flt);\n    }\n    else {\n      return int(flt);\n    }\n  }\n}\n\nint GLSLBinReader_readUIntFrom2xUFloat16(inout GLSLBinReader reader, sampler2D texture) {\n  int partA = GLSLBinReader_readUInt(reader, texture);\n  int partB = GLSLBinReader_readUInt(reader, texture);\n  \n#ifdef INTS_PACKED_AS_2FLOAT16\n  // Changed on version 0.0.28\n  return partA + (partB * 4096);\n#else\n  return partA + (partB * 256);\n#endif\n}\n\nvec4 GLSLBinReader_readVec4(inout GLSLBinReader reader, sampler2D texture) {\n  vec4 result = GLSLBinReader_readVec4( reader, texture, reader.offset);\n  reader.offset += 4;\n  return result;\n}\n\n\nvec3 GLSLBinReader_readVec3(inout GLSLBinReader reader, sampler2D texture) {\n  return GLSLBinReader_readVec4(reader, texture).rgb;\n}\n\nvec2 GLSLBinReader_readVec2(inout GLSLBinReader reader, sampler2D texture) {\n  return vec2(\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture)\n  );\n}\n\n\n\n"),t.shaderLibrary.setShaderModule("GLSLMath.glsl",'\n\n<%include file="stack-gl/transpose.glsl"/>\n\n  ////////////////////////////////////////\n  \n  struct Xfo2d {\n    vec2 tr;\n    float rot;\n    vec2 sc;\n  };\n\n  vec2 rotateVec2(float rot, vec2 vec){\n    float cosa = cos(rot);\n    float sina = sin(rot);\n    return vec2(vec.x * cosa - vec.y * sina, vec.x * sina + vec.y * cosa);\n  }\n\n  vec2 Xfo2D_transformVec2(Xfo2d xfo2d, vec2 pos){\n    return xfo2d.tr + rotateVec2(xfo2d.rot, pos * xfo2d.sc);\n  }\n\n  ////////////////////////////////////////\n\n\n  vec4 quat_fromAxisAndAngle(vec3 axis, float angle) {\n    float halfAngle = angle / 2.0;\n    vec3 vec = axis* sin(halfAngle);\n    return vec4(vec.x, vec.y, vec.z, cos(halfAngle));\n  }\n\n  vec4 quat_conjugate(vec4 quat) {\n    return vec4(-quat.x, -quat.y, -quat.z, quat.w);\n  }\n\n  vec4 quat_multiply(vec4 lhs, vec4 rhs) {\n    float ax = lhs.x;\n    float ay = lhs.y;\n    float az = lhs.z;\n    float aw = lhs.w;\n    float bx = rhs.x;\n    float by = rhs.y;\n    float bz = rhs.z;\n    float bw = rhs.w;\n    return vec4(\n      ax * bw + aw * bx + ay * bz - az * by,\n      ay * bw + aw * by + az * bx - ax * bz,\n      az * bw + aw * bz + ax * by - ay * bx,\n      aw * bw - ax * bx - ay * by - az * bz\n    );\n  }\n\n  vec3 quat_rotateVec3(vec4 quat, vec3 rhs) {\n    vec4 vq = vec4(rhs.x, rhs.y, rhs.z, 0.0);\n    vec4 pq = quat_multiply(quat_multiply(quat, vq), quat_conjugate(quat));\n    return vec3(pq.x, pq.y, pq.z);\n  }\n\n\n  mat4 tr_toMat4(vec3 tr) {\n    // Note: GLSL matrices are transposed compared to the matrices in ZeaEngine\n    vec4 col0 = vec4(1.0, 0.0, 0.0, 0.0);\n    vec4 col1 = vec4(0.0, 1.0, 0.0, 0.0);\n    vec4 col2 = vec4(0.0, 0.0, 1.0, 0.0);\n    vec4 col3 = vec4(tr, 1.0);\n    return mat4(col0, col1, col2, col3);\n  }\n\n  mat4 quat_toMat4(vec4 quat) {\n\n    float x2 = quat.x + quat.x;\n    float y2 = quat.y + quat.y;\n    float z2 = quat.z + quat.z;\n\n    float xx = quat.x * x2;\n    float yx = quat.y * x2;\n    float yy = quat.y * y2;\n    float zx = quat.z * x2;\n    float zy = quat.z * y2;\n    float zz = quat.z * z2;\n    float wx = quat.w * x2;\n    float wy = quat.w * y2;\n    float wz = quat.w * z2;\n\n\n    // Note: GLSL matrices are transposed compared to the matrices in ZeaEngine\n    vec4 col0 = vec4(\n      1.0 - yy - zz,\n      yx - wz,\n      zx + wy,\n      0.0);\n\n    vec4 col1 = vec4(\n      yx + wz,\n      1.0 - xx - zz,\n      zy - wx,\n      0.0);\n\n    vec4 col2 = vec4(\n      zx - wy,\n      zy + wx,\n      1.0 - xx - yy,\n      0.0);\n\n    vec4 col3 = vec4(\n      0.0,\n      0.0,\n      0.0,\n      1.0);\n\n    // return mat4(col0, col1, col2, col3);\n    return transpose(mat4(col0, col1, col2, col3));\n  }\n\n  mat4 sc_toMat4(vec3 sc) {\n    // Note: GLSL matrices are transposed compared to the matrices in ZeaEngine\n    return mat4(\n      sc.x, 0.0,  0.0,  0.0,\n      0.0,  sc.y, 0.0,  0.0,\n      0.0,  0.0,  sc.z, 0.0,\n      0.0,  0.0,  0.0,  1.0);\n  }\n\n  struct Xfo {\n    vec3 tr;\n    vec4 ori;\n    vec3 sc;\n  };\n\n  Xfo xfo_multiply(Xfo xfo, Xfo other){\n    return Xfo(\n      xfo.tr + quat_rotateVec3(xfo.ori, xfo.sc * other.tr),\n      quat_multiply(xfo.ori, other.ori),\n      xfo.sc * other.sc\n    );\n  }\n\n  mat4 xfo_toMat4(Xfo xfo){\n    mat4 sc_mat4 = sc_toMat4(xfo.sc);\n    mat4 ori_mat4  = quat_toMat4(xfo.ori);\n    mat4 tr_mat4  = tr_toMat4(xfo.tr);\n    mat4 result = tr_mat4 * ori_mat4 * sc_mat4;\n    return result;\n  }\n\n'),t.shaderLibrary.setShaderModule("GLSLCADCurves.glsl","\n\n  // http://cadexchanger.com/download/sdk/doc/dev/html/sdk_data_model_geometry_topology.html#sdk_data_model_geometry_curves\n\n\n\n// http://cadexchanger.com/download/sdk/doc/dev/html/sdk_data_model_geometry_topology.html#sdk_data_model_geometry_surfaces\n\n\nvec2 loadVec2(inout GLSLBinReader reader, sampler2D texture) {\n  return vec2(GLSLBinReader_readFloat(reader, texture),  GLSLBinReader_readFloat(reader, texture));\n}\n\nfloat mapDomain1d(vec2 domain, float param) {\n  float u = domain.x + param * ( domain.y - domain.x );\n  return u;\n}\n\n/////////////////////////////////////////\n// Line\n\nPosNorm calcLinePoint(float param, inout GLSLBinReader reader, sampler2D texture) {\n  vec2 domain = loadVec2(reader, texture);\n  float u = mapDomain1d( domain, param );\n  vec3 pos = vec3(u, 0.0, 0.0);\n  vec3 norm = vec3(1.0, 0.0, 0.0);\n  return PosNorm(pos, norm, CURVE_TYPE_LINE);\n}\n\n\n/////////////////////////////////////////\n// Circle\n\nPosNorm calcCirclePoint(float param, inout GLSLBinReader reader, sampler2D texture) {\n  vec2 domain = loadVec2(reader, texture);\n  float radius = GLSLBinReader_readFloat(reader, texture);\n\n  float u = mapDomain1d( domain, param );\n  vec3 pos = vec3(cos(u) * radius, sin(u) * radius, 0.0);\n  vec3 norm = vec3(-sin(u), cos(u), 0.0);\n  return PosNorm(pos, norm, CURVE_TYPE_CIRCLE);\n}\n\n\n\n/////////////////////////////////////////\n// Elipse3d\n// An ellipse is a periodic curve parametrized as follows: C(t) = P + X * R_major * cos(t) + Y * R_minor * sin(t), where\n\n// P is an origin point,\n// X and Y are directions,\n// R_major and R_minor are major and minor radii,\n// t belongs to [0, 2 * PI].\n// Note that major radius is always along the X-axis and minor radius - along the Y-axis, and that with t=0 the point corresponds to a major radius.\n\n\nPosNorm calcElipsePoint(float param, inout GLSLBinReader reader, sampler2D texture) {\n  vec2 domain = loadVec2(reader, texture);\n  float u = mapDomain1d( domain, param );\n  float minorRadius = GLSLBinReader_readFloat(reader, texture);\n  float majorRadius = GLSLBinReader_readFloat(reader, texture);\n  vec3 pos = vec3(cos(u) * majorRadius, sin(u) * minorRadius, 0.0);\n  vec3 norm = normalize(vec3(-sin(u) * majorRadius, cos(u) * minorRadius, 0.0)); // TODO: fix this broken line.\n\n  // pos = vec3(float(minorRadius));\n\n  return PosNorm(pos, norm, CURVE_TYPE_ELIPSE);\n}\n\n"),t.shaderLibrary.setShaderModule("GLSLCADSimpleSurfaces.glsl","\n\n  // http://cadexchanger.com/download/sdk/doc/dev/html/sdk_data_model_geometry_topology.html#sdk_data_model_geometry_surfaces\n\n\n/////////////////////////////////////////\n// Plane\n// A plane is parametrized as follows: S(u,v) = P + u * dX + v * dY, where\n\n// P is an origin point,\n// dX and dY are directions (unit vectors) of X and Y axes respectively,\n// u, v belongs to (-Infinity, +Infinity).\n\nPosNorm calcPlaneSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain = loadBox2(reader, texture);\n  vec2 uv = mapDomain(domain, params);\n\n  vec3 pos = vec3(uv.x, uv.y, 0.0);\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n\n  return PosNorm(pos, normal, SURFACE_TYPE_PLANE);\n}\n\n/////////////////////////////////////////\n// Poly Plane\n// A plane is parametrized as follows: S(u,v) = P + u * dX + v * dY, where\n\n// P is an origin point,\n// dX and dY are directions (unit vectors) of X and Y axes respectively,\n// u, v belongs to (-Infinity, +Infinity).\n\nPosNorm calcPolyPlaneSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  // Domain does not need to be mapped in this case.\n  vec2 uv = params;\n  vec2 p0 = GLSLBinReader_readVec2(reader, texture);\n  vec2 p1 = GLSLBinReader_readVec2(reader, texture);\n  vec2 p2 = GLSLBinReader_readVec2(reader, texture);\n  vec2 p3 = GLSLBinReader_readVec2(reader, texture);\n\n  vec2 pos = mix(mix(p0, p1, uv.x), mix(p3, p2, uv.x), uv.y);\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n\n  return PosNorm(vec3(pos, 0.0), normal, SURFACE_TYPE_POLY_PLANE);\n}\n\n\n/////////////////////////////////////////\n// Fan\n// A plane is parametrized as follows: S(u,v) = P + u * dX + v * dY, where\n\n// P is an origin point,\n// dX and dY are directions (unit vectors) of X and Y axes respectively,\n// u, v belongs to (-Infinity, +Infinity).\n\nPosNorm calcFanSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  // Domain does not need to be mapped in this case.\n  vec2 uv = params;\n  // Skip forward 2 values for each vertex.\n  reader.offset += int(2.0 * floor(v_vertexCoord.x));\n  vec2 pos = GLSLBinReader_readVec2(reader, texture);\n  vec3 normal = vec3(0.0, 0.0, 1.0);\n\n  return PosNorm(vec3(pos, 0.0), normal, SURFACE_TYPE_FAN);\n}\n\n\n\n/////////////////////////////////////////\n// Cone\n// A conical surface is parametrized as follows: S(u,v) = P + r * cos(u) * Dx + r * sin(u) * Dy + v * cos(φ) * Dz, where\n\n// P is an origin point,\n// Dx, Dy and Dz are directions (unit vectors) of X, Y and Z axes respectively,\n// φ - semi-angle, i.e. an angle between Dz and any generatrix,\n// r = R + v * sin(φ), i.e. a radius of a circle at respective parameter v,\n// u belongs to [0, 2 * PI],\n// v belongs to (-infinity, +infinity).\n// U-parameter is an angle along the circle at a given parameter V and V-parameter is a length along the cone. Thus, U-isolines are lines and V-isoline are circles.\n\n// V-isoline at V=0 is a circle of radius R in the plane defined by an axis placement.\n\n// Conical surface contains both halfs of mathematical cone.\n\n// Conical surface is U-periodical with period 2 * PI. At a cone apex, r equals 0, hence V-parameter of an apex equals -R / sin(φ)\n\n\nPosNorm calcConeSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain = loadBox2(reader, texture);\n  float r = GLSLBinReader_readFloat(reader, texture);\n  float semiAngle = GLSLBinReader_readFloat(reader, texture);\n  vec2 uv = mapDomain(domain, params);\n\n  float u = uv.x;\n  float v = uv.y;\n  float r_at_v = r + v * sin(semiAngle);\n  vec3 pos = vec3(r_at_v * cos(u), r_at_v * sin(u), v * cos(semiAngle));\n  vec3 normal = normalize(vec3(cos(u)*cos(semiAngle), sin(u)*cos(semiAngle), -sin(semiAngle)));\n  return PosNorm(pos, normal, SURFACE_TYPE_CONE);\n}\n\n\n/////////////////////////////////////////\n// Cylinder\n// A cylindrical surface is parametrized as follows: S(u,v) = P + R * cos(u) * dX + R * sin(u) * dY + v * dZ, where\n\n// P is an origin point,\n// dX, dY and dZ are directions (unit vectors) of X, Y and Z axes respectively,\n// R is a radius,\n// u belongs to [0, 2 * PI],\n// v belongs to (-infinity, +infinity).\n\n\nPosNorm calcCylinderSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain = loadBox2(reader, texture);\n  float r = GLSLBinReader_readFloat(reader, texture);\n  vec2 uv = mapDomain(domain, params);\n\n  vec3 normal = vec3(cos(uv.x), sin(uv.x), 0.0);\n  vec3 pos = r * normal + vec3(0.0, 0.0, uv.y);\n\n  return PosNorm(pos, normal, SURFACE_TYPE_CYLINDER);\n}\n\n\n/////////////////////////////////////////\n// Sphere\n// A spherical surface is parametrized as follows: S(u,v) = P + R * cos(v) * (cos(u) * Dx + sin(u) * Dy) + R * sin(v) * Dz, where\n\n// P is an origin point,\n// Dx, Dy and Dz are directions (unit vectors) of X, Y and Z axes respectively,\n// R is a radius,\n// u belongs to [0, 2 * PI],\n// v belongs to [-PI/2, +PI/2].\n// U-parameter is an angle of rotation around the Dz axis counterclockwise (i.e. similar to longitude on the Earth), and V-parameter is an angle between plane defined by an axis placement and line from P to a point on a sphere (i.e. latitude). Thus, U-isolines are semi-circles and V-isoline are circles.\n\n// V-isoline at V=0 is a circle of radius R in the plane defined by an axis placement. U-isoline at U=0 corresponds to a semi-circle from south to north pole.\n\n// Spherical surface is U-periodical with period 2 * PI.\n\n// If a face lies on a full spherical surface its boundary wire will contain two a degenerated edges corresponding to the south and north poles (V equals -PI/2 and PI/2 respectively), and a seam-edge.\n\n\nPosNorm calcSphereSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain = loadBox2(reader, texture);\n  vec2 uv = mapDomain(domain, params);\n\n  float r = GLSLBinReader_readFloat(reader, texture);\n\n  float u = uv.x;\n  float v = uv.y;\n  vec3 normal = vec3(cos(v) * cos(u), cos(v) * sin(u), sin(v));\n  vec3 pos = r * normal;\n\n  return PosNorm(pos, normal, SURFACE_TYPE_SPHERE);\n}\n\n/////////////////////////////////////////\n// Torus\n\n// A toroidal surface is parametrized as follows: S(u,v) = (R1 + R2 * cos(v)) * (cos(u) * Dx + sin(u) * Dy) + R2 * sin(v) * Dz, where\n\n// R1 is a major radius,\n// R2 is a minor radius,\n// u belongs to [0, 2 * PI],\n// v belongs to [0, 2 * PI],\n// U-parameter is an angle when rotating around the Dz axis counterclockwise, and V-parameter is an angle in circular section at a given parameter U. Thus, U-isolines circles lying in the plane containing Z axis and V-isolines are circles in the planes perpendicular to Z axis.\n\n// V-isoline at V=0 is a circle of radius (R1 + R2) in the plane defined by an axis placement. U-isoline at U=0 is a circle of radius R2 in the plane containing Z and X axes.\n\n// Radii R1 and R2 must be positive. If R2 > R1 then toroidal surface will be self-intersecting.\n\n// Toroidal surface is both U- and V-periodical with periods 2 * PI.\n\n// If a face lies on a full toroidal surface its boundary wire will contain two seam-edges, corresponding to U=0 and U=2*PI, and V=0 and V=2*PI respectively.\n\n\nPosNorm calcTorusSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain = loadBox2(reader, texture);\n  vec2 uv = mapDomain(domain, params);\n\n  float majorRadius = GLSLBinReader_readFloat(reader, texture);\n  float minorRadius = GLSLBinReader_readFloat(reader, texture);\n  float u = uv.x;\n  float v = uv.y;\n  vec3 pos = (majorRadius + minorRadius * cos(v)) * vec3(cos(u), sin(u), 0.0) + vec3(0.0, 0.0, minorRadius * sin(v));\n\n  vec3 normal = vec3(cos(v) * cos(u), cos(v) * sin(u), sin(v));\n  // vec3 pos = majorRadius * normal;\n\n  return PosNorm(pos, normal, SURFACE_TYPE_TORUS);\n}\n\n"),t.shaderLibrary.setShaderModule("GLSLCADCompoundSurfaces.glsl","\n\n/////////////////////////////////////////\n// LinearExtrusion\n\nPosNorm calcLinearExtrusionSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain = loadBox2(reader, texture);\n  \n  int curve_index = GLSLBinReader_readUIntFrom2xUFloat16(reader, texture);\n\n  vec3 curve_tr = vec3(\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture)\n  );\n  vec4 curve_ori = vec4(\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture)\n    );\n  vec3 curve_sc = vec3(\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture)\n  );\n  vec2 uv = mapDomain(domain, params);\n\n  PosNorm curveResult = evalCADCurve3d(curve_index, uv.x);\n  \n  vec3 pos = quat_rotateVec3(curve_ori, curveResult.pos * curve_sc) + curve_tr;\n  pos.z += uv.y;\n\n  vec3 normal = normalize(cross(vec3(0.0, 0.0, 1.0), quat_rotateVec3(curve_ori, curveResult.normal)));\n\n  return PosNorm(pos, normal, SURFACE_TYPE_LINEAR_EXTRUSION);\n}\n\n\n/////////////////////////////////////////\n// Revolution\nPosNorm calcRevolutionSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture, bool flipDomain) {\n  box2 domain = loadBox2(reader, texture);\n\n  int curve_index = GLSLBinReader_readUIntFrom2xUFloat16(reader, texture);\n\n  vec3 curve_tr = vec3(\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture)\n  );\n  vec4 curve_ori = vec4(\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture)\n    );\n  vec3 curve_sc = vec3(\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture),\n    GLSLBinReader_readFloat(reader, texture)\n  );\n  vec2 uv = mapDomain(domain, params);\n\n  vec3 axis = vec3(0.0, 0.0, 1.0);\n  PosNorm curveResult;\n  vec4 rev;\n  if (flipDomain) {\n    curveResult = evalCADCurve3d(curve_index, uv.x);\n    rev = quat_fromAxisAndAngle(axis, uv.y);\n  } else {\n    curveResult = evalCADCurve3d(curve_index, uv.y);\n    rev = quat_fromAxisAndAngle(axis, uv.x);\n  }\n\n  vec3 p_t = quat_rotateVec3(curve_ori, curveResult.pos * curve_sc) + curve_tr;\n  vec3 pos = quat_rotateVec3(rev, p_t);\n\n  vec3 p_n = quat_rotateVec3(rev, quat_rotateVec3(curve_ori, curveResult.normal));\n  \n  vec3 tangent;\n  if (abs(1.0 - dot(p_n, axis)) > 0.001) {\n    tangent = cross(p_n, axis);\n  } else {\n    tangent = cross(pos, axis);\n  }\n  // TODO: Find a conclusive test file that demonstrates this as correct.\n  // I think it is the master cylinder sample.\n  // vec3 normal = normalize(cross(p_n, tangent));\n  vec3 normal = normalize(cross(tangent, p_n));\n\n  // vec3 pos;\n  // vec3 normal;\n  // pos.x = float(partA);\n  // pos.y = float(partB);\n  // pos.z = float(curve_index);\n  return PosNorm(pos, normal, SURFACE_TYPE_REVOLUTION);\n}\n\n\n/////////////////////////////////////////\n// OffsetSurface\n\nPosNorm calcOffsetSurfaceSurfacePoint(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain = loadBox2(reader, texture);\n  int surfaceId = GLSLBinReader_readUInt(reader, texture);\n  float offset = GLSLBinReader_readFloat(reader, texture);\n  vec2 uv = mapDomain(domain, params);\n\n/*\n  GLSLBinReader subSurfaceReader = reader;\n  subSurfaceReader.start = \n  GLSLBinReader_init(reader, surfaceDataTextureSize, region, start, 32);\n\n  vec3 p = calcCurvePoint(uv.x);\n  vec3 pos = p + dir * (dist * uv.y);\n  \n*/\n  vec3 pos;\n  vec3 normal;\n  return PosNorm(pos, normal, SURFACE_TYPE_OFFSET_SURFACE);\n}\n\n\n\n"),t.shaderLibrary.setShaderModule("GLSLNURBS.glsl","\n\n#define MAX_KNOTS 256\n// Note: The BRP motorcycle features many surfaces of degree 15.\n#define MAX_DEGREE 16\n\nfloat kp(int index, inout GLSLBinReader r, sampler2D t, int offset) {\n  return GLSLBinReader_readFloat(r, t, offset+index);\n}\n\n#ifdef EXPORT_KNOTS_AS_DELTAS\n\nint findSpan(float u, in int degree, in int numKnots, int kpOff, inout GLSLBinReader r, sampler2D t, out highp float knots[MAX_DEGREE*2+1]) {\n  \n  float nextKnot = kp(0, r, t, kpOff);\n  float knot = nextKnot;\n\n  int span = 1;\n  int n = numKnots - degree - 1;\n  // Linear Search...\n  for (; span<n; span++){\n    nextKnot += kp(span, r, t, kpOff);\n    if (span > degree && u < nextKnot){\n      span--;\n      break;\n    }\n    knot = nextKnot;\n  }\n  if (span == n) {\n    span--;\n  }\n\n\n  //Calculate knot values\n  knots[degree] = knot;\n  float left = knot;\n  float right = knot; \n  for (int i=1; i<=degree; i++) {\n    left -= kp(span-i+1, r, t, kpOff);\n    right += kp(span+i, r, t, kpOff);\n    knots[degree-i] = left;\n    knots[degree+i] = right;\n  }\n\n  return span;\n}\n\nvoid calcBasisValues(in float u, in int degree, in highp float knots[MAX_DEGREE*2+1], out highp float basisValues[MAX_DEGREE+1], out highp float bvD[MAX_DEGREE+1]) {\n  \n  highp vec2 savedTemp;\n  highp float left[MAX_DEGREE+1];\n  highp float right[MAX_DEGREE+1];\n\n  //Basis[0] is always 1.0\n  basisValues[0] = 1.0;\n  // Calculate basis values\n  for (int i=1; i<=degree; i++) {\n    left[i] = u - knots[degree+1-i];\n    right[i] = knots[degree+i] - u;\n\n    savedTemp.x = 0.0;\n    for (int j=0; j<i; j++) {\n      float rv = right[j+1];\n      float lv = left[i-j];\n      savedTemp.y = basisValues[j] / (rv + lv);\n      basisValues[j] = savedTemp.x + rv * savedTemp.y;\n      savedTemp.x = lv * savedTemp.y;\n    }\n    basisValues[i] = savedTemp.x;\n\n    // Calculate N' if on second to last iteration\n    if (i == degree-1 || degree == 1) {\n      savedTemp.x = 0.0;\n      //Loop through all basis values\n      for (int j=0; j<degree; j++) {\n        // Calculate a temp variable\n        int jr_z = j + 1;\n        //Calculate right side\n        float kp_0 = knots[jr_z + degree];\n        float kp_1 = knots[jr_z];\n        savedTemp.y = (float(degree) * basisValues[j]) / (kp_0 - kp_1);\n        // Calculate derivative value\n        bvD[j] = savedTemp.x - savedTemp.y;\n        // Swap right side to left\n        savedTemp.x = savedTemp.y;\n      }\n      //Save the last der-basis\n      bvD[degree] = savedTemp.x;\n    }\n  }\n}\n\n#else\n\n// http://read.pudn.com/downloads134/sourcecode/math/569665/nurbsR2006b/findspan.c__.htm\n// Note: I have found the 'early outs' in the Three code to be more correct\n// https://github.com/mrdoob/three.js/blob/b8d8a8625465bd634aa68e5846354d69f34d2ff5/examples/js/curves/NURBSUtils.js\nint findSpan(float u, in int degree, in int numKnots, int kpOff, inout GLSLBinReader r, sampler2D t, bool periodic) {\n  \n  // early outs\n  int n = numKnots - degree - 1;\n  if(u >= kp(n, r, t, kpOff))\n    return n-1;\n  if(u <= kp(degree, r, t, kpOff)) {\n    return degree;\n  }\n\n  // Linear Search...\n#ifdef ENABLE_ES3\n  int i = degree; \n  for (; i<n; i++){\n#else\n  // Note: loop values must be constant.\n  // Loops start at 1 because that is the minimum degree for a curve.\n  for (int i = 1; i<MAX_KNOTS; i++){\n    if(i >= degree && i < numKnots-1){\n#endif\n    if (u < kp(i+1, r, t, kpOff)){\n      return i;\n    }\n#ifndef ENABLE_ES3\n  }\n#endif\n  }\n\n  return i;\n}\n\n\nvoid calcBasisValues(in float u, in int span, int degree, int kpOff, int numKnots, inout GLSLBinReader r, sampler2D t, out highp float basisValues[MAX_DEGREE+1], out highp float bvD[MAX_DEGREE+1]) {\n  \n  highp vec2 savedTemp;\n  highp float left[MAX_DEGREE+1];\n  highp float right[MAX_DEGREE+1];\n\n  // Basis[0] is always 1.0\n  basisValues[0] = 1.0;\n  // Calculate basis values\n#ifdef ENABLE_ES3\n  for (int i=1; i<=degree; i++) {\n#else\n  for (int i=1; i<MAX_DEGREE; i++) {\n    if(i > degree) // i<=degree\n      break;\n#endif\n    left[i] = u - kp(span+1-i, r, t, kpOff);\n    right[i] = kp(span+i, r, t, kpOff) - u;\n\n    savedTemp.x = 0.0;\n#ifdef ENABLE_ES3\n    for (int j=0; j<i; j++) {\n#else\n    for (int j=0; j<MAX_DEGREE; j++) {\n      if(j >= i) // j < i\n        break;\n#endif\n      float rv = right[j+1];\n      float lv = left[i-j];\n      savedTemp.y = basisValues[j] / (rv + lv);\n      basisValues[j] = savedTemp.x + rv * savedTemp.y;\n      savedTemp.x = lv * savedTemp.y;\n    }\n    basisValues[i] = savedTemp.x;\n    \n    // Calculate N' if on second to last iteration\n    if (i == degree-1 || degree == 1) {\n      savedTemp.x = 0.0;\n      // Loop through all basis values\n#ifdef ENABLE_ES3\n      for (int j=0; j<degree; j++) {\n#else\n      for (int j=0; j<MAX_DEGREE; j++) {\n        if(j >= degree) // j < degree\n          break;\n#endif\n        // Calculate a temp variable\n        int jr_z = span - degree + j + 1;\n        // Calculate right side\n        float kp_0 = kp(jr_z + degree, r, t, kpOff);\n        float kp_1 = kp(jr_z, r, t, kpOff);\n        savedTemp.y = (float(degree) * basisValues[j]) / (kp_0 - kp_1);\n        // Calculate derivative value\n        bvD[j] = savedTemp.x - savedTemp.y;\n        // Swap right side to left\n        savedTemp.x = savedTemp.y;\n      }\n      // Save the last der-basis\n#ifdef ENABLE_ES3\n      bvD[degree] = savedTemp.x;\n#else\n      if(degree == 1)\n        bvD[1] = savedTemp.x;\n      else if(degree == 2)\n        bvD[2] = savedTemp.x;\n      else if(degree == 3)\n        bvD[3] = savedTemp.x;\n      else if(degree == 4)\n        bvD[4] = savedTemp.x;\n      else if(degree == 5)\n        bvD[5] = savedTemp.x;\n      else if(degree == 6)\n        bvD[6] = savedTemp.x;\n      else if(degree == 7)\n        bvD[7] = savedTemp.x;\n      else if(degree == 8)\n        bvD[8] = savedTemp.x;\n      else if(degree == 9)\n        bvD[9] = savedTemp.x;\n      else if(degree == 10)\n        bvD[10] = savedTemp.x;\n      else if(degree == 11)\n        bvD[11] = savedTemp.x;\n      else if(degree == 12)\n        bvD[12] = savedTemp.x;\n      else if(degree == 13)\n        bvD[13] = savedTemp.x;\n      else if(degree == 14)\n        bvD[14] = savedTemp.x;\n      else if(degree == 15)\n        bvD[15] = savedTemp.x;\n#endif\n    }\n  }\n}\n\n\n#endif\n\n"),t.shaderLibrary.setShaderModule("GLSLNURBSCurves.glsl","\n\nstruct NURBSCurveData {\n  vec2 domain;\n  bool periodic;\n  int degree;\n  int numCPs;\n  int numKnots;\n\n  int cpStart;\n  int kpStart;\n};\n\nvoid loadNURBSCurve3dData(inout GLSLBinReader reader, sampler2D texture, out NURBSCurveData result) {\n\n  result.domain.x = GLSLBinReader_readFloat(reader, texture);\n  result.domain.y = GLSLBinReader_readFloat(reader, texture);\n  result.degree = GLSLBinReader_readUInt(reader, texture);\n\n  result.numCPs = GLSLBinReader_readUInt(reader, texture);\n  result.numKnots = GLSLBinReader_readUInt(reader, texture);\n  int flags = GLSLBinReader_readUInt(reader, texture);\n  result.periodic = testFlag(flags, CURVE_FLAG_PERIODIC);\n\n  result.cpStart = 2*4; // 2 RGBA pixels of data before the knot values start.\n  result.kpStart = result.cpStart + (result.numCPs*4);\n}\n\nvec4 curve_cp3d(int u, inout GLSLBinReader r, NURBSCurveData d, sampler2D t) {\n  int index = u * 4;\n  return GLSLBinReader_readVec4(r, t, d.cpStart + index);\n}\n\n// https://github.com/akshatamohanty/wildcat-cad/blob/650e18d665ccde3dbc4c78029e35c38951581c92/Source/Geometry/Shaders/ns23_default_plM.fsh\n// https://github.com/mrdoob/three.js/blob/6c7f000734f8579da37fb39e5c2e9e5e2dfb14f8/examples/js/curves/NURBSUtils.js\n\n/*\n  Calculate rational B-Spline curve point. See The NURBS Book, page 134, algorithm A4.3.\n*/\nPosNorm calcNURBSCurve3dPoint(float param, inout GLSLBinReader r, sampler2D t) {\n\n  NURBSCurveData d;\n  loadNURBSCurve3dData(r, t, d);\n\n  float u = d.domain.x + param * ( d.domain.y - d.domain.x ); // linear mapping param->u\n  //if(d.periodic)\n  //    u = wrap(u, kp(0, r, t, d.kpStart), kp(d.numKnots-1, r, t, d.kpStart));\n \n  float bv[MAX_DEGREE+1];\n  float bvds[MAX_DEGREE+1];\n\n#ifdef EXPORT_KNOTS_AS_DELTAS\n  highp float knots[MAX_DEGREE*2+1];\n  int span = findSpan(u, d.degree, d.numKnots, d.kpStart, r, t, knots);\n  //return PosNorm(vec3(span, knots[d.degree], knots[d.degree+1]), vec3(1.0), CURVE_TYPE_NURBS_CURVE);\n  //return PosNorm(vec3(knots[d.degree-1], knots[d.degree], knots[d.degree+1]), vec3(1.0), CURVE_TYPE_NURBS_CURVE);\n  //return PosNorm(vec3(knots[d.degree+1], knots[d.degree+2], knots[d.degree+3]), vec3(1.0), CURVE_TYPE_NURBS_CURVE);\n\n  calcBasisValues(u, d.degree, knots, bv, bvds);\n  // return PosNorm(vec3(bv[0], bv[1], bv[2]), vec3(bv[3], bv[4], bv[5]), CURVE_TYPE_NURBS_CURVE);\n#else\n  int span = findSpan(u, d.degree, d.numKnots, d.kpStart, r, t, d.periodic);\n  // return PosNorm(vec3(float(span)), vec3(1.0), CURVE_TYPE_NURBS_CURVE);\n  // return PosNorm(vec3(kp(span-1, r, t, d.kpStart), kp(span-0, r, t, d.kpStart), kp(span+1, r, t, d.kpStart)), vec3(0.0), CURVE_TYPE_NURBS_CURVE);\n\n  // Invalid knot vectors exist where all the values are identical.\n  if (kp(span, r, t, d.kpStart) == kp(span+1, r, t, d.kpStart)) {\n    for(int x=0; x <= d.degree; x++)\n      bv[x] = 0.0;\n    bv[d.degree] = 1.0;\n  }\n  else {\n    calcBasisValues(u, span, d.degree, d.kpStart, d.numKnots, r, t, bv, bvds);\n  }\n  // return PosNorm(vec3(bv[0], bv[1], bv[2]), vec3(bv[3], bv[4], bv[5]), CURVE_TYPE_NURBS_CURVE);\n#endif\n\n\n  float w = 0.0;\n  vec3 pos = vec3(0.0);\n  vec3 tangent = vec3(0.0);\n\n  int cv0 = (span - d.degree);\n#ifdef ENABLE_ES3\n  for(int x=0; x <= d.degree; x++) {\n#else\n  for(int x=0; x < MAX_DEGREE; x++) {\n    if(x > d.degree) // x<=degree\n      break;\n#endif\n    int index = cv0 + x;\n    vec4 pt = curve_cp3d(index, r, d, t);\n\n    if(d.degree < 3) {\n      // Rhino style evaluation....\n      highp float bvw = bv[x];\n      pos += pt.xyz * bvw;\n      w += pt.w * bvw;\n    }\n    else {\n      // Tiny NURBS/CADEx style evaluation....\n      highp float bvw = pt.w * bv[x];\n      pos += pt.xyz * bvw;\n      w += bvw;\n    }\n\n    tangent += pt.xyz * bvds[x];\n  }\n\n  pos /= w;\n\n\n  // Calc tangent\n  if(d.degree == 1){\n    vec3 pt0 = curve_cp3d(cv0, r, d, t).xyz;\n    vec3 pt1 = curve_cp3d(cv0+1, r, d, t).xyz;\n    tangent = pt1 - pt0;\n  }\n  else {\n    if (length(tangent) < 0.05) {\n\n      float spanLerp = u - knots[span];\n      float spanRange = knots[span+1] - knots[span];\n      int cv = int(floor((spanLerp / spanRange) * float(d.degree-1)));\n\n      vec3 pt0 = curve_cp3d(cv, r, d, t).xyz;\n      vec3 pt1 = curve_cp3d(cv+1, r, d, t).xyz;\n      tangent = pt1 - pt0;\n    }\n  }\n\n  return PosNorm(pos, normalize(tangent), CURVE_TYPE_NURBS_CURVE);\n}\n\n\n\n"),t.shaderLibrary.setShaderModule("GLSLNURBSSurfaces.glsl","\n\nstruct NURBSSurfaceData {\n  box2 domain;\n  bool periodicU;\n  bool periodicV;\n  int degreeU;\n  int degreeV;\n  int numCPsU;\n  int numCPsV;\n  int numKnotsU;\n  int numKnotsV;\n\n  int cpStart;\n  int kpUStart;\n  int kpVStart;\n};\n\nvoid loadNURBSSurfaceData(inout GLSLBinReader reader, sampler2D texture, out NURBSSurfaceData result) {\n\n  result.domain.p0.x = GLSLBinReader_readFloat(reader, texture);\n  result.domain.p0.y = GLSLBinReader_readFloat(reader, texture);\n  result.domain.p1.x = GLSLBinReader_readFloat(reader, texture);\n\n  result.domain.p1.y = GLSLBinReader_readFloat(reader, texture);\n  result.degreeU = GLSLBinReader_readInt(reader, texture);\n  if(result.degreeU > MAX_DEGREE)\n    result.degreeU = MAX_DEGREE;\n  result.degreeV = GLSLBinReader_readInt(reader, texture);\n  if(result.degreeV > MAX_DEGREE)\n    result.degreeV = MAX_DEGREE;\n  result.numCPsU = GLSLBinReader_readInt(reader, texture);\n\n  result.numCPsV = GLSLBinReader_readInt(reader, texture);\n  result.numKnotsU = GLSLBinReader_readInt(reader, texture);\n  result.numKnotsV = GLSLBinReader_readInt(reader, texture);\n  int flags = GLSLBinReader_readInt(reader, texture);\n  result.periodicU = testFlag(flags, SURFACE_FLAG_PERIODIC_U);\n  result.periodicV = testFlag(flags, SURFACE_FLAG_PERIODIC_V);\n\n  result.cpStart  = 3*4; // 3 RGBA pixels of data before the knot values start.\n  result.kpUStart = result.cpStart + (result.numCPsU*result.numCPsV*4);\n  result.kpVStart = result.kpUStart + result.numKnotsU;\n}\n\nvec4 surface_cp(int u, int v, inout GLSLBinReader r, NURBSSurfaceData d, sampler2D t) {\n  int index = (u + (v * d.numCPsU)) * 4;\n  return GLSLBinReader_readVec4(r, t, d.cpStart + index);\n}\n\n/*\n  Calculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n*/\nPosNorm calcNURBSSurfacePoint(vec2 params, inout GLSLBinReader r, sampler2D t) {\n\n  vec3 tmp;\n  NURBSSurfaceData d;\n  loadNURBSSurfaceData(r, t, d);\n\n  // ///////////////////////////////////////\n  // // vec3 cp_pos = vec3(params.x + float(d.degreeU), params.y + float(d.degreeV), 0.0 );\n  // vec3 cp_pos = vec3(params.x + float(d.numCPsU), params.y + float(d.numCPsV), 0.0 );\n  // return PosNorm(cp_pos, tmp);\n  // ///////////////////////////////////////\n\n  // ///////////////////////////////////////\n  // int knot_x = int(params.x * float(d.numCPsU-1));\n  // int knot_y = int(params.y * float(d.numCPsV-1));\n  // vec4 cp_pos = surface_cp(knot_x, knot_y, r, d, t);\n  // return PosNorm(cp_pos.xyz, tmp);\n  // ///////////////////////////////////////\n\n  vec2 uv = mapDomain(d.domain, params); // linear mapping params -> uv\n  float u = uv.x;\n  float v = uv.y;\n\n  highp float basisValuesU[MAX_DEGREE+1];\n  highp float basisValuesV[MAX_DEGREE+1];\n  highp float bvdsU[MAX_DEGREE+1];\n  highp float bvdsV[MAX_DEGREE+1];\n  \n#ifdef EXPORT_KNOTS_AS_DELTAS\n  highp float knotsU[MAX_DEGREE*2+1];\n  highp float knotsV[MAX_DEGREE*2+1];\n  int spanU = findSpan(u, d.degreeU, d.numKnotsU, d.kpUStart, r, t, knotsU);\n  int spanV = findSpan(v, d.degreeV, d.numKnotsV, d.kpVStart, r, t, knotsV);\n  calcBasisValues(u, d.degreeU, knotsU, basisValuesU, bvdsU);\n  calcBasisValues(v, d.degreeV, knotsV, basisValuesV, bvdsV);\n\n#else\n  int spanU = findSpan(u, d.degreeU, d.numKnotsU, d.kpUStart, r, t, d.periodicU);\n  int spanV = findSpan(v, d.degreeV, d.numKnotsV, d.kpVStart, r, t, d.periodicV);\n\n  calcBasisValues(u, spanU, d.degreeU, d.kpUStart, d.numKnotsU, r, t, basisValuesU, bvdsU);\n  calcBasisValues(v, spanV, d.degreeV, d.kpVStart, d.numKnotsV, r, t, basisValuesV, bvdsV);\n#endif\n\n  // ///////////////////////////////////////\n  // return PosNorm(vec3(knotsV[11], knotsV[12], knotsV[13]), tmp, SURFACE_TYPE_NURBS_SURFACE);\n  // return PosNorm(vec3(knotsV[14], knotsV[15], knotsV[16]), tmp, SURFACE_TYPE_NURBS_SURFACE);\n  // return PosNorm(vec3(knotsV[17], knotsV[18], knotsV[19]), tmp, SURFACE_TYPE_NURBS_SURFACE);\n  // return PosNorm(vec3(basisValuesU[0], basisValuesU[1], basisValuesU[2]), tmp, SURFACE_TYPE_NURBS_SURFACE);\n  // ///////////////////////////////////////\n\n  ivec2 indices;\n  highp float w = 0.0;\n  highp vec3 pos = vec3(0.0);\n  highp vec3 tangentU = vec3(0.0);\n  highp vec3 tangentV = vec3(0.0);\n  int cvU0 = (spanU - d.degreeU);\n  int cvV0 = (spanV - d.degreeV);\n#ifdef ENABLE_ES3\n  for(int y=0; y <= d.degreeV; y++) {\n#else\n  for(int y=0; y < MAX_DEGREE; y++) {\n     if(y > d.degreeV) // y<=degree\n         break;\n#endif\n    indices.y = cvV0 + y;\n\n#ifdef ENABLE_ES3\n    for(int x=0; x <= d.degreeU; x++) {\n#else\n    for(int x=0; x < MAX_DEGREE; x++) {\n      if(x > d.degreeU) // x<=degree\n        break;\n#endif\n      indices.x = cvU0 + x;\n      \n      vec4 cv = surface_cp(indices.x, indices.y, r, d, t);\n      vec3 pt = cv.xyz;\n      float weight = cv.w;\n\n      float bvU = basisValuesU[x];\n      float bvV = basisValuesV[y];\n\n// #define USE_RHNIO_EVALUATION_MATH 1\n#ifdef USE_RHNIO_EVALUATION_MATH\n      // Rhino style evaluation....\n      float bvw = bvU * bvV;\n      pos += pt * bvw;\n      w += weight * bvw;\n#else\n      // Tiny NURBS/CADEx style evaluation....\n      highp float bvw = weight * bvU * bvV;\n      pos += pt * bvw;\n      w += bvw;\n#endif\n        \n      float bvdU = bvdsU[x];\n      float bvdV = bvdsV[y];\n\n      tangentU += pt * bvdU * bvV;\n      tangentV += pt * bvU * bvdV;\n    }\n  }\n\n  pos /= w;\n\n  ///////////////////////////////////////////////////////\n  // Calculate normal.\n  float spanRangeU = knotsU[d.degreeU + 1] - knotsU[d.degreeU];\n  float spanRangeV = knotsV[d.degreeV + 1] - knotsV[d.degreeV];\n  float eqKnotRangeU = ( d.domain.p1.x - d.domain.p0.x ) / float(d.numKnotsU);\n  float eqKnotRangeV = ( d.domain.p1.y - d.domain.p0.y ) / float(d.numKnotsV);\n  \n  \n  if (spanRangeU / eqKnotRangeU < 0.01) { \n    // In some cases (COOLANT_INLET_PORT_01.ipt_faceWithBlackEdge.)\n    // we have span segment which has close to zero delta, and \n    // so the normals are broken. We want to advace along the \n    // e.g. [0, 0, 0, 0.00001, 1, 3, 3, 3]\n    // length of the span rather than when we have a pinched corner, \n    // where we move along the toher direction.\n    // console.log(v, 'spanRangeU:', spanRangeU, ' eqKnotRangeU:', eqKnotRangeU, spanRangeU / eqKnotRangeU)\n\n    int cvU = cvU0;\n    if (v > d.domain.p1.y - 0.0001) {\n      // If at the end then we grab the end of the pevious row.\n      cvU = cvU0 + d.degreeU - 2;\n    } else {\n      // if the broken normal is at the start of the U range, then \n      // we will grab the next in the row. \n      cvU = cvU0 + 1;\n    }\n\n    float spanLerpV = (u - knotsV[d.degreeV]) / spanRangeV;\n    int cvV = cvV0 + int(floor(spanLerpV * float(d.degreeV)));\n\n    vec3 pt0 = surface_cp(cvU, cvV, r, d, t).xyz;\n    vec3 pt1 = surface_cp(cvU+1, cvV, r, d, t).xyz;\n\n    tangentU = pt1 - pt0;\n  } else if (length(tangentU) < 0.001) {\n    // Note: on values to big, we get false positives.\n    // See: 2_SR00404681_1_RI510090.CATPart.zcad\n    // long narrow nurbs surface above the tail light.\n    // Reduced from 0.05 to 0.001 fixed it.\n\n    // The derivative in the V direction is zero, \n    // so we calculate the linear derivative for the next control points along.\n    \n    int cvV;\n    if (spanV > d.degreeV) {\n      // If at the end then we grab the end of the pevious row.\n      cvV = cvV0 + d.degreeV - 2;\n    } else {\n      // if the broken normal is at the start of the V range, then \n      // we will grab the next in the row. \n      cvV = cvV0 + 1;\n    }\n    \n    float spanLerpU = (u - knotsU[d.degreeU]) / spanRangeU;\n    int cvU = cvU0 + int(floor(spanLerpU * float(d.degreeU)));\n    \n    vec3 pt0 = surface_cp(cvU, cvV, r, d, t).xyz;\n    vec3 pt1 = surface_cp(cvU+1, cvV, r, d, t).xyz;\n\n    tangentU = pt1 - pt0;\n  }\n\n  if (spanRangeV / eqKnotRangeV < 0.01) {\n    // In some cases (COOLANT_INLET_PORT_01.ipt_faceWithBlackEdge.)\n    // we have span segment which has close to zero delta, and \n    // so the normals are broken. We want to advace along the \n    // e.g. [0, 0, 0, 0.00001, 1, 3, 3, 3]\n    // length of the span rather than when we have a pinched corner, \n    // where we move along the toher direction.\n    // console.log(v, 'spanRangeV:', spanRangeV, ' eqKnotRangeV:', eqKnotRangeV, spanRangeV / eqKnotRangeV)\n\n    int cvV = cvV0;\n    if (v > d.domain.p1.y - 0.0001) {\n      // If at the end then we grab the end of the pevious row.\n      cvV = cvV0 + d.degreeV - 2;\n    } else {\n      // if the broken normal is at the start of the V range, then \n      // we will grab the next in the row. \n      cvV = cvV0 + 1;\n    }\n\n    float spanLerpU = (u - knotsU[d.degreeU]) / spanRangeU;\n    int cvU = cvU0 + int(floor(spanLerpU * float(d.degreeU)));\n\n    vec3 pt0 = surface_cp(cvU, cvV, r, d, t).xyz;\n    vec3 pt1 = surface_cp(cvU, cvV+1, r, d, t).xyz;\n\n    tangentV = pt1 - pt0;\n    \n  } else if (length(tangentV) < 0.001) { \n    // Note: on values to big, we get false positives.\n    // See: 2_SR00404681_1_RI510090.CATPart.zcad\n    // long narrow nurbs surface above the tail light.\n    // Reduced from 0.05 to 0.001 fixed it.\n\n    // The derivative in the V direction is close to zero, \n    // so we calculate the linear derivative for the next control points along.\n\n    int cvU = cvU0;\n    if (v > d.domain.p1.y - 0.0001) {\n      // If at the end then we grab the end of the pevious row.\n      cvU = cvU0 + d.degreeU - 2;\n    } else {\n      // if the broken normal is at the start of the U range, then\n      // we will grab the next in the row.\n      cvU = cvU0 + 1;\n    }\n\n    float spanLerpV = (u - knotsV[d.degreeV]) / spanRangeV;\n    int cvV = cvV0 + int(floor(spanLerpV * float(d.degreeV)));\n\n    vec3 pt0 = surface_cp(cvU, cvV, r, d, t).xyz;\n    vec3 pt1 = surface_cp(cvU, cvV+1, r, d, t).xyz;\n\n    tangentV = pt1 - pt0;\n  }\n\n  // vec3 normal = tangentV;\n  // Note: in the gear_box_final_asm.zcad. the nurbs surfaces were all flipped\n  // This is only apparent in cut-away scenes, which the gearbox demo is.\n  // vec3 normal = normalize(cross(tangentV, tangentU));\n  vec3 normal = normalize(cross(tangentU, tangentV));\n\n  return PosNorm(pos, normal, SURFACE_TYPE_NURBS_SURFACE);\n}\n\n");const G=t.shaderLibrary.parseShader("GLEvaluateCADSurfaceShader.vertexShader",'\nprecision highp float;\n\nattribute vec3 positions;\ninstancedattribute float surfaceId;\n\nuniform sampler2D surfaceAtlasLayoutTexture;\nuniform ivec2 surfaceAtlasLayoutTextureSize;\n\nuniform ivec2 surfacesAtlasTextureSize;\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n\n/* VS Outputs */\nvarying float v_surfaceId;      // flat\nvarying vec3 v_geomDataCoords;  // flat\nvarying vec2 v_patchSize;       // flat\nvarying vec2 v_vertexCoord;\n\n\n\nvoid main(void) {\n\n  GLSLBinReader reader;\n  GLSLBinReader_init(reader, surfaceAtlasLayoutTextureSize, 32);\n  vec4 patchCoords = GLSLBinReader_readVec4(reader, surfaceAtlasLayoutTexture, int(surfaceId)*8);\n  vec4 surfaceDataCoords = GLSLBinReader_readVec4(reader, surfaceAtlasLayoutTexture, (int(surfaceId)*8)+4);\n\n  vec2 patchPos = patchCoords.xy;\n  v_patchSize = patchCoords.zw;\n\n  v_surfaceId = surfaceId;\n  v_geomDataCoords = surfaceDataCoords.xyz;\n  v_vertexCoord = (positions.xy + 0.5) * v_patchSize;\n\n  vec2 pos = (patchPos + v_vertexCoord) / vec2(surfacesAtlasTextureSize);\n  gl_Position = vec4((pos - 0.5) * 2.0, 0.0, 1.0);\n}\n');t.shaderLibrary.setShaderModule("GLSLCADSurfaceFragmentShader.glsl","\n\nstruct PosNorm {\n  vec3 pos;\n  vec3 normal;\n  int geomType;\n};\n\n/* VS Outputs */\nvarying float v_surfaceId;      // flat\nvarying vec3 v_geomDataCoords;  // flat\nvarying vec2 v_patchSize;       // flat\nvarying vec2 v_vertexCoord;\n\nuniform sampler2D surfaceDataTexture;\nuniform ivec2 surfaceDataTextureSize;\nuniform int writeNormals;\n\nvec2 initReader(inout GLSLBinReader reader) {\n\n  // compute exact xy coords per pixel by rounding the vertex coord to the nearest integer and then dividing my patch size.\n  // The interpollated xy coords from the quad are not exact because the quad must cover the pixels with some margin.\n\n  vec2 params = vec2(floor(v_vertexCoord.x), floor(v_vertexCoord.y));\n  if(v_patchSize.x > 1.0)\n    params.x /= v_patchSize.x - 1.0;\n  if(v_patchSize.y > 1.0)\n    params.y /= v_patchSize.y - 1.0;\n\n  ivec4 region = ivec4(0, 0, surfaceDataTextureSize.x, surfaceDataTextureSize.y);\n  ivec2 start = ivec2(v_geomDataCoords.xy);\n  int flags = int(v_geomDataCoords.z);\n  if(testFlag(flags, SURFACE_FLAG_FLIPPED_UV))  {\n    float tmp = params.x;\n    params.x = params.y;\n    params.y = tmp;\n  }\n\n  GLSLBinReader_init(reader, surfaceDataTextureSize, region, start, 32);\n\n  return params;\n}\n\n\nstruct box2 {\n  vec2 p0;\n  vec2 p1;\n};\n\nbox2 loadBox2(inout GLSLBinReader reader, sampler2D texture) {\n  box2 domain;\n  domain.p0.x = GLSLBinReader_readFloat(reader, texture);\n  domain.p0.y = GLSLBinReader_readFloat(reader, texture);\n  domain.p1.x = GLSLBinReader_readFloat(reader, texture);\n  domain.p1.y = GLSLBinReader_readFloat(reader, texture);\n  return domain;\n}\n\nvec2 mapDomain(box2 domain, vec2 params) {\n  return domain.p0 + params * ( domain.p1 - domain.p0 );\n}\n\n\n");class I extends t.GLShader{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=G,this.__shaderStages.FRAGMENT_SHADER=t.shaderLibrary.parseShader("GLEvaluateSimpleCADSurfaceShader.fragmentShader",'\n// #extension GL_EXT_draw_buffers : require\nprecision highp float;\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLCADSurfaceFragmentShader.glsl"/>\n\n<%include file="GLSLCADSimpleSurfaces.glsl"/>\n\nPosNorm evalCADSurfaces(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  // Evaluate the surface per vertex\n  int geomType = GLSLBinReader_readInt(reader, texture);\n\n  PosNorm posNorm;\n  if(geomType == SURFACE_TYPE_PLANE) {\n    posNorm = calcPlaneSurfacePoint(params, reader, texture);\n  } else if(geomType == SURFACE_TYPE_POLY_PLANE) {\n    posNorm = calcPolyPlaneSurfacePoint(params, reader, texture);\n  } else if(geomType == SURFACE_TYPE_FAN) {\n    posNorm = calcFanSurfacePoint(params, reader, texture);\n  } else if(geomType == SURFACE_TYPE_CONE) {\n    posNorm = calcConeSurfacePoint(params, reader, texture);\n  } else if(geomType == SURFACE_TYPE_CYLINDER) {\n    posNorm = calcCylinderSurfacePoint(params, reader, texture);\n  } else if(geomType == SURFACE_TYPE_SPHERE) {\n    posNorm = calcSphereSurfacePoint(params, reader, texture);\n  } else if(geomType == SURFACE_TYPE_TORUS) {\n    posNorm = calcTorusSurfacePoint(params, reader, texture);\n  }\n  return posNorm;\n}\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n  \n  GLSLBinReader reader;\n  vec2 xy = initReader(reader);\n  PosNorm posNorm = evalCADSurfaces(xy, reader, surfaceDataTexture);\n\n  if(writeNormals == 1) {\n    fragColor = vec4(posNorm.normal, float(posNorm.geomType));\n  }\n  else {\n    fragColor = vec4(posNorm.pos, float(posNorm.geomType));\n  }\n  // gl_FragData[0] = vec4(posNorm.pos, 1.0);\n  // gl_FragData[1] = vec4(posNorm.normal, 1.0);\n\n  // fragColor.r = v_geomDataCoords.x;\n  // fragColor.g = v_geomDataCoords.y;\n  // fragColor.r = floor(v_vertexCoord.x);\n  // fragColor.g = floor(v_vertexCoord.y);\n  // fragColor.b = v_patchSize.x;\n  // fragColor.a = v_patchSize.y;\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n')}}class F extends t.GLShader{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=G,this.__shaderStages.FRAGMENT_SHADER=t.shaderLibrary.parseShader("GLEvaluateCompoundCADSurfaceShader.fragmentShader",'\n// #extension GL_EXT_draw_buffers : require\nprecision highp float;\n\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n<%include file="GLSLCADSurfaceFragmentShader.glsl"/>\n\n<%include file="GLSLMath.glsl"/>\n\nuniform sampler2D curvesAtlasTexture;\nuniform ivec2 curvesAtlasTextureSize;\nuniform sampler2D curveTangentsTexture;\nuniform sampler2D curvesAtlasLayoutTexture;\nuniform ivec2 curvesAtlasLayoutTextureSize;\n\nvec3 getCurveVertex(ivec2 curvePatchCoords, int vertexCoord) {\n  return fetchTexel(curvesAtlasTexture, curvesAtlasTextureSize, ivec2(curvePatchCoords.x + vertexCoord, curvePatchCoords.y)).rgb;\n}\n\nvec3 getCurveTangent(ivec2 curvePatchCoords, int vertexCoord) {\n  return fetchTexel(curveTangentsTexture, curvesAtlasTextureSize, ivec2(curvePatchCoords.x + vertexCoord, curvePatchCoords.y)).rgb;\n}\n\nPosNorm evalCADCurve3d(int curveId, float u) {\n\n  GLSLBinReader curveLayoutDataReader;\n  GLSLBinReader_init(curveLayoutDataReader, curvesAtlasLayoutTextureSize, 32);\n  ivec4 curvePatch = ivec4(GLSLBinReader_readVec4(curveLayoutDataReader, curvesAtlasLayoutTexture, curveId * 8));\n\n  float t = float(curvePatch.z - 1) * u;\n  int vertexId0 = min(int(floor(t + 0.5)), curvePatch.z - 1);\n  // int vertexId1 = floor(t) + 1.0;\n  // float lerp = t - floor(t);\n\n  vec3 p0 = getCurveVertex(curvePatch.xy, vertexId0);\n  // vec3 p1 = getCurveVertex(curvePatch.xy, vertexId1);\n  vec3 t0 = getCurveTangent(curvePatch.xy, vertexId0);\n  // vec3 t1 = getCurveTangent(curvePatch.xy, vertexId1);\n\n  PosNorm res;\n  res.pos = p0;//mix(p0, p1, lerp);\n  res.normal = normalize(t0);//mix(t0, t1, lerp));\n  res.geomType = 0;\n\n  // res.pos.x = u;\n  // res.pos.y = float(curveId);\n  // res.pos.x = float(curvePatch.x);\n  // res.pos.y = float(curvePatch.y);\n  // res.pos.z = float(curvePatch.z);\n  return res;\n}\n\n\n<%include file="GLSLCADCompoundSurfaces.glsl"/>\n\nPosNorm evalCADSurfaces(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  // Evaluate the surface per vertex\n  int geomType = GLSLBinReader_readInt(reader, texture);\n\n  PosNorm posNorm;\n  if(geomType == SURFACE_TYPE_LINEAR_EXTRUSION) {\n    posNorm = calcLinearExtrusionSurfacePoint(params, reader, texture);\n  } else if(geomType == SURFACE_TYPE_REVOLUTION) {\n    posNorm = calcRevolutionSurfacePoint(params, reader, texture, false);\n  } else if(geomType == SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN) {\n    posNorm = calcRevolutionSurfacePoint(params, reader, texture, true);\n  } \n  \n  return posNorm;\n}\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n  \n  GLSLBinReader reader;\n  vec2 xy = initReader(reader);\n  PosNorm posNorm = evalCADSurfaces(xy, reader, surfaceDataTexture);\n\n  if(writeNormals == 1) {\n    fragColor = vec4(posNorm.normal, float(posNorm.geomType));\n  }\n  else {\n    fragColor = vec4(posNorm.pos, float(posNorm.geomType));\n  }\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n')}}class w extends t.GLShader{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=G,this.__shaderStages.FRAGMENT_SHADER=t.shaderLibrary.parseShader("GLEvaluateNURBSCADSurfaceShader.fragmentShader",'\n// #extension GL_EXT_draw_buffers : require\nprecision highp float;\n\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n<%include file="GLSLCADSurfaceFragmentShader.glsl"/>\n\n<%include file="GLSLNURBS.glsl"/>\n<%include file="GLSLNURBSSurfaces.glsl"/>\n\nPosNorm evalCADSurfaces(vec2 params, inout GLSLBinReader reader, sampler2D texture) {\n  // Evaluate the surface per vertex\n  int geomType = GLSLBinReader_readInt(reader, texture);\n\n  PosNorm posNorm;\n  if(geomType == SURFACE_TYPE_NURBS_SURFACE) {\n    posNorm = calcNURBSSurfacePoint(params, reader, texture);\n  }\n  \n  return posNorm;\n}\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n  \n  GLSLBinReader reader;\n  vec2 xy = initReader(reader);\n  PosNorm posNorm = evalCADSurfaces(xy, reader, surfaceDataTexture);\n\n  if(writeNormals == 1) {\n    fragColor = vec4(posNorm.normal, float(posNorm.geomType));\n  }\n  else {\n    fragColor = vec4(posNorm.pos, float(posNorm.geomType));\n  }\n\n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n')}}class P extends t.EventEmitter{constructor(e,r,a,n,s){super(),this.__gl=e,this.__cadpassdata=r,this.__surfacesLibrary=a,this.__glCurveLibrary=n,this.cadDataVersion=s;const i=this.__surfacesLibrary.getSurfaceBuffer(),o=Math.sqrt(i.byteLength/8);this.__surfaceDataTexture=new t.GLTexture2D(e,{format:"RGBA",type:"HALF_FLOAT",width:o,height:o,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:new Uint16Array(i)}),this.__bindAttr=(t,r,a,n,s,i=!0)=>{e.enableVertexAttribArray(t),e.vertexAttribPointer(t,r,e.FLOAT,!1,n,s),i&&e.vertexAttribDivisor(t,1)},this.evaluateSurfaceShaders=[],this.__surfaceDrawSets={}}drawSurfaceData(){const e={};if(!this.__surfaceDataTexture||!this.__cadpassdata.debugTrimSetsShader.bind(e))return!1;this.__surfaceDataTexture.bindToUniform(e,e.unifs.trimSetAtlasTexture),this.__cadpassdata.glplanegeom.bind(e),this.__cadpassdata.glplanegeom.draw()}evaluateSurfaces(e,r,a,n){const s=performance.now();if(0==r.length/8)return;const i=this.__gl;this.__surfaceAtlasLayoutTexture=new t.GLTexture2D(i,{format:"RGBA",type:"FLOAT",width:a[0],height:a[1],filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:r}),this.__surfacesAtlasTexture?this.__surfacesAtlasTexture.width==n[0]&&this.__surfacesAtlasTexture.height==n[1]||(this.__surfacesAtlasTexture.resize(n[0],n[1],!0),this.__surfacesFbo.resize()):(this.__surfacesAtlasTexture=new t.GLTexture2D(i,{format:"RGBA",type:"FLOAT",width:n[0],height:n[1],filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1}),this.__surfacesFbo=new t.GLFbo(i,this.__surfacesAtlasTexture),this.__surfacesFbo.setClearColor([0,0,0,0]),this.__surfacesFbo.bindAndClear(),this.__normalsTexture=new t.GLTexture2D(i,{format:"RGBA",type:"FLOAT",width:n[0],height:n[1],filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1}),this.__normalsFbo=new t.GLFbo(i,this.__normalsTexture),this.__normalsFbo.setClearColor([0,0,0,0]),this.__normalsFbo.bindAndClear());const o={},d={directives:[...i.shaderopts.directives]};this.cadDataVersion.compare([0,0,6])>=0&&d.directives.push("#define EXPORT_KNOTS_AS_DELTAS 1"),this.cadDataVersion.compare([0,0,26])>0&&d.directives.push("#define INTS_PACKED_AS_2FLOAT16 1"),e.forEach((e,t)=>{if(!this.evaluateSurfaceShaders[t]){let e;switch(t){case 0:e=new I(i);break;case 1:e=new F(i);break;case 2:e=new w(i)}e.compileForTarget(void 0,d),this.evaluateSurfaceShaders[t]=e}this.evaluateSurfaceShaders[t].bind(o),this.__cadpassdata.glplanegeom.bind(o);const r=o.unifs,a=o.attrs;this.__surfaceAtlasLayoutTexture.bindToUniform(o,r.surfaceAtlasLayoutTexture),i.uniform2i(r.surfaceAtlasLayoutTextureSize.location,this.__surfaceAtlasLayoutTexture.width,this.__surfaceAtlasLayoutTexture.height),i.uniform2i(r.surfacesAtlasTextureSize.location,this.__surfacesAtlasTexture.width,this.__surfacesAtlasTexture.height),this.__surfaceDataTexture.bindToUniform(o,r.surfaceDataTexture),i.uniform2i(r.surfaceDataTextureSize.location,this.__surfaceDataTexture.width,this.__surfaceDataTexture.height),r.curveTangentsTexture&&this.__glCurveLibrary.bindCurvesAtlas(o);const n=i.createBuffer();i.bindBuffer(i.ARRAY_BUFFER,n),i.bufferData(i.ARRAY_BUFFER,e,i.STATIC_DRAW),this.__bindAttr(a.surfaceId.location,1,i.FLOAT,4,0),this.__surfacesFbo.bind(),i.uniform1i(r.writeNormals.location,0),this.__cadpassdata.glplanegeom.drawInstanced(e.length),this.__normalsFbo.bind(),i.uniform1i(r.writeNormals.location,1),this.__cadpassdata.glplanegeom.drawInstanced(e.length),i.deleteBuffer(n)}),this.__surfacesFbo.unbind(),this.__surfacesAtlasLayout=r;return performance.now()-s}logSurfaceData(e){const t=this.__surfacesLibrary.getSurfaceBuffer(),r=new V(t);r.seek(8+16*e+4);const a=r.loadFloat16(),n=r.loadFloat16(),s=r.loadFloat16(),i=r.loadFloat16(),o=r.loadFloat16();console.log("logGeomData "+e+" detailU:["+a+","+n+"] sizeU ["+s+","+i+"] trimSetIndex:"+o)}drawSurfaceAtlas(e){if(!this.__normalsTexture||!this.__cadpassdata.debugTrimSetsShader.bind(e))return!1;this.__normalsTexture.bindToUniform(e,e.unifs.trimSetAtlasTexture),this.__cadpassdata.glplanegeom.bind(e),this.__cadpassdata.glplanegeom.draw()}bindSurfacesData(e){const t=this.__gl,r=e.unifs;this.__surfaceDataTexture.bindToUniform(e,r.surfaceDataTexture),t.uniform2i(r.surfaceDataTextureSize.location,this.__surfaceDataTexture.width,this.__surfaceDataTexture.height)}bindSurfacesAtlas(e){if(!this.__surfacesAtlasTexture)return!1;const t=e.unifs;this.__surfacesAtlasTexture.bindToUniform(e,t.surfacesAtlasTexture);const r=this.__gl;return t.normalsTexture&&this.__normalsTexture.bindToUniform(e,t.normalsTexture),t.surfacesAtlasTextureSize&&r.uniform2i(t.surfacesAtlasTextureSize.location,this.__surfacesAtlasTexture.width,this.__surfacesAtlasTexture.height),t.numSurfacesInLibrary&&r.uniform1i(t.numSurfacesInLibrary.location,this.__surfacesLibrary.getNumSurfaces()),t.surfaceAtlasLayoutTexture&&(this.__surfaceAtlasLayoutTexture.bindToUniform(e,t.surfaceAtlasLayoutTexture),r.uniform2i(t.surfaceAtlasLayoutTextureSize.location,this.__surfaceAtlasLayoutTexture.width,this.__surfaceAtlasLayoutTexture.height)),!0}getSurfaceData(e){return this.__surfacesLibrary.getSurfaceData(e)}destroy(){this.__surfaceDataTexture.destroy(),this.__surfacesAtlasTexture&&(this.__surfacesAtlasTexture.destroy(),this.__normalsTexture.destroy(),this.__surfacesFbo.destroy(),this.__normalsFbo.destroy())}}class U extends t.Mesh{constructor(e=1){super(),this.__detail=e,this.addVertexAttribute("vertexIds",t.Float32),this.__rebuild()}__rebuild(){this.setNumVertices(this.__detail+2),this.setFaceCounts([this.__detail]);for(let e=0;e<this.__detail;e++)this.setFaceVertexIndices(e,[0,e+1,e+2]);const e=this.getVertexAttribute("vertexIds");for(let t=0;t<=e.length;t++)e.setFloat32Value(t,t)}}class N extends t.Plane{constructor(e=1){super(1,2,e,1,!1,!1)}__resize(){this.__sizeXParam.getValue();const e=this.__sizeYParam.getValue(),t=this.__detailXParam.getValue(),r=this.__detailYParam.getValue(),a=this.getVertexAttribute("positions");let n=0;for(let s=0;s<=r;s++){const i=(s/r-.5)*e;for(let e=0;e<=t;e++){const t=e;a.getValueRef(n).set(t,i,0),n++}}this.setBoundingBoxDirty()}}const z={};class X{constructor(e,r,a){this.__gl=e,this.__detail=r,z[r]||(z[r]={glfangeom:new t.GLMesh(e,new U(r)),glstripgeom:new t.GLMesh(e,new N(r))}),this.__glfangeom=z[r].glfangeom,this.__glstripgeom=z[r].glstripgeom,this.__buffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.__buffer),e.bufferData(e.ARRAY_BUFFER,a,e.STATIC_DRAW),this.__drawCount=a.length/14}bindAttr(e,t,r,a,n){if(e<0)return;const s=this.__gl;s.enableVertexAttribArray(e),s.vertexAttribPointer(e,t,s.FLOAT,!1,a,n),s.vertexAttribDivisor(e,1)}setBuffer(){}drawFans(e){const t=this.__gl;this.__glfangeom.bind(e);const r=e.unifs,a=e.attrs;t.bindBuffer(t.ARRAY_BUFFER,this.__buffer),this.bindAttr(a.patchCoords.location,4,t.FLOAT,56,0),this.bindAttr(a.data0.location,4,t.FLOAT,56,16),this.bindAttr(a.data1.location,4,t.FLOAT,56,32),this.bindAttr(a.data2.location,2,t.FLOAT,56,48),t.uniform1i(r.numCurveVertices.location,this.__detail+1),this.__glfangeom.drawInstanced(this.__drawCount)}drawStrips(e){const t=this.__gl;this.__glstripgeom.bind(e);const r=e.unifs,a=e.attrs;t.bindBuffer(t.ARRAY_BUFFER,this.__buffer),this.bindAttr(a.patchCoords.location,4,t.FLOAT,56,0),this.bindAttr(a.data0.location,4,t.FLOAT,56,16),this.bindAttr(a.data1.location,4,t.FLOAT,56,32),this.bindAttr(a.data2.location,2,t.FLOAT,56,48),t.uniform1i(r.numCurveVertices.location,this.__detail+1),this.__glstripgeom.drawInstanced(this.__drawCount)}cleanup(){}}class M extends t.GLShader{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=t.shaderLibrary.parseShader("GLDrawTrimCurveFansShader.vertexShader",'\nprecision highp float;\n\nattribute float vertexIds;\ninstancedattribute vec4 patchCoords;         // instanced attribute..\ninstancedattribute vec4 data0;     // instanced attribute..\ninstancedattribute vec4 data1;     // instanced attribute..\ninstancedattribute vec2 data2;     // instanced attribute..\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLMath.glsl"/>\n\nuniform sampler2D curvesAtlasTexture;\nuniform ivec2 curvesAtlasTextureSize;\n\nuniform ivec2 trimSetAtlasTextureSize;\n\nuniform int numCurveVertices;\n\nstruct CurveRef {\n  int curveId;\n  vec2 tr;\n  mat2 mat;\n  int flags;\n\n  ivec2 addr;\n  int numCurveVertices;\n\n};\n\nvec2 getCurveVertex(in CurveRef curveRef, int vertexId) {\n    if(curveRef.flags != 0)\n      vertexId = curveRef.numCurveVertices - vertexId - 1;\n    return curveRef.tr + curveRef.mat * fetchTexel(curvesAtlasTexture, curvesAtlasTextureSize, ivec2(curveRef.addr.x + vertexId, curveRef.addr.y)).rg;\n}\n\n\nuniform sampler2D curvesAtlasLayoutTexture;\nuniform ivec2 curvesAtlasLayoutTextureSize;\n\nuniform sampler2D trimSetTexture;\nuniform ivec2 trimSetTextureSize;\n\n\n<%include file="GLSLBinReader.glsl"/>\n\nCurveRef getCurveRef(inout GLSLBinReader trimsetDataReader, in int curveRefStart, inout GLSLBinReader curvesAtlasLayoutDataReader) {\n\n  CurveRef curveRef;\n\n  // Get the Curve Id from the trimSet Atlas\n  curveRef.curveId = GLSLBinReader_readInt(trimsetDataReader, trimSetTexture, curveRefStart + 0);\n\n  // Get the Xfo for the curve\n  curveRef.tr = vec2(\n    GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 1), \n    GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 2)\n    );\n  curveRef.mat = mat2(\n    vec2(\n      GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 3), \n      GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 4)\n    ),\n    vec2(\n      GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 5), \n      GLSLBinReader_readFloat(trimsetDataReader, trimSetTexture, curveRefStart + 6)\n    ));\n\n  // Get the flags for the curve\n  curveRef.flags = GLSLBinReader_readInt(trimsetDataReader, trimSetTexture, curveRefStart + 7);\n\n\n  curveRef.addr = ivec2(\n    GLSLBinReader_readInt(curvesAtlasLayoutDataReader, curvesAtlasLayoutTexture, (curveRef.curveId * 8) + 0), \n    GLSLBinReader_readInt(curvesAtlasLayoutDataReader, curvesAtlasLayoutTexture, (curveRef.curveId * 8) + 1)\n    );\n  curveRef.numCurveVertices = GLSLBinReader_readInt(curvesAtlasLayoutDataReader, curvesAtlasLayoutTexture, (curveRef.curveId * 8) + 2);\n\n  return curveRef;\n}\n\n\n\nvoid main(void) {\n\n  vec2 pos;\n  int vertexId = ftoi(vertexIds);\n  if(vertexId == 0) {\n    pos = (patchCoords.xy + patchCoords.zw * 0.5) / vec2(trimSetAtlasTextureSize);\n  }\n  else {\n    vertexId--;\n\n    CurveRef curveRef;\n    curveRef.tr = data0.xy;\n    curveRef.mat = mat2(data0.zw, data1.xy);\n    curveRef.flags = ftoi(data2.x);\n\n    curveRef.addr = ivec2(ftoi(data1.z), ftoi(data1.w));\n    curveRef.numCurveVertices = numCurveVertices;\n\n    //////////////////////////////////////////////\n    pos = getCurveVertex(curveRef, vertexId);\n\n    /*\n    //////////////////////////////////////////////\n    \n    int loopStartPos = ftoi(data0.x);\n    int curveIndexWithLoop = ftoi(data0.y);\n\n    GLSLBinReader trimsetDataReader;\n    GLSLBinReader_init(trimsetDataReader, trimSetTextureSize, 16);\n    int numCurves = GLSLBinReader_readInt(trimsetDataReader, trimSetTexture, loopStartPos);\n\n    GLSLBinReader curvesAtlasLayoutDataReader;\n    GLSLBinReader_init(curvesAtlasLayoutDataReader, curvesAtlasLayoutTextureSize, 32);\n\n    CurveRef curveRef = getCurveRef(trimsetDataReader, loopStartPos + 1 + (curveIndexWithLoop * 8), curvesAtlasLayoutDataReader);\n    pos = getCurveVertex( curveRef, vertexId );\n\n\n    // Tranform the curve points by the xfo2d to put it into the coords of the trim set.\n    Xfo2d xfo2d = Xfo2d(data0.xy, data1.x, data0.zw);\n    pos = Xfo2D_transformVec2(xfo2d, pos);\n\n\n    //////////////////////////////////\n    // Due to the reduced precision we use to store our data\n    // we get cracks in the trim textures. To fix this we weld\n    // the end points of the trim curves here.\n    // For each end point of a curve, we find the joining end point \n    // and average their positions.\n\n    if(vertexId == 0) {\n      // Lookup the vertex of the previous curve.\n      int prevCurveIndexWithinLoop = curveIndexWithLoop - 1;\n      if(prevCurveIndexWithinLoop < 0)\n        prevCurveIndexWithinLoop += numCurves;\n      CurveRef prevCurveRef = getCurveRef(trimsetDataReader, loopStartPos + 1 + (prevCurveIndexWithinLoop * 8), curvesAtlasLayoutDataReader);\n\n      // Get the end of the previous curve.\n      vec2 prevCurveEndPos = getCurveVertex( prevCurveRef, prevCurveRef.numCurveVertices-1 );\n\n      pos = (pos + prevCurveEndPos) * 0.5;\n    }\n    else if(vertexId == numCurveVertices-1) {\n      // Lookup the vertex of the next curve.\n      int nextCurveIndexWithinLoop = curveIndexWithLoop + 1;\n      if(nextCurveIndexWithinLoop >= numCurves)\n        nextCurveIndexWithinLoop = 0;\n      CurveRef nextCurveRef = getCurveRef(trimsetDataReader, loopStartPos + 1 + (nextCurveIndexWithinLoop * 8), curvesAtlasLayoutDataReader);\n\n      // Get the start of the next curve.\n      vec2 nextCurveEndPos = getCurveVertex( nextCurveRef, 0 );\n      pos = (pos + nextCurveEndPos) * 0.5;\n    }\n\n    */\n    //////////////////////////////////////////////\n\n\n    // Now transform the trim set into the coords of the full texture.\n    pos = (patchCoords.xy + (pos * patchCoords.zw));\n    pos /= vec2(trimSetAtlasTextureSize);\n  }\n\n  // transform the position into clip space.\n  gl_Position = vec4(vec2(-1.0, -1.0) + (pos * 2.0), 0.0, 1.0);\n}\n'),this.__shaderStages.FRAGMENT_SHADER=t.shaderLibrary.parseShader("GLDrawTrimCurveFansShader.fragmentShader","\nprecision highp float;\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n    fragColor = vec4(1.0/255.0,0.0,0.0,1.0);\n    \n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n")}}t.Registry.register("GLDrawTrimCurveFansShader",M);class Z extends t.GLShader{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=t.shaderLibrary.parseShader("GLFlattenTrimSetsShader.vertexShader","\nprecision highp float;\n\nattribute vec4 positions;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n    v_texCoord = (positions.xy + 0.5);\n    gl_Position =  vec4(positions.xy * 2.0, 0.0, 1.0);\n}\n"),this.__shaderStages.FRAGMENT_SHADER=t.shaderLibrary.parseShader("GLFlattenTrimSetsShader.fragmentShader","\nprecision highp float;\n\nuniform sampler2D trimSetAtlasTexture;\nuniform ivec2 trimSetAtlasTextureSize;\n\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n\n// returns true if the texel will be kept\n// When the fans are rendered, the pixels are acumulated. \n// An even number means that the pixel should be discarded\n// and an odd number mean the pixel should be kept.\nbool sampleAtlas(vec2 offset){\n    return mod(texture2D(trimSetAtlasTexture, v_texCoord + (offset / vec2(trimSetAtlasTextureSize))).r * 255.0, 2.0) > 0.5;\n}\n\nint scoreAtlas(vec2 offset){\n  if(sampleAtlas(offset))\n    return 1;\n  else\n    return 0;\n}\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n  // if(sampleAtlas(vec2(0.0, 0.0))){\n  //   fragColor = vec4(1.0, 0.5, 0.5, 1.0);\n  // }\n  // else{\n  //   fragColor = vec4(0.0, 0.5, 0.5, 1.0);\n  // }\n  \n  // Smoothing. Look at neighboring pixels to see\n  // if we should fill in the gaps. Due to floating\n  // point issues, we see random pixels floating\n  // in the air that shold have been trimmed by the\n  // fan. If a point \n  int score = scoreAtlas(vec2(-1.0, 0.0)) + \n              scoreAtlas(vec2(-1.0,-1.0)) + \n              scoreAtlas(vec2( 0.0,-1.0)) + \n              scoreAtlas(vec2( 1.0,-1.0)) + \n              scoreAtlas(vec2( 1.0, 0.0)) + \n              scoreAtlas(vec2( 1.0, 1.0)) + \n              scoreAtlas(vec2( 0.0, 1.0)) + \n              scoreAtlas(vec2(-1.0, 1.0));\n\n  float r = 0.0;\n  if(sampleAtlas(vec2(0.0, 0.0))){\n    if(score >= 4) // corner verts have a score of 3\n      r = 1.0;\n    else\n      r = 0.0;\n  }\n  else{\n    if(score < 4) \n      r = 0.0;\n    else\n      r = 1.0;\n  }\n  fragColor = vec4(r, r, 0.0, 0.0);\n  \n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n")}}t.Registry.register("GLFlattenTrimSetsShader",Z);class Y extends t.GLShader{constructor(e){super(e),this.__shaderStages.VERTEX_SHADER=t.shaderLibrary.parseShader("GLDrawTrimCurveStripsShader.vertexShader",'\nprecision highp float;\n\nattribute vec4 positions;\ninstancedattribute vec4 patchCoords;         // instanced attribute..\ninstancedattribute vec4 data0;     // instanced attribute..\ninstancedattribute vec4 data1;     // instanced attribute..\ninstancedattribute vec3 data2;     // instanced attribute..\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLMath.glsl"/>\n\nuniform sampler2D curvesAtlasTexture;\nuniform ivec2 trimSetAtlasTextureSize;\n\nuniform int numCurveVertices;\nuniform float stripWidth;\n\nvec2 getCurveVertex(int vertexId, int flags) {\n  if(flags != 0)\n    vertexId = numCurveVertices - vertexId - 1;\n  return fetchTexel(curvesAtlasTexture, trimSetAtlasTextureSize, ivec2(int(data1.z) + vertexId, int(data1.w))).rg;\n}\n\n#define M_PI 3.1415926535897932384626433832795\n\n/* VS Outputs */\nvarying float v_curveIndexWithinLoop;\nvarying float v_gradient;\n\nvoid main(void) {\n\n  int vertexId = ftoi(positions.x);\n  float side = positions.y < 0.0 ? -1.0 : 1.0;\n  mat2 rot = mat2(data0.zw, data1.xy);\n  int curveRefFlags = ftoi(data2.x);\n  int curveIndexWithinLoop = ftoi(data2.y);\n  v_curveIndexWithinLoop = float(curveIndexWithinLoop);\n\n  // Tranform the curve points by the mat2 to put it into the coords of the trim set.\n  vec2 pos = data0.xy + (rot * getCurveVertex(vertexId, curveRefFlags));\n\n  //////////////////////////////////////////////\n  vec2 curveTangent;\n  if(vertexId > 0) {\n    vec2 posPrev = data0.xy + (rot * getCurveVertex(vertexId-1, curveRefFlags));\n    curveTangent += pos - posPrev;\n  }\n  if(vertexId < numCurveVertices-1) {\n    vec2 posNext = data0.xy + (rot * getCurveVertex(vertexId+1, curveRefFlags));\n    curveTangent += posNext - pos;\n  }\n  curveTangent = normalize(curveTangent);\n  vec2 curveNormal = vec2(-curveTangent.y, curveTangent.x);\n\n  // Fatten the strip\n  pos += (curveNormal * side * stripWidth) / patchCoords.zw;\n\n  //////////////////////////////////////////////\n  // Extend the strip by one pixel at each end.\n  if(vertexId == 0) {\n    pos -= curveTangent * (stripWidth / patchCoords.zw) * 0.5;\n  }\n  else if(vertexId == numCurveVertices-1) {\n    pos += curveTangent * (stripWidth / patchCoords.zw) * 0.5;\n  }\n  //////////////////////////////////////////////\n\n  // Now transform the trim set into the coords of the full texture.\n  pos = (patchCoords.xy + (pos * patchCoords.zw));\n  pos /= vec2(trimSetAtlasTextureSize);\n\n  // transform the position into clip space.\n  gl_Position = vec4((pos * 2.0) - 1.0, 0.0, 1.0);\n  \n\n  // The gradient should run 0.0 ... 1.0 from one side of the strip to the other.\n  // The side value ranges from -1.0 to +1.0\n\n  v_gradient = (side + 1.0) / 2.0;\n  // v_gradient = 1.0;\n\n  // Note: this causes the trim edge to move slightly to grow.\n  // This fills in slight gaps betwen trimmed surfaces.\n  // This causes lots of atrifacts on some thin surfaces\n  // On Mordacious, this causese many artifacts at the border of surfaces.\n  // v_gradient = (v_gradient * 1.1) + 0.05;\n  // v_gradient = (v_gradient * 1.2) + 0.1;\n  // v_gradient = (v_gradient * 1.5) + 0.25;\n  // v_gradient = (v_gradient * 2.0) + 0.5;\n  // v_gradient = (v_gradient * 2.0) + 1.0;\n}\n'),this.__shaderStages.FRAGMENT_SHADER=t.shaderLibrary.parseShader("GLDrawTrimCurveStripsShader.fragmentShader",'\nprecision highp float;\n\n<%include file="GLSLUtils.glsl"/>\n\nuniform int flatten;\n\n/* VS Outputs */\nvarying float v_curveIndexWithinLoop;\nvarying float v_gradient;\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  // Initially a build up the data around the edges by rasterizing a full color pixel,\n  // followed by a subtractive pass that cuts down the borders\n  //\n  // Initially, after the fans are rasterized \n  //     ----\n  //  .  |  .\n  //  .  |  .\n  //     ----\n  //\n  // Becomes \n  //  -------\n  //  .     .\n  //  .     .\n  //  -------\n  //\n  // Becomes \n  //    . ---\n  //    ./     \n  //   /. \n  //  -------\n  // After the subtraction pass\n\n\n  \n  if (flatten > 0) {\n    fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n  } else {\n    int curveIndexWithinLoop = ftoi(v_curveIndexWithinLoop);\n    if (curveIndexWithinLoop % 2 == 0) {\n      fragColor = vec4(v_gradient, 1.0, 1.0, 1.0);\n    }\n    else {\n      fragColor = vec4(1.0, v_gradient, 1.0, 1.0);\n    }\n  }\n    \n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n')}}t.Registry.register("GLDrawTrimCurveStripsShader",Y);class O extends t.GLShader{constructor(e){super(e),this.setShaderStage("VERTEX_SHADER","\nprecision highp float;\n\nattribute vec4 positions;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \nvoid main()\n{\n    v_texCoord = (positions.xy + 0.5);\n    gl_Position =  vec4(positions.xy * 2.0, 0.0, 1.0);\n    // gl_Position =  vec4(positions.xy + vec2(-0.5, 0.5), 0.0, 1.0);\n}\n"),this.setShaderStage("FRAGMENT_SHADER","\nprecision highp float;\n\nuniform sampler2D trimSetAtlasTexture;\n\n/* VS Outputs */\nvarying vec2 v_texCoord;\n \n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n  vec4 fragColor;\n#endif\n\n  vec4 col = texture2D(trimSetAtlasTexture, v_texCoord);\n  vec3 rgb = col.rgb / col.a;\n  fragColor = vec4(rgb,1.0);\n  \n#ifndef ENABLE_ES3\n  gl_FragColor = fragColor;\n#endif\n}\n")}}class k{constructor(e,r,a,n){this.__gl=e,this.__cadpassdata=r,this.__trimSetLibrary=a,this.__glCurvesLibrary=n;const s=this.__trimSetLibrary.getBinaryBuffer(),i=Math.sqrt(s.byteLength/8);this.__trimSetsTexture=new t.GLTexture2D(e,{format:"RGBA",type:"HALF_FLOAT",width:i,height:i,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:new Uint16Array(s)}),this.__bindAttr=(t,r,a,n,s,i=!0)=>{e.enableVertexAttribArray(t),e.vertexAttribPointer(t,r,e.FLOAT,!1,n,s),i&&e.vertexAttribDivisor(t,1)},this.__trimCurveDrawSets={}}evaluateTrimSets(e,r,a,n){const s=this.__gl;if(this.__trimSetsAtlasLayoutTexture=new t.GLTexture2D(this.__gl,{format:"RGBA",type:"FLOAT",width:n[0],height:n[1],filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:a}),this.__trimSetAtlasTexture)this.__trimSetAtlasTexture.width==r[0]&&this.__trimSetAtlasTexture.height==r[1]||(this.__trimSetAtlasTextureSize=r,this.__trimSetAtlasTexture.resize(r[0],r[1],!0),this.__trimSetAtlasFbo.resize());else{this.__trimSetAtlasTextureSize=r,(this.__trimSetAtlasTextureSize[0]>this.__cadpassdata.maxTexSize||this.__trimSetAtlasTextureSize[1]>this.__cadpassdata.maxTexSize)&&console.warn("trimSetAtlas  is too big to fit in a texture. The image will be downsized:"+this.__trimSetAtlasTextureSize+" maxTexSize:"+this.__cadpassdata.maxTexSize),this.__trimSetAtlasMaskTexture=new t.GLTexture2D(s,{format:"webgl2"==s.name?"RG":"RGBA",type:"UNSIGNED_BYTE",width:Math.min(this.__trimSetAtlasTextureSize[0],this.__cadpassdata.maxTexSize),height:Math.min(this.__trimSetAtlasTextureSize[1],this.__cadpassdata.maxTexSize),filter:"NEAREST"}),this.__trimSetAtlasMaskFbo=new t.GLFbo(s,this.__trimSetAtlasMaskTexture),this.__trimSetAtlasMaskFbo.setClearColor([0,0,0,0]);const e="webgl2"==s.name?"RG":"RGBA",a="LINEAR";this.__trimSetAtlasTexture=new t.GLTexture2D(s,{format:e,type:"UNSIGNED_BYTE",width:Math.min(this.__cadpassdata.maxTexSize,this.__trimSetAtlasTextureSize[0]),height:Math.min(this.__cadpassdata.maxTexSize,this.__trimSetAtlasTextureSize[1]),magFilter:a,minFilter:a}),this.__trimSetAtlasFbo=new t.GLFbo(s,this.__trimSetAtlasTexture),this.__trimSetAtlasFbo.setClearColor([0,0,0,0])}const i={};this.trimCurveFansShader||(this.trimCurveFansShader=new M(s),this.flattenTrimSetsShader=new Z(s),this.trimCurveStripsShader=new Y(s),this.debugTrimSetsShader=new O(s)),this.__trimSetAtlasMaskFbo.bindAndClear();{s.enable(s.BLEND),s.blendEquation(s.FUNC_ADD),s.blendFunc(s.ONE,s.ONE),this.trimCurveFansShader.bind(i);const t=i.unifs;this.__glCurvesLibrary.bindCurvesAtlas(i),s.uniform2i(t.trimSetAtlasTextureSize.location,this.__trimSetAtlasTextureSize[0],this.__trimSetAtlasTextureSize[1]),t.trimSetTexture&&(this.__trimSetsTexture.bindToUniform(i,t.trimSetTexture),t.trimSetTextureSize&&s.uniform2i(t.trimSetTextureSize.location,this.__trimSetsTexture.width,this.__trimSetsTexture.height),this.__trimSetsAtlasLayoutTexture.bindToUniform(i,t.curvesAtlasLayoutTexture),t.curvesAtlasLayoutTextureSize&&s.uniform2i(t.curvesAtlasLayoutTextureSize.location,this.__trimSetsAtlasLayoutTexture.width,this.__trimSetsAtlasLayoutTexture.height));for(const t in e){const r=parseInt(t);if(r<0)continue;let a=this.__trimCurveDrawSets[t];a||(a=new X(this.__gl,r,e[t]),this.__trimCurveDrawSets[t]=a),a.drawFans(i)}s.disable(s.BLEND)}this.__trimSetAtlasFbo.bindAndClear();{this.flattenTrimSetsShader.bind(i);const e=i.unifs;this.__trimSetAtlasMaskTexture.bindToUniform(i,e.trimSetAtlasTexture),e.trimSetAtlasTextureSize&&this.__gl.uniform2i(e.trimSetAtlasTextureSize.location,this.__trimSetAtlasTextureSize[0],this.__trimSetAtlasTextureSize[1]),this.__cadpassdata.glplanegeom.bind(i),this.__cadpassdata.glplanegeom.draw()}{this.trimCurveStripsShader.bind(i);const t=i.unifs;this.__glCurvesLibrary.bindCurvesAtlas(i),s.uniform2i(t.trimSetAtlasTextureSize.location,this.__trimSetAtlasTextureSize[0],this.__trimSetAtlasTextureSize[1]),s.uniform1f(t.stripWidth.location,1.25),s.uniform1i(t.flatten.location,1),s.disable(s.BLEND);for(const t in e){const r=parseInt(t);if(r<0)continue;let a=this.__trimCurveDrawSets[t];a||(a=new X(this.__gl,r,e[t]),this.__trimCurveDrawSets[t]=a),a.drawStrips(i)}s.uniform1i(t.flatten.location,0),s.enable(s.BLEND),s.blendEquation(s.MIN),s.blendFunc(s.ONE,s.ONE);for(const t in e){const r=parseInt(t);if(r<0)continue;let a=this.__trimCurveDrawSets[t];a||(a=new X(this.__gl,r,e[t]),this.__trimCurveDrawSets[t]=a),a.drawStrips(i)}s.disable(s.BLEND)}for(const t in e){const e=this.__trimCurveDrawSets[t];e&&e.cleanup()}this.__trimSetsAtlasLayoutData=a,s.finish()}logTrimSetMask(e){const t=this.__gl;this.__trimSetAtlasMaskFbo.bind();const r=[this.__trimSetsAtlasLayoutData[4*e+0],this.__trimSetsAtlasLayoutData[4*e+1],this.__trimSetsAtlasLayoutData[4*e+2],this.__trimSetsAtlasLayoutData[4*e+3]];console.log("logTrimSetMask "+e+":["+r[0]+","+r[1]+"]:"+r[2]+"x"+r[3]);const a=new Uint8Array(4*r[2]);for(let e=0;e<r[3];e++){t.readPixels(r[0],r[1]+e,r[2],1,"webgl2"==t.name?t.RED:t.RGBA,t.UNSIGNED_BYTE,a);let n=e+" ";for(let e=0;e<r[2];e++)n+=a[4*e];console.log(n)}}logTrimSet(e){const t=this.__gl;this.__trimSetAtlasFbo.bind();const r=[this.__trimSetsAtlasLayoutData[4*e+0],this.__trimSetsAtlasLayoutData[4*e+1],this.__trimSetsAtlasLayoutData[4*e+2],this.__trimSetsAtlasLayoutData[4*e+3]];console.log("logTrimSet "+e+":["+r[0]+","+r[1]+"]:"+r[2]+"x"+r[3]);const a=new Uint16Array(4*r[2]);for(let e=0;e<r[3];e++){t.readPixels(r[0],r[1]+e,r[2],1,t.RGBA,t.HALF_FLOAT,a);let n=e+" ";for(let e=0;e<r[2];e++)n+=a[4*e];console.log(n)}}bindTrimSetAtlas(e){const t=this.__gl,r=e.unifs,{trimSetAtlasTexture:a,trimSetAtlasTextureSize:n}=r;this.__trimSetAtlasTexture&&a&&(this.__trimSetAtlasTexture.bindToUniform(e,a),n&&t.uniform2i(n.location,this.__trimSetAtlasTextureSize[0],this.__trimSetAtlasTextureSize[1]),this.ext_filter_anisotropic&&t.texParameterf(t.TEXTURE_2D,this.ext_filter_anisotropic.TEXTURE_MAX_ANISOTROPY_EXT,1))}bindTrimSetAtlasLayout(e){if(!this.__trimSetsAtlasLayoutTexture)return;const t=this.__gl,r=e.unifs;this.__trimSetsAtlasLayoutTexture.bindToUniform(e,r.trimSetsAtlasLayoutTexture),t.uniform2i(r.trimSetsAtlasLayoutTextureSize.location,this.__trimSetsAtlasLayoutTexture.width,this.__trimSetsAtlasLayoutTexture.height)}drawTrimSets(e){if(!this.__trimSetAtlasTexture||!this.debugTrimSetsShader.bind(e))return!1;this.__trimSetAtlasTexture.bindToUniform(e,e.unifs.trimSetAtlasTexture),this.__cadpassdata.glplanegeom.bind(e),this.__cadpassdata.glplanegeom.draw()}destroy(){this.__trimSetsTexture.destroy(),this.__trimSetsAtlasLayoutTexture&&(this.__trimSetsAtlasLayoutTexture.destroy(),this.__trimSetAtlasMaskTexture.destroy(),this.__trimSetAtlasMaskFbo.destroy(),this.__trimSetAtlasTexture.destroy(),this.__trimSetAtlasFbo.destroy())}}class W extends t.EventEmitter{constructor(e,t){super(),this.cadBody=e,this.bodyId=t,this.flags=0,this.dirtyValues=new Set}bind(e,t,r,a,n,s,i){this.cadBodyTextureData=r;const o=this.cadBody.getBodyDataTexelCoords();this.cadBody.isVisible()||(this.flags|=512),this.cadBody.isCutawayEnabled&&this.cadBody.isCutawayEnabled()&&(this.flags|=256);const d=this.cadBody.getMaterial(),l=e.genShaderID(d.getShaderName());let c=d.getMetadata("glmaterialcoords");c||(c=e.materialLibrary.addMaterial(d)),t[0]=this.cadBody.getBodyDescId(),t[1]=l,r[0]=this.cadBody.getBodyDescId(),r[1]=this.flags,r[2]=o.x,r[3]=o.y,r[4]=c.x,r[5]=c.y,this.visibilityChanged=()=>{this.cadBody.isVisible()?0!=(512&this.flags)&&(this.flags&=-513,this.cadBodyTextureData[1]=this.flags,a(this.bodyId)):0==(512&this.flags)&&(this.flags|=512,this.cadBodyTextureData[1]=this.flags,a(this.bodyId))},this.cadBody.on("visibilityChanged",this.visibilityChanged),this.materialChanged=()=>{const t=this.cadBody.getMaterial();let n=t.getMetadata("glmaterialcoords");n||(n=e.materialLibrary.addMaterial(t)),r[4]=n.x,r[5]=n.y,a(this.bodyId)},this.cadBody.getParameter("Material").on("valueChanged",this.materialChanged),this.globalXfoParam=this.cadBody.getParameter("GlobalXfo"),this.updateXfo(),this.globalXfoChanged=()=>{a(this.bodyId),this.dirtyValues.add("Xfo")},this.globalXfoParam.on("valueChanged",this.globalXfoChanged),this.cadBody.isHighlighted()&&(this.updateHighlightColor(),n.push(this.bodyId)),this.highlightChanged=()=>{s.dirty||(setTimeout(i,1),s.dirty=!0);if(this.cadBody.isHighlighted()){if(this.dirtyValues.add("Highlight"),a(this.bodyId),-1==n.indexOf(this.bodyId)){n.push(this.bodyId);const e=s.unhighlightedBodyIds.indexOf(this.bodyId);-1!=e?s.unhighlightedBodyIds.splice(e,1):s.highlightedBodyIds.push(this.bodyId)}}else{const e=n.indexOf(this.bodyId);if(-1!=e){n.splice(e,1);const t=s.highlightedBodyIds.indexOf(this.bodyId);-1!=t?s.highlightedBodyIds.splice(t,1):s.unhighlightedBodyIds.push(this.bodyId)}}},this.cadBody.on("highlightChanged",this.highlightChanged),this.updateCutaway(),this.cutAwayChangedId=this.cadBody.on("cutAwayChanged",()=>{a(this.bodyId),this.dirtyValues.add("Cutaway")})}updateCutaway(){if(this.cadBody.isCutawayEnabled()){256&this.flags||(this.flags|=256,this.cadBodyTextureData[1]=this.flags);const e=this.cadBody.getCutVector(),t=this.cadBody.getCutDist();this.cadBodyTextureData[24]=e.x,this.cadBodyTextureData[25]=e.y,this.cadBodyTextureData[26]=e.z,this.cadBodyTextureData[27]=t}else 256&this.flags&&(this.flags&=-257,this.cadBodyTextureData[1]=this.flags)}updateHighlightColor(){const e=this.cadBody.getHighlight();if(e){const t=20;this.cadBodyTextureData[t+0]=e.r,this.cadBodyTextureData[t+1]=e.g,this.cadBodyTextureData[t+2]=e.b,this.cadBodyTextureData[t+3]=e.a}}updateXfo(){const e=this.globalXfoParam.getValue();this.cadBodyTextureData[8]=e.tr.x,this.cadBodyTextureData[9]=e.tr.y,this.cadBodyTextureData[10]=e.tr.z,this.cadBodyTextureData[12]=e.ori.x,this.cadBodyTextureData[13]=e.ori.y,this.cadBodyTextureData[14]=e.ori.z,this.cadBodyTextureData[15]=e.ori.w,this.cadBodyTextureData[16]=e.sc.x,this.cadBodyTextureData[17]=e.sc.y,this.cadBodyTextureData[18]=e.sc.z}updateCadBodyTex(){this.dirtyValues.forEach(e=>{"Xfo"==e?this.updateXfo():"Highlight"==e?this.updateHighlightColor():"Cutaway"==e&&this.updateCutaway()}),this.dirtyValues.clear()}destroy(){if(this.cadBody.off("visibilityChanged",this.visibilityChanged),this.cadBody.cutAwayChanged)this.cadBody.off("cutAwayChanged",this.cutAwayChangedId);else{const e=this.cadBody.getParameter("CutawayEnabled");e&&e.off("valueChanged",this.cutAwayEnabledId)}this.cadBody.getParameter("Material").off("valueChanged",this.materialChanged),this.cadBody.getParameter("GlobalXfo").off("valueChanged",this.globalXfoChanged),this.cadBody.off("highlightChanged",this.highlightChanged)}}const K="[object process]"===Object.prototype.toString.call("undefined"!=typeof process?process:0),H=K&&"function"==typeof module.require?module.require:null;var Q=function(e,t=null,r=!1){const a=K?function(e,t){return Buffer.from(e,"base64").toString(t?"utf16":"utf8")}(e,r):function(e,t){const r=atob(e);if(t){const e=new Uint8Array(r.length);return Array.prototype.forEach.call(e,(e,t,a)=>{a[t]=r.charCodeAt(t)}),String.fromCharCode.apply(null,new Uint16Array(e.buffer))}return r}(e,r),n=a.indexOf("\n",10)+1,s=a.substring(n)+(t?"//# sourceMappingURL="+t:"");if(H){const e=H("worker_threads").Worker;return function(t){return new e(s,Object.assign({},t,{eval:!0}))}}const i=new Blob([s],{type:"application/javascript"}),o=URL.createObjectURL(i);return function(e){return new Worker(o,e)}}("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwpjbGFzcyB0e2NvbnN0cnVjdG9yKHQ9MCxlPTApe3RoaXMucm9vdD17eDowLHk6MCx3OnQsaDplfX1maXQodCl7aWYoMD09dC5sZW5ndGgpcmV0dXJuO3RoaXMucm9vdC53PHRbMF0udyYmKHRoaXMucm9vdC53PXRbMF0udyksdGhpcy5yb290Lmg8dFswXS5oJiYodGhpcy5yb290Lmg9dFswXS5oKTt0LmZvckVhY2godD0+e3QuZml0PXRoaXMuX19hZGRCbG9jayh0KX0pfV9fYWRkQmxvY2sodCl7Y29uc3QgZT10aGlzLmZpbmROb2RlKHRoaXMucm9vdCx0LncsdC5oKTtyZXR1cm4gZT90aGlzLnNwbGl0Tm9kZShlLHQudyx0LmgpOnRoaXMuZ3Jvd05vZGUodC53LHQuaCl9YWRkQmxvY2sodCl7dGhpcy5yb290LnVzZWR8fCh0aGlzLnJvb3Qudzx0LncmJih0aGlzLnJvb3Qudz10LncpLHRoaXMucm9vdC5oPHQuaCYmKHRoaXMucm9vdC5oPXQuaCkpO2NvbnN0IGU9dGhpcy5maW5kTm9kZSh0aGlzLnJvb3QsdC53LHQuaCk7cmV0dXJuIGU/dGhpcy5zcGxpdE5vZGUoZSx0LncsdC5oKTp0aGlzLmdyb3dOb2RlKHQudyx0LmgpfWZpbmROb2RlKHQsZSxzKXtyZXR1cm4gdC51c2VkP3RoaXMuZmluZE5vZGUodC5yaWdodCxlLHMpfHx0aGlzLmZpbmROb2RlKHQuZG93bixlLHMpOmU8PXQudyYmczw9dC5oP3Q6bnVsbH1zcGxpdE5vZGUodCxlLHMpe3JldHVybiB0LnVzZWQ9ITAsdC5kb3duPXt4OnQueCx5OnQueStzLHc6dC53LGg6dC5oLXN9LHQucmlnaHQ9e3g6dC54K2UseTp0Lnksdzp0LnctZSxoOnN9LHR9Z3Jvd05vZGUodCxlKXtjb25zdCBzPXQ8PXRoaXMucm9vdC53LG89ZTw9dGhpcy5yb290Lmgscj1vJiZ0aGlzLnJvb3QuaD49dGhpcy5yb290LncrdCxhPXMmJnRoaXMucm9vdC53Pj10aGlzLnJvb3QuaCtlO3JldHVybiByP3RoaXMuZ3Jvd1JpZ2h0KHQsZSk6YT90aGlzLmdyb3dEb3duKHQsZSk6bz90aGlzLmdyb3dSaWdodCh0LGUpOnM/dGhpcy5ncm93RG93bih0LGUpOm51bGx9Z3Jvd1JpZ2h0KHQsZSl7dGhpcy5yb290PXt1c2VkOiEwLHg6MCx5OjAsdzp0aGlzLnJvb3Qudyt0LGg6dGhpcy5yb290LmgsZG93bjp0aGlzLnJvb3QscmlnaHQ6e3g6dGhpcy5yb290LncseTowLHc6dCxoOnRoaXMucm9vdC5ofX07Y29uc3Qgcz10aGlzLmZpbmROb2RlKHRoaXMucm9vdCx0LGUpO2xldCBvO3JldHVybiBzJiYobz10aGlzLnNwbGl0Tm9kZShzLHQsZSkpLG99Z3Jvd0Rvd24odCxlKXt0aGlzLnJvb3Q9e3VzZWQ6ITAseDowLHk6MCx3OnRoaXMucm9vdC53LGg6dGhpcy5yb290LmgrZSxkb3duOnt4OjAseTp0aGlzLnJvb3QuaCx3OnRoaXMucm9vdC53LGg6ZX0scmlnaHQ6dGhpcy5yb290fTtjb25zdCBzPXRoaXMuZmluZE5vZGUodGhpcy5yb290LHQsZSk7bGV0IG87cmV0dXJuIHMmJihvPXRoaXMuc3BsaXROb2RlKHMsdCxlKSksb319Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0LGU9MCxzPSEwKXt0aGlzLl9fZGF0YT10LHRoaXMuX19ieXRlT2Zmc2V0PWUsdGhpcy5fX2RhdGFWaWV3PW5ldyBEYXRhVmlldyh0aGlzLl9fZGF0YSksdGhpcy5fX2lzTW9iaWxlRGV2aWNlPXMsdGhpcy51dGY4ZGVjb2Rlcj1uZXcgVGV4dERlY29kZXJ9Z2V0IGlzTW9iaWxlRGV2aWNlKCl7cmV0dXJuIHRoaXMuX19pc01vYmlsZURldmljZX1nZXQgZGF0YSgpe3JldHVybiB0aGlzLl9fZGF0YX1nZXQgYnl0ZUxlbmd0aCgpe3JldHVybiB0aGlzLl9fZGF0YVZpZXcuYnl0ZUxlbmd0aH1nZXQgcmVtYWluaW5nQnl0ZUxlbmd0aCgpe3JldHVybiB0aGlzLl9fZGF0YVZpZXcuYnl0ZUxlbmd0aC10aGlzLl9fYnl0ZU9mZnNldH1wb3MoKXtyZXR1cm4gdGhpcy5fX2J5dGVPZmZzZXR9c2Vlayh0KXt0aGlzLl9fYnl0ZU9mZnNldD10fWFkdmFuY2UodCl7dGhpcy5fX2J5dGVPZmZzZXQrPXR9bG9hZFVJbnQ4KCl7Y29uc3QgdD10aGlzLl9fZGF0YVZpZXcuZ2V0VWludDgodGhpcy5fX2J5dGVPZmZzZXQpO3JldHVybiB0aGlzLl9fYnl0ZU9mZnNldCs9MSx0fWxvYWRVSW50MTYoKXtjb25zdCB0PXRoaXMuX19kYXRhVmlldy5nZXRVaW50MTYodGhpcy5fX2J5dGVPZmZzZXQsITApO3JldHVybiB0aGlzLl9fYnl0ZU9mZnNldCs9Mix0fWxvYWRVSW50MzIoKXtjb25zdCB0PXRoaXMuX19kYXRhVmlldy5nZXRVaW50MzIodGhpcy5fX2J5dGVPZmZzZXQsITApO3JldHVybiB0aGlzLl9fYnl0ZU9mZnNldCs9NCx0fWxvYWRTSW50MzIoKXtjb25zdCB0PXRoaXMuX19kYXRhVmlldy5nZXRJbnQzMih0aGlzLl9fYnl0ZU9mZnNldCwhMCk7cmV0dXJuIHRoaXMuX19ieXRlT2Zmc2V0Kz00LHR9bG9hZEZsb2F0MTYoKXtyZXR1cm4odD0+e2NvbnN0IGU9KDMyNzY4JnQpPj4xNSxzPSgzMTc0NCZ0KT4+MTAsbz0xMDIzJnQ7cmV0dXJuIDA9PXM/KGU/LTE6MSkqTWF0aC5wb3coMiwtMTQpKihvL01hdGgucG93KDIsMTApKTozMT09cz9vP05hTjoxLzAqKGU/LTE6MSk6KGU/LTE6MSkqTWF0aC5wb3coMixzLTE1KSooMStvL01hdGgucG93KDIsMTApKX0pKHRoaXMubG9hZFVJbnQxNigpKX1sb2FkVUZsb2F0MTYoKXtjb25zdCB0PXRoaXMubG9hZEZsb2F0MTYoKTtyZXR1cm4gdDwwPzIwNDgtdDp0fWxvYWRGbG9hdDE2RnJvbTJ4VUludDgoKXtjb25zdCB0PXRoaXMuX19kYXRhVmlldy5nZXRGbG9hdDE2KHRoaXMuX19ieXRlT2Zmc2V0LCEwKTtyZXR1cm4gdGhpcy5fX2J5dGVPZmZzZXQrPTIsdH1sb2FkVUludDMyRnJvbTJ4VUZsb2F0MTYoKXtyZXR1cm4gdGhpcy5sb2FkVUZsb2F0MTYoKSs0MDk2KnRoaXMubG9hZFVGbG9hdDE2KCl9bG9hZFNJbnQzMkZyb20yeEZsb2F0MTYoKXtyZXR1cm4gdGhpcy5sb2FkRmxvYXQxNigpKzIwNDgqdGhpcy5sb2FkRmxvYXQxNigpfWxvYWRGbG9hdDMyKCl7Y29uc3QgdD10aGlzLl9fZGF0YVZpZXcuZ2V0RmxvYXQzMih0aGlzLl9fYnl0ZU9mZnNldCwhMCk7cmV0dXJuIHRoaXMuX19ieXRlT2Zmc2V0Kz00LHR9bG9hZFVJbnQ4QXJyYXkodCxlPSExKXtudWxsPT10JiYodD10aGlzLmxvYWRVSW50MzIoKSk7Y29uc3Qgcz1uZXcgVWludDhBcnJheSh0aGlzLl9fZGF0YSx0aGlzLl9fYnl0ZU9mZnNldCx0KTt0aGlzLl9fYnl0ZU9mZnNldCs9dDt0aGlzLl9fYnl0ZU9mZnNldDtyZXR1cm4gc31sb2FkVUludDE2QXJyYXkodCxlPSExKXtpZihudWxsPT10JiYodD10aGlzLmxvYWRVSW50MzIoKSksMD09dClyZXR1cm4gbmV3IFVpbnQxNkFycmF5O2xldCBzO2lmKHRoaXMucmVhZFBhZGQoMiksdGhpcy5fX2lzTW9iaWxlRGV2aWNlKXtzPW5ldyBVaW50MTZBcnJheSh0KTtmb3IobGV0IGU9MDtlPHQ7ZSsrKXNbZV09dGhpcy5fX2RhdGFWaWV3LmdldFVpbnQxNih0aGlzLl9fYnl0ZU9mZnNldCwhMCksdGhpcy5fX2J5dGVPZmZzZXQrPTJ9ZWxzZSBzPW5ldyBVaW50MTZBcnJheSh0aGlzLl9fZGF0YSx0aGlzLl9fYnl0ZU9mZnNldCx0KSx0aGlzLl9fYnl0ZU9mZnNldCs9Mip0O3JldHVybiBzfWxvYWRVSW50MzJBcnJheSh0LGU9ITEpe2lmKG51bGw9PXQmJih0PXRoaXMubG9hZFVJbnQzMigpKSwwPT10KXJldHVybiBuZXcgVWludDMyQXJyYXk7bGV0IHM7aWYodGhpcy5yZWFkUGFkZCg0KSx0aGlzLl9faXNNb2JpbGVEZXZpY2Upe3M9bmV3IFVpbnQzMkFycmF5KHQpO2ZvcihsZXQgZT0wO2U8dDtlKyspc1tlXT10aGlzLl9fZGF0YVZpZXcuZ2V0VWludDMyKHRoaXMuX19ieXRlT2Zmc2V0LCEwKSx0aGlzLl9fYnl0ZU9mZnNldCs9NH1lbHNlIHM9bmV3IFVpbnQzMkFycmF5KHRoaXMuX19kYXRhLHRoaXMuX19ieXRlT2Zmc2V0LHQpLHRoaXMuX19ieXRlT2Zmc2V0Kz00KnQ7cmV0dXJuIHN9bG9hZEZsb2F0MzJBcnJheSh0LGU9ITEpe2lmKG51bGw9PXQmJih0PXRoaXMubG9hZFVJbnQzMigpKSwwPT10KXJldHVybiBuZXcgRmxvYXQzMkFycmF5O2xldCBzO2lmKHRoaXMucmVhZFBhZGQoNCksdGhpcy5fX2lzTW9iaWxlRGV2aWNlKXtzPW5ldyBGbG9hdDMyQXJyYXkodCk7Zm9yKGxldCBlPTA7ZTx0O2UrKylzW2VdPXRoaXMuX19kYXRhVmlldy5nZXRGbG9hdDMyKHRoaXMuX19ieXRlT2Zmc2V0LCEwKSx0aGlzLl9fYnl0ZU9mZnNldCs9NH1lbHNlIHM9bmV3IEZsb2F0MzJBcnJheSh0aGlzLl9fZGF0YSx0aGlzLl9fYnl0ZU9mZnNldCx0KSx0aGlzLl9fYnl0ZU9mZnNldCs9NCp0O3JldHVybiBzfWxvYWRTdHIoKXtjb25zdCB0PXRoaXMubG9hZFVJbnQzMigpLGU9bmV3IFVpbnQ4QXJyYXkodGhpcy5fX2RhdGEsdGhpcy5fX2J5dGVPZmZzZXQsdCk7dGhpcy5fX2J5dGVPZmZzZXQrPXQ7bGV0IHM9IiI7Zm9yKGxldCBvPTA7bzx0O28rKylzKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbb10pO3JldHVybiBzfWxvYWRTdHJBcnJheSgpe2NvbnN0IHQ9dGhpcy5sb2FkVUludDMyKCksZT1bXTtmb3IobGV0IHM9MDtzPHQ7cysrKWVbc109dGhpcy5sb2FkU3RyKCk7cmV0dXJuIGV9cmVhZFBhZGQodCl7Y29uc3QgZT10aGlzLl9fYnl0ZU9mZnNldCV0OzAhPWUmJih0aGlzLl9fYnl0ZU9mZnNldCs9dC1lKX19Y29uc3Qgcz0wLG89MSxyPTIsYT0zLG49NCxpPTUsbD02LGg9OCx1PTksYz0xMCxmPTE0LGQ9MTUsdz0xNixfPXQ9Pntzd2l0Y2godCl7Y2FzZSBzOnJldHVybiJTVVJGQUNFX1RZUEVfUExBTkUiO2Nhc2UgbzpyZXR1cm4iU1VSRkFDRV9UWVBFX0NPTkUiO2Nhc2UgcjpyZXR1cm4iU1VSRkFDRV9UWVBFX0NZTElOREVSIjtjYXNlIGE6cmV0dXJuIlNVUkZBQ0VfVFlQRV9TUEhFUkUiO2Nhc2UgbjpyZXR1cm4iU1VSRkFDRV9UWVBFX1RPUlVTIjtjYXNlIGk6cmV0dXJuIlNVUkZBQ0VfVFlQRV9MSU5FQVJfRVhUUlVTSU9OIjtjYXNlIGw6cmV0dXJuIlNVUkZBQ0VfVFlQRV9SRVZPTFVUSU9OIjtjYXNlIGg6cmV0dXJuIlNVUkZBQ0VfVFlQRV9OVVJCU19TVVJGQUNFIjtjYXNlIHU6cmV0dXJuIlNVUkZBQ0VfVFlQRV9PRkZTRVRfU1VSRkFDRSI7Y2FzZSBjOnJldHVybiJTVVJGQUNFX1RZUEVfVFJJTU1FRF9SRUNUX1NVUkZBQ0UiO2Nhc2UgZjpyZXR1cm4iU1VSRkFDRV9UWVBFX1BPTFlfUExBTkUiO2Nhc2UgZDpyZXR1cm4iU1VSRkFDRV9UWVBFX0ZBTiI7Y2FzZSB3OnJldHVybiJTVVJGQUNFX1RZUEVfUkVWT0xVVElPTl9GTElQUEVEX0RPTUFJTiJ9fSx5PW5ldyB0LG09bmV3IHQsZz1uZXcgdCxBPXt9O2Z1bmN0aW9uIFModCxlKXtmb3IobGV0IHM9MDtzPDM7cysrKWlmKHRbc10hPT1lW3NdKXJldHVybiB0W3NdLWVbc107cmV0dXJuIDB9Y29uc3QgRj10PT5NYXRoLnBvdygyLE1hdGgucm91bmQoTWF0aC5sb2codCkvTWF0aC5sb2coMikpKTtmdW5jdGlvbiBiKHQsZT0xLHM9MSl7Y29uc3Qgbz1NYXRoLnNxcnQodCplKnMpO2xldCByLGE7aWYoZT49cyl7cj1vL2U7Y29uc3Qgcz1yLU1hdGguZmxvb3Iocik7cz4uNSYmczwxP3IrPTEtczpyPU1hdGgubWF4KDEsTWF0aC5mbG9vcihyKSksYT10L3I7Y29uc3Qgbj1hLU1hdGguZmxvb3IoYSk7bj4wJiZuPDEmJihhKz0xLW4pfWVsc2V7YT1vL3M7Y29uc3QgZT1hLU1hdGguZmxvb3IoYSk7ZT4uNSYmZTwxP2ErPTEtZTphPU1hdGgubWF4KDEsTWF0aC5mbG9vcihhKSkscj10L2E7Y29uc3Qgbj1yLU1hdGguZmxvb3Iocik7bj4wJiZuPDEmJihyKz0xLW4pfWlmKHIqYTx0KXRocm93IG5ldyBFcnJvcigiSW52YWxpZCBjb250YWluZXIgc2l6ZSIpO3JldHVybltyLGFdfWZ1bmN0aW9uIFUodCxlLHMsbyxyKXtjb25zdCBhPWUrIngiK3Msbj1yW2FdO251bGwhPW4/b1tuXS5pZHMucHVzaCh0KTooclthXT1vLmxlbmd0aCxvLnB1c2goe2l0ZW1XaWR0aDplLGl0ZW1IZWlnaHQ6cyxpZHM6W3RdfSkpfWZ1bmN0aW9uIEQodCxlLHMsbyl7Y29uc3Qgcj1mdW5jdGlvbih0KXtjb25zdCBlPW5ldyBVaW50MTZBcnJheSh0Lmxlbmd0aCk7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspe2Vbc109cztjb25zdCBvPXRbc10scj1iKG8uaWRzLmxlbmd0aCxvLml0ZW1XaWR0aCxvLml0ZW1IZWlnaHQpO28uaXRlbUNvdW50VVY9cixvLnc9clswXSpvLml0ZW1XaWR0aCxvLmg9clsxXSpvLml0ZW1IZWlnaHQsby5sPU1hdGgubWF4KG8udyxvLmgpfXJldHVybiBlLnNvcnQoKGUscyk9PnRbZV0ubD50W3NdLmw/LTE6dFtlXS5sPHRbc10ubD8xOjApLGV9KHQpO2Zvcihjb25zdCBhIG9mIHIpe2NvbnN0IHI9dFthXSxuPWUuYWRkQmxvY2soe3c6ci53LGg6ci5ofSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKCJVbmFibGUgdG8gbGF5b3V0IGJpbjoiK3IudysiIHggIityLmgpO28mJm8ocixuKTtmb3IobGV0IHQ9MDt0PHIuaWRzLmxlbmd0aDt0Kyspe3Mocix0LG4ueCt0JXIuaXRlbUNvdW50VVZbMF0qci5pdGVtV2lkdGgsbi55K01hdGguZmxvb3IodC9yLml0ZW1Db3VudFVWWzBdKSpyLml0ZW1IZWlnaHQpfX19Y29uc3QgcD0odCxlLHMsbyxyKT0+e2NvbnN0IGE9dC5sb2FkVUludDMyKCk7bGV0IG49NDtTKFtlLm1ham9yLGUubWlub3IsZS5wYXRjaF0sWzAsMCwwXSk+MCYmKG49OCk7Y29uc3QgaT1iKGEsMSwxKSxsPW5ldyBGbG9hdDMyQXJyYXkoaVswXSppWzFdKjQpLGg9ZT0+e2NvbnN0IG89dC5sb2FkRmxvYXQzMigpLHI9dC5sb2FkRmxvYXQzMigpLGE9dC5sb2FkRmxvYXQzMigpLG49dC5sb2FkRmxvYXQzMigpLGk9dC5sb2FkRmxvYXQzMigpLGw9dC5sb2FkRmxvYXQzMigpLGg9dC5sb2FkRmxvYXQzMigpLHU9dC5sb2FkRmxvYXQzMigpLGM9c1s4Km8rMl0tMTtyZXR1cm57Y3VydmVJZDpvLGN1cnZlSW5kZXhXaXRoaW5Mb29wOmUsYWRkcjpbc1s4Km8rMF0sc1s4Km8rMV1dLGRldGFpbDpjLHRyOltyLGFdLHJvdzA6W24saV0scm93MTpbbCxoXSxmbGFnczp1fX0sdT1bXSxjPXt9O2ZvcihsZXQgZT0wO2U8YTtlKyspdHJ5e3Quc2VlayhuKzQqZSksdC5zZWVrKHQubG9hZFVJbnQzMigpKTtjb25zdCBzPXQubG9hZEZsb2F0MzIoKSxvPXQubG9hZEZsb2F0MzIoKTtpZihpc05hTihzKXx8aXNOYU4obykpe2NvbnNvbGUud2FybigiVW5hYmxlIHRvIGxheW91dCBpdGVtOiIrcysiIHggIitvKTtjb250aW51ZX1jb25zdCBhPU1hdGgubWF4KDEsRihNYXRoLmNlaWwocy9yKSktMSksaT1NYXRoLm1heCgxLEYoTWF0aC5jZWlsKG8vcikpLTEpO2lmKGlzTmFOKGEpfHxpc05hTihpKSl7Y29uc29sZS53YXJuKCJVbmFibGUgdG8gbGF5b3V0IGl0ZW06IithKyIgeCAiK2kpO2NvbnRpbnVlfVUoZSxhKzIsaSsyLHUsYyl9Y2F0Y2godCl7Y29uc29sZS53YXJuKCJFcnJvciB3aGlsZSByZWFkaW5nIFRyaW1TZXQgZGF0YSBpbiB3ZWIgd29ya2VyOiAiLGUsdCl9Y29uc3QgZj17fTtEKHUsZywoZSxzLG8scik9Pntjb25zdCBhPWUuaWRzW3NdLGk9KGU9Pnt0LnNlZWsobis0KmUpLHQuc2Vlayh0LmxvYWRVSW50MzIoKSs4KTtjb25zdCBzPXQubG9hZFVJbnQzMigpLG89dC5sb2FkVUludDMyKCkscj1bXTtmb3IobGV0IHQ9MDt0PG87dCsrKXIucHVzaChoKHQpKTtmb3IobGV0IGU9MDtlPHM7ZSsrKXtjb25zdCBlPXQubG9hZFVJbnQzMigpO2ZvcihsZXQgdD0wO3Q8ZTt0Kyspe2NvbnN0IGU9aCh0KTtyLnB1c2goZSl9fXJldHVybiByfSkoYSksdT00KmE7bFt1KzBdPW8rMSxsW3UrMV09cisxLGxbdSsyXT1lLml0ZW1XaWR0aC0yLGxbdSszXT1lLml0ZW1IZWlnaHQtMjtmb3IoY29uc3QgdCBvZiBpKXtsZXQgcz1mW3QuZGV0YWlsXTtzfHwocz1bXSxmW3QuZGV0YWlsXT1zKSxzLnB1c2gobysxKSxzLnB1c2gocisxKSxzLnB1c2goZS5pdGVtV2lkdGgtMikscy5wdXNoKGUuaXRlbUhlaWdodC0yKSxzLnB1c2godC50clswXSkscy5wdXNoKHQudHJbMV0pLHMucHVzaCh0LnJvdzBbMF0pLHMucHVzaCh0LnJvdzBbMV0pLHMucHVzaCh0LnJvdzFbMF0pLHMucHVzaCh0LnJvdzFbMV0pLHMucHVzaCh0LmFkZHJbMF0pLHMucHVzaCh0LmFkZHJbMV0pLHMucHVzaCh0LmZsYWdzKSxzLnB1c2godC5jdXJ2ZUluZGV4V2l0aGluTG9vcCl9fSk7Y29uc3QgZD17fTtmb3IoY29uc3QgdCBpbiBmKWRbdF09RmxvYXQzMkFycmF5LmZyb20oZlt0XSk7cmV0dXJuIEEudHJpbVNldHNBdGxhc0xheW91dERhdGE9bCx7dHJpbUN1cnZlRHJhd1NldHM6ZCx0cmltU2V0c0F0bGFzTGF5b3V0RGF0YTpsLHRyaW1TZXRzQXRsYXNMYXlvdXRUZXh0dXJlU2l6ZTppfX07bGV0IHYsSTtjb25zdCB4PSh0LHMpPT57Y29uc3Qgbz17fSxyPXtldmVudFR5cGU6ImxvYWRBc3NldERvbmUiLHByb2ZpbGluZzpvfSxhPVtdO2xldCBuLGM9cGVyZm9ybWFuY2Uubm93KCk7e2NvbnN0IHM9KCh0LGUscyk9Pntjb25zdCBvPXQubG9hZFVJbnQzMigpO2lmKDA9PW8pcmV0dXJuO2NvbnNvbGUubG9nKCJudW1DdXJ2ZXMgOiIsbyk7TWF0aC5zcXJ0KHQuZGF0YS5ieXRlTGVuZ3RoLzgpO2NvbnN0IHI9bmV3IFVpbnQzMkFycmF5KG8pLGE9W10sbj17fTtmb3IobGV0IHM9MDtzPG87cysrKXRyeXt0LnNlZWsoOCsxNipzKzQpO2xldCBvPXQubG9hZEZsb2F0MTYoKSxpPXQubG9hZEZsb2F0MTYoKTtjb25zdCBsPXQubG9hZEZsb2F0MTYoKTtsZXQgaDtpZihOdW1iZXIuaXNGaW5pdGUobyl8fChvPTY1NTM2KSxOdW1iZXIuaXNGaW5pdGUoaSl8fChpPTY1NTM2KSw4JmwpaD1vO2Vsc2UgaWYoMD09byloPTE7ZWxzZXtjb25zdCB0PTEvKG8vaSk7aWYodDxlKWg9NjtlbHNle2NvbnN0IHM9dC1lO2lmKGg9by8oMipNYXRoLmFjb3Mocy90KSksaD1NYXRoLm1heCgxLE1hdGgucm91bmQoRihoKSkpLGg+MTAyNSYmKGNvbnNvbGUud2FybigiQ3VydmUgZGV0YWlsOiIraCksaD1NYXRoLm1pbihoLDEwMjUpKSxpc05hTihoKSl7Y29uc29sZS53YXJuKCJVbmFibGUgdG8gbGF5b3V0IEN1cnZlOiIraCk7Y29udGludWV9fX1VKHMsaCsxLDEsYSxuKSxyW3NdPWh9Y2F0Y2godCl7Y29uc29sZS53YXJuKCJFcnJvciB3aGlsZSByZWFkaW5nIENBREN1cnZlIGRhdGEgaW4gd2ViIHdvcmtlcjogIixzLHQpfWNvbnN0IGk9YigyKm8pLGw9bmV3IEZsb2F0MzJBcnJheShpWzBdKmlbMV0qNCk7cmV0dXJuIEQoYSx5LChlLHMsbyxyKT0+e2NvbnN0IGE9ZS5pZHNbc10sbj04KmE7bFtuKzBdPW8sbFtuKzFdPXIsbFtuKzJdPWUuaXRlbVdpZHRoLGxbbiszXT1lLml0ZW1IZWlnaHQsdC5zZWVrKDgrMTYqYSk7Y29uc3QgaT10LmxvYWRVRmxvYXQxNigpLGg9dC5sb2FkVUZsb2F0MTYoKTtsW24rNF09aSxsW24rNV09aH0pLEEuY3VydmVEZXRhaWxzPXIse251bUN1cnZlczpvLGN1cnZlc0F0bGFzTGF5b3V0OmwsY3VydmVzQXRsYXNMYXlvdXRUZXh0dXJlU2l6ZTppfX0pKG5ldyBlKHQuY3VydmVzRGF0YUJ1ZmZlciksdC5lcnJvclRvbGVyYW5jZSx0Lm1heFRleFNpemUpO2lmKHMpe3IubnVtQ3VydmVzPXMubnVtQ3VydmVzLHIuY3VydmVzQXRsYXNMYXlvdXQ9cy5jdXJ2ZXNBdGxhc0xheW91dCxyLmN1cnZlc0F0bGFzTGF5b3V0VGV4dHVyZVNpemU9cy5jdXJ2ZXNBdGxhc0xheW91dFRleHR1cmVTaXplLHIuY3VydmVzQXRsYXNUZXh0dXJlRGltPVt5LnJvb3Qudyx5LnJvb3QuaF0sYS5wdXNoKHIuY3VydmVzQXRsYXNMYXlvdXQuYnVmZmVyKTtmb3IoY29uc3QgdCBpbiByLmN1cnZlRHJhd1NldHMpYS5wdXNoKHIuY3VydmVEcmF3U2V0c1t0XS5idWZmZXIpO249cGVyZm9ybWFuY2Uubm93KCksby5udW1DdXJ2ZXM9cy5udW1DdXJ2ZXMsby5sYXlvdXRDdXJ2ZXM9bi1jLG8uY3VydmVzQXRsYXNUZXh0dXJlRGltPXIuY3VydmVzQXRsYXNUZXh0dXJlRGltfX17Y29uc3Qgcz0oKHQsZSxzLG8scik9Pntjb25zdCBhPU1hdGguc3FydCh0LmRhdGEuYnl0ZUxlbmd0aC84KSxuPXQubG9hZFVJbnQzMigpO2lmKGNvbnNvbGUubG9nKCJudW1TdXJmYWNlcyA6IixuKSwwPT1uKXJldHVybjt0LmxvYWRGbG9hdDMyKCksdC5sb2FkRmxvYXQzMigpO2NvbnN0IGM9bmV3IEludDMyQXJyYXkoNypuKSxmPWU9Pntjb25zdCBzPTgqZS54KzgqZS55KmE7dC5zZWVrKHMpfSx5PVtdLGc9e30scD17fTtsZXQgdj0wO2NvbnN0IEk9Uyhbci5tYWpvcixyLm1pbm9yLHIucGF0Y2hdLFswLDAsMjddKT49MDtmb3IobGV0IHM9MDtzPG47cysrKXRyeXt0LnNlZWsoOCsxOCpzKTtjb25zdCByPXQubG9hZFVGbG9hdDE2KCksYT10LmxvYWRVRmxvYXQxNigpO2xldCBuPXQubG9hZEZsb2F0MTYoKSxtPXQubG9hZEZsb2F0MTYoKSxBPXQubG9hZEZsb2F0MTYoKSxTPXQubG9hZEZsb2F0MTYoKTtjb25zdCBiPXQubG9hZEZsb2F0MTYoKTtsZXQgRCx4LEUsVDtpZihOdW1iZXIuaXNGaW5pdGUoQSl8fChBPTY1NTM2KSxOdW1iZXIuaXNGaW5pdGUoUyl8fChTPTY1NTM2KSxJKUQ9dC5sb2FkU0ludDMyRnJvbTJ4RmxvYXQxNigpO2Vsc2V7Y29uc3QgZT10LmxvYWRGbG9hdDE2KCk7RD1lKyh0LmxvYWRGbG9hdDE2KCk8PDgpfWYoe3g6cix5OmF9KTt0cnl7eD10LmxvYWRGbG9hdDE2KCl9Y2F0Y2godCl7Y29uc29sZS53YXJuKCJFcnJvciB3aGlsZSByZWFkaW5nIFN1cmZhY2UgZGF0YSBpbiB3ZWIgd29ya2VyOiAiLHMsdCk7Y29udGludWV9bGV0IEM9MDtpZih4PT1kKUU9bixUPW07ZWxzZXtjb25zdCB0PUEqUztpZih0PG8pe2NvbnNvbGUubG9nKCJTa2lwcGluZyA6IixfKHgpLCIgc2l6ZToiLEEsIngiLFMsIiBhcmVhOiIsdCk7Y29udGludWV9aWYoTnVtYmVyLmlzRmluaXRlKG4pfHwobj02NTUzNiksTnVtYmVyLmlzRmluaXRlKG0pfHwobT02NTUzNiksNjQmYilFPW47ZWxzZSBpZigwPT1uKUU9MTtlbHNle2NvbnN0IHQ9MS8obi9BKTtpZih0PGUpRT02O2Vsc2V7Y29uc3Qgcz10LWU7RT1uLygyKk1hdGguYWNvcyhzL3QpKSxFPU1hdGgubWF4KDEsTWF0aC5yb3VuZChGKEUpKSksRT4xMDI1JiYoY29uc29sZS53YXJuKCJHZW9tIGRldGFpbFU6IitFKSxFPTEwMjUpfX1pZigxMjgmYilUPW07ZWxzZSBpZigwPT1tKVQ9MTtlbHNle2NvbnN0IHQ9MS8obS9TKTtpZih0PGUpVD02O2Vsc2V7Y29uc3Qgcz10LWU7VD1tLygyKk1hdGguYWNvcyhzL3QpKSxUPU1hdGgubWF4KDEsTWF0aC5yb3VuZChGKFQpKSksVD4xMDI1JiYoY29uc29sZS53YXJuKCJHZW9tIGRldGFpbFY6IitUKSxUPTEwMjUpfX1pZihFPFQpe2NvbnN0IHQ9RTtFPVQsVD10LEM9MzJ9fWlmKGlzTmFOKEUpfHxpc05hTihUKXx8IU51bWJlci5pc0Zpbml0ZShFKXx8IU51bWJlci5pc0Zpbml0ZShUKSl7Y29uc29sZS53YXJuKCJVbmFibGUgdG8gbGF5b3V0IGl0ZW0gIixfKHgpLCIgOiIrRSsiIHggIitUKTtjb250aW51ZX1FKyssVCsrO2xldCBOPTA7eD09aXx8eD09bHx8eD09dXx8eD09dz9OPTE6eD09aCYmKE49MikscFtOXT9wW05dKys6cFtOXT0xLFUocyxFLFQseSxnKTtjb25zdCBNPTcqcztjW00rMF09Q3xiLGNbTSsxXT1yLGNbTSsyXT1hLGNbTSszXT1OLGNbTSs0XT1FLGNbTSs1XT1ULGNbTSs2XT1ELHYrPUUqVH1jYXRjaCh0KXtjb25zb2xlLndhcm4oIkVycm9yIHdoaWxlIHJlYWRpbmcgU3VyZmFjZSBkYXRhIGluIHdlYiB3b3JrZXI6ICIscyx0KX1jb25zdCB4PWIobiwyLDEpLEU9WzIqeFswXSx4WzFdXSxUPW5ldyBGbG9hdDMyQXJyYXkoMip4WzBdKnhbMV0qNCksQz1bXTtmb3IoY29uc3QgdCBpbiBwKXtjb25zdCBlPXBbdF07Q1twYXJzZUludCh0KV09bmV3IEZsb2F0MzJBcnJheShlKSxwW3RdPW51bGx9cmV0dXJuIEQoeSxtLCh0LGUscyxvKT0+e2NvbnN0IHI9dC5pZHNbZV0sYT03KnIsbj1jW2ErMF0saT1jW2ErMV0sbD1jW2ErMl0saD1jW2ErM10sdT04KnI7VFt1KzBdPXMsVFt1KzFdPW8sVFt1KzJdPXQuaXRlbVdpZHRoLFRbdSszXT10Lml0ZW1IZWlnaHQsVFt1KzRdPWksVFt1KzVdPWwsVFt1KzZdPW4sbnVsbD09PXBbaF0/cFtoXT0wOnBbaF0rKyxDW2hdW3BbaF1dPXJ9KSxBLnN1cmZhY2VEZXRhaWxzPWMsQS5zdXJmYWNlc0F0bGFzTGF5b3V0PVQse251bVN1cmZhY2VzOm4sc3VyZmFjZXNBdGxhc0xheW91dDpULHN1cmZhY2VzRXZhbEF0dHJzOkMsc3VyZmFjZXNBdGxhc0xheW91dFRleHR1cmVTaXplOkV9fSkobmV3IGUodC5zdXJmYWNlc0RhdGFCdWZmZXIpLHQuZXJyb3JUb2xlcmFuY2UsdC5tYXhUZXhTaXplLHQuc3VyZmFjZUFyZWFUaHJlc2hvbGQsdC5jYWREYXRhVmVyc2lvbik7aWYocyl7ci5zdXJmYWNlc0V2YWxBdHRycz1zLnN1cmZhY2VzRXZhbEF0dHJzLHIuc3VyZmFjZXNBdGxhc0xheW91dD1zLnN1cmZhY2VzQXRsYXNMYXlvdXQsci5zdXJmYWNlc0F0bGFzTGF5b3V0VGV4dHVyZVNpemU9cy5zdXJmYWNlc0F0bGFzTGF5b3V0VGV4dHVyZVNpemUsci5zdXJmYWNlc0F0bGFzVGV4dHVyZURpbT1bbS5yb290LncsbS5yb290LmhdLGEucHVzaChyLnN1cmZhY2VzQXRsYXNMYXlvdXQuYnVmZmVyKTtmb3IoY29uc3QgdCBpbiByLnN1cmZhY2VzRXZhbEF0dHJzKWEucHVzaChyLnN1cmZhY2VzRXZhbEF0dHJzW3RdLmJ1ZmZlcik7bj1wZXJmb3JtYW5jZS5ub3coKSxvLmxheW91dFN1cmZhY2VzPW4tYyxvLm51bVN1cmZhY2VzPXMubnVtU3VyZmFjZXMsby5zdXJmYWNlc0F0bGFzVGV4dHVyZURpbT1yLnN1cmZhY2VzQXRsYXNUZXh0dXJlRGltfX1pZih0LnRyaW1TZXRzQnVmZmVyKXtjb25zdCBzPW5ldyBlKHQudHJpbVNldHNCdWZmZXIpLGk9cChzLHQuY2FkRGF0YVZlcnNpb24sci5jdXJ2ZXNBdGxhc0xheW91dCx0LmxvZCx0LnRyaW1UZXhlbFNpemUpO3IudHJpbUN1cnZlRHJhd1NldHM9aS50cmltQ3VydmVEcmF3U2V0cyxyLnRyaW1TZXRzQXRsYXNMYXlvdXREYXRhPWkudHJpbVNldHNBdGxhc0xheW91dERhdGEsci50cmltU2V0c0F0bGFzTGF5b3V0VGV4dHVyZVNpemU9aS50cmltU2V0c0F0bGFzTGF5b3V0VGV4dHVyZVNpemUsci50cmltU2V0QXRsYXNUZXh0dXJlU2l6ZT1bZy5yb290LncsZy5yb290LmhdLGEucHVzaChyLnRyaW1TZXRzQXRsYXNMYXlvdXREYXRhLmJ1ZmZlcik7Zm9yKGNvbnN0IHQgaW4gci50cmltQ3VydmVEcmF3U2V0cylhLnB1c2goci50cmltQ3VydmVEcmF3U2V0c1t0XS5idWZmZXIpO2M9cGVyZm9ybWFuY2Uubm93KCksby5sYXlvdXRUcmltU2V0cz1jLW4sby50cmltU2V0QXRsYXNUZXh0dXJlU2l6ZT1yLnRyaW1TZXRBdGxhc1RleHR1cmVTaXplfXtjb25zdCBzPW5ldyBlKHQuYm9keUxpYnJhcnlCdWZmZXIpLGk9bmV3IGUodC5ib2R5TGlicmFyeUJ1ZmZlclRvYyk7by5udW1Cb2RpZXM9dC5zY2VuZUJvZHlJdGVtc0RhdGEubGVuZ3RoLzI7Y29uc3QgbD0oKHQsZSxzLG8scik9Pntjb25zdCBhPXQubGVuZ3RoLzI7ST1uZXcgVWludDMyQXJyYXkoYSk7Y29uc3Qgbj1NYXRoLnNxcnQocy5ieXRlTGVuZ3RoLzE2KTtsZXQgaTtpPVMoW28ubWFqb3Isby5taW5vcixvLnBhdGNoXSxbMCwwLDI5XSk+PTA/MTU6MTE7Y29uc3QgbD1TKFtvLm1ham9yLG8ubWlub3Isby5wYXRjaF0sWzEsMCw1XSk+PTA7dj10PT57ZS5zZWVrKDQrMTIqdCk7Y29uc3Qgbz1lLmxvYWRVSW50MzIoKSxyPWUubG9hZFVJbnQzMigpLGE9MTYqbysxNipyKm47cy5zZWVrKGErMjQpO2NvbnN0IGg9cy5sb2FkRmxvYXQzMigpLHU9bD9zLmxvYWRGbG9hdDMyKCk6MCxjPVtdO2ZvcihsZXQgdD0wO3Q8aDt0Kyspe2NvbnN0IHQ9cy5sb2FkRmxvYXQzMigpO2MucHVzaCh0KSxzLmFkdmFuY2UoNCooaS0xKSl9Y29uc3QgZj1bXSxkPXMucG9zKCk7Zm9yKGxldCB0PTA7dDx1O3QrKyl7cy5zZWVrKGQrdCppKjQpO2NvbnN0IGU9cy5sb2FkRmxvYXQzMigpO2YucHVzaChlKX1yZXR1cm57eDpvLHk6cixzdXJmYWNlSWRzOmMsY3VydmVJZHM6Zn19O2NvbnN0IGg9e30sdT17fTtsZXQgYz0wLGY9MDtmb3IobGV0IGU9MDtlPGE7ZSsrKXRyeXtjb25zdCBzPTIqZSxvPXRbcyswXTtpZigtMT09byljb250aW51ZTtjb25zdCByPXRbcysxXSxhPXYobyk7Yys9YS5zdXJmYWNlSWRzLmxlbmd0aCxmKz1hLmN1cnZlSWRzLmxlbmd0aCxJW2VdPW87Y29uc3Qgbj1hLnN1cmZhY2VJZHM7Zm9yKGxldCB0PTA7dDxuLmxlbmd0aDt0Kyspe2NvbnN0IHM9blt0XSxvPTcqcyxhPUEuc3VyZmFjZURldGFpbHNbbys0XSxpPUEuc3VyZmFjZURldGFpbHNbbys1XTtpZigwPT1hfHwwPT1pKWNvbnRpbnVlO2NvbnN0IGw9YSsieCIraTtsZXQgdT1oW2xdO3V8fCh1PXt9LGhbbF09dSk7bGV0IGM9dVtyXTtjfHwoYz1bXSx1W3JdPWMpO2NvbnN0IGY9QS5zdXJmYWNlRGV0YWlsc1tvKzZdLGQ9dDtjLnB1c2goZSksYy5wdXNoKGQpLGMucHVzaChzKSxjLnB1c2goZil9Y29uc3QgaT1hLmN1cnZlSWRzO2ZvcihsZXQgdD0wO3Q8aS5sZW5ndGg7dCsrKXtjb25zdCBzPWlbdF0sbz1BLmN1cnZlRGV0YWlsc1tzXTtpZigwPT1vKWNvbnRpbnVlO2xldCByPXVbb107cnx8KHI9e30sdVtvXT1yKTtsZXQgYT1yWzBdO2F8fChhPVtdLHJbMF09YSk7Y29uc3QgbD1uLmxlbmd0aCt0O2EucHVzaChlKSxhLnB1c2gobCksYS5wdXNoKHMpLGEucHVzaCgtMSl9fWNhdGNoKHQpe2NvbnNvbGUud2FybigiRXJyb3Igd2hpbGUgcmVhZGluZyBDQURCb2R5RGVzYyBkYXRhIGluIHdlYiB3b3JrZXI6ICIsZSx0KX1BLm51bVN1cmZhY2VJbnN0YW5jZXM9YyxBLm51bUN1cnZlSW5zdGFuY2VzPWY7Y29uc3QgZD17fTtmb3IoY29uc3QgdCBpbiBoKXtkW3RdfHwoZFt0XT17fSk7Y29uc3QgZT1oW3RdO2Zvcihjb25zdCBzIGluIGUpe2NvbnN0IG89ZVtzXTtkW3RdW3NdPUZsb2F0MzJBcnJheS5mcm9tKG8pfX1jb25zdCB3PXt9O2Zvcihjb25zdCB0IGluIHUpe3dbdF18fCh3W3RdPXt9KTtjb25zdCBlPXVbdF07Zm9yKGNvbnN0IHMgaW4gZSl7Y29uc3Qgbz1lW3NdO3dbdF1bc109RmxvYXQzMkFycmF5LmZyb20obyl9fXJldHVybiBBLnN1cmZhY2VEcmF3U2V0c190bXA9aCxBLmN1cnZlRHJhd1NldHNfdG1wPXUsQS5zdXJmYWNlRHJhd1NldHM9ZCxBLmN1cnZlRHJhd1NldHM9dyx7c3VyZmFjZURyYXdTZXRzOmQsY3VydmVEcmF3U2V0czp3fX0pKHQuc2NlbmVCb2R5SXRlbXNEYXRhLGkscyx0LmNhZERhdGFWZXJzaW9uKTtyLnN1cmZhY2VEcmF3U2V0cz1sLnN1cmZhY2VEcmF3U2V0cyxyLmN1cnZlRHJhd1NldHM9bC5jdXJ2ZURyYXdTZXRzO2Zvcihjb25zdCB0IGluIHIuc3VyZmFjZURyYXdTZXRzKXtjb25zdCBlPXIuc3VyZmFjZURyYXdTZXRzW3RdO2Zvcihjb25zdCB0IGluIGUpYS5wdXNoKGVbdF0uYnVmZmVyKX1mb3IoY29uc3QgdCBpbiByLmN1cnZlRHJhd1NldHMpe2NvbnN0IGU9ci5jdXJ2ZURyYXdTZXRzW3RdO2Zvcihjb25zdCB0IGluIGUpYS5wdXNoKGVbdF0uYnVmZmVyKX1vLm51bVN1cmZhY2VJbnN0YW5jZXM9QS5udW1TdXJmYWNlSW5zdGFuY2VzLG8ubnVtQ3VydmVJbnN0YW5jZXM9QS5udW1DdXJ2ZUluc3RhbmNlcyxuPXBlcmZvcm1hbmNlLm5vdygpLG8ubGF5b3V0Qm9keUl0ZW1zPW4tYyxvLmJvZHlBdGxhc0RpbT1yLmJvZHlBdGxhc0RpbX1zKHIsYSksdC5oaWdobGlnaHRlZEJvZGllcy5sZW5ndGg+MCYmVCh7aGlnaGxpZ2h0ZWRCb2R5SWRzOnQuaGlnaGxpZ2h0ZWRCb2RpZXMsdW5oaWdobGlnaHRlZEJvZHlJZHM6W119LHMpfSxFPXt9LFQ9KHQsZSk9Pntjb25zdCBzPXQuaGlnaGxpZ2h0ZWRCb2R5SWRzLG89dC51bmhpZ2hsaWdodGVkQm9keUlkcyxyPSh0LGUpPT57Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspe2NvbnN0IG89dFtzXSxyPUlbb10sYT12KHIpLnN1cmZhY2VJZHM7Zm9yKGxldCB0PTA7dDxhLmxlbmd0aDt0Kyspe2UobyxvPDwxNnx0LGFbdF0sdCl9fX07cihvLCh0LGUscyxvKT0+e2NvbnN0IHI9NypzLGE9QS5zdXJmYWNlRGV0YWlsc1tyKzRdKyJ4IitBLnN1cmZhY2VEZXRhaWxzW3IrNV07bGV0IG49RVthXTtufHwobj17c3VyZmFjZURyYXdDb29yZHM6e30sY291bnQ6MH0sRVthXT1uKSxkZWxldGUgbi5zdXJmYWNlRHJhd0Nvb3Jkc1tlXSxuLmNvdW50LS19KSxyKHMsKHQsZSxzLG8pPT57Y29uc3Qgcj03KnMsYT1BLnN1cmZhY2VEZXRhaWxzW3IrNF0rIngiK0Euc3VyZmFjZURldGFpbHNbcis1XTtsZXQgbj1FW2FdO258fChuPXtzdXJmYWNlRHJhd0Nvb3Jkczp7fSxjb3VudDowfSxFW2FdPW4pO2NvbnN0IGk9QS5zdXJmYWNlRGV0YWlsc1tyKzZdO24uc3VyZmFjZURyYXdDb29yZHNbZV09W3QsbyxzLGldLG4uY291bnQrK30pO2NvbnN0IGE9e30sbj1bXTtmb3IoY29uc3QgdCBpbiBFKXtjb25zdCBlPUVbdF0scz1uZXcgRmxvYXQzMkFycmF5KDQqZS5jb3VudCk7bGV0IG89MDtmb3IoY29uc3QgZSBpbiBFW3RdLnN1cmZhY2VEcmF3Q29vcmRzKXtjb25zdCByPUVbdF0uc3VyZmFjZURyYXdDb29yZHNbZV07cy5zZXQocixvKSxvKz00fWFbdF09cyxuLnB1c2gocy5idWZmZXIpfWUoe2V2ZW50VHlwZToiaGlnaGxpZ2h0ZWRTdXJmYWNlRHJhd1NldHNDaGFuZ2VkIixoaWdobGlnaHRlZFN1cmZhY2VEcmF3U2V0czphLG51bUhpZ2hsaWdodGVkOnMubGVuZ3RoLG51bVVuaGlnaGxpZ2h0ZWQ6by5sZW5ndGh9LG4pfTtnbG9iYWxUaGlzLm9ubWVzc2FnZT1mdW5jdGlvbih0KXshZnVuY3Rpb24odCxlKXtzd2l0Y2godC5ldmVudFR5cGUpe2Nhc2UibG9hZEFzc2VtYmx5Ijp4KHQsZSk7YnJlYWs7Y2FzZSJib2R5SGlnaGxpZ2h0Q2hhbmdlZCI6VCh0LGUpfX0odC5kYXRhLCh0LGUpPT57Z2xvYmFsVGhpcy5wb3N0TWVzc2FnZSh0LGUpfSl9OwoK",null,!1);class J extends t.EventEmitter{constructor(e,r,a,n){super(),this.__gl=e,this.__assetId=r,this.__cadAsset=a,this.__numSurfaces=a.getSurfaceLibrary().getNumSurfaces(),this.__numBodies=a.getBodyLibrary().getNumBodies(),this.__numMaterials=a.getMaterialLibrary().getNumMaterials(),this.__numHighlightedGeoms=0,this.__ready=!1,this.__visible=this.__cadAsset.isVisible(),this.__assetVisibilityChanged=this.__assetVisibilityChanged.bind(this),this.__cadAsset.on("visibilityChanged",this.__assetVisibilityChanged);const s=()=>{this.displayEdges=this.__cadAsset.getParameter("DisplayEdges").getValue(),this.displayEdges?n.incDisplayEdges():n.decDisplayEdges()};s(),this.displayEdgesChangedId=this.__cadAsset.getParameter("DisplayEdges").on("valueChanged",s);const i=()=>{this.edgeColor=this.__cadAsset.getParameter("EdgeColor").getValue().asArray(),this.emit("updated")};i(),this.edgesColorChangedId=this.__cadAsset.getParameter("EdgeColor").on("valueChanged",i),this.__cadpassdata=n,this.__curveLibrary=new B(e,n,this.__cadAsset.getSurfaceLibrary(),a.getVersion()),this.__surfaceLibrary=new P(e,n,this.__cadAsset.getSurfaceLibrary(),this.__curveLibrary,a.getVersion());const o=this.__cadAsset.getTrimSetLibrary().getBinaryBuffer();o&&o.byteLength>8&&(this.__trimSetLibrary=new k(e,n,this.__cadAsset.getTrimSetLibrary(),this.__curveLibrary));{const r=this.__cadAsset.getBodyLibrary().getBinaryBuffer();if(r){const a=Math.sqrt(r.byteLength/16);this.__bodyDescTexture=new t.GLTexture2D(e,{format:"RGBA",type:"FLOAT",width:a,height:a,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:new Float32Array(r)})}}this.__bindAttr=(t,r,a,n,s,i=!0)=>{e.enableVertexAttribArray(t),e.vertexAttribPointer(t,r,e.FLOAT,!1,n,s),i&&e.vertexAttribDivisor(t,1)},this.__trimCurveDrawSets={},this.__surfaceDrawSets={},this.__curveDrawSets={},this.loadWorker()}__assetVisibilityChanged(){this.__visible=this.__cadAsset.isVisible(),this.emit("updated")}getCADAsset(){return this.__cadAsset}getNumSurfaces(){return this.__numSurfaces}getNumBodies(){return this.__numBodies}getNumMaterials(){return this.__numMaterials}incHighlightedCount(e){this.__numHighlightedGeoms+=e,this.__cadpassdata.incHighlightedCount(e)}decHighlightedCount(e){this.__numHighlightedGeoms-=e,this.__cadpassdata.decHighlightedCount(e)}loadWorker(){const e=this.__cadAsset.getNumBodyItems();if(0==e)return;let r=t.MathFunctions.nextPow2(Math.round(Math.sqrt(7*e)+.5));r%7!=0&&(r+=7-r%7),this.cadBodiesTextureData=new Float32Array(r*r*4);const a=this.__cadAsset.getParameter("BoundingBox").getValue();this.__assetCentroid=new t.Vec3;const n=new Float32Array(2*e);let s=0;this.__cadBodies=[];const i=[],o={highlightedBodyIds:[],unhighlightedBodyIds:[],dirty:!1},d=()=>{this.__postMessageToWorker({eventType:"bodyHighlightChanged",highlightedBodyIds:o.highlightedBodyIds,unhighlightedBodyIds:o.unhighlightedBodyIds}),o.highlightedBodyIds=[],o.unhighlightedBodyIds=[],o.dirty=!1};this.__dirtyBodyIndices=[];const l=e=>{-1==this.__dirtyBodyIndices.indexOf(e)&&(this.__dirtyBodyIndices.push(e),this.emit("updated"))},u=t=>{const r=s;if(r>=e)return;const a=2*r*4,c=new Float32Array(n.buffer,a,2),u=7*r*4*4,_=new Float32Array(this.cadBodiesTextureData.buffer,u,28),h=new W(t,r);h.bind(this.__cadpassdata,c,_,l,i,o,d),this.__cadBodies.push(h),s++};this.__cadAsset.traverse(e=>!(e instanceof c)||(u(e),!1));const _=this.__gl;this.__cadBodiesTexture=new t.GLTexture2D(_,{format:"RGBA",type:"FLOAT",width:r,height:r,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1,data:this.cadBodiesTextureData});const h=this.__cadAsset.getUnitsConversion(),f=.5*a.size()/h,m=this.__cadAsset.lod,v=128*Math.pow(2,m),g=2*Math.PI/v,p=f-f*Math.cos(g/2);console.log("assetBBoxRadius:",f," errorTolerance:",p," surfaceAreaThreshold:",0);const y=this.__cadAsset.getSurfaceLibrary().getCurveBuffer(),S=this.__cadAsset.getSurfaceLibrary().getSurfaceBuffer(),x=this.__cadAsset.getVersion(),b=this.__cadAsset.getTrimSetLibrary().getBinaryBuffer();let L=-1;if(b){const e=this.__cadpassdata.assetCount;L=this.__cadAsset.getTrimSetLibrary().getTexelSize(m,e)}const C=this.__cadAsset.getBodyLibrary().getToc(),R=this.__cadAsset.getBodyLibrary().getBinaryBuffer(),T=[S,C,R];b&&T.push(b);const A={eventType:"loadAssembly",assetId:this.__assetId,curvesDataBuffer:y,surfacesDataBuffer:S,cadDataVersion:x,trimSetsBuffer:b,lod:this.__cadAsset.getLOD(),maxTexSize:this.__cadpassdata.maxTexSize/2,errorTolerance:p,surfaceAreaThreshold:0,trimTexelSize:L,sceneBodyItemsData:n,bodyLibraryBufferToc:C,bodyLibraryBuffer:R,highlightedBodies:i};this.__postMessageToWorker(A,T)}updateBodyTexture(e){const t=this.__gl,r=this.__gl.TEXTURE0+e.boundTextures+1;t.activeTexture(r),t.bindTexture(t.TEXTURE_2D,this.__cadBodiesTexture.glTex);const a=this.__cadBodiesTexture.width;for(let e=0;e<this.__dirtyBodyIndices.length;e++){const t=this.__dirtyBodyIndices[e],r=Math.floor(7*t/a),n=7*t%a;this.__cadBodies[t].updateCadBodyTex();const s=7,i=1,o=7*t*4*4,d=new Float32Array(this.cadBodiesTextureData.buffer,o,28);this.__cadBodiesTexture.populate(d,s,i,n,r,!1)}t.bindTexture(t.TEXTURE_2D,null),this.__dirtyBodyIndices=[]}__postMessageToWorker(e,t){this.__worker||(this.__worker=new Q),this.__worker.onmessage=e=>{this.__onWorkerMessage(e.data)},this.__worker.postMessage(e,this.__cadpassdata.debugMode?[]:t)}__onWorkerMessage(e){switch(e.eventType){case"loadAssetDone":console.log("Layout Asset:",this.getCADAsset().getName(),e.profiling),e.curvesAtlasLayout&&this.__curveLibrary.evaluateCurves(e.curvesAtlasLayout,e.numCurves,e.curvesAtlasLayoutTextureSize,e.curvesAtlasTextureDim);const t={};e.surfacesEvalAttrs&&(t.surfaceEvalTime=this.__surfaceLibrary.evaluateSurfaces(e.surfacesEvalAttrs,e.surfacesAtlasLayout,e.surfacesAtlasLayoutTextureSize,e.surfacesAtlasTextureDim)),e.trimCurveDrawSets&&e.trimSetAtlasTextureSize[0]>0&&e.trimSetAtlasTextureSize[1]>0&&this.__trimSetLibrary.evaluateTrimSets(e.trimCurveDrawSets,e.trimSetAtlasTextureSize,e.trimSetsAtlasLayoutData,e.trimSetsAtlasLayoutTextureSize),this.__bodyAtlasDim=e.bodyAtlasDim,this.updateDrawSets(t,e.surfaceDrawSets,e.curveDrawSets),this.__ready=!0,this.emit("loaded",{numSurfaces:e.profiling.numSurfaces,numSurfaceInstances:e.profiling.numSurfaceInstances,surfaceEvalTime:t.surfaceEvalTime,numBodies:e.profiling.numBodies,numMaterials:this.__numMaterials,numTriangles:t.numTriangles,numDrawSets:t.numDrawSets}),this.emit("updated");break;case"highlightedSurfaceDrawSetsChanged":for(const t in e.highlightedSurfaceDrawSets){const r=this.__surfaceDrawSets[t];r?r.setDrawItems(e.highlightedSurfaceDrawSets[t],1):console.warn("Selecting invalid items:",t)}this.incHighlightedCount(e.numHighlighted),this.decHighlightedCount(e.numUnhighlighted),this.emit("updated")}}updateDrawSets(e,t,r){if(e.numTriangles=0,e.numDrawSets=0,t)for(const r in t){let a=this.__surfaceDrawSets[r];if(!a){const e=r.split("x"),t=parseInt(e[0]),n=parseInt(e[1]);a=new C(this.__gl,t,n),this.__surfaceDrawSets[r]=a}const n=t[r];for(const t in n){const r=n[t];e.numTriangles+=a.addDrawItems(r,t)}e.numDrawSets++}if(r)for(const t in r){let a=this.__curveDrawSets[t];if(!a){const e=parseInt(t);a=new E(this.__gl,e),this.__curveDrawSets[t]=a}const n=r[t];for(const e in n){const t=n[e];a.addDrawItems(t,e)}e.numDrawSets++}}bindDrawItemsAtlas(e){this.__drawItemsTarget.bindColorTexture(e,e.unifs.drawItemsTexture),e.unifs.vert_drawItemsTextureSize&&this.__gl.uniform2i(e.unifs.vert_drawItemsTextureSize.location,this.__bodyAtlasDim[0],this.__bodyAtlasDim[1]),e.unifs.frag_drawItemsTextureSize&&this.__gl.uniform2i(e.unifs.frag_drawItemsTextureSize.location,this.__bodyAtlasDim[0],this.__bodyAtlasDim[1])}bind(e){const t=this.__gl,r=e.unifs;r.vert_drawItemsTextureSize&&this.__gl.uniform2i(r.vert_drawItemsTextureSize.location,this.__bodyAtlasDim[0],this.__bodyAtlasDim[1]),r.frag_drawItemsTextureSize&&this.__gl.uniform2i(r.frag_drawItemsTextureSize.location,this.__bodyAtlasDim[0],this.__bodyAtlasDim[1]),r.bodyDescTexture&&(this.__bodyDescTexture.bindToUniform(e,r.bodyDescTexture),t.uniform2i(r.bodyDescTextureSize.location,this.__bodyDescTexture.width,this.__bodyDescTexture.height),r.bodyDescTextureSize_frag&&t.uniform2i(r.bodyDescTextureSize_frag.location,this.__bodyDescTexture.width,this.__bodyDescTexture.height)),r.cadBodiesTexture&&(this.__cadBodiesTexture.bindToUniform(e,r.cadBodiesTexture),r.cadBodiesTextureSize_vert&&t.uniform1i(r.cadBodiesTextureSize_vert.location,this.__cadBodiesTexture.width),r.cadBodiesTextureSize_frag&&t.uniform1i(r.cadBodiesTextureSize_frag.location,this.__cadBodiesTexture.width)),r.assetCentroid&&t.uniform3fv(r.assetCentroid.location,this.__assetCentroid.asArray())}draw(e){if(!this.__visible||!this.__ready)return!1;const t=e.boundTextures;if(this.__dirtyBodyIndices.length>0&&this.updateBodyTexture(e),this.bind(e),this.__surfaceLibrary.bindSurfacesAtlas(e)){this.__trimSetLibrary&&(this.__trimSetLibrary.bindTrimSetAtlasLayout(e),this.__trimSetLibrary.bindTrimSetAtlas(e));for(const t in this.__surfaceDrawSets){this.__surfaceDrawSets[t].draw(e,e.shaderId)}e.boundTextures=t}else e.boundTextures=t}drawHighlightedGeoms(e){if(!this.__visible||0==this.__numHighlightedGeoms)return!1;const t=e.boundTextures;this.bind(e),this.__surfaceLibrary.bindSurfacesAtlas(e),this.__trimSetLibrary&&(this.__trimSetLibrary.bindTrimSetAtlasLayout(e),this.__trimSetLibrary.bindTrimSetAtlas(e));for(const t in this.__surfaceDrawSets){this.__surfaceDrawSets[t].draw(e,1)}e.boundTextures=t}drawNormals(e,t){if(!this.__visible||!this.__ready)return!1;const r=e.boundTextures;this.bind(e),this.__surfaceLibrary.bindSurfacesAtlas(e),this.__trimSetLibrary&&(this.__trimSetLibrary.bindTrimSetAtlasLayout(e),this.__trimSetLibrary.bindTrimSetAtlas(e));for(const r in this.__surfaceDrawSets){this.__surfaceDrawSets[r].drawNormals(e,t)}e.boundTextures=r}drawEdges(e,t){if(!this.__visible||!this.__ready||!this.displayEdges)return!1;const r=e.boundTextures;this.__dirtyBodyIndices.length>0&&this.updateBodyTexture(e),this.bind(e),this.__curveLibrary.bindCurvesAtlas(e);this.__gl.uniform4fv(e.unifs.edgeColor.location,this.edgeColor);for(const r in this.__curveDrawSets){this.__curveDrawSets[r].draw(e,t)}e.boundTextures=r}drawGeomData(e){if(!this.__visible||!this.__ready)return!1;const t=e.boundTextures;this.bind(e),this.__surfaceLibrary.bindSurfacesAtlas(e),this.__trimSetLibrary&&(this.__trimSetLibrary.bindTrimSetAtlasLayout(e),this.__trimSetLibrary.bindTrimSetAtlas(e));const r=this.__gl,a=e.unifs.assetIndex;a&&r.uniform1i(a.location,this.__assetId);for(const t in this.__surfaceDrawSets){this.__surfaceDrawSets[t].draw(e,e.shaderId)}e.boundTextures=t}getGeomItem(e){return this.__cadBodies[e].cadBody}getSurfaceData(e){return this.__cadAsset.getSurfaceLibrary().getSurfaceData(e)}drawSurfaceAtlas(e){this.__surfaceLibrary&&this.__surfaceLibrary.drawSurfaceAtlas(e)}drawTrimSets(e){this.__trimSetLibrary&&this.__trimSetLibrary.drawTrimSets(e)}destroy(){this.__cadAsset.off("visibilityChanged",this.__assetVisibilityChanged),this.__cadBodiesTexture.destroy(),this.__cadBodies.forEach(e=>e.destroy()),this.__cadBodies=[],this.__curveLibrary.destroy(),this.__surfaceLibrary.destroy(),this.__trimSetLibrary&&this.__trimSetLibrary.destroy();for(const e in this.__surfaceDrawSets){this.__surfaceDrawSets[e].destroy()}}}class j extends t.EventEmitter{constructor(e){super(),this.__gl=e,this.__materialDatas=[],this.__dirtyIndices=[],this.__numItems=0,this.__materialPacker=new t.GrowingPacker(256,256),this.__needsUpload=!1}addMaterial(e){if(e.getMetadata("glmaterialcoords"))return;this.__numItems++;const t=this.__materialPacker.addBlock({w:2,h:1}),r=this.__materialDatas.length;return this.__materialDatas.push({material:e,coords:t}),e.on("parameterValueChanged",()=>{this.__dirtyIndices.push(r),this.emit("updated")}),e.setMetadata("glmaterialcoords",t),this.__dirtyIndices.push(r),t}needsUpload(){return this.__dirtyIndices.length>0}uploadMaterials(){const e=this.__gl,r=this.__materialPacker.root.w,a=this.__materialPacker.root.h;if(this.__materialsTexture){if(this.__materialsTexture.width!=r||this.__materialsTexture.height!=a)throw new Error("Cannot resize here. Need a resize the preserves the data.")}else this.__materialsTexture=new t.GLTexture2D(e,{format:"RGBA",type:"FLOAT",width:r,height:a,filter:"NEAREST",wrap:"CLAMP_TO_EDGE",mipMapped:!1}),this.__materialsTexture.clear();e.bindTexture(e.TEXTURE_2D,this.__materialsTexture.glTex);const n=this.__materialsTexture.getTypeID(),s=this.__materialsTexture.getFormatID();this.__dirtyIndices.forEach(r=>{const a=this.__materialDatas[r],i=a.material;let o=t.Registry.getBlueprint(i.getShaderName());o&&o.getPackedMaterialData||(o=t.Registry.getBlueprint("GLDrawCADSurfaceShader"));const d=o.getPackedMaterialData(i),l=d.length/4,c=a.coords;if(n==e.FLOAT)e.texSubImage2D(e.TEXTURE_2D,0,c.x,c.y,l,1,s,n,d);else{const t=Math.convertFloat32ArrayToUInt16Array(d);e.texSubImage2D(e.TEXTURE_2D,0,c.x,c.y,l,1,s,n,t)}}),this.__dirtyIndices=[],e.bindTexture(e.TEXTURE_2D,null)}bind(e){if(!this.__materialsTexture)return!1;const t=this.__gl,r=e.unifs;return r.materialsTexture&&this.__materialsTexture.bindToUniform(e,r.materialsTexture),r.materialsTextureSize&&t.uniform2i(r.materialsTextureSize.location,this.__materialsTexture.width,this.__materialsTexture.height),!0}}t.shaderLibrary.setShaderModule("GLSLCADConstants.glsl","\n  const int SURFACE_FLAG_PERIODIC_U = 1; // 1<<0;\n  const int SURFACE_FLAG_PERIODIC_V = 2; // 1<<1;\n  const int SURFACE_FLAG_UNUSED2 = 4; // 1<<2;\n  const int SURFACE_FLAG_UNUSED3 = 8; // 1<<3;\n  const int SURFACE_FLAG_FLIPPED_NORMAL = 16; // 1<<4\n  const int SURFACE_FLAG_FLIPPED_UV = 32; // 1<<5\n  const int SURFACE_FLAG_COST_IS_DETAIL_U = 64; // 1<<6;\n  const int SURFACE_FLAG_COST_IS_DETAIL_V = 128; // 1<<7;\n\n  const int BODY_FLAG_CUTAWAY = 256; // 1<<8\n  const int BODY_FLAG_INVISIBLE = 512; // 1<<9\n\n  const int CURVE_FLAG_PERIODIC = 1; // 1<<0;\n  const int CURVE_FLAG_UNUSED2 = 4; // 1<<2;\n  const int CURVE_FLAG_COST_IS_DETAIL = 8;//1<<3;\n\n\n  const int SURFACE_TYPE_PLANE = 0;\n  const int SURFACE_TYPE_CONE = 1;\n  const int SURFACE_TYPE_CYLINDER = 2;\n  const int SURFACE_TYPE_SPHERE = 3;\n  const int SURFACE_TYPE_TORUS = 4;\n  const int SURFACE_TYPE_LINEAR_EXTRUSION = 5;\n  const int SURFACE_TYPE_REVOLUTION = 6;\n  const int SURFACE_TYPE_BEZIER_SURFACE = 7;\n  const int SURFACE_TYPE_NURBS_SURFACE = 8;\n  const int SURFACE_TYPE_OFFSET_SURFACE = 9;\n  const int SURFACE_TYPE_TRIMMED_RECT_SURFACE = 10;\n\n  const int SURFACE_TYPE_POLY_PLANE = 14;\n  const int SURFACE_TYPE_FAN = 15;\n  const int SURFACE_TYPE_REVOLUTION_FLIPPED_DOMAIN = 16;\n\n\n  const int CURVE_TYPE_LINE = 20;\n  const int CURVE_TYPE_CIRCLE = 21;\n  const int CURVE_TYPE_ELIPSE = 22;\n  // const int CURVE_TYPE_HYPERBOLA = 23;\n  // const int CURVE_TYPE_PARABOLA = 24;\n  // const int CURVE_TYPE_BEZIERCURVE = 25;\n  const int CURVE_TYPE_NURBS_CURVE = 26;\n  // const int CURVE_TYPE_OFFSET_CURVE = 27;\n  // const int CURVE_TYPE_TRIMMED_CURVE = 28;\n\n\n  const int geomLibraryHeaderSize = 4; // 2 pixels at the start of the GeomLibrary and CurveLibrary\n\n  // [bodyDescId, surfaceId, cadBodyDesc.xy], [glmaterialcoords.xy][tr-xyz], [ori], [sc], [highlight], [cutPlane]\n  const int pixelsPerCADBody = 7;\n"),t.shaderLibrary.setShaderModule("GLSLCADGeomDrawing.vertexShader.glsl",'\n\n\nuniform sampler2D cadBodiesTexture;\nuniform int cadBodiesTextureSize_vert;\n  \nvec4 getCADBodyPixel(int cadBodyId, int pixelOffset) {\n  int offset = cadBodyId * pixelsPerCADBody;\n  ivec2 start;\n  start.y += offset / cadBodiesTextureSize_vert;\n  start.x = imod(offset, cadBodiesTextureSize_vert);\n  return fetchTexel(cadBodiesTexture, ivec2(cadBodiesTextureSize_vert), ivec2(start.x + pixelOffset, start.y));\n}\n\n<%include file="GLSLMath.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n\n\nconst int pixelsPerDrawItem = 10; // The number of RGBA pixels per draw item.\nconst int valuesPerSurfaceTocItem = 9;\nconst int bytesPerValue = 4; // 32 bit floats\n\n// Before enabling this, enable the 2nd vertex attribute (drawItemTexAddr)\n// in the Draw shader and in the GLDrawSet, and in the GLCADAssetWorker\n#define CALC_GLOBAL_XFO_DURING_DRAW\n#ifdef CALC_GLOBAL_XFO_DURING_DRAW\n\nmat4 getCADBodyMatrix(int cadBodyId) {\n  vec3 body_tr = getCADBodyPixel(cadBodyId, 2).rgb;\n  vec4 body_ori = normalize(getCADBodyPixel(cadBodyId, 3));\n  vec3 body_sc = getCADBodyPixel(cadBodyId, 4).rgb;\n  Xfo bodyXfo = Xfo(body_tr, body_ori, body_sc);\n  return xfo_toMat4(bodyXfo);\n  // return mat4(1.0);\n}\n\nuniform sampler2D bodyDescTexture;\nuniform ivec2 bodyDescTextureSize;\n\nGLSLBinReader setupBodyDescReader(ivec2 bodyDescAddr) {\n  GLSLBinReader bodyDescReader;\n  ivec4 region = ivec4(0, 0, bodyDescTextureSize.x, bodyDescTextureSize.y);\n  ivec2 start = ivec2(bodyDescAddr.x, bodyDescAddr.y);\n  GLSLBinReader_init(bodyDescReader, bodyDescTextureSize, region, start, 32);\n  return bodyDescReader;\n}\n\nXfo getDrawItemXfo(ivec2 bodyDescAddr, int drawItemIndexInBody) {\n  GLSLBinReader bodyDescReader = setupBodyDescReader(bodyDescAddr);\n  \n  // Skip over the bbox, numSurfaces and then to the current surface data.  \n  #ifdef ENABLE_BODY_EDGES\n  int offsetOfItemRef = (6/*bbox*/) + (1/*numSurfaces*/) + (1/*numCurves*/) + (drawItemIndexInBody * (1/*id*/ + 10/*xfo*/));\n  #else\n  int offsetOfItemRef = (6/*bbox*/) + (1/*numSurfaces*/) + (drawItemIndexInBody * (1/*id*/ + 10/*xfo*/));\n  #endif\n  #ifdef ENABLE_PER_FACE_COLORS\n  offsetOfItemRef += drawItemIndexInBody * 4/*color*/; // Skip over the color.\n  #endif\n  \n  vec3 surface_tr = vec3(\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+1),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+2),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+3)\n    );\n\n  vec4 surface_ori = normalize(vec4(\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+4),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+5),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+6),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+7)\n    ));\n\n  vec3 surface_sc = vec3(\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+8),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+9),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+10)\n  );\n\n  Xfo surfaceXfo = Xfo(surface_tr, surface_ori, surface_sc);\n  return surfaceXfo;\n\n}\nmat4 getDrawItemMatrix(ivec2 bodyDescAddr, int drawItemIndexInBody) {\n  return xfo_toMat4(getDrawItemXfo(bodyDescAddr, drawItemIndexInBody));\n  // return mat4(1.0);\n}\n\n#else // CALC_GLOBAL_XFO_DURING_DRAW\n\nuniform sampler2D drawItemsTexture;\nuniform ivec2 vert_drawItemsTextureSize;\n\n// The Draw Items texture is laid out with 8 pixels per draw item.\nvec4 getDrawItemData(int offset) {\n  return fetchTexel(drawItemsTexture, vert_drawItemsTextureSize, ivec2(ftoi(drawItemTexAddr.x) + offset, ftoi(drawItemTexAddr.y)));\n}\n\nmat4 getModelMatrix() {\n  // Unpack 3 x 4 matix columns into a 4 x 4 matrix.\n  vec4 col0 = getDrawItemData(0);\n  vec4 col1 = getDrawItemData(1);\n  vec4 col2 = getDrawItemData(2);\n  mat4 result = mat4(col0, col1, col2, vec4(0.0, 0.0, 0.0, 1.0));\n  return transpose(result);\n}\n\n#endif // CALC_GLOBAL_XFO_DURING_DRAW\n\n  '),t.shaderLibrary.setShaderModule("GLSLCADSurfaceDrawing.vertexShader.glsl",'\n  \n<%include file="GLSLCADGeomDrawing.vertexShader.glsl"/>\n\n\n// GEOM\nuniform sampler2D surfaceAtlasLayoutTexture;\nuniform ivec2 surfaceAtlasLayoutTextureSize;\n\nuniform sampler2D surfacesAtlasTexture;\nuniform ivec2 surfacesAtlasTextureSize;\nuniform sampler2D normalsTexture;\n\nvec4 getSurfaceVertex(vec2 surfacePatchCoords, vec2 vertexCoord) {\n  return fetchTexel(surfacesAtlasTexture, surfacesAtlasTextureSize, ivec2(ftoi(surfacePatchCoords.x + vertexCoord.x), ftoi(surfacePatchCoords.y + vertexCoord.y)));\n}\n\nvec3 getSurfaceNormal(vec2 surfacePatchCoords, vec2 vertexCoord) {\n  return fetchTexel(normalsTexture, surfacesAtlasTextureSize, ivec2(ftoi(surfacePatchCoords.x + vertexCoord.x), ftoi(surfacePatchCoords.y + vertexCoord.y))).rgb;\n}\n\n'),t.shaderLibrary.setShaderModule("GLSLCADGeomDrawing.fragmentShader.glsl",'\n  uniform sampler2D cadBodiesTexture;\n  uniform int cadBodiesTextureSize_frag;\n  \n  vec4 getCADBodyPixel(int cadBodyId, int pixelOffset) {\n    \n    int offset = cadBodyId * pixelsPerCADBody;\n    ivec2 start;\n    start.y += offset / cadBodiesTextureSize_frag;\n    start.x = imod(offset, cadBodiesTextureSize_frag);\n  \n    return fetchTexel(cadBodiesTexture, ivec2(cadBodiesTextureSize_frag), ivec2(start.x + pixelOffset, start.y));\n  }\n  \n  // Is this still used?\n  uniform sampler2D drawItemsTexture;\n  uniform ivec2 frag_drawItemsTextureSize;\n  // The Draw Items texture is laid out with 8 pixels per draw item.\n  vec4 getDrawItemData(int offset) {\n    return fetchTexel(drawItemsTexture, frag_drawItemsTextureSize, ivec2(ftoi(v_drawCoords.x) + offset, ftoi(v_drawCoords.y)));\n  }\n  \n  \n\n//////////////////////////////////////////////\n// Cutaways\n\n<%include file="cutaways.glsl"/>\n\n// bool applyCutaway(int cadBodyId, int flags) {\n//   if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\n//     vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\n//     vec3 cutNormal = cadBodyPixel6.xyz;\n//     float cutPlaneDist = cadBodyPixel6.w;\n//     if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\n//         discard;\n//     }\n//     return true;\n//   }\n//   return false;\n// }\n\n// int applyCutaway(int flags, bool backFacing, vec3 cutColor, inout vec4 fragColor) {\n//   bool cut = testFlag(flags, BODY_FLAG_CUTAWAY);\n//   if(cut){\n//     if(cutaway(v_worldPos, cutNormal, planeDist)) {\n//       return 1;\n//     }\n//     if(backFacing){\n//       fragColor = vec4(cutColor, 1.0);\n//       return 2;\n//     }\n//   }\n//   return 0;\n// }\n  '),t.shaderLibrary.setShaderModule("GLSLCADSurfaceDrawing.fragmentShader.glsl",'\n  \n<%include file="GLSLCADGeomDrawing.fragmentShader.glsl"/>\n\n\nuniform sampler2D materialsTexture;\nuniform ivec2 materialsTextureSize;\n\nvec4 getMaterialValue(vec2 materialCoords, int valueIndex) {\n  return fetchTexel(materialsTexture, materialsTextureSize, ivec2(ftoi(materialCoords.x) + valueIndex, ftoi(materialCoords.y)));\n}\n\n\n//////////////////////////////////////////////\n// Surface Colors\n\nuniform sampler2D bodyDescTexture;\nuniform ivec2 bodyDescTextureSize_frag;\n\nGLSLBinReader setupBodyDescReader(ivec2 bodyDescAddr) {\n  GLSLBinReader bodyDescReader;\n  ivec4 region = ivec4(0, 0, bodyDescTextureSize_frag.x, bodyDescTextureSize_frag.y);\n  ivec2 start = ivec2(bodyDescAddr.x, bodyDescAddr.y);\n  GLSLBinReader_init(bodyDescReader, bodyDescTextureSize_frag, region, start, 32);\n  return bodyDescReader;\n}\n\nvec4 getDrawItemColor(ivec2 bodyDescAddr, int drawItemIndexInBody) {\n  GLSLBinReader bodyDescReader = setupBodyDescReader(bodyDescAddr);\n  \n  #ifdef ENABLE_BODY_EDGES\n  int offsetOfItemRef = (6/*bbox*/) + (1/*numSurfaces*/) + (1/*numCurves*/) + (drawItemIndexInBody * (1/*id*/ + 10/*xfo*/ + 4/*color*/));\n  #else\n  int offsetOfItemRef = (6/*bbox*/) + (1/*numSurfaces*/) + (drawItemIndexInBody * (1/*id*/ + 10/*xfo*/ + 4/*color*/));\n  #endif\n\n  vec4 color = vec4(\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+11),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+12),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+13),\n    GLSLBinReader_readFloat(bodyDescReader, bodyDescTexture, offsetOfItemRef+14)\n  );\n\n  return color;\n}\n\n//////////////////////////////////////////////\n// Trimming\nuniform sampler2D trimSetsAtlasLayoutTexture;\nuniform ivec2 trimSetsAtlasLayoutTextureSize;\n\nuniform sampler2D trimSetAtlasTexture;\nuniform ivec2 trimSetAtlasTextureSize;\n\nbool applyTrim(vec4 trimPatchQuad, inout vec3 trimCoords, int flags) {\n  if(trimPatchQuad.z > 0.0 && trimPatchQuad.w > 0.0){\n    // Remove cobwebs along borders.\n    // Tis appears to eliminate cobwebs along borders of trim sets. \n    // It does indicate that a math eror exists somewhere else\n    // that we would get cobwebs here.\n    // To repro, load Dead Eye Bearing and zoom out.\n    if (v_textureCoord.x < 0.0 || v_textureCoord.x >= 1.0 || v_textureCoord.y < 0.0 || v_textureCoord.y >= 1.0)\n      return true;\n\n    trimCoords.xy = trimPatchQuad.xy + (trimPatchQuad.zw * v_textureCoord);\n\n    vec2 trimUv = (trimCoords.xy) / vec2(trimSetAtlasTextureSize);\n    vec4 trimTexel = texture2D(trimSetAtlasTexture, trimUv);\n\n    trimCoords.z = max(trimTexel.r, trimTexel.g);\n    \n    if (trimTexel.r < 0.5 || trimTexel.g < 0.5) {\n      return true;\n    }\n    return false;\n  }\n  else {\n    // This is a non-trimmed surface, so return false.\n    trimCoords = vec3(-1.0);\n    return false;\n  }\n}\n\n\n');class q extends t.GLShader{constructor(e){super(e),this.stack=[{}]}setPreprocessorValue(e){this.getState()[e]=e}clearPreprocessorValue(e){delete this.getState()[e]}getState(){return this.stack[this.stack.length-1]}pushState(){this.stack.push(Object.assign({},this.getState()))}popState(){this.stack.pop(),this.applyOptions()}applyOptions(){const e=[...this.__gl.shaderopts.directives],t=this.getState();for(const r in t)e.push(t[r]);const r=e.join("\n")+"\n";this.__key=r,this.compileForTarget(this.__key,{directives:e})}bind(e){return super.bind(e,this.__key)}}class $ extends q{constructor(e){super(e),this.setShaderStage("VERTEX_SHADER",'\nprecision highp float;\n\nattribute vec3 positions;\ninstancedattribute vec4 drawCoords;  // (DrawItemData Coords (x, y) \n// instancedattribute vec2 drawItemTexAddr;  // Address of the data in the draw item texture. (mat4)\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform ivec2 quadDetail;\nuniform vec3 assetCentroid;\nuniform float normalLength;\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="stack-gl/inverse.glsl"/>\n\n<%include file="GLSLCADSurfaceDrawing.vertexShader.glsl"/>\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_textureCoord;\n\nvoid main(void) {\n    int cadBodyId = ftoi(drawCoords.r);\n    int drawItemIndexInBody = ftoi(drawCoords.g);\n    int surfaceId = ftoi(drawCoords.b);\n    int trimSetId = ftoi(drawCoords.a);\n\n    vec2 texCoords = positions.xy + 0.5;\n    \n    v_drawCoords = drawCoords;\n\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    vec4 cadBodyPixel1 = getCADBodyPixel(cadBodyId, 1);\n\n    // int bodyDescId = ftoi(cadBodyPixel0.r);\n    int cadBodyFlags = ftoi(cadBodyPixel0.g);\n    \n    //////////////////////////////////////////////\n    // Visibility\n    if(testFlag(cadBodyFlags, BODY_FLAG_INVISIBLE)) {\n        gl_Position = vec4(-3.0, -3.0, -3.0, 1.0);;\n        return;\n    }\n\n    //////////////////////////////////////////////\n    // Transforms\n#ifdef DEBUG_SURFACES\n    mat4 modelMatrix = mat4(1.0);\n    // if(v_surfaceType == SURFACE_TYPE_NURBS_SURFACE) {\n    //     // int drawItemIndexInBody = int(metadata.b+0.5);\n    //     int sideLen = int(ceil(sqrt(float(numSurfacesInLibrary))));\n    //     int x = drawItemIndexInBody % sideLen;\n    //     int y = drawItemIndexInBody / sideLen;\n    //     modelMatrix = mat4(1.0, 0.0, 0.0, 0.0, \n    //                     0.0, 1.0, 0.0, 0.0, \n    //                     0.0, 0.0, 1.0, 0.0,  \n    //                     float(x), float(y), 0.0, 1.0);\n    // }\n#else\n\n#ifdef CALC_GLOBAL_XFO_DURING_DRAW\n    mat4 bodyMat = getCADBodyMatrix(cadBodyId);\n    ivec2 bodyDescAddr = ftoi(cadBodyPixel0.ba);\n    mat4 surfaceMat = getDrawItemMatrix(bodyDescAddr, drawItemIndexInBody);\n    mat4 modelMatrix = bodyMat * surfaceMat;\n#else\n    mat4 modelMatrix = getModelMatrix();\n    // Note: on mobile GPUs, we get only FP16 math in the\n    // fragment shader, causing inaccuracies in modelMatrix\n    // calculation. By offsetting the data to the origin\n    // we calculate a modelMatrix in the asset space, and\n    //  then add it back on during final drawing.\n    // modelMatrix[3][0] += assetCentroid.x;\n    // modelMatrix[3][1] += assetCentroid.y;\n    // modelMatrix[3][2] += assetCentroid.z;\n#endif\n#endif\n    // modelMatrix = mat4(1.0);\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n    mat4 viewProjectionMatrix = projectionMatrix * viewMatrix;\n\n    //////////////////////////////////////////////\n    // Vertex Attributes\n    \n    GLSLBinReader surfaceLayoutDataReader;\n    GLSLBinReader_init(surfaceLayoutDataReader, surfaceAtlasLayoutTextureSize, 16);\n    vec4 surfaceDataAddr = GLSLBinReader_readVec4(surfaceLayoutDataReader, surfaceAtlasLayoutTexture, surfaceId * 8);\n    int surfaceFlags = GLSLBinReader_readInt(surfaceLayoutDataReader, surfaceAtlasLayoutTexture, surfaceId * 8 + 6);\n\n    bool isFan = int(quadDetail.y) == 0;\n    vec2 vertexCoords = texCoords * (isFan ? vec2(quadDetail) + vec2(1.0, 1.0) : vec2(quadDetail));\n\n    vec3 normal = getSurfaceNormal(surfaceDataAddr.xy, vertexCoords);\n    vec4 pos = vec4(getSurfaceVertex(surfaceDataAddr.xy, vertexCoords).rgb, 1.0);\n\n    bool flippedNormal = testFlag(surfaceFlags, SURFACE_FLAG_FLIPPED_NORMAL);\n    if(flippedNormal){\n        normal = -normal;\n    }\n  \n    vec4 worldPos = modelMatrix * pos;\n    vec3 worldNormal = normalize(mat3(modelMatrix) * normal);\n\n    // if (positions.z > 0.5)\n    //   worldPos = vec4(vec3(0.0), 1.0);\n    worldPos += vec4(worldNormal * positions.z * normalLength, 0.0);\n    \n    gl_Position = viewProjectionMatrix * worldPos;\n\n    \n    v_textureCoord = texCoords;\n    if(testFlag(surfaceFlags, SURFACE_FLAG_FLIPPED_UV))\n        v_textureCoord = vec2(v_textureCoord.y, v_textureCoord.x);\n\n    // v_textureCoord.y = 1.0 - v_textureCoord.y; // Flip y\n}'),this.setShaderStage("FRAGMENT_SHADER",'\nprecision highp float;\n\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="materialparams.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n\nuniform color BaseColor;\n\nuniform mat4 cameraMatrix;\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_textureCoord;\n\n<%include file="GLSLCADSurfaceDrawing.fragmentShader.glsl"/>\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n    int cadBodyId = int(floor(v_drawCoords.r + 0.5));\n    int drawItemIndexInBody = int(floor(v_drawCoords.g + 0.5));\n    int surfaceId = int(floor(v_drawCoords.b + 0.5));\n    int trimSetId = int(floor(v_drawCoords.a + 0.5));\n\n    // TODO: pass as varying from pixel shader.\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    int flags = int(floor(cadBodyPixel0.g + 0.5));\n            \n\n    //////////////////////////////////////////////\n    // Cutaways\n    if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\n        vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\n        vec3 cutNormal = cadBodyPixel6.xyz;\n        float cutPlaneDist = cadBodyPixel6.w;\n        if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\n            discard;\n        }\n    }\n\n    //////////////////////////////////////////////\n    // Trimming\n    vec4 trimPatchQuad;\n    vec3 trimCoords;\n    if(trimSetId >= 0) {\n        GLSLBinReader trimsetLayoutDataReader;\n        GLSLBinReader_init(trimsetLayoutDataReader, trimSetsAtlasLayoutTextureSize, 16);\n        trimPatchQuad = GLSLBinReader_readVec4(trimsetLayoutDataReader, trimSetsAtlasLayoutTexture, trimSetId*4);\n\n        if(applyTrim(trimPatchQuad, trimCoords, flags)){\n            discard;\n            return;\n        }\n    }\n\n    vec4 baseColor      = vec4(1.0,0.0,0.0,1.0);\n\n//#ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(baseColor.rgb);\n//#endif\n\n}\n'),this.nonSelectable=!0}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new Color(1,1,.5)}),e}}t.Registry.register("GLDrawCADSurfaceNormalsShader",$);const ee='\nprecision highp float;\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="stack-gl/inverse.glsl"/>\n\nattribute vec3 positions;\ninstancedattribute vec4 drawCoords;  // body ID, Surface index in Body, Surface Id, TrimSet Id\n// instancedattribute vec2 drawItemTexAddr;  // Address of the data in the draw item texture. (mat4)\n\nuniform mat4 viewMatrix;\nuniform mat4 cameraMatrix;\nuniform mat4 projectionMatrix;\nuniform ivec2 quadDetail;\nuniform vec3 assetCentroid;\n\n// #define DEBUG_SURFACES\nuniform int numSurfacesInLibrary;\n\n\n<%include file="GLSLCADSurfaceDrawing.vertexShader.glsl"/>\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_textureCoord;\nvarying vec3 v_bodyDescAddr;\nvarying float v_surfaceType;\nvarying vec2 v_quadDetail;\n\nvoid main(void) {\n    int cadBodyId = ftoi(drawCoords.r);\n    int drawItemIndexInBody = ftoi(drawCoords.g);\n    int surfaceId = ftoi(drawCoords.b);\n    int trimSetId = ftoi(drawCoords.a);\n\n    vec2 texCoords = positions.xy + 0.5;\n    \n    v_drawCoords = drawCoords;\n\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    vec4 cadBodyPixel1 = getCADBodyPixel(cadBodyId, 1);\n\n    // int bodyDescId = ftoi(cadBodyPixel0.r);\n    int cadBodyFlags = ftoi(cadBodyPixel0.g);\n    \n    //////////////////////////////////////////////\n    // Visibility\n    if(testFlag(cadBodyFlags, BODY_FLAG_INVISIBLE)) {\n        gl_Position = vec4(-3.0, -3.0, -3.0, 1.0);;\n        return;\n    }\n\n    //////////////////////////////////////////////\n    // Transforms\n#ifdef DEBUG_SURFACES\n    mat4 modelMatrix = mat4(1.0);\n    // if(v_surfaceType == SURFACE_TYPE_NURBS_SURFACE) {\n    //     // int drawItemIndexInBody = int(metadata.b+0.5);\n    //     int sideLen = int(ceil(sqrt(float(numSurfacesInLibrary))));\n    //     int x = drawItemIndexInBody % sideLen;\n    //     int y = drawItemIndexInBody / sideLen;\n    //     modelMatrix = mat4(1.0, 0.0, 0.0, 0.0, \n    //                     0.0, 1.0, 0.0, 0.0, \n    //                     0.0, 0.0, 1.0, 0.0,  \n    //                     float(x), float(y), 0.0, 1.0);\n    // }\n#else\n\n#ifdef CALC_GLOBAL_XFO_DURING_DRAW\n    mat4 bodyMat = getCADBodyMatrix(cadBodyId);\n    ivec2 bodyDescAddr = ftoi(cadBodyPixel0.ba);\n    v_bodyDescAddr.xy = vec2(float(bodyDescAddr.x), float(bodyDescAddr.y));\n    v_bodyDescAddr.z = float(drawItemIndexInBody);\n    mat4 surfaceMat = getDrawItemMatrix(bodyDescAddr, drawItemIndexInBody);\n    mat4 modelMatrix = bodyMat * surfaceMat;\n#else\n    mat4 modelMatrix = getModelMatrix();\n    // Note: on mobile GPUs, we get only FP16 math in the\n    // fragment shader, causing inaccuracies in modelMatrix\n    // calculation. By offsetting the data to the origin\n    // we calculate a modelMatrix in the asset space, and\n    //  then add it back on during final drawing.\n    // modelMatrix[3][0] += assetCentroid.x;\n    // modelMatrix[3][1] += assetCentroid.y;\n    // modelMatrix[3][2] += assetCentroid.z;\n#endif\n#endif\n    // modelMatrix = mat4(1.0);\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n    mat3 normalMatrix = mat3(transpose(inverse(modelViewMatrix)));\n\n    //////////////////////////////////////////////\n    // Vertex Attributes\n    \n    GLSLBinReader surfaceLayoutDataReader;\n    GLSLBinReader_init(surfaceLayoutDataReader, surfaceAtlasLayoutTextureSize, 16);\n    vec4 surfaceDataAddr = GLSLBinReader_readVec4(surfaceLayoutDataReader, surfaceAtlasLayoutTexture, surfaceId * 8);\n    int surfaceFlags = GLSLBinReader_readInt(surfaceLayoutDataReader, surfaceAtlasLayoutTexture, surfaceId * 8 + 6);\n\n    bool isFan = int(quadDetail.y) == 0;\n    vec2 vertexCoords = texCoords * (isFan ? vec2(quadDetail) + vec2(1.0, 1.0) : vec2(quadDetail));\n    vec4 surfaceVertex = getSurfaceVertex(surfaceDataAddr.xy, vertexCoords);\n    v_surfaceType = surfaceVertex.a;\n    vec3 normal  = getSurfaceNormal(surfaceDataAddr.xy, vertexCoords);\n    vec4 pos     = vec4(surfaceVertex.rgb, 1.0);\n    \n    bool flippedNormal = testFlag(surfaceFlags, SURFACE_FLAG_FLIPPED_NORMAL);\n    if(flippedNormal)\n        normal = -normal;\n\n    vec4 viewPos = modelViewMatrix * pos;\n    v_viewPos    = viewPos.xyz;\n    v_worldPos   = (modelMatrix * pos).xyz;\n    gl_Position  = projectionMatrix * viewPos;\n    v_viewNormal = normalMatrix * normal;\n\n    v_quadDetail = vec2(quadDetail);\n\n    {\n        // Pull back facing vertices towards us ever so slightly...\n        // This is to avoid z-fighting that occurs wehn we see the inside\n        // of a surface that is resting on another surface.\n        vec3 worldNormal = normalize(mat3(cameraMatrix) * v_viewNormal);\n\n        vec3 viewVector = normalize(mat3(cameraMatrix) * normalize(-v_viewPos));\n        float ndotv = dot(worldNormal, viewVector);\n        bool backFacing = ndotv <= 0.0;\n        if (backFacing) {\n            // Pull backfacing vertices towards us ever so slightly...\n            gl_Position.z *= 0.99999;\n        }\n    }\n\n    if(isFan) {\n        // We are drawing a Fan surface, so the uv coords\n        // simply come from the vertex positions.\n        v_textureCoord = positions.xy;\n    }\n    else {\n        v_textureCoord = texCoords;\n        if(testFlag(surfaceFlags, SURFACE_FLAG_FLIPPED_UV)) {\n            v_textureCoord = vec2(v_textureCoord.y, v_textureCoord.x);\n            v_quadDetail = vec2(v_quadDetail.y, v_quadDetail.x);\n        }\n\n        // v_textureCoord.y = 1.0 - v_textureCoord.y; // Flip y\n    }\n}';t.Registry.register("GLDrawCADSurfaceShader",class extends q{constructor(e){super(e),this.setShaderStage("VERTEX_SHADER",ee),this.setShaderStage("FRAGMENT_SHADER",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="materialparams.glsl"/>\n<%include file="GGX_Specular.glsl"/>\n<%include file="PBRSurfaceRadiance.glsl"/>\n\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n\nuniform mat4 cameraMatrix;\n\nuniform bool headLighting;\nuniform bool displayWireframes;\nuniform bool displayEdges;\n\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\nuniform float exposure;\n#endif\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_textureCoord;\nvarying vec3 v_bodyDescAddr;\nvarying float v_surfaceType;\nvarying vec2 v_quadDetail;\n\nvec3 getDebugColor(int id){\n    \n    int sel = int(round(mod(float(id), 14.0)));\n    \n    if(sel==0)\n        return vec3(0.0, 1.0, 1.0);\n    else if (sel==1)\n        return vec3(0.0, 1.0, 0.0);\n    else if (sel==2)\n        return vec3(1.0, 0.0, 1.0);\n    else if (sel==3)\n        return vec3(0.75, 0.75, 0.0);\n    else if (sel==4)\n        return vec3(0.0, 0.75, 0.75);\n    else if (sel==5)\n        return vec3(0.75, 0.0, 0.75);\n    else if (sel==6)\n        return vec3(0.45, 0.95, 0.0);\n    else if (sel==7)\n        return vec3(0.0, 0.45, 0.95);\n    else if (sel==8)\n        return vec3(0.95, 0.0, 0.45);\n    else if (sel==9)\n        return vec3(0.95, 0.45, 0.0);\n    else if (sel==10)\n        return vec3(0.0, 0.95, 0.45);\n    else if (sel==11)\n        return vec3(0.45, 0.0, 0.95);\n    else if (sel==12)\n        return vec3(0.45, 0.45, 0.95);\n    else if (sel==13)\n        return vec3(0.0, 0.0, 0.45);\n    else if (sel==14)\n        return vec3(0.0, 0.45, 0.45);\n    else if (sel==15)\n        return vec3(0.45, 0.0, 0.45);\n    else return vec3(0.2, 0.2, 0.2);\n}\n\n<%include file="GLSLCADSurfaceDrawing.fragmentShader.glsl"/>\n\n// const float gridSize = 0.02;\nconst float gridSize = 0.2;\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n    \n    int cadBodyId = int(floor(v_drawCoords.r + 0.5));\n    int drawItemIndexInBody = int(floor(v_drawCoords.g + 0.5));\n    int surfaceId = int(floor(v_drawCoords.b + 0.5));\n    int trimSetId = int(floor(v_drawCoords.a + 0.5));\n\n\n    // TODO: pass as varying from pixel shader.\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    vec4 cadBodyPixel1 = getCADBodyPixel(cadBodyId, 1);\n\n    int flags = int(floor(cadBodyPixel0.g + 0.5));\n    vec2 materialCoords = cadBodyPixel1.xy;\n    //////////////////////////////////////////////\n    // Trimming\n    vec4 trimPatchQuad;\n    vec3 trimCoords;\n    if(trimSetId >= 0) {\n        GLSLBinReader trimsetLayoutDataReader;\n        GLSLBinReader_init(trimsetLayoutDataReader, trimSetsAtlasLayoutTextureSize, 16);\n        trimPatchQuad = GLSLBinReader_readVec4(trimsetLayoutDataReader, trimSetsAtlasLayoutTexture, trimSetId*4);\n\n        if(applyTrim(trimPatchQuad, trimCoords, flags)){\n            discard;\n            return;\n        }\n    }\n\n    ///////////////////////////////////////////\n    // Normal\n\n    vec3 normal = normalize(mat3(cameraMatrix) * v_viewNormal);\n    vec3 viewNormal = normalize(v_viewNormal);\n\n    vec3 viewVector = normalize(mat3(cameraMatrix) * normalize(-v_viewPos));\n    bool backFacing = dot(normal, viewVector) <= 0.0;\n    if(backFacing){\n        normal = -normal;\n        viewNormal = -viewNormal;\n    }\n\n    //////////////////////////////////////////////\n    // Material\n\n    vec4 matValue0 = getMaterialValue(materialCoords, 0);\n\n    MaterialParams material;\n\n    /////////////////\n    bool clayRendering = false;\n    \n    material.baseColor             = matValue0.rgb;\n    material.opacity               = matValue0.a;\n    \n    /////////////////\n    // Face color\n#ifdef ENABLE_PER_FACE_COLORS\n    vec4 faceColor = getDrawItemColor(ftoi(v_bodyDescAddr.xy), ftoi(v_bodyDescAddr.z));\n    material.baseColor = mix(material.baseColor, faceColor.rgb, faceColor.a);\n#endif\n\n    if(clayRendering) {\n        material.baseColor          = vec3(0.45, 0.26, 0.13);\n        material.opacity            = 1.0;\n    } \n\n    //////////////////////////////////////////////\n    // Cutaways\n    // if (applyCutaway(cadBodyId, flags)) {\n    //     discard;\n    //     return;\n    // }\n    if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\n        vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\n        vec3 cutNormal = normalize(cadBodyPixel6.xyz);\n        float cutPlaneDist = cadBodyPixel6.w;\n        if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\n            discard;\n            return;\n        }\n        // If we are not cutaway, but we can see a back facing face\n        // then set the normal to the cut plane do the lighting is flat.\n        if (backFacing){\n            normal = cutNormal;\n        }\n    }\n\n    /////////////////\n    // Debug backFacing\n    // if(backFacing) {\n    //     material.baseColor = mix(material.baseColor, vec3(1.0, 0.0, 0.0), 0.5);\n    // }\n\n    /////////////////\n    // Debug materialId\n#ifdef DEBUG_MATERIALID\n    {\n        material.baseColor = vec3(float(int(materialCoords.x) % 5)/5.0, float(int(materialCoords.y) % 5)/5.0, 0.0);\n    }\n#endif\n\n    /////////////////\n    // Debug bodyId\n#ifdef DEBUG_BODYID\n    {\n        material.baseColor       = getDebugColor(cadBodyId);\n    }\n#endif\n\n    /////////////////\n    // Debug drawItemIndexInBody\n#ifdef DEBUG_SURFACEID\n    {\n        material.baseColor       = getDebugColor(drawItemIndexInBody);\n    }\n#endif\n\n    /////////////////\n    // Debug surface Type\n#ifdef DEBUG_SURFACETYPE\n    {\n        material.baseColor       = getDebugColor(v_surfaceType);\n    }\n#endif\n\n    /////////////////\n    // bool flippedNormal = testFlag(flags, SURFACE_FLAG_FLIPPED_NORMAL);\n    // if(flippedNormal) {\n    //    material.baseColor = mix(material.baseColor, vec3(1,0,0), 0.75);\n    // }\n\n    // if (backFacing) {\n    //     material.baseColor = mix(material.baseColor, vec3(1,0,0), 0.75);\n    // }\n\n    /////////////////\n    // Debug UV layout.\n    // {\n    //     material.baseColor = vec3(v_textureCoord.x);\n    //     // material.baseColor.r = mix(0.0, 1.0, v_textureCoord.x);\n    //     // material.baseColor.g = mix(0.0, 1.0, v_textureCoord.y);\n    // }\n\n    /////////////////\n    // if(testFlag(flags, SURFACE_FLAG_FLIPPED_UV)){\n    //     material.baseColor = mix(material.baseColor, vec3(1,1,1), 0.5);\n    // }\n\n    /////////////////\n    // if(v_quadDetail.x > 512.0 || v_quadDetail.y > 512.0){\n    //     material.baseColor = mix(material.baseColor, vec3(1,0,0), 0.75);\n    // } else {\n    //     // discard;\n    // }\n    \n    /////////////////\n    // Debug trim texture.\n#ifdef DEBUG_TRIMTEXELS\n    if(trimCoords.x >= 0.0) {\n        // trimCoords = (trimPatchQuad.xy + 0.5) + ((trimPatchQuad.zw - 0.5) * v_textureCoord);\n        trimCoords.xy = trimPatchQuad.xy + (trimPatchQuad.zw * v_textureCoord);\n        vec2 trimUv = (trimCoords.xy) / vec2(trimSetAtlasTextureSize);\n        vec4 trimTexel = texture2D(trimSetAtlasTexture, trimUv);\n\n        vec2 texelOffset = trimCoords.xy - (floor(trimCoords.xy) + 0.5);\n        float texelDist = length(texelOffset);\n        \n        material.baseColor = trimTexel.rgb * texelDist;\n\n        // if (trimTexel.r > 0.5 && trimTexel.g > 0.5) {\n        //     material.baseColor = vec3(0,0,0);\n        // }\n\n        // material.baseColor = mix(material.baseColor, vec3(0,0,0), texelDist);\n        // material.baseColor = mix(material.baseColor, vec3(0,0,0), trimCoords.z);\n        // material.baseColor = mix(material.baseColor, vec3(0,0,0), (trimCoords.z < 0.5) ? 1.0 : 0.0);\n\n        // if(trimCoords.z < 0.5) {\n        //     material.baseColor = mix(material.baseColor, vec3(0,0,0), 0.1);\n        // }\n        // else{\n        //     float total = floor(trimCoords.x) +\n        //                   floor(trimCoords.y);\n        //     if(mod(total,2.0)==0.0)\n        //         material.baseColor = mix(material.baseColor, vec3(0,0,0), 0.25);\n        //     else\n        //         material.baseColor = mix(material.baseColor, vec3(1,1,1), 0.25);\n        // }\n    }\n#endif\n\n\n    \n    //////////////////////////////////////////////\n    // Transparency\n    // Simple screen door transparency.\n    // float threshold = gridSize * opacity * (1.0 - (v_viewPos.z / 300.0));\n    // // if(mod(v_viewPos.x / v_viewPos.z, gridSize) > threshold || mod(v_viewPos.y/v_viewPos.z, gridSize) > threshold)// || mod(v_viewPos.z, gridSize) > threshold)\n    // if(mod(abs(v_worldPos.x), gridSize) > threshold || mod(abs(v_worldPos.y), gridSize) > threshold || mod(abs(v_worldPos.z), gridSize) > threshold)\n    //     discard;\n\n\n    ///////////////////////////////////////////\n    // Lighting\n    vec3 radiance;\n\n    vec4 matValue1;\n    if(clayRendering)\n        matValue1          = vec4(0.0, 0.9, 0.1, 0.0);\n    else\n        matValue1          = getMaterialValue(materialCoords, 1);\n\n    material.metallic       = matValue1.r;\n    material.roughness      = matValue1.g;\n    material.reflectance    = matValue1.b;\n    material.emission       = matValue1.a;\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n    fragColor = pbrSurfaceRadiance(material, normal, viewVector);\n\n    /////////////////////////////\n    // fragColor = vec4(material.baseColor, 1.0);\n    // fragColor = vec4( normalize(viewNormal), 1.0);\n    // fragColor = vec4( normalize(normal), 1.0);\n\n    // fragColor = vec4(sampleEnvMap(viewNormal, material.roughness), 1.0);;\n    \n    ////////////////////\n    {\n        // vec4 wireColor = vec4(0.1, 0.1, 0.1, 1.0);\n        //vec4 wireColor = vec4(0.6, 0.6, 0.6, 1.0);\n        vec4 wireColor = vec4(0.0, 0.0, 0.0, 1.0);\n        \n        vec2 vertexCoords = v_textureCoord * v_quadDetail;\n        vec2 vcD = fwidth(vertexCoords);\n        vec2 vcW = fract(vertexCoords);\n\n        bool isFan = v_quadDetail.y < 0.5;\n        if(displayWireframes) {\n            if (isFan) {\n\n            } else {\n        \n                float lerpVal = smoothstep(0.0, vcD.x, vcW.x) * smoothstep(1.0, 1.0 - vcD.x, vcW.x) * smoothstep(0.0, vcD.y, vcW.y) * smoothstep(1.0, 1.0 - vcD.y, vcW.y);\n                \n                // Display a thin line at 50% opacity.\n                fragColor = mix(fragColor, wireColor, (1.0-smoothstep(0.0, 0.5, lerpVal)) * 0.5 );\n        \n                //fragColor = mix(fragColor, wireColor, (mod(vertexCoords.x, 2.0) < 1.0) ? 0.5 : 0.0 );\n            }\n        }\n    }\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb * exposure);\n#endif\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n')}bind(e,t){super.bind(e,t);const r=this.__gl;e.envMap&&e.envMap.bind(e);const{exposure:a}=e.unifs;return a&&r.uniform1f(a.location,e.exposure),!0}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new t.Color(1,1,.5)}),e.push({name:"EmissiveStrength",defaultValue:0}),e.push({name:"Metallic",defaultValue:0}),e.push({name:"Roughness",defaultValue:.25}),e.push({name:"Normal",defaultValue:new t.Color(0,0,0)}),e.push({name:"TexCoordScale",defaultValue:1,texturable:!1}),e.push({name:"Reflectance",defaultValue:.025}),e}static getPackedMaterialData(e){const t=new Float32Array(8),r=e.getParameter("BaseColor").getValue();return t[0]=r.r,t[1]=r.g,t[2]=r.b,t[3]=r.a,e.getParameter("EmissiveStrength")?(t[4]=e.getParameter("Metallic").getValue(),t[5]=e.getParameter("Roughness").getValue(),t[6]=e.getParameter("Reflectance").getValue(),t[7]=e.getParameter("EmissiveStrength").getValue()):t[5]=1,t}});class te extends q{constructor(e){super(e),this.setShaderStage("VERTEX_SHADER",ee),this.setShaderStage("FRAGMENT_SHADER",'\nprecision highp float;\n\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n\nuniform int passIndex;\nuniform int assetIndex;\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_textureCoord;\nvarying float v_surfaceType;\nvarying vec2 v_quadDetail;\n\n<%include file="GLSLCADSurfaceDrawing.fragmentShader.glsl"/>\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n    int cadBodyId = int(floor(v_drawCoords.r + 0.5));\n    int surfaceIndexInBody = int(floor(v_drawCoords.g + 0.5));\n    int surfaceId = int(floor(v_drawCoords.b + 0.5));\n    int trimSetId = int(floor(v_drawCoords.a + 0.5));\n\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    int flags = int(floor(cadBodyPixel0.g + 0.5));\n\n    //////////////////////////////////////////////\n    // Cutaways\n    if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\n        vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\n        vec3 cutNormal = cadBodyPixel6.xyz;\n        float cutPlaneDist = cadBodyPixel6.w;\n        if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\n            discard;\n        }\n    }\n\n    //////////////////////////////////////////////\n    // Trimming\n    vec4 trimPatchQuad;\n    vec3 trimCoords;\n    if(trimSetId >= 0) {\n        GLSLBinReader trimsetLayoutDataReader;\n        GLSLBinReader_init(trimsetLayoutDataReader, trimSetsAtlasLayoutTextureSize, 16);\n        trimPatchQuad = GLSLBinReader_readVec4(trimsetLayoutDataReader, trimSetsAtlasLayoutTexture, trimSetId*4);\n\n        if(applyTrim(trimPatchQuad, trimCoords, flags)){\n            discard;\n            return;\n        }\n    }\n\n    float dist = length(v_viewPos);\n\n    int passAndAssetIndex = passIndex + (assetIndex * 64);\n\n    fragColor.r = float(passAndAssetIndex);\n    fragColor.g = float(cadBodyId);\n    fragColor.b = float(surfaceIndexInBody);\n    fragColor.a = dist;\n    \n    // fragColor.b = float(v_surfaceType);\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n'),this.nonSelectable=!0}}class re extends q{constructor(e){super(e),this.setShaderStage("VERTEX_SHADER",ee),this.setShaderStage("FRAGMENT_SHADER",'\nprecision highp float;\n\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLBinReader.glsl"/>\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\nvarying vec3 v_viewNormal;\nvarying vec2 v_textureCoord;\nvarying float v_surfaceType;\nvarying vec2 v_quadDetail;\n\n<%include file="GLSLCADSurfaceDrawing.fragmentShader.glsl"/>\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n    \n    int cadBodyId = int(floor(v_drawCoords.r + 0.5));\n    int surfaceIndexInBody = int(floor(v_drawCoords.g + 0.5));\n    int surfaceId = int(floor(v_drawCoords.b + 0.5));\n    int trimSetId = int(floor(v_drawCoords.a + 0.5));\n\n    // TODO: pass as varying from pixel shader.\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    int flags = int(floor(cadBodyPixel0.g + 0.5));\n            \n\n    //////////////////////////////////////////////\n    // Cutaways\n    if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\n        vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\n        vec3 cutNormal = cadBodyPixel6.xyz;\n        float cutPlaneDist = cadBodyPixel6.w;\n        if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\n            discard;\n        }\n    }\n\n    //////////////////////////////////////////////\n    // Trimming\n    vec4 trimPatchQuad;\n    vec3 trimCoords;\n    if(trimSetId >= 0) {\n        GLSLBinReader trimsetLayoutDataReader;\n        GLSLBinReader_init(trimsetLayoutDataReader, trimSetsAtlasLayoutTextureSize, 16);\n        trimPatchQuad = GLSLBinReader_readVec4(trimsetLayoutDataReader, trimSetsAtlasLayoutTexture, trimSetId*4);\n\n        if(applyTrim(trimPatchQuad, trimCoords, flags)){\n            discard;\n            return;\n        }\n    }\n    \n    vec4 highlightColor = getCADBodyPixel(cadBodyId, 5);\n    fragColor = highlightColor;\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n'),this.nonSelectable=!0}}t.Registry.register("GLDrawSelectedCADSurfaceShader",re);class ae extends q{constructor(e){super(e),this.setShaderStage("VERTEX_SHADER",'\nprecision highp float;\n\n<%include file="GLSLUtils.glsl"/>\n<%include file="GLSLCADConstants.glsl"/>\n<%include file="stack-gl/transpose.glsl"/>\n<%include file="stack-gl/inverse.glsl"/>\n\nattribute vec3 positions;\ninstancedattribute vec4 drawCoords;  // body ID, Surface index in Body, Surface Id, TrimSet Id\n// instancedattribute vec2 drawItemTexAddr;  // Address of the data in the draw item texture. (mat4)\n\nuniform mat4 viewMatrix;\nuniform mat4 cameraMatrix;\nuniform mat4 projectionMatrix;\nuniform int edgeDetail;\nuniform vec3 assetCentroid;\n\n\n// #define DEBUG_SURFACES\nuniform int numCurvesInLibrary;\n\n\n<%include file="GLSLCADGeomDrawing.vertexShader.glsl"/>\n\n// GEOM\nuniform sampler2D curvesAtlasLayoutTexture;\nuniform ivec2 curvesAtlasLayoutTextureSize;\n\n\nuniform sampler2D curvesAtlasTexture;\nuniform ivec2 curvesAtlasTextureSize;\n// uniform sampler2D normalsTexture;\n\nvec3 getCurveVertex(ivec2 addr, int vertexId) {\n  return fetchTexel(curvesAtlasTexture, curvesAtlasTextureSize, ivec2(addr.x + vertexId, addr.y)).rgb;\n}\n\n// vec3 getCurveTangent(vec2 surfacePatchCoords, vec2 vertexCoord) {\n//   return fetchTexel(normalsTexture, curvesAtlasTextureSize, ivec2(ftoi(surfacePatchCoords.x + vertexCoord.x), ftoi(surfacePatchCoords.y + vertexCoord.y))).rgb;\n// }\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\n\nvoid main(void) {\n    int cadBodyId = ftoi(drawCoords.r);\n    int drawItemIndexInBody = ftoi(drawCoords.g);\n    int curveId = ftoi(drawCoords.b);\n    int trimSetId = ftoi(drawCoords.a);\n    v_drawCoords = drawCoords;\n\n    vec2 texCoords = positions.xy;\n\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    vec4 cadBodyPixel1 = getCADBodyPixel(cadBodyId, 1);\n\n    // int bodyDescId = ftoi(cadBodyPixel0.r);\n    int flags = ftoi(cadBodyPixel0.g);\n\n    // vec4 metadata = getDrawItemData(0);\n    // ivec4 curveAtlasCoords = ftoi(getDrawItemData(2));\n    // int flags = int(floor(metadata.a + 0.5));\n\n    //////////////////////////////////////////////\n    // Visibility\n    if(testFlag(flags, BODY_FLAG_INVISIBLE)) {\n        gl_Position = vec4(-3.0, -3.0, -3.0, 1.0);;\n        return;\n    }\n\n    //////////////////////////////////////////////\n    // Transforms\n#ifdef DEBUG_SURFACES\n    mat4 modelMatrix = mat4(1.0);\n    int numCurvesInLibrary = 15;\n    // int sideLen = int(ceil(sqrt(float(numCurvesInLibrary))));\n    // int x = curveId % sideLen;\n    // int y = curveId / sideLen;\n    modelMatrix = mat4(1.0, 0.0, 0.0, 0.0, \n                    0.0, 1.0, 0.0, 0.0, \n                    0.0, 0.0, 1.0, 0.0,  \n                    float(curveId), float(0), 0.0, 1.0);\n#else\n\n#ifdef CALC_GLOBAL_XFO_DURING_DRAW\n    mat4 bodyMat = getCADBodyMatrix(cadBodyId);\n    ivec2 bodyDescAddr = ftoi(cadBodyPixel0.ba);\n    mat4 curveMat = getDrawItemMatrix(bodyDescAddr, drawItemIndexInBody);\n    mat4 modelMatrix = bodyMat * curveMat;\n\n    // v_sc = surfaceXfo.sc;\n    //if (v_sc.z > 0.0) {\n    //  gl_Position = vec4(-3.0, -3.0, -3.0, 1.0);;\n    //  return;\n    //}\n#else\n    mat4 modelMatrix = getModelMatrix();\n    // Note: on mobile GPUs, we get only FP16 math in the\n    // fragment shader, causing inaccuracies in modelMatrix\n    // calculation. By offsetting the data to the origin\n    // we calculate a modelMatrix in the asset space, and\n    //  then add it back on during final drawing.\n    // modelMatrix[3][0] += assetCentroid.x;\n    // modelMatrix[3][1] += assetCentroid.y;\n    // modelMatrix[3][2] += assetCentroid.z;\n#endif\n#endif\n    // modelMatrix = mat4(0.001, 0.0, 0.0, 0.0, \n    //   0.0, 0.001, 0.0, 0.0, \n    //   0.0, 0.0, 0.001, 0.0,  \n    //   0.0, 0.0, 0.0, 1.0);\n    mat4 modelViewMatrix = viewMatrix * modelMatrix;\n\n    //////////////////////////////////////////////\n    // Vertex Attributes\n    \n    GLSLBinReader curvesLayoutDataReader;\n    GLSLBinReader_init(curvesLayoutDataReader, curvesAtlasLayoutTextureSize, 16);\n    vec4 curveDataAddr = GLSLBinReader_readVec4(curvesLayoutDataReader, curvesAtlasLayoutTexture, curveId * 8);\n\n    int vertexId = int(positions.x * float(edgeDetail));\n    vec4 pos     = vec4(getCurveVertex(ftoi(curveDataAddr.xy), vertexId), 1.0);\n    // vec4 pos     = vec4(positions * float(edgeDetail), 1.0);\n\n    // if (vertexId == 0)\n    //   pos = vec4(vec3(0.0), 1.0);\n\n    vec4 viewPos = modelViewMatrix * pos;\n    v_viewPos    = viewPos.xyz;\n    v_worldPos   = (modelMatrix * pos).xyz;\n    gl_Position  = projectionMatrix * viewPos;\n\n    {\n        // Pull edge vertices towards us ever so slightly...\n        gl_Position.z *= 0.99999;\n    }\n}'),this.setShaderStage("FRAGMENT_SHADER",'\nprecision highp float;\n\n<%include file="math/constants.glsl"/>\n<%include file="GLSLUtils.glsl"/>\n<%include file="stack-gl/gamma.glsl"/>\n<%include file="materialparams.glsl"/>\n<%include file="GGX_Specular.glsl"/>\n<%include file="PBRSurfaceRadiance.glsl"/>\n\n<%include file="GLSLCADConstants.glsl"/>\n\nuniform mat4 cameraMatrix;\n\nuniform bool headLighting;\nuniform bool displayWireframes;\nuniform bool displayEdges;\nuniform vec4 edgeColor;\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\nuniform float exposure;\nuniform float gamma;\n#endif\n\nvarying vec4 v_drawCoords;\nvarying vec3 v_viewPos;\nvarying vec3 v_worldPos;\n\n<%include file="GLSLCADGeomDrawing.fragmentShader.glsl"/>\n\nvec3 getDebugColor(int id){\n    \n  int sel = int(round(mod(float(id), 14.0)));\n  \n  if(sel==0)\n      return vec3(0.0, 1.0, 1.0);\n  else if (sel==1)\n      return vec3(0.0, 1.0, 0.0);\n  else if (sel==2)\n      return vec3(1.0, 0.0, 1.0);\n  else if (sel==3)\n      return vec3(0.75, 0.75, 0.0);\n  else if (sel==4)\n      return vec3(0.0, 0.75, 0.75);\n  else if (sel==5)\n      return vec3(0.75, 0.0, 0.75);\n  else if (sel==6)\n      return vec3(0.45, 0.95, 0.0);\n  else if (sel==7)\n      return vec3(0.0, 0.45, 0.95);\n  else if (sel==8)\n      return vec3(0.95, 0.0, 0.45);\n  else if (sel==9)\n      return vec3(0.95, 0.45, 0.0);\n  else if (sel==10)\n      return vec3(0.0, 0.95, 0.45);\n  else if (sel==11)\n      return vec3(0.45, 0.0, 0.95);\n  else if (sel==12)\n      return vec3(0.45, 0.45, 0.95);\n  else if (sel==13)\n      return vec3(0.0, 0.0, 0.45);\n  else if (sel==14)\n      return vec3(0.0, 0.45, 0.45);\n  else if (sel==15)\n      return vec3(0.45, 0.0, 0.45);\n  else return vec3(0.2, 0.2, 0.2);\n}\n\n#ifdef ENABLE_ES3\nout vec4 fragColor;\n#endif\n\nvoid main(void) {\n\n#ifndef ENABLE_ES3\n    vec4 fragColor;\n#endif\n\n    int cadBodyId = int(floor(v_drawCoords.r + 0.5));\n    int drawItemIndexInBody = int(floor(v_drawCoords.g + 0.5));\n    int curveId = int(floor(v_drawCoords.b + 0.5));\n\n    // TODO: pass as varying from pixel shader.\n    vec4 cadBodyPixel0 = getCADBodyPixel(cadBodyId, 0);\n    int flags = int(floor(cadBodyPixel0.g + 0.5));\n            \n\n    //////////////////////////////////////////////\n    // Cutaways\n    if (testFlag(flags, BODY_FLAG_CUTAWAY)) {\n        vec4 cadBodyPixel6 = getCADBodyPixel(cadBodyId, 6);\n        vec3 cutNormal = cadBodyPixel6.xyz;\n        float cutPlaneDist = cadBodyPixel6.w;\n        if (cutaway(v_worldPos, cutNormal, cutPlaneDist)) {\n            discard;\n            return;\n        }\n    }\n\n    fragColor = edgeColor;\n\n    // fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    // if (v_sc.x < 0.0) {\n    //   fragColor.r = 1.0;\n    // }\n    // if (v_sc.y < 0.0) {\n    //   fragColor.g = 1.0;\n    // }\n    // if (v_sc.z < 0.0) {\n    //   fragColor.b = 1.0;\n    // }\n\n    /////////////////\n    // Debug drawItemIndexInBody\n    // {\n    //   fragColor.rgb = mix(vec3(1.,1.,1.), getDebugColor(drawItemIndexInBody), float(drawItemIndexInBody)/5.0);\n    // }\n\n#ifdef ENABLE_INLINE_GAMMACORRECTION\n    fragColor.rgb = toGamma(fragColor.rgb * exposure, gamma);\n#endif\n\n#ifndef ENABLE_ES3\n    gl_FragColor = fragColor;\n#endif\n}\n')}static getParamDeclarations(){const e=super.getParamDeclarations();return e.push({name:"BaseColor",defaultValue:new t.Color(1,1,.5)}),e.push({name:"EmissiveStrength",defaultValue:0}),e.push({name:"Metallic",defaultValue:0}),e.push({name:"Roughness",defaultValue:.25}),e.push({name:"Normal",defaultValue:new t.Color(0,0,0)}),e.push({name:"TexCoordScale",defaultValue:1,texturable:!1}),e.push({name:"Reflectance",defaultValue:.025}),e}static getPackedMaterialData(e){const t=new Float32Array(8),r=e.getParameter("BaseColor").getValue();return t[0]=r.r,t[1]=r.g,t[2]=r.b,t[3]=r.a,e.getParameter("EmissiveStrength")?(t[4]=e.getParameter("Metallic").getValue(),t[5]=e.getParameter("Roughness").getValue(),t[6]=e.getParameter("Reflectance").getValue(),t[7]=e.getParameter("EmissiveStrength").getValue()):t[5]=1,t}}class ne extends t.GLPass{constructor(e=!1){super(),this.debugMode=e,this.headLighting=!1,this.displayWireframes=!1,this.displaySurfaces=!0,this.__displayEdges=0,this.displayNormals=!1,this.normalLength=.002,this.debugTrimTex=!1,this.debugSurfaceAtlas=!1,this.debugAssetId=0,this.pbrEnabled=!1,this.__assets=[],this.__loadQueue=0,this.__numHighlightedGeoms=0,this.__shaderCount=2,this.__shaderKeys={},this.__shaderOptsStack=[{}],this.__profiling={numSurfaces:0,numSurfaceInstances:0,surfaceEvalTime:0,numBodies:0,numMaterials:0,numTriangles:0,numDrawSets:0}}get displayEdges(){return this.__displayEdges>0}set displayEdges(e){1==e?this.__displayEdges++:this.__displayEdges--,this.emit("updated")}init(e,r){super.init(e,r),this.__dataLoadStartTime=performance.now();const a=e.gl,n=new j(a);n.on("updated",()=>this.emit("updated")),"webgl2"!=a.name&&this.setShaderPreprocessorValue("#extension GL_OES_standard_derivatives : enable"),this.debugMode&&this.setShaderPreprocessorValue("#define DEBUG_MODE"),this.setShaderPreprocessorValue("#define ENABLE_TRIMMING"),this.setShaderPreprocessorValue("#define ENABLE_INLINE_GAMMACORRECTION"),this.__cadpassdata={debugMode:this.debugMode,assetCount:0,materialLibrary:n,glplanegeom:new t.GLMesh(a,new t.Plane(1,1,1,1)),maxTexSize:t.SystemDesc.gpuDesc.maxTextureSize,incHighlightedCount:this.incHighlightedCount.bind(this),decHighlightedCount:this.decHighlightedCount.bind(this),incDisplayEdges:()=>{this.__displayEdges++,this.emit("updated")},decDisplayEdges:()=>{this.__displayEdges--,this.emit("updated")},genShaderID:e=>{if("SimpleSurfaceShader"!=e&&"StandardSurfaceShader"!=e||(e="GLDrawCADSurfaceShader"),!(e in this.__shaderKeys)){const r=t.Registry.getBlueprint(e);if(!r||!r.getPackedMaterialData)return this.__cadpassdata.genShaderID("GLDrawCADSurfaceShader");const n=this.applyOptsToShader(t.Registry.constructClass(e,a)),s=this.__shaderCount;return this.__shaderKeys[e]={id:s,shader:n},this.__shaderCount++,s}return this.__shaderKeys[e].id}},this.__decrementLoadQueue=()=>{this.__loadQueue--,0==this.__loadQueue&&(this.__profiling.numTriangles=this.__profiling.numTriangles/1e6,this.emit("updated"))}}itemAddedToScene(e,t){if(e instanceof _){const r=e;return this.__loadQueue++,this.__cadpassdata.assetCount++,r.isLoaded()?r.getSurfaceLibrary().getNumSurfaces()>0?this.addCADAsset(r):this.__decrementLoadQueue():r.once("loaded",()=>{r.getSurfaceLibrary().getNumSurfaces()>0?this.addCADAsset(r):this.__decrementLoadQueue()}),t.continueInSubTree=!0,!0}return!1}itemRemovedFromScene(e,t){return e instanceof _&&(this.removeCADAsset(e),!0)}getShaderPreprocessorValue(e){return this.getShaderState()[e]}setShaderPreprocessorValue(e,t=!0){e.startsWith("#")||(e="#define "+e),this.getShaderState()[e]=e;for(const r in this.__shaderKeys){const a=this.__shaderKeys[r];a.shader.setPreprocessorValue&&(a.shader.setPreprocessorValue(e),t&&a.shader.applyOptions())}this.__drawSelectedCADSurfaceShader&&(this.__drawSelectedCADSurfaceShader.setPreprocessorValue(e),t&&this.__drawSelectedCADSurfaceShader.applyOptions()),this.__drawCADSurfaceGeomDataShader&&(this.__drawCADSurfaceGeomDataShader.setPreprocessorValue(e),t&&this.__drawCADSurfaceGeomDataShader.applyOptions()),this.__renderer&&this.__renderer.requestRedraw()}clearShaderPreprocessorValue(e,t=!0){delete this.getShaderState()[e];for(const r in this.__shaderKeys){const a=this.__shaderKeys[r];a.shader.clearPreprocessorValue&&(a.shader.clearPreprocessorValue(e),t&&a.shader.applyOptions())}this.__renderer&&this.__renderer.requestRedraw()}applyOptsToShader(e){if(e.setPreprocessorValue){const t=this.getShaderState();for(const r in t)e.setPreprocessorValue(r);e.applyOptions()}return e}getShaderState(){return this.__shaderOptsStack[this.__shaderOptsStack.length-1]}pushShaderState(){this.__shaderOptsStack.push(Object.assign({},this.getShaderState()));for(const e in this.__shaderKeys){const t=this.__shaderKeys[e];t.shader.pushState&&t.shader.pushState()}}popShaderState(){this.__shaderOptsStack.pop();for(const e in this.__shaderKeys){const t=this.__shaderKeys[e];t.shader.popState&&t.shader.popState()}}startPresenting(){"High"!=t.SystemDesc.deviceCategory&&this.pushShaderState()}stopPresenting(){"High"!=t.SystemDesc.deviceCategory&&this.popShaderState()}getCutPlaneNormalParam(){return this.__cutPlaneNormalParam}getCutPlaneDistParam(){return this.__cutDistParam}getCutPlaneColorParam(){return this.__cutPlaneColorParam}incHighlightedCount(e){this.__numHighlightedGeoms+=e}decHighlightedCount(e){this.__numHighlightedGeoms-=e}addCADAsset(e){this.__gl.finish();const t=this.__assets.length;0==t&&(this.__gpuLoadStartTime=performance.now()),e.getVersion().compare([0,0,26])>0&&this.setShaderPreprocessorValue("#define INTS_PACKED_AS_2FLOAT16"),e.getVersion().compare([0,0,29])>=0&&this.setShaderPreprocessorValue("#define ENABLE_PER_FACE_COLORS"),e.getVersion().compare([1,0,5])>=0&&this.setShaderPreprocessorValue("#define ENABLE_BODY_EDGES");const r=new J(this.__gl,t,e,this.__cadpassdata);r.once("loaded",e=>{this.__profiling.numSurfaces+=e.numSurfaces,this.__profiling.numSurfaceInstances+=e.numSurfaceInstances,this.__profiling.surfaceEvalTime+=e.surfaceEvalTime,this.__profiling.numBodies+=e.numBodies,this.__profiling.numMaterials+=e.numMaterials,this.__profiling.numTriangles+=e.numTriangles,this.__profiling.numDrawSets+=e.numDrawSets,this.__decrementLoadQueue()}),r.on("updated",()=>this.emit("updated")),this.__assets.push(r)}removeCADAsset(e){this.__assets=this.__assets.filter(t=>t.getCADAsset()!=e||(t.destroy(),!1)),this.emit("updated")}getGLCADAsset(e){return this.__assets[e]}draw(e){const r=this.__gl;if(0!=this.__profiling.numBodies){if(t.SystemDesc.isIOSDevice)throw new Error("The ZeaCAD cannot be supported on iOS due to no ability to render to a FLOAT framebuffer.");if(this.debugTrimTex&&this.__assets.length>this.debugAssetId&&this.__assets[this.debugAssetId].drawTrimSets(e),this.debugSurfaceAtlas)this.__assets.length>this.debugAssetId&&this.__assets[this.debugAssetId].drawSurfaceAtlas(e);else{if(this.displaySurfaces){!this.pbrEnabled&&e.envMap&&(this.setShaderPreprocessorValue("#define ENABLE_PBR"),this.pbrEnabled=!0),this.__cadpassdata.materialLibrary.needsUpload()&&this.__cadpassdata.materialLibrary.uploadMaterials();for(const t in this.__shaderKeys){const a=this.__shaderKeys[t];if(a.shader.bind(e),e.shaderId=a.id,!this.__cadpassdata.materialLibrary.bind(e))return!1;e.unifs.headLighting&&r.uniform1i(e.unifs.headLighting.location,this.headLighting),e.unifs.displayWireframes&&r.uniform1i(e.unifs.displayWireframes.location,this.displayWireframes);const n=e.boundTextures;for(const t of this.__assets)t.draw(e),e.boundTextures=n;a.shader.unbind(e)}}if(this.displayNormals){if(this.__drawCADSurfaceNormalsShader||(this.__drawCADSurfaceNormalsShader=this.applyOptsToShader(new $(r))),!this.__drawCADSurfaceNormalsShader.bind(e))return!1;r.uniform1f(e.unifs.normalLength.location,this.normalLength);const t=this.__shaderKeys.GLDrawCADSurfaceShader.id,a=e.boundTextures;for(const r of this.__assets)r.drawNormals(e,t),e.boundTextures=a}if(this.__displayEdges>0){if(this.__drawCADCurvesShader||(this.__drawCADCurvesShader=this.applyOptsToShader(new ae(r))),!this.__drawCADCurvesShader.bind(e))return!1;r.uniform4f(e.unifs.edgeColor.location,.1,.1,.1,1),r.enable(r.BLEND),r.blendEquation(r.FUNC_ADD),r.blendFunc(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA);const t=e.boundTextures;for(const r of this.__assets)r.drawEdges(e,0),e.boundTextures=t;r.disable(r.BLEND)}}}}drawHighlightedGeoms(e){if(0==this.__numHighlightedGeoms)return!1;const t=this.__gl;if(this.__drawSelectedCADSurfaceShader||(this.__drawSelectedCADSurfaceShader=this.applyOptsToShader(new re(t))),!this.__drawSelectedCADSurfaceShader.bind(e))return!1;for(const t of this.__assets)t.drawHighlightedGeoms(e)}drawGeomData(e){if(0==this.__profiling.numBodies)return;if(t.SystemDesc.isIOSDevice)throw new Error("The ZeaCAD cannot be supported on iOS due to no ability to render to a FLOAT framebuffer.");const r=this.__gl;if(this.__drawCADSurfaceGeomDataShader||(this.__drawCADSurfaceGeomDataShader=this.applyOptsToShader(new te(r))),!this.__drawCADSurfaceGeomDataShader.bind(e))return!1;r.disable(r.BLEND),r.disable(r.CULL_FACE),r.enable(r.DEPTH_TEST),r.depthFunc(r.LESS),r.depthMask(!0);const a=e.unifs.passIndex;a&&r.uniform1i(a.location,this.passIndex);for(const t in this.__shaderKeys){const r=this.__shaderKeys[t];if(!r.shader.nonSelectable){e.shaderId=r.id;for(const t of this.__assets)t.drawGeomData(e)}}}getGeomItemAndDist(e){const t=Math.round(e[0]/64),r=Math.round(e[1]),a=e[3];return{geomItem:this.__assets[t].getGeomItem(r),dist:a}}}e.BODY_FLAG_CUTAWAY=256,e.BODY_FLAG_INVISIBLE=512,e.CADAssembly=h,e.CADAsset=_,e.CADBody=c,e.CADCurveTypes=r,e.CADPart=f,e.CADSurfaceTypes=a,e.CURVE_FLAG_COST_IS_DETAIL=8,e.GLCADPass=ne,e.PMIItem=g,e.PMIView=p,e.SURFACE_FLAG_COST_IS_DETAIL_U=64,e.SURFACE_FLAG_COST_IS_DETAIL_V=128,e.SURFACE_FLAG_FLIPPED_NORMAL=16,e.SURFACE_FLAG_FLIPPED_UV=32,e.SURFACE_FLAG_PERIODIC_U=1,e.SURFACE_FLAG_PERIODIC_V=2,e.XRef=y,e.drawItemShaderAttribsStride=8,e.drawShaderAttribsStride=4,e.floatsPerSceneBody=2,e.geomLibraryHeaderSize=8,e.getCurveTypeName=n,e.getSurfaceTypeName=s,e.numValuesPerTrimSetCurveRef=14,e.pixelsPerDrawItem=3,e.valuesPerCurveLibraryLayoutItem=8,e.valuesPerCurveTocItem=8,e.valuesPerSurfaceLibraryLayoutItem=8,e.valuesPerSurfaceTocItem=9,Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.js.map
